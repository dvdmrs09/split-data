{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a self - signed x509 certificate for a common name and a ECDSAP256 key pair.", "response": "def x509_from_ecdsap256_key_pair(pub_key, priv_key, common_name):\n    \"\"\"\n    Creates a self-signed x509 certificate for a common name and\n    ECDSAP256 key pair.\n\n    :pub_key: an ECDSAP256PublicKey instance\n    :priv_key: an ECDSAP256PrivateKey instance\n    :common_name: an XTTIdentity instance\n    :returns: the certificate as a byte string\n    \"\"\"\n    cert_len = _lib.xtt_x509_certificate_length()\n    cert = _ffi.new('unsigned char[]', cert_len)\n    rc = _lib.xtt_x509_from_ecdsap256_keypair(pub_key.native,\n                                           priv_key.native,\n                                           common_name.native,\n                                           cert, len(cert))\n    if rc == RC.SUCCESS:\n        return _ffi.buffer(cert)[:]\n    else:\n        raise error_from_code(rc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the ASN. 1 encoding of a ECDSAP256 private ket.", "response": "def asn1_from_ecdsap256_private_key(priv_key, pub_key):\n    \"\"\"\n    Returns the ASN.1 encoding of a ECDSAP256 private ket.\n\n    :priv_key: an ECDSAP256PrivateKey instance\n    :returns: the ASN.1 encoding as a byte string\n    \"\"\"\n    encoded_len = _lib.xtt_asn1_private_key_length()\n    encoded = _ffi.new('unsigned char[]', encoded_len)\n    rc = _lib.xtt_asn1_from_ecdsap256_private_key(priv_key.native, pub_key.native, encoded, len(encoded))\n    if rc == RC.SUCCESS:\n        return _ffi.buffer(encoded)[:]\n    else:\n        raise error_from_code(rc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_size(image, size):\n        bits = size.split(\"x\")\n        if image.size[0] == 0 or image.size[1] == 0:\n            ratio = 1.0\n        else:\n            ratio = float(image.size[0]) / float(image.size[1])\n\n        if len(bits) == 1 or not bits[1]:\n            width = int(bits[0])\n            height = int(1 / ratio * width)\n        elif not bits[0]:\n            height = int(bits[1])\n            width = int(height * ratio)\n        else:\n            width, height = map(int, bits)\n        return width, height", "response": "Parse a size string into width height tuple."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef smart_fit(image, fit_to_width, fit_to_height):\n        im_width, im_height = image.size\n        out_width, out_height = fit_to_width, fit_to_height\n        if im_width == 0 or im_height == 0:\n            return (fit_to_width, fit_to_height)\n\n        w_scale = float(fit_to_width) / float(im_width)\n        h_scale = float(fit_to_height) / float(im_height)\n        if w_scale < h_scale:\n            scale = float(fit_to_width) / float(im_width)\n            out_height = int(round(scale * im_height))\n        else:\n            scale = float(fit_to_height) / float(im_height)\n            out_width = int(round(scale * im_width))\n\n        return out_width, out_height", "response": "Given an image fit it into the specified width and height."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef process(image, size, *args, **kwargs):\n        from autodetect import smart_crop\n        box_width, box_height = AutoCrop.parse_size(image, size)\n        scaled_size, rect = smart_crop(box_width, box_height, image.filename)\n        return image.resize(scaled_size, Image.ANTIALIAS).crop(tuple(rect))", "response": "Auto - crop the image based on image gravity face detection\n        Automatically crop the image based on image gravity and face detection\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_any_valid_version(self):  # type: () -> str\n        versions = self.all_current_versions()\n\n        if not versions and not self.force_init:\n            raise JiggleVersionException(\n                \"Have no versions to work with, failed to find any. Include --init to start out at 0.1.0\"\n            )\n\n        if not versions and self.force_init:\n            versions = {\"force_init\": \"0.1.0\"}\n\n        if len(versions) > 1:\n            if not self.all_versions_equal(versions):\n                if not self.all_versions_equal(versions):\n                    almost_same = self.almost_the_same_version(\n                        [x for x in versions.values()]\n                    )\n                    if almost_same:\n                        # TODO: disable with strict option\n                        logger.warning(\n                            \"Version very by a patch level, will use greater.\"\n                        )\n                        return unicode(almost_same)\n\n        if not versions.keys():\n            raise JiggleVersionException(\"Noooo! Must find a value\" + unicode(versions))\n        return unicode(first_value_in_dict(versions))", "response": "Find any valid version of the current version and return the first one."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef almost_the_same_version(\n        self, version_list\n    ):  # type: (List[str]) -> Optional[str]\n        \"\"\"\n        Are these versions different by a .1 patch level? This is crazy common in the wild.\n        :param version_list:\n        :return:\n        \"\"\"\n\n        version_list = list(set(version_list))\n        try:\n            sem_ver_list = list(\n                set([unicode(Version(x)) for x in version_list])\n            )  # type: List[Version]\n        except ValueError:\n            # I hope htat was a bad semver\n            return None\n\n        # should be good sem vers from here\n        if len(sem_ver_list) == 2:\n            if (\n                sem_ver_list[0] == unicode(Version(sem_ver_list[1]).next_patch())\n                or unicode(Version(sem_ver_list[0]).next_patch()) == sem_ver_list[1]\n            ):\n                if sem_ver_list[0] > sem_ver_list[1]:\n                    return unicode(sem_ver_list[0])\n                return unicode(sem_ver_list[1])\n        return None", "response": "Return the most common version of the current version."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if all current versions are valid sem ver?", "response": "def validate_current_versions(self):  # type: () -> bool\n        \"\"\"\n        Can a version be found? Are all versions currently the same? Are they valid sem ver?\n        :return:\n        \"\"\"\n        versions = self.all_current_versions()\n        for _, version in versions.items():\n            if \"Invalid Semantic Version\" in version:\n                logger.error(\n                    \"Invalid versions, can't compare them, can't determine if in sync\"\n                )\n                return False\n\n        if not versions:\n            logger.warning(\"Found no versions, will use default 0.1.0\")\n            return True\n\n        if not self.all_versions_equal(versions):\n            if self.almost_the_same_version([x for x in versions.values()]):\n                # TODO: disable with strict option\n                logger.warning(\"Version very by a patch level, will use greater.\")\n                return True\n            logger.error(\"Found various versions, how can we rationally pick?\")\n            logger.error(unicode(versions))\n            return False\n\n        for _ in versions:\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nversioning by ast evaluation. Didn t find more versions that existing methods .", "response": "def version_by_eval(self, file_path):  # type: (str) ->Dict[str,str]\n        \"\"\"\n        Version by ast evaluation. Didn't find more versions that existing methods\n        :param file_path:\n        :return:\n        \"\"\"\n        source = self.file_opener.read_this(file_path)\n        sb = \"{\"\n        for line in source.split(\"\\n\"):\n            if \"=\" in line:\n                parts = line.split(\"=\")\n                sb += \"'\" + parts[0] + \"':\" + parts[1]\n        sb += \"}\"\n        if sb == \"{}\":\n            return {}\n        try:\n            thing = ast.literal_eval(sb)\n        except:\n            return {}\n        for version_token in dunder_version.version_tokens:\n            if version_token in thing:\n                return {\"literal_eval\": thing[version_token]}\n        return {}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a dictionary of version and module import", "response": "def version_by_import(self, module_name):  # type: (str) ->Dict[str,str]\n        \"\"\"\n        This is slow & if running against random code, dangerous\n\n        Sometimes apps call exit() in import if conditions not met.\n        :param module_name:\n        :return:\n        \"\"\"\n        if not module_name:\n            return {}\n        try:\n            module = __import__(module_name)\n        except ModuleNotFoundError:\n            # hypothetical module would have to be on python path or execution folder, I think.\n            return {}\n        except FileNotFoundError:\n            return {}\n\n        if hasattr(module, \"__version__\"):\n            version = module.__version__\n            return {\"module import\": version}\n        return {}"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef all_current_versions(self):  # type: () ->Dict[str,str]\n        if self.PROJECT is None:\n            raise TypeError(\"self.PROJECT missing, can't continue\")\n\n        versions = {}  # type: Dict[str,str]\n        files_to_check = [x for x in self.file_inventory.source_files]\n        files_to_check.append(self.PROJECT + \".py\")  # is this the 'central' module?\n        for file in self.file_inventory.source_files:\n\n            if not os.path.isfile(file):\n                continue\n            vers = self.find_dunder_version_in_file(file)\n            if vers:\n                versions = merge_two_dicts(versions, vers)\n\n        for finder in [self.read_metadata, self.read_text, self.read_setup_py]:\n            more_vers = finder()\n            if more_vers:\n                versions = merge_two_dicts(versions, more_vers)\n\n        bad_versions, good_versions = self.kick_out_bad_versions(versions)\n\n        # get more versions here via risky routes\n        if not good_versions:\n            # desperate times, man...\n            for folder in [self.file_inventory.project_root, self.file_inventory.src]:\n                if not os.path.isdir(folder):\n                    print(os.listdir(\".\"))\n                    continue\n\n                if folder == \"\":\n                    folder = \".\"\n                for file in [x for x in os.listdir(folder) if x.endswith(\".py\")]:\n                    # not going to do the extensionsless py files, too slow.\n                    file_path = os.path.join(folder, file)\n                    if not os.path.isfile(file_path):\n                        continue\n                    vers = self.find_dunder_version_in_file(file_path)\n                    if vers:\n                        maybe_good = merge_two_dicts(good_versions, vers)\n\n                        more_bad_versions, good_versions = self.kick_out_bad_versions(\n                            maybe_good\n                        )\n\n        if not good_versions:\n            vers = self.execute_setup()\n            if vers:\n                try:\n                    for key, value in vers.items():\n                        _ = version_object_and_next(value)\n                except:\n                    print(vers)\n\n                maybe_good = merge_two_dicts(good_versions, vers)\n                more_bad_versions, good_versions = self.kick_out_bad_versions(\n                    maybe_good\n                )\n\n        # more_bad_versions, good_versions = self.kick_out_bad_versions(versions)\n        if not good_versions:\n            vers = self.version_by_import(self.PROJECT)\n            maybe_good = merge_two_dicts(good_versions, vers)\n            more_bad_versions, good_versions = self.kick_out_bad_versions(maybe_good)\n\n        # no new versions found!\n        # for file in self.file_inventory.source_files:\n        #\n        #     if not os.path.isfile(file):\n        #         continue\n        #     vers = self.version_by_eval(file)\n        #     maybe_good = merge_two_dicts(good_versions, vers)\n        #     more_bad_versions, good_versions = self.kick_out_bad_versions(\n        #         maybe_good\n        #     )\n\n        if bad_versions:\n            print(unicode(bad_versions))\n            logger.warning(unicode(bad_versions))\n        return good_versions", "response": "Return a dictionary of all the current versions of the current module."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nverifies that all the versions are the same.", "response": "def all_versions_equal(self, versions):  # type: (Dict[str,str]) -> bool\n        \"\"\"\n        Verify that all the versions are the same.\n        :param versions:\n        :return:\n        \"\"\"\n        if len(versions) <= 1:\n            return True\n\n        semver = None\n        for key, version in versions.items():\n            if semver is None:\n                try:\n                    semver, _, __ = version_object_and_next(version)\n                except ValueError:\n                    logger.error(\"Invalid version at:\" + unicode((key, version)))\n                    return False\n                continue\n            try:\n                version_as_version, _, __ = version_object_and_next(version)\n            except:\n                return False\n            if version_as_version != semver:\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_setup_py(self):  # type: ()-> Dict[str,str]\n        found = {}  # type: Dict[str,str]\n        setup_py = os.path.join(\"setup.py\")\n\n        if not os.path.isfile(setup_py):\n            if self.strict:\n                logger.debug(unicode(os.getcwd()))\n                logger.debug(unicode(os.listdir(os.getcwd())))\n                # return \"\"\n                # raise JiggleVersionException(\n                #     \"Can't find setup.py : {0}, path :{1}\".format(setup_py, self.SRC)\n                # )\n                return found\n            else:\n                return found\n\n        self.setup_py_source = self.file_opener.open_this(setup_py, \"r\").read()\n\n        if \"use_scm_version=True\" in self.setup_py_source:\n            die(\n                -1,\n                \"setup.py has use_scm_version=True in it- this means we expect no file to have a version string. Nothing to change\",\n            )\n            return {}\n\n        with self.file_opener.open_this(setup_py, \"r\") as infile:\n            for line in infile:\n                version = kwarg_version.find_in_line(line)\n                if version:\n                    found[setup_py] = version\n                    continue\n                version, _ = dunder_version.find_in_line(line)\n                if version:\n                    found[setup_py] = version\n                    continue\n\n        # stress testing\n        # if \"version\" in self.setup_py_source and not found:\n        #     raise TypeError(self.setup_py_source)\n\n        return found", "response": "Reads the setup. py file and returns a dict of the names of the version strings."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading the text of the ad - hoc version. txt file and return a dictionary of the text of the ad - hoc version. txt files.", "response": "def read_text(self):  # type: () ->Dict[str,str]\n        \"\"\"\n        Get version out of ad-hoc version.txt\n        :return:\n        \"\"\"\n        found = {}\n        for file in self.file_inventory.text_files:\n            if not os.path.isfile(file):\n                continue\n            with self.file_opener.open_this(file, \"r\") as infile:\n                text = infile.readline()\n            found[file] = text.strip(\" \\n\")\n        return found"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_metadata(self):  # type: () ->Dict[str,str]\n        config = configparser.ConfigParser()\n        config.read(self.file_inventory.config_files[0])\n        try:\n            return {\"setup.cfg\": config[\"metadata\"][\"version\"]}\n        except KeyError:\n            return {}", "response": "Read metadata from. ini or. cfg file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds __version__ in a source file", "response": "def find_dunder_version_in_file(self, full_path):  # type: (str)-> Dict[str,str]\n        \"\"\"\n        Find __version__ in a source file\n        :param full_path:\n        :return:\n        \"\"\"\n        versions = {}\n\n        with self.file_opener.open_this(full_path, \"r\") as infile:\n            for line in infile:\n                version, _ = dunder_version.find_in_line(line)\n                if version:\n                    versions[full_path] = version\n                version, _ = dunder_version.find_in_line(line)\n        return versions"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntake 1st version string found.", "response": "def version_to_write(self, found):  # type: (str) -> Version\n        \"\"\"\n        Take 1st version string found.\n        :param found: possible version string\n        :return:\n        \"\"\"\n        first = False\n        if self.version is None:\n            first = True\n            try:\n                self.current_version, self.version, self.schema = version_object_and_next(\n                    found.strip(\" \")\n                )\n            except:\n                raise JiggleVersionException(\"Shouldn't throw here.\")\n\n        if first:\n            logger.info(\n                \"Updating from version {0} to {1}\".format(\n                    unicode(self.version), unicode(self.version)\n                )\n            )\n        return self.version"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexecute python 3 setup. py and return a dict of the current version of the user s current version.", "response": "def execute_setup(self):  # type: () -> Dict[str,str]\n        \"\"\"\n        for really surprising things like a dict foo in setup(**foo)\n        consider python3 setup.py --version\n        :return:\n        \"\"\"\n\n        ver = execute_get_text(\"python setup.py --version\")\n        if not ver:\n            return None\n\n        if \"UserWarning\" in ver:\n            logger.warning(\n                \"python setup.py --version won't parse, got :\" + unicode(ver)\n            )\n            # UserWarning- Ther version specified ... is an invalid...\n            return {}\n\n        if ver:\n            string = unicode(ver).strip(\" \\n\")\n            if \"\\n\" in string:\n                string = string.split(\"\\n\")[0]\n\n            return {\"setup.py --version\": string.strip(\" \\n\")}\n        else:\n            return {}"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes an activegit repo.", "response": "def initrepo(repopath, bare, shared):\n    \"\"\" Initialize an activegit repo. \n    Default makes base shared repo that should be cloned for users \"\"\"\n\n    ag = activegit.ActiveGit(repopath, bare=bare, shared=shared)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clonerepo(barerepo, userrepo):\n\n    git.clone(barerepo, userrepo)\n    ag = activegit.ActiveGit(userrepo)", "response": "Clone a bare base repo to a user"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef example(script, explain, contents, requirements, output, outputfmt, details):\n    blank()\n    cprint(script.upper(), \"yellow\")\n    cprint(''.join([\"=\" for i in range(70)]) + '\\n', \"yellow\")\n\n    cprint(\"DETAILS\", \"blue\")\n    std(explain + '\\n')\n\n    cprint(requirements, \"red\")\n    cprint(output, \"green\")\n    blank()\n\n    if details != \"\":\n        std(details)\n        blank()\n\n    cprint(\"OUTPUT FORMAT\", \"blue\")\n    std(outputfmt)\n    blank()\n\n    cprint(\"EXAMPLES\", \"blue\")\n    for i in range(len(contents)):\n        pre, code, post = contents[i]\n        std(\"{}) {}\".format(i + 1, pre))\n        cprint(\"    \" + code, \"cyan\")\n        if post != \"\":\n            std('\\n' + post)\n        blank()", "response": "Prints the example help for the script."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning an object to use as entry point when calling registry. solve_resource on a root resource.", "response": "def EntryPoints(registry, **kwargs):\n    \"\"\"Returns an object to use as entry point when calling ``registry.solve_resource``.\n\n    When calling ``registry.solve_resource`` on a \"root\" resource, we don't have any value.\n    This function will create a object to use as a first value and is used to specify which\n    entry points are allowed at the first level of a dataql query.\n\n    Example\n    -------\n\n    >>> from datetime import date, timedelta\n    >>> registry = Registry()\n    >>> registry.register(date, ['strftime'])\n    >>> entry_points = EntryPoints(registry,\n    ...     today=date(2015, 6, 1),\n    ...     in_days=lambda days: date(2015, 6, 1)+timedelta(days=days))\n    >>> from dataql.resources import *\n    >>> resource = Field('today', filters=[\n    ...     Filter('today'),\n    ...     Filter('strftime', args=[PosArg('%F')]),\n    ... ])\n    >>> registry.solve_resource(entry_points, resource)\n    '2015-06-01'\n    >>> registry.solve_resource(entry_points, Field('tomorrow', filters=[\n    ...     Filter('in_days', args=[NamedArg('days', '=', 1)]),\n    ...     Filter('strftime', args=[PosArg('%F')]),\n    ... ]))\n    '2015-06-02'\n\n    Notes\n    -----\n    The name of this function is intentionally made to resemble a class, as it returns an instance\n    of a class named ``EntryPoints``.\n\n    \"\"\"\n\n    # We convert functions to staticmethod as they will be held by a class and\n    # we don't want them to expect a ``self`` or ``cls`` argument.\n    attrs = {k: (staticmethod(v) if isfunction(v) else v) for k, v in kwargs.items()}\n\n    klass = type('EntryPoints', (BaseEntryPoints, ), attrs)\n    registry.register(klass, kwargs.keys())\n    return klass()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef solve(self, value, args=None, kwargs=None):\n\n        # If we have a function, apply this, using the value as first argument,\n        # then args and kwargs.\n        if self.function:\n            try:\n                return self.function(value, *(args or []), **(kwargs or {}))\n            except Exception as ex:\n                raise CallableError(self, value, args, kwargs, ex)\n\n        # Manage a normal attribute.\n        try:\n            # try to get an attribute.\n            result = getattr(value, self.name)\n        except AttributeError:\n            try:\n                # Attribute not found, try to get a key.\n                result = value[self.name]\n            except (TypeError, KeyError):\n                # No attribute, no key.\n                raise AttributeNotFound(self)\n\n        # We make a call from the attribute in all cases if we have some arguments.\n        if args is not None or kwargs is not None:\n            result = result(*(args or []), **(kwargs or {}))\n\n        elif not isclass(result) and callable(result):\n            # We have no arguments, but the attribute is a callable, so, if it not a class,\n            # we'll try to call it, without arguments.\n            try:\n                result = result()\n\n            except Exception as ex:\n                # If an exception is raised during the call, we have two cases:\n                # - the \"thing\" called is a function or method, then we re-raise the exception\n                # - it's something else, like an instance of a class having a ``__call__`` method,\n                #   in this case we want to return the instance (if the user want the thing to be\n                #   called it could still use parentheses)\n                if isfunction(result) or ismethod(result):\n                    raise CallableError(self, value, args, kwargs, ex)\n\n        return result", "response": "Try to get the current attribute or function result for the given value."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef solve(self, value, attribute, args=None, kwargs=None):\n\n        if not isinstance(value, self.source) and (\n                not self.allow_class or value is not self.source):\n            raise NotSolvable(self, value)\n\n        attr = None\n        if attribute in self.attributes:\n            attr = self.attributes[attribute]\n        else:\n            for parent_source in self.parent_sources:\n                if attribute in parent_source.attributes:\n                    attr = parent_source.attributes[attribute]\n                    break\n\n            if attr is None:\n                raise AttributeNotFound(attribute, self)\n\n        try:\n            return attr.solve(value, args, kwargs)\n        except AttributeNotFound:\n            # Raise an ``AttributeError`` with ``self`` as source.\n            raise AttributeNotFound(attr, self)", "response": "Try to get the given attribute or function result for the given value instance."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register(self, source, attributes=None, allow_class=False, allow_subclasses=True,\n                 propagate_attributes=True, inherit_attributes=True):\n        \"\"\"Register a source class with its attributes.\n\n        Arguments\n        ---------\n        source : type\n            Must be a class for which we want to allow access to only the given attributes.\n        attributes : iterable[str] / Attributes, optional\n            A list (or other iterable) of string representing the names of the allowed\n            attributes from the source.\n            Can also be an ``Attributes`` instance.\n            To allow all attributes, you must pass an ``Attributes`` instance with\n            ``allow_all=True``.\n        allow_class : boolean, default ``False``\n            If set to ``True``, the source apply not only to instances of the source class, but\n            also to the class itself.\n        allow_subclasses : boolean, default ``True``\n                When ``True``, if an instance of a subclass is used without defined source, this\n                source will be used.\n        propagate_attributes : boolean, default ``True``\n            When ``True``, all the attributes of this source will be propagated to subclasses of\n            this source (except if the subclass has ``inherit_attributes`` set to ``False``.\n            When ``False``, subclasses will have to declare their own attributes.\n        inherit_attributes : boolean, default ``True``\n            When ``True``, if the source class has a parent class in the registry, it will inherits\n            its attributes if it has ``propagate_attributes`` set to ``True``.\n            When ``False``, it has to declare its own attributes\n\n        Raises\n        ------\n        dataql.solvers.exception.AlreadyRegistered\n            If the source class is already registered.\n\n        Example\n        -------\n\n        >>> from datetime import date\n        >>> d = date(2015, 6, 1)\n        >>> registry = Registry()\n        >>> registry.register(date, ['day', 'today'])\n        >>> registry.register(date, ['day']) # doctest: +ELLIPSIS\n        Traceback (most recent call last):\n        dataql.solvers.exceptions.AlreadyRegistered: The `datetime.date` source is already...\n        >>> registry[date].solve(d, 'day')\n        1\n        >>> registry[date].solve(date, 'today') # doctest: +ELLIPSIS\n        Traceback (most recent call last):\n        dataql.solvers.exceptions.NotSolvable: The `datetime.date` source can only...\n        >>> registry = Registry()\n        >>> registry.register(date, ['day', 'today'], True)\n        >>> s = Source(date, ['day', 'today'], allow_class=True)\n        >>> registry[date].solve(d, 'day')\n        1\n        >>> registry[date].solve(date, 'today') == date.today()\n        True\n\n        \"\"\"\n\n        if source in self.sources:\n            raise AlreadyRegistered(self, source)\n\n        # Inherit attributes from parent classes\n        parent_sources = set()\n        if inherit_attributes:\n            bases = source.__bases__ if isinstance(source, type) else source.__class__.__bases__\n            for klass in bases:\n                if klass in self.sources and self.sources[klass].propagate_attributes:\n                    parent_sources.add(self.sources[klass])\n\n        self.sources[source] = self.Source(\n            source, attributes, allow_class, allow_subclasses,\n            propagate_attributes, inherit_attributes, parent_sources\n        )\n\n        # Propagate attributes to existing subclasses\n        if propagate_attributes:\n            for src in self.sources.values():\n                if src.source != source and src.inherit_attributes\\\n                        and issubclass(src.source, source):\n                    src.parent_source.add(self.sources[source])", "response": "Register a source class with its attributes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_resource_solvers(self, resource):\n\n        solvers_classes = [s for s in self.resource_solver_classes if s.can_solve(resource)]\n\n        if solvers_classes:\n            solvers = []\n\n            for solver_class in solvers_classes:\n\n                # Put the solver instance in the cache if not cached yet.\n                if solver_class not in self._resource_solvers_cache:\n                    self._resource_solvers_cache[solver_class] = solver_class(self)\n\n                solvers.append(self._resource_solvers_cache[solver_class])\n\n            return solvers\n\n        raise SolverNotFound(self, resource)", "response": "Returns the list of resource solvers that can solve the given resource."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_filter_solvers(self, filter_):\n\n        solvers_classes = [s for s in self.filter_solver_classes if s.can_solve(filter_)]\n\n        if solvers_classes:\n            solvers = []\n\n            for solver_class in solvers_classes:\n\n                # Put the solver instance in the cache if not cached yet.\n                if solver_class not in self._filter_solvers_cache:\n                    self._filter_solvers_cache[solver_class] = solver_class(self)\n\n                solvers.append(self._filter_solvers_cache[solver_class])\n\n            return solvers\n\n        raise SolverNotFound(self, filter_)", "response": "Returns the list of filter solvers that can solve the given filter."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef solve_resource(self, value, resource):\n\n        for solver in self.get_resource_solvers(resource):\n            try:\n                return solver.solve(value, resource)\n            except CannotSolve:\n                continue\n\n        raise SolveFailure(self, resource, value)", "response": "Solve the given resource for the given value."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsolves the given filter for the given value.", "response": "def solve_filter(self, value, filter_):\n        \"\"\"Solve the given filter for the given value.\n\n        The solving is done by the first filter solver class that returns ``True`` when calling\n        its ``can_solve`` method for the given filter, and that doesn't raise a ``CannotSolve``\n         exception.\n\n        Arguments\n        ---------\n        value : ?\n            A value to be solved with the given filter.\n        filter_ : dataql.resources.BaseFilter\n            An instance of a subclass of ``dataql.resources.BaseFilter`` to be solved\n            with the given value.\n\n        Returns\n        -------\n        The solved result.\n\n        Raises\n        ------\n        dataql.solvers.exceptions.SolveFailure\n            If no solvers were able to solve the filter. This happen if a solver says that\n            it can solve a filter (by returning ``True`` when calling its ``can_solve`` method,\n            but raises a ``CannotSolve`` exception during solving).\n\n        Example\n        -------\n        >>> from datetime import date\n        >>> registry = Registry()\n        >>> registry.register(date, ['day', 'strftime'])\n        >>> from dataql.resources import Filter, PosArg\n        >>> registry.solve_filter(date(2015, 6, 1), Filter('day'))\n        1\n        >>> registry.solve_filter(date(2015, 6, 1), Filter('strftime', args=[PosArg('%F')]))\n        '2015-06-01'\n\n        # Example of ``SolveFailure`` exception.\n        >>> from dataql.solvers.exceptions import CannotSolve\n        >>> raise SolveFailure(registry, Filter('fromtimestamp'), date)\n        Traceback (most recent call last):\n        dataql.solvers.exceptions.SolveFailure: Unable to solve `<Filter[fromtimestamp]>`.\n\n        \"\"\"\n\n        for solver in self.get_filter_solvers(filter_):\n            try:\n                return solver.solve(value, filter_)\n            except CannotSolve:\n                continue\n\n        raise SolveFailure(self, filter_, value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending an SMS message to the Twilio account.", "response": "def send_message(self, phone_number, message_text):\r\n\r\n        ''' send an SMS from the Twilio account to phone number\r\n\r\n        :param phone_number: string with phone number with country and area code\r\n        :param message_text: string with message text\r\n        :return: dictionary with details of response\r\n\r\n        {\r\n            'direction': 'outbound-api',\r\n            'to': '+18001234567',\r\n            'status': 'queued',\r\n            'dt': 1479603651.0,\r\n            'body': 'good times',\r\n            'error_code': None,\r\n            'from': '+19001234567'\r\n        }\r\n\r\n        '''\r\n\r\n        response = self.client.messages.save(\r\n            to=phone_number,\r\n            from_=self.twilio_phone,\r\n            body=message_text\r\n        )\r\n\r\n        keys = ['body', 'status', 'error_code', 'direction', 'date_updated', 'to', 'from_']\r\n        response_details = {}\r\n        import re\r\n        builtin_pattern = re.compile('^_')\r\n        for method in dir(response):\r\n            if not builtin_pattern.findall(method):\r\n                if method == 'date_updated':\r\n                    from labpack.records.time import labDT\r\n                    python_dt = getattr(response, method)\r\n                    from tzlocal import get_localzone\r\n                    python_dt = python_dt.replace(tzinfo=get_localzone())\r\n                    response_details[method] = labDT.fromPython(python_dt).epoch()\r\n                elif method in keys:\r\n                    response_details[method] = getattr(response, method)\r\n\r\n        return response_details"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding or update value in configuration file format used by proftpd.", "response": "def add_or_update(data, item, value):\n    \"\"\"\n    Add or update value in configuration file format used by proftpd.\n\n    Args:\n        data (str): Configuration file as string.\n        item (str): What option will be added/updated.\n        value (str): Value of option.\n\n    Returns:\n        str: updated configuration\n    \"\"\"\n    data = data.splitlines()\n\n    # to list of bytearrays (this is useful, because their reference passed to\n    # other functions can be changed, and it will change objects in arrays\n    # unlike strings)\n    data = map(lambda x: bytearray(x), data)\n\n    # search for the item in raw (ucommented) values\n    conf = filter(lambda x: x.strip() and x.strip().split()[0] == item, data)\n\n    if conf:\n        conf[0][:] = conf[0].strip().split()[0] + \" \" + value\n    else:\n        # search for the item in commented values, if found, uncomment it\n        comments = filter(\n            lambda x: x.strip().startswith(\"#\")\n                      and len(x.split(\"#\")) >= 2\n                      and x.split(\"#\")[1].split()\n                      and x.split(\"#\")[1].split()[0] == item,\n            data\n        )\n\n        if comments:\n            comments[0][:] = comments[0].split(\"#\")[1].split()[0] + \" \" + value\n        else:\n            # add item, if not found in raw/commented values\n            data.append(item + \" \" + value + \"\\n\")\n\n    return \"\\n\".join(map(lambda x: str(x), data))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncomment line containing what in string data.", "response": "def comment(data, what):\n    \"\"\"\n    Comments line containing `what` in string `data`.\n\n    Args:\n        data (str): Configuration file in string.\n        what (str): Line which will be commented out.\n\n    Returns:\n        str: Configuration file with commented `what`.\n    \"\"\"\n    data = data.splitlines()\n\n    data = map(\n        lambda x: \"#\" + x if x.strip().split() == what.split() else x,\n        data\n    )\n\n    return \"\\n\".join(data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _write_conf_file():\n    with open(CONF_FILE, \"w\") as f:\n        f.write(DEFAULT_PROFTPD_CONF)\n        logger.debug(\"'%s' created.\", CONF_FILE)", "response": "Write configuration file as it is defined in settings."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nuse to create configuration files, set permissions and so on.", "response": "def main(overwrite):\n    \"\"\"\n    Used to create configuration files, set permissions and so on.\n    \"\"\"\n    logger.debug(\"Checking existence of '%s'.\", CONF_PATH)\n    if not os.path.exists(CONF_PATH):\n        logger.debug(\"Directory %s not found! Panicking..\", CONF_PATH)\n        raise UserWarning(\n            \"Can't find '%s' - it looks like ProFTPD is not installed!\" % (\n                CONF_PATH,\n            )\n        )\n\n    # check existence of proftpd.conf\n    logger.debug(\"Checking existence of configuration file '%s'.\", CONF_FILE)\n    if not os.path.exists(CONF_FILE):\n        logger.debug(\"Configuration file not found, creating..\")\n        _write_conf_file()\n    else:\n        logger.debug(\"Found.\")\n\n        if not os.path.exists(CONF_FILE + \"_\"):\n            logger.debug(\n                \"Backing up the configuration file '%s' -> '%s'.\",\n                CONF_FILE,\n                CONF_FILE + \"_\"\n            )\n            shutil.copyfile(CONF_FILE, CONF_FILE + \"_\")\n        else:\n            logger.debug(\n                \"Backup already exists. '%s' will be overwritten.\",\n                CONF_FILE\n            )\n    if overwrite:\n        logger.debug(\"--update switch not found, overwriting conf file\")\n        _write_conf_file()\n\n    logger.debug(\"Checking existence of the '%s' file.\", MODULES_FILE)\n    if not os.path.exists(MODULES_FILE) and _is_deb_system():\n        with open(MODULES_FILE, \"w\") as f:\n            f.write(DEFAULT_MODULES_CONF)\n            logger.debug(\"Modules file not found. Created '%s'.\", MODULES_FILE)\n\n    # create data directory, where the user informations will be stored\n    logger.debug(\"Checking existence of user's directory '%s'.\", DATA_PATH)\n    if not os.path.exists(DATA_PATH):\n        logger.debug(\"Directory '%s' not found, creating..\", DATA_PATH)\n\n        os.makedirs(DATA_PATH, 0777)\n\n        logger.debug(\"Done. '%s' created.\", DATA_PATH)\n\n    # create user files if they doesn't exists\n    logger.debug(\"Checking existence of passwd file '%s'.\", LOGIN_FILE)\n    if not os.path.exists(LOGIN_FILE):\n        logger.debug(\"passwd file not found, creating..\")\n\n        open(LOGIN_FILE, \"a\").close()\n\n        logger.debug(\"Done. '%s' created.\")\n\n    logger.debug(\"Setting permissions..\")\n    os.chown(LOGIN_FILE, get_ftp_uid(), -1)\n    os.chmod(LOGIN_FILE, 0400)\n\n    # load values from protpd conf file\n    logger.debug(\"Switching and adding options..\")\n    data = \"\"\n    with open(CONF_FILE) as f:\n        data = f.read()\n\n    # set path to passwd file\n    logger.debug(\"\\tAuthUserFile\")\n    data = add_or_update(\n        data,\n        \"AuthUserFile\",\n        LOGIN_FILE\n    )\n    logger.debug(\"\\tRequireValidShell\")\n    data = add_or_update(data, \"RequireValidShell\", \"off\")\n    logger.debug(\"\\tDefaultRoot\")\n    data = add_or_update(data, \"DefaultRoot\", \"~\")\n\n    # http://www.proftpd.org/docs/modules/mod_log.html\n    logger.debug(\"\\tLogFormat\")\n    data = add_or_update(data, \"LogFormat\", 'paths \"%f, %u, %m, %{%s}t\"')\n    logger.debug(\"\\tExtendedLog\")\n    data = add_or_update(\n        data,\n        \"ExtendedLog\",\n        LOG_FILE + \" WRITE paths\"\n    )\n\n    if not _is_deb_system():\n        logger.debug(\"Detected non debian based linux. Aplying SUSE changes.\")\n        data = comment(data, \"IdentLookups off\")\n        data = comment(data, \"Include /etc/proftpd/modules.conf\")\n        data = add_or_update(data, \"User\", \"ftp\")\n\n    # save changed file\n    logger.debug(\"Saving into config file..\")\n    with open(CONF_FILE, \"w\") as f:\n        f.write(data)\n        logger.debug(\"Done.\")\n\n    logger.debug(\"Sending proftpd signal to reload configuration..\")\n    reload_configuration()\n    logger.debug(\"Done.\")\n    logger.info(\"All set.\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts co -ordinate values to integers.", "response": "def integerize(self):\n        \"\"\"Convert co-ordinate values to integers.\"\"\"\n        self.x = int(round(self.x))\n        self.y = int(round(self.y))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting co -ordinate values to floats.", "response": "def floatize(self):\n        \"\"\"Convert co-ordinate values to floats.\"\"\"\n        self.x = float(self.x)\n        self.y = float(self.y)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef translate(self, val1, val2=None):\n        error = \"Point.translate only accepts a Point, a tuple, a list, ints or floats.\"\n        if val1 and val2:\n            if isinstance(val1, (int, float)) and isinstance(val2, (int, float)):\n                self.x += val1\n                self.y += val2\n            else:\n                raise ValueError(error)\n        elif val1 and val2 is None:\n            if isinstance(val1, (tuple, list)):\n                self.x += val1[0]\n                self.y += val1[1]\n            elif isinstance(val1, (int, float)):\n                self.x += val1\n                self.y += val1\n            elif isinstance(val1, Point):\n                self.x += val1.x\n                self.y += val1.y\n            else:\n                raise ValueError(error)\n        else:\n            raise ValueError(error)", "response": "Translate the current point to the new location."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrotates the current Point by rad radians.", "response": "def rotate(self, rad):\n        \"\"\"\n        Rotate counter-clockwise by rad radians.\n\n        Positive y goes *up,* as in traditional mathematics.\n\n        Interestingly, you can use this in y-down computer graphics, if\n        you just remember that it turns clockwise, rather than\n        counter-clockwise.\n\n        The new position is returned as a new Point.\n        \"\"\"\n        s, c = [f(rad) for f in (math.sin, math.cos)]\n        x, y = (c * self.x - s * self.y, s * self.x + c * self.y)\n        return Point(x, y)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rotate_about(self, p, theta):\n        result = self.clone()\n        result.translate(-p.x, -p.y)\n        result.rotate(theta)\n        result.translate(p.x, p.y)\n        return result", "response": "Rotate counter - clockwise around a point by theta degrees."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_points(self, pt1, pt2):\n        (x1, y1) = pt1.as_tuple()\n        (x2, y2) = pt2.as_tuple()\n        self.left = min(x1, x2)\n        self.top = min(y1, y2)\n        self.right = max(x1, x2)\n        self.bottom = max(y1, y2)", "response": "Reset the rectangle coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if a rectangle overlaps this rectangle.", "response": "def overlaps(self, other):\n        \"\"\"\n        Return true if a rectangle overlaps this rectangle.\n        \"\"\"\n        return (\n            self.right > other.left and\n            self.left < other.right and\n            self.top < other.bottom and\n            self.bottom > other.top\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef expanded_by(self, n):\n        return Rect(self.left - n, self.top - n, self.right + n, self.bottom + n)", "response": "Return a new rectangle with extended borders."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save(self, *args, **kwargs):\n        if self.no_query:\n            if not self.pk or self.pmid > 0:\n                try:\n                    pmid_min = Publication.objects.all().aggregate(\n                        models.Min('pmid'))['pmid__min'] - 1\n                except:\n                    self.pmid = 0\n                else:\n                    self.pmid = min(0, pmid_min)\n\n            self.pubmed_url = ''\n            self.mini_citation = '{} - {} - {}'.format(\n                self.first_author, self.year, self.journal)\n\n        elif self.redo_query or not self.pk:\n            if self.pmid:\n                query = self.pmid\n            else:\n                query = self.pubmed_url\n\n            email = \"\"    # FIX THIS: Use logged-in user's email\n            lookup = pubmed_lookup.PubMedLookup(query, email)\n            publication = pubmed_lookup.Publication(lookup)\n\n            self.pmid = publication.pmid\n            self.pubmed_url = publication.pubmed_url\n\n            self.title = strip_tags(publication.title)\n            self.authors = publication.authors\n            self.first_author = publication.first_author\n            self.last_author = publication.last_author\n            self.journal = publication.journal\n            self.year = publication.year\n            self.month = publication.month\n            self.day = publication.day\n            self.url = publication.url\n            self.citation = publication.cite()\n            self.mini_citation = publication.cite_mini()\n            self.abstract = strip_tags(publication.abstract)\n\n        self.redo_query = False\n\n        super().save(*args, **kwargs)", "response": "Save the object to the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef perform_bulk_pubmed_query(self):\n        if self.bulk_pubmed_query:\n            failed_queries = []\n            pmid_list = re.findall(r'(\\d+)(?:[\\s,]+|$)', self.bulk_pubmed_query)\n\n            for pmid in pmid_list:\n                try:\n                    p, created = Publication.objects.get_or_create(pmid=pmid)\n                except:\n                    failed_queries.append(pmid)\n                else:\n                    self.publications.add(p.id)\n\n            if failed_queries:\n                failed_queries.sort(key=int)\n                self.bulk_pubmed_query = 'FAILED QUERIES: {}'.format(', '.join(failed_queries))\n            else:\n                self.bulk_pubmed_query = ''", "response": "Perform a bulk PubMed query on the resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save(self, *args, **kwargs):\n        self.perform_bulk_pubmed_query()\n        super().save(*args, **kwargs)", "response": "Save the object to the database."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_backend(self, backend):\n        \"Add a RapidSMS backend to this tenant\"\n        if backend in self.get_backends():\n            return\n        backend_link, created = BackendLink.all_tenants.get_or_create(backend=backend)\n        self.backendlink_set.add(backend_link)", "response": "Add a RapidSMS backend to this tenant"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngroup data into fixed - length chunks or blocks of items.", "response": "def grouper(iterable, items, fillvalue=None):\n    \"\"\"\n    Collect data into fixed-length chunks or blocks\n\n    e.g:\n\n        grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx\n\n    Got it from https://docs.python.org/2/library/itertools.html#recipes\n    \"\"\"\n    args = [iter(iterable)] * items\n    return izip_longest(fillvalue=fillvalue, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding resources to the deform registry", "response": "def add_resources_to_registry():\n    \"\"\"\n    Add resources to the deform registry\n    \"\"\"\n    from deform.widget import default_resource_registry\n\n    default_resource_registry.set_js_resources(\"jqueryui\", None, None)\n    default_resource_registry.set_js_resources(\"datetimepicker\", None, None)\n    default_resource_registry.set_js_resources(\"custom_dates\", None, None)\n    default_resource_registry.set_js_resources(\n        \"radio_choice_toggle\", None, None\n    )\n    default_resource_registry.set_js_resources(\"checkbox_toggle\", None, None)\n\n    from js.deform import resource_mapping\n    # fix missing resource\n    from js.select2 import select2\n    resource_mapping['select2'] = select2\n    # add the datetimepicker\n    from js.jquery_timepicker_addon import timepicker\n    resource_mapping['datetimepicker'] = timepicker\n\n    resource_mapping['custom_dates'] = custom_dates\n    resource_mapping['radio_choice_toggle'] = radio_choice_toggle\n    resource_mapping['checkbox_toggle'] = checkbox_toggle"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning children grouped regarding the grid description", "response": "def childgroup(self, field):\n        \"\"\"\n        Return children grouped regarding the grid description\n        \"\"\"\n        cols = getattr(self, \"cols\", self.default_cols)\n        width = self.num_cols / cols\n        for child in field.children:\n            child.width = width\n        res = list(grouper(field.children, cols, fillvalue=None))\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _childgroup(self, children, grid):\n        result = []\n        index = 0\n        hidden_fields = []\n\n        for row in grid:\n            child_row = []\n            width_sum = 0\n            for width, filled in row:\n                width_sum += width\n                if width_sum > self.num_cols:\n                    warnings.warn(u\"It seems your grid configuration overlaps \\\nthe bootstrap layout columns number. One of your lines is larger than {0}. \\\nYou can increase this column number by compiling bootstrap css with \\\nlessc.\".format(self.num_cols))\n\n                if isinstance(filled, StaticWidget):\n                    child = filled\n                    child.width = width\n\n                elif filled:\n                    try:\n                        child = children[index]\n                    except IndexError:\n                        warnings.warn(u\"The grid items number doesn't \\\nmatch the number of children of our mapping widget\")\n                        break\n                    if type(child.widget) == deform.widget.HiddenWidget:\n                        hidden_fields.append(child)\n                        index += 1\n                        try:\n                            child = children[index]\n                        except IndexError:\n                            warnings.warn(u\"The grid items number doesn't \\\nmatch the number of children of our mapping widget\")\n                            break\n                    child.width = width\n                    index += 1\n                else:\n                    child = VoidWidget(width)\n                child_row.append(child)\n            if child_row != []:\n                result.append(child_row)\n\n        if index <= len(children):\n            result.append(children[index:])\n\n        if hidden_fields != []:\n            result.append(hidden_fields)\n        return result", "response": "This method creates a list of children that are part of a grid."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngrouping the children by name", "response": "def _childgroup_by_name(self, children, grid):\n        \"\"\"\n        Group the children ordering them by name\n        \"\"\"\n        children = self._dict_children(children)\n        result = []\n\n        for row in grid:\n            child_row = []\n            row_is_void = True\n            width_sum = 0\n            for name, width in row:\n                width_sum += width\n                if width_sum > self.num_cols:\n                    warnings.warn(u\"It seems your grid configuration overlaps \\\nthe bootstrap layout columns number. One of your lines is larger than {0}. \\\nYou can increase this column number by compiling bootstrap css with \\\nlessc.\".format(self.num_cols))\n\n                if isinstance(name, StaticWidget):\n                    child = name\n                    child.width = width\n                    row_is_void = False\n                elif name is not None:\n                    try:\n                        child = children.pop(name)\n                        row_is_void = False\n                    except KeyError:\n                        warnings.warn(u\"No node {0} found\".format(name))\n                        child = VoidWidget(width)\n                    child.width = width\n\n                else:\n                    child = VoidWidget(width)\n                child_row.append(child)\n\n            if not row_is_void:\n                result.append(child_row)\n\n        # Add the field not configured in the grid\n        for value in children.values():\n            result.append([value])\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of fields stored by row regarding the configured grid", "response": "def childgroup(self, field):\n        \"\"\"\n        Return a list of fields stored by row regarding the configured grid\n\n        :param field: The original field this widget is attached to\n        \"\"\"\n        grid = getattr(self, \"grid\", None)\n        named_grid = getattr(self, \"named_grid\", None)\n\n        if grid is not None:\n            childgroup = self._childgroup(field.children, grid)\n        elif named_grid is not None:\n            childgroup = self._childgroup_by_name(field.children, named_grid)\n        else:\n            raise AttributeError(u\"Missing the grid or named_grid argument\")\n\n        return childgroup"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the chlidren of the given form in a dict allowing to render them in accordions with a grid layout", "response": "def accordions(self, form):\n        \"\"\"\n        return the chlidren of the given form in a dict allowing to render them\n        in accordions with a grid layout\n        :param form: the form object\n        \"\"\"\n        fixed = []\n        accordions = OrderedDict()\n\n        for child in form.children:\n            section = getattr(child.schema, 'section', '')\n            if not section:\n                fixed.append(child)\n            else:\n                if section not in accordions.keys():\n                    accordions[section] = {\n                        'tag_id': random_tag_id(),\n                        'children': [],\n                        'name': section,\n                        \"error\": False,\n                    }\n                if child.error:\n                    accordions[section]['error'] = True\n                accordions[section]['children'].append(child)\n\n        grids = getattr(self, \"grids\", {})\n        named_grids = getattr(self, 'named_grids', {})\n\n        if grids != {}:\n            method = self._childgroup\n        elif named_grids != {}:\n            method = self._childgroup_by_name\n            grids = named_grids\n        else:\n            warnings.warn(u\"Missing both grids and named_grids argument\")\n\n        for accordion in accordions.values():\n            name = accordion['name']\n            grid = grids.get(name)\n            if grid is not None:\n                children = accordion.pop('children')\n                accordion['rows'] = method(children, grid)\n\n        return fixed, accordions"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check(src, dst):  # type: (str,str)->None\n    was_bad = False\n    try:\n        _ = ast.parse(src)\n    except Exception as exc:\n        was_bad = True\n        major, minor = sys.version_info[:2]\n        logger.warning(\n            \"failed to parse source file \"\n            \"with Python {0}.{1}'s builtin AST. Switch to manual \"\n            \"or stop using deprecated Python 2 syntax. AST error message: {2}\".format(\n                major, minor, exc\n            )\n        )\n\n    try:\n        _ = ast.parse(dst)\n    except Exception as exc:\n        if was_bad:\n            # I didn't make it worse.\n            pass\n        else:\n            # ok, this made the file worse. It must be jiggle_version's fault.\n            print(dst)\n            logger.error(dst)\n            raise", "response": "Check if source file is in black formatter."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing the execution summary", "response": "def summary(self):\n        '''Compute the execution summary'''\n        out = {}\n        for bench in self.runner.runned:\n            key = self.key(bench)\n            runs = {}\n            for method, results in bench.results.items():\n                mean = results.total / bench.times\n                name = bench.label_for(method)\n                runs[method] = {\n                    'name': name,\n                    'total': results.total,\n                    'mean': mean\n                }\n            out[key] = {\n                'name': bench.label,\n                'times': bench.times,\n                'runs': runs\n            }\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef end(self):\n        '''\n        Dump the report into the output file.\n\n        If the file directory does not exists, it will be created.\n        The open file is then given as parameter to :meth:`~minibench.report.FileReporter.output`.\n        '''\n        dirname = os.path.dirname(self.filename)\n        if dirname and not os.path.exists(dirname):\n            os.makedirs(dirname)\n        with open(self.filename, 'w') as out:\n            self.out = out\n            self.output(out)\n            self.out = None", "response": "Dump the report into the output file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef line(self, text=''):\n        '''A simple helper to write line with `\\n`'''\n        self.out.write(text)\n        self.out.write('\\n')", "response": "A simple helper to write line with \\ n"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef with_sizes(self, *headers):\n        '''Compute the report summary and add the computed column sizes'''\n        if len(headers) != 5:\n            raise ValueError('You need to provide this headers: class, method, times, total, average')\n\n        summary = self.summary()\n\n        for row in summary.values():\n            sizes = [len(header) for header in headers]\n            # Benchmark/Class column\n            sizes[0] = max(sizes[0], len(row['name']))\n            # Method column\n            max_length = max(len(r['name']) for r in row['runs'].values())\n            sizes[1] = max(sizes[1], max_length)\n            # Times column\n            sizes[2] = max(sizes[2], len(str(row['times'])))\n            # Float columns\n            for idx, field in [(3, 'total'), (4, 'mean')]:\n                float_len = lambda r: len(self.float(r[field]))\n                max_length = max(float_len(r) for r in row['runs'].values())\n                sizes[idx] = max(sizes[idx], max_length)\n            row['sizes'] = sizes\n\n        return summary", "response": "Compute the report summary and add the computed column sizes"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __telnet_event_listener(self, ip, callback):\n\n        tn = telnetlib.Telnet(ip, 2708)\n        self._last_event = \"\"\n        self._telnet_running = True\n        while self._telnet_running:\n            try:\n                raw_string = tn.read_until(b'.\\n', 5)\n\n                if len(raw_string) >= 2 and raw_string[-2:] == b'.\\n':\n                    # lightpad sends \".\\n\" at the end that we need to chop off\n                    json_string = raw_string.decode('ascii')[0:-2]\n                    if json_string != self._last_event:\n                        callback(json.loads(json_string))\n\n                    self._last_event = json_string\n\n            except:\n                pass\n        tn.close()", "response": "create a telnet connection and call callback when the event is received"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsingles theme ===== Header ===== = items = ==================", "response": "def single(window, config):\n    \"\"\"Single theme\n    ===== Header =====\n    = items          =\n    ==================\n\n    \"\"\"\n    cordx = round(config.get('cordx', 0))\n    color = config.get('color', red)\n    icon = config.get('icon', '=')\n    align = config.get('align', 'left')\n    term = window.term\n\n    width = round(config.get('width', window.width))\n\n    title = config.get('header', ' Menu ')\n    header = term.center(title, width, icon)\n    header = header.split(title)\n    header = color(header[0]) + title + color(header[1])\n\n    footer = color(icon * width)\n\n    l_eq = term.move_x(cordx) + color(icon)\n    l_eq += term.move_x(cordx + width - 1) + \\\n        color(icon) + term.move_x(cordx + 2)\n\n    if align == 'right':\n        for_s = functools.partial(term.rjust, width=width - 4)  # *\n    elif align == 'center':\n        for_s = functools.partial(\n            term.center, width=width - 4)  # -4 width \"= text =\"\n    elif align == 'left':\n        for_s = functools.partial(term.ljust, width=width - 4)  # *\n    else:\n        raise ValueError(\"Only align center, left, right\")\n\n    return {\n        'header': header,\n        'footer': footer,\n        'formater': lambda text, **kwargs: l_eq + for_s(text),\n        'selector': lambda text, **kwargs: l_eq + underline_ns(for_s(text)),\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndouble theme ================== = Header = ================== = items = ================== = footer = ==================", "response": "def double(window, config):\n    \"\"\"Double theme\n    ==================\n    =     Header     =\n    ==================\n    = items          =\n    ==================\n    = footer         =\n    ==================\n\n    \"\"\"\n    cordx = round(config.get('cordx', 0))\n    color = config.get('color', red)\n    icon = config.get('icon', '=')\n    width = config.get('width', window.width)\n    title = config.get('header', 'Menu'.center(width - 2))\n    back = config.get('footer', 'Pagina: {page:03d}/{last:03d}')\n    align = config.get('align', 'left')\n\n    term = window.term\n    line = color(icon * width)\n\n    l_eq = term.move_x(cordx) + color(icon)\n    l_eq += term.move_x(cordx + width - 1) + \\\n        color(icon) + term.move_x(cordx + 1)\n\n    wrapper = f'{line}\\n{l_eq}{{}}\\n{line}'\n\n    header = wrapper.format(title)\n    footer = wrapper.format(back)\n\n    if align == 'right':\n        for_s = functools.partial(term.rjust, width=width - 4)  # *\n    elif align == 'center':\n        for_s = functools.partial(\n            term.center, width=width - 4)  # -4 width \"= text =\"\n    elif align == 'left':\n        for_s = functools.partial(term.ljust, width=width - 4)  # *\n    else:\n        raise ValueError(\"Only align center, left, right\")\n    return {\n        'header': header,\n        'footer': footer,\n        'formater': lambda text, **_: f'{l_eq} {for_s(text)}',\n        'selector': lambda text, **_: f'{l_eq} {underline_ns(for_s(text))}',\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_assign(data, varname):\n    ASSIGN_RE = re.compile(BASE_ASSIGN_PATTERN.format(varname))\n\n    if len(ASSIGN_RE.findall(data)) > 1:\n        raise PluginError('Found multiple {}-strings.'.format(varname))\n\n    if len(ASSIGN_RE.findall(data)) < 1:\n        raise PluginError('No version assignment (\"{}\") found.'\n                          .format(varname))\n\n    return ASSIGN_RE.search(data).group(2)", "response": "Finds a substring that looks like an assignment."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_instance_id(self, instance):\n        \" Returns instance pk even if multiple instances were passed to RichTextField. \"\n        if type(instance) in [list, tuple]:\n            core_signals.request_finished.connect(receiver=RichTextField.reset_instance_counter_listener)\n            if RichTextField.__inst_counter >= len(instance):\n                return None\n            else:\n                obj_id = self.instance[ RichTextField.__inst_counter ].pk\n            RichTextField.__inst_counter += 1\n        else:\n            obj_id = instance.pk\n        return obj_id", "response": "Returns instance pk even if multiple instances were passed to RichTextField."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clean(self, value):\n        super_value = super(RichTextField, self).clean(value)\n\n        if super_value in fields.EMPTY_VALUES:\n            if self.instance:\n                obj_id = self.get_instance_id(self.instance)\n                if not obj_id:\n                    SourceText.objects.filter(content_type=self.ct, object_id=obj_id, field=self.field_name, processor=self.processor).delete()\n                else:\n                    SourceText.objects.filter(content_type=self.ct, object_id=obj_id, field=self.field_name).delete()\n            self.validate_rendered('')\n            return ''\n\n        text = smart_unicode(value)\n        if self.instance:\n            obj_id = self.get_instance_id(self.instance)\n            try:\n                if not obj_id:\n                    src_text = SourceText(content_type=self.ct, object_id=obj_id, field=self.field_name, processor=self.processor)\n                else:\n                    src_text = SourceText.objects.get(content_type=self.ct, object_id=obj_id, field=self.field_name)\n                assert src_text.processor == self.processor\n            except SourceText.DoesNotExist:\n                src_text = SourceText(content_type=self.ct, object_id=obj_id, field=self.field_name, processor=self.processor)\n            src_text.content = text\n            try:\n                rendered = src_text.render()\n            except ProcessorError, e:\n                raise ValidationError(self.error_messages['syntax_error'])\n        else:\n            # in case of adding new model, instance is not set\n            self.instance = src_text = SourceText(\n                content_type=self.ct,\n                field=self.field_name,\n                content=text,\n                processor=self.processor\n            )\n            try:\n                rendered = src_text.render()\n            except Exception, err:\n                raise ValidationError(self.error_messages['syntax_error'])\n\n        self.validate_rendered(rendered)\n\n        if not hasattr(self.model, RICH_FIELDS_SET):\n            setattr(self.model, RICH_FIELDS_SET, set())\n        getattr(self.model, RICH_FIELDS_SET).add(self.field_name)\n\n        # register the listener that saves the SourceText\n        #listener = self.post_save_listener(src_text)\n        signals.post_save.connect(receiver=self.post_save_listener, sender=self.model)\n\n        # wrap the text so that we can store the src_text on it\n        rendered = UnicodeWrapper(rendered)\n        setattr(rendered, self.src_text_attr, src_text)\n\n        return rendered", "response": "When cleaning field store original value to SourceText model and return rendered field."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread a new object from the given input protocol and returns the object.", "response": "def read(cls, iprot):\n        '''\n        Read a new object from the given input protocol and return the object.\n\n        :type iprot: thryft.protocol._input_protocol._InputProtocol\n        :rtype: pastpy.gen.database.impl.online.online_database_object_detail.OnlineDatabaseObjectDetail\n        '''\n\n        init_kwds = {}\n\n        iprot.read_struct_begin()\n        while True:\n            ifield_name, ifield_type, _ifield_id = iprot.read_field_begin()\n            if ifield_type == 0:  # STOP\n                break\n            elif ifield_name == 'attributes':\n                init_kwds['attributes'] = dict([(iprot.read_string(), iprot.read_string()) for _ in range(iprot.read_map_begin()[2])] + (iprot.read_map_end() is None and []))\n            elif ifield_name == 'guid':\n                init_kwds['guid'] = iprot.read_string()\n            elif ifield_name == 'id':\n                init_kwds['id'] = iprot.read_string()\n            elif ifield_name == 'related_photos':\n                init_kwds['related_photos'] = tuple([pastpy.gen.database.impl.online.online_database_object_detail_image.OnlineDatabaseObjectDetailImage.read(iprot) for _ in range(iprot.read_list_begin()[1])] + (iprot.read_list_end() is None and []))\n            iprot.read_field_end()\n        iprot.read_struct_end()\n\n        return cls(**init_kwds)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite the object to the given output protocol and returns the object.", "response": "def write(self, oprot):\n        '''\n        Write this object to the given output protocol and return self.\n\n        :type oprot: thryft.protocol._output_protocol._OutputProtocol\n        :rtype: pastpy.gen.database.impl.online.online_database_object_detail.OnlineDatabaseObjectDetail\n        '''\n\n        oprot.write_struct_begin('OnlineDatabaseObjectDetail')\n\n        oprot.write_field_begin(name='attributes', type=13, id=None)\n        oprot.write_map_begin(11, len(self.attributes), 11)\n        for __key0, __value0 in self.attributes.items():\n            oprot.write_string(__key0)\n            oprot.write_string(__value0)\n        oprot.write_map_end()\n        oprot.write_field_end()\n\n        oprot.write_field_begin(name='guid', type=11, id=None)\n        oprot.write_string(self.guid)\n        oprot.write_field_end()\n\n        oprot.write_field_begin(name='id', type=11, id=None)\n        oprot.write_string(self.id)\n        oprot.write_field_end()\n\n        oprot.write_field_begin(name='related_photos', type=15, id=None)\n        oprot.write_list_begin(12, len(self.related_photos))\n        for _0 in self.related_photos:\n            _0.write(oprot)\n        oprot.write_list_end()\n        oprot.write_field_end()\n\n        oprot.write_field_stop()\n\n        oprot.write_struct_end()\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef value_from_datadict(self, data, files, name):\n        '''Generate a single value from multi-part form data.  Constructs a W3C\n        date based on values that are set, leaving out day and month if they are\n        not present.\n\n        :param data: dictionary of data submitted by the form\n        :param files: - unused\n        :param name: base name of the form field\n        :returns: string value\n        '''\n\n        y = data.get(self.year_field % name)\n        m = data.get(self.month_field % name)\n        d = data.get(self.day_field % name)\n\n        if y == 'YYYY':\n            y = ''\n\n        if m == 'MM':\n            m = ''\n\n        if d == 'DD':\n            d = ''\n\n        date = y\n        if m:\n            date += '-%s' % m\n            if d:\n                date += '-%s' % d\n        return date", "response": "Generate a single value from multi - part form data."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrender the widget as HTML inputs for display on a form.", "response": "def render(self, name, value, attrs=None):\n        '''Render the widget as HTML inputs for display on a form.\n\n        :param name: form field base name\n        :param value: date value\n        :param attrs: - unused\n        :returns: HTML text with three inputs for year/month/day\n        '''\n\n        # expects a value in format YYYY-MM-DD or YYYY-MM or YYYY (or empty/None)\n        year, month, day = 'YYYY', 'MM', 'DD'\n        if value:\n            # use the regular expression to pull out year, month, and day values\n            # if regular expression does not match, inputs will be empty\n            match = W3C_DATE_RE.match(value)\n            if match:\n                date_parts = match.groupdict()\n                year = date_parts['year']\n                month = date_parts['month']\n                day = date_parts['day']\n\n\n        year_html = self.create_textinput(name, self.year_field, year, size=4, title='4-digit year', onClick='javascript:if(this.value == \"YYYY\") { this.value = \"\" };')\n        month_html = self.create_textinput(name, self.month_field, month, size=2, title='2-digit month', onClick='javascript:if(this.value == \"MM\") { this.value = \"\" };')\n        day_html = self.create_textinput(name, self.day_field, day, size=2, title='2-digit day', onClick='javascript:if(this.value == \"DD\") { this.value = \"\" };')\n\n        # display widget fields in YYYY-MM-DD order to match W3C date format,\n        # and putting required field(s) on the left\n        output = [year_html, month_html, day_html]\n\n        return mark_safe(u' / \\n'.join(output))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating and render a TextInput for the current locale.", "response": "def create_textinput(self, name, field, value, **extra_attrs):\n        '''Generate and render a :class:`django.forms.widgets.TextInput` for\n        a single year, month, or day input.\n\n        If size is specified in the extra attributes, it will also be used to\n        set the maximum length of the field.\n\n        :param name: base name of the input field\n        :param field: pattern for this field (used with name to generate input name)\n        :param value: initial value for the field\n        :param extra_attrs: any extra widget attributes\n        :returns: rendered HTML output for the text input\n        '''\n        # TODO: move id-generation logic out for re-use\n        if 'id' in self.attrs:\n            id_ = self.attrs['id']\n        else:\n            id_ = 'id_%s' % name\n\n        # use size to set maximum length\n        if 'size' in extra_attrs:\n            extra_attrs['maxlength'] = extra_attrs['size']\n        local_attrs = self.build_attrs(id=field % id_, **extra_attrs)\n        txtinput = TextInput()\n        return txtinput.render(field % name, value, local_attrs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef describe(self):\n        '''Provide a dictionary with information describing itself.'''\n        description = {\n            'description': self._description,\n            'type': self.name,\n        }\n        description.update(self.extra_params)\n        return description", "response": "Provide a dictionary with information describing itself."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __build_query(self, routine, parameters):\n\n        parameter_names = []\n        replacements = {}\n        for i, value in enumerate(parameters):\n            name = 'arg' + str(i)\n\n            parameter_names.append(name)\n            replacements[name] = value\n\n        parameter_pieces = []\n        for i, name in enumerate(parameter_names):\n            if i > 0:\n                parameter_pieces.append(', ')\n\n            # Embed encoded blobs directly.\n            if issubclass(replacements[name].__class__, _BlobArgumentWrapper) is True:\n                parameter_pieces.append(replacements[name].encoded)\n                del replacements[name]\n            else:\n                parameter_pieces.append(':' + name)\n\n        query = \"CALL \" + routine + \"(\" + ''.join(parameter_pieces) + \")\"\n\n        return (query, replacements)", "response": "Build a query string that uses traditional or proper parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __build_raw_query(self, routine, parameters):\n\n        parameter_names = []\n        replacements = {}\n\n        for i, value in enumerate(parameters):\n            name = 'arg' + str(i)\n\n            parameter_names.append(name)\n            replacements[name] = value\n\n        parameter_phrase = ', '.join([('%(' + p + ')s') for p in parameter_names])\n\n        query = \"CALL \" + routine + \"(\" + parameter_phrase + \")\"\n        return (query, replacements)", "response": "Build a raw SQL query that uses raw string - replacement for parameters."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of lists of dictionaries for when a query returns more than one resultset.", "response": "def get_resultsets(self, routine, *args):\n        \"\"\"Return a list of lists of dictionaries, for when a query returns \n        more than one resultset.\n        \"\"\"\n\n        (query, replacements) = self.__build_raw_query(routine, args)\n\n        # Grab a raw connection from the connection-pool.\n        connection = mm.db.ENGINE.raw_connection()\n\n        sets = []\n\n        try:\n            cursor = connection.cursor()\n\n            cursor.execute(query, replacements)\n\n            while 1:\n                #(column_name, type_, ignore_, ignore_, ignore_, null_ok, column_flags)\n                names = [c[0] for c in cursor.description]\n\n                set_ = []\n                while 1:\n                    row_raw = cursor.fetchone()\n                    if row_raw is None:\n                        break\n\n                    row = dict(zip(names, row_raw))\n                    set_.append(row)\n\n                sets.append(list(set_))\n\n                if cursor.nextset() is None:\n                    break\n\n# TODO(dustin): nextset() doesn't seem to be sufficiant to tell the end.\n                if cursor.description is None:\n                    break\n        finally:\n            # Return the connection to the pool (won't actually close).\n            connection.close()\n\n        return sets"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nexecutes a text query and return a generator of the results.", "response": "def __execute_text(self, query, **replacements):\n        \"\"\"This is an older interface that should now only be used by call(), \n        above.\n        \"\"\"\n\n        # We've had persistent and long-term issues where we can't access tables \n        # from another client because they're locked, as well as getting the \n        # \"gone away\" error quite frequenctly. Per the documentation, apparently \n        # it is common to -not- reuse the same session from request to request,\n        # and we believe this to be the problem. Hopefully it's fixed, now.\n        #\n        # REF: http://docs.sqlalchemy.org/en/rel_0_9/orm/session.html#when-do-i-construct-a-session-when-do-i-commit-it-and-when-do-i-close-it\n        session = self.__get_session()\n        \n        try:\n            records = session.execute(query, replacements)\n        except:\n            _LOGGER.exception(\"Query failure:\\n%s\", query)\n\n            raise\n\n        # Verifying that we have a realized list of results before we commit \n        # the transaction.\n\n        try:\n            records = list(records)\n        finally:\n            session.commit()\n\n        for record in records:\n            yield dict(record)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find(self, name, namespace=None):\n        if \".\" in name:\n            namespace, name = name.rsplit(\".\", 1)\n        caret = self.raw\n        if namespace:\n            for term in namespace.split('.'):\n                if term not in caret:\n                    caret[term] = Bunch()\n                caret = caret[term]\n        return caret[name]", "response": "Find plugin object in the local cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register(self, name, obj, namespace=None):\n        if \".\" in name:\n            namespace, name = name.rsplit(\".\", 1)\n        caret = self.raw\n        if namespace:\n            for term in namespace.split('.'):\n                if term not in caret:\n                    caret[term] = Bunch()\n                caret = caret[term]\n        caret[name] = obj", "response": "Register a new entry in the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_plugins(self, plugin_dirs=None, quiet=True):\n        from pkg_resources import working_set\n        from pkg_resources import iter_entry_points\n        from pkg_resources import Environment\n\n        if plugin_dirs is None:\n            plugin_dirs = []\n            plugin_dirs.append(environment.get_system_plugins_directory())\n            plugin_dirs.append(environment.get_user_plugins_directory())\n\n        distributions, errors = working_set.find_plugins(\n                Environment(plugin_dirs)\n            )\n        map(working_set.add, distributions)\n\n        if not quiet:\n            # display error info\n            for distribution, error in errors:\n                print distrubution, error\n\n        for entry_point in iter_entry_points(self.ENTRY_POINT):\n            # load entry point\n            plugin = entry_point.load()\n            # if plugin is callable and `manually` is True, initialize manually\n            if callable(plugin) and getattr(plugin, 'manually', False):\n                # manually initialize plugin\n                plugin(self)\n            else:\n                # automatically initialize plugin\n                self.register(entry_point.name, plugin)", "response": "Load plugins in sys. path and the attribute plugin_dirs."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates the signable string for a request and returns it.", "response": "def signable(self, request, authheaders):\n        \"\"\"Creates the signable string for a request and returns it.\n\n        Keyword arguments:\n        request -- A request object which can be consumed by this API.\n        authheaders -- A string-indexable object which contains the headers appropriate for this signature version.\n        \"\"\"\n        method = request.method.upper()\n        md5 = hashlib.md5()\n        if request.body is not None:\n            md5.update(request.body)\n        bodyhash = md5.hexdigest()\n        ctype = request.get_header(\"content-type\")\n        date = request.get_header(\"date\")\n        cheaders = []\n        cheader_first = True\n        cheaders_sign = ''\n        if \"headers\" in authheaders:\n            cheaders = authheaders[\"headers\"].split(\";\")\n        cheaders.sort()\n        for cheader in cheaders:\n            if cheader_first:\n                cheader_first = False\n            else:\n                cheaders_sign += '\\n'\n            cheaders_sign += '{0}: {1}'.format(cheader.lower(), request.get_header(cheader))\n        requri = request.url.request_uri()\n\n        return '{0}\\n{1}\\n{2}\\n{3}\\n{4}\\n{5}'.format(method, bodyhash, ctype, date, cheaders_sign, requri)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the base64 - encoded signature appropriate for the request.", "response": "def sign(self, request, authheaders, secret):\n        \"\"\"Returns the signature appropriate for the request. The request is not changed by this function.\n\n        Keyword arguments:\n        request -- A request object which can be consumed by this API.\n        authheaders -- A string-indexable object which contains the headers appropriate for this signature version.\n        secret -- The base64-encoded secret key for the HMAC authorization.\n        \"\"\"\n        mac = hmac.HMAC(secret.encode('utf-8'), digestmod=self.digest)\n        mac.update(self.signable(request, authheaders).encode('utf-8'))\n        digest = mac.digest()\n        return base64.b64encode(digest).decode('utf-8')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the authorization headers from the request and returns a dict that is accepted by all other API functions which expect them in a dict format.", "response": "def parse_auth_headers(self, authorization):\n        \"\"\"Parses the authorization headers from the authorization header taken from a request.\n        Returns a dict that is accepted by all other API functions which expect authorization headers in a dict format.\n\n        Keyword arguments:\n        authorization -- The authorization header of any request. The header must be in a format understood by the signer.\n        \"\"\"\n        m = re.match(r'^(?i)Acquia\\s+(.*?):(.+)$', authorization)\n        if m is not None:\n            return {\"id\": m.group(1), \"signature\": m.group(2)}\n        return {}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check(self, request, secret):\n        if request.get_header(\"Authorization\") == \"\":\n            return False\n        ah = self.parse_auth_headers(request.get_header(\"Authorization\"))\n        if \"id\" not in ah:\n            return False\n        if \"signature\" not in ah:\n            return False\n        return ah[\"signature\"] == self.sign(request, ah, secret)", "response": "Verifies whether or not the request is an authorization appropriate and valid for this version of the signature."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsigns a request directly with an appropriate signature.", "response": "def sign_direct(self, request, authheaders, secret):\n        \"\"\"Signs a request directly with an appropriate signature. The request's Authorization header will change.\n\n        Keyword arguments:\n        request -- A request object which can be consumed by this API.\n        authheaders -- A string-indexable object which contains the headers appropriate for this signature version.\n        secret -- The base64-encoded secret key for the HMAC authorization.\n        \"\"\"\n        sig = self.sign(request, authheaders, secret)\n        return request.with_header(\"Authorization\", \"Acquia {0}:{1}\".format(authheaders[\"id\"], sig))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_system_root_directory():\n    root = os.path.dirname(__file__)\n    root = os.path.dirname(root)\n    root = os.path.abspath(root)\n    return root", "response": "Returns the system root directory of the application."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_user_root_directory():\n    uname = platform.system()\n    if uname == 'Windows':\n        root = os.path.join(os.environ['APPDATA'], APP_NAME)\n        root = os.path.abspath(root)\n    elif uname == 'Linux':\n        if os.path.exists(os.path.expanduser('~/.config')):\n            root = os.path.join(os.path.expanduser('~/.config'), APP_NAME)\n        else:\n            root = os.path.join(os.path.expanduser('~'), '.%s' % APP_NAME)\n        root = os.path.abspath(root)\n    elif uname in ('Linux', 'Darwin'):\n        root = os.path.join(os.path.expanduser('~'), '.%s' % APP_NAME)\n        root = os.path.abspath(root)\n    else:\n        root = os.path.join(os.path.expanduser('~'), APP_NAME)\n        root = os.path.abspath(root)\n    return root", "response": "Get user root directory"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nperforms all checks on the API s contained in directory.", "response": "def main(directories):\n    '''Perform all checks on the API's contained in `directory`.'''\n    msg = 'Checking module \"{}\" from directory \"{}\" for coding errors.'\n    api_checker = ApiChecker()\n    resource_checker = ResourceChecker()\n    errors = []\n    modules = []\n    for loader, mname, _ in pkgutil.walk_packages(directories):\n        sys.path.append(os.path.abspath(loader.path))\n        log.info(msg.format(mname, loader.path))\n        modules.append(mname)\n        import_module(mname)\n    for api in Api:\n        if api.__module__.split('.')[-1] not in modules:\n            continue\n        log.debug('Anlysing Api class: {}'.format(api.__name__))\n        errors.extend(api_checker(api))\n    for res in Resource:\n        if res.__module__.split('.')[-1] not in modules:\n            continue\n        log.debug('Anlysing Resource class: {}'.format(res.__name__))\n        errors.extend(resource_checker(res))\n    else:\n        log.info('All modules tested, no problem detected.')\n    return errors"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef checks(self):\n        '''Return the list of all check methods.'''\n        condition = lambda a: a.startswith('check_')\n        return (getattr(self, a) for a in dir(self) if condition(a))", "response": "Return the list of all check methods."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_has_docstring(self, api):\n        '''An API class must have a docstring.'''\n        if not api.__doc__:\n            msg = 'The Api class \"{}\" lacks a docstring.'\n            return [msg.format(api.__name__)]", "response": "An API class must have a docstring."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_has_version(self, api):\n        '''An API class must have a `version` attribute.'''\n        if not hasattr(api, 'version'):\n            msg = 'The Api class \"{}\" lacks a `version` attribute.'\n            return [msg.format(api.__name__)]", "response": "An API class must have a version attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_docstring(self, method):\n        '''All methods should have a docstring.'''\n        mn = method.__name__\n        if method.__doc__ is None:\n            return ['Missing docstring for method \"{}\"'.format(mn)]", "response": "Check that the method has a docstring."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck that the return types of a method are correct.", "response": "def check_return_types(self, method):\n        '''Return types must be correct, their codes must match actual use.'''\n        mn = method.__name__\n        retanno = method.__annotations__.get('return', None)\n        # Take a look at the syntax\n        if not retanno:\n            return ['Missing return types for method \"{}\"'.format(mn)]\n        if not isinstance(retanno, (list, tuple)):\n            msg = 'Return annotation for method \"{}\" not tuple nor list'\n            return [msg.format(mn)]\n        if (any(map(lambda t: not isinstance(t, (list, tuple)), retanno)) or\n                any(map(lambda t: not (2 <= len(t) <= 3), retanno))):\n            msg = ('Return values series for \"{}\" should be composed of '\n                   '2 or 3-items tuples (code, msg, type).')\n            return [msg.format(mn)]\n        errors = []\n        # Take a look at the codes\n        declared = set([t[0] for t in retanno])\n        actual = set(int(s)\n                     for s in HTTP_STATUSES_REGEX.findall(method.source))\n        if declared != actual:\n            if declared.issubset(actual):\n                msg = 'Method {} returns undeclared codes: {}.'\n                errors.append(msg.format(mn, actual - declared))\n            elif actual.issubset(declared):\n                msg = 'Method {} declares codes {} that are never used.'\n                errors.append(msg.format(mn, declared - actual))\n            else:\n                msg = 'Declared {} and Used {} codes mismatch.'\n                errors.append(msg.format(declared, actual))\n        # Take a look at the types\n        ret_with_types = filter(lambda t: len(t) == 3, retanno)\n        msg = 'Method {} return type for code {} must be class (not instance).'\n        msg_mod = 'Method {} return type for code {} must subclass from Model.'\n        for code, _, type_ in ret_with_types:\n            try:\n                if Model not in type_.__bases__:\n                    errors.append(msg_mod.format(mn, code))\n            except AttributeError:\n                errors.append(msg.format(mn, code))\n        return errors"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck that the types of parameters in the method are instances not classes.", "response": "def check_params_types(self, method):\n        '''Types in argument annotations must be instances, not classes.'''\n        mn = method.__name__\n        annos = dict(method.__annotations__)\n        errors = []\n        # Take a look at the syntax\n        msg_tuple = 'Parameter {} in method {} is not annotated with a tuple.'\n        msg_ptype = 'Parameter {} in method {} is not a valid Ptype.'\n        msg_mod = 'Type for param {} in method {} must descend from Model.'\n        msg_cls = 'Type for param {} in method {} must be instance (not class)'\n        bodies = []\n        for pname, anno in annos.items():\n            if pname == 'return':\n                continue\n            elif len(anno) != 2:\n                errors.append(msg_tuple.format(pname, mn))\n            else:\n                param_type, value_type = anno\n                if param_type not in Ptypes:\n                    errors.append(msg_ptype.format(pname, mn))\n                elif param_type == 'body':\n                    bodies.append(pname)\n                elif param_type == 'path':\n                    default = method.signature.parameters[pname].default\n                    if default is not inspect._empty:\n                        msg = ('Path prameter {} in method {} has a default '\n                               'value ({}) that would make it optional (which '\n                               'is wrong!)')\n                        errors.append(msg.format(pname, mn, default))\n                if hasattr(value_type, '__bases__'):\n                    errors.append(msg_cls.format(pname, mn))\n                elif Model not in value_type.__class__.__bases__:\n                    errors.append(msg_mod.format(pname, mn))\n        # Only one body parameter!\n        if len(bodies) > 1:\n            msg = 'Too many \"Ptypes.body\" params {} for method {} (max=1).'\n            errors.append(msg.format(bodies, mn))\n        return errors"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking that path arguments are consistent for all methods.", "response": "def check_path_consistency(self, resource):\n        '''Path arguments must be consistent for all methods.'''\n        msg = ('Method \"{}\" path variables {}) do not conform with the '\n               'resource subpath declaration ({}).')\n        errors = []\n        # If subpath is not set, it will be detected by another checker\n        if resource.subpath is None:\n            return errors\n        declared = sorted(self.path_params_regex.findall(resource.subpath))\n        for callback in resource.callbacks:\n            actual = sorted(utils.filter_annotations_by_ptype(\n                callback, Ptypes.path))\n            if declared == actual:\n                continue\n            errors.append(msg.format(\n                '{}.{}'.format(resource.__name__, callback.__name__),\n                actual, resource.subpath))\n        return errors"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_no_multiple_handlers(self, resource):\n        '''The same verb cannot be repeated on several endpoints.'''\n        seen = []\n        errors = []\n        msg = 'HTTP verb \"{}\" associated to more than one endpoint in \"{}\".'\n        for method in resource.callbacks:\n            for op in getattr(method, 'swagger_ops'):\n                if op in seen:\n                    errors.append(msg.format(op, resource.__name__))\n                else:\n                    seen.append(op)\n        return errors", "response": "Check that no multiple handlers are associated to a resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef init(req, model):\n\n    rels = model.relationships\n    params = req.get_param_as_list('include') or []\n    params = [param.lower() for param in params]\n\n    for param in params:\n        _validate_no_nesting(param)\n        _validate_rels(param, rels)\n\n    return params", "response": "Return an array of fields to include."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef disable(self, identifier, children_only=False):\n        import_path = self._identifier2import_path(identifier=identifier)\n        if not children_only and import_path not in self._disabled:\n            self._disable_path(import_path)\n            self._disabled.add(import_path)\n        if import_path not in self._children_disabled:\n            self._children_disabled.add(import_path)\n            self._write_child_disabled()", "response": "Disable an include type for the current process."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef enable(self, identifier, exclude_children=False):\n        import_path = self._identifier2import_path(identifier=identifier)\n        if import_path in self._disabled:\n            self._enable_path(import_path)\n            self._disabled.remove(import_path)\n        if not exclude_children and import_path in self._children_disabled:\n            self._children_disabled.remove(import_path)\n            self._write_child_disabled()", "response": "Enable a previously disabled include type."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_module(self, name):\n        # allow reload noop\n        if name in sys.modules:\n            return sys.modules[name]\n        raise DisabledIncludeError('Include type %r disabled, cannot import module %r' % (self._module_prefix, name))", "response": "Load and return a module with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef relative(dataset, ori=0, column=1, fail_silently=True):\n    try:\n        if isinstance(ori, int):\n            # relative from the [ori]th array\n            ori = dataset[ori][column]\n        if isinstance(ori[0], (list, tuple, np.ndarray)):\n            # calculate min/max difference\n            for i in range(len(ori[0])):\n                orimin = np.min(ori[:,i])\n                orimax = np.max(ori[:,i])\n                oridiff = orimax - orimin\n                # baseline\n                for data in dataset:\n                    data[column][:,i] -= orimin\n                # convert\n                for data in dataset:\n                    data[column][:,i] /= oridiff / 100.0\n        else:\n            orimin = np.min(ori)\n            orimax = np.max(ori)\n            oridiff = orimax - orimin\n            # baseline\n            for data in dataset:\n                data[column] -= orimin\n            # convert\n            for data in dataset:\n                data[column] /= oridiff / 100.0\n        return dataset\n    except IndexError, e:\n        if fail_silently:\n            # fail silently\n            return dataset\n        raise e", "response": "Convert dataset to relative value from the value of column."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef execute_get_text(command):  # type: (str) ->str\n    try:\n        _ = subprocess.run\n        try:\n            completed = subprocess.run(\n                command,\n                check=True,\n                shell=True,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE\n            )\n        except subprocess.CalledProcessError as cpe:\n            raise\n        else:\n            return completed.stdout.decode('utf-8') + completed.stderr.decode(\"utf-8\")\n    except AttributeError:\n        try:\n            p = subprocess.Popen(command.split(\" \"), stdout=subprocess.PIPE)\n            out, err = p.communicate()\n        except subprocess.CalledProcessError as cpe:\n            raise\n        else:\n            return str(out) + str(err)", "response": "Execute shell command and return stdout txt\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_query_type(query):\n\n    if URL_RE.match(query):\n        query_type = 'domain'\n    elif EMAIL_RE.match(query):\n        query_type = 'email'\n    else:\n        query_type = ''\n\n    return query_type", "response": "Gets the type of query in use."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn endpoint URL for the relevant search type.", "response": "def get_endpoint(api_key, query, offset, type):\n    \"\"\"Return endpoint URL for the relevant search type.\n\n    The base API endpoint only varies by type of search requested, of\n    which there are two: 1) domain search and 2) email search. Each\n    search type requires different parameters, though api_key is common\n    between them.\n\n    Note: if both a url and email address are provided the endpoint\n    returned will default to the domain search as it is considered to\n    be the primary function of the API and thus takes precedent.\n\n    :param api_key: Secret client API key.\n    :param query: URL or email address on which to search.\n    :param offset: Specifies the number of emails to skip.\n    :param type: Specifies email type (i.e. generic or personal).\n\n    \"\"\"\n\n    query_type = get_query_type(query)\n\n    if query_type not in ('domain', 'email'):\n        raise ex.InvalidQueryStringException('Invalid query string')\n\n    if query_type == 'domain':\n        return DOMAIN_URL.format(query, api_key, offset, type)\n    else:\n        return EMAIL_URL.format(query, api_key)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncenter blit the source surface onto the target surface.", "response": "def center_blit(target, source, dest = (0, 0), area=None, special_flags=0):\n    '''\n    Blits surface @source to the center of surface @target. Takes the normal \n    Surface.blit() flags; however, @dest is used as an offset.\n    '''\n    loc = lambda d, s: _vec(d.get_size()) / 2 - _vec(s.get_size()) / 2\n    _blitter(loc, target, source, dest, area, special_flags)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef vcenter_blit(target, source, dest = (0, 0), area=None, special_flags=0):\n    '''\n    The same as center_blit(), but only centers vertically.\n    '''\n    loc = lambda d, s: (_vec(0, d.get_height() / 2) - \n            _vec(0, s.get_height() / 2))\n    _blitter(loc, target, source, dest, area, special_flags)", "response": "Center a source block vertically."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncentering a block of a source block onto a target block.", "response": "def hcenter_blit(target, source, dest = (0, 0), area=None, special_flags=0):\n    '''\n    The same as center_blit(), but only centers horizontally.\n    '''\n    loc = lambda d, s: (_vec(d.get_width() / 2, 0) - \n            _vec(s.get_width() / 2, 0))\n    _blitter(loc, target, source, dest, area, special_flags)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef incrementName(nameList, name):\n    if name not in nameList:\n        return name\n    newName = name + str(1)\n    for n in range(1, len(nameList) + 2):\n        found = False\n        for b in nameList:\n            newName = name + str(n)\n            if b == newName:\n                found = True\n        if not found:\n            break\n    return newName", "response": "return a name that is unique in a given nameList"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef provider_factory(factory=_sentinel, scope=NoneScope):\n    '''\n    Decorator to create a provider using the given factory, and scope.\n    Can also be used in a non-decorator manner.\n\n    :param scope: Scope key, factory, or instance\n    :type scope: object or callable\n    :return: decorator\n    :rtype: decorator\n    '''\n    if factory is _sentinel:\n        return functools.partial(provider_factory, scope=scope)\n    provider = Provider(factory, scope)\n    return provider", "response": "Decorator to create a provider using the given factory and scope."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef scaleToBoxParam(quad, shape):\n    '''\n    so, you have a [quad] ((x0,y0),,,) inside a box [shape](width,height)\n    \n    this function gives you center [x,y], and scale factor [x,y]\n    you would need to apply to [quad] in order to scale it to the same shape as the box\n    \n    \n    !quad corners needs to be sorted like in example\n    '''\n    \n    #get edge middle points\n    x0 = 0.5*(quad[0][0]+quad[1][0])\n    x1 = 0.5*(quad[2][0]+quad[3][0])\n    \n    y0 = 0.5*(quad[0][1]+quad[3][1])\n    y1 = 0.5*(quad[1][1]+quad[2][1])\n    \n    cx = (x0*shape[0]) / (x0-x1+shape[0])\n    cy = (y0*shape[1]) / (y0-y1+shape[1])\n\n    fx = abs(cx/(x0-cx))\n    fy = abs(cy/(y0-cy))\n\n    return (fx,fy), (cx,cy)", "response": "This function scales the image to the specified shape."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_from_human_key(self, key):\n        if key in self._identifier_map:\n            return self._identifier_map[key]\n        raise KeyError(key)", "response": "Return the key ( aka database value of a human key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_human_key(self, key):\n        for human_key, k in self._identifier_map.items():\n            if k == key:\n                return human_key\n        raise KeyError(key)", "response": "Return the human key of a key."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load(self):\n\n        filters = [Filter(self.field, 'eq', self.rid)]\n        store = goldman.sess.store\n\n        self._is_loaded = True\n        self.models = store.search(self.rtype, filters=filters)\n\n        return self.models", "response": "Load the model from the store"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts to native object.", "response": "def to_native(self, value, context=None):\n        \"\"\" Schematics deserializer override\n\n        :return: ToMany instance\n        \"\"\"\n\n        if isinstance(value, ToMany):\n            return value\n        else:\n            return ToMany(self.rtype, self.field, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives the name of the PC return the database identifier.", "response": "def _id_for_pc(self, name):\n        \"\"\" Given the name of the PC, return the database identifier. \"\"\"\n        if not name in self.pc2id_lut:\n            self.c.execute(\"INSERT INTO pcs (name) VALUES ( ? )\", (name,))\n            self.pc2id_lut[name] = self.c.lastrowid\n            self.id2pc_lut[self.c.lastrowid] = name\n        return self.pc2id_lut[name]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving the name of the source return the database identifier.", "response": "def _id_for_source(self, name):\n        \"\"\" Given the name of the source, return the database identifier. \"\"\"\n        if not name in self.source2id_lut:\n            self.c.execute(\"INSERT INTO sources (name) VALUES ( ? )\", (name,))\n            self.source2id_lut[name] = self.c.lastrowid\n            self.id2source_lut[self.c.lastrowid] = name\n        return self.source2id_lut[name]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_occupation(self):\n        ret = {}\n        self.l.info(\"Reading occupation from database...\")\n        with self.lock:\n            for pc_name, pc_id in self.pc2id_lut.iteritems():\n                self.c.execute(\"\"\" SELECT occupation FROM occupationUpdates\n                                          WHERE pc=? ORDER BY datetime DESC\n                                          LIMIT 0, 1 \"\"\", \n                                            (pc_id,))\n                row = self.c.fetchone()\n                if row is not None:\n                    ret[pc_name] = row[0]\n        self.l.info(\"  ... done: %s entries\", len(ret))\n        return ret", "response": "Returns the occupation as was last recorded."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef record_occupation_updates(self, updates, source, version):\n        now = int(time.time())\n        # Put it on the recordQueue and notify the worker thread.\n        with self.recordCond:\n            self.recordQueue.append((now, updates, source))\n            self.recordCond.notify()", "response": "Records an occupation update."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of count occupation updates from offset.", "response": "def get_occupation_updates(self, offset=0, count=1000):\n        \"\"\" Returns <count> occupation updates from <offset>.\n        \n            An occupation update is a quadrupel\n\n                (pc, source, timestamp, occupation) \"\"\"\n        ret = []\n        c = self.conn.cursor()\n        for pc_id, source_id, datetime, occupation in c.execute(\n                    \"\"\" SELECT pc, source, datetime, occupation\n                            FROM occupationUpdates LIMIT ?, ? \"\"\",\n                            (offset, count)):\n            ret.append((self.id2pc_lut[pc_id],\n                        self.id2source_lut[source_id],\n                        datetime,\n                        occupation))\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self):\n        # TODO is a separate thread necessary?  Wouldn't a threadPool.execute\n        #      suffice?\n        self.running = True\n        self.recordCond.acquire()\n        while self.running or self.recordQueue:\n            # Check for new entries.  If none: wait.\n            if self.running and not self.recordQueue:\n                self.recordCond.wait()\n                continue\n            entries = list(reversed(self.recordQueue))\n            self.recordQueue = []\n            self.recordCond.release()\n            with self.lock:\n                # Record the entries\n                for now, updates, source in entries:\n                    for pc, occupation in updates.iteritems():\n                        self.c.execute(\"\"\" INSERT INTO occupationUpdates\n                                            ( pc, datetime, occupation, source )\n                                           VALUES ( ?, ?, ?, ? ) \"\"\", (\n                                   self._id_for_pc(pc), now, occupation,\n                                   self._id_for_source(source)))\n                self.conn.commit()\n            self.recordCond.acquire()\n        self.recordCond.release()", "response": "Runs the worker thread that records the occupation updates for the specified resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn list of phone numbers without punctuation.", "response": "def phones(text):\n    '''Returns list of phone numbers without punctuation.'''\n    return imap(lambda m: m.group(0).replace('-', ''),\n                REGEX_PHONE.finditer(text))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef emails(text):\n    '''Returns list of phone numbers without punctuation.'''\n    return imap(lambda m: m.group(0).lower(), REGEX_EMAIL.finditer(text))", "response": "Returns list of phone numbers without punctuation."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns normalized urls found in the a tag", "response": "def a_urls(html):\n    '''\n    return normalized urls found in the 'a' tag\n    '''\n    soup = BeautifulSoup(html, 'lxml')\n    for node in soup.find_all('a'):\n        try:\n            href = node['href']\n        except KeyError:\n            continue\n        yield norm_url(href)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntake a StringCounter of normalized URL and parses their hostnames N. B. this assumes that absolute URLs begin with http:// Relative URLs begin with http:// .", "response": "def host_names(urls):\n    '''\n    Takes a StringCounter of normalized URL and parses their hostnames\n\n    N.B. this assumes that absolute URLs will begin with\n\n    http://\n\n    in order to accurately resolve the host name.\n    Relative URLs will not have host names.\n    '''\n    host_names = StringCounter()\n    for url in urls:\n        host_names[urlparse(url).netloc] += urls[url]\n    return host_names"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef path_dirs(urls):\n    '''\n    Takes a StringCounter of normalized URL and parses them into\n    a list of path directories. The file name is\n    included in the path directory list.\n    '''\n    path_dirs = StringCounter()\n    for url in urls:\n        for path_dir in filter(None, urlparse(url).path.split('/')):\n            path_dirs[path_dir] += urls[url]\n    return path_dirs", "response": "Takes a StringCounter of normalized URL and parses them into a list of path directories. The file name is\n    included in the path directory list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nscan the path for a binary.", "response": "def scan_path(executable=\"mongod\"):\n    \"\"\"Scan the path for a binary.\n    \"\"\"\n    for path in os.environ.get(\"PATH\", \"\").split(\":\"):\n        path = os.path.abspath(path)\n        executable_path = os.path.join(path, executable)\n        if os.path.exists(executable_path):\n            return executable_path"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_open_port(host=\"localhost\"):\n    temp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    temp_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    temp_sock.bind((host, 0))\n    port = temp_sock.getsockname()[1]\n    temp_sock.close()\n    del temp_sock\n    return port", "response": "Get an open port on the machine."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef configure(self, options, conf):\n        # This option has to be specified on the command line, to enable the\n        # plugin.\n        if not options.mongoengine or options.mongodb_bin:\n            return\n\n        if not options.mongodb_bin:\n            self.mongodb_param['mongodb_bin'] = scan_path()\n            if self.mongodb_param['mongodb_bin'] is None:\n                raise AssertionError(\n                    \"Mongoengine plugin enabled, but no mongod on path, \"\n                    \"please specify path to binary\\n\"\n                    \"ie. --mongoengine-mongodb=/path/to/mongod\")\n        else:\n            self.mongodb_param['mongodb_bin'] = os.path.abspath(\n                os.path.expanduser(os.path.expandvars(options.mongodb_bin)))\n            if not os.path.exists(self.mongodb_param['mongodb_bin']):\n                raise AssertionError(\n                    \"Invalid mongodb binary %r\" % \\\n                    self.mongodb_param['mongodb_bin'])\n\n        # Its necessary to enable in nose\n        self.enabled = True\n\n        db_log_path = os.path.expandvars(os.path.expanduser(\n            options.mongodb_logpath))\n        try:\n            db_file = open(db_log_path, \"w\")\n            db_file.close()\n        except Exception as exc:\n            raise AssertionError(\"Invalid log path %r\" % exc)\n\n        if not options.mongodb_port:\n            self.mongodb_param['db_port'] = get_open_port()\n        else:\n            self.mongodb_param['db_port'] = options.mongodb_port\n\n        db_prealloc = options.mongodb_prealloc\n        db_scripting = options.mongodb_scripting\n\n        self.clear_context['module'] = options.mongoengine_clear_after_module\n        self.clear_context['class'] = options.mongoengine_clear_after_class\n\n        # generate random database name\n        self.database_name = str(uuid.uuid1())\n\n        #########################################\n        # Start a instance of mongo\n        #########################################\n\n        # Stores data here\n        self.mongodb_param['db_path'] = tempfile.mkdtemp()\n        if not os.path.exists(self.mongodb_param['db_path']):\n            os.mkdir(self.mongodb_param['db_path'])\n\n        args = [\n            self.mongodb_param['mongodb_bin'],\n            \"--dbpath\",\n            self.mongodb_param['db_path'],\n            \"--port\",\n            str(self.mongodb_param['db_port']),\n            # don't flood stdout, we're not reading it\n            \"--quiet\",\n            # save the port\n            \"--nohttpinterface\",\n            # disable unused.\n            \"--nounixsocket\",\n            # use a smaller default file size\n            \"--smallfiles\",\n            # journaling on by default in 2.0 and makes it to slow\n            # for tests, can causes failures in jenkins\n            \"--nojournal\",\n            # Default is /dev/null\n            \"--logpath\",\n            db_log_path,\n            \"-vvvvv\"\n            ]\n\n        if not db_prealloc:\n            args.append(\"--noprealloc\")\n\n        if not db_scripting:\n            args.append(\"--noscripting\")\n\n        self.process = Popen(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT\n            )\n\n        self._running = True\n        os.environ[\"TEST_MONGODB\"] = \"localhost:%s\" % \\\n                                     self.mongodb_param['db_port']\n        os.environ[\"TEST_MONGODB_DATABASE\"] = self.database_name\n\n        # Give a moment for mongodb to finish coming up\n        time.sleep(0.3)\n\n        # Connecting using mongoengine\n        self.connection = connect(self.database_name, host=\"localhost\",\n                port=self.mongodb_param['db_port'])", "response": "Configure the nose object with the options."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef stopContext(self, context):\n\n        # Use pymongo directly to drop all collections of created db\n        if ((self.clear_context['module'] and inspect.ismodule(context)) or\n           (self.clear_context['class'] and inspect.isclass(context))):\n            self.connection.drop_database(self.database_name)", "response": "Stop the context if so configured for this\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstopping the mongodb instance.", "response": "def finalize(self, result):\n        \"\"\"Stop the mongodb instance.\n        \"\"\"\n\n        if not self._running:\n            return\n\n        # Clear out the env variable.\n        del os.environ[\"TEST_MONGODB\"]\n        del os.environ[\"TEST_MONGODB_DATABASE\"]\n\n        # Kill the mongod process\n        if sys.platform == 'darwin':\n            self.process.kill()\n        else:\n            self.process.terminate()\n        self.process.wait()\n\n        # Clean out the test data.\n        shutil.rmtree(self.mongodb_param['db_path'])\n        self._running = False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nembed an image to an email message.", "response": "def email_embed_image(email, img_content_id, img_data):\n    \"\"\"\n    email is a django.core.mail.EmailMessage object\n    \"\"\"\n    img = MIMEImage(img_data)\n    img.add_header('Content-ID', '<%s>' % img_content_id)\n    img.add_header('Content-Disposition', 'inline')\n    email.attach(img)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef safe_mongocall(call):\n\n    def _safe_mongocall(*args, **kwargs):\n        for i in range(4):\n            try:\n                return call(*args, **kwargs)\n            except pymongo.errors.AutoReconnect:\n                print ('AutoReconnecting, try %d' % i)\n                time.sleep(pow(2, i))\n        # Try one more time, but this time, if it fails, let the\n        # exception bubble up to the caller.\n        return call(*args, **kwargs)\n    return _safe_mongocall", "response": "Decorator for automatic handling of AutoReconnect - exceptions."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the user name.", "response": "def get_username(self):\n        \"\"\"\n        Gets the user name. The value can be stored in parameters \"username\" or \"user\".\n\n        :return: the user name.\n        \"\"\"\n        username = self.get_as_nullable_string(\"username\")\n        username = username if username != None else self.get_as_nullable_string(\"user\")\n        return username"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the user password.", "response": "def get_password(self):\n        \"\"\"\n        Get the user password. The value can be stored in parameters \"password\" or \"pass\".\n\n        :return: the user password.\n        \"\"\"\n        password = self.get_as_nullable_string(\"password\")\n        password = password if password != None else self.get_as_nullable_string(\"pass\")\n        return password"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_access_id(self):\n        access_id = self.get_as_nullable_string(\"access_id\")\n        access_id = access_id if access_id != None else self.get_as_nullable_string(\"client_id\")\n        return access_id", "response": "Gets the application access id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the application secret key.", "response": "def get_access_key(self):\n        \"\"\"\n        Gets the application secret key.\n        The value can be stored in parameters \"access_key\", \"client_key\" or \"secret_key\".\n\n        :return: the application secret key.\n        \"\"\"\n        access_key = self.get_as_nullable_string(\"access_key\")\n        access_key = access_key if access_key != None else self.get_as_nullable_string(\"access_key\")\n        return access_key"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve all CredentialParams from configuration parameters from credentials section.", "response": "def many_from_config(config):\n        \"\"\"\n        Retrieves all CredentialParams from configuration parameters\n        from \"credentials\" section. If \"credential\" section is present instead,\n        than it returns a list with only one CredentialParams.\n\n        :param config: a configuration parameters to retrieve credentials\n\n        :return: a list of retrieved CredentialParams\n        \"\"\"\n        result = []\n\n        # Try to get multiple credentials first\n        credentials = config.get_section(\"credentials\")\n        if len(credentials) > 0:\n            sections_names = credentials.get_section_names()\n            for section in sections_names:\n                credential = credentials.get_section(section)\n                result.append(CredentialParams(credential))\n        # Then try to get a single credential\n        else:\n            credential = config.get_section(\"credential\")\n            result.append(CredentialParams(credential))\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_output_supports_color():\n        plat = sys.platform\n        supported_platform = plat != 'Pocket PC' and (plat != 'win32' or 'ANSICON' in os.environ)\n\n        is_a_tty = hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()\n        if not supported_platform or not is_a_tty:\n            return False\n        return True", "response": "Returns True if the running system s terminal supports color and False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints relevant attributes of an object.", "response": "def show(self, displayAll = False):\n\t\t'''Prints relevant attributes of an object\n\t\tArgs:\n\t\t\tdisplayAll\t\tif True displays ALL class attributes.\n\t\t'''\n\t\tfrom pprint import pprint\n\t\tif displayAll:\n\t\t\tpprint(self.attributes)\n\t\telse:\n\t\t\tdisp_attr = {}\n\t\t\tfor key in self.disp_attr_keys:\n\t\t\t\ttry:\n\t\t\t\t\tdisp_attr[key] = self.attributes[key]\n\t\t\t\texcept KeyError:\n\t\t\t\t\tif key == 'lowercaseEmail':\n\t\t\t\t\t\tdisp_attr[key] = disp_attr['email'].lower()\n\t\t\t\t\telse:\n\t\t\t\t\t\tdisp_attr[key] = None\n\t\t\tpprint(disp_attr)\n\t\tdel pprint"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_dict(self, rw = False):\n\t\t'''Returns relevant attributes as a dict.\n\t\tArgs:\n\t\t\trw \t\t\tif True only returns the read/write enabled object attributes\n\t\t'''\n\t\treturn {k:v for (k,v) in self.attributes.items() \n\t\t\t\tif (v is not None and (not rw or (k in self.rw_attr_keys)))}", "response": "Returns relevant attributes as a dict."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the configuration of a celestial sun and eight planets in order of the sun.", "response": "def configuration(t0: date, t1: Optional[date] = None,  \n                  steps_per_day: int = None) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Get the positions and velocities of the sun and eight planets\n    Returned as a tuple q, v\n    q: Nx3 array of positions (x, y, z) in the J2000.0 coordinate frame.\n    \"\"\"\n    # Default steps_per_day = 1\n    if steps_per_day is None:\n        steps_per_day = 1\n        \n    # Time step dt is 1.0 over steps per day\n    dt: float = 1.0 / float(steps_per_day)\n\n    # Default t1 to one day after t0\n    if t1 is not None:\n        # Convert t to a julian day\n        jd0: int = julian_day(t0)\n        jd1: int = julian_day(t1)\n    else:\n        jd0: int = julian_day(t0)\n        jd1: int = jd0 + dt\n\n    # Pass the times as an array of julian days\n    jd: np.ndarray = np.arange(jd0, jd1, dt)\n\n    # Number of time steps\n    N: int = len(jd)\n    \n    # bodies is a list of the celestial bodies considered; should be in an enclosing scope\n    # Number of bodies\n    B: int = len(bodies)\n    # Number of dimensions\n    dims: int = B * 3\n    \n    # Initialize empty arrays for position q and velocity v\n    q: np.ndarray = np.zeros((N, dims))\n    v: np.ndarray = np.zeros((N, dims))\n\n    # Position and velocity of the sun as arrays of length 3\n    body_ids: List[int] = [jpl_body_id[body] for body in bodies]\n\n    # Fill in the position and velocity for each body in order\n    for i, body_id in enumerate(body_ids):\n        # The slice of columns for this body (same in q and v)\n        slice_i = slice(3*i, 3*(i+1))\n        # Extract the position and velocity from jpl\n        qi, vi = jpl_kernel[0, body_id].compute_and_differentiate(jd)\n        # Convert positions from km to meters (multiply by km2m)\n        q[:, slice_i] = qi.T * km2m\n        # Convert velocities from km / day to meters / sec (multiply by km2m, divide by day2sec)\n        v[:, slice_i] = vi.T * (km2m / day2sec)\n\n    # Return tuple of Tx6 arrays for position q and velocity v\n    return q, v"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef plot(q: np.ndarray, bodies: List[str], plot_colors: Dict[str, str],\n         sim_name: str, fname: Optional[str] = None):\n    \"\"\"\n    Plot the planetary orbits.  Plot size limited to box of 10 AU around the sun.\n    q is a Nx3B array.  t indexes time points.  3B columns are (x, y, z) for the bodies in order.\n    \"\"\"\n    # Get N and number of dims\n    N, dims = q.shape\n\n    # Slices for \n    x_slice = slice(0, dims, 3)\n    y_slice = slice(1, dims, 3)\n    # Convert all distances from meters to astronomical units (AU)\n    plot_x = q[:, x_slice] / au2m\n    plot_y = q[:, y_slice] / au2m\n    \n    # Set up chart title and scale\n    fig, ax = plt.subplots(figsize=[12,12])\n    ax.set_title(f'Inner Planetary Orbits in 2018; Weekly from {sim_name}')\n    ax.set_xlabel('x in J2000.0 Frame; Astronomical Units (au)')\n    ax.set_ylabel('y in J2000.0 Frame; Astronomical Units (au)')\n    # Scale and tick size\n    a = 5.0\n    da = 1.0\n    ticks = np.arange(-a, a+da, da)\n    # Set limits and ticks\n    ax.set_xlim(-a, a)\n    ax.set_ylim(-a, a)\n    ax.set_xticks(ticks)\n    ax.set_yticks(ticks)\n\n    # Set marker sizes proportional to size of bodies\n    radius_earth = radius_tbl['earth']\n    markersize_earth = 4.0\n    markersize_tbl = {body : cbrt(radius_tbl[body] / radius_earth) * markersize_earth for body in bodies}\n    \n    # Plot the orbit of each body\n    for k, body in enumerate(bodies):\n        ax.plot(plot_x[:, k], plot_y[:, k], label=body, color=plot_colors[body], \n                linewidth=0, markersize = markersize_tbl[body], marker='o')\n    \n    # Legend and grid\n    fig.legend(loc=7, bbox_to_anchor=(0.85, 0.5))\n    # ax.legend()\n    ax.grid()\n\n    # Save plot if a filename was provided\n    if fname is not None:\n        fig.savefig(fname, bbox_inches='tight')\n\n    # Display plot\n    plt.show()", "response": "Plot the inner planetary orbits of each body in a list of bodies."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_frame(fig, ax, plot_x: np.ndarray, plot_y: np.ndarray, frame_num: int, \n               bodies: List[str], plot_colors: Dict[str, str], markersize_tbl: Dict[str, float],\n               fname: str):\n    \"\"\"\n    Make a series of frames of the planetary orbits that can be assembled into a movie.\n    q is a Nx3B array.  t indexes time points.  3B columns are (x, y, z) for the bodies in order.\n    \"\"\"\n    # Clear the axis\n    ax.clear()\n\n    ax.set_title(f'Inner Planetary Orbits in 2018')\n    ax.set_xlabel('x in J2000.0 Frame; Astronomical Units (au)')\n    ax.set_ylabel('y in J2000.0 Frame; Astronomical Units (au)')\n\n    # Scale and tick size\n    a = 2.0\n    da = 1.0\n    ticks = np.arange(-a, a+da, da)\n\n    # Set limits and ticks\n    ax.set_xlim(-a, a)\n    ax.set_ylim(-a, a)\n    ax.set_xticks(ticks)\n    ax.set_yticks(ticks)\n\n    # Plot the orbit of each body\n    for k, body in enumerate(bodies[0:5]):\n        ax.plot(plot_x[k], plot_y[k], label=body, color=plot_colors[body], \n                linewidth=0, markersize = markersize_tbl[body], marker='o')    \n    ax.grid()\n\n    # Save this frame\n    fig.savefig(f'{fname}_{frame_num:05d}.png')", "response": "Make a series of frames of the planetary orbits that can be assembled into a movie."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmakes a series of frames of the planetary orbits that can be assembled into a movie.", "response": "def make_movie(q: np.ndarray, step: int, bodies: List[str], plot_colors: Dict[str, str], fname: str):\n    \"\"\"\n    Make a series of frames of the planetary orbits that can be assembled into a movie.\n    q is a Nx3B array.  t indexes time points.  3B columns are (x, y, z) for the bodies in order.\n    \"\"\"\n    # Get N and number of dims\n    N, dims = q.shape\n\n    # Slices for x and y\n    x_slice = slice(0, dims, 3)\n    y_slice = slice(1, dims, 3)\n    # Convert all distances from meters to astronomical units (AU)\n    plot_x = q[:, x_slice] / au2m\n    plot_y = q[:, y_slice] / au2m\n    \n    # Set marker sizes proportional to size of bodies\n    radius_earth = radius_tbl['earth']\n    markersize_earth = 8.0\n    markersize_tbl = {body : (radius_tbl[body] / radius_earth)**0.25 * markersize_earth for body in bodies}\n    \n    # Set up chart title and scale\n    fig, ax = plt.subplots(figsize=[12,12])\n\n    # Make each frame\n    print(f'Generating movie with {N} frames...')\n    for fn in tqdm(range(N//step)):\n        # The row number in the array is the frame number times the step size\n        rn: int = fn * step\n        make_frame(fig, ax, plot_x[rn], plot_y[rn], fn, bodies, plot_colors, markersize_tbl, fname)\n\n    # Assemble the frames into a movie (video only)\n    cmd1: List[str] = ['ffmpeg', '-r', '24', '-f', 'image2', '-s', '864x864', '-i', 'movie/planets_%05d.png',\n                     '-vcodec',  'libx264', '-crf', '20', '-pix_fmt', 'yuv420p', 'movie/planets_video.mp4']\n    call(cmd1)\n\n    # Add the soundtrack to the movie\n    cmd2: List[str] = ['ffmpeg', '-i', 'movie/planets_video.mp4', '-i', 'movie/holst_jupiter.mp3', \n                      '-c:v', 'copy', '-shortest', 'movie/planets.mp4']\n    call(cmd2) \n\n    # Delete the frames\n    cmd3: List[str] = ['rm', 'movie/*.png']\n    call(cmd3)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute the gravitational accelerations in the system q in row vector of 6 elements.", "response": "def accel(q: np.ndarray):\n    \"\"\"\n    Compute the gravitational accelerations in the system\n    q in row vector of 6 elements: sun (x, y, z), earth (x, y, z)\n    \"\"\"\n\n    # Infer number of dimensions from q\n    dims: int = len(q)\n\n    # Initialize acceleration as dimsx1 array\n    a: np.ndarray = np.zeros(dims)\n    \n    # Iterate over each distinct pair of bodies\n    for i in range(B):\n        for j in range(i+1, B):\n    \n            # Masses of body i and j\n            m0 = mass[i]\n            m1 = mass[j]\n        \n            # Extract position of body i and j as 3-vectors\n            pos_0 = q[slices[i]]\n            pos_1 = q[slices[j]]\n        \n            # Displacement vector from body i to body j\n            dv_01: np.ndarray = pos_1 - pos_0\n        \n            # Distance from body i to j\n            r_01: float = np.linalg.norm(dv_01)\n            \n            # Unit vector pointing from body i to body j\n            udv_01 = dv_01 / r_01\n        \n            # The force between these has magnitude G*m0*m1 / r^2\n            f_01: float = (G * m0 * m1) / (r_01 ** 2)\n            \n            # The force vectors are attractive\n            a[slices[i]] += f_01 * udv_01 / m0\n            a[slices[j]] -= f_01 * udv_01 / m1\n        \n    # Return the acceleration vector\n    return a"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing the kinetic and potential energy of the planetary system", "response": "def energy(q, v):\n    \"\"\"Compute the kinetic and potential energy of the planetary system\"\"\"\n    \n    # Number of points\n    N: int = len(q)\n    \n    # Initialize arrays to zero of the correct size\n    T: np.ndarray = np.zeros(N)\n    U: np.ndarray = np.zeros(N)    \n    \n    # Add up kinetic energy of each body\n    for i in range(B):\n        # Kinetic energy is 1/2 mv^2\n        m = mass[i]\n        vi = v[:, slices[i]]\n        T += 0.5 * m * np.sum(vi * vi, axis=1)\n    \n    # Add up potential energy of each pair of bodies\n    for i in range(B):\n        for j in range(i+1, B):\n            # Masses of these two bodies\n            mi = mass[i]\n            mj = mass[j]\n        \n            # Positions of body i and j\n            qi: np.ndarray = q[:, slices[i]]\n            qj: np.ndarray = q[:, slices[j]]\n        \n            # Potential energy is -G m1 m2  / r\n            dv_ij = qj - qi\n            r_ij = np.linalg.norm(dv_ij, axis=1)\n            U -= G * mi * mj * 1.0 / r_ij\n    \n    # Total energy H = T + U\n    H = T + U\n    \n    return H, T, U"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_force(q_vars, mass):\n    # Number of bodies\n    B: int = len(mass)\n    \n    # Build the potential energy fluxion by iterating over distinct pairs of bodies\n    U = fl.Const(0.0)\n    for i in range(B):\n        for j in range(i+1, B):\n            U +=  U_ij(q_vars, mass, i, j)\n    \n    # Varname arrays for both the coordinate system and U\n    vn_q = np.array([q.var_name for q in q_vars])\n    vn_fl = np.array(sorted(U.var_names))\n    # Permutation array for putting variables in q in the order expected by U (alphabetical)\n    q2fl = np.array([np.argmax((vn_q == v)) for v in vn_fl])\n    # Permutation array for putting results of U.diff() in order of q_vars\n    fl2q = np.array([np.argmax((vn_fl == v)) for v in vn_q])\n    # Return a force function from this potential\n    force_func = lambda q: -U.diff(q[q2fl]).squeeze()[fl2q]\n    return force_func", "response": "Creates a function that calculates the potential energy fluxion of the eight planets sytem."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tweet(tweet_text_func):\n    '''\n    A decorator to make a function Tweet\n\n    Parameters\n\n    - `tweet_text_func` is a function that takes no parameters and returns a tweetable string\n\n    For example::\n\n        @tweet\n        def total_deposits_this_week():\n            # ...\n\n        @tweet\n        def not_an_interesting_tweet():\n            return 'This tweet is not data-driven.'\n    '''\n    def tweet_func():\n        api = _connect_to_twitter()\n        tweet = tweet_text_func()\n        print \"Tweeting: %s\" % tweet\n        api.update_status(tweet)\n        return tweet\n\n    return tweet_func", "response": "A decorator to make a function Tweetable string"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_perm_name(cls, action, full=True):\n    codename = \"{}_{}\".format(action, cls.__name__.lower())\n    if full:\n        return \"{}.{}\".format(cls._meta.app_label, codename)\n    return codename", "response": "Returns the name of the permission for a given model and action."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef configure(self, config):\n        connections = ConnectionParams.many_from_config(config)\n        for connection in connections:\n            self._connections.append(connection)", "response": "Configures the component by passing configuration parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register(self, correlation_id, connection):\n        result = self._register_in_discovery(correlation_id, connection)\n        \n        if result:\n            self._connections.append(connection)", "response": "Registers the given connection in all referenced discovery services."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nresolve a single component connection.", "response": "def resolve(self, correlation_id):\n        \"\"\"\n        Resolves a single component connection. If connections are configured to be retrieved\n        from Discovery service it finds a [[IDiscovery]] and resolves the connection there.\n\n        :param correlation_id: (optional) transaction id to trace execution through call chain.\n\n        :return: resolved connection parameters or null if nothing was found.\n        \"\"\"\n        if len(self._connections) == 0: return None\n        \n        # Return connection that doesn't require discovery\n        for connection in self._connections:\n            if not connection.use_discovery():\n                return connection\n        \n        # Return connection that require discovery\n        for connection in self._connections:\n            if connection.use_discovery():\n                resolved_connection = self._resolve_in_discovery(correlation_id, connection)\n                if resolved_connection != None:\n                    # Merge configured and new parameters\n                    resolved_connection = ConnectionParams(ConfigParams.merge_configs(connection, resolved_connection))\n                    return resolved_connection\n        \n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nresolve all component connections.", "response": "def resolve_all(self, correlation_id):\n        \"\"\"\n        Resolves all component connection. If connections are configured to be retrieved\n        from Discovery service it finds a [[IDiscovery]] and resolves the connection there.\n\n        :param correlation_id: (optional) transaction id to trace execution through call chain.\n\n        :return: a list of resolved connections.\n        \"\"\"\n        resolved = []\n        to_resolve = []\n\n        # Sort connections\n        for connection in self._connections:\n            if connection.use_discovery():\n                to_resolve.append(connection)\n            else:\n                resolved.append(connection)\n        \n        # Resolve addresses that require that\n        if len(to_resolve) > 0:\n            for connection in to_resolve:\n                resolved_connections = self._resolve_all_in_discovery(correlation_id, connection)\n                for resolved_connection in resolved_connections:\n                    # Merge configured and new parameters\n                    resolved_connection = ConnectionParams(ConfigParams.merge_configs(connection, resolved_connection))\n                    resolved.append(resolved_connection)\n        \n        return resolved"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprotect the login with a captcha after of N failed access attempts :param func: :return:", "response": "def protect_login_with_captcha(func):\n    \"\"\"\n    Protect the login with a captcha after of N failed access attempts\n    :param func:\n    :return:\n    \"\"\"\n    @wraps(func)\n    def decorated_login(request, *args, **kwargs):\n        response = func(request, *args, **kwargs)\n\n        access_attempt = AccessAttempt(request, response)\n        access_attempt.inspect()\n\n        return response\n\n    return decorated_login"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef push(self, queue_name, task_id, data):\n        # SQS doesn't let you specify a task id.\n        queue = self._get_queue(queue_name)\n        message = queue.new_message(body=data)\n        queue.write(message)\n        return message.id", "response": "Pushes a task onto the queue."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npopping a task off the queue.", "response": "def pop(self, queue_name):\n        \"\"\"\n        Pops a task off the queue.\n\n        :param queue_name: The name of the queue. Usually handled by the\n            ``Gator`` instance.\n        :type queue_name: string\n\n        :returns: The data for the task.\n        :rtype: string\n        \"\"\"\n        queue = self._get_queue(queue_name)\n        message = queue.read()\n\n        if message:\n            data = message.get_body()\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending a partial response without closing the connection.", "response": "def sendPartialResponse(self):\n        \"\"\"\n        Send a partial response without closing the connection.\n\n        :return: <void>\n        \"\"\"\n        self.requestProtocol.requestResponse[\"code\"] = (\n            self.responseCode\n        )\n        self.requestProtocol.requestResponse[\"content\"] = (\n            self.responseContent\n        )\n        self.requestProtocol.requestResponse[\"errors\"] = (\n            self.responseErrors\n        )\n        self.requestProtocol.sendPartialRequestResponse()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sendFinalResponse(self):\n        self.requestProtocol.requestResponse[\"code\"] = (\n            self.responseCode\n        )\n        self.requestProtocol.requestResponse[\"content\"] = (\n            self.responseContent\n        )\n        self.requestProtocol.requestResponse[\"errors\"] = (\n            self.responseErrors\n        )\n        self.requestProtocol.sendFinalRequestResponse()", "response": "Send the final response and close the connection."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a minimal __init__ file with enough boiler plate to not add to lint messages", "response": "def create_init(self, path):  # type: (str) -> None\n        \"\"\"\n        Create a minimal __init__ file with enough boiler plate to not add to lint messages\n        :param path:\n        :return:\n        \"\"\"\n        source = \"\"\"# coding=utf-8\n\\\"\\\"\\\"\nVersion\n\\\"\\\"\\\"\n__version__ = \\\"0.0.0\\\"\n\"\"\"\n        with io.open(path, \"w\", encoding=\"utf-8\") as outfile:\n            outfile.write(source)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_setup_cfg(self, path):  # type: (str) -> None\n        source = \"\"\"[metadata]\nname = {0}\nversion=0.0.1 \n\"\"\".format(\n            self.project\n        )\n        with io.open(path, \"w\", encoding=\"utf-8\") as outfile:\n            outfile.write(source)", "response": "Create config file for the current version of the local cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef process_request(self, req, resp):\n\n        if goldman.config.TLS_REQUIRED and req.protocol != 'https':\n            abort(TLSRequired)", "response": "Process the request before routing it."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nposting - processing of the response.", "response": "def process_response(self, req, resp, resource):\n        \"\"\" Post-processing of the response (after routing).\n\n        We attempt to follow many of the 'hardening reponse headers'\n        best practices. These include things like:\n\n            HPKP: HTTP Public Key Pinning\n            HSTS: HTTP Srict Transport Security\n            X-Content-Type-Options:\n                prevents mime-sniffing so user generated content\n                isn't auto determined as something it shouldn't be.\n            XSS Protection: built in reflective XSS protection\n        \"\"\"\n\n        hpkp = goldman.config.HPKP\n\n        if hpkp:\n            resp.set_header(\n                'Public-Key-Pins',\n                '{}; includeSubdomains; max-age=31536000'.format(hpkp),\n            )\n\n        resp.set_header(\n            'Strict-Transport-Security',\n            'max-age=31536000; includeSubDomains',\n        )\n\n        resp.set_header(\n            'X-Content-Type-Options',\n            'nosniff',\n        )\n\n        resp.set_header(\n            'X-Xss-Protection',\n            '1; mode=block',\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add(self, value):\n        ind = int(self._ind % self.shape)\n        self._pos = self._ind % self.shape\n        self._values[ind] = value\n        if self._ind < self.shape:\n            self._ind += 1  # fast fill\n        else:\n            self._ind += self._splitValue\n            self._splitPos += self._splitValue\n        self._cached = False", "response": "Add a value to the buffer."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef array(self):\n        if self._ind < self.shape:\n            return self._values[:self._ind]\n        if not self._cached:\n            ind = int(self._ind % self.shape)\n            self._cache[:self.shape - ind] = self._values[ind:]\n            self._cache[self.shape - ind:] = self._values[:ind]\n            self._cached = True\n        return self._cache", "response": "Returns a numpy array containing the last stored values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the position where to split the array to get the values in the right order", "response": "def splitPos(self):\n        \"\"\"return the position of where to split the array\n        to get the values in the right order\"\"\"\n        if self._ind < self.shape:\n            return 0\n        v = int(self._splitPos)\n        if v >= 1:\n            self._splitPos = 0\n        return v"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sort(polylines):\n    for n, c in enumerate(polylines):\n        l = len(c)\n        if l > 2:\n            # DEFINE FIRST AND LAST INDEX A THOSE TWO POINTS THAT\n            # HAVE THE BIGGEST DIFFERENCE FROM A MIDDLE:\n            mid = c.mean(axis=0)\n\n            distV = (c - mid)\n            dists = norm(distV, axis=-1)\n\n            firstI = np.argmax(dists)\n            sign = np.sign(distV[firstI])\n\n            dd = np.logical_or(np.sign(distV[:, 0]) != sign[0],\n                               np.sign(distV[:, 1]) != sign[1])\n\n            dists[~dd] = 0\n            lastI = np.argmax(dists)\n\n            ind = _sort(c, firstI, lastI)\n            c = c[ind]\n            polylines[n] = c", "response": "sort points within polyline p0 - p1 - p2..."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfilters polylines shorter than given min length", "response": "def filter(polylines, min_len=20):\n    \"\"\"\n    filter polylines shorter than given min length\n    \"\"\"\n    filtered = []\n    for n in range(len(polylines) - 1, -1, -1):\n        if lengths(polylines[n]).sum() < min_len:\n            filtered.append(polylines.pop(n))\n    return filtered"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef separate(polylines, f_mx_dist=2, mn_group_len=4):\n    s = []\n\n    for n in range(len(polylines) - 1, -1, -1):\n        c = polylines[n]\n        separated = False\n        start = 0\n\n        for m in range(mn_group_len, len(c) - 1):\n            if m - start < mn_group_len:\n                continue\n            m += 1\n            group = c[m - mn_group_len:m]\n\n            x, y = group[:, 0], group[:, 1]\n            asc, offs, _, _, _ = linregress(x, y)\n            yfit = asc * x + offs\n\n            # check whether next point would fit in:\n            p1 = c[m]\n            l = (x[0], yfit[0], p1[-1], asc * p1[-1] + offs)\n            std = np.mean([line.distance(l, g) for g in group])\n            dist = line.distance(l, p1)\n\n            if dist > 2 and dist > f_mx_dist * std:\n                separated = True\n                s.append(c[start:m - 1])\n                start = m - 1\n\n        if separated:\n            if len(c) - start >= 2:\n                s.append(c[start:])\n            polylines.pop(n)\n\n    polylines.extend(s)\n\n    return polylines", "response": "split a list of crinkles into two lists wherever crinkles are found"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef merge(polylines, mx_dist=4):\n    l = len(polylines)\n    to_remove = set()\n    for n in range(l - 1, -1, -1):\n        if n not in to_remove:\n            c = polylines[n]\n            for p0, p1 in zip(c[:-1], c[1:]):\n                # create a line from any subsegment:\n                l0 = p0[0], p0[1], p1[0], p1[1]\n\n                # for every other polyline:\n                for m in range(l - 1, -1, -1):\n                    if m not in to_remove:\n                        if n == m:\n                            continue\n                        remove = False\n                        cc = polylines[m]\n                        ind = np.zeros(shape=cc.shape[0], dtype=bool)\n\n                        # for every point p in this polyline:\n                        for o in range(len(cc) - 1, -1, -1):\n                            p = cc[o]\n\n                            if line.segmentDistance(l0, p) < mx_dist:\n                                remove = True\n                                ind[o] = True\n\n                        if remove:\n                            polylines[n] = np.append(c, cc[ind], axis=0)\n                            ind = ~ind\n                            s = ind.sum()\n                            if s < 2:\n                                to_remove.add(m)\n                            else:\n                                polylines[m] = cc[ind]\n\n    to_remove = sorted(to_remove)\n    to_remove.reverse()\n    for i in to_remove:\n        polylines.pop(i)", "response": "Merge a list of polylines into a single tree."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef connect(polylines, max_dist=10):\n    ll = len(polylines)\n    remove = []\n    for n in range(ll - 1, -1, -1):\n        c = polylines[n]\n        if len(c) > 1:\n            for d0, p0 in enumerate((c[0, 0], c[-1, 0])):\n                for m in range(len(polylines) - 1, -1, -1):\n                    # combine all x all polylines\n                    if n == m:\n                        continue\n                    cc = polylines[m]\n\n                    for d1, p1 in enumerate((cc[0, 0], cc[-1, 0])):\n                        # for end points of other polylines:\n                        # measure closest distance for current polyline\n                        ndist = norm(p0 - p1)\n                        if ndist < max_dist:\n                            is_same, c = _connect(c, cc, d0, d1)\n                            if is_same:\n                                if m not in remove:\n                                    remove.append(m)\n                                polylines[n] = c\n                                break\n    # remove those which are already in connected to other polyline:\n    remove.sort()\n    remove.reverse()\n    for r in remove:\n        polylines.pop(r)", "response": "connects the given polylines to the current one"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsmoothing every polyline using spline interpolation", "response": "def smooth(polylines):\n    \"\"\"\n    smooth every polyline using spline interpolation\n    \"\"\"\n    for c in polylines:\n        if len(c) < 9:\n            # smoothing wouldn't make sense here\n            continue\n        x = c[:, 0]\n        y = c[:, 1]\n\n        t = np.arange(x.shape[0], dtype=float)\n        t /= t[-1]\n        x = UnivariateSpline(t, x)(t)\n        y = UnivariateSpline(t, y)(t)\n        c[:, 0] = x\n        c[:, 1] = y"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_acorn(self, method, *items):\n    #IMPORTANT!! I lost two hours because the ndarray becomes unstable if you\n    #don't call the original method first. Somehow passing the array instance to\n    #other methods changed its internal representation and made it unusable by\n    #the original numpy functions. Putting them first makes it work.\n    \n    # Because we had to subclass numpy.ndarray, the original methods get\n    # stuck in an infinite loop (max. recursion depth exceeded errors). So,\n    # we instead grab the reference to the original ndarray object.\n    if method == \"slice\":\n        r = np.ndarray.__acornext__.__getslice__(self, *items)\n    else:\n        r = np.ndarray.__acornext__.__getitem__(self, *items)\n        \n    if not (decorating or streamlining):\n        from acorn.logging.decoration import (pre, post, _fqdn)\n        if method == \"slice\":\n            fqdn = \"numpy.ndarray.__getslice__\"\n        else:\n            fqdn = \"numpy.ndarray.__getitem__\"\n        preres = pre(fqdn, np.ndarray, 5, self, *items)\n        entry, bound, ekey = preres\n        # This method can trick acorn into thinking that it is a bound\n        # method. We want it to behave like it's not.\n        post(fqdn, \"numpy\", r, entry, np.ndarray, ekey)\n    return r", "response": "This method is used to get either a slice or an item from an array."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nquery for the most voted messages sorting by the sum of voted and after by date.", "response": "def get_queryset(self):\n        \"\"\"Query for the most voted messages sorting by the sum of\n        voted and after by date.\"\"\"\n\n        queryset = super(MostVotedManager, self).get_queryset()\n\n        sql = \"\"\"\n            SELECT\n                count(sav.id)\n            FROM\n                colab_superarchives_vote AS sav\n            WHERE\n                colab_superarchives_message.id = sav.message_id\n        \"\"\"\n\n        messages = queryset.extra(\n            select={\n                'vote_count': sql,\n            }\n        )\n        return messages.order_by('-vote_count', 'received_time')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parser_options():\n    #We have two options: get some of the details from the config file,\n    import argparse\n    from acorn import base\n    pdescr = \"ACORN setup and custom configuration\"\n    parser = argparse.ArgumentParser(parents=[base.bparser], description=pdescr)\n    for arg, options in script_options.items():\n        parser.add_argument(arg, **options)\n        \n    args = base.exhandler(examples, parser)\n    if args is None:\n        return\n\n    return args", "response": "Parses the options and arguments from the command line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning custom configuration steps for the packages that ship with support in acorn.", "response": "def _conf_packages(args):\n    \"\"\"Runs custom configuration steps for the packages that ship with support\n    in acorn.\n    \"\"\"\n    from acorn.config import config_dir\n    from os import path\n    from acorn.base import testmode\n    target = config_dir(True)\n    alternate = path.join(path.abspath(path.expanduser(\"~\")), \".acorn\")\n    if not testmode and target != alternate:# pragma: no cover\n        msg.err(\"Could not configure custom ~/.acorn directory.\")\n        exit(0)\n\n    from acorn.utility import reporoot\n    from glob import glob\n    from os import chdir, getcwd\n    from shutil import copy\n    current = getcwd()\n    source = path.join(reporoot, \"acorn\", \"config\")\n    chdir(source)\n    count = 0\n\n    #For the unit testing, we don't clobber the local directory, so the copies\n    #are disabled.\n    for json in glob(\"*.json\"):\n        if not testmode:# pragma: no cover\n            copy(json, target)\n        count += 1\n    for cfg in glob(\"*.cfg\"):\n        if not testmode:# pragma: no cover\n            copy(cfg, target)\n        count += 1\n\n    #Switch the directory back to what it was.\n    chdir(current)        \n    msg.okay(\"Copied {0:d} package files to {1}.\".format(count, target))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _run_configure(subcmd, args):\n    maps = {\n        \"packages\": _conf_packages\n        }\n    if subcmd in maps:\n        maps[subcmd](args)\n    else:\n        msg.warn(\"'configure' sub-command {} is not supported.\".format(subcmd))", "response": "Runs the configuration step for the specified sub - command."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun the acorn setup or configuration commands.", "response": "def run(args):\n    \"\"\"Runs the acorn setup/configuration commands.\n    \"\"\"\n    if args is None:\n        return\n    \n    cmd = args[\"commands\"][0]\n    if cmd == \"configure\":\n        if len(args[\"commands\"]) < 2:# pragma: no cover\n            msg.err(\"'configure' command requires a second, sub-command \"\n                    \"parameter. E.g., `acorn.py configure packages`.\")\n            exit(0)\n\n        subcmd = args[\"commands\"][1]\n        _run_configure(subcmd, args)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if all children of this node are elements or whitespace - only text nodes.", "response": "def _check_for_legal_children(self, name, elt, mustqualify=1):\n        '''Check if all children of this node are elements or whitespace-only\n        text nodes.\n        '''\n        inheader = name == \"Header\"\n        for n in _children(elt):\n            t = n.nodeType\n            if t == _Node.COMMENT_NODE: continue\n            if t != _Node.ELEMENT_NODE:\n                if t == _Node.TEXT_NODE and n.nodeValue.strip() == \"\":\n                    continue\n                raise ParseException(\"Non-element child in \" + name, \n                        inheader, elt, self.dom)\n            if mustqualify and not n.namespaceURI:\n                raise ParseException('Unqualified element \"' + \\\n                        n.nodeName + '\" in ' + name, inheader, elt, self.dom)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nraise an exception if any of the list descendants are PI nodes.", "response": "def _check_for_pi_nodes(self, list, inheader):\n        '''Raise an exception if any of the list descendants are PI nodes.\n        '''\n        list = list[:]\n        while list:\n            elt = list.pop()\n            t = elt.nodeType\n            if t == _Node.PROCESSING_INSTRUCTION_NODE:\n                raise ParseException('Found processing instruction \"<?' + \\\n                        elt.nodeName + '...>\"',\n                        inheader, elt.parentNode, self.dom)\n            elif t == _Node.DOCUMENT_TYPE_NODE:\n                raise ParseException('Found DTD', inheader,\n                        elt.parentNode, self.dom)\n            list += _children(elt)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef FindLocalHREF(self, href, elt, headers=1):\n        '''Find a local HREF in the data elements.\n        '''\n        if href[0] != '#':\n            raise EvaluateException(\n                'Absolute HREF (\"%s\") not implemented' % href,\n                self.Backtrace(elt))\n        frag = href[1:]\n        # Already found?\n        e = self.id_cache.get(frag)\n        if e: return e\n        # Do a breadth-first search, in the data first.  Most likely\n        # to find multi-ref targets shallow in the data area.\n        list = self.data_elements[:] + [self.body_root]\n        if headers: list.extend(self.header_elements)\n        while list:\n            e = list.pop()\n            if e.nodeType == _Node.ELEMENT_NODE:\n                nodeid = _find_id(e)\n                if nodeid:\n                    self.id_cache[nodeid] = e\n                    if nodeid == frag: return e\n            list += _children(e)\n        raise EvaluateException('''Can't find node for HREF \"%s\"''' % href,\n                self.Backtrace(elt))", "response": "Find a local HREF in the data area."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of all elements intended for these actor ( s.", "response": "def GetMyHeaderElements(self, actorlist=None):\n        '''Return a list of all elements intended for these actor(s).\n        '''\n        if actorlist is None:\n            actorlist = [None, SOAP.ACTOR_NEXT]\n        else:\n            actorlist = list(actorlist) + [None, SOAP.ACTOR_NEXT]\n        return [ E for E in self.header_elements\n                if _find_actor(E) in actorlist ]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a dictionary of all the namespace attributes for the indicated element. The dictionaries are cached and we recurse up the tree as necessary.", "response": "def GetElementNSdict(self, elt):\n        '''Get a dictionary of all the namespace attributes for the indicated\n        element.  The dictionaries are cached, and we recurse up the tree\n        as necessary.\n        '''\n        d = self.ns_cache.get(id(elt))\n        if not d:\n            if elt != self.dom: d = self.GetElementNSdict(elt.parentNode)\n            for a in _attrs(elt):\n                if a.namespaceURI == XMLNS.BASE:\n                    if a.localName == \"xmlns\":\n                        d[''] = a.nodeValue\n                    else:\n                        d[a.localName] = a.nodeValue\n            self.ns_cache[id(elt)] = d\n        return d.copy()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef IsAFault(self):\n        '''Is this a fault message?\n        '''\n        e = self.body_root\n        if not e: return 0\n        return e.namespaceURI == SOAP.ENV and e.localName == 'Fault'", "response": "Is this a fault message?"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef WhatMustIUnderstand(self):\n        '''Return a list of (uri,localname) tuples for all elements in the\n        header that have mustUnderstand set.\n        '''\n        return [ ( E.namespaceURI, E.localName )\n                for E in self.header_elements if _find_mu(E) == \"1\" ]", "response": "Return a list of ( uri localName ) tuples for all elements in the the\n        header that have mustUnderstand set."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of URI s of all the actor attributes found in the header.", "response": "def WhatActorsArePresent(self):\n        '''Return a list of URI's of all the actor attributes found in\n        the header.  The special actor \"next\" is ignored.\n        '''\n        results = []\n        for E in self.header_elements:\n            a = _find_actor(E)\n            if a not in [ None, SOAP.ACTOR_NEXT ]: results.append(a)\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ParseHeaderElements(self, ofwhat):\n        '''Returns a dictionary of pyobjs.\n        ofhow -- list of typecodes w/matching nspname/pname to the header_elements.\n        '''\n        d = {}\n        lenofwhat = len(ofwhat)\n        c, crange = self.header_elements[:], range(len(self.header_elements))\n        for i,what in [ (i, ofwhat[i]) for i in range(lenofwhat) ]:\n            if isinstance(what, AnyElement): \n                raise EvaluateException, 'not supporting <any> as child of SOAP-ENC:Header'\n\n            v = []\n            occurs = 0\n            namespaceURI,tagName = what.nspname,what.pname\n            for j,c_elt in [ (j, c[j]) for j in crange if c[j] ]:\n                prefix,name = SplitQName(c_elt.tagName)\n                nsuri = _resolve_prefix(c_elt, prefix)\n                if tagName == name and namespaceURI == nsuri:\n                    pyobj = what.parse(c_elt, self)\n                else:\n                    continue\n                v.append(pyobj)\n                c[j] = None\n            if what.minOccurs > len(v) > what.maxOccurs:\n               raise EvaluateException, 'number of occurances(%d) doesnt fit constraints (%d,%s)'\\\n                   %(len(v),what.minOccurs,what.maxOccurs)\n            if what.maxOccurs == 1:\n                if len(v) == 0: v = None\n                else: v = v[0]\n            d[(what.nspname,what.pname)] = v\n        return d", "response": "Returns a dictionary of pyobjs.\n        ofhow -- list of typecodes w/ matching nspname / pname to the header_elements."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _repr_html_(self):\n        # Use StringIO to avoid a large number of memory allocations with string concat\n        with io.StringIO() as out:\n            out.write('<{tag}'.format(tag=escape(self.tag_name)))\n            if self.style:\n                # Important values are in double quotes - cgi.escape only escapes double quotes, not single quotes!\n                out.write(' style=\"{css}\"'.format(\n                    css=escape(self._to_inline_css(self.style))))\n\n            for k, v in self.attributes.items():\n                k2 = k\n                if k2 == 'class_':\n                    k2 = 'class'\n                # Important values are in double quotes - cgi.escape only escapes double quotes, not single quotes!\n                if isinstance(v, string_types):\n                    out.write(' {key}=\"{value}\"'.format(\n                        key=escape(k2), value=escape(v)))\n                if isinstance(v, bool) and v:\n                    out.write(' {key}'.format(key=escape(k2)))\n            out.write('>')\n\n            for c in self.children:\n                if isinstance(c, string_types):\n                    out.write(escape(safe_unicode(c)))\n                else:\n                    out.write(c._repr_html_())\n\n            out.write('</{tag}>'.format(tag=escape(self.tag_name)))\n\n            return out.getvalue()", "response": "Return HTML representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndo the UNIX double-fork magic, see Stevens' \"Advanced Programming in the UNIX Environment\" for details (ISBN 0201563177) http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16", "response": "def daemonize(self):\n        \"\"\"\n        do the UNIX double-fork magic, see Stevens' \"Advanced\n        Programming in the UNIX Environment\" for details (ISBN 0201563177)\n        http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16\n        \"\"\"\n        try:\n            pid = os.fork()\n            if pid > 0:\n                # exit first parent\n                sys.exit(0)\n        except OSError as e:\n            self.logger.error(\"Fork #1 failed: %d (%s)\\n\" % (e.errno, e.strerror))\n            sys.exit(1)\n\n        # decouple from parent environment\n        os.chdir(\"/\")\n        os.setsid()\n        os.umask(0)\n\n        # do second fork\n        try:\n            pid = os.fork()\n            if pid > 0:\n                # exit from second parent\n                sys.exit(0)\n        except OSError as e:\n            self.logger.error(\"Fork #2 failed: %d (%s)\\n\" % (e.errno, e.strerror))\n            sys.exit(1)\n\n        # write pidfile\n        atexit.register(self.delpid)\n        pid = str(os.getpid())\n        with open(self.pidfile,'w+') as f:\n            f.write(\"%s\\n\" % pid)\n\n        sys.stdout = LoggerProxy(self.logger.info)\n        sys.stderr = LoggerProxy(self.logger.error)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstop the daemon process", "response": "def stop(self):\n        \"\"\"\n        Stop the daemon\n        \"\"\"\n        # Get the pid from the pidfile\n        pid = self.get_pid()\n\n        if not pid:\n            message = \"Pidfile %s does not exist. Daemon not running?\" % self.pidfile\n            self.logger.error(message)\n            return message # not an error in a restart\n\n        # Try killing the daemon process\n        try:\n            while 1:\n                os.kill(pid, SIGTERM)\n                time.sleep(0.1)\n        except OSError as err:\n            err = str(err)\n            if err.find(\"No such process\") > 0:\n                if os.path.exists(self.pidfile):\n                    os.remove(self.pidfile)\n            else:\n                self.logger.error(err)\n                sys.exit(1)\n\n        return 'Daemon is stopped'"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef vignettingEq(xxx_todo_changeme, f=100, alpha=0, Xi=0, tau=0, cx=50, cy=50):\r\n    '''\r\n    Vignetting equation using the KARL-WEISS-MODEL\r\n    see http://research.microsoft.com/en-us/people/stevelin/vignetting.pdf\r\n\r\n    f - focal length\r\n    alpha - coefficient in the geometric vignetting factor\r\n    Xi - tilt factor of a planar scene\r\n    tau - rotation angle of a planar scene\r\n    cx - image center, x\r\n    cy - image center, y\r\n    '''\r\n    (x, y) = xxx_todo_changeme\r\n    dist = ((x - cx)**2 + (y - cy)**2)**0.5\r\n\r\n    A = old_div(1.0, (1 + (old_div(dist, f))**2)**2)\r\n    G = (1 - alpha * dist)\r\n    T = np.cos(tau) * (1 + (old_div(np.tan(tau), f))\r\n                       * (x * np.sin(Xi) - y * np.cos(Xi)))**3\r\n\r\n    return A * G * T", "response": "Returns the vignetting equation of a todo change."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndeploy a file to the Artifactory BEL namespace.", "response": "def _deploy_helper(filename, module_name, get_module, get_today_fn, hash_check=True, auth=None):\n    \"\"\"Deploys a file to the Artifactory BEL namespace cache\n\n    :param str filename: The physical path\n    :param str module_name: The name of the module to deploy to\n    :param tuple[str] auth: A pair of (str username, str password) to give to the auth keyword of the constructor of\n                            :class:`artifactory.ArtifactoryPath`. Defaults to the result of :func:`get_arty_auth`.\n    :return: The resource path, if it was deployed successfully, else none.\n    :rtype: Optional[str]\n    \"\"\"\n    path = ArtifactoryPath(\n        get_module(module_name),\n        auth=get_arty_auth() if auth is None else auth\n    )\n    path.mkdir(exist_ok=True)\n\n    if hash_check:\n        deployed_semantic_hashes = {\n            get_bel_resource_hash(subpath.as_posix())\n            for subpath in path\n        }\n\n        semantic_hash = get_bel_resource_hash(filename)\n\n        if semantic_hash in deployed_semantic_hashes:\n            return  # Don't deploy if it's already uploaded\n\n    target = path / get_today_fn(module_name)\n    target.deploy_file(filename)\n\n    log.info('deployed %s', module_name)\n\n    return target.as_posix()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef deploy_namespace(filename, module_name, hash_check=True, auth=None):\n    return _deploy_helper(\n        filename,\n        module_name,\n        get_namespace_module_url,\n        get_namespace_today,\n        hash_check=hash_check,\n        auth=auth\n    )", "response": "Deploy a file to the BEL namespace cache."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef deploy_annotation(filename, module_name, hash_check=True, auth=None):\n    return _deploy_helper(\n        filename,\n        module_name,\n        get_annotation_module_url,\n        get_annotation_today,\n        hash_check=hash_check,\n        auth=auth\n    )", "response": "Deploy a file to the BEL annotation cache."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndeploy a file to the BEL knowledge cache.", "response": "def deploy_knowledge(filename, module_name, auth=None):\n    \"\"\"Deploy a file to the Artifactory BEL knowledge cache.\n\n    :param str filename: The physical file path\n    :param str module_name: The name of the module to deploy to\n    :param tuple[str] auth: A pair of (str username, str password) to give to the auth keyword of the constructor of\n                            :class:`artifactory.ArtifactoryPath`. Defaults to the result of :func:`get_arty_auth`.\n    :return: The resource path, if it was deployed successfully, else none.\n    :rtype: Optional[str]\n    \"\"\"\n    return _deploy_helper(\n        filename,\n        module_name,\n        get_knowledge_module_url,\n        get_knowledge_today,\n        hash_check=False,\n        auth=auth\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef deploy_directory(directory, auth=None):\n    for file in os.listdir(directory):\n        full_path = os.path.join(directory, file)\n\n        if file.endswith(BELANNO_EXTENSION):\n            name = file[:-len(BELANNO_EXTENSION)]\n            log.info('deploying annotation %s', full_path)\n            deploy_annotation(full_path, name, auth=auth)\n\n        elif file.endswith(BELNS_EXTENSION):\n            name = file[:-len(BELNS_EXTENSION)]\n            log.info('deploying namespace %s', full_path)\n            deploy_namespace(full_path, name, auth=auth)\n\n        elif file.endswith(BEL_EXTENSION):\n            name = file[:-len(BEL_EXTENSION)]\n            log.info('deploying knowledge %s', full_path)\n            deploy_knowledge(full_path, name, auth=auth)\n\n        else:\n            log.debug('not deploying %s', full_path)", "response": "Deploy all files in a given directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef export_tree(lookup, tree, path):\n    FILE_PERM = S_IRWXU | S_IRWXG | S_IRWXO\n\n    for name, mode, hexsha in tree.iteritems():\n        dest = os.path.join(path, name)\n\n        if S_ISGITLINK(mode):\n            log.error('Ignored submodule {}; submodules are not yet supported.'\n                      .format(name))\n            # raise ValueError('Does not support submodules')\n        elif S_ISDIR(mode):\n            os.mkdir(dest)\n            os.chmod(dest, 0o0755)\n            export_tree(lookup, lookup(hexsha), dest)\n        elif S_ISLNK(mode):\n            os.symlink(lookup(hexsha).data, dest)\n        elif S_ISREG(mode):\n            with open(dest, 'wb') as out:\n                for chunk in lookup(hexsha).chunked:\n                    out.write(chunk)\n            os.chmod(dest, mode & FILE_PERM)\n        else:\n            raise ValueError('Cannot deal with mode of {:o} from {}'.format(\n                mode, name))", "response": "Exports the given tree object to path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef abook2vcf():\n    from argparse import ArgumentParser, FileType\n    from os.path import expanduser\n    from sys import stdout\n\n    parser = ArgumentParser(description='Converter from Abook to vCard syntax.')\n    parser.add_argument('infile', nargs='?', default=expanduser('~/.abook/addressbook'),\n                        help='The Abook file to process (default: ~/.abook/addressbook)')\n    parser.add_argument('outfile', nargs='?', type=FileType('w'), default=stdout,\n                        help='Output vCard file (default: stdout)')\n    args = parser.parse_args()\n\n    args.outfile.write(Abook(args.infile).to_vcf())", "response": "Command line tool to convert from Abook to vCard"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef vcf2abook():\n    from argparse import ArgumentParser, FileType\n    from sys import stdin\n\n    parser = ArgumentParser(description='Converter from vCard to Abook syntax.')\n    parser.add_argument('infile', nargs='?', type=FileType('r'), default=stdin,\n                        help='Input vCard file (default: stdin)')\n    parser.add_argument('outfile', nargs='?', default=expanduser('~/.abook/addressbook'),\n                        help='Output Abook file (default: ~/.abook/addressbook)')\n    args = parser.parse_args()\n\n    Abook.abook_file(args.infile, args.outfile)", "response": "Command line tool to convert from vCard to Abook"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nappend an address to the Abook addressbook vcard -- vCard to append vcard filename -- unused return the new UID of the appended vcard", "response": "def append_vobject(self, vcard, filename=None):\n        \"\"\"Appends an address to the Abook addressbook\n        vcard -- vCard to append\n        filename -- unused\n        return the new UID of the appended vcard\n        \"\"\"\n        book = ConfigParser(default_section='format')\n        with self._lock:\n            book.read(self._filename)\n            section = str(max([-1] + [int(k) for k in book.sections()]) + 1)\n            Abook.to_abook(vcard, section, book, self._filename)\n            with open(self._filename, 'w') as fp:\n                book.write(fp, False)\n\n        return Abook._gen_uid(book[section])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove an entry from the Abook", "response": "def remove(self, uid, filename=None):\n        \"\"\"Removes an address to the Abook addressbook\n        uid -- UID of the entry to remove\n        \"\"\"\n        book = ConfigParser(default_section='format')\n        with self._lock:\n            book.read(self._filename)\n            del book[uid.split('@')[0]]\n            with open(self._filename, 'w') as fp:\n                book.write(fp, False)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating an entry in the Abook with a new vCard.", "response": "def replace_vobject(self, uid, vcard, filename=None):\n        \"\"\"Updates an address to the Abook addressbook\n        uid -- uid of the entry to replace\n        vcard -- vCard of the new content\n        filename -- unused\n        \"\"\"\n        entry = uid.split('@')[0]\n\n        book = ConfigParser(default_section='format')\n        with self._lock:\n            book.read(self._filename)\n            Abook.to_abook(vcard, entry, book, self._filename)\n            with open(self._filename, 'w') as fp:\n                book.write(fp, False)\n\n        return Abook._gen_uid(self._book[entry])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _gen_addr(entry):\n        return Address(street=entry.get('address', ''),\n                       extended=entry.get('address2', ''),\n                       city=entry.get('city', ''),\n                       region=entry.get('state', ''),\n                       code=entry.get('zip', ''),\n                       country=entry.get('country', ''))", "response": "Generates a vCard Address object from a vCard entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _add_photo(self, card, name):\n        try:\n            photo_file = join(dirname(self._filename), 'photo/%s.jpeg' % name)\n            jpeg = open(photo_file, 'rb').read()\n            photo = card.add('photo')\n            photo.type_param = 'jpeg'\n            photo.encoding_param = 'b'\n            photo.value = jpeg\n        except IOError:\n            pass", "response": "Tries to load a photo and add it to the vCard"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _to_vcard(self, entry):\n        card = vCard()\n\n        card.add('uid').value = Abook._gen_uid(entry)\n        card.add('fn').value = entry['name']\n        card.add('n').value = Abook._gen_name(entry['name'])\n\n        if 'email' in entry:\n            for email in entry['email'].split(','):\n                card.add('email').value = email\n\n        addr_comps = ['address', 'address2', 'city', 'country', 'zip', 'country']\n        if any(comp in entry for comp in addr_comps):\n            card.add('adr').value = Abook._gen_addr(entry)\n\n        if 'other' in entry:\n            tel = card.add('tel')\n            tel.value = entry['other']\n\n        if 'phone' in entry:\n            tel = card.add('tel')\n            tel.type_param = 'home'\n            tel.value = entry['phone']\n\n        if 'workphone' in entry:\n            tel = card.add('tel')\n            tel.type_param = 'work'\n            tel.value = entry['workphone']\n\n        if 'mobile' in entry:\n            tel = card.add('tel')\n            tel.type_param = 'cell'\n            tel.value = entry['mobile']\n\n        if 'nick' in entry:\n            card.add('nickname').value = entry['nick']\n\n        if 'url' in entry:\n            card.add('url').value = entry['url']\n\n        if 'notes' in entry:\n            card.add('note').value = entry['notes']\n\n        self._add_photo(card, entry['name'])\n\n        return card", "response": "Return a vCard of the Abook entry"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_uids(self, filename=None):\n        self._update()\n        return [Abook._gen_uid(self._book[entry]) for entry in self._book.sections()]", "response": "Return a list of UIDs from the current Abook"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_vcards(self):\n        self._update()\n        return [self._to_vcard(self._book[entry]) for entry in self._book.sections()]", "response": "Return a list of vCards"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_vobjects(self, filename, uids=None):\n        self._update()\n\n        if not uids:\n            uids = self.get_uids(filename)\n\n        items = []\n\n        for uid in uids:\n            entry = self._book[uid.split('@')[0]]\n            # TODO add getmtime of photo\n            etag = sha1(str(dict(entry)).encode('utf-8'))\n            items.append((uid, self._to_vcard(entry), '\"%s\"' % etag.hexdigest()))\n        return items", "response": "Return vCards and etags of all Abook entries in uids\n        filename"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_vobject(self, filename=None, uid=None):\n        self._update()\n        return self._to_vcard(self._book[uid.split('@')[0]])", "response": "Return the vObject corresponding to the uid"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _conv_adr(adr, entry):\n        if adr.value.street:\n            entry['address'] = adr.value.street\n        if adr.value.extended:\n            entry['address2'] = adr.value.extended\n        if adr.value.city:\n            entry['city'] = adr.value.city\n        if adr.value.region:\n            entry['state'] = adr.value.region\n        if adr.value.code and adr.value.code != '0':\n            entry['zip'] = adr.value.code\n        if adr.value.country:\n            entry['country'] = adr.value.country", "response": "Converts Abook address format to Abook address format"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _conv_tel_list(tel_list, entry):\n        for tel in tel_list:\n            if not hasattr(tel, 'TYPE_param'):\n                entry['other'] = tel.value\n            elif tel.TYPE_param.lower() == 'home':\n                entry['phone'] = tel.value\n            elif tel.TYPE_param.lower() == 'work':\n                entry['workphone'] = tel.value\n            elif tel.TYPE_param.lower() == 'cell':\n                entry['mobile'] = tel.value", "response": "Converts a list of Telephone numbers to Abook phone types"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a vCard to Abook", "response": "def to_abook(card, section, book, bookfile=None):\n        \"\"\"Converts a vCard to Abook\"\"\"\n        book[section] = {}\n        book[section]['name'] = card.fn.value\n\n        if hasattr(card, 'email'):\n            book[section]['email'] = ','.join([e.value for e in card.email_list])\n\n        if hasattr(card, 'adr'):\n            Abook._conv_adr(card.adr, book[section])\n\n        if hasattr(card, 'tel_list'):\n            Abook._conv_tel_list(card.tel_list, book[section])\n\n        if hasattr(card, 'nickname') and card.nickname.value:\n            book[section]['nick'] = card.nickname.value\n\n        if hasattr(card, 'url') and card.url.value:\n            book[section]['url'] = card.url.value\n\n        if hasattr(card, 'note') and card.note.value:\n            book[section]['notes'] = card.note.value\n\n        if hasattr(card, 'photo') and bookfile:\n            try:\n                photo_file = join(dirname(bookfile), 'photo/%s.%s' % (card.fn.value, card.photo.TYPE_param))\n                open(photo_file, 'wb').write(card.photo.value)\n            except IOError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef abook_file(vcard, bookfile):\n        book = ConfigParser(default_section='format')\n\n        book['format'] = {}\n        book['format']['program'] = 'abook'\n        book['format']['version'] = '0.6.1'\n\n        for (i, card) in enumerate(readComponents(vcard.read())):\n            Abook.to_abook(card, str(i), book, bookfile)\n        with open(bookfile, 'w') as fp:\n            book.write(fp, False)", "response": "Write a new Abook file with the given vcards"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves all empty Dicts and falsy stuff inside the Dict.", "response": "def prune(self, prune_zero=False, prune_empty_list=True):\n        \"\"\"\n        Removes all empty Dicts and falsy stuff inside the Dict.\n        E.g\n        >>> a = Dict()\n        >>> a.b.c.d\n        {}\n        >>> a.a = 2\n        >>> a\n        {'a': 2, 'b': {'c': {'d': {}}}}\n        >>> a.prune()\n        >>> a\n        {'a': 2}\n        Set prune_zero=True to remove 0 values\n        E.g\n        >>> a = Dict()\n        >>> a.b.c.d = 0\n        >>> a.prune(prune_zero=True)\n        >>> a\n        {}\n        Set prune_empty_list=False to have them persist\n        E.g\n        >>> a = Dict({'a': []})\n        >>> a.prune()\n        >>> a\n        {}\n        >>> a = Dict({'a': []})\n        >>> a.prune(prune_empty_list=False)\n        >>> a\n        {'a': []}\n        \"\"\"\n        for key, val in list(self.items()):\n            if ((not val) and ((val != 0) or prune_zero) and\n                    not isinstance(val, list)):\n                del self[key]\n            elif isinstance(val, Dict):\n                val.prune(prune_zero, prune_empty_list)\n                if not val:\n                    del self[key]\n            elif isinstance(val, (list, tuple)):\n                new_iter = self._prune_iter(val, prune_zero, prune_empty_list)\n                if (not new_iter) and prune_empty_list:\n                    del self[key]\n                else:\n                    if isinstance(val, tuple):\n                        new_iter = tuple(new_iter)\n                    self[key] = new_iter"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates - Updates the internal state of the object with the given parameters", "response": "def update(self, *args, **kwargs):\n        \"\"\" update() method will *recursively* update nested dict:\n\n            >>> d=Dict({'a':{'b':{'c':3,'d':4},'h':4}})\n            >>> d.update({'a':{'b':{'c':'888'}}})\n            >>> d\n            {'a': {'b': {'c': '888', 'd': 4}, 'h': 4}}\n\n            please use update_dict() if you do not want this behaviour\n        \"\"\"\n        for arg in args:\n            if not arg:\n                continue\n            elif isinstance(arg, dict):\n                for k, v in arg.items():\n                    self._update_kv(k, v)\n            elif isinstance(arg, (list, tuple)) and (not isinstance(arg[0], (list, tuple))):\n                k = arg[0]\n                v = arg[1]\n                self._update_kv(k, v)\n            elif isinstance(arg, (list, tuple)) or isgenerator(arg):\n                for k, v in arg:\n                    self._update_kv(k, v)\n            else:\n                raise TypeError(\"update does not understand \"\n                                \"{0} types\".format(type(arg)))\n\n        for k, v in kwargs.items():\n            self._update_kv(k, v)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extract_keys(self,key_list):\n        if isinstance(key_list,basestring):\n            key_list = key_list.split(',')\n        return type(self)([ (k,self[k]) for k in key_list if k in self ])", "response": "Extract keys from a list of keys."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a new dictionary with only the keys in key_list", "response": "def exclude_keys(self,key_list):\n        \"\"\" >>> d = {'a':1,'b':2,'c':3}\n            >>> print d.exclude_keys('b,c,d')\n            >>> {'a':1}\n            >>> d = {'a':1,'b':2,'c':3}\n            >>> print d.exclude_keys(['b','c','d'])\n            >>> {'a':1} \"\"\"\n        if isinstance(key_list,basestring):\n            key_list = key_list.split(',')\n        return type(self)([ (k,self[k]) for k in self if k not in key_list ])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_and_check(self, base_settings, prompt=None):\n        checker = Checker(self.file_name, self.section, self.registry, self.strategy_type, prompt)\n        settings = self.load(base_settings)\n        if checker.check(settings):\n            return settings, True\n        return None, False", "response": "Load settings and check them."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload the local settings from file with base_settings.", "response": "def load(self, base_settings):\n        \"\"\"Merge local settings from file with ``base_settings``.\n\n        Returns a new settings dict containing the base settings and the\n        loaded settings. Includes:\n\n            - base settings\n            - settings from extended file(s), if any\n            - settings from file\n\n        \"\"\"\n        is_valid_key = lambda k: k.isupper() and not k.startswith('_')\n\n        # Base settings, including `LocalSetting`s, loaded from the\n        # Django settings module.\n        valid_keys = (k for k in base_settings if is_valid_key(k))\n        base_settings = DottedAccessDict((k, base_settings[k]) for k in valid_keys)\n\n        # Settings read from the settings file; values are unprocessed.\n        settings_from_file = self.strategy.read_file(self.file_name, self.section)\n        settings_from_file.pop('extends', None)\n\n        # The fully resolved settings.\n        settings = Settings(base_settings)\n\n        settings_names = []\n        settings_not_decoded = set()\n\n        for name, value in settings_from_file.items():\n            for prefix in ('PREPEND.', 'APPEND.', 'SWAP.'):\n                if name.startswith(prefix):\n                    name = name[len(prefix):]\n                    name = '{prefix}({name})'.format(**locals())\n                    break\n\n            settings_names.append(name)\n\n            # Attempt to decode raw values. Errors in decoding at this\n            # stage are ignored.\n            try:\n                value = self.strategy.decode_value(value)\n            except ValueError:\n                settings_not_decoded.add(name)\n\n            settings.set_dotted(name, value)\n\n            # See if this setting corresponds to a `LocalSetting`. If\n            # so, note that the `LocalSetting` has a value by putting it\n            # in the registry. This also makes it easy to retrieve the\n            # `LocalSetting` later so its value can be set.\n            current_value = base_settings.get_dotted(name, None)\n            if isinstance(current_value, LocalSetting):\n                self.registry[current_value] = name\n\n        # Interpolate values of settings read from file. When a setting\n        # that couldn't be decoded previously is encountered, its post-\n        # interpolation value will be decoded.\n        for name in settings_names:\n            value = settings.get_dotted(name)\n            value, _ = self._interpolate_values(value, settings)\n            if name in settings_not_decoded:\n                value = self.strategy.decode_value(value)\n            settings.set_dotted(name, value)\n\n        # Interpolate base settings.\n        self._interpolate_values(settings, settings)\n\n        self._interpolate_keys(settings, settings)\n\n        self._prepend_extras(settings, settings.pop('PREPEND', None))\n        self._append_extras(settings, settings.pop('APPEND', None))\n        self._swap_list_items(settings, settings.pop('SWAP', None))\n        self._import_from_string(settings, settings.pop('IMPORT_FROM_STRING', None))\n\n        for local_setting, name in self.registry.items():\n            local_setting.value = settings.get_dotted(name)\n\n        return settings"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninjecting settings into value.", "response": "def _inject(self, value, settings):\n        \"\"\"Inject ``settings`` into ``value``.\n\n        Go through ``value`` looking for ``{{NAME}}`` groups and replace\n        each group with the value of the named item from ``settings``.\n\n        Args:\n            value (str): The value to inject settings into\n            settings: An object that provides the dotted access interface\n\n        Returns:\n            (str, bool): The new value and whether the new value is\n                different from the original value\n\n        \"\"\"\n        assert isinstance(value, string_types), 'Expected str; got {0.__class__}'.format(value)\n\n        begin, end = '{{', '}}'\n\n        if begin not in value:\n            return value, False\n\n        new_value = value\n        begin_pos, end_pos = 0, None\n        len_begin, len_end = len(begin), len(end)\n        len_value = len(new_value)\n\n        while begin_pos < len_value:\n            # Find next {{.\n            begin_pos = new_value.find(begin, begin_pos)\n\n            if begin_pos == -1:\n                break\n\n            # Save everything before {{.\n            before = new_value[:begin_pos]\n\n            # Find }} after {{.\n            begin_pos += len_begin\n            end_pos = new_value.find(end, begin_pos)\n            if end_pos == -1:\n                raise ValueError('Unmatched {begin}...{end} in {value}'.format(**locals()))\n\n            # Get name between {{ and }}, ignoring leading and trailing\n            # whitespace.\n            name = new_value[begin_pos:end_pos]\n            name = name.strip()\n\n            if not name:\n                raise ValueError('Empty name in {value}'.format(**locals()))\n\n            # Save everything after }}.\n            after_pos = end_pos + len_end\n            try:\n                after = new_value[after_pos:]\n            except IndexError:\n                # Reached end of value.\n                after = ''\n\n            # Retrieve string value for named setting (the \"injection\n            # value\").\n            try:\n                injection_value = settings.get_dotted(name)\n            except KeyError:\n                raise KeyError('{name} not found in {settings}'.format(**locals()))\n\n            if not isinstance(injection_value, string_types):\n                injection_value = self.strategy.encode_value(injection_value)\n\n            # Combine before, inject value, and after to get the new\n            # value.\n            new_value = ''.join((before, injection_value, after))\n\n            # Continue after injected value.\n            begin_pos = len(before) + len(injection_value)\n            len_value = len(new_value)\n\n        return new_value, (new_value != value)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_reporoot():\n    from os import path\n    import acorn\n    medpath = path.abspath(acorn.__file__)\n    return path.dirname(path.dirname(medpath))", "response": "Returns the absolute path to the repo root directory on the current\n    system."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the absolute path to the specified file or folder relative to the repository root.", "response": "def abspath(fpath):\n    \"\"\"Returns the absolute path to the specified file/folder *relative to the\n    repository root*.\n\n    Args:\n        fpath (str): path to a file or folder; doesn't need to exist.\n    \"\"\"\n    from os import path, getcwd, chdir\n    original = getcwd()\n    chdir(reporoot)\n    result = path.abspath(path.expanduser(fpath))\n    chdir(original)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters a flag of a parent command", "response": "def registerParentFlag(self, optionName, value):\n        '''Register a flag of a parent command\n\n        :Parameters:\n            - `optionName`: String. Name of option\n            - `value`: Mixed. Value of parsed flag`\n        '''\n        self.parentFlags.update({optionName: value})\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting datetime. datetime object between timezones", "response": "def _convert(value, tzto, defaulttz):\n    \"\"\"Convert datetime.datetime object between timezones\"\"\"\n    if not isinstance(value, datetime):\n        raise ValueError('value must be a datetime.datetime object')\n\n    if value.tzinfo is None:\n        value = value.replace(tzinfo=defaulttz)\n\n    return value.astimezone(tzto)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_local(value, defaulttz=None):\n    if defaulttz is None:\n        defaulttz = tzutc()\n    return _convert(value, tzlocal(), defaulttz)", "response": "Convert datetime. datetime time to local time zone\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting datetime. datetime time to UTC", "response": "def to_utc(value, defaulttz=None):\n    \"\"\"Convert datetime.datetime time to UTC\n\n    If value doesn't have tzinfo, then defaulttz is set.\n    Default value of defaulttz is local time zone.\n    \"\"\"\n    if defaulttz is None:\n        defaulttz = tzlocal()\n    return _convert(value, tzutc(), defaulttz)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nyield a reduced set of kwargs of only the valid keyword arguments for the function f", "response": "def filterKWArgsForFunc(kwargs, f):\n    '''Yield a reduced set of kwargs of only the valid keyword arguments for the function / constructor f'''\n    return dict([(k, v) for k, v in kwargs.iteritems() if k in _getValidArgList(f)])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef flatten(lst):\n    def flatten_aux(item, accumulated):\n        if type(item) != list:\n            accumulated.append(item)\n        else:\n            for l in item:\n                flatten_aux(l, accumulated)\n    accumulated = []\n    flatten_aux(lst,accumulated)\n    return accumulated", "response": "flatten a list of items into a single list"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the mean and precision of the cholesky factor of the precision matrix and the step size of the next element in the sequence.", "response": "def update_params(state, t):\n    \"\"\"\n    Update parameters\n        updates mean and precision to the step size\n    Inputs:\n        state :\n            mu :\n                mean\n            L  :\n                cholesky factor of the precision matrix\n        t : \n            step size\n    Outputs:\n        mu :\n            updated mean\n        L  :\n            updated cholesky factor of the precision matrix  \n    \"\"\"\n    mu = (1.-t)*state['x'] + t*state['mu']\n    L  = state['L'] / np.sqrt(2.*t - t**2)\n    return mu, L"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef log_K(Z, X, t):\n    m, L = update_params(X, t)\n    z = Z['x']\n    return np.log(det(L))-la.norm(np.dot(L.T,z-m))**2/2.", "response": "Log of the proposal probability density function for gnm\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef multi_normal(X, t):\n    m, L = update_params(X, t)\n    z = np.random.standard_normal(np.shape(m)) # generate i.i.d N(0,1)\n    return  la.solve(L.T,z)+m", "response": "Multivariate normal sampler:\n        Generates normal samples with mean m, precision matrix LL' \n    Inputs:\n        x : \n            propose from \n    Outputs:\n        normal with mean m and precision LL'"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef det(L):\n    size_L = L.shape\n    if np.size(L) == 1:\n        return np.array(L)\n    else:    \n        try: \n            assert np.all(np.tril(L)==L)\n        except AssertionError:\n            print 'Error: Input is not a lower triangular matrix.'\n            return 0\n        try:\n            assert size_L[0] == size_L[1]\n        except AssertionError:\n            print 'Error: Not a square matrix.'\n            return 0\n        det_L = 1.\n        for i in xrange(size_L[1]):\n            det_L = det_L*L[i,i]\n        return det_L", "response": "Compute the determinant given a lower triangular matrix L."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nthird order approximation to find the minimum of the function f : function to be optimized over Inputs : t : previous step size f_0 : f(0), function value at 0 d_f_0: f'(0), the derivative of the function at 0 f_t : f(t), function value at t d_f_t : f'(t), the derivative of the function at t t1 : step size reduction if minimum is at 0 or it can't be found t2 : step size reduction if minimum is at 1 Outputs : alpha_new : the new step size that minimizes the function", "response": "def optimize(t, f_0, d_f_0, f_t, d_f_t, t1=0.05, t2=0.5):\n    \"\"\"\n    Third order approximation to find the minimum of the function\n        f : function to be optimized over\n    Inputs :  \n        t : \n            previous step size\n        f_0 : f(0),\n            function value at 0\n        d_f_0: f'(0),\n            the derivative of the function at 0\n        f_t : f(t),\n            function value at t\n        d_f_t : f'(t),\n            the derivative of the function at t\n        t1 : \n            step size reduction if minimum is at 0 or it can't be found  \n        t2 : \n            step size reduction if minimum is at 1\n    Outputs :\n        alpha_new : \n            the new step size that minimizes the function\n    \"\"\"\n    if t <= 0 :\n        print(\"Error: please enter non-negative t\")\n        return t\n\n    a = (t*d_f_t-2*f_t+2*f_0+t*d_f_0)/(t**3)\n    b = (f_t-f_0-t*d_f_0)/(t**2)\n    c = d_f_0\n    A = 3*a\n    B = b-t*a\n    C = B**2-A*c\n\n    if C == 0. :\n        if c>0 or d_f_t>0 :\n            t_new = t1*t\n        else :\n            t_new = t2*t\n    elif A == 0 :\n        t_new = -c/2./B \n    elif C > 0 :\n        t_new = (-B+np.sqrt(C))/A\n    else : \n        t_new = t1*t\n\n    # check the bounds on new step size\n    if   t_new < t1*t :\n        t_new = t1*t\n    elif t_new > t2*t :\n        t_new = t2*t\n\n    return t_new"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprocess the request and return the appropriate HTTP status code.", "response": "def process_request(self, req, resp):\n        \"\"\" Process the request before routing it.\n\n        A summary of the rational for the different behavior\n        is shown below.\n\n        Expect Header\n        ~~~~~~~~~~~~~\n\n        Our API does not currently support any implementation\n        of the Expect header. This mostly impacts clients that\n        use the `100-continue` expectation. Per the spec a\n        response code of HTTP 417 should force the client to\n        retry without the header.\n\n            tools.ietf.org/html/rfc7231#section-5.1.1\n\n        URI Too Long\n        ~~~~~~~~~~~~\n\n        99.99% of the time this is a protection mechanism\n        against assholes doing asshole'ish stuff. 0.01% of\n        the time it's a bug.\n\n        Message Body Length\n        ~~~~~~~~~~~~~~~~~~~\n\n        RFC 7230 section 3.3.3 has everything you really need\n        to know. Per the spec a Content-Length header & a\n        Transfer-Encoding header are mutaully exclusive & if\n        neither are provided then return a 411 indicating a\n        Content-Length header is required.\n\n        NOTE: falcon already raises an exception for invalid\n              Content-Length values so we don't need to type\n              check it.\n        \"\"\"\n\n        max_length = goldman.config.MAX_URI_LENGTH\n\n        if req.expect:\n            abort(exceptions.ExpectationUnmet)\n        elif len(req.uri) > max_length:\n            abort(exceptions.URITooLong(max_length))\n        elif req.content_required:\n            # content_length could be zero\n            has_content_length = req.content_length is not None\n            transfer_encoding = req.get_header('transfer-encoding')\n\n            if has_content_length and transfer_encoding:\n                abort(exceptions.InvalidRequestHeader(**{\n                    'detail': 'Your request has both Transfer-Encoding & '\n                              'Content-Length headers which is a violation '\n                              'of RFC 7230. This is likely a bug in your '\n                              'client & your request cannot proceed as is.',\n                    'links': 'tools.ietf.org/html/rfc7230#section-3.3.3',\n                }))\n            elif transfer_encoding:\n                pass\n            elif not has_content_length:\n                abort(exceptions.ContentLengthRequired)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef process_response(self, req, resp, resource):\n\n        if not resource and resp.status == falcon.HTTP_404:\n            abort(exceptions.RouteNotFound)\n        elif resp.status == falcon.HTTP_405:\n            abort(exceptions.MethodNotAllowed)", "response": "Post-processing of the response (after routing).\n\n        Some fundamental errors can't be intercepted any other\n        way in Falcon. These include 404 when the route isn't found\n        & 405 when the method is bunk. Falcon will try to send its\n        own errors.\n\n        In these cases, intercept them & replace them with our\n        JSON API compliant version.\n\n        TIP: If no route could be determined then the resource\n             will be None."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef label(self):\n        '''A human readable label'''\n        if self.__doc__ and self.__doc__.strip():\n            return self.__doc__.strip().splitlines()[0]\n        return humanize(self.__class__.__name__)", "response": "A human readable label"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a human readable label for a method given its name", "response": "def label_for(self, name):\n        '''Get a human readable label for a method given its name'''\n        method = getattr(self, name)\n        if method.__doc__ and method.__doc__.strip():\n            return method.__doc__.strip().splitlines()[0]\n        return humanize(name.replace(self._prefix, ''))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning all tests and run them.", "response": "def run(self):\n        '''\n        Collect all tests to run and run them.\n\n        Each method will be run :attr:`Benchmark.times`.\n        '''\n        tests = self._collect()\n\n        if not tests:\n            return\n\n        self.times\n        self.before_class()\n\n        for test in tests:\n            func = getattr(self, test)\n            results = self.results[test] = Result()\n            self._before(self, test)\n            self.before()\n            for i in range(self.times):\n                self._before_each(self, test, i)\n                result = self._run_one(func)\n                results.total += result.duration\n                if result.success:\n                    results.has_success = True\n                else:\n                    results.has_errors = True\n                self._after_each(self, test, i)\n                if self.debug and not result.success:\n                    results.error = result.result\n                    break\n            self.after()\n            self._after(self, test)\n\n        self.after_class()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef authorizer(self, schemes, resource, action, request_args):\n        if not schemes:\n            return u'', u''\n        for scheme in schemes:\n            if scheme in self.schemes and self.has_auth_params(scheme):\n                cred = Context.format_auth_params(self.schemes[scheme][u'params'])\n                if hasattr(self, 'mfa_token'):\n                    cred = '{}, mfa_token=\"{}\"'.format(cred, self.mfa_token)\n                return scheme, cred\n\n        raise AuthenticationError(self, schemes)", "response": "Construct the Authorization header for a request."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef authorize(self, scheme, **params):\n        if scheme not in self.schemes:\n            return False\n\n        for field, value in iteritems(params):\n            setattr(self, field, value)\n            if field in self.schemes[scheme][u'params'].keys() and value:\n                self.schemes[scheme][u'params'][field] = value\n\n        return True", "response": "Store credentials required to satisfy a given auth scheme."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef has_auth_params(self, scheme):\n        for k, v in iteritems(self.schemes[scheme][u'params']):\n            if not v: return False\n        return True", "response": "Check whether all required parameters for a given authentication scheme have been supplied."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef format_auth_params(params):\n        parts = []\n        for (key, value) in params.items():\n            if value:\n                parts.append('{}=\"{}\"'.format(key, value))\n        return \", \".join(parts)", "response": "Generate the format expected by HTTP Headers from parameters."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_backend(backend_class=None):\n    cache_name = '_backend_instance'\n    if not hasattr(get_backend, cache_name):\n        backend_class = backend_class or settings.ROUGHPAGES_BACKEND\n        if isinstance(backend_class, basestring):\n            module_path, class_name = backend_class.rsplit(\".\", 1)\n            module = import_module(module_path)\n            backend_class = getattr(module, class_name)\n        setattr(get_backend, cache_name, backend_class())\n    return getattr(get_backend, cache_name)", "response": "Get backend instance from base class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding the MIDI input name for a connected FaderPort.", "response": "def find_faderport_input_name(number=0):\n    \"\"\"\n    Find the MIDI input name for a connected FaderPort.\n\n    NOTE! Untested for more than one FaderPort attached.\n    :param number: 0 unless you've got more than one FaderPort attached.\n                   In which case 0 is the first, 1 is the second etc\n    :return: Port name or None\n    \"\"\"\n    ins = [i for i in mido.get_input_names() if i.lower().startswith('faderport')]\n    if 0 <= number < len(ins):\n        return ins[number]\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_faderport_output_name(number=0):\n    outs = [i for i in mido.get_output_names() if i.lower().startswith('faderport')]\n    if 0 <= number < len(outs):\n        return outs[number]\n    else:\n        return None", "response": "Find the MIDI output name for a connected FaderPort."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nopens the FaderPort and register a callback so we can receive MIDI messages.", "response": "def open(self, number=0):\n        \"\"\"\n        Open the FaderPort and register a callback so we can send and\n        receive MIDI messages.\n        :param number: 0 unless you've got more than one FaderPort attached.\n                       In which case 0 is the first, 1 is the second etc\n                       I only have access to a single device so I can't\n                       actually test this.\n        \"\"\"\n        self.inport = mido.open_input(find_faderport_input_name(number))\n        self.outport = mido.open_output(find_faderport_output_name(number))\n        self.outport.send(mido.Message.from_bytes([0x91, 0, 0x64]))  # A reset message???\n        time.sleep(0.01)\n        self.inport.callback = self._message_callback\n        self.on_open()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmove the fader to a new position in the range 0 to 1023.", "response": "def fader(self, value: int):\n        \"\"\"Move the fader to a new position in the range 0 to 1023.\"\"\"\n        self._fader = int(value) if 0 < value < 1024 else 0\n        self.outport.send(mido.Message('control_change', control=0,\n                                       value=self._fader >> 7))\n        self.outport.send(mido.Message('control_change', control=32,\n                                       value=self._fader & 0x7F))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nturns the light on for the given Button.", "response": "def light_on(self, button: Button):\n        \"\"\"Turn the light on for the given Button.\n\n        NOTE! If yuo turn the \"Off\" button light on, the fader won't\n        report value updates when it's moved.\"\"\"\n        self.outport.send(mido.Message('polytouch', note=button.light, value=1))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nturning the button lights on then off in a snakelike sequence.", "response": "def snake(self, duration: float = 0.03):\n        \"\"\"\n        Turn the button lights on then off in a snakelike sequence.\n        NOTE! Does not remember prior state of lights and will finish\n        with all lights off.\n        :param duration: The duration to hold each individual button.\n        \"\"\"\n        for button in BUTTONS:\n            self.light_on(button)\n            time.sleep(duration)\n\n        for button in reversed(BUTTONS):\n            self.light_off(button)\n            time.sleep(duration)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nblinks all the lights on and off at once.", "response": "def blink(self, interval: float = 0.2, n: int = 3):\n        \"\"\"\n        Blink all the lights on and off at once.\n        NOTE! Does not remember prior state of lights and will finish\n        with all lights off.\n        :param interval: The length in seconds of an ON/OFF cycle\n        :param n: How many times to cycle ON and OFF\n        :return:\n        \"\"\"\n        for i in range(n):\n            self.all_on()\n            time.sleep(interval / 2)\n            self.all_off()\n            time.sleep(interval / 2)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef char_on(self, c):\n        if c.upper() in CHARACTERS:\n            for i in CHARACTERS[c.upper()]:\n                self.light_on(BUTTONS[i])", "response": "Display a hex character."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndisplay a numeric countdown from 5. 5.", "response": "def countdown(self, interval: float = 0.5):\n        \"\"\"\n        Display a numeric countdown from 5\n        :param interval: The interval in seconds for each number.\n        \"\"\"\n        for c in '54321':\n            self.char_on(c)\n            time.sleep(interval * 0.66667)\n            self.all_off()\n            time.sleep(interval * 0.33333)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef chase(self, duration: float = 0.08, num_lights: int = 2, ticks: int = 20):\n        seq = [\n            button_from_name('Chan Down'),\n            button_from_name('Bank'),\n            button_from_name('Chan Up'),\n            button_from_name('Output'),\n            button_from_name('Off'),\n            button_from_name('Undo'),\n            button_from_name('Loop'),\n            button_from_name('User'),\n            button_from_name('Punch'),\n            button_from_name('Shift'),\n            button_from_name('Mix'),\n            button_from_name('Read'),\n        ]\n\n        num_lights = num_lights if num_lights in [1, 2, 3, 4] else 2\n\n        its = [cycle(seq) for _ in range(num_lights)]\n        for i, it in enumerate(its):\n            if i:\n                consume(it, i * (len(seq) // num_lights))\n\n        for x in range(ticks):\n            for it in its:\n                button = next(it)\n                self.light_on(button)\n            time.sleep(duration)\n            self.all_off()", "response": "Display an animated light chaser pattern for each light."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef serialize(self, data):\n\n        super(Serializer, self).serialize(data)\n\n        self.resp.content_type += '; header=present'\n        import pprint\n        pprint.PrettyPrinter().pprint(data)", "response": "Serialize the data into the response."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _serialize_data(self, data):\n\n        data.update(data['include'])\n        data.update(data['to_many'])\n        data.update(data['to_one'])\n\n        for key, val in data.items():\n            if isinstance(val, dict):\n                pass\n            elif isinstance(val, list):\n                pass\n            else:\n                str(val)", "response": "Turn the data into a single CSV record"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setUp(self):\n        '''Look for WS-Address\n        '''\n        toplist = filter(lambda wsa: wsa.ADDRESS==self.wsAddressURI, WSA_LIST)\n        epr = 'EndpointReferenceType'\n        for WSA in toplist+WSA_LIST:\n            if (self.wsAddressURI is not None and self.wsAddressURI != WSA.ADDRESS) or \\\n                _has_type_definition(WSA.ADDRESS, epr) is True:\n                break\n        else:\n            raise EvaluateException,\\\n                'enabling wsAddressing requires the inclusion of that namespace'\n\n        self.wsAddressURI = WSA.ADDRESS\n        self.anonymousURI = WSA.ANONYMOUS\n        self._replyTo = WSA.ANONYMOUS", "response": "Set up the object s attributes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _checkAction(self, action, value):\n        '''WS-Address Action\n        action -- Action value expecting.\n        value  -- Action value server returned.\n        '''\n        if action is None:\n            raise WSActionException, 'Response missing WSAddress Action'\n        if not value:\n            raise WSActionException, 'missing WSAddress Action, expecting %s' %action\n        if value != action:\n            raise WSActionException, 'wrong WSAddress Action(%s), expecting %s'%(value,action)", "response": "Check the action and value."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck that the value is correct for the RelatesTo field.", "response": "def _checkRelatesTo(self, value):\n        '''WS-Address From\n        value  -- From server returned.\n        '''\n        if value != self._messageID:\n            raise WSActionException, 'wrong WS-Address RelatesTo(%s), expecting %s'%(value,self._messageID)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _checkReplyTo(self, value):\n        '''WS-Address From\n        value  -- From server returned in wsa:To\n        '''\n        if value != self._replyTo:\n            raise WSActionException, 'wrong WS-Address ReplyTo(%s), expecting %s'%(value,self._replyTo)", "response": "Check that the value is correct for the replyTo field."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of typecodes for the given namespace.", "response": "def _getWSAddressTypeCodes(self, **kw):\n        '''kw -- namespaceURI keys with sequence of element names.\n        '''\n        typecodes = []\n        try:\n            for nsuri,elements in kw.items():\n                for el in elements:\n                    typecode = GED(nsuri, el)\n                    if typecode is None:\n                        raise WSActionException, 'Missing namespace, import \"%s\"' %nsuri\n\n                    typecodes.append(typecode)\n            else:\n                pass\n        except EvaluateException, ex:\n            raise EvaluateException, \\\n                'To use ws-addressing register typecodes for namespace(%s)' %self.wsAddressURI\n        return typecodes"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef checkResponse(self, ps, action):\n        ''' \n        ps -- ParsedSoap\n        action -- ws-action for response\n        '''\n        namespaceURI = self.wsAddressURI\n        d = {namespaceURI:(\"MessageID\",\"Action\",\"To\",\"From\",\"RelatesTo\")}\n        typecodes = self._getWSAddressTypeCodes(**d)\n        pyobjs = ps.ParseHeaderElements(typecodes)\n\n        got_action = pyobjs.get((namespaceURI,\"Action\"))\n        self._checkAction(action, got_action)\n\n        From = pyobjs.get((namespaceURI,\"From\"))\n        self._checkFrom(From)\n\n        RelatesTo = pyobjs.get((namespaceURI,\"RelatesTo\"))\n        self._checkRelatesTo(RelatesTo)\n\n        To = pyobjs.get((namespaceURI,\"To\"))\n        if To: self._checkReplyTo(To)", "response": "check the response of a SOAP request"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setResponseFromWSAddress(self, address, localURL):\n        '''Server-side has to set these fields in response.\n        address -- Address instance, representing a WS-Address\n        '''\n        self.From = localURL\n        self.header_pyobjs = None\n        pyobjs = []\n        namespaceURI = self.wsAddressURI\n\n        for nsuri,name,value in (\\\n             (namespaceURI, \"Action\", self._action), \n             (namespaceURI, \"MessageID\",\"uuid:%s\" %time.time()),\n             (namespaceURI, \"RelatesTo\", address.getMessageID()),\n             (namespaceURI, \"To\", self.anonymousURI),):\n\n            typecode = GED(nsuri, name)\n            pyobjs.append(typecode.pyclass(value))\n\n        typecode = GED(nsuri, \"From\")\n        pyobj = typecode.pyclass()\n        pyobj._Address = self.From\n        pyobjs.append(pyobj)\n        self.header_pyobjs = tuple(pyobjs)", "response": "Server - side has to set these fields in response."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nserializing the header of the current object to the SoapWriter instance sw.", "response": "def serialize(self, sw, **kw):\n        '''\n        sw -- SoapWriter instance, add WS-Address header.\n        '''\n        for pyobj in self.header_pyobjs:\n            if hasattr(pyobj, 'typecode') is False:\n                raise RuntimeError, 'all header pyobjs must have a typecode attribute'\n\n            sw.serialize_header(pyobj, **kw)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse(self, ps, **kw):\n        '''\n        ps -- ParsedSoap instance\n        '''\n        namespaceURI = self.wsAddressURI\n        elements = (\"MessageID\",\"Action\",\"To\",\"From\",\"RelatesTo\")\n        d = {namespaceURI:elements}\n        typecodes = self._getWSAddressTypeCodes(**d)\n        pyobjs = ps.ParseHeaderElements(typecodes)\n        self._messageID = pyobjs[(namespaceURI,elements[0])]\n        self._action = pyobjs[(namespaceURI,elements[1])]\n        self._addressTo = pyobjs[(namespaceURI,elements[2])]\n        self._from = pyobjs[(namespaceURI,elements[3])]\n        self._relatesTo = pyobjs[(namespaceURI,elements[4])]", "response": "parse the SOAP message and store the result in self. _messageID self. _action self. _addressTo self. _from self. _relatesTo"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndrops an attribute or element key - value pair from all the dictionaries.", "response": "def dropKey(self, key):\n        '''Drop an attribute/element/key-value pair from all the dictionaries.\n\n        If the dictionary key does not exist in a particular dictionary, then\n        that dictionary is left unchanged.\n\n        Side effect: if the key is a number and it matches a list (interpreted\n        as a dictionary), it will cause the \"keys\" to shift just as a list\n        would be expected to.\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"wigs\": 68       },\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"wigs\": [3, 2, 9]},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"wigs\": [1, 2, 3]},\n        ...    {\"name\": \"Jim\",   \"age\": 29, \"zim\": {\"zam\": \"99\"}              },\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000                   },\n        ... ]\n        >>> print PLOD(test).dropKey(\"income\").returnString()\n        [\n            {age: 18, name: 'Jim'  , wigs:        68, zim: None         },\n            {age: 18, name: 'Larry', wigs: [3, 2, 9], zim: None         },\n            {age: 20, name: 'Joe'  , wigs: [1, 2, 3], zim: None         },\n            {age: 29, name: 'Jim'  , wigs: None     , zim: {'zam': '99'}},\n            {age: 19, name: 'Bill' , wigs: None     , zim: None         }\n        ]\n        \n        .. versionadded:: 0.1.2\n        \n        :param key:\n           The dictionary key (or cascading list of keys point to final key)\n           that should be removed.\n        :returns: self\n        '''\n        result = []\n        for row in self.table:\n            result.append(internal.remove_member(row, key))\n        self.table = result\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninsert a attribute or element / key - value pair to all of the dictionaries.", "response": "def addKey(self, key, value):\n        '''Insert a attribute/element/key-value pair to all the dictionaries.\n\n        The same value is added to all of the dictionaries.\n\n        Of note: the current version of this routine cannot handle subtending\n        keys (dictionaries in dictionaries).\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"wigs\": 68       },\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"wigs\": [3, 2, 9]},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"wigs\": [1, 2, 3]},\n        ...    {\"name\": \"Jim\",   \"age\": 29, \"zim\": {\"zam\": \"99\"}              },\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000                   },\n        ... ]\n        >>> print PLOD(test).addKey(\"sp\", 3).returnString()\n        [\n            {age: 18, income: 93000, name: 'Jim'  , sp: 3, wigs:        68, zim: None         },\n            {age: 18, income: None , name: 'Larry', sp: 3, wigs: [3, 2, 9], zim: None         },\n            {age: 20, income: 15000, name: 'Joe'  , sp: 3, wigs: [1, 2, 3], zim: None         },\n            {age: 29, income: None , name: 'Jim'  , sp: 3, wigs: None     , zim: {'zam': '99'}},\n            {age: 19, income: 29000, name: 'Bill' , sp: 3, wigs: None     , zim: None         }\n        ]\n        \n        .. versionadded:: 0.1.4\n        \n        :param key:\n           The dictionary key (or cascading list of keys point to final key)\n           that should be removed.\n        :param value:\n           The value assigned to the key.\n        :returns: self\n        '''\n        result = []\n        for row in self.table:\n            try:\n                row[key]=value\n            except:\n                pass\n            result.append(row)\n        self.table = result\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef upsert(self, key, value, entry):\n        '''Update or Insert an entry into the list of dictionaries.\n\n        If a dictionary in the list is found where key matches the value, then\n           the FIRST matching list entry is replaced with entry\n        else\n           the entry is appended to the end of the list.\n\n        The new entry is not examined in any way. It is, in fact, possible\n        to upsert an entry that does not match the supplied key/value.\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"wigs\": 68       },\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"wigs\": [3, 2, 9]},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"wigs\": [1, 2, 3]},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000                   },\n        ... ]\n        >>> entryA = {\"name\": \"Willie\", \"age\": 77}\n        >>> myPLOD = PLOD(test)\n        >>> print myPLOD.upsert(\"name\", \"Willie\", entryA).returnString()\n        [\n            {age: 18, income: 93000, name: 'Jim'   , wigs:        68},\n            {age: 18, income: None , name: 'Larry' , wigs: [3, 2, 9]},\n            {age: 20, income: 15000, name: 'Joe'   , wigs: [1, 2, 3]},\n            {age: 19, income: 29000, name: 'Bill'  , wigs: None     },\n            {age: 77, income: None , name: 'Willie', wigs: None     }\n        ]\n        >>> entryB = {\"name\": \"Joe\", \"age\": 20, \"income\": 30, \"wigs\": [3, 2, 9]}\n        >>> print myPLOD.upsert(\"name\", \"Joe\", entryB).returnString()\n        [\n            {age: 18, income: 93000, name: 'Jim'   , wigs:        68},\n            {age: 18, income: None , name: 'Larry' , wigs: [3, 2, 9]},\n            {age: 20, income:    30, name: 'Joe'   , wigs: [3, 2, 9]},\n            {age: 19, income: 29000, name: 'Bill'  , wigs: None     },\n            {age: 77, income: None , name: 'Willie', wigs: None     }\n        ]\n\n        :param key:\n           The dictionary key to examine.\n        :param value:\n           The value to search for as referenced by the key.\n        :param entry:\n           The replacement (or new) entry for the list.\n        :returns:\n           class\n        '''\n        index=internal.get_index(self.table, key, self.EQUAL, value)\n        if index is None:\n            self.index_track.append(len(self.table))\n            self.table.append(entry)\n        else:\n            self.table[index]=entry\n        return self", "response": "Update or Insert an entry into the list of dictionaries."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef insert(self, new_entry):\n        '''Insert a new entry to the end of the list of dictionaries.\n\n        This entry retains the original index tracking but adds this\n        entry incrementally at the end.\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"wigs\": 68       },\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"wigs\": [3, 2, 9]},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"wigs\": [1, 2, 3]},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000                   },\n        ... ]\n        >>> entryA = {\"name\": \"Willie\", \"age\": 77}\n        >>> print PLOD(test).insert(entryA).returnString()\n        [\n            {age: 18, income: 93000, name: 'Jim'   , wigs:        68},\n            {age: 18, income: None , name: 'Larry' , wigs: [3, 2, 9]},\n            {age: 20, income: 15000, name: 'Joe'   , wigs: [1, 2, 3]},\n            {age: 19, income: 29000, name: 'Bill'  , wigs: None     },\n            {age: 77, income: None , name: 'Willie', wigs: None     }\n        ]\n\n        :param new_entry:\n           The new list entry to insert.\n        '''\n        self.index_track.append(len(self.table))\n        self.table.append(new_entry)\n        return self", "response": "Insert a new entry into the end of the list of dictionaries."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef deleteByOrigIndex(self, index):\n        result = []\n        result_tracker = []\n        for counter, row in enumerate(self.table):\n            if self.index_track[counter] != index:\n                result.append(row)\n                result_tracker.append(self.index_track[counter])\n        self.table = result\n        self.index_track = result_tracker\n        return self", "response": "Removes a single entry from the list given the index."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove entries from the list given the index references.", "response": "def deleteByOrigIndexList(self, indexList):\n        \"\"\"Remove entries from the list given the index references.\n\n        The index, in this instance, is a reference to the *original* list\n        indexing as seen when the list was first inserted into PLOD.\n\n        An example:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"wigs\": 68       },\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"wigs\": [3, 2, 9]},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"wigs\": [1, 2, 3]},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000                   },\n        ... ]\n        >>> myPLOD = PLOD(test)\n        >>> print myPLOD.sort(\"name\").returnString()\n        [\n            {age: 19, income: 29000, name: 'Bill' , wigs: None     },\n            {age: 18, income: 93000, name: 'Jim'  , wigs:        68},\n            {age: 20, income: 15000, name: 'Joe'  , wigs: [1, 2, 3]},\n            {age: 18, income: None , name: 'Larry', wigs: [3, 2, 9]}\n        ]\n        >>> listA = [0, 1]\n        >>> print myPLOD.deleteByOrigIndexList(listA).returnString()\n        [\n            {age: 20, income: 15000, name: 'Joe'  , wigs: [1, 2, 3]},\n            {age: 18, income: None , name: 'Larry', wigs: [3, 2, 9]}\n        ]\n\n        As you can see in the example, the list was sorted by 'name', which\n        rearranged the entries. Yet, when the deleteByOrigIndexList was\n        passed a [0, 1] (for the first and second entries), it removed 'Jim'\n        and \"Larry\" since those were the original first and second entries.\n\n        :param indexList:\n           A list of integer representing the places of entry in the original\n           list of dictionaries.\n        :return:\n           self\n        \"\"\"\n        result = []\n        result_tracker = []\n        counter = 0\n        for row in self.table:\n            if not counter in indexList:\n                result.append(row)\n                result_tracker.append(self.index_track[counter])\n            counter += 1\n        self.table = result\n        self.index_track = result_tracker\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsort the list in the order of the dictionary key.", "response": "def sort(self, key, reverse=False, none_greater=False):\n        '''Sort the list in the order of the dictionary key.\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"wigs\": 68       },\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"wigs\": [3, 2, 9]},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"wigs\": [1, 2, 3]},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000                   },\n        ... ]\n        >>> print PLOD(test).sort(\"name\").returnString()\n        [\n            {age: 19, income: 29000, name: 'Bill' , wigs: None     },\n            {age: 18, income: 93000, name: 'Jim'  , wigs:        68},\n            {age: 20, income: 15000, name: 'Joe'  , wigs: [1, 2, 3]},\n            {age: 18, income: None , name: 'Larry', wigs: [3, 2, 9]}\n        ]\n        >>> print PLOD(test).sort(\"income\").returnString()\n        [\n            {age: 18, income: None , name: 'Larry', wigs: [3, 2, 9]},\n            {age: 20, income: 15000, name: 'Joe'  , wigs: [1, 2, 3]},\n            {age: 19, income: 29000, name: 'Bill' , wigs: None     },\n            {age: 18, income: 93000, name: 'Jim'  , wigs:        68}\n        ]\n        >>> print PLOD(test).sort([\"age\", \"income\"]).returnString()\n        [\n            {age: 18, income: None , name: 'Larry', wigs: [3, 2, 9]},\n            {age: 18, income: 93000, name: 'Jim'  , wigs:        68},\n            {age: 19, income: 29000, name: 'Bill' , wigs: None     },\n            {age: 20, income: 15000, name: 'Joe'  , wigs: [1, 2, 3]}\n        ]\n        \n        .. versionadded:: 0.0.2\n        \n        :param key:\n           A dictionary key (or a list of keys) that should be the\n           basis of the sorting.\n        :param reverse:\n           Defaults to False. If True, then list is sorted decrementally.\n        :param none_greater:\n           Defaults to False. If True, then entries missing the key/value\n           pair are considered be of greater value than the non-missing values.\n        :returns: self\n        '''\n        for i in range(0, len(self.table)):\n            min = i\n            for j in range(i + 1, len(self.table)):\n                if internal.is_first_lessor(self.table[j], self.table[min], key, none_greater=none_greater, reverse=reverse):\n                    min = j\n            if i!=min:\n                self.table[i], self.table[min] = self.table[min], self.table[i] # swap\n                self.index_track[i], self.index_track[min] = self.index_track[min], self.index_track[i] # swap\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning entries where the key s value is of equal value.", "response": "def eq(self, key, value, includeMissing=False):\n        '''Return entries where the key's value is of equal (==) value.\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"wigs\": 68       },\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"wigs\": [3, 2, 9]},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"wigs\": [1, 2, 3]},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000                   },\n        ... ]\n        >>> print PLOD(test).eq(\"name\", \"Larry\").returnString()\n        [\n            {age: 18, name: 'Larry', wigs: [3, 2, 9]}\n        ]\n        >>> print PLOD(test).eq(\"income\", 15000, includeMissing=True).returnString()\n        [\n            {age: 18, income: None , name: 'Larry', wigs: [3, 2, 9]},\n            {age: 20, income: 15000, name: 'Joe'  , wigs: [1, 2, 3]}\n        ]\n        \n        .. versionadded:: 0.1.1\n        \n        :param key:\n           The dictionary key (or cascading list of keys) that should be the\n           basis of comparison.\n        :param value:\n           The value to compare with.\n        :param includeMissing:\n           Defaults to False. If True, then entries missing the key are also\n           included.\n        :returns: self\n        '''\n        (self.table, self.index_track) = internal.select(self.table, self.index_track, key, self.EQUAL, value, includeMissing)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ne(self, key, value, includeMissing=False):\n        '''Return entries where the key's value is NOT of equal (!=) value.\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"wigs\": 68       },\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"wigs\": [3, 2, 9]},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"wigs\": [1, 2, 3]},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000                   },\n        ... ]\n        >>> print PLOD(test).ne(\"name\", \"Larry\").returnString()\n        [\n            {age: 18, income: 93000, name: 'Jim' , wigs:        68},\n            {age: 20, income: 15000, name: 'Joe' , wigs: [1, 2, 3]},\n            {age: 19, income: 29000, name: 'Bill', wigs: None     }\n        ]\n        >>> print PLOD(test).ne(\"income\", 15000, includeMissing=True).returnString()\n        [\n            {age: 18, income: 93000, name: 'Jim'  , wigs:        68},\n            {age: 18, income: None , name: 'Larry', wigs: [3, 2, 9]},\n            {age: 19, income: 29000, name: 'Bill' , wigs: None     }\n        ]\n        \n        .. versionadded:: 0.1.1\n        \n        :param key:\n           The dictionary key (or cascading list of keys) that should be the\n           basis of comparison.\n        :param value:\n           The value to compare with.\n        :param includeMissing:\n           Defaults to False. If True, then entries missing the key are also\n           included.\n        :returns: self\n        '''\n        (self.table, self.index_track) = internal.select(self.table, self.index_track, key, self.NOT_EQUAL, value, includeMissing)\n        return self", "response": "Return entries where the key s value is NOT of equal ( = ) value."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns entries where the key s value is greater than value.", "response": "def gt(self, key, value, includeMissing=False):\n        '''Return entries where the key's value is greater (>).\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"wigs\": 68       },\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"wigs\": [3, 2, 9]},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"wigs\": [1, 2, 3]},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000                   },\n        ... ]\n        >>> print PLOD(test).gt(\"age\", 19).returnString()\n        [\n            {age: 20, income: 15000, name: 'Joe', wigs: [1, 2, 3]}\n        ]\n        \n        .. versionadded:: 0.1.1\n        \n        :param key:\n           The dictionary key (or cascading list of keys) that should be the\n           basis of comparison.\n        :param value:\n           The value to compare with.\n        :param includeMissing:\n           Defaults to False. If True, then entries missing the key are also\n           included.\n        :returns: self\n        '''\n        (self.table, self.index_track) = internal.select(self.table, self.index_track, key, self.GREATER, value, includeMissing)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns entries where the key s value is greater or equal ( > =.", "response": "def gte(self, key, value, includeMissing=False):\n        '''Return entries where the key's value is greater or equal (>=).\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"wigs\": 68       },\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"wigs\": [3, 2, 9]},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"wigs\": [1, 2, 3]},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000                   },\n        ... ]\n        >>> print PLOD(test).gte(\"age\", 19).returnString()\n        [\n            {age: 20, income: 15000, name: 'Joe' , wigs: [1, 2, 3]},\n            {age: 19, income: 29000, name: 'Bill', wigs: None     }\n        ]\n        \n        .. versionadded:: 0.1.1\n        \n        :param key:\n           The dictionary key (or cascading list of keys) that should be the\n           basis of comparison.\n        :param value:\n           The value to compare with.\n        :param includeMissing:\n           Defaults to False. If True, then entries missing the key are also\n           included.\n        :returns: self\n        '''\n        (self.table, self.index_track) = internal.select(self.table, self.index_track, key, self.GREATERorEQUAL, value, includeMissing)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns entries where the key s value is less than the given value.", "response": "def lt(self, key, value, includeMissing=False):\n        '''Return entries where the key's value is less (<).\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"wigs\": 68       },\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"wigs\": [3, 2, 9]},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"wigs\": [1, 2, 3]},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000                   },\n        ... ]\n        >>> print PLOD(test).lt(\"age\", 19).returnString()\n        [\n            {age: 18, income: 93000, name: 'Jim'  , wigs:        68},\n            {age: 18, income: None , name: 'Larry', wigs: [3, 2, 9]}\n        ]\n        \n        .. versionadded:: 0.1.1\n        \n        :param key:\n           The dictionary key (or cascading list of keys) that should be the\n           basis of comparison.\n        :param value:\n           The value to compare with.\n        :param includeMissing:\n           Defaults to False. If True, then entries missing the key are also\n           included.\n        :returns: self\n        '''\n        (self.table, self.index_track) = internal.select(self.table, self.index_track, key, self.LESS, value, includeMissing)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef lte(self, key, value, includeMissing=False):\n        '''Return entries where the key's value is less or equal (=<).\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"wigs\": 68       },\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"wigs\": [3, 2, 9]},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"wigs\": [1, 2, 3]},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000                   },\n        ... ]\n        >>> print PLOD(test).lte(\"age\", 19).returnString()\n        [\n            {age: 18, income: 93000, name: 'Jim'  , wigs:        68},\n            {age: 18, income: None , name: 'Larry', wigs: [3, 2, 9]},\n            {age: 19, income: 29000, name: 'Bill' , wigs: None     }\n        ]\n        \n        .. versionadded:: 0.1.1\n        \n        :param key:\n           The dictionary key (or cascading list of keys) that should be the\n           basis of comparison.\n        :param value:\n           The value to compare with.\n        :param includeMissing:\n           Defaults to False. If True, then entries missing the key are also\n           included.\n        :returns: self\n        '''\n        (self.table, self.index_track) = internal.select(self.table, self.index_track, key, self.LESSorEQUAL, value, includeMissing)\n        return self", "response": "Return entries where the key s value is less or equal ( =."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hasKey(self, key, notNone=False):\n        '''Return entries where the key is present.\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"wigs\": 68       },\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"wigs\": [3, 2, 9]},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": None , \"wigs\": [1, 2, 3]},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000                   },\n        ... ]\n        >>> print PLOD(test).hasKey(\"income\").returnString()\n        [\n            {age: 18, income: 93000, name: 'Jim' , wigs:        68},\n            {age: 20, income: None , name: 'Joe' , wigs: [1, 2, 3]},\n            {age: 19, income: 29000, name: 'Bill', wigs: None     }\n        ]\n        >>> print PLOD(test).hasKey(\"income\", notNone=True).returnString()\n        [\n            {age: 18, income: 93000, name: 'Jim' , wigs:   68},\n            {age: 19, income: 29000, name: 'Bill', wigs: None}\n        ]\n        \n        .. versionadded:: 0.1.2\n        \n        :param key:\n           The dictionary key (or cascading list of keys) to locate.\n        :param notNone:\n           If True, then None is the equivalent of a missing key. Otherwise, a key\n           with a value of None is NOT considered missing.\n        :returns: self\n        '''\n        result = []\n        result_tracker = []\n\n        for counter, row in enumerate(self.table):\n            (target, _, value) = internal.dict_crawl(row, key)\n            if target:\n                if notNone==False or not value is None:\n                    result.append(row)\n                    result_tracker.append(self.index_track[counter])\n        self.table = result\n        self.index_track = result_tracker\n        return self", "response": "Return entries where the key is present."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef contains(self, key, value, findAll=False, exclude=False, includeMissing=False):\n        '''Return entries that:\n        \n        * have the key\n        * key points to a list, and\n        * value is found in the list.\n\n        If value is also a list itself, then the list entry is selected if any of\n        the values match.  If findAll is set to True, then all the entries\n        must be found.\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"wigs\": [9, 12]  },\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"wigs\": [3, 2, 9]},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"wigs\": [1, 2, 3]},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000                   },\n        ... ]\n        >>> print PLOD(test).contains(\"wigs\", [1, 12]).returnString()\n        [\n            {age: 18, income: 93000, name: 'Jim', wigs: [9, 12]  },\n            {age: 20, income: 15000, name: 'Joe', wigs: [1, 2, 3]}\n        ]\n\n        .. versionadded:: 0.1.3b\n        \n        :param key:\n           The dictionary key (or cascading list of keys) that should point to\n           a list.\n        :param value:\n           The value to locate in the list. This argument can be an immutable\n           value such as a string, tuple, or number.\n\n           If this argument is a list of values instead, then this method will\n           search for any of the values in that list. If the optional 'findAll'\n           parameter is set to True, then all of the values in that list must\n           be found. \n            \n        Optional named arguments:\n        \n        :param finalAll:\n           If True, then all the values in the 'value' parameter must be found.\n        :param exclude:\n           If 'exclude' is True, then the entries that do NOT match the above\n           conditions are returned.\n        :param includeMissing:\n           If 'includeMissing' is True, then if the key is missing then that\n           entry is included in the results. However, it does not include\n           entries that have the key but its value is for a non-list or empty\n           list.\n        :returns:\n           self\n        '''\n        result = []\n        result_index = []\n        for counter, row in enumerate(self.table):\n            (target, tkey, target_list) = internal.dict_crawl(row, key)\n            if target:\n                if findAll:\n                    success = internal.list_match_all(target_list, value)\n                else:\n                    success = internal.list_match_any(target_list, value)\n                if exclude:\n                    success = not success\n                if success:\n                    result.append(row)\n                    result_index.append(self.index_track[counter])\n                else:\n                    # item missing from list, so skip over\n                    pass\n            else:\n                if includeMissing:\n                    result.append(row)\n                    result_index.append(self.index_track[counter])\n                else:\n                    pass\n        self.table = result\n        self.index_track = result_index\n        return self", "response": "Return entries that have the key and value that point to a list and the value is found in the list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef returnList(self, limit=False):\n        '''Return a list of dictionaries (and *not* a PLOD class).\n\n        The list returned maintains the 'types' of the original entries unless\n        another operation has explicity changed them. For example, an 'upsert'\n        replacement of an entry.\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"wigs\": [9, 12]  },\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"wigs\": [3, 2, 9]},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"wigs\": [1, 2, 3]},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000                   },\n        ... ]\n        >>> my_list = PLOD(test).sort(\"age\").returnList()\n        >>> print my_list\n        [{'age': 18, 'name': 'Jim', 'wigs': [9, 12], 'income': 93000}, {'age': 18, 'name': 'Larry', 'wigs': [3, 2, 9]}, {'age': 19, 'name': 'Bill', 'income': 29000}, {'age': 20, 'name': 'Joe', 'wigs': [1, 2, 3], 'income': 15000}]\n        >>> print my_list[2][\"age\"]\n        19\n\n        :param limit:\n           A number limiting the quantity of entries to return. Defaults to\n           False, which means that the full list is returned.\n        :return:\n           the list of dictionaries\n        '''\n        if limit==False:\n            return self.table\n        result = []\n        for i in range(limit):\n            if len(self.table)>i:\n                result.append(self.table[i])\n        return result", "response": "Return a list of dictionaries."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef returnLOD(self, limit=False):\n        '''Return a TRUE list of dictionaries (and *not* a PLOD class).\n\n        The entries are modified if the original list was not already a list of\n        dictionaries. So, for example, a list of objects would be returned as\n        an interpreted list of dictionaries instead.\n        '''\n\n        if limit==False:\n            limit = len(self.table)\n        result = []\n        if limit:\n            for i in range(limit):\n                result.append(internal.convert_to_dict(self.table[i]))\n        return result", "response": "Return a TRUE list of dictionaries and not a PLOD class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a string containing the list of dictionaries in easy human - readable read format.", "response": "def returnString(self, limit=False, omitBrackets=False, executable=False, honorMissing=False):\n        '''Return a string containing the list of dictionaries in easy\n        human-readable read format.\n\n        Each entry is on one line. Key/value pairs are 'spaced' in such a way\n        as to have them all line up vertically if using a monospace font. The\n        fields are normalized to alphabetical order. Missing keys in a\n        dictionary are inserted with a value of 'None' unless *honorMissing* is\n        set to True.\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"order\": 2},\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"order\": 3},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"order\": 1},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000, \"order\": 4},\n        ... ]\n        >>> print PLOD(test).returnString()\n        [\n            {age: 18, income: 93000, name: 'Jim'  , order: 2},\n            {age: 18, income: None , name: 'Larry', order: 3},\n            {age: 20, income: 15000, name: 'Joe'  , order: 1},\n            {age: 19, income: 29000, name: 'Bill' , order: 4}\n        ]\n        >>> print PLOD(test).returnString(limit=3, omitBrackets=True, executable=True)\n        {'age': 18, 'income': 93000, 'name': 'Jim'  , 'order': 2},\n        {'age': 18, 'income': None , 'name': 'Larry', 'order': 3},\n        {'age': 20, 'income': 15000, 'name': 'Joe'  , 'order': 1}\n        >>> print PLOD(test).returnString(honorMissing=True)\n        [\n            {age: 18, income: 93000, name: 'Jim'  , order: 2},\n            {age: 18,                name: 'Larry', order: 3},\n            {age: 20, income: 15000, name: 'Joe'  , order: 1},\n            {age: 19, income: 29000, name: 'Bill' , order: 4}\n        ]\n        \n        :param limit:\n           A number limiting the quantity of entries to return. Defaults to\n           False, which means that the full list is returned.\n        :param omitBrackets:\n           If set to True, the outer square brackets representing the entire\n           list are omitted. Defaults to False.\n        :param executable:\n           If set to True, the string is formatted in such a way that it\n           conforms to Python syntax. Defaults to False.\n        :param honorMissing:\n           If set to True, keys that are missing in a dictionary are simply\n           skipped with spaces. If False, then the key is display and given\n           a value of None. Defaults to False.\n        :return:\n           A string containing a formatted textual representation of the list\n           of dictionaries.\n        '''\n        result = \"\"\n        # we limit the table if needed\n        if not limit:\n            limit = len(self.table)\n        used_table = []\n        for i in range(limit):\n            if len(self.table)>i:\n                used_table.append(internal.convert_to_dict(self.table[i]))\n        # we locate all of the attributes and their lengths\n        attr_width = {}\n        # first pass to get the keys themselves\n        for row in used_table:\n            for key in row:\n                if not key in attr_width:\n                    attr_width[key] = 0\n        # get a sorted list of keys\n        attr_order = attr_width.keys()\n        attr_order.sort()\n        # not get minimum widths\n        #  (this is done as a seperate step to account for 'None' and other conditions.\n        for row in used_table:\n            for key in attr_width:\n                if not key in row:\n                    if not honorMissing:\n                        if attr_width[key] < len(\"None\"):\n                            attr_width[key] = len(\"None\")\n                else:\n                    if len(repr(row[key])) > attr_width[key]:\n                        attr_width[key] = len(repr(row[key]))\n        # now we do the pretty print\n        if not omitBrackets:\n            result += \"[\\n\"\n        body = []\n        for row in used_table:\n            row_string = \"\"\n            if not omitBrackets:\n                row_string += \"    \"\n            row_string += \"{\"\n            middle = []\n            for key in attr_order:\n                if key in row:\n                    # build the key\n                    if executable:\n                        item = \"'\"+str(key) + \"': \"\n                    else:\n                        item = str(key) + \": \"\n                    # build the value\n                    s = repr(row[key])\n                    if type(row[key]) is typemod.IntType:\n                        s = s.rjust(attr_width[key])\n                else:\n                    if honorMissing:\n                        # build the key\n                        item = \" \"*len(str(key))\n                        if executable:\n                            item += \"  \"\n                        item +=  \"  \"\n                        # build the value\n                        s=\"\"\n                    else:\n                        # build the key\n                        if executable:\n                            item = \"'\"+str(key) + \"': \"\n                        else:\n                            item = str(key) + \": \"\n                        # build the value\n                        s = \"None\"\n                item += s.ljust(attr_width[key])\n                middle.append(item)\n            # row_string += \", \".join(middle)\n            row_string += internal.special_join(middle)\n            row_string += \"}\"\n            body.append(row_string)\n        result += \",\\n\".join(body)\n        if len(body) and not omitBrackets:\n            result += \"\\n\"\n        if not omitBrackets:\n            result += \"]\"\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef returnCSV(self, keys=None, limit=False, omitHeaderLine=False, quoteChar=None, eolChars='\\r\\n'):\n        r'''Return a list of dictionaries formated as a comma seperated values\n        (CSV) list in a string.\n\n        Each entry is on one line. By default, each value is seperated by\n        commas and each entry is followed by a newline ('\\n').\n\n        By default, RFC4180 is followed. See:\n\n           http://tools.ietf.org/html/rfc4180\n\n        The RFC has considerable detail describing the format.\n\n        Note regarding certain RFC section 2 sub 4: there is no default\n        behavior specified if the last field on a line is empty and thus\n        creating a 'trailing comma'. This routine handles it by quoting\n        the final field. The first example below demonstrates this for the\n        entry with 'name' of 'Larry' and a missing 'income' field. The\n        missing field is shown as \"\" at the end of the line.\n           \n        Missing keys and/or values of None are simply blank.\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim, Phd\",         \"age\": 18  , \"income\": 93000, \"order\": 2},\n        ...    {\"name\": \"Larry\",            \"age\": None,                  \"order\": 3},\n        ...    {\"name\": \"Joe\",              \"age\": 20  , \"income\": 15000, \"order\": 1},\n        ...    {\"name\": \"B \\\"Zip\\\" O'Tool\", \"age\": 19  , \"income\": 29000, \"order\": 4},\n        ... ]\n        >>> print PLOD(test).returnCSV()   # doctest: +NORMALIZE_WHITESPACE\n        age,order,name,income\n        18,2,\"Jim, Phd\",93000\n        ,3,Larry,\"\"\n        20,1,Joe,15000\n        19,4,\"B \"\"Zip\"\" O'Tool\",29000\n        <BLANKLINE>\n        >>> print PLOD(test).returnCSV(limit=3, omitHeaderLine=True, quoteChar=\"'\", eolChars='\\n')\n        '18','2','Jim, Phd','93000'\n        '','3','Larry',''\n        '20','1','Joe','15000'\n        <BLANKLINE>\n        >>> print PLOD(test).returnCSV(keys=[\"name\", \"age\"], quoteChar='\"', eolChars='\\n')\n        \"name\",\"age\"\n        \"Jim, Phd\",\"18\"\n        \"Larry\",\"\"\n        \"Joe\",\"20\"\n        \"B \"\"Zip\"\" O'Tool\",\"19\"\n        <BLANKLINE>\n        \n        :param keys:\n           If the 'keys' parameter is passed a list of keys, then only those\n           keys are returned. The order of keys in the list is retained. If a\n           key is not found in an entry (or in *any* entry), that is not an error\n           condition. Those entries simply have an empty value for that position.\n\n           NOTE: use this parameter if the order of the keys is critical. Order\n           is not guaranteed otherwise.\n        :param limit:\n           A number limiting the quantity of entries to return. Defaults to\n           False, which means that the full list is returned.\n        :param omitHeaderLine:\n           If set to True, the initial line of text listing the keys\n           is not included. Defaults to False.\n        :param quoteChar:\n           If set to anything (including a single quote), then all fields will\n           be surrounded by the quote character.\n        :param eolChars:\n           These are the characters inserted at the end of each line. By default\n           they are CRLF ('\\r\\n') as specified in RFC4180. To be more pythonic\n           you could change it to '\\n'.\n        :return:\n           A string containing a formatted textual representation of the list\n           of dictionaries.\n        '''\n        result = \"\"\n        if quoteChar:\n            quoteAll=True\n        else:\n            quoteAll=False\n        # we limit the table if needed\n        used_table = self.table\n        if limit:\n            used_table = []\n            for i in range(limit):\n                if len(self.table)>i:\n                    used_table.append(self.table[i])\n        # we locate all of the attributes\n        if keys:\n            attr_list = keys\n        else:\n            attr_list = []\n            for row in used_table:\n                for key in row:\n                    if not key in attr_list:\n                        attr_list.append(key)\n        # now we do the pretty print\n        if not omitHeaderLine:\n            if quoteAll:\n                result += quoteChar\n                temp = quoteChar+\",\"+quoteChar\n                result += temp.join(attr_list)\n                result += quoteChar\n            else:\n                result += \",\".join(attr_list)\n            result += eolChars\n        for row in used_table:\n            ml = []\n            for ctr, key in enumerate(attr_list):\n                if key in row:\n                    if row[key] is None:\n                        value = \"\"\n                    else:\n                        value = str(row[key])\n                    if quoteAll:\n                        ml.append(internal.csv_quote(quoteChar,value))\n                    else:\n                        if ('\"' in value) or (',' in value):\n                            ml.append(internal.csv_quote('\"', value))\n                        else:\n                            if ((ctr+1)==len(attr_list)) and (len(value)==0):\n                                ml.append('\"\"')\n                            else:\n                                ml.append(value)\n                else:\n                    if quoteAll:\n                        ml.append(quoteChar+quoteChar)\n                    else:\n                        if (ctr+1)==len(attr_list):\n                            ml.append('\"\"')\n                        else:\n                            ml.append(\"\")\n            result += \",\".join(ml)\n            result += eolChars\n        return result", "response": "r Return a list of dictionaries formated as a comma seperated values in a string in a string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of integers that are list - index references to the original list of dictionaries.", "response": "def returnIndexList(self, limit=False):\n        '''Return a list of integers that are list-index references to the\n        original list of dictionaries.\"\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"order\": 2},\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"order\": 3},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"order\": 1},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000, \"order\": 4},\n        ... ]\n        >>> print PLOD(test).returnIndexList()\n        [0, 1, 2, 3]\n        >>> print PLOD(test).sort(\"name\").returnIndexList()\n        [3, 0, 2, 1]\n        \n        :param limit:\n           A number limiting the quantity of entries to return. Defaults to\n           False, which means that the full list is returned.\n        :return:\n           A list of integers representing the original indices.\n        '''\n        if limit==False:\n            return self.index_track\n        result = []\n        for i in range(limit):\n            if len(self.table)>i:\n                result.append(self.index_track[i])\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the first origin index of the current list. This is a very useful way to get the original placement of the first item in the list.", "response": "def returnOneIndex(self, last=False):\n        '''Return the first origin index (integer) of the current list. That\n        index refers to it's placement in the original list of dictionaries.\n        \n        This is very useful when one wants to reference the original entry by\n        index.\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"order\": 2},\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"order\": 3},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"order\": 1},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000, \"order\": 4},\n        ... ]\n        >>> print PLOD(test).returnOneIndex()\n        0\n        >>> print PLOD(test).sort(\"name\").returnOneIndex()\n        3\n\n        :param last:\n           The last origin of the current list is returned rather than the first.\n        :return:\n           An integer representing the original placement of the first item in\n           the list. Returns None if the list is currently empty.\n        '''\n        if len(self.table)==0:\n            return None\n        else:\n            if last:\n                return self.index_track.pop()\n            else:\n                return self.index_track[0]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef returnOneEntry(self, last=False):\n        '''Return the first entry in the current list. If 'last=True', then\n        the last entry is returned.\"\n\n        Returns None is the list is empty.\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"order\": 2},\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"order\": 3},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"order\": 1},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000, \"order\": 4},\n        ... ]\n        >>> print PLOD(test).returnOneEntry()\n        {'age': 18, 'order': 2, 'name': 'Jim', 'income': 93000}\n        >>> print PLOD(test).returnOneEntry(last=True)\n        {'age': 19, 'order': 4, 'name': 'Bill', 'income': 29000}\n\n        :param last:\n           If True, the last entry is returned rather than the first.\n        :return:\n           A list entry, or None if the list is empty.\n        '''\n        if len(self.table)==0:\n            return None\n        else:\n            if last:\n                return self.table[len(self.table)-1]\n            else:\n                return self.table[0]", "response": "Return the first entry in the current list. If last = True then\n        the last entry is returned."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef returnValue(self, key, last=False):\n        '''Return the key's value for the first entry in the current list.\n        If 'last=True', then the last entry is referenced.\"\n\n        Returns None is the list is empty or the key is missing.\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"order\": 2},\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"order\": 3},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"order\": 1},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000, \"order\": 4},\n        ... ]\n        >>> print PLOD(test).returnValue(\"name\")\n        Jim\n        >>> print PLOD(test).sort(\"name\").returnValue(\"name\", last=True)\n        Larry\n        >>> print PLOD(test).sort(\"name\").returnValue(\"income\", last=True)\n        None\n\n        :param last:\n           If True, the last entry is used rather than the first.\n        :return:\n           A value, or None if the list is empty or the key is missing.\n        '''\n        row = self.returnOneEntry(last=last)\n        if not row:\n            return None\n        dict_row = internal.convert_to_dict(row)\n        return dict_row.get(key, None)", "response": "Return the key s value for the first entry in the current list. If last = True then the last entry is referenced."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef returnValueList(self, key_list, last=False):\n        '''Return a list of key values for the first entry in the current list.\n        If 'last=True', then the last entry is referenced.\"\n\n        Returns None is the list is empty. If a key is missing, then\n        that entry in the list is None.\n\n        Example of use:\n\n        >>> test = [\n        ...    {\"name\": \"Jim\",   \"age\": 18, \"income\": 93000, \"order\": 2},\n        ...    {\"name\": \"Larry\", \"age\": 18,                  \"order\": 3},\n        ...    {\"name\": \"Joe\",   \"age\": 20, \"income\": 15000, \"order\": 1},\n        ...    {\"name\": \"Bill\",  \"age\": 19, \"income\": 29000, \"order\": 4},\n        ... ]\n        >>> print PLOD(test).returnValueList([\"name\", \"income\"])\n        ['Jim', 93000]\n        >>> print PLOD(test).sort(\"name\").returnValueList([\"name\", \"income\"], last=True)\n        ['Larry', None]\n\n        :param last:\n           If True, the last entry is used rather than the first.\n        :return:\n           A value, or None if the list is empty.\n        '''\n        result = []\n        row = self.returnOneEntry(last=last)\n        if not row:\n            return None\n        dict_row = internal.convert_to_dict(row)\n        for field in key_list:\n            result.append(dict_row.get(field, None))\n        return result", "response": "Return a list of key values for the first entry in the current list. If last = True then the last entry is referenced."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execOnSubArrays(arrs, fn, splitX, splitY):\n    if type(arrs) not in (tuple, list):\n        arrs = (arrs,)\n    s0, s1 = arrs[0].shape\n    ss0 = s0 // splitX\n    ss1 = s1 // splitY\n    px, py = 0, 0\n    out = None\n    for ix in range(splitX):\n        if ix == splitX - 1:\n            ss0 = s0 - px\n\n        for iy in range(splitY):\n            if iy == splitY - 1:\n                ss1 = s1 - py\n            # current sub arrays:\n            sarrs = [a[px:px + ss0, py:py + ss1] for a in arrs]\n            sub = fn(*tuple(sarrs))\n\n            if out is None:\n                out = np.empty(shape=(s0, s1), dtype=sub.dtype)\n\n            out[px:px + ss0, py:py + ss1] = sub\n\n            py += ss1\n        py = 0\n        px += ss0\n    return out", "response": "execute a function on or multiple arrays"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_queryset(self, request):\n        qs = super(TenantGroupAdmin, self).get_queryset(request)\n        if not request.user.is_superuser:\n            qs = qs.filter(tenantrole__user=request.user,\n                           tenantrole__role=TenantRole.ROLE_GROUP_MANAGER)\n        return qs", "response": "Limit to TenantGroups that this user can access."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_queryset(self, request):\n        qs = super(TenantAdmin, self).get_queryset(request)\n        if not request.user.is_superuser:\n            tenants_by_group_manager_role = qs.filter(\n                group__tenantrole__user=request.user,\n                group__tenantrole__role=TenantRole.ROLE_GROUP_MANAGER\n            )\n            tenants_by_tenant_manager_role = qs.filter(\n                tenantrole__user=request.user,\n                tenantrole__role=TenantRole.ROLE_TENANT_MANAGER\n            )\n            return tenants_by_group_manager_role | tenants_by_tenant_manager_role\n        return qs", "response": "Limit to Tenants that this user can access."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setHeader(package_path,\n              header_start='', header_end='', header_text='',\n              remove_header=False,\n              exclude_init=True, exclude_empty_files=True):\n    \"\"\"\n    Adds, modifies removes a header text in all *.py files in a python package\n\n    header_start -> string indicating the begin of the header e.g. '#<<<<<<<<<'\n    header_text -> the header text e.g. '#copyright John Doe 2033\\n#licensed under GPLv3'\n    header_end -> string indicating the end of the header e.g. '#>>>>>>>>>'\n\n    package_path -> relative or absolute path of the package to modify e.g. 'C:\\\\...\\\\myPackage'\n    remove_header -> Set to True to remove the header in every py file in the package\n    \"\"\"\n\n    pkg_name = os.path.split(package_path)[-1]\n\n    if not os.path.exists(package_path):\n        Exception(\"ERROR: given path '%s' not valid\" % package_path)\n\n    py_files = _findPyFiles(package_path, exclude_init)\n    print('found %s py files in package %s' % (len(py_files), pkg_name))\n    for path in py_files:\n        print(path)\n        _setHeaderInPyFile(path, header_start, header_text,\n                           header_end, remove_header, exclude_empty_files)\n    print('done.')", "response": "Adds modifies removes a header text in all. py files in a python package"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_html(grafs):\n    html = [format_html('<p>{}</p>', p) for p in grafs]\n    html = [p.replace(\"\\n\", \"<br>\") for p in html]\n    return format_html(six.text_type('\\n\\n'.join(html)))", "response": "Returns the HTML representation of the given grafs."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses the incoming bytestream as a URL encoded form and returns the resulting QueryDict.", "response": "def parse(self, stream, media_type=None, parser_context=None):\n        \"\"\"\n        Parses the incoming bytestream as a URL encoded form,\n        and returns the resulting QueryDict.\n        \"\"\"\n        parser_context = parser_context or {}\n        encoding = parser_context.get('encoding', settings.DEFAULT_CHARSET)\n        data = QueryDict(stream.read(), encoding=encoding)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse(self, stream, media_type=None, parser_context=None):\n        parser_context = parser_context or {}\n        request = parser_context['request']\n        encoding = parser_context.get('encoding', settings.DEFAULT_CHARSET)\n        meta = request.META.copy()\n        meta['CONTENT_TYPE'] = media_type\n        upload_handlers = request.upload_handlers\n\n        try:\n            parser = DjangoMultiPartParser(meta, stream, upload_handlers, encoding)\n            data, files = parser.parse()\n            return DataAndFiles(data, files)\n        except MultiPartParserError as exc:\n            raise ParseError('Multipart form parse error - %s' % six.text_type(exc))", "response": "Parses the incoming bytestream as a multipart encoded form and returns a DataAndFiles object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the incoming bytestream as a raw file upload and returns a DataAndFiles object.", "response": "def parse(self, stream, media_type=None, parser_context=None):\n        \"\"\"\n        Treats the incoming bytestream as a raw file upload and returns\n        a `DataAndFiles` object.\n\n        `.data` will be None (we expect request body to be a file content).\n        `.files` will be a `QueryDict` containing one 'file' element.\n        \"\"\"\n\n        parser_context = parser_context or {}\n        request = parser_context['request']\n        encoding = parser_context.get('encoding', settings.DEFAULT_CHARSET)\n        meta = request.META\n        upload_handlers = request.upload_handlers\n        filename = self.get_filename(stream, media_type, parser_context)\n\n        # Note that this code is extracted from Django's handling of\n        # file uploads in MultiPartParser.\n        content_type = meta.get('HTTP_CONTENT_TYPE',\n                                meta.get('CONTENT_TYPE', ''))\n        try:\n            content_length = int(meta.get('HTTP_CONTENT_LENGTH',\n                                          meta.get('CONTENT_LENGTH', 0)))\n        except (ValueError, TypeError):\n            content_length = None\n\n        # See if the handler will want to take care of the parsing.\n        for handler in upload_handlers:\n            result = handler.handle_raw_input(None,\n                                              meta,\n                                              content_length,\n                                              None,\n                                              encoding)\n            if result is not None:\n                return DataAndFiles({}, {'file': result[1]})\n\n        # This is the standard case.\n        possible_sizes = [x.chunk_size for x in upload_handlers if x.chunk_size]\n        chunk_size = min([2 ** 31 - 4] + possible_sizes)\n        chunks = ChunkIter(stream, chunk_size)\n        counters = [0] * len(upload_handlers)\n\n        for index, handler in enumerate(upload_handlers):\n            try:\n                handler.new_file(None, filename, content_type,\n                                 content_length, encoding)\n            except StopFutureHandlers:\n                upload_handlers = upload_handlers[:index + 1]\n                break\n\n        for chunk in chunks:\n            for index, handler in enumerate(upload_handlers):\n                chunk_length = len(chunk)\n                chunk = handler.receive_data_chunk(chunk, counters[index])\n                counters[index] += chunk_length\n                if chunk is None:\n                    break\n\n        for index, handler in enumerate(upload_handlers):\n            file_obj = handler.file_complete(counters[index])\n            if file_obj:\n                return DataAndFiles({}, {'file': file_obj})\n        raise ParseError(\"FileUpload parse error - \"\n                         \"none of upload handlers can handle the stream\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_filename(self, stream, media_type, parser_context):\n        try:\n            return parser_context['kwargs']['filename']\n        except KeyError:\n            pass\n\n        try:\n            meta = parser_context['request'].META\n            disposition = parse_header(meta['HTTP_CONTENT_DISPOSITION'].encode('utf-8'))\n            filename_parm = disposition[1]\n            if 'filename*' in filename_parm:\n                return self.get_encoded_filename(filename_parm)\n            return force_text(filename_parm['filename'])\n        except (AttributeError, KeyError, ValueError):\n            pass", "response": "Detects the uploaded file name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_encoded_filename(self, filename_parm):\n        encoded_filename = force_text(filename_parm['filename*'])\n        try:\n            charset, lang, filename = encoded_filename.split('\\'', 2)\n            filename = urlparse.unquote(filename)\n        except (ValueError, LookupError):\n            filename = force_text(filename_parm['filename'])\n        return filename", "response": "Get the filename encoded in RFC6266."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef standardize(self):\n\n\n        nonmissing = numpy.invert(self.missing)\n        nmcount = numpy.sum(nonmissing)\n\n        self.covariates = []\n        self.phenotypes = []\n\n        for idx in range(0, self.covar_count):\n            x = self.datasource.covariate_data[idx]\n            nonmissing = x != PhenoCovar.missing_encoding\n            mx = numpy.mean(x[nonmissing])\n            sx = numpy.std(x[nonmissing])\n            self.covariates.append((x-mx)/sx)\n\n        for idx in range(0, self.pheno_count):\n            y = self.datasource.phenotype_data[idx]\n            nonmissing = y != PhenoCovar.missing_encoding\n            my = numpy.mean(y[nonmissing])\n            sy = numpy.std(y[nonmissing])\n            self.phenotypes.append((y-my)/sy)", "response": "Standardize the variables within a range [-1. 0 and 1. 0 )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrevert betas and variance components back to the original scale.", "response": "def destandardize(self, estimates, se, **kwargs):\n        \"\"\"Revert the betas and variance components back to the original scale.\n\n        \"\"\"\n        pvalues = kwargs[\"pvalues\"]\n        v = kwargs[\"v\"]\n        nonmissing=kwargs[\"nonmissing\"]\n        pheno = self.datasource.phenotype_data[self.idx][self.datasource.phenotype_data[self.idx] != PhenoCovar.missing_encoding]\n        covariates = []\n        mmx = []\n        ssx = []\n        a = [1,0]\n\n        for c in self.datasource.covariate_data:\n            covariates.append(c[c!=PhenoCovar.missing_encoding])\n            mmx.append(numpy.mean(covariates[-1]))\n            ssx.append(numpy.std(covariates[-1]))\n            a.append(-mmx[-1]/ssx[-1])\n        if len(mmx) < 1:\n            mmx = 1\n            ssx = 1\n        else:\n            mmx = numpy.array(mmx)\n            ssx = numpy.array(ssx)\n        covariates = numpy.array(covariates)\n        ssy = numpy.std(pheno)\n        mmy = numpy.mean(pheno)\n        # Quick scratch pad for Chun's new destandardization\n        ccount = len(covariates) + 2\n        a=numpy.array(a)\n\n        meanpar = list([mmy + ssy * (estimates[0] - numpy.sum(estimates[2:ccount]*mmx/ssx)),\n                    estimates[1] * ssy])\n\n\n        meanse = [ssy*numpy.sqrt(a.dot(v[0:ccount, 0:ccount]).dot(a.transpose())),\n                  ssy * se[1]]\n        varpar = [2*numpy.log(ssy) + estimates[ccount] - numpy.sum(estimates[ccount+2:]*mmx/ssx),\n                  estimates[ccount+1]]\n        varse = [numpy.sqrt(a.dot(v[ccount:, ccount:]).dot(a.transpose())),\n                 se[ccount+1]]\n        if ccount > 2:\n            meanpar += list(estimates[2:ccount] * ssy / ssx)\n            meanse += list(ssy * se[2:ccount]/ssx)\n            varpar += list(estimates[ccount+2:]/ssx)\n            varse += list(se[ccount+2:]/ssx)\n        pvals = 2*scipy.stats.norm.cdf(-numpy.absolute(numpy.array(meanpar+varpar)/numpy.array(meanse+varse)))\n\n\n\n        return meanpar+varpar, meanse + varse, pvals"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndetecting the current version of the application.", "response": "def detect(self, app):\n        \"\"\"\n        Given an app, run detect script on it to determine whether it can be\n        built with this pack.  Return True/False.\n        \"\"\"\n        script = os.path.join(self.folder, 'bin', 'detect')\n        cmd = '%s %s' % (script, app.folder)\n        result = run(cmd)\n        return result.status_code == 0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a tar. bz2 file with all of the contents inside this folder and return a Build object with the attributes for appname appversion time and path.", "response": "def tar(self, appname, appversion):\n        \"\"\"\n        Given an app name and version to be used in the tarball name,\n        create a tar.bz2 file with all of this folder's contents inside.\n\n        Return a Build object with attributes for appname, appversion,\n        time, and path.\n        \"\"\"\n        name_tmpl = '%(app)s-%(version)s-%(time)s.tar.bz2'\n        time = utc.now()\n        name = name_tmpl % {'app': appname,\n                            'version': appversion,\n                            'time': time.strftime('%Y-%m-%dT%H-%M')}\n\n        if not os.path.exists(TARBALL_HOME):\n            os.mkdir(TARBALL_HOME)\n        tarball = os.path.join(TARBALL_HOME, name)\n        tar_params = {'filename': tarball, 'folder': self.folder}\n        tar_result = run('tar -C %(folder)s -cjf %(filename)s .' % tar_params)\n        tar_result.raise_for_status()\n        return Build(appname, appversion, time, tarball)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef config_dir(mkcustom=False):\n    from acorn.utility import reporoot\n    from acorn.base import testmode\n    from os import path\n    alternate = path.join(path.abspath(path.expanduser(\"~\")), \".acorn\")\n    if testmode or (not path.isdir(alternate) and not mkcustom):\n        return path.join(reporoot, \"acorn\", \"config\")\n    else:\n        if mkcustom:# pragma: no cover\n            #This never gets reached when we are in testmode because we don't\n            #want to clobber the user's local config cache.\n            from os import mkdir\n            mkdir(alternate)\n        return alternate", "response": "Returns the configuration directory for the current user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the full path to the default configuration file for the given python package.", "response": "def _package_path(package):\n    \"\"\"Returns the full path to the default package configuration file.\n\n    Args:\n    package (str): name of the python package to return a path for.    \n    \"\"\"\n    from os import path\n    confdir = config_dir()\n    return path.join(confdir, \"{}.cfg\".format(package))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _read_single(parser, filepath):\n    from os import path\n    global packages\n    if path.isfile(filepath):\n        parser.readfp(open(filepath))", "response": "Reads a single config file into the parser."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the config settings for the specified python package.", "response": "def settings(package, reload_=False):\n    \"\"\"Returns the config settings for the specified package.\n\n    Args:\n        package (str): name of the python package to get settings for.\n    \"\"\"\n    global packages\n    if package not in packages or reload_:\n        from os import path\n        result = CaseConfigParser()\n        if package != \"acorn\":\n            confpath = _package_path(package)\n            _read_single(result, confpath)\n        _read_single(result, _package_path(\"acorn\"))\n        packages[package] = result\n\n    return packages[package]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dictionary of descriptors deserialized from JSON for the specified package.", "response": "def descriptors(package):\n    \"\"\"Returns a dictionary of descriptors deserialized from JSON for the\n    specified package.\n\n    Args:\n        package (str): name of the python package to get settings for.\n    \"\"\"\n    from os import path\n    dpath = _descriptor_path(package)\n    if path.isfile(dpath):\n        import json\n        with open(dpath) as f:\n            jdb = json.load(f)\n        return jdb\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a dictionary of parameters contained in a magnet uri", "response": "def parse_magnet(magnet_uri):\n    \"\"\"returns a dictionary of parameters contained in a magnet uri\"\"\"\n    data = defaultdict(list)\n    if not magnet_uri.startswith('magnet:'):\n        return data\n    else:\n        magnet_uri = magnet_uri.strip('magnet:?')\n        for segment in magnet_uri.split('&'):\n            key, value = segment.split('=')\n            if key == 'dn':\n                data['name'] = requests.utils.unquote(value).replace('+', '.')\n            elif key == 'xt':\n                data['infoHash'] = value.strip('urn:btih:')\n            elif key == 'tr':\n                data['trackers'].append(requests.utils.unquote(value))\n            else:\n                data[key] = value\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing local or remote torrent file", "response": "def parse_torrent_file(torrent):\n    \"\"\"parse local or remote torrent file\"\"\"\n    link_re = re.compile(r'^(http?s|ftp)')\n    if link_re.match(torrent):\n        response = requests.get(torrent, headers=HEADERS, timeout=20)\n        data = parse_torrent_buffer(response.content)\n    elif os.path.isfile(torrent):\n        with open(torrent, 'rb') as f:\n            data = parse_torrent_buffer(f.read())\n    else:\n        data = None\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a torrent buffer into a dictionary of metadata", "response": "def parse_torrent_buffer(torrent):\n    \"\"\"parse a torrent buffer\"\"\"\n    md = {}\n    try:\n        metadata = bencode.bdecode(torrent)\n    except bencode.BTL.BTFailure:\n        print 'Not a valid encoded torrent'\n        return None\n    if 'announce-list' in metadata:\n        md['trackers'] = []\n        for tracker in metadata['announce-list']:\n            md['trackers'].append(tracker[0])\n    if 'announce' in metadata:\n        md['trackers'].append(metadata['announce'])\n    md['trackers'] = list(set(md['trackers']))\n    if 'name' in metadata['info']:\n        md['name'] = metadata['info']['name']\n    webseeds = []\n    if 'httpseeds' in metadata:\n        webseeds = metadata['httpseeds']\n    if 'url-list' in metadata:\n        webseeds += md['url-list']\n    if webseeds:\n        md['webseeds'] = webseeds\n    if 'created by' in metadata:\n        md['creator'] = metadata['created by']\n    if 'creation date' in metadata:\n        utc_dt = datetime.utcfromtimestamp(metadata['creation date'])\n        md['created'] = utc_dt.strftime('%Y-%m-%d %H:%M:%S')\n    if 'comment' in metadata:\n        md['comment'] = metadata['comment']\n    md['piece_size'] = metadata['info']['piece length']\n    if 'length' in metadata['info']:\n        md['file'] = {'path': metadata['info']['name'],\n                      'length': metadata['info']['length']}\n    if 'files' in metadata['info']:\n        md['files'] = []\n        for item in metadata['info']['files']:\n            md['files'].append(\n                {'path': item['path'][0], 'length': item['length']})\n    # TODO check if torrent is private and encoding\n    hashcontents = bencode.bencode(metadata['info'])\n    digest = hashlib.sha1(hashcontents).digest()\n    md['infoHash'] = hashlib.sha1(hashcontents).hexdigest()\n    b32hash = base64.b32encode(digest)\n    md['infoHash_b32'] = b32hash\n    md['pieces'] = _split_pieces(metadata['info']['pieces'])\n    md['total_size'] = hsize(sum([x['length'] for x in md['files']]))\n    return md"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hsize(bytes):\n    sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']\n    if bytes == 0:\n        return '0 Byte'\n    i = int(math.floor(math.log(bytes) / math.log(1024)))\n    r = round(bytes / math.pow(1024, i), 2)\n    return str(r) + '' + sizes[i]", "response": "converts a bytes to human - readable format"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ratio(leechs, seeds):\n    try:\n        ratio = float(seeds) / float(leechs)\n    except ZeroDivisionError:\n        ratio = int(seeds)\n    return ratio", "response": "computes the torrent ratio"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_torrent(magnet_link):\n    infoHash = parse_magnet(magnet_link)['infoHash']\n    torcache = 'http://torcache.net/torrent/' + infoHash + '.torrent'\n    torrage = 'https://torrage.com/torrent/' + infoHash + '.torrent'\n    reflektor = 'http://reflektor.karmorra.info/torrent/' + \\\n        infoHash + '.torrent'\n    thetorrent = 'http://TheTorrent.org/'+infoHash\n    btcache = 'http://www.btcache.me/torrent/'+infoHash\n    for link in [torcache, torrage, reflektor, btcache, thetorrent]:\n        try:\n            print \"Checking \"+link\n            response = requests.head(link, headers=HEADERS)\n            if response.headers['content-type'] in ['application/x-bittorrent',\n                                                    'application/octet-stream']:\n                return link\n        except requests.exceptions.ConnectionError:\n            pass\n    return", "response": "turn a magnet link to a link to a torrent file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_story():\n    return Story(\n        slug=\"la-data-latimes-ipsum\",\n        headline=\"This is not a headline\",\n        byline=\"This is not a byline\",\n        pub_date=datetime.now(),\n        canonical_url=\"http://www.example.com/\",\n        kicker=\"This is not a kicker\",\n        description=lorem_ipsum.COMMON_P.split(\".\")[0],\n        sources=\"This is not a source\",\n        credits=\"This is not a credit\",\n        content=six.text_type('\\n\\n'.join(lorem_ipsum.paragraphs(6))),\n        image=get_image(900)\n    )", "response": "Returns a boiler plate story as an object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_related_items(count=4):\n    defaults = dict(\n        headline=\"This is not a headline\",\n        url=\"http://www.example.com/\",\n        image=get_image(400, 400)\n    )\n    return [RelatedItem(**defaults) for x in range(0, count)]", "response": "Returns the requested number of boiler plate related items as a list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn an image with the given width height and background color as requested.", "response": "def get_image(width, height=None, background_color=\"cccccc\", random_background_color=False):\n    \"\"\"\n    Returns image with caption, credit, and random background color as requested.\n    \"\"\"\n    return Image(\n        url=placeholdit.get_url(\n            width,\n            height=height,\n            background_color=background_color,\n            random_background_color=random_background_color\n        ),\n        credit=\"This is not an image credit\",\n        caption=\"This is not a caption\"\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_context(self, serializer_field):\n        # Determine the underlying model field name. This may not be the\n        # same as the serializer field name if `source=<>` is set.\n        self.field_name = serializer_field.source_attrs[0]\n        # Determine the existing instance, if this is an update operation.\n        self.instance = getattr(serializer_field.parent, 'instance', None)", "response": "Set the context of the current object based on the serializer field."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef filter_queryset(self, value, queryset):\n        filter_kwargs = {self.field_name: value}\n        return queryset.filter(**filter_kwargs)", "response": "Filter the queryset to only instances matching the given attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef exclude_current_instance(self, queryset):\n        if self.instance is not None:\n            return queryset.exclude(pk=self.instance.pk)\n        return queryset", "response": "Exclude the current instance from the queryset."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef enforce_required_fields(self, attrs):\n        if self.instance is not None:\n            return\n\n        missing = {\n            field_name: self.missing_message\n            for field_name in self.fields\n            if field_name not in attrs\n        }\n        if missing:\n            raise ValidationError(missing)", "response": "Enforces that the unique TogetherValidator always forces an implied required state on the fields it applies to."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef filter_queryset(self, attrs, queryset):\n        # If this is an update, then any unprovided field should\n        # have it's value set based on the existing instance attribute.\n        if self.instance is not None:\n            for field_name in self.fields:\n                if field_name not in attrs:\n                    attrs[field_name] = getattr(self.instance, field_name)\n\n        # Determine the filter keyword arguments and filter the queryset.\n        filter_kwargs = {\n            field_name: attrs[field_name]\n            for field_name in self.fields\n        }\n        return queryset.filter(**filter_kwargs)", "response": "Filter the queryset to all instances matching the given attributes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the context of the object.", "response": "def set_context(self, serializer):\n        \"\"\"\n        This hook is called by the serializer instance,\n        prior to the validation call being made.\n        \"\"\"\n        # Determine the underlying model field names. These may not be the\n        # same as the serializer field names if `source=<>` is set.\n        self.field_name = serializer.fields[self.field].source_attrs[0]\n        self.date_field_name = serializer.fields[self.date_field].source_attrs[0]\n        # Determine the existing instance, if this is an update operation.\n        self.instance = getattr(serializer, 'instance', None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef enforce_required_fields(self, attrs):\n        missing = {\n            field_name: self.missing_message\n            for field_name in [self.field, self.date_field]\n            if field_name not in attrs\n        }\n        if missing:\n            raise ValidationError(missing)", "response": "The UniqueFor<Range >Validator class always forces an implied\n        required state on the fields they are applied to."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmodify the view with the get item as extra context", "response": "def modify(self, view):\n        \"\"\"\n        adds the get item as extra context\n        \"\"\"\n        view.params['extra_context'][self.get['name']] = self.get['value']\n        return view"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite this object to the given output protocol and returns self.", "response": "def write(self, oprot):\n        '''\n        Write this object to the given output protocol and return self.\n\n        :type oprot: thryft.protocol._output_protocol._OutputProtocol\n        :rtype: pastpy.gen.database.impl.online.online_database_configuration.OnlineDatabaseConfiguration\n        '''\n\n        oprot.write_struct_begin('OnlineDatabaseConfiguration')\n\n        oprot.write_field_begin(name='collection_name', type=11, id=None)\n        oprot.write_string(self.collection_name)\n        oprot.write_field_end()\n\n        if self.download_dir_path is not None:\n            oprot.write_field_begin(name='download_dir_path', type=11, id=None)\n            oprot.write_string(self.download_dir_path)\n            oprot.write_field_end()\n\n        oprot.write_field_stop()\n\n        oprot.write_struct_end()\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_args_and_kwargs(self):\n\n        args = None\n        kwargs = None\n\n        if self.args:\n            args = []\n            kwargs = {}\n            for arg in self.args:\n                if arg.is_named:\n                    kwargs[arg.arg] = arg.value\n                else:\n                    args.append(arg.value)\n\n        return args, kwargs", "response": "Return a list and a dict usable as * args and ** kwargs to pass to a callable."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets list of S3 Buckets", "response": "def get_bucket_list():\n    \"\"\"\n    Get list of S3 Buckets\n    \"\"\"\n    args = parser.parse_args()\n    for b in s3_conn(args.aws_access_key_id, args.aws_secret_access_key).get_all_buckets():\n        print(''.join([i if ord(i) < 128 else ' ' for i in b.name]))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a generator that generates backspace and backline characters for the next frame.", "response": "def _get_back_up_generator(frame_function, *args, **kwargs):\n    \"\"\"Create a generator for the provided animation function that backs up\n    the cursor after a frame. Assumes that the animation function provides\n    a generator that yields strings of constant width and height.\n\n    Args:\n        frame_function: A function that returns a FrameGenerator.\n        args: Arguments for frame_function.\n        kwargs: Keyword arguments for frame_function.\n    Returns:\n        a generator that generates backspace/backline characters for\n        the animation func generator.\n    \"\"\"\n    lines = next(frame_function(*args, **kwargs)).split('\\n')\n    width = len(lines[0])\n    height = len(lines)\n    if height == 1:\n        return util.BACKSPACE_GEN(width)\n    return util.BACKLINE_GEN(height)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nturns an animation into an automatically backspaced animation.", "response": "def _backspaced_single_line_animation(animation_, *args, **kwargs):\n    \"\"\"Turn an animation into an automatically backspaced animation.\n\n    Args:\n        animation: A function that returns a generator that yields\n        strings for animation frames.\n        args: Arguments for the animation function.\n        kwargs: Keyword arguments for the animation function.\n    Returns:\n        the animation generator, with backspaces applied to each but the first\n        frame.\n    \"\"\"\n    animation_gen = animation_(*args, **kwargs)\n    yield next(animation_gen)  # no backing up on the first frame\n    yield from util.concatechain(\n        util.BACKSPACE_GEN(kwargs['width']), animation_gen)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nraises TypeError if a function is decorated with Annotate.", "response": "def _raise_if_annotated(self, func):\n        \"\"\"Raise TypeError if a function is decorated with Annotate, as such\n        functions cause visual bugs when decorated with Animate.\n\n        Animate should be wrapped by Annotate instead.\n\n        Args:\n            func (function): Any callable.\n        Raises:\n            TypeError\n        \"\"\"\n        if hasattr(func, ANNOTATED) and getattr(func, ANNOTATED):\n            msg = ('Functions decorated with {!r} '\n                   'should not be decorated with {!r}.\\n'\n                   'Please reverse the order of the decorators!'.format(\n                       self.__class__.__name__, Annotate.__name__))\n            raise TypeError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _start_print(self):\n        if self._start_no_nl:\n            sys.stdout.write(self._start_msg)\n            sys.stdout.flush()\n        else:\n            print(self._start_msg)", "response": "Print the start message with or without newline depending on the _start_no_nl variable."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _sync_call(self, func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            if self._start_msg:\n                self._start_print()\n            result = func(*args, **kwargs)\n            if self._end_msg:\n                print(self._end_msg)\n            return result\n\n        setattr(wrapper, ANNOTATED, True)\n        return wrapper", "response": "A function to be used in the synchronous function."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nresetting the current generator.", "response": "def reset(self):\n        \"\"\"Reset the current animation generator.\"\"\"\n        animation_gen = self._frame_function(*self._animation_args,\n                                             **self._animation_kwargs)\n        self._current_generator = itertools.cycle(\n            util.concatechain(animation_gen, self._back_up_generator))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a frame that completely erases the current frame and then backs up.", "response": "def get_erase_frame(self):\n        \"\"\"Return a frame that completely erases the current frame, and then\n        backs up.\n\n        Assumes that the current frame is of constant width.\"\"\"\n        lines = self._current_frame.split('\\n')\n        width = len(lines[0])\n        height = len(lines)\n        line = ' ' * width\n        if height == 1:\n            frame = line + BACKSPACE * width\n        else:\n            frame = '\\n'.join([line] * height) + BACKLINE * (height - 1)\n        return frame"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef runAllInDir(dir_path, exclude=[], add_args=(), ignoreErrors=True):\n    print('testing all modules of %s' % dir_path)\n\n    if type(add_args) in (tuple, list):\n        sys.argv.extend(add_args)\n    else:\n        sys.argv.append(add_args)\n    t = 0\n    failed = []\n    for _, modname, ispkg in pkgutil.walk_packages(\n            [dir_path],\n            #onerror=lambda x: None\n    ):\n        if not ispkg and modname != thismodname and modname not in exclude:  # don't test this module\n            print('... %s' % modname)\n            t0 = time()\n            try:\n                runpy.run_module(\n                    modname,\n                    init_globals=None,\n                    run_name='__main__',\n                    alter_sys=False)\n            except Exception as err:\n                if ignoreErrors:\n                    print(\"FAILED: %s\" % err)\n                else:\n                    raise err\n                failed.append((modname, err))\n            dt = time() - t0\n            t += dt\n            print('execution time=%s' % dt)\n    print('----------------')\n    print('time needed=%s' % t)\n    if failed:\n        print('=======================')\n        print('failed for %s modules' % len(failed))\n        print('-----------------------')\n        for mod, err in failed:\n            print(mod, err)", "response": "Execute all modules in a given directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild a CustomMetar object from a string or a CustomMetar object.", "response": "def get_metar(\n            metar: typing.Union[str, 'CustomMetar']\n    ) -> typing.Tuple[typing.Union[str, None], typing.Union['CustomMetar', None]]:\n        \"\"\"\n        Builds a CustomMetar object from a CustomMetar object (returns it), an ICAO code or a METAR string\n\n        Args:\n            metar: CustomMetar object, ICAO string or METAR string\n\n        Returns: CustomMetar object\n\n        \"\"\"\n        error: typing.Optional[str] = None\n        if isinstance(metar, CustomMetar):\n            return None, metar\n\n        if isinstance(metar, str):\n            LOGGER.debug('building CustomMetar from: %s', metar)\n            if len(metar) == 4:\n                LOGGER.debug('retrieving METAR from ICAO')\n                # NOAA has discontinued their hosting of raw METAR text files ...\n                # error, metar = noaa.retrieve_metar(metar)\n                # metar = avwx.AVWX.query_icao(metar).rawreport\n                metar = AWC.query_icao(metar).raw_metar\n        else:\n            error = f'expected a string or or a CustomMetar object, got: {type(metar)}'\n\n        if error:\n            return error, None\n\n        try:\n            return None, CustomMetar(metar_code=metar)\n        except ParserError:\n            return f'Unable to parse METAR: {metar}', None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef string(self):  # noqa: C901\n        lines = [\"station: %s\" % self.station_id]\n        if self.type:\n            lines.append(\"type: %s\" % self.report_type())\n        if self.time:\n            lines.append(\"time: %s\" % self.time.ctime())\n        if self.temp:\n            lines.append(\"temperature: %s\" % self.temp.string(\"C\"))\n        if self.dewpt:\n            lines.append(\"dew point: %s\" % self.dewpt.string(\"C\"))\n        if self.wind_speed:\n            lines.append(\"wind: %s\" % self.wind())\n        if self.wind_speed_peak:\n            lines.append(\"peak wind: %s\" % self.peak_wind())\n        if self.wind_shift_time:\n            lines.append(\"wind shift: %s\" % self.wind_shift())\n        if self.vis:\n            lines.append(\"visibility: %s\" % self.visibility())\n        if self.runway:\n            lines.append(\"visual range: %s\" % self.runway_visual_range())\n        if self.press:\n            lines.append(f\"pressure: {self.press.string('MB')} {self.press.string('IN')} {self.press.string('MM')}\")\n        if self.weather:\n            lines.append(\"weather: %s\" % self.present_weather())\n        if self.sky:\n            lines.append(\"sky: %s\" % self.sky_conditions(\"\\n     \"))\n        if self.press_sea_level:\n            lines.append(\"sea-level pressure: %s\" % self.press_sea_level.string(\"mb\"))\n        if self.max_temp_6hr:\n            lines.append(\"6-hour max temp: %s\" % str(self.max_temp_6hr))\n        if self.max_temp_6hr:\n            lines.append(\"6-hour min temp: %s\" % str(self.min_temp_6hr))\n        if self.max_temp_24hr:\n            lines.append(\"24-hour max temp: %s\" % str(self.max_temp_24hr))\n        if self.max_temp_24hr:\n            lines.append(\"24-hour min temp: %s\" % str(self.min_temp_24hr))\n        if self.precip_1hr:\n            lines.append(\"1-hour precipitation: %s\" % str(self.precip_1hr))\n        if self.precip_3hr:\n            lines.append(\"3-hour precipitation: %s\" % str(self.precip_3hr))\n        if self.precip_6hr:\n            lines.append(\"6-hour precipitation: %s\" % str(self.precip_6hr))\n        if self.precip_24hr:\n            lines.append(\"24-hour precipitation: %s\" % str(self.precip_24hr))\n        if self._remarks:\n            lines.append(\"remarks:\")\n            lines.append(\"- \" + self.remarks(\"\\n- \"))\n        if self._unparsed_remarks:\n            lines.append(\"- \" + ' '.join(self._unparsed_remarks))\n        lines.append(\"METAR: \" + self.code)\n        return \"\\n\".join(lines)", "response": "Return a human - readable version of the report."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses an altimeter - pressure group.", "response": "def _handlePressure(self, d):\n        \"\"\"\n        Parse an altimeter-pressure group.\n\n        The following attributes are set:\n            press    [int]\n        \"\"\"\n        press = d['press']\n        if press != '////':\n            press = float(press.replace('O', '0'))\n            if d['unit']:\n                if d['unit'] == 'A' or (d['unit2'] and d['unit2'] == 'INS'):\n                    self.press = CustomPressure(press / 100, 'IN')\n                elif d['unit'] == 'SLP':\n                    if press < 500:\n                        press = press / 10 + 1000\n                    else:\n                        press = press / 10 + 900\n                    self.press = CustomPressure(press)\n                    self._remarks.append(\"sea-level pressure %.1fhPa\" % press)\n                else:\n                    self.press = CustomPressure(press)\n            elif press > 2500:\n                self.press = CustomPressure(press / 100, 'IN')\n            else:\n                self.press = CustomPressure(press)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _handleSealvlPressRemark(self, d):\n        value = float(d['press']) / 10.0\n        if value < 50:\n            value += 1000\n        else:\n            value += 900\n        if not self.press:\n            self.press = CustomPressure(value)\n        self.press_sea_level = CustomPressure(value)", "response": "Parse the sea - level pressure remark group."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_tasklogger(name=\"TaskLogger\"):\n    try:\n        return logging.getLogger(name).tasklogger\n    except AttributeError:\n        return logger.TaskLogger(name)", "response": "Returns a TaskLogger object for the given logger name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef log_start(task, logger=\"TaskLogger\"):\n    tasklogger = get_tasklogger(logger)\n    tasklogger.start_task(task)\n    return tasklogger", "response": "Begin logging a task in the default task logger"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlogging a DEBUG message to the default Logger", "response": "def log_debug(msg, logger=\"TaskLogger\"):\n    \"\"\"Log a DEBUG message\n\n    Convenience function to log a message to the default Logger\n\n    Parameters\n    ----------\n    msg : str\n        Message to be logged\n    logger : str, optional (default: \"TaskLogger\")\n        Unique name of the logger to retrieve\n\n    Returns\n    -------\n    logger : TaskLogger\n    \"\"\"\n    tasklogger = get_tasklogger(logger)\n    tasklogger.debug(msg)\n    return tasklogger"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlog an INFO message to the default Logger", "response": "def log_info(msg, logger=\"TaskLogger\"):\n    \"\"\"Log an INFO message\n\n    Convenience function to log a message to the default Logger\n\n    Parameters\n    ----------\n    msg : str\n        Message to be logged\n    logger : str, optional (default: \"TaskLogger\")\n        Unique name of the logger to retrieve\n\n    Returns\n    -------\n    logger : TaskLogger\n    \"\"\"\n    tasklogger = get_tasklogger(logger)\n    tasklogger.info(msg)\n    return tasklogger"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef log_warning(msg, logger=\"TaskLogger\"):\n    tasklogger = get_tasklogger(logger)\n    tasklogger.warning(msg)\n    return tasklogger", "response": "Log a WARNING message to the default Logger"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlogs an ERROR message to the specified logger", "response": "def log_error(msg, logger=\"TaskLogger\"):\n    \"\"\"Log an ERROR message\n\n    Convenience function to log a message to the default Logger\n\n    Parameters\n    ----------\n    msg : str\n        Message to be logged\n    logger : str, optional (default: \"TaskLogger\")\n        Unique name of the logger to retrieve\n\n    Returns\n    -------\n    logger : TaskLogger\n    \"\"\"\n    tasklogger = get_tasklogger(logger)\n    tasklogger.error(msg)\n    return tasklogger"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlogs a CRITICAL message to the default Logger", "response": "def log_critical(msg, logger=\"TaskLogger\"):\n    \"\"\"Log a CRITICAL message\n\n    Convenience function to log a message to the default Logger\n\n    Parameters\n    ----------\n    msg : str\n        Message to be logged\n    name : `str`, optional (default: \"TaskLogger\")\n        Name used to retrieve the unique TaskLogger\n\n    Returns\n    -------\n    logger : TaskLogger\n    \"\"\"\n    tasklogger = get_tasklogger(logger)\n    tasklogger.critical(msg)\n    return tasklogger"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the logging level of the base log file.", "response": "def set_level(level=1, logger=\"TaskLogger\"):\n    \"\"\"Set the logging level\n\n    Convenience function to set the logging level\n\n    Parameters\n    ----------\n    level : `int` or `bool` (optional, default: 1)\n        If False or 0, prints WARNING and higher messages.\n        If True or 1, prints INFO and higher messages.\n        If 2 or higher, prints all messages.\n\n    Returns\n    -------\n    logger : TaskLogger\n    \"\"\"\n    tasklogger = get_tasklogger(logger)\n    tasklogger.set_level(level)\n    return tasklogger"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the timer function", "response": "def set_timer(timer='wall', logger=\"TaskLogger\"):\n    \"\"\"Set the timer function\n\n    Convenience function to set the task timer\n\n    Parameters\n    ----------\n    timer : {'wall', 'cpu', or callable}, optional, default='wall'\n            Timer function used to measure task running times.\n            'wall' uses `time.time`, 'cpu' uses `time.process_time`\n\n    Returns\n    -------\n    logger : TaskLogger\n    \"\"\"\n    tasklogger = get_tasklogger(logger)\n    tasklogger.set_timer(timer)\n    return tasklogger"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the indent size of the", "response": "def set_indent(indent=2, logger=\"TaskLogger\"):\n    \"\"\"Set the indent function\n\n    Convenience function to set the indent size\n\n    Parameters\n    ----------\n    indent : int, optional (default: 2)\n        number of spaces by which to indent based on the\n        number of tasks currently running`\n\n    Returns\n    -------\n    logger : TaskLogger\n    \"\"\"\n    tasklogger = get_tasklogger(logger)\n    tasklogger.set_indent(indent)\n    return tasklogger"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gridPointsFromEdges(edges, nCells, dtype=float):\n    e = edges\n    sx, sy = nCells[0] + 1, nCells[1] + 1\n    # horizontal lines\n    x0 = np.linspace(e[0, 0], e[3, 0], sy, dtype=dtype)\n    x1 = np.linspace(e[1, 0], e[2, 0], sy, dtype=dtype)\n\n    y0 = np.linspace(e[0, 1], e[3, 1], sy, dtype=dtype)\n    y1 = np.linspace(e[1, 1], e[2, 1], sy, dtype=dtype)\n    # points:\n    p = np.empty(shape=(sx * sy, 2))\n    n0 = 0\n    n1 = sx\n    for x0i, x1i, y0i, y1i in zip(x0, x1, y0, y1):\n        p[n0:n1, 0] = np.linspace(x0i, x1i, sx)\n        p[n0:n1, 1] = np.linspace(y0i, y1i, sx)\n        n0 = n1\n        n1 += sx\n    return p", "response": "Creates a 2d grid from given edges"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef main(miz_path):\n    from emiz.miz import Miz\n    with Miz(miz_path) as m:\n        mis = m.mission\n\n    result = defaultdict(dict)\n    for unit in mis.units:\n        airport, spot = unit.group_name.split('#')\n        spot = int(spot)\n        # print(airport, int(spot), unit.unit_position)\n        result[airport][spot] = unit.unit_position\n\n    import pickle  # nosec\n    with open('_parking_spots.py', mode='w') as f:\n        f.write('parkings = {}\\n'.format(pickle.dumps(result)))", "response": "This is the main function for the _parking_spots. py script."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntraverse to the item specified by name.", "response": "def _traverse(self, name, create_missing=False, action=None, value=NO_DEFAULT):\n        \"\"\"Traverse to the item specified by ``name``.\n\n        To create missing items on the way to the ``name``d item, pass\n        ``create_missing=True``. This will insert an item for each\n        missing segment in ``name``. The type and value of item that\n        will be inserted for a missing segment depends on the *next*\n        segment. If a ``default`` value is passed, the ``name``d item\n        will be set to this value; otherwise, a default default will\n        be used. See :meth:`_create_segment` for more info.\n\n        \"\"\"\n        obj = self\n        segments = self._parse_path(name)\n\n        for segment, next_segment in zip(segments, segments[1:] + [None]):\n            last = next_segment is None\n\n            if create_missing:\n                self._create_segment(obj, segment, next_segment)\n\n            try:\n                next_obj = obj[segment]\n            except IndexError:\n                raise KeyError(segment)\n\n            if not last:\n                obj = next_obj\n            else:\n                if action:\n                    value = action(obj, segment)\n                elif value is not NO_DEFAULT:\n                    obj[segment] = value\n                else:\n                    value = obj[segment]\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates the missing segment in obj.", "response": "def _create_segment(self, obj, segment, next_segment):\n        \"\"\"Create ``obj[segment]`` if missing.\n\n        The default value for a missing segment is based on the *next*\n        segment, unless a ``default`` is explicitly passed.\n\n        If the next segment is an int, the default will be a list with\n        the indicated number of items. Otherwise the default will be\n        a :class:`Settings` dict.\n\n        \"\"\"\n        if isinstance(next_segment, int):\n            value = [PLACEHOLDER] * (next_segment + 1)\n        else:\n            value = Settings()\n        if isinstance(obj, Mapping):\n            if segment not in obj:\n                obj[segment] = value\n        elif isinstance(obj, Sequence):\n            old_len = len(obj)\n            new_len = segment + 1\n            if new_len > old_len:\n                obj.extend([PLACEHOLDER] * (new_len - old_len))\n            if obj[segment] is PLACEHOLDER:\n                obj[segment] = value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_path(self, path):\n        if not path:\n            raise ValueError('path cannot be empty')\n\n        segments = []\n        path_iter = zip(iter(path), chain(path[1:], (None,)))\n        if six.PY2:\n            # zip() returns a list on Python 2\n            path_iter = iter(path_iter)\n        convert_name = self._convert_name\n        current_segment = []\n        current_segment_contains_group = False\n\n        def append_segment():\n            segment = ''.join(current_segment)\n            if not current_segment_contains_group:\n                segment = convert_name(segment)\n            segments.append(segment)\n            del current_segment[:]\n\n        for c, d in path_iter:\n            if c == '.':\n                append_segment()\n                current_segment_contains_group = False\n            elif c == '(':\n                nested = 0\n                for c, d in path_iter:\n                    current_segment.append(c)\n                    if c == '(':\n                        nested += 1\n                    elif c == ')':\n                        if nested:\n                            nested -= 1\n                        else:\n                            current_segment.pop()  # Remove the closing paren\n                            current_segment_contains_group = True\n                            break\n                else:\n                    raise ValueError('Unclosed (...) in %s' % path)\n            elif c == '{' and d == '{':\n                current_segment_contains_group = True\n                current_segment.append(c)\n                for c, d in path_iter:\n                    current_segment.append(c)\n                    if c == '}' and d == '}':\n                        current_segment_contains_group = True\n                        break\n                else:\n                    raise ValueError('Unclosed {{...}} in %s' % path)\n            else:\n                current_segment.append(c)\n\n        if current_segment:\n            append_segment()\n\n        return segments", "response": "Parse path into segments."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts name to int.", "response": "def _convert_name(self, name):\n        \"\"\"Convert ``name`` to int if it looks like an int.\n\n        Otherwise, return it as is.\n\n        \"\"\"\n        if re.search('^\\d+$', name):\n            if len(name) > 1 and name[0] == '0':\n                # Don't treat strings beginning with \"0\" as ints\n                return name\n            return int(name)\n        return name"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstarts the consumer for messages from a queue.", "response": "async def basic_consume(self, queue_name='', consumer_tag='',\n                            no_local=False, no_ack=False, exclusive=False,\n                            no_wait=False, arguments=None, wait_message=True,\n                            timeout=0):\n        \"\"\"Starts the consumption of message into a queue.\n        the callback will be called each time we're receiving a message.\n\n            Args:\n                queue_name:     str, the queue to receive message from\n                consumer_tag:   str, optional consumer tag\n                no_local:       bool, if set the server will not send messages\n                                to the connection that published them.\n                no_ack:         bool, if set the server does not expect\n                                acknowledgements for messages\n                exclusive:      bool, request exclusive consumer access,\n                                meaning only this consumer can access the queue\n                no_wait:        bool, if set, the server will not respond to\n                                the method\n                arguments:      dict, AMQP arguments to be passed to the server\n                wait_message:   Indicates if the consumer should wait for new\n                                messages in the queue or simply return None if\n                                the queue is empty.\n                timeout:        A timeout for waiting messages.\n                                ``wait_message`` has precendence over timeout.\n        \"\"\"\n        # If a consumer tag was not passed, create one\n        consumer_tag = consumer_tag or 'ctag%i.%s' % (\n            self.channel_id, uuid.uuid4().hex)\n\n        if arguments is None:\n            arguments = {}\n\n        frame = amqp_frame.AmqpRequest(\n            self.protocol._stream_writer, amqp_constants.TYPE_METHOD,\n            self.channel_id)\n        frame.declare_method(\n            amqp_constants.CLASS_BASIC, amqp_constants.BASIC_CONSUME)\n        request = amqp_frame.AmqpEncoder()\n        request.write_short(0)\n        request.write_shortstr(queue_name)\n        request.write_shortstr(consumer_tag)\n        request.write_bits(no_local, no_ack, exclusive, no_wait)\n        request.write_table(arguments)\n\n        self.consumer_queues[consumer_tag] = asyncio.Queue(self.max_queue_size)\n        self.last_consumer_tag = consumer_tag\n\n        consumer = self.CONSUMER_CLASS(\n            self, self.consumer_queues[consumer_tag],\n            consumer_tag, nowait=not wait_message,\n            timeout=timeout)\n\n        await self._write_frame_awaiting_response(\n            'basic_consume', frame, request, no_wait)\n\n        if not no_wait:\n            self._ctag_events[consumer_tag].set()\n\n        return consumer"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the version of the current version of the plugin", "response": "def getPluginVersion():\n    \"\"\"The version must be updated in the .cdmp file\"\"\"\n    desc_file = os.path.join('cdmplugins', 'gc', plugin_desc_file)\n    if not os.path.exists(desc_file):\n        print('Cannot find the plugin description file. Expected here: ' +\n              desc_file, file=sys.stderr)\n        sys.exit(1)\n\n    with open(desc_file) as dec_file:\n        for line in dec_file:\n            line = line.strip()\n            if line.startswith('Version'):\n                return line.split('=')[1].strip()\n    print('Cannot find a version line in the ' + desc_file,\n          file=sys.stderr)\n    sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmatch and returns any certificates found except the first match.", "response": "def chainCerts(data):\n    \"\"\"\n    Matches and returns any certificates found except the first match.\n\n    Regex code copied from L{twisted.internet.endpoints._parseSSL}.\n    Related ticket: https://twistedmatrix.com/trac/ticket/7732\n\n    @type path: L{bytes}\n    @param data: PEM-encoded data containing the certificates.\n\n    @rtype: L{list} containing L{Certificate}s.\n    \"\"\"\n    matches = re.findall(\n        r'(-----BEGIN CERTIFICATE-----\\n.+?\\n-----END CERTIFICATE-----)',\n        data,\n        flags=re.DOTALL)\n    chainCertificates = [\n        Certificate.loadPEM(chainCertPEM).original\n        for chainCertPEM in matches]\n    return chainCertificates[1:]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef new(cls):\r\n\r\n        ''' a method to generate the current datetime as a labDT object\r\n        \r\n        :return: labDT object\r\n        '''\r\n\r\n        dT = datetime.utcnow().replace(tzinfo=pytz.utc)\r\n        dt_kwargs = {\r\n            'year': dT.year,\r\n            'month': dT.month,\r\n            'day': dT.day,\r\n            'hour': dT.hour,\r\n            'minute': dT.minute,\r\n            'second': dT.second,\r\n            'microsecond': dT.microsecond,\r\n            'tzinfo': dT.tzinfo\r\n        }\r\n        return labDT(**dt_kwargs)", "response": "a method to generate the current datetime as a labDT object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef epoch(self):\r\n\r\n        ''' a method to report posix epoch timestamp from a labDT object\r\n\r\n        :return: float with timestamp\r\n        '''\r\n\r\n    # construct epoch timestamp from labDT\r\n        epoch_dt = datetime.utcfromtimestamp(0).replace(tzinfo=pytz.utc)\r\n        delta_time = self - epoch_dt\r\n        return delta_time.total_seconds()", "response": "a method to report posix epoch timestamp from a labDT object"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rfc2822(self):\r\n\r\n        ''' \r\n            a method to report a RFC-2822 Compliant Date from a labDT object\r\n\r\n            https://tools.ietf.org/html/rfc2822.html#page-14\r\n\r\n        :return: string with RFC-2822 compliant date time\r\n        '''\r\n\r\n    # define format\r\n        js_format = '%a, %d %b %Y %H:%M:%S GMT'\r\n        utc_time = self.astimezone(pytz.utc)\r\n\r\n        return format(utc_time, js_format)", "response": "Returns a string with the RFC 2822 compliant date time"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef humanFriendly(self, time_zone='', include_day=True, include_time=True):\r\n\r\n        ''' a method to report a human friendly string from a labDT object\r\n\r\n        :param time_zone: [optional] string with timezone to report in\r\n        :return: string with date and time info\r\n        '''\r\n\r\n    # validate inputs\r\n        zeroHourPattern = re.compile('\\s0\\d:')\r\n        title = 'Timezone input for labDT.humanFriendly'\r\n        human_format = ''\r\n        if include_day:\r\n            human_format += '%A, '\r\n        human_format += '%B %d, %Y'\r\n        if include_time:\r\n            human_format += ' %I:%M%p %Z'\r\n        get_tz = get_localzone()\r\n        if time_zone:\r\n            # if time_zone.lower() in ('utc', 'uct', 'universal', 'zulu'):\r\n            #     raise ValueError('time_zone cannot be UTC. %s requires a local timezone value. Try:\\nfor tz in pytz.all_timezones:\\n  print tz' % title)\r\n            try:\r\n                get_tz = tz.gettz(time_zone)\r\n            except:\r\n                raise ValueError('%s is not a valid timezone format. Try:\\nfor tz in pytz.all_timezones:\\n  print tz' % title)\r\n        \r\n    # construct human friendly string from labDT\r\n        dtLocal = self.astimezone(get_tz)\r\n        dtString = format(dtLocal, human_format)\r\n        zeroHour = zeroHourPattern.findall(dtString)\r\n        if zeroHour:\r\n            noZero = zeroHour[0].replace(' 0',' ')\r\n            dtString = zeroHourPattern.sub(noZero,dtString)\r\n        return dtString", "response": "a method to report a human friendly string from a labDT object"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fromISO(cls, iso_string):\r\n\r\n        ''' a method for constructing a labDT object from a timezone aware ISO string\r\n        \r\n        :param iso_string: string with date and time info in ISO format\r\n        :return: labDT object\r\n        '''\r\n\r\n    # validate input\r\n        title = 'ISO time input for labDT.fromISO'\r\n        isopattern = re.compile('\\d{4}-?\\d{2}-?\\d{2}[\\s|T].*')\r\n        if not isopattern.search(iso_string):\r\n            raise ValueError('\\n%s is not a valid ISO string.' % title)\r\n        python_datetime = dTparser.parse(iso_string)\r\n        if not python_datetime.tzinfo:\r\n            raise ValueError('\\n%s must have timezone info.' % title)\r\n\r\n    # construct labDT from parsed string\r\n        dT = python_datetime.astimezone(pytz.utc)\r\n        dt_kwargs = {\r\n            'year': dT.year,\r\n            'month': dT.month,\r\n            'day': dT.day,\r\n            'hour': dT.hour,\r\n            'minute': dT.minute,\r\n            'second': dT.second,\r\n            'microsecond': dT.microsecond,\r\n            'tzinfo': dT.tzinfo\r\n        }\r\n        return labDT(**dt_kwargs)", "response": "a method for constructing a labDT object from a timezone aware ISO string"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fromPython(cls, python_datetime):\r\n\r\n        ''' a method for constructing a labDT from a python datetime with timezone info\r\n        \r\n        :param python_datetime: datetime object with timezone info\r\n        :return: labDT object\r\n        '''\r\n\r\n    # validate inputs\r\n        title = 'Python datetime input for labDT.fromPython'\r\n        if not isinstance(python_datetime, datetime):\r\n            raise TypeError('\\n%s must be a valid %s object.' % (title, datetime.__class__))\r\n        elif not python_datetime.tzinfo:\r\n            raise ValueError('\\n%s must have a timezone.' % title)\r\n\r\n    # construct labDT from python datetime\r\n        dT = python_datetime.astimezone(pytz.utc)\r\n        dt_kwargs = {\r\n            'year': dT.year,\r\n            'month': dT.month,\r\n            'day': dT.day,\r\n            'hour': dT.hour,\r\n            'minute': dT.minute,\r\n            'second': dT.second,\r\n            'microsecond': dT.microsecond,\r\n            'tzinfo': dT.tzinfo\r\n        }\r\n        return labDT(**dt_kwargs)", "response": "a method for constructing a labDT object from a python datetime object with timezone info\r\nAttributeNames returns a new object with the same fields."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fromJavascript(cls, javascript_datetime):\r\n\r\n        ''' a method to construct labDT from a javascript datetime string\r\n        \r\n        :param javascript_datetime: string with datetime info in javascript formatting\r\n        :return: labDT object\r\n        '''\r\n\r\n    # validate inputs\r\n        title = 'Javascript datetime string input for labDT.fromJavascript'\r\n        jsDTpattern = re.compile('\\s*\\(.*\\)$')\r\n        jsGMTpattern = re.compile('GMT[-\\+]\\d{4}')\r\n        if not jsGMTpattern.findall(javascript_datetime):\r\n            raise Exception('\\n%s must have a GMT timezone adjustment.' % title)\r\n\r\n    # construct datetime from javascript string\r\n        adj_input = jsDTpattern.sub('', javascript_datetime)\r\n        if '-' in adj_input:\r\n            adj_input = adj_input.replace('-','+')\r\n        elif '+' in adj_input:\r\n            adj_input = adj_input.replace('+','-')\r\n        python_datetime = dTparser.parse(adj_input)\r\n        dT = python_datetime.astimezone(pytz.utc)\r\n        dt_kwargs = {\r\n            'year': dT.year,\r\n            'month': dT.month,\r\n            'day': dT.day,\r\n            'hour': dT.hour,\r\n            'minute': dT.minute,\r\n            'second': dT.second,\r\n            'microsecond': dT.microsecond,\r\n            'tzinfo': dT.tzinfo\r\n        }\r\n        return labDT(**dt_kwargs)", "response": "a method to construct a new instance of the class from a javascript string"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the names of directories to be created.", "response": "def directories(self):\n        \"\"\" Return the names of directories to be created. \"\"\"\n        directories_description = [\n            self.project_name,\n            self.project_name + '/conf',\n            self.project_name + '/static',\n        ]\n        return directories_description"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the substitutions for the templating replacements.", "response": "def substitutes(self):\n        \"\"\" Return the substitutions for the templating replacements. \"\"\"\n        author_collector = AuthorCollector()\n        mail_collector = AuthorMailCollector()\n        substitute_dict = {\n            'project': self.project_name,\n            'project_lower': self.project_name.lower(),\n            'date': date.today().isoformat(),\n            'author': author_collector.collect(),\n            'author_email': mail_collector.collect(),\n        }\n        return substitute_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a dictionary with request details extracted from the request object.", "response": "def extract_request_details(request_object, session_object=None):\r\n\r\n    '''\r\n        a method for extracting request details from request and session objects\r\n\r\n        NOTE:   method is also a placeholder funnel for future validation\r\n                processes, request logging, request context building and\r\n                counter-measures for the nasty web\r\n\r\n    :param request_object: request object generated by flask from request route\r\n    :param session_object: session object generated by flask from client cookie\r\n    :return: dictionary with request details\r\n    '''\r\n    \r\n    request_details = {\r\n        'error': '',\r\n        'status': 'ok',\r\n        'code': 200,\r\n        'method': request_object.method,\r\n        'session': {},\r\n        'root': request_object.url_root,\r\n        'route': request_object.path,\r\n        'headers': {},\r\n        'form': {},\r\n        'params': {},\r\n        'json': {},\r\n        'data': ''\r\n    }\r\n\r\n# automatically add header and query field data\r\n    request_details['headers'].update(**request_object.headers)\r\n    for key in request_object.args.keys():\r\n        request_details['params'][key] = request_object.args.get(key)\r\n\r\n# retrieve session details\r\n    if session_object:\r\n        request_details['session'].update(**session_object)\r\n\r\n# add data based upon type\r\n    if request_object.is_json:\r\n        try:\r\n            json_details = request_object.get_json(silent=True)\r\n            if isinstance(json_details, dict):\r\n                request_details['json'] = json_details\r\n        except:\r\n                pass\r\n    else:\r\n        try:\r\n            from base64 import b64encode\r\n            request_details['data'] = b64encode(request_object.data).decode()\r\n        except:\r\n            pass\r\n        try:\r\n            for key, value in request_object.form.items():\r\n                request_details['form'][key] = value\r\n        except:\r\n            pass\r\n\r\n# TODO: handle non-json data parsing (such as by mimetype and request.files)\r\n# TODO: check content type against buffer values\r\n# TODO: status code and error handling\r\n\r\n    return request_details"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef extract_session_details(request_headers, session_header, secret_key):\r\n\r\n    '''\r\n        a method to extract and validate jwt session token from request headers\r\n\r\n    :param request_headers: dictionary with header fields from request\r\n    :param session_header: string with name of session token header key\r\n    :param secret_key: string with secret key to json web token encryption\r\n    :return: dictionary with request details with session details or error coding\r\n    '''\r\n\r\n    session_details = {\r\n        'error': '',\r\n        'code': 200,\r\n        'session': {}\r\n    }\r\n\r\n    if not session_header in request_headers.keys():\r\n        session_details['error'] = '%s is missing.' % session_header\r\n        session_details['code'] = 400\r\n    else:\r\n        import jwt\r\n        session_token = request_headers[session_header]\r\n        try:\r\n            session_details['session'] = jwt.decode(session_token, secret_key)\r\n        except jwt.DecodeError as err:\r\n            session_details['error'] = 'Session token decoding error.'\r\n            session_details['code'] = 400\r\n        except jwt.ExpiredSignatureError as err:\r\n            session_details['error'] = 'Session token has expired.'\r\n            session_details['code'] = 400\r\n        except Exception:\r\n            session_details['error'] = 'Session token is invalid.'\r\n            session_details['code'] = 400\r\n\r\n    return session_details", "response": "a method to extract and validate jwt session token from request headers"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_job_resolver(self, job_resolver):\n        for i, r in enumerate(self.job_resolvers()):\n            if job_resolver == r:\n                del self._job_resolvers[i]", "response": "Removes the job resolver from the list of job resolvers."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef resolve_job(self, name):\n        for r in self.job_resolvers():\n            resolved_name = r(name)\n            if resolved_name is not None:\n                return resolved_name\n        return None", "response": "Attempt to resolve the task name in to a job name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite header: [8bit][16bit] [protocol_version][msg_length]", "response": "def writeHeader(self, msg):\n\t\t\"\"\"write header:\n\t\t[8bit][16bit]\n\t\t[protocol_version][msg_length]\n\t\t\"\"\"\n\n\t\theader = bytearray([self.protocol_version]) #protocol version 1.0\n\t\theader.extend(struct.pack('<H', len(msg)))\n\n\t\tmsg = header + msg\n\n\t\treturn msg"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setColor(self, id, color):\n\t\theader = bytearray()\n\t\theader.append(LightProtocolCommand.SetColor)\n\n\t\tif not isinstance(id, list):\n\t\t\tid = [id]\n\n\t\tif not isinstance(color, list):\n\t\t\tcolor = [color]\n\n\t\theader.extend(struct.pack('<H', len(id)))\n\n\t\ti = 0\n\t\tlight = bytearray()\n\t\t\n\t\tfor curr_id in id:\n\t\t\tlight.extend(struct.pack('<H', curr_id))\n\t\t\tlight.extend(color[i])\n\t\t\ti += 1\n\t\t\n\t\tbuff = header + light\n\n\t\treturn self.send(buff)", "response": "set the color of a specific light"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setSeries(self, startId, length, color):\n\n\t\tbuff = bytearray()\n\t\tbuff.append(LightProtocolCommand.SetSeries)\n\t\tbuff.extend(struct.pack('<H', startId))\n\t\tbuff.extend(struct.pack('<H', length))\n\t\tbuff.extend(color)\n\n\t\treturn self.send(buff)", "response": "setSeries - Sets the color of all lights in the series starting from startId to length and color of all lights in the series starting from endId to color"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting all colors in the array", "response": "def setAllColor(self, color):\n\t\t\"\"\"\n\t\tCommand: 0x06\n\t\tsets all colors in the array\n\n\t\tData:\n\t\t[Command][r][g][b]\n\n\t\t\"\"\"\n\n\t\theader = bytearray()\n\t\theader.append(LightProtocolCommand.SetAllColor)\n\n\t\tlight = bytearray()\n\t\tlight.extend(color)\n\n\t\tbuff = header + light\n\t\treturn self.send(buff)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clear(self):\n\n\t\theader = bytearray()\n\t\theader.append(LightProtocolCommand.Clear)\n\n\t\treturn self.send(header)", "response": "send Clear command to device"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstoring a single feature collection.", "response": "def v1_fc_put(request, response, store, kvlclient, tfidf, cid):\n    '''Store a single feature collection.\n\n    The route for this endpoint is:\n    ``PUT /dossier/v1/feature-collections/<content_id>``.\n\n    ``content_id`` is the id to associate with the given feature\n    collection. The feature collection should be in the request\n    body serialized as JSON.\n\n    Alternatively, if the request's ``Content-type`` is\n    ``text/html``, then a feature collection is generated from the\n    HTML. The generated feature collection is then returned as a\n    JSON payload.\n\n    This endpoint returns status ``201`` upon successful\n    storage otherwise. An existing feature collection with id\n    ``content_id`` is overwritten.\n    '''\n    tfidf = tfidf or None\n    if request.headers.get('content-type', '').startswith('text/html'):\n        url = urllib.unquote(cid.split('|', 1)[1])\n        fc = etl.create_fc_from_html(url, request.body.read(), tfidf=tfidf)\n        logger.info('created FC for %r', cid)\n        store.put([(cid, fc)])\n        return fc_to_json(fc)\n    else:\n        fc = FeatureCollection.from_dict(json.load(request.body))\n        keywords = set()\n        for subid in fc:\n            if subid.startswith('subtopic'):\n                ty = subtopic_type(subid)\n                if ty in ('text', 'manual'):\n                    # get the user selected string\n                    data = typed_subtopic_data(fc, subid)\n                    map(keywords.add, cleanse(data).split())\n                    keywords.add(cleanse(data))\n\n        folders = Folders(kvlclient)\n        for fid, sid in folders.parent_subfolders(cid):\n            if not isinstance(fid, unicode):\n                fid = fid.decode('utf8')\n            if not isinstance(sid, unicode):\n                sid = sid.decode('utf8')\n            keywords.add(cleanse(fid))\n            keywords.add(cleanse(sid))\n\n        fc[u'keywords'] = StringCounter(keywords)\n        store.put([(cid, fc)])\n        response.status = 201"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngathering suggestions from various engines and within this dossier stack instance and filter them before sending to requestor.", "response": "def v1_suggest_get(request, response, tfidf, query):\n    '''Gather suggestions from various engines and within this dossier\n    stack instance and filter/rank them before sending to requestor.\n\n    '''\n    config = yakonfig.get_global_config('dossier.models')\n    suggest_services = config.get('suggest_services', [])\n    session = requests.Session()\n    suggestions = []\n    logger.info('querying %d suggest_services', len(suggest_services))\n    for url in suggest_services:\n        try:\n            url = url % dict(query=query)\n        except Exception, exc:\n            logger.error('failed to insert query=%r into pattern: %r', query, url)\n            continue\n        try:\n            resp = session.get(url)\n        except Exception, exc:\n            logger.error('failed to retrieve %r', url)\n            continue\n        try:\n            results = resp.json()\n        except Exception, exc:\n            logger.error('failed to get JSON from: %r', \n                         resp.content, exc_info=True)\n            continue\n        if not isinstance(results, list) or len(results) < 2:\n            logger.error('got other than list of length at least two from service: %r --> %r',\n                         url, results)\n            continue\n        query_ack = results[0]\n        query_suggestions = results[1]\n        if not isinstance(query_suggestions, list):\n            logger.error('got other than list of query suggestions: %r --> %r',\n                         url, results)\n            continue\n        suggestions += query_suggestions\n        logger.info('%d suggestions from %r', len(query_suggestions), url)\n\n    logger.info('found %d suggestions for %r', len(suggestions), query)\n    return [query, suggestions]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef v0_highlighter_post(request, response, tfidf, cid):\n    '''Obtain highlights for a document POSTed as the body, which is the\n    pre-design-thinking structure of the highlights API.  See v1 below.\n\n    NB: This end point will soon be deleted.\n\n    The route for this endpoint is:\n    ``POST /dossier/v0/highlighter/<cid>``.\n\n    ``content_id`` is the id to associate with the given feature\n    collection. The feature collection should be in the request\n    body serialized as JSON.\n\n    '''\n    logger.info('got %r', cid)\n    tfidf = tfidf or None\n    content_type = request.headers.get('content-type', '')\n    if not content_type.startswith('text/html'):\n        logger.critical('content-type=%r', content_type)\n        response.status = 415\n        return {'error': {'code': 0, 'message': 'content_type=%r and should be text/html' % content_type}}\n\n    url = urllib.unquote(cid.split('|', 1)[1])\n    body = request.body.read()\n    if len(body) == 0:\n        response.status = 420\n        return {'error': {'code': 1, 'message': 'empty body'}}\n    logger.info('parsing %d bytes for url: %r', len(body), url)\n    fc = etl.create_fc_from_html(url, body, tfidf=tfidf)\n    if fc is None:\n        logger.critical('failed to get FC using %d bytes from %r', len(body), url)\n        response.status = 506\n        return {'error': {'code': 2, 'message': 'FC not generated for that content'}}\n    highlights = dict()\n    for feature_name, pretty_name in feature_pretty_names:\n        # Each type of string is\n        if feature_name not in fc: continue\n        total = sum(fc[feature_name].values())\n        highlights[pretty_name] = [\n            (phrase, count / total, [], [])\n            for phrase, count in sorted(fc[feature_name].items(), key=itemgetter(1), reverse=True)]\n        logger.info('%r and %d keys', feature_name, len(highlights[pretty_name]))\n    return {'highlights': highlights}", "response": "Obtain highlights for a document POSTed as the body of the request."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nobtains highlights for a document POSTed previously to this end point.", "response": "def v1_highlights_get(response, kvlclient, file_id_str, max_elapsed = 300):\n    '''Obtain highlights for a document POSTed previously to this end\n    point.  See documentation for v1_highlights_post for further\n    details.  If the `state` is still `pending` for more than\n    `max_elapsed` after the start of the `WorkUnit`, then this reports\n    an error, although the `WorkUnit` may continue in the background.\n\n    '''\n    file_id = make_file_id(file_id_str)\n    kvlclient.setup_namespace(highlights_kvlayer_tables)\n    payload_strs = list(kvlclient.get('highlights', file_id))\n    if not (payload_strs and payload_strs[0][1]):\n        response.status = 500\n        payload = {\n            'state': ERROR,\n            'error': {\n                'code': 8,\n                'message': 'unknown error'}}\n        logger.critical('got bogus info for %r: %r', file_id, payload_strs)\n    else:\n        payload_str = payload_strs[0][1]\n        try:\n            payload = json.loads(payload_str)\n            if payload['state'] == HIGHLIGHTS_PENDING:\n                elapsed = time.time() - payload.get('start', 0)\n                if elapsed > max_elapsed:\n                    response.status = 500\n                    payload = {\n                        'state': ERROR,\n                        'error': {\n                            'code': 8,\n                            'message': 'hit timeout'}}\n                    logger.critical('hit timeout on %r', file_id)\n                    kvlclient.put('highlights', (file_id, json.dumps(payload)))\n                else:\n                    payload['elapsed'] = elapsed\n            logger.info('returning stored payload for %r', file_id)\n        except Exception, exc:\n            logger.critical('failed to decode out of %r', \n                            payload_str, exc_info=True)\n            response.status = 400\n            payload = {\n                'state': ERROR,\n                'error': {\n                    'code': 9,\n                    'message': 'nothing known about file_id=%r' % file_id}\n                }\n    # only place where payload is returned\n    return payload"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef v1_highlights_post(request, response, kvlclient, tfidf, \n                       min_delay=3, task_master=None):\n    '''Obtain highlights for a document POSTed inside a JSON object.\n\n    Get our Diffeo Highlighter browser extension here:\n    https://chrome.google.com/webstore/detail/jgfcplgdmjkdepnmbdkmgohaldaiplpo\n\n    While you're at it, pre-register for a beta account on\n    http://diffeo.com.\n\n    `min_delay` and `task_master` are used by tests.\n\n    The route for this endpoint is:\n    ``POST /dossier/v1/highlights``.\n\n    The expected input structure is a JSON encoded string of an\n    object with these keys:\n\n    .. code-block:: javascript\n      {\n        // only text/html is supported at this time; hopefully PDF.js\n        // enables this to support PDF rendering too.\n        \"content-type\": \"text/html\",\n\n        // URL of the page (after resolving all redirects)\n        \"content-location\": \"http://...\",\n\n        // If provided by the original host, this will be populated,\n        // otherwise it is empty.\n        \"last-modified\": \"datetime string or empty string\",\n\n        // Boolean indicating whether the content may be stored by the\n        // server.  If set to `false`, then server must respond\n        // synchronously with a newly computed response payload, and\n        // must purge any stored copies of this `content-location`.\n        // If `true`, server may respond with `state` of `pending`.\n        \"store\": false,\n\n        // full page contents obtained by Javascript in the browser\n        // extension accessing `document.documentElement.innerHTML`.\n        // This must be UTF-8 encoded.\n        // N.B. This needs experimentation to figure out whether the\n        // browser will always encode this as Unicode.\n        \"body\": \"... the body content ...\",\n      }\n\n    The output structure is a JSON UTF-8 encoded string of an\n    object with these keys:\n\n    .. code-block:: javascript\n\n      {\n        \"highlights\": [Highlight, Highlight, ...],\n        \"state\":  State,\n        \"id\": StoreID,\n        \"delay\": 10.0,\n        \"error\": Error\n      }\n\n    where a `State` is one of these strings: `completed`, `stored`,\n    `pending`, or `error`.  The `StoreID` is an opaque string computed\n    by the backend that the client can use to poll this end point with\n    `GET` requests for a `pending` request.  The `delay` value is a\n    number of seconds that the client should wait before beginning\n    polling, e.g. ten seconds.\n\n    An `Error` object has this structure:\n\n    .. code-block:: javascript\n      {\n\n        // Error codes are (0, wrong content type), (1, empty body),\n        // (2, JSON decode error), (3, payload structure incorrect),\n        // (4, payload missing required keys), (5, invalid\n        // content-location), (6, too small body content), (7,\n        // internal error), (8, internal time out), (9, file_id does\n        // not exist)\n        \"code\": 0,\n\n        \"message\": \"wrong content_type\"\n      }\n\n    A `Highlight` object has this structure:\n\n    .. code-block:: javascript\n\n      {\n        // float in the range [0, 1]\n        \"score\": 0.7\n\n        // a string presented with a check box inside the options\n        // bubble when the user clicks the extension icon to choose\n        // which categories of highlights should be displayed.\n        \"category\": \"Organization\",\n\n        // `queries` are strings that are to be presented as\n        // suggestions to the user, and the extension enables the user\n        // to click any of the configured search engines to see\n        // results for a selected query string.\n        \"queries\": [],\n\n        // zero or more strings to match in the document and highlight\n        // with a single color.\n        \"strings\": [],\n\n        // zero or more xpath highlight objects to lookup in the document\n        // and highlight with a single color.\n        \"xranges\": [],\n\n        // zero or more Regex objects to compile and\n        // execute to find spans to highlight with a single color.\n        \"regexes\": []\n      }\n\n    where a Regex object is:\n\n    .. code-block:: javascript\n\n      {\n        \"regex\": \"...\", // e.g., \"[0-9]\"\n        \"flags\": \"...\"  // e.g., \"i\" for case insensitive\n      }\n\n    where an xpath highlight object is:\n\n    .. code-block:: javascript\n\n      {\n        \"range\": XPathRange\n      }\n\n    where an XpathRange object is:\n\n    .. code-block:: javascript\n\n      {\n        \"start\": XPathOffset,\n        \"end\": XPathOffset\n      }\n\n    where an XpathOffset object is:\n\n    .. code-block:: javascript\n\n      {\n        \"node\": \"/html[1]/body[1]/p[1]/text()[2]\",\n        \"idx\": 4,\n      }\n\n    All of the `strings`, `ranges`, and `regexes` in a `Highlight`\n    object should be given the same highlight color.  A `Highlight`\n    object can provide values in any of the three `strings`, `ranges`,\n    or `regexes` lists, and all should be highlighted.\n    '''\n    tfidf = tfidf or None\n    content_type = request.headers.get('content-type', '')\n    if not content_type.startswith('application/json'):\n        logger.critical('content-type=%r', content_type)\n        response.status = 415\n        return {\n\t    'state': ERROR,\n            'error': {\n                'code': 0,\n                'message': 'content_type=%r and should be '\n                           'application/json' % content_type,\n            },\n        }\n\n    body = request.body.read()\n    if len(body) == 0:\n        response.status = 400\n        return {\n            'state': ERROR,\n            'error': {'code': 1, 'message': 'empty body'}\n        }\n    try:\n        data = json.loads(body.decode('utf-8'))\n    except Exception, exc:\n        response.status = 400\n        return {\n\t    'state': ERROR,\n            'error': {\n                'code': 2,\n                'message':\n                'failed to read JSON body: %s' % exc,\n            },\n        }\n\n    if not isinstance(data, dict):\n        response.status = 400\n        return {\n\t    'state': ERROR,\n            'error': {\n                'code': 3,\n                'message': 'JSON request payload deserialized to'\n                      ' other than an object: %r' % type(data),\n            },\n        }\n\n    expected_keys = set([\n        'content-type', 'content-location', 'last-modified', 'body',\n\t'store',\n    ])\n    if set(data.keys()) != expected_keys:\n        response.status = 400\n        return {\n\t    'state': ERROR,\n            'error': {\n                'code': 4,\n                'message': 'other than expected keys in JSON object. '\n                           'Expected %r and received %r'\n                           % (sorted(expected_keys), sorted(data.keys())),\n            },\n        }\n\n    if len(data['content-location']) < 3:\n        response.status = 400\n        return {\n\t    'state': ERROR,\n            'error': {\n                'code': 5,\n                'message': 'received invalid content-location=%r'\n                           % data['content-location'],\n            },\n        }\n\n    if len(data['body']) < 3:\n        response.status = 400\n        return {\n\t    'state': ERROR,\n            'error': {\n                'code': 6,\n                'message': 'received too little body=%r' % data['body'],\n            },\n        }\n\n    if data['last-modified']:\n        try:\n            last_modified = int(datetime.datetime(*eut.parsedate(data['last-modified'])[:6]).strftime('%s'))\n        except Exception, exc:\n            logger.info('failed to parse last-modified=%r', data['last-modified'])\n            last_modified = 0\n    else:\n        last_modified = 0\n    doc_id = md5(data['content-location']).hexdigest()\n    content_hash = Nilsimsa(data['body']).hexdigest()\n    file_id = (doc_id, last_modified, content_hash)\n    file_id_str = '%s-%d-%s' % file_id\n\n    kvlclient.setup_namespace(highlights_kvlayer_tables)\n    if data['store'] is False:\n        kvlclient.delete('files', (file_id[0],))\n        kvlclient.delete('highlights', (file_id[0],))\n        logger.info('cleared all store records related to doc_id=%r', file_id[0])\n    else: # storing is allowed\n        payload_strs = list(kvlclient.get('highlights', file_id))\n        if payload_strs and payload_strs[0][1]:\n            payload_str = payload_strs[0][1]\n            try:\n                payload = json.loads(payload_str)\n            except Exception, exc:\n                logger.critical('failed to decode out of %r', \n                                payload_str, exc_info=True)\n            if payload['state'] != ERROR:\n                logger.info('returning stored payload for %r', file_id)\n                return payload\n            else:\n                logger.info('previously stored data was an error so trying again')\n\n        delay = len(data['body']) / 5000 # one second per 5KB\n        if delay > min_delay:\n            # store the data in `files` table\n            kvlclient.put('files', (file_id, json.dumps(data)))\n            payload = {\n                'state': HIGHLIGHTS_PENDING,\n                'id': file_id_str,\n                'delay': delay,\n                'start': time.time()\n            }\n            # store the payload, so that it gets returned during\n            # polling until replaced by the work unit.\n            payload_str = json.dumps(payload)\n            kvlclient.put('highlights', (file_id, payload_str))\n\n            logger.info('launching highlights async work unit')\n            if task_master is None:\n                conf = yakonfig.get_global_config('coordinate')\n                task_master = coordinate.TaskMaster(conf)\n            task_master.add_work_units('highlights', [(file_id_str, {})])\n\n            return payload\n\n    return maybe_store_highlights(file_id, data, tfidf, kvlclient)", "response": "Obtain highlights for a document POSTed inside a JSON object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef highlights_worker(work_unit):\n    '''coordinate worker wrapper around :func:`maybe_create_highlights`\n    '''\n    if 'config' not in work_unit.spec:\n        raise coordinate.exceptions.ProgrammerError(\n            'could not run `create_highlights` without global config')\n\n    web_conf = Config()\n    unitconf = work_unit.spec['config']\n    with yakonfig.defaulted_config([coordinate, kvlayer, dblogger, web_conf],\n                                   config=unitconf):\n        file_id = make_file_id(work_unit.key)\n        web_conf.kvlclient.setup_namespace(highlights_kvlayer_tables)\n        payload_strs = list(web_conf.kvlclient.get('files', file_id))\n        if payload_strs and payload_strs[0][1]:\n            payload_str = payload_strs[0][1]\n            try:\n                data = json.loads(payload_str)\n                # now create the response payload\n                maybe_store_highlights(file_id, data, web_conf.tfidf, web_conf.kvlclient)\n            except Exception, exc:\n                logger.critical('failed to decode data out of %r', \n                                payload_str, exc_info=True)\n                payload = {\n                    'state': ERROR,\n                    'error': {\n                        'code': 7,\n                        'message': 'failed to generate stored results:\\n%s' % \\\n                        traceback.format_exc(exc)}\n                    }\n                payload_str = json.dumps(payload)\n                kvlclient.put('highlights', (file_id, payload_str))", "response": "coordinate worker wrapper around :func:`maybe_create_highlights`"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwrapping around create_highlights that stores the response payload as a stored value.", "response": "def maybe_store_highlights(file_id, data, tfidf, kvlclient):\n    '''wrapper around :func:`create_highlights` that stores the response\n    payload in the `kvlayer` table called `highlights` as a stored\n    value if data['store'] is `False`.  This allows error values as\n    well as successful responses from :func:`create_highlights` to\n    both get stored.\n\n    '''\n    payload = create_highlights(data, tfidf)\n    if data['store'] is True:\n        stored_payload = {}\n        stored_payload.update(payload)\n        stored_payload['state'] = STORED\n        payload_str = json.dumps(stored_payload)\n        kvlclient.put('highlights', (file_id, payload_str))\n    return payload"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_highlights(data, tfidf):\n    '''compute highlights for `data`, store it in the store using\n    `kvlclient`, and return a `highlights` response payload.\n\n    '''\n    try:\n        fc = etl.create_fc_from_html(\n            data['content-location'], data['body'], tfidf=tfidf, encoding=None)\n    except Exception, exc:\n        logger.critical('failed to build FC', exc_info=True)\n        return {\n            'state': ERROR,\n            'error': {'code': 7,\n                      'message': 'internal error: %s' % traceback.format_exc(exc),\n                      }\n        }\n    if fc is None:\n        logger.critical('failed to get FC using %d bytes from %r',\n                        len(body), data['content-location'])\n        response.status = 500\n        return {\n            'state': ERROR,\n            'error': {\n                'code': 7,\n                'message': 'internal error: FC not generated for that content',\n            },\n        }\n    try:\n        highlights = dict()\n        for feature_name, pretty_name in feature_pretty_names:\n            # Each type of string is\n            if feature_name not in fc:\n                continue\n            total = sum(fc[feature_name].values())\n            bow = sorted(fc[feature_name].items(), key=itemgetter(1), reverse=True)\n            highlights[pretty_name] = [(phrase, count / total)\n                                       for phrase, count in bow]\n            logger.info('%r and %d keys',\n                        feature_name, len(highlights[pretty_name]))\n\n        highlight_objs = build_highlight_objects(data['body'], highlights)\n    except Exception, exc:\n        logger.critical('failed to build highlights', exc_info=True)\n        return {\n            'state': ERROR,\n            'error': {'code': 7,\n                      'message': 'internal error: %s' % traceback.format_exc(exc),\n                      }\n        }\n\n    payload = {\n        'highlights': highlight_objs,\n        'state': COMPLETED,\n    }\n    return payload", "response": "compute highlights for data store it in the store using\n    kvlclient and return a highlights response payload."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef build_highlight_objects(html, highlights, uniformize_html=True):\n    '''converts a dict of pretty_name --> [tuple(string, score), ...] to\n    `Highlight` objects as specified above.\n\n    '''\n    if uniformize_html:\n        try:\n            html = uniform_html(html.encode('utf-8')).decode('utf-8')\n        except Exception, exc:\n            logger.info('failed to get uniform_html(%d bytes) --> %s',\n                        len(html), exc, exc_info=True)\n            html = None\n\n    highlight_objects = []\n    for category, phrase_scores in highlights.iteritems():\n        for (phrase, score) in phrase_scores:\n            hl = dict(\n                score=score,\n                category=category,\n                )\n            ranges = make_xpath_ranges(html, phrase)\n            if ranges:\n                hl['xranges'] = [{'range': r} for r in ranges]\n            elif phrase in html:\n                hl['strings'] = [phrase]\n            else:\n                hl['regexes'] = [{\n                    'regex': phrase,\n                    'flags': 'i',\n                }]\n            highlight_objects.append(hl)\n    return highlight_objects", "response": "converts a dict of pretty_name --> [ string score... ] to\n    highlights as specified above."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a HTML string and a phrase build a regex to find offsets for the phrase and then return a list of XPathRange objects for that phrase.", "response": "def make_xpath_ranges(html, phrase):\n    '''Given a HTML string and a `phrase`, build a regex to find offsets\n    for the phrase, and then build a list of `XPathRange` objects for\n    it.  If this fails, return empty list.\n\n    '''\n    if not html:\n        return []\n    if not isinstance(phrase, unicode):\n        try:\n            phrase = phrase.decode('utf8')\n        except:\n            logger.info('failed %r.decode(\"utf8\")', exc_info=True)\n            return []\n\n    phrase_re = re.compile(\n        phrase, flags=re.UNICODE | re.IGNORECASE | re.MULTILINE)\n    spans = []\n    for match in phrase_re.finditer(html, overlapped=False):\n        spans.append(match.span())  # a list of tuple(start, end) char indexes\n\n    # now run fancy aligner magic to get xpath info and format them as\n    # XPathRange per above\n    try:\n        xpath_ranges = list(char_offsets_to_xpaths(html, spans))\n    except:\n        logger.info('failed to get xpaths', exc_info=True)\n        return []\n    ranges = []\n    for xpath_range in filter(None, xpath_ranges):\n        ranges.append(dict(\n            start=dict(node=xpath_range.start_xpath,\n                       idx=xpath_range.start_offset),\n            end=dict(node=xpath_range.end_xpath,\n                     idx=xpath_range.end_offset)))\n\n    return ranges"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsave the image to the output_path.", "response": "def save(self):\n        \"\"\"\n        Apply a series of actions from a set of (action, arg) tuples, probably\n        as parsed from a URL. Each action is a code into PROCESSORS.\n\n        Then save the mogrified image.\n        \"\"\"\n        from settings import PROCESSORS\n        from .filesystem import makedirs\n\n        if self.im is None:\n            # If we got here something very strange is going on that I can't even\n            # predict.\n            return  # pragma: no cover\n        makedirs(self.output_path)\n        for action, arg in self.actions:\n            action = PROCESSORS[action]\n            if self.frames:\n                new_frames = []\n                for frame in self.frames:\n                    new_frames.append(action.process(frame, arg))\n                self.frames = new_frames\n            else:\n                self.im = action.process(self.im, arg)\n\n        self.im = optimize.optimize(self.im, fmt=self.format, quality=self.quality)\n\n        kwargs = {\n            'format': self.format,\n            'optimize': True,\n            'quality': self.quality,\n        }\n        if self.format == 'jpeg':\n            kwargs['progressive'] = True\n\n        if self.filename.startswith('s3://'):\n            import cStringIO\n            from filesystem import s3\n            output = cStringIO.StringIO()\n            if self.frames:\n                images2gif.write_gif(output, self.frames)\n            else:\n                self.im.save(output, **kwargs)\n            output.reset()\n            s3.put_file(output, self.filename)\n        else:\n            if self.frames:\n                images2gif.write_gif(self.filename, self.frames)\n            else:\n                self.im.save(self.filename, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef eval_poly(uvec, nvec, Jvec):\n    '''Evaluate multi-dimensional polynomials through tensor multiplication.\n\n    :param list uvec: vector value of the uncertain parameters at which to evaluate the\n        polynomial\n\n    :param list nvec: order in each dimension at which to evaluate the polynomial\n\n    :param list Jvec: Jacobi matrix of each dimension's 1D polynomial\n\n    :return: poly_value - value of the polynomial evaluated at uvec\n\n    :rtype: float\n\n    '''\n    us = _makeIter(uvec)\n    ns = _makeIter(nvec)\n    Js = _makeIter(Jvec)\n    return np.prod([_eval_poly_1D(u, n, J) for u, n, J in zip(us, ns, Js)])", "response": "Evaluate multi - dimensional polynomials through tensor multiplication."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef surrogate(self, u_sparse, q_sparse):\n        '''Combines the train and predict methods to create a surrogate\n        model function fitted to the input/output combinations given in\n        u_sparse and q_sparse.\n\n        :param numpy.ndarray u_sparse: input values at which the output\n            values are obtained.  Must be the same as the qaudrature\n            points defined by the getQuadraturePoints method.\n        :param numpy.ndarray q_sparse: output values corresponding\n            to the input values given in u_sparse to which the\n            surrogate is fitted\n\n        :return: surrogate model fitted to u_sparse and q_sparse\n\n        :rtype: function\n\n        *Sample Usage*::\n\n            >>> thePC = PolySurrogate(dimensions=2)\n            >>> U = thePC.getQuadraturePoints()\n            >>> Q = [myFunc(u) for u in U]\n            >>> surrogateFunc = thePC.surrogate(U, Q)\n\n        '''\n        self.train(q_sparse)\n        def model(u):\n            return self.predict(u)\n        return model", "response": "Combines the train and predict methods to create a surrogate\n            model function fitted to the input values given in u_sparse and q_sparse."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npredicts the output value at u from the fitted polynomial expansion. This method train is called first.", "response": "def predict(self, u):\n        '''Predicts the output value at u from the fitted polynomial expansion.\n        Therefore the method train() must be called first.\n\n        :param numpy.ndarray u: input value at which to predict the output.\n\n        :return: q_approx - the predicted value of the output at u\n\n        :rtype: float\n\n        *Sample Usage*::\n\n            >>> thePC = PolySurrogate(dimensions=2)\n            >>> U = thePC.getQuadraturePoints()\n            >>> Q = [myFunc(u) for u in U]\n            >>> thePC.train(U, Q)\n            >>> thePC.predict([0, 1])\n\n        '''\n        y, ysub = 0, np.zeros(self.N_poly)\n        for ip in range(self.N_poly):\n            inds = tuple(self.index_polys[ip])\n            ysub[ip] = self.coeffs[inds]*eval_poly(u, inds, self.J_list)\n            y += ysub[ip]\n\n        self.response_components = ysub\n        return y"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntraining the polynomial expansion.", "response": "def train(self, ftrain):\n        '''Trains the polynomial expansion.\n\n        :param numpy.ndarray/function ftrain: output values corresponding to the\n            quadrature points given by the getQuadraturePoints method to\n            which the expansion should be trained. Or a function that should be evaluated\n            at the quadrature points to give these output values.\n\n        *Sample Usage*::\n\n            >>> thePC = PolySurrogate(dimensions=2)\n            >>> thePC.train(myFunc)\n            >>> predicted_q = thePC.predict([0, 1])\n\n            >>> thePC = PolySurrogate(dimensions=2)\n            >>> U = thePC.getQuadraturePoints()\n            >>> Q = [myFunc(u) for u in U]\n            >>> thePC.train(Q)\n            >>> predicted_q = thePC.predict([0, 1])\n\n        '''\n        self.coeffs = 0*self.coeffs\n\n        upoints, wpoints = self.getQuadraturePointsAndWeights()\n\n        try:\n            fpoints = [ftrain(u) for u in upoints]\n        except TypeError:\n            fpoints = ftrain\n\n        for ipoly in np.arange(self.N_poly):\n\n            inds = tuple(self.index_polys[ipoly])\n            coeff = 0.0\n            for (u, q, w) in zip(upoints, fpoints, wpoints):\n                coeff += eval_poly(u, inds, self.J_list)*q*np.prod(w)\n\n            self.coeffs[inds] = coeff\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getQuadraturePointsAndWeights(self):\n        '''Gets the quadrature points and weights for gaussian quadrature\n        integration of inner products from the definition of the polynomials in\n        each dimension.\n\n\n        :return: (u_points, w_points) - np.ndarray of shape\n            (num_polynomials, num_dimensions) and a np.ndarray of size\n            (num_polynomials)\n\n        :rtype: (np.ndarray, np.ndarray)\n        '''\n\n        qw_list, qp_list = [], []\n        for ii in np.arange(len(self.J_list)):\n\n            d, Q = np.linalg.eig(self.J_list[ii])\n            qp, qpi = d[np.argsort(d)].reshape([d.size, 1]), np.argsort(d)\n            qw = (Q[0, qpi]**2).reshape([d.size, 1])\n\n            qw_list.append(qw)\n            qp_list.append(qp)\n\n        umesh = np.meshgrid(*qp_list)\n        upoints = np.vstack([m.flatten() for m in umesh]).T\n\n        wmesh = np.meshgrid(*qw_list)\n        wpoints = np.vstack([m.flatten() for m in wmesh]).T\n\n        return upoints, wpoints", "response": "Gets the quadrature points and weights for gaussian quadrature in\n            integration of inner products from the definition of the polynomials in\n            each dimension."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting columns info for the model.", "response": "def _model_columns(ins):\n    \"\"\" Get columns info\n\n    :type ins: sqlalchemy.orm.mapper.Mapper\n    :rtype: list[SaColumnDoc]\n    \"\"\"\n    columns = []\n    for c in ins.column_attrs:\n        # Skip protected\n        if c.key.startswith('_'):\n            continue\n\n        # Collect\n        columns.append(SaColumnDoc(\n            key=c.key,\n            doc=c.doc or '',\n            type=str(c.columns[0].type),  # FIXME: support multi-column properties\n            null=c.columns[0].nullable,\n        ))\n    return columns"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _model_foreign(ins):\n    fks = []\n    for t in ins.tables:\n        fks.extend([\n            SaForeignkeyDoc(\n                key=fk.column.key,\n                target=fk.target_fullname,\n                onupdate=fk.onupdate,\n                ondelete=fk.ondelete\n            )\n            for fk in t.foreign_keys])\n    return fks", "response": "Get foreign keys info from tables."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting unique constraints info for the given model", "response": "def _model_unique(ins):\n    \"\"\" Get unique constraints info\n\n    :type ins: sqlalchemy.orm.mapper.Mapper\n    :rtype: list[tuple[str]]\n    \"\"\"\n    unique = []\n    for t in ins.tables:\n        for c in t.constraints:\n            if isinstance(c, UniqueConstraint):\n                unique.append(tuple(col.key for col in c.columns))\n    return unique"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting relationships info for the current language.", "response": "def _model_relations(ins):\n    \"\"\" Get relationships info\n\n    :type ins: sqlalchemy.orm.mapper.Mapper\n    :rtype: list[SaRelationshipDoc]\n    \"\"\"\n    relations = []\n    for r in ins.relationships:\n        # Hard times with the foreign model :)\n        if isinstance(r.argument, Mapper):\n            model_name = r.argument.class_.__name__\n        elif hasattr(r.argument, 'arg'):\n            model_name = r.argument.arg\n        else:\n            model_name = r.argument.__name__\n\n        # Format\n        relations.append(SaRelationshipDoc(\n            key=r.key,\n            doc=r.doc or '',\n            model=model_name,\n            pairs=map(lambda a_b_tuple: a_b_tuple[0].key if a_b_tuple[0].key == a_b_tuple[1].key else '{}={}'.format(a_b_tuple[0].key, a_b_tuple[1].key), r.local_remote_pairs),\n            uselist=r.uselist\n        ))\n    return relations"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef doc(model):\n    ins = inspect(model)\n\n    return SaModelDoc(\n        name=model.__name__,\n        table=[t.name for t in ins.tables],\n        doc=getdoc(ins.class_),\n        columns=_model_columns(ins),\n        primary=_model_primary(ins),\n        foreign=_model_foreign(ins),\n        unique=_model_unique(ins),\n        relations=_model_relations(ins)\n    )", "response": "Get documentation object for an SqlAlchemy model"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write(self, oprot):\n        '''\n        Write this object to the given output protocol and return self.\n\n        :type oprot: thryft.protocol._output_protocol._OutputProtocol\n        :rtype: pastpy.gen.database.impl.dbf.dbf_database_configuration.DbfDatabaseConfiguration\n        '''\n\n        oprot.write_struct_begin('DbfDatabaseConfiguration')\n\n        if self.pp_images_dir_path is not None:\n            oprot.write_field_begin(name='pp_images_dir_path', type=11, id=None)\n            oprot.write_string(self.pp_images_dir_path)\n            oprot.write_field_end()\n\n        if self.pp_install_dir_path is not None:\n            oprot.write_field_begin(name='pp_install_dir_path', type=11, id=None)\n            oprot.write_string(self.pp_install_dir_path)\n            oprot.write_field_end()\n\n        if self.pp_objects_dbf_file_path is not None:\n            oprot.write_field_begin(name='pp_objects_dbf_file_path', type=11, id=None)\n            oprot.write_string(self.pp_objects_dbf_file_path)\n            oprot.write_field_end()\n\n        oprot.write_field_stop()\n\n        oprot.write_struct_end()\n\n        return self", "response": "Writes the object to the given output protocol and returns the original object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the base name of the module from the wsdl.", "response": "def GetModuleBaseNameFromWSDL(wsdl):\n    \"\"\"By default try to construct a reasonable base name for all\n    generated modules.  Otherwise return None.\n    \"\"\"\n    base_name = wsdl.name or wsdl.services[0].name\n    base_name = SplitQName(base_name)[1]\n    if base_name is None: \n        return None\n    return NCName_to_ModuleName(base_name)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef condense(ss_unescaped):\n    def estimated_len(longg, short):\n        return (3\n                + len(short)\n                + sum(map(len, longg))\n                - len(longg)\n                * (len(short) - 1)\n                - 1 )\n\n    def stupid_len(longg):\n        return sum(map(len, longg)) + len(longg)\n\n    ss = [re.escape(s) for s in set(ss_unescaped)]\n    ss.sort(key=len)\n\n    short2long = defaultdict(lambda: {'p':[],'s':[]})\n\n    for short, longg in combinations(ss, 2):\n        if longg.startswith(short):\n            short2long[short]['p'].append(longg)\n        if longg.endswith(short):\n            short2long[short]['s'].append(longg)\n\n    short2long = sorted(list(short2long.items()),\n                        key=lambda x: len(x[0]),\n                        reverse=True)\n\n    output = []\n    objs = set(ss)\n\n    for s, pre_sur in short2long:\n        pp = set(pre_sur['p']) & objs\n        ss = set(pre_sur['s']) & objs\n        if ((stupid_len(pp) - estimated_len(pp, s))\n            < (stupid_len(ss) - estimated_len(ss, s))):\n            reg = (r'({heads})?{surfix}'\n                    .format(surfix=s,\n                           heads='|'.join(sorted([p[:-len(s)] for p in ss],\n                           key=len,\n                           reverse=True))))\n            assert len(reg) == estimated_len(ss, s)\n            output.append(reg)\n            objs -= (ss | set([s]))\n        elif ((stupid_len(pp) - estimated_len(pp, s))\n            > (stupid_len(ss) - estimated_len(ss, s))):\n            reg = (r'{prefix}({tails})?'\n                .format(prefix=s,\n                        tails='|'.join(sorted([p[len(s):] for p in pp],\n                        key=len,\n                        reverse=True))))\n            assert len(reg) == estimated_len(pp, s)\n            output.append(reg)\n            objs -= (pp | set([s]))\n\n    for residual in objs:\n        output.append(residual)\n    return re.sub(r'\\(([^)])\\)\\?', r'\\1?', r'|'.join(output))", "response": "Given multiple strings returns a compressed regular expression just\n    for these strings"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if a regular expression is solid.", "response": "def is_solid(regex):\n    \"\"\"\n    Check the given regular expression is solid.\n\n    >>> is_solid(r'a')\n    True\n    >>> is_solid(r'[ab]')\n    True\n    >>> is_solid(r'(a|b|c)')\n    True\n    >>> is_solid(r'(a|b|c)?')\n    True\n    >>> is_solid(r'(a|b)(c)')\n    False\n    >>> is_solid(r'(a|b)(c)?')\n    False\n    \"\"\"\n\n    shape = re.sub(r'(\\\\.|[^\\[\\]\\(\\)\\|\\?\\+\\*])', '#', regex)\n    skeleton = shape.replace('#', '')\n    if len(shape) <= 1:\n        return True\n    if re.match(r'^\\[[^\\]]*\\][\\*\\+\\?]?$', shape):\n        return True\n    if re.match(r'^\\([^\\(]*\\)[\\*\\+\\?]?$', shape):\n        return True\n    if re.match(r'^\\(\\)#*?\\)\\)', skeleton):\n        return True\n    else:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nunpacking a single sequence of tokens into a single sequence of tokens.", "response": "def unpack(regex):\n    \"\"\"\n    Remove the outermost parens, keep the (?P...) one\n\n    >>> unpack(r'(abc)')\n    'abc'\n    >>> unpack(r'(?:abc)')\n    'abc'\n    >>> unpack(r'(?P<xyz>abc)')\n    '(?P<xyz>abc)'\n    >>> unpack(r'[abc]')\n    '[abc]'\n    \"\"\"\n    if is_packed(regex) and not regex.startswith('(?P<'):\n        return re.sub(r'^\\((\\?:)?(?P<content>.*?)\\)$', r'\\g<content>', regex)\n    else:\n        return regex"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parallel(regex_list, sort=False):\n    if sort:\n        regex_list = sorted(regex_list, key=len, reverse=True)\n    return '|'.join([unpack(regex) for regex in regex_list])", "response": "Join the given regexes using r| and return the result as a string."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a regex that can be used to match a nocatch pattern.", "response": "def nocatch(regex):\n    \"\"\"\n    Put on a pair of parens (with no catch tag) outside the regex,\n    if the regex is not yet packed;\n    modified the outmost parens by adding nocatch tag\n    \"\"\"\n    if is_solid(regex) and not is_packed(regex):\n        return regex\n    else:\n        return '(?:{})'.format(danger_unpack(regex))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef concat(regex_list):\n    output_list = []\n\n    for regex in regex_list:\n        output_list.append(consolidate(regex))\n    return r''.join(output_list)", "response": "Concatenate multiple regular expression into one."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting the cache directory to the dtool config file.", "response": "def set_cache(config_fpath, cache_dir):\n    \"\"\"Write the cache directory to the dtool config file.\n\n    :param config_fpath: path to the dtool config file\n    :param cache_dir: the path to the dtool cache direcotory\n    \"\"\"\n    cache_dir = os.path.abspath(cache_dir)\n    return write_config_value_to_file(\n        CACHE_DIRECTORY_KEY,\n        cache_dir,\n        config_fpath\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_azure_secret_access_key(config_fpath, container, az_secret_access_key):\n    key = AZURE_KEY_PREFIX + container\n    return write_config_value_to_file(key, az_secret_access_key, config_fpath)", "response": "Write the ECS access key id to the dtool config file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlisting the azure storage containers in the config file.", "response": "def list_azure_containers(config_fpath):\n    \"\"\"List the azure storage containers in the config file.\n\n    :param config_fpath: path to the dtool config file\n    :returns: the list of azure storage container names\n    \"\"\"\n    config_content = _get_config_dict_from_file(config_fpath)\n    az_container_names = []\n    for key in config_content.keys():\n        if key.startswith(AZURE_KEY_PREFIX):\n            name = key[len(AZURE_KEY_PREFIX):]\n            az_container_names.append(name)\n    return sorted(az_container_names)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load(self, filename, create = None, default_conf = {}):\n        filenames, tries = self.__search_config_files(filename)\n\n        if len(filenames):\n            self.__loaded_config_file = filenames if self.__nested else filenames[0]\n            return self.__load_config_files(filenames if self.__nested else filenames[:1])\n\n        if create is not None:\n            self.__loaded_config_file = os.path.join(create, filename)\n            self.save(default_conf)\n            return default_conf\n\n        raise ConfigFileNotFoundException(\"Config file not found in: %s\" % tries)", "response": "Loads the config file and returns the value of the ConfigFormatter. decode or the default_conf value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves the config data", "response": "def save(self, data):\n        \"\"\"Save the config data\n\n        Args:\n            data: any serializable config data\n\n        Raises:\n            ConfigLoaderException: if the ConfigLoader.load not called, so there is no config file name,\n                                   or the data is not serializable or the loader is nested\n        \"\"\"\n        if self.__nested:\n            raise ConfigLoaderException(\"Cannot save the config if the 'nested' paramter is True!\")\n\n        if self.__loaded_config_file is None:\n            raise ConfigLoaderException(\"Load not called yet!\")\n\n        try:\n            with open(self.__loaded_config_file, 'w') as f:\n                f.write(self.__formatter.encode(data))\n        except Exception as e:\n            raise ConfigLoaderException(\"Config data is not serializable: %s\" % e)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef execute_get_text(command, raise_errors=False):  # type: (str, bool) -> str\n    try:\n        result = subprocess.check_output(command, stderr=subprocess.STDOUT, shell=True)\n        # print(result.decode())\n    except subprocess.CalledProcessError:\n        if raise_errors:\n            raise\n        return \"\"\n    if result:\n        return result.decode(\"utf-8\")\n    return \"\"", "response": "Execute a shell commmand\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a speakable text from a METAR string.", "response": "def metar_to_speech(metar: str) -> str:\n        \"\"\"\n        Creates a speakable text from a METAR\n\n        Args:\n            metar: METAR string to use\n\n        Returns: speakable METAR for TTS\n\n        \"\"\"\n        LOGGER.info('getting speech text from METAR: %s', metar)\n        metar_data, metar_units = emiz.avwx.metar.parse_in(metar)\n        speech = emiz.avwx.speech.metar(metar_data, metar_units)\n        speech = str(speech).replace('Altimeter', 'Q N H')\n        LOGGER.debug('resulting speech: %s', speech)\n        return speech"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the lowercase name if this name adheres to requirements None otherwise.", "response": "def valid(name, maxlength=None):\n    '''\n    Return the lowercase name if this name adheres to requirements, None\n    otherwise.\n    The requirements are:\n      * only alphanumeric characters or dashes\n      * no number at the start\n      * no double dashes or dashes at the start or end of the name\n      * no empty string\n      * no string bigger than maxlength\n    '''\n\n    if not name:\n        return None\n    if maxlength is not None and len(name) > maxlength:\n        return None\n    name = name.lower()\n    if name.endswith('-') or name.startswith('-') or '--' in name:\n        return None\n    if name[0] in string.digits:\n        return None\n    for c in name:\n        if c not in string.digits+string.ascii_lowercase+'-':\n            return None\n\n    return name"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns true if this name is allowed in the forbidden list and false otherwise.", "response": "def allowed(name, collection='all'):\n    '''\n    Return true if this name is allowed (e.g. not in the forbidden list,\n    indicated by 'collection'), false otherwise.\n    '''\n\n    if not valid(name):\n        return False\n\n    blacklist = names()\n    for forbidden in blacklist[collection]:\n        if name.lower() == forbidden.lower():\n            return False\n        if forbidden.endswith('*'):\n            # very primitive glob matching\n            if name.lower().startswith(forbidden[:-1].lower()):\n                return False\n        if forbidden.startswith('/'):\n            # reference to another collection\n            if not allowed(name, collection=forbidden[1:]):\n                return False\n\n    # No match.\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncopies src and dst to temp_dir and replace all variables in dst.", "response": "def copy_tree_and_replace_vars(self, src, dst):\n        \"\"\"\n        \u0415\u0441\u043b\u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u0435\u0442\u0441\u044f \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u044f \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430, \u0442\u043e \u0431\u0443\u0434\u0435\u0442\n        \u0440\u0430\u0441\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c\u0441\u044f \u043a\u0430\u043a \u0448\u0430\u0431\u043b\u043e\u043d \u0438\u043c\u0435\u043d\u043d\u043e \u0435\u0451 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435!! \u041e\u043d\u043e \u0436\u0435 \u0438 \u0431\u0443\u0434\u0435\u0442\n        \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c\u0441\u044f\n        \"\"\"\n        if os.path.isdir(src):\n            copy_tree(src, self.temp_dir)\n        elif os.path.isfile(src):\n            shutil.copy(src, self.temp_dir)\n\n        for root, subdirs, files in os.walk(self.temp_dir, topdown=False):\n            for file in files:\n                self.replace_f(os.path.join(root, file))\n            for subdir in subdirs:\n                self.replace_d(os.path.join(root, subdir))\n        copy_tree(self.temp_dir, dst)\n\n        # \u041e\u0447\u0438\u0441\u0442\u0438\u0442\u044c \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u044e\n        shutil.rmtree(self.temp_dir)\n        os.makedirs(self.temp_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef replace_f(self, path, arg_name=None):\n        root, file = os.path.split(path)\n\n        pattern = re.compile(r'(\\<\\<\\<)([A-Za-z_]+)(\\>\\>\\>)')\n        file_path = path\n        fh, abs_path = mkstemp()\n        with open(abs_path, 'w') as new_file:\n            with open(file_path) as old_file:\n                for line in old_file:\n                    for (o, var_name, c) in re.findall(pattern, line):\n                        line = self.handle_args(line, var_name, arg_name)\n                    new_file.write(line)\n        os.close(fh)\n        # Remove original file\n        os.remove(file_path)\n        # Move new file\n        shutil.move(abs_path, file_path)\n\n        pattern = re.compile(r'(\\[\\[)([A-Za-z_]+)(\\]\\])')\n        for (o, var_name, c) in re.findall(pattern, file):\n            file = self.handle_args(file, var_name, isfilename=True)\n        os.rename(path, os.path.join(root, file))", "response": "Replace files in path with new ones."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef replace_d(self, path, arg_name=None):\n        root, dir = os.path.split(path)\n        pattern = re.compile(r'(\\[\\[)([A-Za-z_]+)(\\]\\])')\n        for (o, var_name, c) in re.findall(pattern, dir):\n            dir = self.handle_args(dir, var_name, arg_name, isfilename=True)\n        os.rename(path, os.path.join(root, dir))", "response": "Replace directories in path with the values in arg_name."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns rel path to a downloaded file as include node argument.", "response": "def run(self):\n        \"\"\"Return rel path to a downloaded file as `include` node argument.\"\"\"\n        document = self.state.document\n        env = document.settings.env\n        buildpath = env.app.outdir\n        link = self.arguments[0]\n\n        try:\n            r = requests.get(link)\n            r.raise_for_status()\n            downloadpath = os.path.join(buildpath, '_downloads')\n            if not os.path.isdir(downloadpath):\n                os.makedirs(downloadpath)\n            rstfile = os.path.join(downloadpath, os.path.basename(link))\n            with open(rstfile, 'w') as f:\n                f.write(r.text)\n            rstfile = os.path.relpath(rstfile, os.path.dirname(env.doc2path\n                                                               (env.docname)))\n            self.arguments = [rstfile]\n            return super(RemoteInclude, self).run()\n        except Exception:\n            err = 'Unable to resolve ' + link\n            return [document.reporter.warning(str(err), line=self.lineno)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninvokes the deserializer method will return a dict of the JSON payload.", "response": "def deserialize(self):\n        \"\"\" Invoke the deserializer\n\n        The JsonDeserializer.deserializer() method will\n        return a dict of the JSON payload.\n\n        :return:\n            normalized dict\n        \"\"\"\n\n        body = super(Deserializer, self).deserialize()\n\n        self.parse(body)\n        return self.normalize(body)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting all the relationships by key and val & return them", "response": "def _normalize_relationships(relationships):\n        \"\"\" Get all the relationships by key/val & return them\n\n        A normalized relationship dict uses the key name without\n        any alteration but the value will be the `id` provided\n        in the payload if present. If not present, then the client\n        wants to unset the relationship so it will be set to None.\n\n        INFO: only works for to-one relationships.\n\n        :param relationships:\n            dict JSON API relationships object\n        :return: dict\n        \"\"\"\n\n        ret = {}\n\n        for key, val in relationships.items():\n            if not val['data']:\n                ret[key] = None\n            else:\n                ret[key] = val['data']['id']\n\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef normalize(self, body):\n\n        resource = body['data']\n        data = {'rtype': resource['type']}\n\n        if 'attributes' in resource:\n            attributes = resource['attributes']\n            attributes = self._normalize_attributes(attributes)\n\n            data.update(attributes)\n\n        if 'relationships' in resource:\n            relationships = resource['relationships']\n            relationships = self._normalize_relationships(relationships)\n\n            data.update(relationships)\n\n        if resource.get('id'):\n            data['rid'] = resource['id']\n\n        return data", "response": "This method is called by the Parser class to normalize the JSON API response."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_attributes(self, attributes):\n\n        link = 'jsonapi.org/format/#document-resource-object-attributes'\n\n        if not isinstance(attributes, dict):\n            self.fail('The JSON API resource object attributes key MUST '\n                      'be a hash.', link)\n        elif 'id' in attributes or 'type' in attributes:\n            self.fail('A field name of `id` or `type` is not allowed in '\n                      'the attributes object. They should be top-level '\n                      'keys.', link)", "response": "Ensure compliance with the spec s attributes section\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_relationships(self, relationships):\n\n        link = 'jsonapi.org/format/#document-resource-object-relationships'\n\n        if not isinstance(relationships, dict):\n            self.fail('The JSON API resource object relationships key MUST '\n                      'be a hash & comply with the spec\\'s resource linkage '\n                      'section.', link)\n\n        for key, val in relationships.items():\n            if not isinstance(val, dict) or 'data' not in val:\n                self.fail('Relationship key %s MUST be a hash & contain '\n                          'a `data` field compliant with the spec\\'s '\n                          'resource linkage section.' % key, link)\n            elif isinstance(val['data'], dict):\n                data = val['data']\n                rid = isinstance(data.get('id'), unicode)\n                rtype = isinstance(data.get('type'), unicode)\n\n                if not rid or not rtype:\n                    self.fail('%s relationship\\'s resource linkage MUST '\n                              'contain `id` & `type` fields. Additionally, '\n                              'they must both be strings.' % key, link)\n            elif isinstance(val['data'], list):\n                abort(exceptions.ModificationDenied(**{\n                    'detail': 'Modifying the %s relationship or any to-many '\n                              'relationships for that matter are is not '\n                              'currently supported. Instead, modify the '\n                              'to-one side directly.' % key,\n                    'links': link,\n                }))\n            elif val['data']:\n                self.fail('The relationship key %s is malformed & impossible '\n                          'for us to understand your intentions. It MUST be '\n                          'a hash & contain a `data` field compliant with '\n                          'the spec\\'s resource linkage section or null if '\n                          'you want to unset the relationship.' % key, link)", "response": "Ensure compliance with the spec s relationships section\n\n        Specifically the relationships object of the single resource object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nensure compliance with the spec s resource objects section", "response": "def _parse_resource(self, resource):\n        \"\"\" Ensure compliance with the spec's resource objects section\n\n        :param resource:\n            dict JSON API resource object\n        \"\"\"\n\n        link = 'jsonapi.org/format/#document-resource-objects'\n        rid = isinstance(resource.get('id'), unicode)\n        rtype = isinstance(resource.get('type'), unicode)\n\n        if not rtype or (self.req.is_patching and not rid):\n            self.fail('JSON API requires that every resource object MUST '\n                      'contain a `type` top-level key. Additionally, when '\n                      'modifying an existing resource object an `id` '\n                      'top-level key is required. The values of both keys '\n                      'MUST be strings. Your request did not comply with '\n                      'one or more of these 3 rules', link)\n        elif 'attributes' not in resource and 'relationships' not in resource:\n            self.fail('Modifiying or creating resources require at minimum '\n                      'an attributes object and/or relationship object.', link)\n        elif rid and self.req.is_posting:\n            abort(exceptions.ModificationDenied(**{\n                'detail': 'Our API does not support client-generated ID\\'s '\n                          'when creating NEW resources. Instead, our API '\n                          'will generate one for you & return it in the '\n                          'response.',\n                'links': 'jsonapi.org/format/#crud-creating-client-ids',\n            }))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nensuring compliance with the spec s top - level section.", "response": "def _parse_top_level(self, body):\n        \"\"\" Ensure compliance with the spec's top-level section \"\"\"\n\n        link = 'jsonapi.org/format/#document-top-level'\n\n        try:\n            if not isinstance(body['data'], dict):\n                raise TypeError\n        except (KeyError, TypeError):\n            self.fail('JSON API payloads MUST be a hash at the most '\n                      'top-level; rooted at a key named `data` where the '\n                      'value must be a hash. Currently, we only support '\n                      'JSON API payloads that comply with the single '\n                      'Resource Object section.', link)\n\n        if 'errors' in body:\n            self.fail('JSON API payloads MUST not have both `data` & '\n                      '`errors` top-level keys.', link)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse(self, body):\n\n        self._parse_top_level(body)\n        self._parse_resource(body['data'])\n\n        resource = body['data']\n\n        if 'attributes' in resource:\n            self._parse_attributes(resource['attributes'])\n        if 'relationships' in resource:\n            self._parse_relationships(resource['relationships'])", "response": "Parse the JSON API response body and return a dict containing the parsed attributes and relationships."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_signer_by_version(digest, ver):\n    if int(ver) == 1:\n        return V1Signer(digest)\n    elif int(ver) == 2:\n        return V2Signer(digest)\n    else:\n        return None", "response": "Returns a new signer object for a digest and version combination."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef identify(self, header):\n        for ver, signer in self.signers.items():\n            if signer.matches(header):\n                return signer\n        return None", "response": "Identifies a signature and returns the appropriate Signer object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_transforms(transforms):\n\n    from . import Transform\n    import inspect\n\n    # normalize arguments to form as [(name, [option, ...]), ...]\n    transforms_with_argv = map(lambda t: (t[0], t[1:]) if isinstance(t, list) else (t, []),\n                               transforms)\n\n    def instantiate_transform(module_name, argv):\n        tr_module = __import__(\n            module_name if module_name.count('.') > 0 else TRANSFORM_MODULE_PREFIX + module_name,\n            fromlist=['dummy'])\n        tr_classes = inspect.getmembers(\n            tr_module,\n            lambda c: issubclass(c if inspect.isclass(c) else None.__class__,\n                                 Transform))\n\n        if len(tr_classes) != 1:\n            raise TypeError('Transform module must have only one subclass of Transform')\n\n        tr_class = tr_classes[0]\n        return tr_class[1](argv)\n\n    return [instantiate_transform(tr[0], tr[1])\n            for tr in transforms_with_argv]", "response": "Load transforms modules and return instance of transform class."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a tuple of day month year for a list of overlays.", "response": "def date_tuple(ovls):\n    \"\"\"\n    We should have a list of overlays from which to extract day month\n    year.\n    \"\"\"\n\n    day = month = year = 0\n    for o in ovls:\n        if 'day' in o.props:\n            day = o.value\n\n        if 'month' in o.props:\n            month = o.value\n\n        if 'year' in o.props:\n            year = o.value\n\n        if 'date' in o.props:\n            day, month, year = [(o or n) for o, n in zip((day, month,\n                                                          year), o.value)]\n\n    return (day, month, year)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef longest_overlap(ovls):\n\n    # Ovls know how to compare to each other.\n    ovls = sorted(ovls)\n\n    # I know this could be better but ovls wont be more than 50 or so.\n    for i, s in enumerate(ovls):\n        passing = True\n\n        for l in ovls[i + 1:]:\n            if s.start in Rng(l.start, l.end, rng=(True, True)) or \\\n               s.end in Rng(l.start, l.end, rng=(True, True)):\n                passing = False\n                break\n\n        if passing:\n            yield s", "response": "Yields the longest overlays that overlap with each other."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef GetSchema(component):\n    parent = component\n    while not isinstance(parent, XMLSchema):\n        parent = parent._parent()\n    return parent", "response": "convience function for finding the parent XMLSchema instance."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __setImports(self, schema):\n        for ns,val in schema.imports.items(): \n            if self._imports.has_key(ns):\n                schema.addImportSchema(self._imports[ns])", "response": "Add dictionary of imports to schema instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __setIncludes(self, schema):\n        for schemaLocation, val in schema.includes.items(): \n            if self._includes.has_key(schemaLocation):\n                schema.addIncludeSchema(schemaLocation, self._imports[schemaLocation])", "response": "Add dictionary of includes to schema instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading XMLSchema from DOM node.", "response": "def loadFromNode(self, parent, element):\n        \"\"\"element -- DOM node or document\n           parent -- WSDLAdapter instance\n        \"\"\"\n        reader = self.__readerClass(element)\n        schema = XMLSchema(parent)\n        #HACK to keep a reference\n        schema.wsdl = parent\n        schema.setBaseUrl(self.__base_url)\n        schema.load(reader)\n        return schema"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef loadFromStream(self, file, url=None):\n        reader = self.__readerClass()\n        reader.loadDocument(file)\n        schema = XMLSchema()\n        if url is not None:\n             schema.setBaseUrl(url)\n        schema.load(reader)\n        self.__setIncludes(schema)\n        self.__setImports(schema)\n        return schema", "response": "Return an XMLSchema instance loaded from a file object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an XMLSchema instance loaded from the given URL.", "response": "def loadFromURL(self, url, schema=None):\n        \"\"\"Return an XMLSchema instance loaded from the given url.\n           url -- URL to dereference\n           schema -- Optional XMLSchema instance.\n        \"\"\"\n        reader = self.__readerClass()\n        if self.__base_url:\n            url = basejoin(self.__base_url,url)\n\n        reader.loadFromURL(url)\n        schema = schema or XMLSchema()\n        schema.setBaseUrl(url)\n        schema.load(reader)\n        self.__setIncludes(schema)\n        self.__setImports(schema)\n        return schema"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef loadFromFile(self, filename):\n        if self.__base_url:\n            filename = basejoin(self.__base_url,filename)\n        file = open(filename, 'rb')\n        try:\n            schema = self.loadFromStream(file, filename)\n        finally:\n            file.close()\n\n        return schema", "response": "Load an XMLSchema instance from the given file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if the attribute is in the attribute dictionary.", "response": "def hasattr(self, attr, ns=None):\n        \"\"\"attr -- attribute \n           ns -- optional namespace, None means unprefixed attribute.\n        \"\"\"\n        if not self.__attributes:\n            self.setAttributeDictionary()\n        if ns:\n            return self.__attributes.get(ns,{}).has_key(attr)\n        return self.__attributes.has_key(attr)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the namespace of the node with the given prefix", "response": "def getNamespace(self, prefix):\n        \"\"\"prefix -- deference namespace prefix in node's context.\n           Ascends parent nodes until found.\n        \"\"\"\n        namespace = None\n        if prefix == 'xmlns':\n            namespace = DOM.findDefaultNS(prefix, self.__node)\n        else:\n            try:\n                namespace = DOM.findNamespaceURI(prefix, self.__node)\n            except DOMException, ex:\n                if prefix != 'xml':\n                    raise SchemaError, '%s namespace not declared for %s'\\\n                        %(prefix, self.__node._get_tagName())\n                namespace = XMLNS.XML\n        return namespace"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a node trace up to the item.", "response": "def getItemTrace(self):\n        \"\"\"Returns a node trace up to the <schema> item.\n        \"\"\"\n        item, path, name, ref = self, [], 'name', 'ref'\n        while not isinstance(item,XMLSchema) and not isinstance(item,WSDLToolsAdapter):\n            attr = item.getAttribute(name)\n            if not attr:\n                attr = item.getAttribute(ref)\n                if not attr:\n                    path.append('<%s>' %(item.tag))\n                else: \n                    path.append('<%s ref=\"%s\">' %(item.tag, attr))\n            else:\n                path.append('<%s name=\"%s\">' %(item.tag,attr))\n\n            item = item._parent()\n        try:\n            tns = item.getTargetNamespace()\n        except: \n            tns = ''\n        path.append('<%s targetNamespace=\"%s\">' %(item.tag, tns))\n        path.reverse()\n        return ''.join(path)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the targetNamespace of the current object", "response": "def getTargetNamespace(self):\n        \"\"\"return targetNamespace\n        \"\"\"\n        parent = self\n        targetNamespace = 'targetNamespace'\n        tns = self.attributes.get(targetNamespace)\n        while not tns and parent and parent._parent is not None:\n            parent = parent._parent()\n            tns = parent.attributes.get(targetNamespace)\n        return tns or ''"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getQNameAttribute(self, collection, attribute):\n        tdc = self.getAttributeQName(attribute)\n        if not tdc:\n            return\n\n        obj = self.getSchemaItem(collection, tdc.getTargetNamespace(), tdc.getName())\n        if obj: \n            return obj\n\n#        raise SchemaError, 'No schema item \"%s\" in collection %s' %(tdc, collection)\n        return", "response": "returns object instance representing QName --> ( namespace name )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getSchemaItem(self, collection, namespace, name):\n        parent = GetSchema(self)\n        if parent.targetNamespace == namespace:\n            try:\n                obj = getattr(parent, collection)[name]\n            except KeyError, ex:\n                raise KeyError, 'targetNamespace(%s) collection(%s) has no item(%s)'\\\n                    %(namespace, collection, name)\n                    \n            return obj\n        \n        if not parent.imports.has_key(namespace):\n            if namespace in BUILT_IN_NAMESPACES:            \n                # built-in just return\n                # WARNING: expecting import if \"redefine\" or add to built-in namespace.\n                return\n            \n            raise SchemaError, 'schema \"%s\" does not import namespace \"%s\"' %(\n                parent.targetNamespace, namespace)\n            \n        # Lazy Eval\n        schema = parent.imports[namespace]\n        if not isinstance(schema, XMLSchema):\n            schema = schema.getSchema()    \n            if schema is not None:\n                parent.imports[namespace] = schema\n            \n        if schema is None:\n            if namespace in BUILT_IN_NAMESPACES:\n                # built-in just return\n                return\n            \n            raise SchemaError, 'no schema instance for imported namespace (%s).'\\\n                %(namespace)\n                \n        if not isinstance(schema, XMLSchema):\n            raise TypeError, 'expecting XMLSchema instance not \"%r\"' %schema\n                \n        try:\n            obj = getattr(schema, collection)[name]\n        except KeyError, ex:\n            raise KeyError, 'targetNamespace(%s) collection(%s) has no item(%s)'\\\n                %(namespace, collection, name)\n                    \n        return obj", "response": "returns object instance representing namespace name and order of item in collection"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getXMLNS(self, prefix=None):\n        if prefix == XMLSchemaComponent.xml:\n            return XMLNS.XML\n        parent = self\n        ns = self.attributes[XMLSchemaComponent.xmlns].get(prefix or\\\n                XMLSchemaComponent.xmlns_key)\n        while not ns:\n            parent = parent._parent()\n            ns = parent.attributes[XMLSchemaComponent.xmlns].get(prefix or\\\n                    XMLSchemaComponent.xmlns_key)\n            if not ns and isinstance(parent, WSDLToolsAdapter):\n                if prefix is None:\n                    return ''\n                raise SchemaError, 'unknown prefix %s' %prefix\n        return ns", "response": "deference prefix or by default xmlns returns namespace. XMLNS. XML\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getAttribute(self, attribute):\n        if type(attribute) in (list, tuple):\n            if len(attribute) != 2:\n                raise LookupError, 'To access attributes must use name or (namespace,name)'\n\n            ns_dict = self.attributes.get(attribute[0])\n            if ns_dict is None:\n                return None\n\n            return ns_dict.get(attribute[1])\n\n        return self.attributes.get(attribute)", "response": "get requested attribute value or None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning requested attribute value as namespace name or None if attribute value is not set", "response": "def getAttributeQName(self, attribute):\n        \"\"\"return requested attribute value as (namespace,name) or None \n        \"\"\"\n        qname = self.getAttribute(attribute)\n        if isinstance(qname, TypeDescriptionComponent) is True:\n            return qname\n        if qname is None:\n            return None\n\n        prefix,ncname = SplitQName(qname)\n        namespace = self.getXMLNS(prefix)\n        return TypeDescriptionComponent((namespace,ncname))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting up the attribute dictionary checks for required attributes and sets default attribute values.", "response": "def setAttributes(self, node):\n        \"\"\"Sets up attribute dictionary, checks for required attributes and \n           sets default attribute values. attr is for default attribute values \n           determined at runtime.\n           \n           structure of attributes dictionary\n               ['xmlns'][xmlns_key] --  xmlns namespace\n               ['xmlns'][prefix] --  declared namespace prefix \n               [namespace][prefix] -- attributes declared in a namespace\n               [attribute] -- attributes w/o prefix, default namespaces do\n                   not directly apply to attributes, ie Name can't collide \n                   with QName.\n        \"\"\"\n        self.attributes = {XMLSchemaComponent.xmlns:{}}\n        for k,v in node.getAttributeDictionary().items():\n            prefix,value = SplitQName(k)\n            if value == XMLSchemaComponent.xmlns:\n                self.attributes[value][prefix or XMLSchemaComponent.xmlns_key] = v\n            elif prefix:\n                ns = node.getNamespace(prefix)\n                if not ns: \n                    raise SchemaError, 'no namespace for attribute prefix %s'\\\n                        %prefix\n                if not self.attributes.has_key(ns):\n                    self.attributes[ns] = {}\n                elif self.attributes[ns].has_key(value):\n                    raise SchemaError, 'attribute %s declared multiple times in %s'\\\n                        %(value, ns)\n                self.attributes[ns][value] = v\n            elif not self.attributes.has_key(value):\n                self.attributes[value] = v\n            else:\n                raise SchemaError, 'attribute %s declared multiple times' %value\n\n        if not isinstance(self, WSDLToolsAdapter):\n            self.__checkAttributes()\n        self.__setAttributeDefaults()\n\n        #set QNames\n        for k in ['type', 'element', 'base', 'ref', 'substitutionGroup', 'itemType']:\n            if self.attributes.has_key(k):\n                prefix, value = SplitQName(self.attributes.get(k))\n                self.attributes[k] = \\\n                    TypeDescriptionComponent((self.getXMLNS(prefix), value))\n\n        #Union, memberTypes is a whitespace separated list of QNames \n        for k in ['memberTypes']:\n            if self.attributes.has_key(k):\n                qnames = self.attributes[k]\n                self.attributes[k] = []\n                for qname in qnames.split():\n                    prefix, value = SplitQName(qname)\n                    self.attributes['memberTypes'].append(\\\n                        TypeDescriptionComponent(\\\n                            (self.getXMLNS(prefix), value)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlooking for default values for unset attributes.", "response": "def __setAttributeDefaults(self):\n        \"\"\"Looks for default values for unset attributes.  If\n           class variable representing attribute is None, then\n           it must be defined as an instance variable.\n        \"\"\"\n        for k,v in self.__class__.attributes.items():\n            if v is not None and self.attributes.has_key(k) is False:\n                if isinstance(v, types.FunctionType):\n                    self.attributes[k] = v(self)\n                else:\n                    self.attributes[k] = v"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __checkAttributes(self):\n        for a in self.__class__.required:\n            if not self.attributes.has_key(a):\n                raise SchemaError,\\\n                    'class instance %s, missing required attribute %s'\\\n                    %(self.__class__, a)\n        for a,v in self.attributes.items():\n            # attribute #other, ie. not in empty namespace\n            if type(v) is dict:\n                continue\n            \n            # predefined prefixes xmlns, xml\n            if a in (XMLSchemaComponent.xmlns, XMLNS.XML):\n                continue\n            \n            if (a not in self.__class__.attributes.keys()) and not\\\n                (self.isAttribute() and self.isReference()):\n                raise SchemaError, '%s, unknown attribute(%s,%s)' \\\n                    %(self.getItemTrace(), a, self.attributes[a])", "response": "Checks that required attributes have been defined and that all attributes are legal. Raises SchemaError if any of the attributes are not legal."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef addImportSchema(self, schema):\n        if not isinstance(schema, XMLSchema):\n            raise TypeError, 'expecting a Schema instance'\n        if schema.targetNamespace != self.targetNamespace:\n            self._imported_schemas[schema.targetNamespace] = schema\n        else:\n            raise SchemaError, 'import schema bad targetNamespace'", "response": "add an import schema to the set of imported schemas"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef addIncludeSchema(self, schemaLocation, schema):\n        if not isinstance(schema, XMLSchema):\n            raise TypeError, 'expecting a Schema instance'\n        if not schema.targetNamespace or\\\n             schema.targetNamespace == self.targetNamespace:\n            self._included_schemas[schemaLocation] = schema\n        else:\n            raise SchemaError, 'include schema bad targetNamespace'", "response": "for resolving include statements in Schema instance instance\n           schemaLocation - location of schema instance schema - schema instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getAttribute(self, attribute):\n        value = XMLSchemaComponent.getAttribute(self, attribute)\n        if attribute != 'type' or value is not None:\n            return value\n        \n        if self.content is not None:\n            return None\n        \n        parent = self\n        while 1:\n            nsdict = parent.attributes[XMLSchemaComponent.xmlns]\n            for k,v in nsdict.items():\n                if v not in SCHEMA.XSD_LIST: continue\n                return TypeDescriptionComponent((v, 'anyType'))\n            \n            if isinstance(parent, WSDLToolsAdapter)\\\n                or not hasattr(parent, '_parent'):\n                break\n            \n            parent = parent._parent()\n            \n        raise SchemaError, 'failed to locate the XSD namespace'", "response": "get the attribute of a WSDLToolsAdapter"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getTypeDefinition(self, attribute=None):\n        if attribute:\n            return XMLSchemaComponent.getTypeDefinition(self, attribute)\n        gt = XMLSchemaComponent.getTypeDefinition(self, 'type')\n        if gt:\n            return gt\n        return self.content", "response": "Returns the corresponding type definition for this element."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef isQualified(self):\n        form = self.getAttribute('form')\n        if form == 'qualified':\n            return True\n        if form == 'unqualified':\n            return False\n        raise SchemaError, 'Bad form (%s) for element: %s' %(form, self.getItemTrace())", "response": "Returns True if the local element is qualified False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the corresponding element declaration for the given attribute.", "response": "def getElementDeclaration(self, attribute=None):\n        \"\"\"If attribute is None, \"ref\" is assumed, return the corresponding\n        representation of the global element declaration (ElementDeclaration),\n        To maintain backwards compat, if attribute is provided call base class method.\n        \"\"\"\n        if attribute:\n            return XMLSchemaComponent.getElementDeclaration(self, attribute)\n        return XMLSchemaComponent.getElementDeclaration(self, 'ref')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntake a list of SeqRecordExpanded objects corresponding to a gene_code and produces the gene_block as string.", "response": "def convert_to_string(self, block):\n        \"\"\"\n        Takes a list of SeqRecordExpanded objects corresponding to a gene_code\n        and produces the gene_block as string.\n\n        :param block:\n        :return: str.\n        \"\"\"\n        if self.aminoacids:\n            molecule_type = \"protein\"\n        else:\n            molecule_type = \"dna\"\n\n        out = None\n        for seq_record in block:\n            if not out:\n                out = '&[{0}]\\n'.format(molecule_type, seq_record.gene_code)\n            taxon_id = '{0}_{1}_{2}'.format(seq_record.voucher_code,\n                                            seq_record.taxonomy['genus'],\n                                            seq_record.taxonomy['species'],\n                                            )\n            sequence = get_seq(seq_record, self.codon_positions, self.aminoacids,\n                               self.degenerate)\n            seq = sequence.seq\n            if sequence.warning:\n                self.warnings.append(sequence.warning)\n\n            out += '{0}{1}\\n'.format(taxon_id.ljust(55), seq)\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef render_title_tag(context, is_og=False):\n    request = context['request']\n    content = ''\n\n    # Try to get the title from the context object (e.g. DetailViews).\n    if context.get('object'):\n        try:\n            content = context['object'].get_meta_title()\n        except AttributeError:\n            pass\n    elif context.get('meta_tagger'):\n        content = context['meta_tagger'].get('title')\n\n    if not content:\n        # Try to get the title from the cms page.\n        try:\n            content = request.current_page.get_page_title()  # Try the `page_title` before the `title of the CMS page.\n            if not content:\n                content = request.current_page.get_title()\n        except (AttributeError, NoReverseMatch):\n            pass\n\n    if not is_og:\n        return content\n    else:\n        return mark_safe('<meta property=\"og:title\" content=\"{content}\">'.format(content=content))", "response": "Returns the title as string or a complete open graph meta tag."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef render_description_meta_tag(context, is_og=False):\n    request = context['request']\n    content = ''\n\n    # Try to get the description from the context object (e.g. DetailViews).\n    if context.get('object'):\n        try:\n            content = context['object'].get_meta_description()\n        except AttributeError:\n            pass\n    elif context.get('meta_tagger'):\n        content = context['meta_tagger'].get('description')\n\n    if not content:\n        try:\n            # Try for the meta description of the cms page.\n            content = request.current_page.get_meta_description()\n        except (AttributeError, NoReverseMatch):\n            pass\n\n    if content:\n        return mark_safe('<meta {attr_name}=\"{tag_name}\" content=\"{content}\">'.format(\n            attr_name='name' if not is_og else 'property',\n            tag_name='description' if not is_og else 'og:description',\n            content=content\n        ))\n    else:\n        return ''", "response": "Returns the description as meta or open graph tag."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef render_robots_meta_tag(context):\n    request = context['request']\n    robots_indexing = None\n    robots_following = None\n\n    # Prevent indexing any unwanted domains (e.g. staging).\n    if context.request.get_host() in settings.META_TAGGER_ROBOTS_DOMAIN_WHITELIST:\n\n        # Try to get the title from the context object (e.g. DetailViews).\n        if context.get('object'):\n            try:\n                robots_indexing = context['object'].get_robots_indexing()\n                robots_following = context['object'].get_robots_following()\n            except AttributeError:\n                pass\n        elif context.get('meta_tagger'):\n            robots_indexing = context['meta_tagger'].get('robots_indexing', robots_indexing)\n            robots_following = context['meta_tagger'].get('robots_following', robots_following)\n\n        # Try fetching the robots values of the cms page.\n        if robots_indexing is None:\n            try:\n                robots_indexing = request.current_page.metatagpageextension.robots_indexing\n            except (AttributeError, NoReverseMatch, MetaTagPageExtension.DoesNotExist):\n                robots_indexing = True\n\n        if robots_following is None:\n            try:\n                robots_following = request.current_page.metatagpageextension.robots_following\n            except (AttributeError, NoReverseMatch, MetaTagPageExtension.DoesNotExist):\n                robots_following = True\n\n    return mark_safe('<meta name=\"robots\" content=\"{robots_indexing}, {robots_following}\">'.format(\n        robots_indexing='index' if robots_indexing else 'noindex',\n        robots_following='follow' if robots_following else 'nofollow'\n    ))", "response": "Returns the robots meta tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_buckets(self):\n\n        '''\n            a method to retrieve a list of buckets on s3\n\n        :return: list of buckets\n        '''\n\n        title = '%s.list_buckets' % self.__class__.__name__\n        \n        bucket_list = []\n        \n    # send request to s3\n        try:\n            response = self.connection.list_buckets()\n        except:\n            raise AWSConnectionError(title)\n\n    # create list from response\n        for bucket in response['Buckets']:\n            bucket_list.append(bucket['Name'])\n\n        self.bucket_list = bucket_list\n        \n        return self.bucket_list", "response": "a method to retrieve a list of buckets on s3\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_bucket(self, bucket_name):\n\n        '''\n            a method to delete a bucket in s3 and all its contents\n\n        :param bucket_name: string with name of bucket\n        :return: string with status of method\n        '''\n\n        title = '%s.delete_bucket' % self.__class__.__name__\n        \n    # validate inputs\n        input_fields = {\n            'bucket_name': bucket_name\n        }\n        for key, value in input_fields.items():\n            object_title = '%s(%s=%s)' % (title, key, str(value))\n            self.fields.validate(value, '.%s' % key, object_title)\n\n    # check for existence of bucket\n        if not bucket_name in self.bucket_list:\n            if not bucket_name in self.list_buckets():\n                status_msg = 'S3 bucket \"%s\" does not exist.' % bucket_name\n                self.iam.printer(status_msg)\n                return status_msg\n\n    # retrieve list of records in bucket\n        record_keys = []\n        record_list, next_key = self.list_versions(bucket_name)\n        for record in record_list:\n            details = {\n                'Key': record['key'],\n                'VersionId': record['version_id']\n            }\n            record_keys.append(details)\n\n    # delete records in bucket\n        kw_args = {\n            'Bucket': bucket_name,\n            'Delete': { 'Objects': record_keys }\n        }\n        if record_keys:\n            try:\n                response = self.connection.delete_objects(**kw_args)\n            except:\n                raise AWSConnectionError(title)\n\n    # continue deleting objects in bucket until empty\n        if next_key:\n            while next_key:\n                record_keys = []\n                record_list, next_key = self.list_versions(bucket_name, starting_key=next_key['key'], starting_version=next_key['version_id'])\n                for record in record_list:\n                    details = {\n                        'Key': record['key'],\n                        'VersionId': record['version_id']\n                    }\n                    record_keys.append(details)\n                kw_args = {\n                    'Bucket': bucket_name,\n                    'Delete': { 'Objects': record_keys }\n                }\n                try:\n                    response = self.connection.delete_objects(**kw_args)\n                except:\n                    raise AWSConnectionError(title)\n\n    # send delete bucket request\n        try:\n            self.connection.delete_bucket( Bucket=bucket_name )\n        except:\n            raise AWSConnectionError(title)\n\n    # report result and return true\n        status_msg = 'S3 bucket \"%s\" deleted.' % bucket_name\n        self.iam.printer(status_msg)\n        \n        return status_msg", "response": "a method to delete a bucket in s3 and all its contents"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_record(self, bucket_name, record_key, record_data, record_metadata=None, record_mimetype='', record_encoding='', overwrite=True):\n\n        '''\n            a method for adding a record to an S3 bucket\n            \n        :param bucket_name: string with name of bucket\n        :param record_key: string with name of key (path) for record\n        :param record_data: byte data for record\n        :param record_metadata: [optional] dictionary with metadata to attach to record\n        :param record_mimetype: [optional] string with content mimetype of record data\n        :param record_encoding: [optional] string with content encoding of record data\n        :param overwrite: [optional] boolean to overwrite any existing record\n        :return: string with name of record key\n        '''\n        \n        title = '%s.create_record' % self.__class__.__name__\n\n        import sys\n        from hashlib import md5\n        from base64 import b64encode\n    \n    # define size limitations\n        metadata_max = self.fields.metadata['limits']['metadata_max_bytes']\n        record_max = self.fields.metadata['limits']['record_max_bytes']\n        record_optimal = self.fields.metadata['limits']['record_optimal_bytes']\n        \n    # validate inputs\n        input_fields = {\n            'bucket_name': bucket_name,\n            'record_key': record_key,\n            'record_metadata': record_metadata,\n            'secret_key': secret_key\n        }\n        for key, value in input_fields.items():\n            if value:\n                object_title = '%s(%s=%s)' % (title, key, str(value))\n                self.fields.validate(value, '.%s' % key, object_title)\n    \n    # validate metadata fields\n        if record_metadata:\n            for key, value in record_metadata.items():\n                object_title = '%s(record_metadata={%s:...})' % (title, key)\n                self.fields.validate(key, '.metadata_keys', object_title)\n                object_title = '%s(record_metadata={%s:%s})' % (title, key, value)\n                self.fields.validate(value, '.metadata_values', object_title)\n        else:\n            record_metadata = {}\n    \n    # verify existence of bucket\n        if not bucket_name in self.bucket_list:\n            if not bucket_name in self.list_buckets():\n                raise ValueError('S3 bucket \"%s\" does not exist in aws region %s.' % (bucket_name, self.iam.region_name))\n    \n    # verify overwrite condition\n        if not overwrite:\n            record_status = self.read_headers(bucket_name, record_key)\n            if record_status:\n                error_msg = 'S3 bucket \"%s\" already contains a record for key \"%s\"' % (bucket_name, record_key)\n                raise ValueError(error_msg)\n        \n    # validate size of metadata\n        import json\n        metadata_size = sys.getsizeof(json.dumps(record_metadata).encode('utf-8'))\n        if metadata_size > metadata_max:\n            raise ValueError('%s(record_metadata={...}) cannot be greater than %s bytes.' % (title, metadata_max))\n                \n    # validate size of record\n        record_size = sys.getsizeof(record_data)\n        error_prefix = '%s(record_key=\"%s\", record_data=...)' % (title, record_key)\n        if record_size > record_max:\n            raise ValueError('%s exceeds maximum record data size of %s bytes.' % (error_prefix, record_max))\n        elif record_size > record_optimal:\n            self.iam.printer('[WARNING] %s exceeds optimal record data size of %s bytes.' % (error_prefix, record_optimal))\n\n    # determine content encoding\n        if not record_encoding or not record_mimetype:\n            import mimetypes\n            guess_mimetype, guess_encoding = mimetypes.guess_type(record_key)\n            if not record_mimetype:\n                record_mimetype = guess_mimetype\n            if not record_encoding:\n                record_encoding = guess_encoding\n                    \n    # create RFC 1864 base64 encoded md5 digest of data to confirm integrity\n        hash_bytes = md5(record_data).digest()\n        content_md5 = b64encode(hash_bytes).decode()\n        check_sum = md5(record_data).hexdigest()\n\n    # create key word argument dictionary\n        create_kwargs = {\n            'Bucket': bucket_name,\n            'Key': record_key,\n            'Body': record_data,\n            'ContentMD5': content_md5\n        }\n        if record_metadata:\n            create_kwargs['Metadata'] = record_metadata\n        if record_mimetype:\n            create_kwargs['ContentType'] = record_mimetype\n        if record_encoding:\n            create_kwargs['ContentEncoding'] = record_encoding\n\n    # add server side encryption key to request\n    #     if server_encryption:\n    #         key_b64, digest_b64 = self._key_digest(secret_key)\n    #         kw_args['SSECustomerAlgorithm'] = 'AES256'\n    #         kw_args['SSECustomerKey'] = key_b64\n    #         kw_args['SSECustomerKeyMD5'] = digest_b64\n\n    # send request to add object\n        try:\n            response = self.connection.put_object(**create_kwargs)\n            if response['ETag'] != '\"%s\"' % check_sum:\n                raise Exception('%s experienced a data transcription error for record \"%s\".' % record_key)\n        except:\n            raise AWSConnectionError(title)\n\n        return record_key", "response": "a method for adding a record to an S3 bucket"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_headers(self, bucket_name, record_key, record_version='', version_check=False):\n\n        '''\n            a method for retrieving the headers of a record from s3\n\n        :param bucket_name: string with name of bucket\n        :param record_key: string with key value of record\n        :param record_version: [optional] string with aws id of version of record\n        :param version_check: [optional] boolean to enable current version check\n        :return: dictionary with headers of record\n        '''\n        \n        title = '%s.read_headers' % self.__class__.__name__\n        \n        from datetime import datetime\n        from dateutil.tz import tzutc\n        \n    # validate inputs\n        input_fields = {\n            'bucket_name': bucket_name,\n            'record_key': record_key,\n            'record_version': record_version\n        }\n        for key, value in input_fields.items():\n            if value:\n                object_title = '%s(%s=%s)' % (title, key, str(value))\n                self.fields.validate(value, '.%s' % key, object_title)\n\n    # verify existence of bucket\n        if not bucket_name in self.bucket_list:\n            if not bucket_name in self.list_buckets():\n                raise ValueError('S3 bucket \"%s\" does not exist in aws region %s.' % (bucket_name, self.iam.region_name))\n                \n    # create key word argument dictionary\n        headers_kwargs = {\n            'Bucket': bucket_name,\n            'Key': record_key\n        }\n        if record_version:\n            headers_kwargs['VersionId'] = record_version\n\n    # create metadata default\n        metadata_details = {}\n        \n    # send request for record header\n        try:\n            record = self.connection.head_object(**headers_kwargs)\n        except Exception as err:\n            try:\n                import requests\n                requests.get('https://www.google.com')\n                return metadata_details\n            except:\n                raise AWSConnectionError(title, captured_error=err)\n\n    # create metadata from response\n        metadata_details = {\n            'key': record_key,\n            'version_id': '',\n            'current_version': True,\n            'content_type': '',\n            'content_encoding': '',\n            'metadata': {}\n        }\n        metadata_details = self.iam.ingest(record, metadata_details)\n        epoch_zero = datetime.fromtimestamp(0).replace(tzinfo=tzutc())\n        metadata_details['last_modified'] = (metadata_details['last_modified'] - epoch_zero).total_seconds()\n        if 'response_metadata' in metadata_details.keys():\n            del metadata_details['response_metadata']\n\n    # determine current version from version id\n        if record_version and version_check:\n            version_kwargs = {\n                'Bucket': bucket_name,\n                'Prefix': record_key\n            }\n            try:\n                version_check = self.connection.list_object_versions(**version_kwargs)\n                for version in version_check['Versions']:\n                    if version['VersionId'] == metadata_details['version_id']:\n                        metadata_details['current_version'] = version['IsLatest']\n                        break\n            except:\n                raise AWSConnectionError(title)\n\n        return metadata_details", "response": "a method for retrieving the headers of a record from s3"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_record(self, bucket_name, record_key, record_version=''):\n\n        '''\n            a method for deleting an object record in s3\n\n        :param bucket_name: string with name of bucket\n        :param record_key: string with key value of record\n        :param record_version: [optional] string with aws id of version of record\n        :return: dictionary with status of delete request\n        '''\n\n        title = '%s.delete_record' % self.__class__.__name__\n        \n    # validate inputs\n        input_fields = {\n            'bucket_name': bucket_name,\n            'record_key': record_key,\n            'record_version': record_version\n        }\n        for key, value in input_fields.items():\n            if value:\n                object_title = '%s(%s=%s)' % (title, key, str(value))\n                self.fields.validate(value, '.%s' % key, object_title)\n\n    # verify existence of bucket\n        if not bucket_name in self.bucket_list:\n            if not bucket_name in self.list_buckets():\n                raise ValueError('S3 bucket \"%s\" does not exist in aws region %s.' % (bucket_name, self.iam.region_name))\n                \n    # create key word argument dictionary\n        delete_kwargs = {\n            'Bucket': bucket_name,\n            'Key': record_key\n        }\n        if record_version:\n            delete_kwargs['VersionId'] = record_version\n\n    # send request to delete record\n        try:\n            response = self.connection.delete_object(**delete_kwargs)\n        except:\n            raise AWSConnectionError(title)\n\n    # report status\n        response_details = {\n            'version_id': ''\n        }\n        response_details = self.iam.ingest(response, response_details)\n        if 'response_metadata' in response_details.keys():\n            del response_details['response_metadata']\n        \n        return response_details", "response": "a method for deleting an object record in s3\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef export_records(self, bucket_name, export_path='', overwrite=True):\n\n        '''\n            a method to export all the records from a bucket to local files\n\n        :param bucket_name: string with name of bucket\n        :param export_path: [optional] string with path to root directory for record dump\n        :param overwrite: [optional] boolean to overwrite existing files matching records\n        :return: True\n        '''\n\n        title = '%s.export_records' % self.__class__.__name__\n        \n    # validate inputs\n        input_fields = {\n            'bucket_name': bucket_name,\n            'export_path': export_path\n        }\n        for key, value in input_fields.items():\n            if value:\n                object_title = '%s(%s=%s)' % (title, key, str(value))\n                self.fields.validate(value, '.%s' % key, object_title)\n        \n    # validate path\n        from os import path, makedirs\n        if not export_path:\n            export_path = './'\n        if not path.exists(export_path):\n            raise ValueError('%s(export_path=\"%s\") is not a valid path.' % (title, export_path))\n        elif not path.isdir(export_path):\n            raise ValueError('%s(export_path=\"%s\") must be a directory.' % (title, export_path))\n    \n    # verify existence of bucket\n        if not bucket_name in self.bucket_list:\n            if not bucket_name in self.list_buckets():\n                raise ValueError('S3 bucket \"%s\" does not exist in aws region %s.' % (bucket_name, self.iam.region_name))\n\n    # retrieve list of records in bucket\n        record_list, next_key = self.list_records(bucket_name)\n        if next_key:\n            record_number = 'first %s' % str(len(record_list))\n        else:\n            record_number = str(len(record_list))\n        plural = ''\n        if len(record_list) != 1:\n            plural = 's'\n        self.iam.printer('Exporting %s record%s from bucket \"%s\" to path \"%s\"' % (record_number, plural, bucket_name, export_path), flush=True)\n\n    # define local save function\n        def save_to_file(_export_path, _bucket_name, _record_key, _overwrite):\n            \n            try:\n                response = self.connection.get_object(Bucket=_bucket_name,Key=_record_key)\n            except:\n                raise AWSConnectionError(title)\n            record_data = response['Body'].read()\n            file_path = path.join(_export_path, _record_key)\n            dir_path = path.dirname(file_path)\n            if not path.exists(dir_path):\n                makedirs(dir_path)\n            if path.exists(file_path) and not _overwrite:\n                self.iam.printer('.\\n%s already exists. File skipped. Continuing.' % file_path, flush=True)\n            else:\n                with open(file_path, 'wb') as file:\n                    file.write(record_data)\n                    file.close()\n                self.iam.printer('.', flush=True)\n            \n    # retrieve data for records in bucket\n        for record in record_list:\n            save_to_file(export_path, bucket_name, record['key'], overwrite)\n\n    # continue exporting records in bucket until all exported\n        if next_key:\n            while next_key or record_list:\n                record_list, next_key = self.list_records(bucket_name)\n                if next_key:\n                    record_number = 'next %s' % str(len(record_list))\n                else:\n                    record_number = 'last %s' % str(len(record_list))\n                self.iam.printer('.')\n                plural = ''\n                if len(record_list) != 1:\n                    plural = 's'\n                self.iam.printer('Exporting %s record%s from bucket \"%s\" to path \"%s\"' % (record_number, plural, bucket_name, export_path), flush=True)\n                for record in record_list:\n                    save_to_file(export_path, bucket_name, record['key'], overwrite)\n\n    # report completion and return true\n        self.iam.printer(' done.')\n        return True", "response": "a method to export all the records from a bucket to local files"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _import(self, record_key, record_data, overwrite=True, encryption='', last_modified=0.0, **kwargs):\n        \n        '''\n            a helper method for other storage clients to import into s3\n            \n        :param record_key: string with key for record\n        :param record_data: byte data for body of record\n        :param overwrite: [optional] boolean to overwrite existing records\n        :param encryption: [optional] string with encryption type add to metadata\n        :param kwargs: [optional] keyword arguments from other import methods \n        :return: boolean indicating whether record was imported\n        '''\n\n    # define keyword arguments\n        from time import time\n        create_kwargs = {\n            'bucket_name': self.bucket_name,\n            'record_key': record_key,\n            'record_data': record_data,\n            'overwrite': overwrite,\n            'record_metadata': { 'last_modified': str(time()) }\n        }\n    \n    # add encryption and last_modified\n        if encryption:\n            create_kwargs['record_metadata']['encryption'] = encryption\n        if last_modified:\n            create_kwargs['record_metadata']['last_modified'] = str(last_modified)\n            \n    # add record mimetype and encoding\n        import mimetypes\n        guess_mimetype, guess_encoding = mimetypes.guess_type(record_key)\n        if not guess_mimetype:\n            if record_key.find('.yaml') or record_key.find('.yml'):\n                guess_mimetype = 'application/x-yaml'\n            if record_key.find('.drep'):\n                guess_mimetype = 'application/x-drep'\n        if guess_mimetype:\n            create_kwargs['record_mimetype'] = guess_mimetype\n        if guess_encoding:\n            create_kwargs['record_encoding'] = guess_encoding\n            \n    # create record\n        try:\n            self.s3.create_record(**create_kwargs)\n        except ValueError as err:\n            if str(err).find('already contains') > -1:\n                self.s3.iam.printer('%s already exists in %s collection. Skipping.' % (record_key, self.bucket_name))\n                return False\n            # elif str(err).find('exceeds maximum record') > -1:\n            #     self.s3.iam.printer('%s exceeds the maximum size for files on S3. Skipping.' % record_key)\n            else:\n                raise\n        except:\n            raise\n\n        return True", "response": "helper method for other storage clients to import into s3\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load(self, record_key, secret_key=''):\n        \n        '''\n            a method to retrieve byte data of an S3 record\n\n        :param record_key: string with name of record\n        :param secret_key: [optional] string used to decrypt data\n        :return: byte data for record body\n        '''\n        \n        title = '%s.load' % self.__class__.__name__\n    \n    # validate inputs\n        input_fields = {\n            'record_key': record_key,\n            'secret_key': secret_key\n        }\n        for key, value in input_fields.items():\n            if value:\n                object_title = '%s(%s=%s)' % (title, key, str(value))\n                self.fields.validate(value, '.%s' % key, object_title)\n    \n    # retrieve record data from s3\n        record_data, record_metadata = self.s3.read_record(self.bucket_name, record_key)\n    \n    # validate secret key\n        error_msg = '%s(secret_key=\"...\") required to decrypt record \"%s\"' % (title, record_key)\n        if 'encryption' in record_metadata['metadata'].keys():\n            if record_metadata['metadata']['encryption'] == 'lab512':\n                if not secret_key:\n                    raise Exception(error_msg)\n            else:\n                self.s3.iam.printer('[WARNING]: %s uses unrecognized encryption method. Decryption skipped.' % record_key)\n                secret_key = ''\n                \n    # decrypt (if necessary)\n        if secret_key:\n            from labpack.encryption import cryptolab\n            record_data = cryptolab.decrypt(record_data, secret_key)\n    \n        return record_data", "response": "a method to retrieve byte data of an S3 record"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list(self, prefix='', delimiter='', filter_function=None, max_results=1, previous_key=''):\n    \n        ''' \n            a method to list keys in the collection\n\n        :param prefix: string with prefix value to filter results\n        :param delimiter: string with value results must not contain (after prefix)\n        :param filter_function: (positional arguments) function used to filter results\n        :param max_results: integer with maximum number of results to return\n        :param previous_key: string with key in collection to begin search after\n        :return: list of key strings\n        \n        NOTE:   each key string can be divided into one or more segments\n                based upon the / characters which occur in the key string as\n                well as its file extension type. if the key string represents\n                a file path, then each directory in the path, the file name\n                and the file extension are all separate indexed values.\n\n                eg. lab/unittests/1473719695.2165067.json is indexed:\n                [ 'lab', 'unittests', '1473719695.2165067', '.json' ]\n\n                it is possible to filter the records in the collection according\n                to one or more of these path segments using a filter_function.\n\n        NOTE:   the filter_function must be able to accept an array of positional\n                arguments and return a value that can evaluate to true or false.\n                while searching the records, list produces an array of strings\n                which represent the directory structure in relative path of each\n                key string. if a filter_function is provided, this list of strings\n                is fed to the filter function. if the function evaluates this input\n                and returns a true value the file will be included in the list\n                results.\n        '''\n        \n        title = '%s.list' % self.__class__.__name__\n\n    # validate input\n        input_fields = {\n            'prefix': prefix,\n            'delimiter': delimiter,\n            'max_results': max_results,\n            'record_key': previous_key\n        }\n        for key, value in input_fields.items():\n            if value:\n                object_title = '%s(%s=%s)' % (title, key, str(value))\n                self.fields.validate(value, '.%s' % key, object_title)\n    \n    # construct default response\n        results_list = []\n        \n    # handle filter function filter\n        if filter_function:\n        \n        # validate filter function\n            try:\n                path_segments = [ 'lab', 'unittests', '1473719695.2165067', '.json' ]\n                filter_function(*path_segments)\n            except:\n                err_msg = '%s(filter_function=%s)' % (title, filter_function.__class__.__name__)\n                raise TypeError('%s must accept positional arguments.' % err_msg)\n            \n        # construct keyword arguments\n            list_kwargs = {\n                'bucket_name': self.bucket_name,\n                'prefix': prefix,\n                'delimiter': delimiter\n            }\n            \n        # determine starting key\n            starting_key = '1'\n            if previous_key:\n                previous_kwargs = {}\n                previous_kwargs.update(**list_kwargs)\n                previous_kwargs['max_results'] = 1\n                previous_kwargs['starting_key'] = previous_key\n                search_list, next_key = self.s3.list_records(**list_kwargs)\n                list_kwargs['starting_key'] = next_key\n        \n        # iterate filter over collection\n            import os\n            while starting_key:\n                search_list, starting_key = self.s3.list_records(**list_kwargs)\n                for record in search_list:\n                    record_key = record['key']\n                    path_segments = record_key.split(os.sep)\n                    if filter_function(*path_segments):\n                        results_list.append(record_key)\n                    if len(results_list) == max_results:\n                        return results_list\n        \n    # handle other filters\n        else:\n            \n        # construct keyword arguments\n            list_kwargs = {\n                'bucket_name': self.bucket_name,\n                'prefix': prefix,\n                'delimiter': delimiter,\n                'max_results': max_results\n            }\n        \n        # determine starting key\n            if previous_key:\n                previous_kwargs = {}\n                previous_kwargs.update(**list_kwargs)\n                previous_kwargs['max_results'] = 1\n                previous_kwargs['starting_key'] = previous_key\n                search_list, starting_key = self.s3.list_records(**list_kwargs)\n                list_kwargs['starting_key'] = starting_key\n    \n        # retrieve results \n            search_list, starting_key = self.s3.list_records(**list_kwargs)\n    \n        # construct result list\n            for record in search_list:\n                results_list.append(record['key'])\n        \n        return results_list", "response": "a method to list the keys in the collection"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete(self, record_key):\n        \n        ''' a method to delete a record from S3\n\n        :param record_key: string with key of record\n        :return: string reporting outcome\n        '''\n    \n        title = '%s.delete' % self.__class__.__name__\n    \n    # validate inputs\n        input_fields = {\n            'record_key': record_key\n        }\n        for key, value in input_fields.items():\n            object_title = '%s(%s=%s)' % (title, key, str(value))\n            self.fields.validate(value, '.%s' % key, object_title)\n    \n    # delete record\n        try:\n            self.s3.delete_record(self.bucket_name, record_key)\n        except:\n            if not self.exists(record_key):\n                exit_msg = '%s does not exist.' % record_key\n                return exit_msg\n            raise\n        \n        exit_msg = '%s has been deleted.' % record_key\n        return exit_msg", "response": "a method to delete a record from S3"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_uri_to_be_filtered(uri, filter_list):\n    match = False\n    if filter_list:\n        for uri_filter in filter_list:\n            if re.search(uri_filter, uri, flags=re.IGNORECASE):\n                match = True\n        return match", "response": "Test whether the given uri should be filtered by the given list of filter_list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_uris(self, base_uri, filter_list=None):\n        return {\n            re.sub(r'^/', base_uri, link.attrib['href'])\n            for link in self.parsedpage.get_nodes_by_selector('a')\n            if 'href' in link.attrib and (\n                link.attrib['href'].startswith(base_uri) or\n                link.attrib['href'].startswith('/')\n            ) and\n            not is_uri_to_be_filtered(link.attrib['href'], filter_list)\n        }", "response": "Return a set of internal URIs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfilter the headers to only include the X X", "response": "def filter_headers(data):\n    \"\"\"\u53ea\u8bbe\u7f6ehost content-type \u8fd8\u6709x\u5f00\u5934\u7684\u5934\u90e8.\n\n    :param data(dict): \u6240\u6709\u7684\u5934\u90e8\u4fe1\u606f.\n    :return(dict): \u8ba1\u7b97\u8fdb\u7b7e\u540d\u7684\u5934\u90e8.\n    \"\"\"\n    headers = {}\n    for i in data:\n        if i == 'Content-Type' or i == 'Host' or i[0] == 'x' or i[0] == 'X':\n            headers[i] = data[i]\n    return headers"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextracting messages from angular template (HTML) files that use the angular-gettext translate directive as per https://angular-gettext.rocketeer.be/ . :param fileobj: the file-like object the messages should be extracted from :param keywords: This is a standard parameter so it is accepted but ignored. :param comment_tags: This is a standard parameter so it is accepted but ignored. :param options: Another standard parameter that is accepted but ignored. :return: an iterator over ``(lineno, funcname, message, comments)`` tuples :rtype: ``iterator`` This particular extractor is quite simple because it is intended to only deal with angular templates which do not need comments, or the more complicated forms of translations. A later version will address pluralization.", "response": "def extract_angular(fileobj, keywords, comment_tags, options):\n    \"\"\"Extract messages from angular template (HTML) files that use the\n    angular-gettext translate directive as per\n    https://angular-gettext.rocketeer.be/ .\n\n    :param fileobj: the file-like object the messages should be extracted\n                    from\n    :param keywords: This is a standard parameter so it is accepted but ignored.\n\n    :param comment_tags: This is a standard parameter so it is accepted but\n                        ignored.\n    :param options: Another standard parameter that is accepted but ignored.\n    :return: an iterator over ``(lineno, funcname, message, comments)``\n             tuples\n    :rtype: ``iterator``\n\n    This particular extractor is quite simple because it is intended to only\n    deal with angular templates which do not need comments, or the more\n    complicated forms of translations.\n\n    A later version will address pluralization.\n    \"\"\"\n\n    if keywords:\n        logging.debug('Parameter keywords ignored.')\n\n    if comment_tags:\n        logging.debug('Parameter comment_tags ignored.')\n\n    if options:\n        logging.debug('Parameter options ignored.')\n\n    parser = AngularGettextHTMLParser()\n\n    for line in fileobj:\n        if not isinstance(line, str):\n            line = line.decode(locale.getpreferredencoding())\n        parser.feed(line)\n\n    for string in parser.strings:\n        yield(string)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find(*args, **kwargs):\n    # default end_at to now and start to 1 day from now\n    end_at = kwargs.get('end_at', datetime.datetime.now())\n    start_at = kwargs.get('start_at', end_at - datetime.timedelta(days=1))\n\n    # default # of records to fetch to be 50\n    limit = kwargs.get('limit', 50)\n\n    # if no user is defined, fetch for ALL\n    user = kwargs.get('user', None)\n    if user:\n        return request_log.find(start_at, end_at, limit, spec={'user': user})\n    else:\n        return request_log.find(start_at, end_at, limit)", "response": "finds the record in the log"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef TP1(x, u, jac=False):\n    '''Demo problem 1 for horsetail matching, takes two input vectors of size 2\n    and returns just the qoi if jac is False or the qoi and its gradient if jac\n    is True'''\n    factor = 0.1*(u[0]**2 + 2*u[0]*u[1] + u[1]**2)\n    q = 0 + factor*(x[0]**2 + 2*x[1]*x[0] + x[1]**2)\n    if not jac:\n        return q\n    else:\n        grad = [factor*(2*x[0] + 2*x[1]), factor*(2*x[0] + 2*x[1])]\n        return q, grad", "response": "Demo problem 1 for horsetail matching takes two input vectors of size 2\n    and returns just the qoi and its gradient"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef TP3(x, u, jac=False):\n    '''Demo problem 1 for horsetail matching, takes two input values of\n    size 1'''\n\n    q = 2 + 0.5*x + 1.5*(1-x)*u\n    if not jac:\n        return q\n    else:\n        grad = 0.5 -1.5*u\n        return q, grad", "response": "Demo problem 1 for horsetail matching takes two input values of two input values of size 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsolving the equation f = 0 for a function from R - > R using Newton s method", "response": "def newtons_method_scalar(f: fl.Fluxion, x: float, tol: float =1e-8) -> float:\n    \"\"\"Solve the equation f(x) = 0 for a function from R->R using Newton's method\"\"\"\n    max_iters: int = 100\n    for i in range(max_iters):\n        # Evaluate f(x) and f'(x)\n        y, dy_dx = f(x)\n        # Is y within the tolerance?\n        if abs(y) < tol:\n            break\n        # Compute the newton step\n        dx = -y / dy_dx\n        # update x\n        x += float(dx)\n    # Return x and the number of iterations required\n    return x, i"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_request(self, resource, params=None):\n        if params is None:\n            params = {}\n\n        url = self.request_url(resource)\n        params['format'] = 'json'\n\n        r = self.session.get(url=url, params=params)\n\n        r.raise_for_status()\n\n        return r", "response": "Makes a request to the API."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a cached item by key.", "response": "def get(self, key, bucket):\n        \"\"\" Get a cached item by key\n\n        If the cached item isn't found the return None.\n        \"\"\"\n\n        try:\n            return self._cache[bucket][key]\n        except (KeyError, TypeError):\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets a cached item by key.", "response": "def set(self, key, val, bucket):\n        \"\"\" Set a cached item by key\n\n        WARN: Regardless if the item is already in the cache,\n              it will be udpated with the new value.\n        \"\"\"\n\n        if bucket not in self._cache:\n            self._cache[bucket] = {}\n\n        self._cache[bucket][key] = val"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self, project_name, template_name, substitutions):\n        self.project_name = project_name\n        self.template_name = template_name\n\n        # create substitutions dictionary from user arguments\n        # TODO: check what is given\n        for subs in substitutions:\n            current_sub = subs.split(',')\n            current_key = current_sub[0].strip()\n            current_val = current_sub[1].strip()\n            self.substitutes_dict[current_key] = current_val\n\n        self.term.print_info(u\"Creating project '{0}' with template {1}\"\n            .format(self.term.text_in_color(project_name, TERM_PINK), template_name))\n\n        self.make_directories()\n        self.make_files()\n        self.make_posthook()", "response": "Launch the project creation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_directories(self):\n\n        # get the directories from the template\n        directories = []\n        try:\n            directories = self.directories()\n        except AttributeError:\n            self.term.print_info(u\"No directory in the template.\")\n\n        working_dir = os.getcwd()\n        # iteratively create the directories\n        for directory in directories:\n            dir_name = working_dir + '/' + directory\n            if not os.path.isdir(dir_name):\n                try:\n                    os.makedirs(dir_name)\n                except OSError as error:\n                    if error.errno != errno.EEXIST:\n                        raise\n            else:\n                self.term.print_error_and_exit(u\"The directory {0} already exists.\"\n                         .format(directory))\n\n            self.term.print_info(u\"Creating directory '{0}'\"\n                                 .format(self.term.text_in_color(directory, TERM_GREEN)))", "response": "Create the directories of the template."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating the files of the template.", "response": "def make_files(self):\n        \"\"\" Create the files of the template.  \"\"\"\n\n        # get the files from the template\n        files = []\n        try:\n            files = self.files()\n        except AttributeError:\n            self.term.print_info(u\"No file in the template. Weird, but why not?\")\n\n        # get the substitutes intersecting the template and the cli\n        try:\n            for key in self.substitutes().keys():\n                if key not in self.substitutes_dict:\n                    self.substitutes_dict[key] = self.substitutes()[key]\n\n        except AttributeError:\n            self.term.print_info(u\"No substitute in the template.\")\n\n        working_dir = os.getcwd()\n        # iteratively create the files\n        for directory, name, template_file in files:\n            if directory:\n                filepath = working_dir + '/' + directory + '/' + name\n                filename = directory + '/' + name\n            else:\n                filepath = working_dir + '/' + name\n                filename = name\n\n            # open the file to write into\n            try:\n                output = open(filepath, 'w')\n            except IOError:\n                self.term.print_error_and_exit(u\"Can't create destination\"\\\n                                                \" file: {0}\".format(filepath))\n\n            # open the template to read from\n            if template_file:\n                input_file = join(dirname(__file__), template_file + '.txt')\n\n                # write each line of input file into output file,\n                # templatized with substitutes\n                try:\n                    with open(input_file, 'r') as line:\n                        template_line = Template(line.read())\n                        try:\n                            output.write(template_line.\n                                safe_substitute(self.substitutes_dict).encode('utf-8'))\n                        except TypeError:\n                            output.write(template_line.\n                                safe_substitute(self.substitutes_dict))\n                    output.close()\n                except IOError:\n                    self.term.print_error_and_exit(u\"Can't create template file\"\\\n                                                   \": {0}\".format(input_file))\n            else:\n                output.close() # the file is empty, but still created\n\n            self.term.print_info(u\"Creating file '{0}'\"\n                             .format(self.term.text_in_color(filename, TERM_YELLOW)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning the post hook into the project directory.", "response": "def make_posthook(self):\n        \"\"\" Run the post hook into the project directory. \"\"\"\n        print(id(self.posthook), self.posthook)\n        print(id(super(self.__class__, self).posthook), super(self.__class__, self).posthook)\n        import ipdb;ipdb.set_trace()\n        if self.posthook:\n            os.chdir(self.project_name) # enter the project main directory\n            self.posthook()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreplace all old_exp by new_exp in the given file.", "response": "def replace_in_file(self, file_path, old_exp, new_exp):\n        \"\"\" In the given file, replace all 'old_exp' by 'new_exp'. \"\"\"\n        self.term.print_info(u\"Making replacement into {}\"\n                                 .format(self.term.text_in_color(file_path,\n                                                                 TERM_GREEN)))\n        # write the new version into a temporary file\n        tmp_file = tempfile.NamedTemporaryFile(mode='w+t', delete=False)\n        for filelineno, line in enumerate(io.open(file_path, encoding=\"utf-8\")):\n            if old_exp in line:\n                line = line.replace(old_exp, new_exp)\n            try:\n                tmp_file.write(line.encode('utf-8'))\n            except TypeError:\n                tmp_file.write(line)\n\n        name = tmp_file.name # keep the name\n        tmp_file.close()\n        shutil.copy(name, file_path) # replace the original one\n        os.remove(name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprocesses the request after routing.", "response": "def process_resource(self, req, resp, resource):\n        \"\"\" Process the request after routing.\n\n        Serializer selection needs a resource to determine which\n        serializers are allowed.\n        \"\"\"\n\n        if resource:\n            allowed = resource.serializer_mimetypes\n            preferred = req.client_prefers(allowed)\n\n            if not preferred:\n                abort(RequestNotAcceptable(allowed))\n            else:\n                serializer = self._get_serializer(preferred)\n                resp.serializer = serializer(req, resp)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds si into the currently open chunk which it creates if necessary.", "response": "def add(self, si):\n        '''puts `si` into the currently open chunk, which it creates if\n        necessary.  If this item causes the chunk to cross chunk_max,\n        then the chunk closed after adding.\n\n        '''\n        if self.o_chunk is None:\n            if os.path.exists(self.t_path):\n                os.remove(self.t_path)\n            self.o_chunk = streamcorpus.Chunk(self.t_path, mode='wb')\n        self.o_chunk.add(si)\n        logger.debug('added %d-th item to chunk', len(self.o_chunk))\n        if len(self.o_chunk) == self.chunk_max:\n            self.close()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a reference to the first element in the iterable for which pred returns True. If no such element is found the function returns default.", "response": "def find_if(pred, iterable, default=None):\n    \"\"\"\n    Returns a reference to the first element in the ``iterable`` range for\n    which ``pred`` returns ``True``. If no such element is found, the\n    function returns ``default``.\n\n        >>> find_if(lambda x: x == 3, [1, 2, 3, 4])\n        3\n\n    :param pred: a predicate function to check a value from the iterable range\n    :param iterable: an iterable range to check in\n    :param default: a value that will be returned if no elements were found\n    :returns: a reference to the first found element or default\n    \"\"\"\n    return next((i for i in iterable if pred(i)), default)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmanages an object represented by a. resources. Object instance.", "response": "def visit_named_object(self, _, children):\n        \"\"\"Manage an object, represented by a ``.resources.Object`` instance.\n\n        This object is populated with data from the result of the ``FILTERS``.\n\n        Arguments\n        ---------\n        _ (node) : parsimonious.nodes.Node.\n        children : list\n            - 0: for ``FILTERS``: list of instances of ``.resources.Field``.\n            - 1: for ``OBJECT``: an ``Object`` resource\n\n        Example\n        -------\n\n        >>> DataQLParser(r'foo{name}', default_rule='NAMED_OBJECT').data\n        <Object[foo]>\n          <Field[name] />\n        </Object[foo]>\n\n        \"\"\"\n\n        filters, resource = children\n        resource.name = filters[0].name\n        resource.filters = filters\n\n        return resource"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef visit_named_list(self, _, children):\n\n        filters, resource = children\n        resource.name = filters[0].name\n        resource.filters = filters\n\n        return resource", "response": "Manage a list represented by a. resources. List instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndisables an include type.", "response": "def disable(identifier, children_only=False):\n    \"\"\"\n    Disable an include type\n\n    :param identifier: module or name of the include type\n    :param children_only: disable the include type only for child processes, not the current process\n\n    The ``identifier`` can be specified in multiple ways to disable an include type.\n    See :py:meth:`~.DisabledIncludeTypes.disable` for details.\n    \"\"\"\n    DISABLED_TYPES.disable(identifier=identifier, children_only=children_only)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef enable(identifier, exclude_children=False):\n    DISABLED_TYPES.enable(identifier=identifier, exclude_children=exclude_children)", "response": "Enable a previously disabled include type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading the physical constants for the earth - sun system", "response": "def load_constants():\n    \"\"\"Load physical constants to simulate the earth-sun system\"\"\"\n    \n    # The universal gravitational constant\n    # https://en.wikipedia.org/wiki/Gravitational_constant\n    G: float = 6.67408E-11\n    \n    # The names of the celestial bodies\n    body_name = \\\n        ['sun',\n         'moon',\n         'mercury',\n         'venus',\n         'earth',\n         'mars',\n         'jupiter',\n         'saturn',\n         'uranus',\n         'neptune']\n    \n    # The mass of the celestial bodies\n    # https://en.wikipedia.org/wiki/Earth_mass\n    mass_earth: float = 5.9722E24\n    mass: Dict[str, float]  = \\\n        {'sun': mass_earth * 332946.0487,\n         'moon' : mass_earth * 0.012300037,\n         'mercury': mass_earth * 0.0553,\n         'venus': mass_earth * 0.815, \n         'earth': mass_earth * 1.0000,\n         'mars': mass_earth * 0.107,\n         'jupiter': mass_earth * 317.8,\n         'saturn': mass_earth * 95.2,\n         'uranus': mass_earth * 14.5,\n         'neptune': mass_earth * 17.1,\n         }\n    \n    # The radii of the celestial bodiea\n    # https://nineplanets.org/data1.html\n    radius: Dict[str, float] = \\\n    {'sun': 695000e3,\n     'moon': 1738e3,\n     'mercury': 2440e3,\n     'venus': 6052e3,\n     'earth': 6378e3,\n     'mars': 3397e3,\n     'jupiter': 71492e3,\n     'saturn': 60268e3,\n     'uranus': 35559e3,\n     'neptune': 24766e3     \n     }\n\n    return G, body_name, mass, radius"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef julian_day(t: date) -> int:\n    # Compute the number of days from January 1, 2000 to date t\n    dt = t - julian_base_date\n    # Add the julian base number to the number of days from the julian base date to date t\n    return julian_base_number + dt.days", "response": "Convert a Python datetime to a Julian day"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef calc_mse(q1, q2):\n    # Difference in positions between two simulations\n    dq = q2 - q1\n    # Mean squared error in AUs\n    return np.sqrt(np.mean(dq*dq))/au2m", "response": "Calculate the mean squared error in AUs\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef simulate_leapfrog(config_func: Callable, accel_func: Callable, \n                      t0: date, t1: date, steps_per_day: int):\n    \"\"\"\n    Simulate the earth-sun system from t0 to t1 using Leapfrog Integration.\n    INPUTS:\n    config_func: function taking a date or date range and returning position and velocity of bodies\n    accel_func:  function taking positions of the bodies and returning their accelerations\n    t0: start date of the simulation; a python date\n    t1: end date of the simulation (exclusive); a python date\n    dt: time step in days.\n    num_bodies: the number of celestial bodies in the simulation\n    \"\"\"\n    \n    # Length of the simulation (number of steps)\n    N: int = (t1 - t0).days * steps_per_day\n\n    # Get the initial conditions\n    q0, v0 = config_func(t0)\n\n    # Infer the number of dimensions from the shape of q0\n    dims: int = q0.shape[1]\n    \n    # The time step in seconds\n    dt = float(day2sec) / float(steps_per_day)\n    # Square of the time step\n    dt2: float = dt * dt\n    \n    # Initialize arrays to store computed positions and velocities\n    q: np.ndarray = np.zeros((N, dims))\n    v: np.ndarray = np.zeros((N, dims))\n    \n    # Initialize the first row with the initial conditions from the JPL ephemerides\n    q[0, :] = q0\n    v[0, :] = v0\n    \n    # Initialize an array to store the acceleration at each time step\n    a: np.ndarray = np.zeros((N, dims))\n    # First row of accelerations\n    a[0, :] = accel_func(q[0])\n    \n    # Perform leapfrog integration simulation\n    # https://en.wikipedia.org/wiki/Leapfrog_integration\n    print(f'Performing leapfrog integration with {N} steps...')\n    for i in tqdm(range(N-1)):\n        # Positions at the next time step\n        q[i+1,:] = q[i,:] + v[i,:] * dt + 0.5 * a[i,:] * dt2\n        # Accelerations of each body in the system at the next time step\n        a[i+1,:] = accel_func(q[i+1])        \n        # Velocities of each body at the next time step\n        v[i+1,:] = v[i,:] + 0.5 * (a[i,:] + a[i+1,:]) * dt\n    return q, v", "response": "Simulate the earth - sun system from t0 to t1 using Leapfrog Integration."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking Fluxion with the distance between body i and j", "response": "def flux_r2(q_vars: List[fl.Var], i: int, j: int):\n    \"\"\"Make Fluxion with the distance between body i and j\"\"\"\n    # Indices with the base of (x, y, z) for each body\n    k0 = 3*i\n    k1 = 3*j\n    # The squared distance bewteen body i and j as a Fluxion instance\n    return fl.square(q_vars[k1+0] - q_vars[k0+0]) + \\\n           fl.square(q_vars[k1+1] - q_vars[k0+1]) + \\\n           fl.square(q_vars[k1+2] - q_vars[k0+2])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmake Fluxion with the distance between body i and j", "response": "def flux_r(q_vars: List[fl.Var], i: int, j: int):\n    \"\"\"Make Fluxion with the distance between body i and j\"\"\"\n    return fl.sqrt(flux_r2(q_vars, i, j))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef flux_v2(v_vars: List[fl.Var], i: int):\n    # Index with the base of (v_x, v_y, v_z) for body i\n    k = 3*i\n    # The speed squared of body i\n    return fl.square(v_vars[k+0]) + fl.square(v_vars[k+1]) + fl.square(v_vars[k+2])", "response": "Make Fluxion with the speed squared of body i"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmakes Fluxion with the gratiational potential energy beween body i and j", "response": "def U_ij(q_vars: List[fl.Var], mass: np.ndarray, i: int, j: int):\n    \"\"\"Make Fluxion with the gratiational potential energy beween body i and j\"\"\"\n    # Check that the lengths are consistent\n    assert len(q_vars) == 3 * len(mass)\n    \n    # Masses of the bodies i and j\n    mi = mass[i]\n    mj = mass[j]\n    \n    # Gravitational potential is -G * m1 * m2 / r\n    U = -(G * mi * mj) / flux_r(q_vars, i, j)\n    return U"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmakes Fluxion with the kinetic energy of body i", "response": "def T_i(v_vars: List[fl.Var], mass: np.ndarray, i: int):\n    \"\"\"Make Fluxion with the kinetic energy of body i\"\"\"\n    # Check that the lengths are consistent\n    assert len(v_vars) == 3 * len(mass)\n\n    # Mass of the body i\n    m = mass[i]\n    \n    # kineteic energy = 1/2 * mass * speed^2\n    T = (0.5 * m) * flux_v2(v_vars, i)\n    return T"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef plot_energy(time, H, T, U):\n    # Normalize energy to initial KE\n    T0 = T[0]\n    H = H / T0\n    T = T / T0\n    U = U / T0\n    \n    # Plot\n    fig, ax = plt.subplots(figsize=[16,8])\n    ax.set_title('System Energy vs. Time')\n    ax.set_xlabel('Time in Days')\n    ax.set_ylabel('Energy (Ratio Initial KE)')\n    ax.plot(time, T, label='T', color='r')\n    ax.plot(time, U, label='U', color='b')\n    ax.plot(time, H, label='H', color='k')\n    ax.legend()\n    ax.grid()\n    plt.show()", "response": "Plot kinetic and potential energy of system over time"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sort_seq_records(self, seq_records):\n        for seq_record in seq_records:\n            seq_record.voucher_code = seq_record.voucher_code.replace(\"-\", \"_\")\n\n        unsorted_gene_codes = set([i.gene_code for i in seq_records])\n        sorted_gene_codes = list(unsorted_gene_codes)\n        sorted_gene_codes.sort(key=lambda x: x.lower())\n\n        unsorted_voucher_codes = set([i.voucher_code for i in seq_records])\n        sorted_voucher_codes = list(unsorted_voucher_codes)\n        sorted_voucher_codes.sort(key=lambda x: x.lower())\n\n        sorted_seq_records = []\n        for gene_code in sorted_gene_codes:\n            for voucher_code in sorted_voucher_codes:\n                for seq_record in seq_records:\n                    should_be_done = (\n                        seq_record.gene_code == gene_code and\n                        seq_record.voucher_code == voucher_code\n                    )\n                    if should_be_done:\n                        sorted_seq_records.append(seq_record)\n        return sorted_seq_records", "response": "Sort the SeqExpandedRecords by gene code and then by voucher code."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalidates the given outgroup.", "response": "def _validate_outgroup(self, outgroup):\n        \"\"\"All voucher codes in our datasets have dashes converted to underscores.\"\"\"\n        if outgroup:\n            outgroup = outgroup.replace(\"-\", \"_\")\n            good_outgroup = False\n            for seq_record in self.seq_records:\n                if seq_record.voucher_code == outgroup:\n                    good_outgroup = True\n                    break\n            if good_outgroup:\n                self.outgroup = outgroup\n            else:\n                raise ValueError(\"The given outgroup {0!r} cannot be found in the \"\n                                 \"input sequence records.\".format(outgroup))\n        else:\n            self.outgroup = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates named tuple with info needed to create a dataset.", "response": "def _prepare_data(self):\n        \"\"\"\n        Creates named tuple with info needed to create a dataset.\n\n        :return: named tuple\n        \"\"\"\n        self._extract_genes()\n        self._extract_total_number_of_chars()\n        self._extract_number_of_taxa()\n        self._extract_reading_frames()\n\n        Data = namedtuple('Data', ['gene_codes', 'number_taxa', 'number_chars',\n                                   'seq_records', 'gene_codes_and_lengths',\n                                   'reading_frames'])\n        self.data = Data(self.gene_codes, self.number_taxa, self.number_chars,\n                         self.seq_records, self._gene_codes_and_lengths,\n                         self.reading_frames)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset self. number_chars to the number of characters as string.", "response": "def _extract_total_number_of_chars(self):\n        \"\"\"\n        sets `self.number_chars` to the number of characters as string.\n        \"\"\"\n        self._get_gene_codes_and_seq_lengths()\n\n        sum = 0\n        for seq_length in self._gene_codes_and_lengths.values():\n            sum += sorted(seq_length, reverse=True)[0]\n        self.number_chars = str(sum)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _extract_number_of_taxa(self):\n        n_taxa = dict()\n        for i in self.seq_records:\n            if i.gene_code not in n_taxa:\n                n_taxa[i.gene_code] = 0\n            n_taxa[i.gene_code] += 1\n        number_taxa = sorted([i for i in n_taxa.values()], reverse=True)[0]\n        self.number_taxa = str(number_taxa)", "response": "Extracts the number of taxa from the sequence records."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cli(self):\n        # first we parse only for a configuration file with an initial parser\n        init_parser = argparse.ArgumentParser(\n                description = __doc__,\n                formatter_class = argparse.RawDescriptionHelpFormatter,\n                add_help = False)\n\n        # we don't use a file metavar because we need to support both json/yml\n        init_parser.add_argument(\"-c\", \"--config\", action=\"store\",\n                help = \"read from target configuration file\")\n\n        args, remaining_args = init_parser.parse_known_args()\n\n        # read from supplied configuration file or try to find one in the\n        # current working directory\n        reader = None\n        config_file = args.config or self.detect_config()\n        if config_file:\n            with open(config_file, 'r') as f:\n                reader = ConfigReader(f.read())\n\n        # implement the rest cli options\n        parser = argparse.ArgumentParser(\n                parents = [init_parser],\n                add_help = True,\n                description = \"Static wiki generator using Github's gists as pages\")\n\n        application_opts = reader.application if reader else {}\n        default_options = self.merge_with_default_options(application_opts)\n        parser.set_defaults(**default_options)\n\n        parser.add_argument(\"-v\", \"--version\", action=\"version\",\n                version=\"%(prog)s {0}\".format(__version__))\n\n        parser.add_argument(\"-t\", \"--templates\", action=\"store\",\n                help=\"read templates from specified folder\")\n\n        parser.add_argument(\"-o\", \"--output\", action=\"store\",\n                help=\"generate static files in target folder\")\n\n        parser.add_argument(\"-u\", \"--baseurl\", action=\"store\",\n                help=\"use a specific base URL instead of /\")\n\n        if reader:\n            self.config = reader.config\n        self.config['app'] = vars(parser.parse_args(remaining_args))\n\n        # parsing of command line argumenents is done check if we have gists\n        if 'gists' not in self.config:\n            raise WigikiConfigError(\"Cannot read gists. \"\n                                    \"Check your configuration file.\")", "response": "Read program parameters from command line and configuration files and return a dictionary of options and values."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef detect_config(self):\n        default_files = (\"config.json\", \"config.yml\")\n        for file_ in default_files:\n            if os.path.exists(file_):\n                return file_", "response": "detect the configuration files"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmerges options from configuration file with the default options", "response": "def merge_with_default_options(self, config_opts):\n        \"\"\"merge options from configuration file with the default options\"\"\"\n        return dict(list(self.defaults.items()) + list(config_opts.items()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef authorize():\n    auth = tweepy.OAuthHandler(CONSUMER_KEY, CONSUMER_SECRET)\n    url = auth.get_authorization_url()\n    print('Open this url on your webbrowser: {0}'.format(url))\n    webbrowser.open(url)\n    pin = input('Input verification number here: ').strip()\n\n    token_key, token_secret = auth.get_access_token(verifier=pin)\n\n    return OAuthToken(token_key, token_secret)", "response": "Authorize to twitter.\n    Use PIN authentification."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef expand_url(status):\n\n    try:\n        txt = get_full_text(status)\n        for url in status.entities['urls']:\n            txt = txt.replace(url['url'], url['expanded_url'])\n    except:\n        # Manually replace\n        txt = status\n        tco_pattern = re.compile(r'https://t.co/\\S+')\n        urls = tco_pattern.findall(txt)\n        for url in urls:\n            with urlopen(url) as resp:\n                expanded_url = resp.url\n            txt = txt.replace(url, expanded_url)\n\n    return txt", "response": "Expand url on statuses."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef strip_tweet(text, remove_url=True):\n    if remove_url:\n        text = url_pattern.sub('', text)\n    else:\n        text = expand_url(text)\n    text = mention_pattern.sub('', text)\n    text = html_parser.unescape(text)\n    text = text.strip()\n    return text", "response": "Strip tweet message.\n\n    This method removes mentions strings and urls(optional).\n\n    :param text: tweet message\n    :type text: :class:`str`\n\n    :param remove_url: Remove urls. default :const:`True`.\n    :type remove_url: :class:`boolean`\n\n    :returns: Striped tweet message\n    :rtype: :class:`str`"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read(fname):\n    content = None\n    with open(os.path.join(here, fname)) as f:\n        content = f.read()\n    return content", "response": "Quick way to read a file content."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_client(self, initial_timeout=0.1, next_timeout=30):\n        try:\n            return self._test_client(self._q.get(True, initial_timeout))\n        except Empty:\n            try:\n                self._lock.acquire()\n                if self._clients_in_use >= self._max_clients:\n                    raise _ClientUnavailableError(\"Too many clients in use\")\n                return self._test_client(self._make_client())\n            except NetworkError:\n                if not self._tolerate_error:\n                    raise\n            except _ClientUnavailableError as e:\n                try:\n                    return self._test_client(self._q.get(True, next_timeout))\n                except Empty:\n                    raise e\n            finally:\n                self._lock.release()", "response": "Wait until a client instance is available in the pool."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef release_client(self, cb):\n        if cb:\n            self._q.put(cb, True)\n            self._clients_in_use -= 1", "response": "Release a client from the pool."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndownload the archive from the IRS website.", "response": "def download(self):\n        \"\"\"\n        Download the archive from the IRS website.\n        \"\"\"\n        url = 'http://forms.irs.gov/app/pod/dataDownload/fullData'\n        r = requests.get(url, stream=True)\n        with open(self.zip_path, 'wb') as f:\n            # This is a big file, so we download in chunks\n            for chunk in r.iter_content(chunk_size=30720):\n                logger.debug('Downloading...')\n                f.write(chunk)\n                f.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clean(self):\n        logger.info('Cleaning up archive')\n        shutil.move(\n            os.path.join(\n                self.data_dir,\n                'var/IRS/data/scripts/pofd/download/FullDataFile.txt'\n            ),\n            self.final_path\n        )\n\n        shutil.rmtree(os.path.join(self.data_dir, 'var'))\n        os.remove(self.zip_path)", "response": "Delete the many - layered ISO - Erics and the files in the final directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the xsi type as a tuple coupled with ZSI. schema", "response": "def _get_xsitype(pyclass):\n    '''returns the xsi:type as a tuple, coupled with ZSI.schema\n    '''\n    if hasattr(pyclass,'type') and type(pyclass.type) in _seqtypes:\n        return pyclass.type\n    elif hasattr(pyclass,'type') and hasattr(pyclass, 'schema'):\n        return (pyclass.schema, pyclass.type)\n\n    return (None,None)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef serialize(self, elt, sw, pyobj, name=None, orig=None, **kw):\n        '''\n        Parameters:\n           elt -- the current DOMWrapper element \n           sw -- soapWriter object\n           pyobj -- python object to serialize\n\n        '''\n        raise EvaluateException(\"Unimplemented evaluation\", sw.Backtrace(elt))", "response": "Serialize the object to a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef SimpleHREF(self, elt, ps, tag):\n        '''Simple HREF for non-string and non-struct and non-array.\n        Parameters:\n            elt -- the DOM element being parsed\n            ps -- the ParsedSoap object.\n            tag -- \n        '''\n        if len(_children(elt)): return elt\n        href = _find_href(elt)\n        if not href:\n            if self.minOccurs is 0: return None\n            raise EvaluateException('Required' + tag + ' missing',\n                    ps.Backtrace(elt))\n        return ps.FindLocalHREF(href, elt, 0)", "response": "Simple HREF for non - string and non - struct and non - array."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the parselist and human - readable version errorlist is returned", "response": "def get_parse_and_errorlist(self):\n        \"\"\"Get the parselist and human-readable version, errorlist is returned,\n        because it is used in error messages.\n        \"\"\"\n        d = self.__class__.__dict__\n        parselist = d.get('parselist')\n        errorlist = d.get('errorlist')\n        if parselist and not errorlist:\n            errorlist = []\n            for t in parselist:\n                if t[1] not in errorlist: errorlist.append(t[1])\n            errorlist = ' or '.join(errorlist)\n            d['errorlist'] = errorlist\n        return (parselist, errorlist)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsee if the name and type of the element is what we re looking for. Otherwise return the element s type.", "response": "def checkname(self, elt, ps):\n        '''See if the name and type of the \"elt\" element is what we're\n        looking for.   Return the element's type.\n        Parameters:\n            elt -- the DOM element being parsed\n            ps -- the ParsedSoap object.\n        '''\n\n        parselist,errorlist = self.get_parse_and_errorlist()\n        ns, name = _get_element_nsuri_name(elt)\n        if ns == SOAP.ENC:\n            # Element is in SOAP namespace, so the name is a type.\n            if parselist and \\\n            (None, name) not in parselist and (ns, name) not in parselist:\n                raise EvaluateException(\n                'Element mismatch (got %s wanted %s) (SOAP encoding namespace)' % \\\n                        (name, errorlist), ps.Backtrace(elt))\n            return (ns, name)\n\n        # Not a type, check name matches.\n        if self.nspname and ns != self.nspname:\n            raise EvaluateException('Element NS mismatch (got %s wanted %s)' % \\\n                (ns, self.nspname), ps.Backtrace(elt))\n\n        if self.pname and name != self.pname:\n            raise EvaluateException('Element Name mismatch (got %s wanted %s)' % \\\n                (name, self.pname), ps.Backtrace(elt))\n        return self.checktype(elt, ps)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsees if the type of the element is what we re looking for. Return the element s type.", "response": "def checktype(self, elt, ps):\n        '''See if the type of the \"elt\" element is what we're looking for.\n        Return the element's type.\n        Parameters:\n            elt -- the DOM element being parsed\n            ps -- the ParsedSoap object.\n        '''\n        typeName = _find_type(elt)\n        if typeName is None or typeName == \"\":\n            return (None,None)\n\n        # Parse the QNAME.\n        prefix,typeName = SplitQName(typeName)\n        uri = ps.GetElementNSdict(elt).get(prefix)\n        if uri is None:\n            raise EvaluateException('Malformed type attribute (bad NS)',\n                    ps.Backtrace(elt))\n\n        #typeName = list[1]\n        parselist,errorlist = self.get_parse_and_errorlist()\n        if not parselist or \\\n        (uri,typeName) in parselist or \\\n        (_is_xsd_or_soap_ns(uri) and (None,typeName) in parselist):\n            return (uri,typeName)\n        raise EvaluateException(\n                'Type mismatch (%s namespace) (got %s wanted %s)' % \\\n                (uri, typeName, errorlist), ps.Backtrace(elt))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nis the element NIL and is that okay?", "response": "def nilled(self, elt, ps):\n        '''Is the element NIL, and is that okay?\n        Parameters:\n            elt -- the DOM element being parsed\n            ps -- the ParsedSoap object.\n        '''\n        if _find_nil(elt) not in [ \"true\",  \"1\"]: return False\n        if self.nillable is False:\n            raise EvaluateException('Non-nillable element is NIL',\n                    ps.Backtrace(elt))\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef simple_value(self, elt, ps, mixed=False):\n        '''Get the value of the simple content of this element.\n        Parameters:\n            elt -- the DOM element being parsed\n            ps -- the ParsedSoap object.\n            mixed -- ignore element content, optional text node\n        '''\n        if not _valid_encoding(elt):\n            raise EvaluateException('Invalid encoding', ps.Backtrace(elt))\n        c = _children(elt)\n        if mixed is False:\n            if len(c) == 0:\n                raise EvaluateException('Value missing', ps.Backtrace(elt))\n            for c_elt in c:\n                if c_elt.nodeType == _Node.ELEMENT_NODE:\n                    raise EvaluateException('Sub-elements in value',\n                        ps.Backtrace(c_elt))\n\n        # It *seems* to be consensus that ignoring comments and\n        # concatenating the text nodes is the right thing to do.\n        return ''.join([E.nodeValue for E in c\n                if E.nodeType \n                in [ _Node.TEXT_NODE, _Node.CDATA_SECTION_NODE ]])", "response": "Get the value of the simple content of this element."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_attributes(self, elt, ps):\n        '''find all attributes specified in the attribute_typecode_dict in\n        current element tag, if an attribute is found set it in the \n        self.attributes dictionary.  Default to putting in String.\n        Parameters:\n            elt -- the DOM element being parsed\n            ps -- the ParsedSoap object.\n        '''\n        if self.attribute_typecode_dict is None: \n            return\n        \n        attributes = {}\n        for attr,what in self.attribute_typecode_dict.items():\n            namespaceURI,localName = None,attr\n            if type(attr) in _seqtypes: \n                namespaceURI,localName = attr\n            value = _find_attrNodeNS(elt, namespaceURI, localName)\n            self.logger.debug(\"Parsed Attribute (%s,%s) -- %s\", \n                               namespaceURI, localName, value)\n\n            # For Now just set it w/o any type interpretation.\n            if value is None: continue\n            attributes[attr] = what.text_to_data(value, elt, ps)\n\n        return attributes", "response": "find all attributes specified in the attribute_typecode_dict in\n            current element tag set them in the self. attributes dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the attributes of the element el to the values of the attributes of the object pyobj.", "response": "def set_attributes(self, el, pyobj):\n        '''Instance data attributes contains a dictionary \n        of keys (namespaceURI,localName) and attribute values.\n        These values can be self-describing (typecode), or use\n        attribute_typecode_dict to determine serialization.\n        Paramters:\n            el -- MessageInterface representing the element\n            pyobj -- \n        '''\n        if not hasattr(pyobj, self.attrs_aname):\n            return\n\n        if not isinstance(getattr(pyobj, self.attrs_aname), dict):\n            raise TypeError,\\\n                'pyobj.%s must be a dictionary of names and values'\\\n                % self.attrs_aname\n\n        for attr, value in getattr(pyobj, self.attrs_aname).items():\n            namespaceURI,localName = None, attr\n            if type(attr) in _seqtypes:\n                namespaceURI, localName = attr\n\n            what = None\n            if getattr(self, 'attribute_typecode_dict', None) is not None:\n                what = self.attribute_typecode_dict.get(attr)\n                if what is None and namespaceURI is None:\n                    what = self.attribute_typecode_dict.get(localName)\n\n            # allow derived type\n            if hasattr(value, 'typecode') and not isinstance(what, AnyType):\n                if what is not None and not isinstance(value.typecode, what):\n                    raise EvaluateException, \\\n                        'self-describing attribute must subclass %s'\\\n                        %what.__class__\n\n                what = value.typecode\n                \n            self.logger.debug(\"attribute create -- %s\", value)\n            if isinstance(what, QName):\n                what.set_prefix(el, value)\n            \n            #format the data\n            if what is None:\n                value = str(value)\n            else:\n                value = what.get_formatted_content(value)\n\n            el.setAttributeNS(namespaceURI, localName, value)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_attribute_xsi_type(self, el, **kw):\n        '''if typed, set the xsi:type attribute \n        Paramters:\n            el -- MessageInterface representing the element\n        '''\n        if kw.get('typed', self.typed):\n            namespaceURI,typeName = kw.get('type', _get_xsitype(self))\n            if namespaceURI and typeName:\n                self.logger.debug(\"attribute: (%s, %s)\", namespaceURI, typeName)\n                el.setAttributeType(namespaceURI, typeName)", "response": "set the xsi : type attribute \n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_attribute_id(self, el, objid):\n        '''set id attribute\n        Paramters:\n            el -- MessageInterface representing the element\n            objid -- ID type, unique id\n        '''\n        if self.unique is False:\n            el.setAttributeNS(None, 'id', \"%s\" %objid)", "response": "set id attribute on the message interface el to objid"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the name of the tag.", "response": "def get_name(self, name, objid):\n        '''\n        Paramters:\n            name -- element tag\n            objid -- ID type, unique id\n        '''\n        if type(name) is tuple:\n            return name\n\n        ns = self.nspname\n        n = name or self.pname or ('E' + objid)\n        return ns,n"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef serialize_text_node(self, elt, sw, pyobj):\n        '''Serialize without an element node.\n        '''\n        textNode = None\n        if pyobj is not None:\n            text = self.get_formatted_content(pyobj)\n            if type(text) not in _stringtypes:\n                raise TypeError, 'pyobj must be a formatted string'\n\n            textNode = elt.createAppendTextNode(text)\n\n        return textNode", "response": "Serialize without an element node."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle the start and end tags, and attributes. callout to get_formatted_content to get the textNode value. Parameters: elt -- ElementProxy/DOM element sw -- SoapWriter instance pyobj -- processed content KeyWord Parameters: name -- substitute name, (nspname,name) or name orig --", "response": "def serialize(self, elt, sw, pyobj, name=None, orig=None, **kw):\n        '''Handles the start and end tags, and attributes.  callout\n        to get_formatted_content to get the textNode value.\n        Parameters:\n            elt -- ElementProxy/DOM element \n            sw -- SoapWriter instance\n            pyobj -- processed content\n            \n        KeyWord Parameters:\n            name -- substitute name, (nspname,name) or name\n            orig --\n            \n        '''\n        objid = _get_idstr(pyobj)\n        ns,n = self.get_name(name, objid)\n\n        # nillable\n        el = elt.createAppendElement(ns, n)\n        if self.nillable is True and pyobj is Nilled:\n            self.serialize_as_nil(el)\n            return None\n\n        # other attributes\n        self.set_attributes(el, pyobj)\n\n        # soap href attribute\n        unique = self.unique or kw.get('unique', False)\n        if unique is False and sw.Known(orig or pyobj):\n            self.set_attribute_href(el, objid)\n            return None\n\n        # xsi:type attribute \n        if kw.get('typed', self.typed) is True:\n            self.set_attribute_xsi_type(el, **kw)\n\n        # soap id attribute\n        if self.unique is False:\n            self.set_attribute_id(el, objid)\n\n        #Content, <empty tag/>c\n        self.serialize_text_node(el, sw, pyobj)\n\n        return el"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting text into typecode specific data.", "response": "def text_to_data(self, text, elt, ps):\n        '''convert text into typecode specific data.\n        Encode all strings as UTF-8, which will be type 'str'\n        not 'unicode'\n        '''\n        if self.strip: text = text.strip()\n        if self.pyclass is not None:\n            return self.pyclass(text.encode(UNICODE_ENCODING))\n        return text.encode(UNICODE_ENCODING)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef text_to_data(self, text, elt, ps):\n        '''text --> typecode specific data.\n        '''\n        return String.text_to_data(self, urldecode(text), elt, ps)", "response": "text --> typecode specific data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the prefix of the QName", "response": "def set_prefix(self, elt, pyobj):\n        '''use this method to set the prefix of the QName,\n        method looks in DOM to find prefix or set new prefix.\n        This method must be called before get_formatted_content.\n        '''\n        if isinstance(pyobj, tuple):\n            namespaceURI,localName = pyobj\n            self.prefix = elt.getPrefix(namespaceURI)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef text_to_data(self, text, elt, ps):\n        '''convert text into typecode specific data.\n        '''\n        prefix,localName = SplitQName(text)\n        nsdict = ps.GetElementNSdict(elt)\n        prefix = prefix or ''\n        try:\n            namespaceURI = nsdict[prefix]\n        except KeyError, ex:\n            raise EvaluateException('cannot resolve prefix(%s)'%prefix,\n                ps.Backtrace(elt))\n                \n        v = (namespaceURI,localName)\n        if self.pyclass is not None:\n            return self.pyclass(v)    \n        return v", "response": "convert text into typecode specific data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nserializing without an element node.", "response": "def serialize_text_node(self, elt, sw, pyobj):\n        '''Serialize without an element node.\n        '''\n        self.set_prefix(elt, pyobj)\n        return String.serialize_text_node(self, elt, sw, pyobj)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef text_to_data(self, text, elt, ps):\n        '''convert text into typecode specific data.\n        '''\n        val = b64decode(text.replace(' ', '').replace('\\n','').replace('\\r',''))\n        if self.pyclass is not None:\n            return self.pyclass(val)\n        return val", "response": "convert text into typecode specific data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef text_to_data(self, text, elt, ps):\n        '''convert text into typecode specific data.\n        '''\n        val = hexdecode(text)\n        if self.pyclass is not None:\n            return self.pyclass(val) \n        return val", "response": "convert text into typecode specific data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef text_to_data(self, text, elt, ps):\n        '''convert text into typecode specific data.\n        '''\n        if self.pyclass is not None:\n            v = self.pyclass(text) \n        else:\n            try:\n                v = int(text)\n            except:\n                try:\n                    v = long(text)\n                except:\n                    raise EvaluateException('Unparseable integer', \n                        ps.Backtrace(elt))\n        return v", "response": "convert text into typecode specific data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert text into typecode specific data.", "response": "def text_to_data(self, text, elt, ps):\n        '''convert text into typecode specific data.\n        '''\n        v = text\n        if self.pyclass is not None:\n            return self.pyclass(v)\n\n        m = _magicnums.get(v)\n        if m: return m\n\n        try:\n            return float(v)\n        except:\n            raise EvaluateException('Unparseable floating point number',\n                    ps.Backtrace(elt))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert text into typecode specific data.", "response": "def text_to_data(self, text, elt, ps):\n        '''convert text into typecode specific data.\n        '''\n        v = text\n        if v == 'false': \n            if self.pyclass is None:\n                return False\n            return self.pyclass(False)\n\n        if v == 'true': \n            if self.pyclass is None:\n                return True\n            return self.pyclass(True)\n\n        try:\n            v = int(v)\n        except:\n            try:\n                v = long(v)\n            except:\n                raise EvaluateException('Unparseable boolean', \n                        ps.Backtrace(elt))\n\n        if v:\n            if self.pyclass is None:\n                return True\n            return self.pyclass(True)\n\n        if self.pyclass is None:\n             return False\n        return self.pyclass(False)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nserializing an AnyElement to the given sw.", "response": "def serialize(self, elt, sw, pyobj, **kw):\n        '''Must provice typecode to AnyElement for serialization, else\n        try to use TC.Any to serialize instance which will serialize \n        based on the data type of pyobj w/o reference to XML schema \n        instance.\n        '''\n        if isinstance(pyobj, TypeCode):\n            raise TypeError, 'pyobj is a typecode instance.'\n        \n        what = getattr(pyobj, 'typecode', None)\n        if what is not None and type(pyobj) is types.InstanceType:\n            tc = pyobj.__class__\n            what = Any.serialmap.get(tc)\n            if not what:\n                tc = (types.ClassType, pyobj.__class__.__name__)\n                what = Any.serialmap.get(tc)\n        \n        self.logger.debug('processContents: %s', self.processContents)\n\n        # failed to find a registered type for class\n        if what is None:\n            #TODO: seems incomplete.  what about facets.\n            #if self.processContents == 'strict':\n            what = Any(pname=(self.nspname,self.pname))\n                \n        self.logger.debug('serialize with %s', what.__class__.__name__)\n        what.serialize(elt, sw, pyobj, **kw)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse(self, elt, ps):\n        '''\n        processContents -- 'lax' | 'skip' | 'strict', 'strict'\n        1) if 'skip' check namespaces, and return the DOM node.\n        2) if 'lax' look for declaration, or definition.  If\n           not found return DOM node.\n        3) if 'strict' get declaration, or raise.\n        '''\n        skip = self.processContents == 'skip'\n        nspname,pname = _get_element_nsuri_name(elt)\n        what = GED(nspname, pname)\n        if not skip and what is not None:\n            pyobj = what.parse(elt, ps)\n            try:\n                pyobj.typecode = what\n            except AttributeError, ex:\n                # Assume this means builtin type.\n                pyobj = WrapImmutable(pyobj, what)\n            return pyobj\n        \n        # Allow use of \"<any>\" element declarations w/ local\n        # element declarations\n        prefix, typeName = SplitQName(_find_type(elt))\n        if not skip and typeName:\n            namespaceURI = _resolve_prefix(elt, prefix or 'xmlns')\n            # First look thru user defined namespaces, if don't find\n            # look for 'primitives'.\n            pyclass = GTD(namespaceURI, typeName) or Any\n            what = pyclass(pname=(nspname,pname))\n            pyobj = what.parse(elt, ps)\n            try:\n                pyobj.typecode = what\n            except AttributeError, ex:\n                # Assume this means builtin type.\n                pyobj = WrapImmutable(pyobj, what)\n                \n            what.typed = True\n            return pyobj\n\n        if skip:\n            what = XML(pname=(nspname,pname), wrapped=False)\n        elif self.processContents == 'lax':\n            what = Any(pname=(nspname,pname), unique=True)\n        else:\n            what = Any(pname=(nspname,pname), unique=True)\n\n        try:\n            pyobj = what.parse(elt, ps)\n        except EvaluateException, ex:\n            self.logger.debug(\"error parsing:  %s\" %str(ex))\n\n            if len(_children(elt)) != 0:\n                self.logger.debug('parse <any>, return as dict')\n                return Any(aslist=False).parse_into_dict_or_list(elt, ps)\n\n            self.logger.debug(\"Give up, parse (%s,%s) as a String\", \n                  what.nspname, what.pname)\n            what = String(pname=(nspname,pname), typed=False)\n            return WrapImmutable(what.parse(elt, ps), what)\n\n        if pyobj is None: \n            return\n\n        # dict is elementName:value pairs\n        if type(pyobj) is dict:\n            return pyobj\n\n        try:\n            pyobj.typecode = what\n        except AttributeError:\n            pyobj = WrapImmutable(pyobj, what)\n\n        return pyobj", "response": "Parse an element and return a new object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse(self, elt, ps, **kw):\n        '''attempt to parse sequentially.  No way to know ahead of time\n        what this instance represents.  Must be simple type so it can\n        not have attributes nor children, so this isn't too bad.\n        '''\n        self.setMemberTypeCodes()\n        (nsuri,typeName) = self.checkname(elt, ps)\n\n        #if (nsuri,typeName) not in self.memberTypes:\n        #    raise EvaluateException(\n        #            'Union Type mismatch got (%s,%s) not in %s' % \\\n        #            (nsuri, typeName, self.memberTypes), ps.Backtrace(elt))\n\n        for indx in range(len(self.memberTypeCodes)):\n            typecode = self.memberTypeCodes[indx]\n            try:\n                pyobj = typecode.parse(elt, ps)\n            except ParseException, ex:\n                continue\n            except Exception, ex:\n                continue\n\n            if indx > 0:\n                self.memberTypeCodes.remove(typecode)\n                self.memberTypeCodes.insert(0, typecode)\n            break\n\n        else:\n            raise\n\n        return pyobj", "response": "attempt to parse sequentially."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting text into typecode specific data. items in list are space separated.", "response": "def text_to_data(self, text, elt, ps):\n        '''convert text into typecode specific data.  items in\n        list are space separated.\n        '''\n        v = []\n        items = text.split()\n        for item in items:\n            v.append(self.itemTypeCode.text_to_data(item, elt, ps))\n\n        if self.pyclass is not None:\n            return self.pyclass(v)\n        return v"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the element and return a list of the related object.", "response": "def parse(self, elt, ps):\n        '''elt -- the DOM element being parsed\n        ps -- the ParsedSoap object.\n        '''\n        self.checkname(elt, ps)\n        if len(_children(elt)) == 0:\n            href = _find_href(elt)\n            if not href:\n                if self.nilled(elt, ps) is False:\n                    return []\n                if self.nillable is True: \n                    return Nilled\n                raise EvaluateException('Required string missing',\n                        ps.Backtrace(elt))\n            if href[0] != '#':\n                return ps.ResolveHREF(href, self)\n            elt = ps.FindLocalHREF(href, elt)\n            self.checktype(elt, ps)\n\n        if self.nilled(elt, ps): return Nilled\n        if len(_children(elt)) == 0: return []\n\n        v = self.simple_value(elt, ps)\n        return self.text_to_data(v, elt, ps)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef serialize(self, elt, sw, pyobj, name=None, orig=None, **kw):\n        '''elt -- the current DOMWrapper element \n           sw -- soapWriter object\n           pyobj -- python object to serialize\n        '''\n        if pyobj is not None and type(pyobj) not in _seqtypes:\n            raise EvaluateException, 'expecting a list or None'\n\n        objid = _get_idstr(pyobj)\n        ns,n = self.get_name(name, objid)\n        el = elt.createAppendElement(ns, n)\n        if self.nillable is True and pyobj is None:\n            self.serialize_as_nil(el)\n            return None\n        \n        tc = self.itemTypeCode\n        s = StringIO(); sep = ' '\n        for item in pyobj:\n            s.write(tc.get_formatted_content(item))\n            s.write(sep)\n\n        el.createAppendTextNode(s.getvalue())", "response": "Serialize the object into the current DOMWrapper element."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconsumes URI using site config.", "response": "def consumer(site, uri):\n    \"\"\"Consume URI using site config.\"\"\"\n    config = load_site_config(site)\n    model = _get_model('consume', config, uri)\n    consumestore = get_consumestore(\n        model=model,\n        method=_config.get('storage', 'file'),\n        bucket=_config.get('s3_data_bucket', None)\n    )\n    consumestore.save_media()\n    consumestore.save_data()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef crawler(site, uri=None):\n    config = load_site_config(site)\n    model = _get_model('crawl', config, uri)\n    visited_set, visited_uri_set, consume_set, crawl_set = get_site_sets(\n        site, config\n    )\n\n    if not visited_set.has(model.hash):\n        visited_set.add(model.hash)\n        visited_uri_set.add(model.uri)\n\n        if (\n            model.is_consume_page\n            and not consume_set.has(model.hash)\n        ):\n            consume_set.add(model.hash)\n            consume_q.enqueue(\n                consumer,\n                site,\n                model.uri\n            )\n        else:\n            for crawl_uri in model.uris_to_crawl:\n                if (\n                    not visited_uri_set.has(crawl_uri)\n                    and not crawl_set.has(crawl_uri)\n                ):\n                    crawl_set.add(crawl_uri)\n                    crawl_q.enqueue(\n                        crawler,\n                        site,\n                        crawl_uri\n                    )", "response": "Crawl URI using site config."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nkill queues and Redis sets.", "response": "def killer(site):\n    \"\"\"Kill queues and Redis sets.\"\"\"\n    config = load_site_config(site)\n    crawl_q.empty()\n    consume_q.empty()\n\n    for site_set in get_site_sets(site, config):\n        site_set.destroy()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a tuple containing client authentication data.", "response": "def GetAuth(self):\n        '''Return a tuple containing client authentication data.\n        '''\n        if self.auth: return self.auth\n        for elt in self.ps.GetMyHeaderElements():\n            if elt.localName == 'BasicAuth' \\\n            and elt.namespaceURI == ZSI_SCHEMA_URI:\n                d = _auth_tc.parse(elt, self.ps)\n                self.auth = (AUTH.zsibasic, d['Name'], d['Password'])\n                return self.auth\n        ba = self.environ.get('HTTP_AUTHENTICATION')\n        if ba:\n            ba = ba.split(' ')\n            if len(ba) == 2 and ba[0].lower() == 'basic':\n                ba = _b64_decode(ba[1])\n                self.auth = (AUTH.httpbasic,) + tuple(ba.split(':'))\n                return self.auth\n        self.auth = (AUTH.none,)\n        return self.auth"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef permission_required_with_403(perm, login_url=None):\n    return user_passes_test_with_403(lambda u: u.has_perm(perm), login_url=login_url)", "response": "Decorator for views that checks whether a user has a particular permission and redirects to the login page if it s not."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting an image to RGB if it isn t already RGB or grayscale", "response": "def convert_to_rgb(img):\n    \"\"\"\n    Convert an image to RGB if it isn't already RGB or grayscale\n    \"\"\"\n    if img.mode == 'CMYK' and HAS_PROFILE_TO_PROFILE:\n        profile_dir = os.path.join(os.path.dirname(__file__), 'profiles')\n        input_profile = os.path.join(profile_dir, \"USWebUncoated.icc\")\n        output_profile = os.path.join(profile_dir, \"sRGB_v4_ICC_preference.icc\")\n        return profileToProfile(img, input_profile, output_profile, outputMode='RGB')\n    return img"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef optimize(image, fmt='jpeg', quality=80):\n    from io import BytesIO\n\n    if IMAGE_OPTIMIZATION_CMD and is_tool(IMAGE_OPTIMIZATION_CMD):\n        image_buffer = BytesIO()\n        image.save(image_buffer, format=fmt, quality=quality)\n        image_buffer.seek(0)  # If you don't reset the file pointer, the read command returns an empty string\n        p1 = subprocess.Popen(IMAGE_OPTIMIZATION_CMD, stdin=subprocess.PIPE, stdout=subprocess.PIPE)\n        output_optim, output_err = p1.communicate(image_buffer.read())\n        if not output_optim:\n            logger.debug(\"No image buffer received from IMAGE_OPTIMIZATION_CMD\")\n            logger.debug(\"output_err: {0}\".format(output_err))\n            return image\n        im = Image.open(BytesIO(output_optim))\n        return im\n    else:\n        return image", "response": "Optimize the image if IMAGE_OPTIMIZATION_CMD is set."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setup_config(\n        config_directories=None,\n        config_file=None,\n        default_filename=\"opentc.yml\"\n):\n    \"\"\"Setup configuration\n\n    \"\"\"\n    config_found = False\n    config_file_path = None\n    if config_file:\n        config_file_path = config_file\n        if os.path.isfile(config_file_path) and os.access(config_file_path, os.R_OK):\n            config_found = True\n    else:\n        for directory in config_directories:\n            if directory is None:\n                continue\n            config_file_path = os.path.join(directory, default_filename)\n            if os.path.isfile(config_file_path) and os.access(config_file_path, os.R_OK):\n                config_found = True\n                break\n    if config_found:\n        with open(config_file_path, 'rt') as ymlfile:\n            config = yaml.safe_load(ymlfile.read())\n        return config\n    else:\n        print(\"The configuration file is not found.\")\n        exit(1)", "response": "Setup the configuration of the current user s page."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading a single object from a file.", "response": "def load(filename, default=None):\n    '''\n    Try to load @filename. If there is no loader for @filename's filetype, \n    return @default.\n    '''\n    ext = get_ext(filename)\n    if ext in ldict:\n        return ldict[ext](filename)\n    else:\n        return default"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprint to stdout msg followed by the runtime.", "response": "def report(self, msg, do_reset=False, file=sys.stdout):\n        \"\"\"Print to stdout msg followed by the runtime.\n\n        When true, do_reset will result in a reset of start time.\n\n        \"\"\"\n        print >> file, \"%s (%s s)\" % (msg, time.time() - self.start)\n        if do_reset:\n            self.start = time.time()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a string containing ellapsed time as a string.", "response": "def result(self, msg, do_reset=False):\n        \"\"\"Return log message containing ellapsed time as a string.\n\n        When true, do_reset will result in a reset of start time.\n\n        \"\"\"\n        result = \"%s (%s s)\" % (msg, time.time() - self.start)\n        if do_reset:\n            self.start = time.time()\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef runtime(self):\n        t = time.time() - self.start\n        self.start = time.time()\n        return t", "response": "Return ellapsed time and reset start."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sync_one(self, aws_syncr, amazon, gateway):\n        gateway_info = amazon.apigateway.gateway_info(gateway.name, gateway.location)\n        if not gateway_info:\n            amazon.apigateway.create_gateway(gateway.name, gateway.location, gateway.stages, gateway.resources, gateway.api_keys, gateway.domain_names)\n        else:\n            amazon.apigateway.modify_gateway(gateway_info, gateway.name, gateway.location, gateway.stages, gateway.resources, gateway.api_keys, gateway.domain_names)", "response": "Make sure this gateway exists and has only attributes we want it to have"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef includeme(configurator):\n    settings = configurator.registry.settings\n\n    # lets default it to running path\n    yaml_locations = settings.get('yaml.location',\n                                  settings.get('yml.location', os.getcwd()))\n\n    configurator.add_directive('config_defaults', config_defaults)\n\n    configurator.config_defaults(yaml_locations)\n\n    # reading yml configuration\n\n    if configurator.registry['config']:\n        config = configurator.registry['config']\n        log.debug('Yaml config created')\n\n        # extend settings object\n        if 'configurator' in config and config.configurator:\n            _extend_settings(settings, config.configurator)\n\n        # run include's\n        if 'include' in config:\n            _run_includemes(configurator, config.include)\n\n    # let's calla a convenience request method\n    configurator.add_request_method(\n        lambda request: request.registry['config'],\n        name='config', property=True\n    )", "response": "Add yaml configuration utilities."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef config_defaults(\n        configurator, config_locations, files=None):\n    \"\"\"\n    Read and extends/creates configuration from yaml source.\n\n    .. note::\n        If exists, this method extends config with defaults,\n        so it will not override existing values, merely add those,\n        that were not defined already!\n\n    :param pyramid.config.Configurator configurator: pyramid's app configurator\n    :param list config_locations: list of yaml file locations\n    :param list files: list of files to include from location\n    \"\"\"\n    if files is None:\n        files = ['config.yaml', 'config.yml']\n    if not isinstance(config_locations, (list, tuple)):\n        config_locations = config_locations.split(',')\n\n    env = configurator.registry.settings.get('env', 'dev')\n\n    file_paths = []\n    for location in config_locations:\n        path = _translate_config_path(location)\n        current_files = files\n        if os.path.isfile(path):\n            path, current_files = os.path.split(path)\n            current_files = [current_files]\n\n        for config_path in [\n                os.path.join(path, f)\n                for f in _env_filenames(current_files, env)\n        ]:\n            if os.path.isfile(config_path):\n                file_paths.append(config_path)\n\n    config = ConfigManager(files=file_paths)\n\n    # we could use this method both for creating and extending.\n    # Hence the checks to not override\n    if 'config' not in configurator.registry:\n        configurator.registry['config'] = config\n    else:\n        config.merge(configurator.registry['config'])\n        configurator.registry['config'] = config", "response": "Read and extends config with defaults from yaml source."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntranslate location into full path according asset specification.", "response": "def _translate_config_path(location):\n    \"\"\"\n    Translate location into fullpath according asset specification.\n\n    Might be package:path for package related paths, or simply path\n\n    :param str location: resource location\n    :returns: fullpath\n\n    :rtype: str\n    \"\"\"\n    # getting spec path\n    package_name, filename = resolve_asset_spec(location.strip())\n    if not package_name:\n        path = filename\n    else:\n        package = __import__(package_name)\n        path = os.path.join(package_path(package), filename)\n\n    return path"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _env_filenames(filenames, env):\n    env_filenames = []\n    for filename in filenames:\n        filename_parts = filename.split('.')\n        filename_parts.insert(1, env)\n        env_filenames.extend([filename, '.'.join(filename_parts)])\n\n    return env_filenames", "response": "Extend filenames with ennv indication of environments."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nextending settings dictionary with content of yaml s configurator key.", "response": "def _extend_settings(settings, configurator_config, prefix=None):\n    \"\"\"\n    Extend settings dictionary with content of yaml's  configurator key.\n\n    .. note::\n\n        This methods changes multilayered subkeys defined\n        within **configurator** into dotted keys in settings dictionary:\n\n        .. code-block:: yaml\n\n            configurator:\n                sqlalchemy:\n                    url: mysql://user:password@host/dbname\n\n        will result in **sqlalchemy.url**: mysql://user:password@host/dbname\n        key value in settings dictionary.\n\n    :param dict settings: settings dictionary\n    :param dict configurator_config: yml defined settings\n    :param str prefix: prefix for settings dict key\n    \"\"\"\n    for key in configurator_config:\n        settings_key = '.'.join([prefix, key]) if prefix else key\n\n        if hasattr(configurator_config[key], 'keys') and\\\n                hasattr(configurator_config[key], '__getitem__'):\n            _extend_settings(\n                settings, configurator_config[key], prefix=settings_key\n            )\n        else:\n            settings[settings_key] = configurator_config[key]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _run_includemes(configurator, includemes):\n    for include in includemes:\n        if includemes[include]:\n            try:\n                configurator.include(include, includemes[include])\n            except AttributeError:\n                configurator.include(include)", "response": "Run includemes on the base base."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_instance(uri):\n    global _instances\n    try:\n        instance = _instances[uri]\n    except KeyError:\n        instance = Page(\n            uri,\n            client.get_instance()\n        )\n        _instances[uri] = instance\n\n    return instance", "response": "Return an instance of Page."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch(self):\n        self.content = self.client.get_content(\n            uri=self.uri\n        )\n        self.hash = hashlib.sha256(\n            self.content\n        ).hexdigest()", "response": "Fetch Page. content from client."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload image from file.", "response": "def load_image(self, loc, title, group):\n        '''\n        Used internally when loading images. You should probably use \n        load_objects().\n        '''\n        self.images.setdefault(group, {})\n        self.images[group][title] = pygame.image.load(loc).convert_alpha()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads a music file into the cache.", "response": "def load_music(self, loc, title, group):\n        '''\n        Used internally when loading music. You should probably use \n        load_objects().\n        '''\n        self.music.setdefault(group, {})\n        self.music[group][title] = loc"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_playlist(self, loc, title):\n        '''\n        Used internally when loading playlists. You should probably use \n        load_objects().\n        '''\n        lines = [l.strip() for l in open(loc).readlines()]\n        self.playlists.setdefault(title, [])\n        self.playlists[title].append(Playlist(lines, True))", "response": "Load a playlist from a file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload a sound from the local cache.", "response": "def load_sound(self, loc, title, group):\n        '''\n        Used internally when loading sounds. You should probably use \n        load_objects().\n        '''\n        self.sounds.setdefault(group, {})\n        self.sounds[group][title] = Sound(loc, self)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_code(self, path, package, callwith):\n        '''\n        Used internally when loading code. You should probably use \n        load_objects().\n        '''\n        sys.path = [path] + sys.path\n        g_o = importlib.import_module(package).get_objects\n        del sys.path[0]\n        for obj in g_o(callwith):\n            self.code[obj.title.lower()] = obj", "response": "Load code from a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_objects(self, dirs=[], callwith={}):\n        '''\n        Call this to load resources from each dir in @dirs. Code resources will \n        receive @callwith as an argument.\n        '''\n        for d in dirs:\n            contents = ls(d)\n            for t in contents:\n                first = join(d, t)\n                if t.startswith('.') or os.path.isfile(first):\n                    continue\n                t_l = t.lower()\n                for fl in ls(first):\n                    full = join(first, fl)\n                    if fl.startswith('.') or os.path.isdir(full):\n                        continue\n                    fl_n = fl.lower().rsplit('.', 1)[0]\n                    ty = guess_type(full)\n                    if ty == T_IMAGE:\n                        self.load_image(full, fl_n, t)\n                    elif ty == T_SOUND:\n                        self.load_sound(full, fl_n, t)\n                    elif ty == T_MUSIC:\n                        self.load_music(full, fl_n, t)\n                    elif ty == T_CODE and fl_n == '__init__':\n                        self.load_code(d, t, callwith)\n                    elif ty == T_PLAYLIST:\n                        self.load_playlist(full, fl_n)", "response": "Load resources from each directory in dirs."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the music from the given plylst.", "response": "def set_music(self, plylst, force=False):\n        '''\n        Use to set the playlist to @plylst. If @force is False, the playlist \n        will not be set if it is @plylst already.\n        '''\n        plylst = plylst.lower()\n        if plylst != self.cur_playlist or force:\n            self.cur_playlist = plylst\n            self.play_song(self.get_playlist().begin())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the music volume.", "response": "def set_m_vol(self, vol=None, relative=False):\n        '''\n        Set the music volume. If @vol != None, It will be changed to it (or by \n        it, if @relative is True.)\n        '''\n        if vol != None:\n            if relative:\n                vol += self.m_vol\n            self.m_vol = min(max(vol, 0), 1)\n        pygame.mixer.music.set_volume(self.m_vol)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the volume of all sounds.", "response": "def set_s_vol(self, vol=None, relative=False):\n        '''\n        Set the volume of all sounds. If @vol != None, It will be changed to \n        it (or by it, if @relative is True.)\n        '''\n        if vol != None:\n            if relative:\n                vol += self.s_vol\n            self.s_vol = min(max(vol, 0), 1)\n        for sgroup in self.sounds.values():\n            for snd in sgroup.values():\n                snd.set_volume()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve sound from group and title.", "response": "def get_sound(self, title, group):\n        '''\n        Retrieve sound @title from group @group.\n        '''\n        return self.sounds[group.lower()][title.lower()]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_image(self, title, group):\n        '''\n        Retrieve image @title from group @group.\n        '''\n        return self.images[group.lower()][title.lower()]", "response": "Retrieve image from group."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nuse internally when playing sounds.", "response": "def get_channel(self):\n        '''\n        Used internally when playing sounds.\n        '''\n        c = pygame.mixer.find_channel(not self.dynamic)\n        while c is None:\n            self.channels += 1\n            pygame.mixer.set_num_channels(self.channels)\n            c = pygame.mixer.find_channel()\n        return c"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bind(self, func, etype):\n        '''\n        Register @func for execution when events with `.type` of @etype \n        or meta-events with `.utype` of @etype are handled. @func will be \n        called with self, self.gstate, and the event as arguments.\n        '''\n        self.event_funcs.setdefault(etype, [])\n        # Don't add multiple times!\n        if func not in self.event_funcs[etype]:\n            self.event_funcs[etype].append(func)", "response": "Register a function to be called when a specific event is received."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nunbinding a function from the execution list for the specified type.", "response": "def unbind(self, func, etype):\n        '''\n        Remove @func from the execution list for events with `.type` of @etype \n        or meta-events with `.utype` of @etype. If @func is not in said list, \n        a ValueError will be raised.\n        '''\n        i= self.event_funcs[etype].index(func)\n        del self.event_funcs[etype][i]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef event(self, utype, **kw):\n        '''\n        Make a meta-event with a utype of @type. **@kw works the same as for \n        pygame.event.Event().\n        '''\n        d = {'utype': utype}\n        d.update(kw)\n        pygame.event.post(pygame.event.Event(METAEVENT, d))", "response": "Make a meta - event with a utype of @type. ** @kw works the same as for \n       ."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_states(self, *states):\n        '''\n        Add @states.\n        '''\n        for state in states:\n            self.states[state] = EventManagerPlus(self)", "response": "Add states to the internal state manager."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reactToAMQPMessage(message, send_back):\n    if _instanceof(message, structures.AddUser):\n        api.add_user(\n            username=message.username,\n            password=message.password\n        )\n        return True\n    elif _instanceof(message, structures.RemoveUser):\n        api.remove_user(message.username)\n        return True\n    elif _instanceof(message, structures.ChangePassword):\n        api.change_password(\n            username=message.username,\n            new_password=message.new_password\n        )\n        return True\n    elif _instanceof(message, structures.ListRegisteredUsers):\n        return structures.Userlist(api.list_users())\n    elif _instanceof(message, structures.SetUserSettings):\n        username = message.username\n\n        # convert namedtuple to dict (python rocks)\n        conf_dict = dict(message._asdict())\n        del conf_dict[\"username\"]\n\n        passwd_reader.save_user_config(\n            username,\n            conf_dict\n        )\n\n        conf_dict = passwd_reader.read_user_config(username)\n        conf_dict[\"username\"] = username\n        return structures.UserSettings(**conf_dict)\n    elif _instanceof(message, structures.GetUserSettings):\n        conf_dict = passwd_reader.read_user_config(message.username)\n        conf_dict[\"username\"] = message.username\n        return structures.UserSettings(**conf_dict)\n\n    raise ValueError(\n        \"Unknown type of request: '\" + str(type(message)) + \"'!\"\n    )", "response": "React to given AMQP message."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef accumulate(a_generator, cooperator=None):\n    if cooperator:\n        own_cooperate = cooperator.cooperate\n    else:\n        own_cooperate = cooperate\n\n    spigot = ValueBucket()\n    items = stream_tap((spigot,), a_generator)\n    d = own_cooperate(items).whenDone()\n    d.addCallback(accumulation_handler, spigot)\n    return d", "response": "A generator function that returns a Deferred that will be called with the yielded values yielded from a_generator."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef batch_accumulate(max_batch_size, a_generator, cooperator=None):\n    if cooperator:\n        own_cooperate = cooperator.cooperate\n    else:\n        own_cooperate = cooperate\n\n    spigot = ValueBucket()\n    items = stream_tap((spigot,), a_generator)\n\n    d = own_cooperate(i_batch(max_batch_size, items)).whenDone()\n    d.addCallback(accumulation_handler, spigot)\n    return d", "response": "A generator that yields a set of values from a_generator and accumulates them over a_batch_size batches."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_connection():\n    # REDIS_URL is defined in .env and loaded into the environment by Honcho\n    redis_url = os.getenv('REDIS_URL')\n    # If it's not defined, use the Redis default\n    if not redis_url:\n        redis_url = 'redis://localhost:6379'\n    urlparse.uses_netloc.append('redis')\n    url = urlparse.urlparse(redis_url)\n    return redis.StrictRedis(\n        host=url.hostname,\n        port=url.port,\n        db=0,\n        password=url.password\n    )", "response": "Return a redis. Redis instance connected to REDIS_URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef work():\n    with rq.Connection(create_connection()):\n        worker = rq.Worker(list(map(rq.Queue, listen)))\n        worker.work()", "response": "Start an rq worker on the connection provided by create_connection."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a list of all the shuffles for the current metasong and the current index.", "response": "def _gen_shuffles(self):\n        '''\n        Used internally to build a list for mapping between a random number and \n        a song index.\n        '''\n        # The current metasong index \n        si = 0\n        # The shuffle mapper list\n        self.shuffles = []\n        # Go through all our songs...\n        for song in self.loop:\n            # And add them to the list as many times as they say to.\n            for i in range(song[1]):\n                self.shuffles.append(si)\n            si += 1"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _new_song(self):\n        '''\n        Used internally to get a metasong index.\n        '''\n        # We'll need this later\n        s = self.song\n        \n        if self.shuffle:\n            # If shuffle is on, we need to (1) get a random song that \n            # (2) accounts for weighting. This line does both.\n            self.song = self.shuffles[random.randrange(len(self.shuffles))]\n        else:\n            # Nice and easy, just get the next song...\n            self.song += 1\n            # But wait! need to make sure it exists!\n            if self.song >= len(self.loop):\n                # It doesn't, so start over at the beginning.\n                self.song = 0\n        # Set flag if we have the same song as we had before.\n        self.dif_song = s != self.song\n        # Reset the position within the metasong\n        self.pos = 0", "response": "Used internally to get a new song."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_selectable(self):\n        '''\n        Used internally to get a group of choosable tracks.\n        '''\n        # Save some typing\n        cursong = self.loop[self.song][0]\n        \n        if self.dif_song and len(cursong) > 1:\n            # Position is relative to the intro of the track,\n            # so we we will get the both the intro and body.\n            s = cursong[0] + cursong[1]\n        else:\n            # Position is relative to the body of the track, so just get that.\n            s = cursong[-1]\n        # Return what we found\n        return s", "response": "Used internally to get a group of choosable tracks."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_song(self):\n        '''\n        Used internally to get the current track and make sure it exists.\n        '''\n        # Try to get the current track from the start metasong\n        if self.at_beginning:\n            # Make sure it exists.\n            if self.pos < len(self.start):\n                # It exists, so return it.\n                return self.start[self.pos]\n            # It doesn't exist, so let's move on!\n            self.at_beginning = False\n            # Generate a new track selection\n            self._new_track()\n        # A bit more difficult than using the start metasong, \n        # because we could have a beginning part. Call a function that gets all \n        # applicable tracks from the metasong.\n        s = self._get_selectable()\n        # Make sure it is long enough\n        while self.pos >= len(s):\n            # Or pick a new metasong.\n            self._new_song()\n            # And repeat.\n            s = self._get_selectable()\n        # Found a track, return it.\n        return s[self.pos]", "response": "Get the current track from the selectable and return it."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstarts over and get a track.", "response": "def begin(self):\n        '''\n        Start over and get a track.\n        '''\n        # Check for a start metasong\n        if self.start:\n            # We are in the beginning song\n            self.at_beginning = True\n            # And on the first track.\n            self.pos = 0\n        else:\n            # We aren't in the beginning song\n            self.at_beginning = False\n            # So we need to get new one.\n            self._new_song()\n        return self._get_song()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitializes the database connection pool.", "response": "def _applicationStart(self, data):\n        \"\"\"\n        Initializes the database connection pool.\n\n        :param data: <object> event data object\n        :return: <void>\n        \"\"\"\n        checkup = False\n        if \"viper.mysql\" in self.application.config \\\n                and isinstance(self.application.config[\"viper.mysql\"], dict):\n            if \"host\" in self.application.config[\"viper.mysql\"] and \\\n                    \"port\" in self.application.config[\"viper.mysql\"] and \\\n                    \"name\" in self.application.config[\"viper.mysql\"]:\n                if len(self.application.config[\"viper.mysql\"][\"host\"]) > 0 and \\\n                        self.application.config[\"viper.mysql\"][\"port\"] > 0 and \\\n                        len(self.application.config[\"viper.mysql\"][\"name\"]) > 0:\n                    checkup = True\n\n        if checkup is not True:\n            return\n\n        try:\n            self._connectionPool = adbapi.ConnectionPool(\n                \"MySQLdb\",\n                host=self.application.config[\"viper.mysql\"][\"host\"],\n                port=int(self.application.config[\"viper.mysql\"][\"port\"]),\n\n                user=self.application.config[\"viper.mysql\"][\"username\"],\n                passwd=self.application.config[\"viper.mysql\"][\"password\"],\n\n                db=self.application.config[\"viper.mysql\"][\"name\"],\n                charset=self.application.config[\"viper.mysql\"][\"charset\"],\n\n                cp_min=int(\n                    self.application.config[\"viper.mysql\"][\"connectionsMinimum\"]\n                ),\n                cp_max=int(\n                    self.application.config[\"viper.mysql\"][\"connectionsMaximum\"]\n                ),\n                cp_reconnect=True\n            )\n        except Exception as e:\n            self.log.error(\n                \"[Viper.MySQL] Cannot connect to server. Error: {error}\",\n                error=str(e)\n            )\n\n        if \"init\" in self.application.config[\"viper.mysql\"] \\\n                and self.application.config[\"viper.mysql\"][\"init\"][\"runIfEmpty\"]:\n            self._checkIfDatabaseIsEmpty(\n                lambda isEmpty:\n                    self._scheduleDatabaseInit(isEmpty)\n                ,\n                lambda error:\n                    self.log.error(\"[Viper.MySQL] Cannot check if database is empty. Error {error}\", error=error)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if database contains any tables.", "response": "def _checkIfDatabaseIsEmpty(self, successHandler=None, failHandler=None):\n        \"\"\"\n        Check if database contains any tables.\n\n        :param successHandler: <function(<bool>)> method called if interrogation was successful where the first argument\n                                is a boolean flag specifying if the database is empty or not\n        :param failHandler: <function(<str>)> method called if interrogation failed where the first argument is the\n                                error message\n        :return: <void>\n        \"\"\"\n        def failCallback(error):\n            errorMessage = str(error)\n            if isinstance(error, Failure):\n                errorMessage = error.getErrorMessage()\n\n            if failHandler is not None:\n                reactor.callInThread(failHandler, errorMessage)\n\n        def selectCallback(transaction, successHandler):\n            querySelect = \\\n                \"SELECT `TABLE_NAME` \" \\\n                \"FROM INFORMATION_SCHEMA.TABLES \" \\\n                \"WHERE \" \\\n                \"`TABLE_SCHEMA` = %s\" \\\n                \";\"\n\n            try:\n                transaction.execute(\n                    querySelect,\n                    (self.application.config[\"viper.mysql\"][\"name\"],)\n                )\n\n                tables = transaction.fetchall()\n            except Exception as e:\n                failCallback(e)\n                return\n\n            if successHandler is not None:\n                reactor.callInThread(successHandler, len(tables) == 0)\n\n        interaction = self.runInteraction(selectCallback, successHandler)\n        interaction.addErrback(failCallback)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _initDatabase(self):\n        queries = []\n\n        if len(self.application.config[\"viper.mysql\"][\"init\"][\"scripts\"]) > 0:\n            for scriptFilePath in self.application.config[\"viper.mysql\"][\"init\"][\"scripts\"]:\n                sqlFile = open(scriptFilePath, \"r\")\n                queriesInFile = self.extractFromSQLFile(sqlFile)\n                sqlFile.close()\n\n                queries.extend(queriesInFile)\n\n        def failCallback(error):\n            errorMessage = str(error)\n            if isinstance(error, Failure):\n                errorMessage = error.getErrorMessage()\n\n            self.log.error(\n                \"[Viper.MySQL] _initDatabase() database error: {errorMessage}\",\n                errorMessage=errorMessage\n            )\n\n        def runCallback(transaction, queries):\n            try:\n                for query in queries:\n                    transaction.execute(query)\n            except Exception as e:\n                failCallback(e)\n                return\n\n        interaction = self.runInteraction(runCallback, queries)\n        interaction.addErrback(failCallback)", "response": "Initializes the database structure based on application configuration."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprocessing an SQL file and extract all the queries sorted. :param filePointer: <io.TextIOWrapper> file pointer to SQL file :return: <list> list of queries", "response": "def extractFromSQLFile(self, filePointer, delimiter=\";\"):\n        \"\"\"\n        Process an SQL file and extract all the queries sorted.\n\n        :param filePointer: <io.TextIOWrapper> file pointer to SQL file\n        :return: <list> list of queries\n        \"\"\"\n        data = filePointer.read()\n\n        # reading file and splitting it into lines\n        dataLines = []\n        dataLinesIndex = 0\n        for c in data:\n            if len(dataLines) - 1 < dataLinesIndex:\n                dataLines.append(\"\")\n\n            if c == \"\\r\\n\" or c == \"\\r\" or c == \"\\n\":\n                dataLinesIndex += 1\n            else:\n                dataLines[dataLinesIndex] = \"{}{}\".format(\n                    dataLines[dataLinesIndex],\n                    c\n                )\n\n        # forming SQL statements from all lines provided\n        statements = []\n        statementsIndex = 0\n        for line in dataLines:\n            # ignoring comments\n            if line.startswith(\"--\") or line.startswith(\"#\"):\n                continue\n\n            # removing spaces\n            line = line.strip()\n\n            # ignoring blank lines\n            if len(line) == 0:\n                continue\n\n            # appending each character to it's statement until delimiter is reached\n            for c in line:\n                if len(statements) - 1 < statementsIndex:\n                    statements.append(\"\")\n\n                statements[statementsIndex] = \"{}{}\".format(\n                    statements[statementsIndex],\n                    c\n                )\n\n                if c == delimiter:\n                    statementsIndex += 1\n\n        return statements"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef runInteraction(self, interaction, *args, **kwargs):\n        try:\n            return self._connectionPool.runInteraction(\n                interaction,\n                *args,\n                **kwargs\n            )\n        except:\n            d = defer.Deferred()\n            d.errback()\n            return d", "response": "Interact with the database and return the result."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef runQuery(self, *args, **kwargs):\n        try:\n            return self._connectionPool.runQuery(*args, **kwargs)\n        except:\n            d = defer.Deferred()\n            d.errback()\n            return d", "response": "Execute an SQL query and return the result."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconnect callback properties to Qt widgets automatically.", "response": "def autoconnect_callbacks_to_qt(instance, widget, connect_kwargs={}):\n    \"\"\"\n    Given a class instance with callback properties and a Qt widget/window,\n    connect callback properties to Qt widgets automatically.\n\n    The matching is done based on the objectName of the Qt widgets. Qt widgets\n    that need to be connected should be named using the syntax ``type_name``\n    where ``type`` describes the kind of matching to be done, and ``name``\n    matches the name of a callback property. By default, the types can be:\n\n    * ``value``: the callback property is linked to a Qt widget that has\n      ``value`` and ``setValue`` methods. Note that for this type, two\n      additional keyword arguments can be specified using ``connect_kwargs``\n      (see below): these are ``value_range``, which is used for cases where\n      the Qt widget is e.g. a slider which has a range of values, and you want\n      to map this range of values onto a different range for the callback\n      property, and the second is ``log``, which can be set to `True` if this\n      mapping should be done in log space.\n\n    * ``valuetext``: the callback property is linked to a Qt widget that has\n      ``text`` and ``setText`` methods, and the text is set to a string\n      representation of the value. Note that for this type, an additional\n      argument ``fmt`` can be provided, which gives either the format to use\n      using the ``{}`` syntax, or should be a function that takes a value\n      and returns a string. Optionally, if the Qt widget supports\n      the ``editingFinished`` signal, this signal is connected to the callback\n      property too.\n\n    * ``bool``: the callback property is linked to a Qt widget that has\n      ``isChecked`` and ``setChecked`` methods, such as a checkable button.\n\n    * ``text``: the callback property is linked to a Qt widget that has\n      ``text`` and ``setText`` methods. Optionally, if the Qt widget supports\n      the ``editingFinished`` signal, this signal is connected to the callback\n      property too.\n\n    * ``combodata``: the callback property is linked to a QComboBox based on\n      the ``userData`` of the entries in the combo box.\n\n    * ``combotext``: the callback property is linked to a QComboBox based on\n      the label of the entries in the combo box.\n\n    Applications can also define additional mappings between type and\n    auto-linking. To do this, simply add a new entry to the ``HANDLERS`` object::\n\n        >>> echo.qt.autoconnect import HANDLERS\n        >>> HANDLERS['color'] = connect_color\n\n    The handler function (``connect_color`` in the example above) should take\n    the following arguments: the instance the callback property is attached to,\n    the name of the callback property, the Qt widget, and optionally some\n    keyword arguments.\n\n    When calling ``autoconnect_callbacks_to_qt``, you can specify\n    ``connect_kwargs``, where each key should be a valid callback property name,\n    and which gives any additional keyword arguments that can be taken by the\n    connect functions, as described above. These include for example\n    ``value_range``, ``log``, and ``fmt``.\n\n    This function is especially useful when defining ui files, since widget\n    objectNames can be easily set during the editing process.\n    \"\"\"\n\n    if not hasattr(widget, 'children'):\n        return\n\n    for child in widget.findChildren(QtWidgets.QWidget):\n        full_name = child.objectName()\n        if '_' in full_name:\n            wtype, wname = full_name.split('_', 1)\n            if full_name in connect_kwargs:\n                kwargs = connect_kwargs[full_name]\n            elif wname in connect_kwargs:\n                kwargs = connect_kwargs[wname]\n            else:\n                kwargs = {}\n            if hasattr(instance, wname):\n                if wtype in HANDLERS:\n                    HANDLERS[wtype](instance, wname, child, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsolving a resource with a value.", "response": "def solve(self, value, resource):\n        \"\"\"Solve a resource with a value.\n\n        Arguments\n        ---------\n        value : ?\n            A value to solve in combination with the given resource. The first filter of the\n            resource will be applied on this value (next filters on the result of the previous\n            filter).\n        resource : dataql.resources.Resource\n            An instance of a subclass of ``Resource`` to solve with the given value.\n\n        Returns\n        -------\n        (depends on the implementation of the ``coerce`` method)\n\n        Raises\n        ------\n        CannotSolve\n            If a solver accepts to solve a resource but cannot finally solve it.\n            Allows ``Registry.solve_resource`` to use the next available solver.\n\n        Notes\n        -----\n        This method simply calls ``solve_value``, then ``coerce`` with the result.\n        To change the behavior, simply override at least one of these two methods.\n\n        \"\"\"\n\n        result = self.solve_value(value, resource)\n        return self.coerce(result, resource)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsolving a resource with a value without coercing it.", "response": "def solve_value(self, value, resource):\n        \"\"\"Solve a resource with a value, without coercing.\n\n        Arguments\n        ---------\n        value : ?\n            A value to solve in combination with the given resource. The first filter of the\n            resource will be applied on this value (next filters on the result of the previous\n            filter).\n        resource : dataql.resources.Resource\n            An instance of a subclass of ``Resource`` to solve with the given value.\n\n        Returns\n        -------\n        The result of all filters applied on the value for the first filter, and result of the\n        previous filter for next filters.\n\n        Example\n        -------\n\n        >>> from dataql.solvers.registry import Registry\n        >>> registry = Registry()\n        >>> from datetime import date\n        >>> registry.register(date, allow_class=True)\n        >>> registry.register(str)\n        >>> class MySolver(Solver):\n        ...     def coerce(self, value, resource): return value\n        >>> solver = MySolver(registry)\n        >>> from dataql.resources import Filter, NamedArg, PosArg, SliceFilter\n        >>> field = Field(None,\n        ...     filters=[\n        ...         Filter(name='fromtimestamp', args=[PosArg(1433109600)]),\n        ...         Filter(name='replace', args=[NamedArg('year', '=', 2014)]),\n        ...         Filter(name='strftime', args=[PosArg('%F')]),\n        ...         Filter(name='replace', args=[PosArg('2014'), PosArg('2015')]),\n        ...     ]\n        ... )\n        >>> solver.solve_value(date, field)\n        '2015-06-01'\n        >>> solver.solve_value(None, field)\n\n        >>> d = {'foo': {'date': date(2015, 6, 1)}, 'bar': {'date': None}, 'baz': [{'date': None}]}\n        >>> registry.register(dict)\n        >>> solver.solve_value(d, Field(None, filters=[\n        ...     Filter(name='foo'),\n        ...     Filter(name='date'),\n        ...     Filter(name='strftime', args=[PosArg('%F')]),\n        ... ]))\n        '2015-06-01'\n        >>> solver.solve_value(d, Field(None, filters=[\n        ...     Filter(name='bar'),\n        ...     Filter(name='date'),\n        ...     Filter(name='strftime', args=[PosArg('%F')]),\n        ... ]))\n\n        >>> solver.solve_value(d, Field(None, filters=[\n        ...     Filter(name='baz'),\n        ...     SliceFilter(0),\n        ...     Filter(name='date'),\n        ...     Filter(name='strftime', args=[PosArg('%F')]),\n        ... ]))\n\n        # Example of how to raise a ``CannotSolve`` exception.\n        >>> from dataql.solvers.exceptions import CannotSolve\n        >>> raise CannotSolve(solver, Field('fromtimestamp'), date)  # doctest: +ELLIPSIS\n        Traceback (most recent call last):\n        dataql...CannotSolve: Solver `<MySolver>` was not able to solve...`<Field[fromtimestamp]>`.\n\n        \"\"\"\n\n        # The given value is the starting point on which we apply the first filter.\n        result = value\n\n        # Apply filters one by one on the previous result.\n        if result is not None:\n            for filter_ in resource.filters:\n                result = self.registry.solve_filter(result, filter_)\n                if result is None:\n                    break\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntell if the current solver class can resolve the given resource.", "response": "def can_solve(cls, resource):\n        \"\"\"Tells if the solver is able to resolve the given resource.\n\n        Arguments\n        ---------\n        resource : subclass of ``dataql.resources.Resource``\n            The resource to check if it is solvable by the current solver class\n\n        Returns\n        -------\n        boolean\n            ``True`` if the current solver class can solve the given resource, ``False`` otherwise.\n\n        Example\n        -------\n\n        >>> AttributeSolver.solvable_resources\n        (<class 'dataql.resources.Field'>,)\n        >>> AttributeSolver.can_solve(Field('foo'))\n        True\n        >>> AttributeSolver.can_solve(Object('bar'))\n        False\n\n        \"\"\"\n\n        for solvable_resource in cls.solvable_resources:\n            if isinstance(resource, solvable_resource):\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncoerces the value to an acceptable one.", "response": "def coerce(self, value, resource):\n        \"\"\"Coerce the value to an acceptable one.\n\n        Only these kinds of values are returned as is:\n        - str\n        - int\n        - float\n        - True\n        - False\n        - None\n\n        For all others values, it will be coerced using ``self.coerce_default`` (with convert the\n        value to a string in the default implementation).\n\n        Arguments\n        ---------\n        value : ?\n            The value to be coerced.\n        resource : dataql.resources.Resource\n            The ``Resource`` object used to obtain this value from the original one.\n\n        Returns\n        -------\n        str | int | float | True | False | None\n            The coerced value.\n\n        Example\n        -------\n\n        >>> from dataql.solvers.registry import Registry\n        >>> registry = Registry()\n        >>> from datetime import date\n        >>> registry.register(date)\n        >>> solver = AttributeSolver(registry)\n        >>> solver.coerce('foo', None)\n        'foo'\n        >>> solver.coerce(11, None)\n        11\n        >>> solver.coerce(1.1, None)\n        1.1\n        >>> solver.coerce(True, None)\n        True\n        >>> solver.coerce(False, None)\n        False\n        >>> solver.coerce(date(2015, 6, 1), None)\n        '2015-06-01'\n        >>> solver.coerce(None, None)\n\n        \"\"\"\n        if value in (True, False, None):\n            return value\n        if isinstance(value, (int, float)):\n            return value\n        if isinstance(value, str):\n            return value\n        return self.coerce_default(value, resource)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef coerce(self, value, resource):\n\n        return {r.name: self.registry.solve_resource(value, r) for r in resource.resources}", "response": "Get a dict with attributes from value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef coerce(self, value, resource):\n\n        if not isinstance(value, Iterable):\n            raise NotIterable(resource, self.registry[value])\n\n        # Case #1: we only have one sub-resource, so we return a list with this item for\n        # each iteration\n        if len(resource.resources) == 1:\n            res = resource.resources[0]\n            return [self.registry.solve_resource(v, res) for v in value]\n\n        # Case #2: we have many sub-resources, we return a list with, for each iteration, a\n        # list with all entries\n        return [\n            [self.registry.solve_resource(v, res) for res in resource.resources]\n            for v in value\n        ]", "response": "Convert a list of objects in a list of dicts."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a pronunciation dictionary specific to a list of recordings", "response": "def create_recordings_dictionary(list_selected, pronunciation_dictionary_filename, out_dictionary_filename, htk_trace,\n                                 additional_dictionary_filenames=[]):\n    \"\"\"Create a pronunciation dictionary specific to a list of recordings\"\"\"\n    temp_words_fd, temp_words_file = tempfile.mkstemp()\n\n    words = set()\n    for recording in list_selected:\n        words |= set([w.upper() for w in get_words_from_recording(recording)])\n\n    with codecs.open(temp_words_file, 'w', 'utf-8') as f:\n        f.writelines([u'{}\\n'.format(w) for w in sorted(list(words))])\n\n    prepare_dictionary(temp_words_file,\n                       pronunciation_dictionary_filename,\n                       out_dictionary_filename,\n                       htk_trace,\n                       global_script_filename=config.project_path('etc/global.ded'),\n                       additional_dictionary_filenames=additional_dictionary_filenames)\n\n    os.remove(temp_words_file)\n\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nnormalizing UTF - 8 characters of a file in a dictionary file.", "response": "def utf8_normalize(input_filename, comment_char='#', to_upper=False):\n    \"\"\"Normalize UTF-8 characters of a file\n    \"\"\"\n    # Prepare the input dictionary file in UTF-8 and NFC\n    temp_dict_fd, output_filename = tempfile.mkstemp()\n\n    logging.debug('to_nfc from file {} to file {}'.format(input_filename, output_filename))\n\n    with codecs.open(output_filename, 'w', 'utf-8') as f:\n        with codecs.open(input_filename, 'r', 'utf-8') as input_f:\n            lines = sorted([unicodedata.normalize(UTF8_NORMALIZATION, l)\n                            for l in input_f.readlines()\n                            if not l.strip().startswith(comment_char)])\n            if to_upper:\n                lines = [l.upper() for l in lines]\n\n            f.writelines(lines)\n\n    return output_filename"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_instance_count(instance_count, speaker_total_count):\n\n    # Use all the instances of a speaker unless specified\n    result = copy.copy(speaker_total_count)\n    for speaker_id, count in instance_count.items():\n        speaker_id = str(speaker_id)\n        speaker_total = speaker_total_count.get(speaker_id, 0)\n\n        if type(count) == float and 0.0 <= count <= 1.0:\n            result[speaker_id] = int(speaker_total * count)\n\n        else:\n            result[speaker_id] = int(count)\n\n    return result", "response": "This parses the instance count dictionary and converts it to actual instance count."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a flat start model for the given list of states.", "response": "def create_flat_start_model(feature_filename,\n                            state_stay_probabilities,\n                            symbol_list,\n                            output_model_directory,\n                            output_prototype_filename,\n                            htk_trace):\n    \"\"\"\n    Creates a flat start model by using HCompV to compute the global mean and variance.\n    Then uses these global mean and variance to create an N-state model for each symbol in the given list.\n\n    :param feature_filename: The filename containing the audio and feature file pairs\n    :param output_model_directory: The directory where to write the created model\n    :param output_prototype_filename: The prototype model filename\n    :param htk_trace: Trace level for HTK\n    :rtype : None\n    \"\"\"\n    # Create a prototype model\n    create_prototype_model(feature_filename,\n                           output_prototype_filename,\n                           state_stay_probabilities=state_stay_probabilities)\n\n    # Compute the global mean and variance\n    config.htk_command(\"HCompV -A -D -T {} -f 0.01 \"\n                       \"-S {} -m -o {} -M {} {}\".format(htk_trace,\n                                                        feature_filename,\n                                                        'proto',\n                                                        output_model_directory,\n                                                        output_prototype_filename))\n\n    # Create an hmmdefs using the global mean and variance for all states and symbols\n    # Duplicate the model 'proto' -> symbol_list\n    proto_model_filename = config.path(output_model_directory, 'proto')\n    model = htk.load_model(proto_model_filename)\n    model = htk_model_utils.map_hmms(model, {'proto': symbol_list})\n\n    # vFloors -> macros\n    vfloors_filename = config.path(output_model_directory, 'vFloors')\n    variance_model = htk.load_model(vfloors_filename)\n\n    model['macros'] += variance_model['macros']\n\n    macros, hmmdefs = htk_model_utils.split_model(model)\n\n    htk.save_model(macros, config.path(output_model_directory, 'macros'))\n    htk.save_model(hmmdefs, config.path(output_model_directory, 'hmmdefs'))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nperforms recognition using a model and assuming a single word language. If the list_words_filename is == '' then all the words in the dictionary are used as language words.", "response": "def recognise_model(feature_filename,\n                    symbollist_filename,\n                    model_directory,\n                    recognition_filename,\n                    pronunciation_dictionary_filename,\n                    list_words_filename='',\n                    cmllr_directory=None,\n                    tokens_count=None,\n                    hypotheses_count=1,\n                    htk_trace=0):\n    \"\"\"\n        Perform recognition using a model and assuming a single word language.\n\n        If the list_words_filename is == '' then all the words in the dictionary are used as language words.\n    \"\"\"\n    # Normalize UTF-8 to avoid Mac problems\n    temp_dictionary_filename = utf8_normalize(pronunciation_dictionary_filename)\n\n    # Create language word list\n    if list_words_filename:\n        list_words = parse_wordlist(list_words_filename)\n    else:\n        list_words = sorted(parse_dictionary(temp_dictionary_filename).keys())\n\n    # Create language model\n    temp_directory = config.project_path('tmp', create=True)\n    grammar_filename = config.path(temp_directory, 'grammar_words')\n    wdnet_filename = config.path(temp_directory, 'wdnet')\n    logging.debug('Create language model')\n    create_language_model(list_words,\n                          grammar_filename,\n                          wdnet_filename)\n\n    # Handle the Adaptation parameters\n    cmllr_arguments = ''\n    if cmllr_directory:\n        if not os.path.isdir(cmllr_directory):\n            logging.error('CMLLR adapatation directory not found: {}'.format(cmllr_directory))\n\n        cmllr_arguments = \"-J {} mllr2 -h '*/*_s%.mfc' -k -J {}\".format(\n            os.path.abspath(config.path(cmllr_directory, 'xforms')),\n            os.path.abspath(config.path(cmllr_directory, 'classes')))\n    # Handle the N-Best parameters\n    hypotheses_count = hypotheses_count or 1\n    tokens_count = tokens_count or int(math.ceil(hypotheses_count / 5.0))\n    if hypotheses_count == 1 and tokens_count == 1:\n        nbest_arguments = \"\"\n    else:\n        nbest_arguments = \"-n {tokens_count} {hypotheses_count} \".format(tokens_count=tokens_count,\n                                                                         hypotheses_count=hypotheses_count)\n\n    # Run the HTK command\n    config.htk_command(\"HVite -A -l '*' -T {htk_trace} \"\n                       \"-H {model_directory}/macros -H {model_directory}/hmmdefs \"\n                       \"-i {recognition_filename} -S {feature_filename} \"\n                       \"{cmllr_arguments} -w {wdnet_filename} \"\n                       \"{nbest_arguments} \"\n                       \"-p 0.0 -s 5.0 \"\n                       \"{pronunciation_dictionary_filename} \"\n                       \"{symbollist_filename}\".format(htk_trace=htk_trace,\n                                                      model_directory=model_directory,\n                                                      recognition_filename=recognition_filename,\n                                                      feature_filename=feature_filename,\n                                                      symbollist_filename=symbollist_filename,\n                                                      nbest_arguments=nbest_arguments,\n                                                      pronunciation_dictionary_filename=temp_dictionary_filename,\n                                                      wdnet_filename=wdnet_filename,\n                                                      cmllr_arguments=cmllr_arguments))\n\n    # Remove temporary files\n    os.remove(temp_dictionary_filename)\n    os.remove(wdnet_filename)\n    os.remove(grammar_filename)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a language model for HTK using a very simple single - word grammar", "response": "def create_language_model(list_words,\n                          grammar_filename,\n                          wdnet_filename):\n    \"\"\"Create a language model (wdnet) for HTK using a very simple single-word grammar\"\"\"\n\n    # Create the temporary grammar file\n    grammar = u''\n    grammar += u'$possible_words = '\n    grammar += u' | '.join([word for word in list_words])\n    grammar += u';\\n'\n\n    grammar += u'( [SENT-START] ( $possible_words ) [SENT-END] )\\n'\n\n    with codecs.open(grammar_filename, 'w', 'utf-8') as f:\n        f.write(grammar)\n\n    # Use HParse to create the wdnet file\n    config.htk_command('HParse -A {} {}'.format(grammar_filename, wdnet_filename))\n\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct the psycopg2 connection instance and register the hstore", "response": "def connect(self):\n        \"\"\" Construct the psycopg2 connection instance\n\n        :return: psycopg2.connect instance\n        \"\"\"\n\n        if self._conn:\n            return self._conn\n\n        self._conn = psycopg2.connect(\n            self.config,\n            cursor_factory=psycopg2.extras.RealDictCursor,\n        )\n\n        self._conn.set_session(autocommit=True)\n        psycopg2.extras.register_hstore(self._conn)\n\n        return self._conn"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef initializerepo(self):\n\n        try:\n            os.mkdir(self.repopath)\n        except OSError:\n            pass\n\n        cmd = self.repo.init(bare=self.bare, shared=self.shared)\n\n        if not self.bare:\n            self.write_testing_data([], [])\n            self.write_training_data([], [])\n            self.write_classifier(None)\n\n            cmd = self.repo.add('training.pkl')\n            cmd = self.repo.add('testing.pkl')\n            cmd = self.repo.add('classifier.pkl')\n\n            cmd = self.repo.commit(m='initial commit')\n            cmd = self.repo.tag('initial')\n            cmd = self.set_version('initial')", "response": "Initialize the repository with the initial version."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking whether contents of repo are consistent with standard set.", "response": "def isvalid(self):\n        \"\"\" Checks whether contents of repo are consistent with standard set. \"\"\"\n\n        gcontents = [gf.rstrip('\\n') for gf in self.repo.bake('ls-files')()]\n        fcontents = os.listdir(self.repopath)\n        return all([sf in gcontents for sf in std_files]) and all([sf in fcontents for sf in std_files])"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the version name for the current state of repo", "response": "def set_version(self, version, force=True):\n        \"\"\" Sets the version name for the current state of repo \"\"\"\n\n        if version in self.versions:\n            self._version = version\n            if 'working' in self.repo.branch().stdout:\n                if force:\n                    logger.info('Found working branch. Removing...')\n                    cmd = self.repo.checkout('master')\n                    cmd = self.repo.branch('working', d=True)                    \n                else:\n                    logger.info('Found working branch from previous session. Use force=True to remove it and start anew.')\n                    return\n\n            stdout = self.repo.checkout(version, b='working').stdout  # active version set in 'working' branch\n            logger.info('Version {0} set'.format(version))\n        else:\n            raise AttributeError('Version {0} not found'.format(version))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_version_info(self, version):\n\n        if version in self.versions:\n            stdout = self.repo.show(version, '--summary').stdout\n            logger.info(stdout)\n        else:\n            logger.info('Version {0} not found'.format(version))", "response": "Summarizes info of a particular version"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns data dictionary from training. pkl", "response": "def training_data(self):\n        \"\"\" Returns data dictionary from training.pkl \"\"\"\n\n        data = pickle.load(open(os.path.join(self.repopath, 'training.pkl')))\n        return data.keys(), data.values()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns classifier from classifier. pkl file", "response": "def classifier(self):\n        \"\"\" Returns classifier from classifier.pkl \"\"\"        \n\n        clf = pickle.load(open(os.path.join(self.repopath, 'classifier.pkl')))\n        return clf"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite training data to file", "response": "def write_training_data(self, features, targets):\n        \"\"\" Writes data dictionary to filename \"\"\"\n\n        assert len(features) == len(targets)\n\n        data = dict(zip(features, targets))\n\n        with open(os.path.join(self.repopath, 'training.pkl'), 'w') as fp:\n            pickle.dump(data, fp)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write_classifier(self, clf):\n\n        with open(os.path.join(self.repopath, 'classifier.pkl'), 'w') as fp:\n            pickle.dump(clf, fp)", "response": "Writes classifier object to pickle file"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncommits and push changes to the remote.", "response": "def commit_version(self, version, msg=None):\n        \"\"\" Add tag, commit, and push changes \"\"\"\n\n        assert version not in self.versions, 'Will not overwrite a version name.'\n\n        if not msg:\n            feat, targ = self.training_data\n            msg = 'Training set has {0} examples. '.format(len(feat))\n            feat, targ = self.testing_data\n            msg += 'Testing set has {0} examples.'.format(len(feat))\n\n        cmd = self.repo.commit(m=msg, a=True)\n        cmd = self.repo.tag(version)\n        cmd = self.repo.checkout('master')\n        self.update()\n        cmd = self.repo.merge('working')\n        cmd = self.repo.branch('working', d=True)\n        self.set_version(version)\n\n        try:\n            stdout = self.repo.push('origin', 'master', '--tags').stdout\n            logger.info(stdout)\n        except:\n            logger.info('Push not working. Remote not defined?')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the latest version of a local node.", "response": "def update(self):\n        \"\"\" Pull latest versions/tags, if linked to a remote (e.g., github). \"\"\"\n\n        try:\n            stdout = self.repo.pull().stdout\n            logger.info(stdout)\n        except:\n            logger.info('Pull not working. Remote not defined?')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_all_usb_devices(idVendor, idProduct):\n        all_dev = list(usb.core.find(find_all = True, idVendor = idVendor, idProduct = idProduct))\n        for dev in all_dev:\n            try:\n                dev.detach_kernel_driver(0)\n            except usb.USBError:\n                pass\n        return all_dev", "response": "Returns a list of all the usb devices matching the provided vendor ID and product ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_device_address(usb_device):\n        try:\n            usb_device.ctrl_transfer(0x21, 0x09, 0x0300, 0, GrizzlyUSB.COMMAND_GET_ADDR)\n            internal_addr = usb_device.ctrl_transfer(0xa1, 0x01, 0x0301, 0, 2)[1]\n            return internal_addr >> 1\n        except usb.USBError as e:\n            return GrizzlyUSB.USB_DEVICE_ERROR", "response": "Get the grizzly s internal address value."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef exchange_bytes(self, cmd):\n        assert len(cmd) == 16, \"Must send 16 bytes\"\n        self._dev.ctrl_transfer(0x21, 0x09, 0x0300, 0, cmd)\n        numBytes = ord(cmd[1]) & 0x7f\n        return self._dev.ctrl_transfer(0xa1, 0x01, 0x0301, 0, numBytes + 1)[1::]", "response": "Sends a packet to the grizzly requesting information. Reads back\n        the data requested."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nscanning for grizzlies that have not been bound or constructed and returns a list of their id s or motor number.", "response": "def get_all_ids(idVendor = GrizzlyUSB.ID_VENDOR, idProduct=GrizzlyUSB.ID_PRODUCT):\n        \"\"\" Scans for grizzlies that have not been bound, or constructed, and returns a list\n        of their id's, or motor number.\"\"\"\n        all_dev = GrizzlyUSB.get_all_usb_devices(idVendor, idProduct)\n            \n        if len(all_dev) <= 0:\n            raise usb.USBError(\"Could not find any GrizzlyBear device (idVendor=%d, idProduct=%d)\" % (idVendor, idProduct))\n        else:\n            all_addresses = []\n\n            # bound devices is a list of devices that are already busy.\n            bound_devices = []\n            for device in all_dev:\n                internal_addr = GrizzlyUSB.get_device_address(device)\n\n                if internal_addr == GrizzlyUSB.USB_DEVICE_ERROR: # device bound\n                    bound_devices.append(device)\n                else:\n                    all_addresses.append(internal_addr)\n\n            # we release all devices that we aren't using and aren't bound.\n            for device in all_dev:\n                if device not in bound_devices:\n                    usb.util.dispose_resources(device)\n            return map(addr_to_id, all_addresses)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_register(self, addr, data):\n        assert len(data) <= 14, \"Cannot write more than 14 bytes at a time\"\n        cmd = chr(addr) + chr(len(data) | 0x80)\n        for byte in data:\n            cmd += chr(cast_to_byte(byte))\n        cmd += (16 - len(cmd)) * chr(0)\n        self._dev.send_bytes(cmd)", "response": "This method writes an arbitrary register at addr and writes the specified data to the specified address."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_register(self, addr, numBytes):\n        assert numBytes <= 0x7f, \"Cannot read more than 127 bytes at a time\"\n        cmd = chr(addr) + chr(numBytes)\n        cmd += (16 - len(cmd)) * chr(0)\n        return self._dev.exchange_bytes(cmd)", "response": "Reads the specified number of bytes from the grizzly starting at addr."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _set_as_int(self, addr, val, numBytes = 1):\n        if not isinstance(val, int):\n            raise ValueError(\"val must be an int. You provided: %s\" % str(val))\n        buf = []\n        for i in range(numBytes):\n            buf.append(cast_to_byte(val >> 8 * i))\n        self.set_register(addr, buf)", "response": "Convenience method. Oftentimes we need to set a range of registers\n        to represent an int."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck the grizzly to see if the current time of the current node is less than orange. Useful to reinitialize acceleration or calendar current limiting.", "response": "def has_reset(self):\n        \"\"\"Checks the grizzly to see if it reset itself because of\n        voltage sag or other reasons. Useful to reinitialize acceleration or\n        current limiting.\"\"\"\n        currentTime = self._read_as_int(Addr.Uptime, 4)\n        if currentTime <= self._ticks:\n            self._ticks = currentTime\n            return True\n        self._ticks = currentTime\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef limit_acceleration(self, accel):\n        if accel >= 143:\n            raise ValueError(\"Acceleration limit cannot exceed 143. You provided: %s\" % str(accel))\n        if accel <= 0:\n            raise ValueError(\"Acceleration limit must be positive. You provided: %s\" % str(accel))\n        self._set_as_int(Addr.AccelLimit, accel)", "response": "Sets the acceleration limit on the Grizzly."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the current limit on the Grizzly. The units are in amps. The internal default value is 5 amps.", "response": "def limit_current(self, curr):\n        \"\"\"Sets the current limit on the Grizzly. The units are in amps. The\n        internal default value is 5 amps.\"\"\"\n        if curr <= 0:\n            raise ValueError(\"Current limit must be a positive number. You provided: %s\" % str(curr))\n        current = int(curr * (1024.0 / 5.0) * (66.0 / 1000.0))\n        self._set_as_int(Addr.CurrentLimit, current, 2)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the constants for the PID modes. Arguments are all floating point numbers.", "response": "def init_pid(self, kp, ki, kd):\n        \"\"\"Sets the PID constants for the PID modes. Arguments are all\n        floating point numbers.\"\"\"\n        p, i, d = map(lambda x: int(x * (2 ** 16)), (kp, ki, kd))\n        self._set_as_int(Addr.PConstant, p, 4)\n        self._set_as_int(Addr.IConstant, i, 4)\n        self._set_as_int(Addr.DConstant, d, 4)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_pid_constants(self):\n        p = self._read_as_int(Addr.PConstant, 4)\n        i = self._read_as_int(Addr.IConstant, 4)\n        d = self._read_as_int(Addr.DConstant, 4)\n        \n        return map(lambda x: x / (2 ** 16), (p, i, d))", "response": "Reads back the PID constants stored on the Grizzly system."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the folder the package is located in.", "response": "def getReposPackageFolder():\n\t\"\"\"Returns the folder the package is located in.\"\"\"\n\tlibdir = sysconfig.get_python_lib()\n\trepodir = os.path.join(libdir, \"calcrepo\", \"repos\")\n\treturn repodir"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef replaceNewlines(string, newlineChar):\n\tif newlineChar in string:\n\t\tsegments = string.split(newlineChar)\n\t\tstring = \"\"\n\t\tfor segment in segments:\n\t\t\tstring += segment\n\treturn string", "response": "Replace all instances of \\ r or \\ n in a string with something else."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getScriptLocation():\n\tlocation = os.path.abspath(\"./\")\n\tif __file__.rfind(\"/\") != -1:\n\t\tlocation = __file__[:__file__.rfind(\"/\")]\n\treturn location", "response": "Helper function to get the location of a Python file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_param(key, val):\n\n    regex = re.compile(r'fields\\[([A-Za-z]+)\\]')\n    match = regex.match(key)\n\n    if match:\n        if not isinstance(val, list):\n            val = val.split(',')\n\n        fields = [field.lower() for field in val]\n        rtype = match.groups()[0].lower()\n\n        return rtype, fields", "response": "Parse the key val pair in the request and return the type and fields of the sparse fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _validate_param(rtype, fields):\n\n    try:\n        # raises ValueError if not found\n        model = rtype_to_model(rtype)\n        model_fields = model.all_fields\n    except ValueError:\n        raise InvalidQueryParams(**{\n            'detail': 'The fields query param provided with a '\n                      'field type of \"%s\" is unknown.' % rtype,\n            'links': LINK,\n            'parameter': PARAM,\n        })\n\n    for field in fields:\n        if field not in model_fields:\n            raise InvalidQueryParams(**{\n                'detail': 'The fields query param \"TYPE\" of \"%s\" '\n                          'is not possible. It does not have a field '\n                          'by the name of \"%s\".' % (rtype, field),\n                'links': LINK,\n                'parameter': PARAM,\n            })", "response": "Validates that the sparse fields exist on the models."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndetermine the sparse fields to limit the response to", "response": "def init(req, model):  # pylint: disable=unused-argument\n    \"\"\" Determine the sparse fields to limit the response to\n\n    Return a dict where the key is the resource type (rtype) &\n    the value is an array of string fields names to whitelist\n    against.\n\n    :return:\n        dict\n    \"\"\"\n\n    params = {}\n\n    for key, val in req.params.items():\n        try:\n            rtype, fields = _parse_param(key, val)\n            params[rtype] = fields\n        except TypeError:\n            continue\n\n    if params:\n        _validate_req(req)\n        for rtype, fields in params.items():\n            _validate_param(rtype, fields)\n    return params"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef request(url, message):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    host, port = url.split(':')\n    port = int(port)\n    s.connect((host, port))\n    s.send(pack(message))\n    data = s.makefile().read()\n    s.close()\n    return data", "response": "Sends a message synchronously to a url and returns the response."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef query_mxrecords(self):\n        import dns.resolver\n        logging.info('Resolving DNS query...')\n        answers = dns.resolver.query(self.domain, 'MX')\n        addresses = [answer.exchange.to_text() for answer in answers]\n        logging.info(\n            '{} records found:\\n{}'.format(\n                len(addresses), '\\n  '.join(addresses)))\n        return addresses", "response": "Query MX DNS records of the recipient SMTP server."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends the message through the recipient s domain MX records.", "response": "def send(self):\n        \"\"\"\n        Attempts the delivery through recipient's domain MX records.\n        \"\"\"\n        try:\n            for mx in self.mxrecords:\n                logging.info('Connecting to {} {}...'.format(mx, self.port))\n                server = smtplib.SMTP(mx, self.port)\n                server.set_debuglevel(logging.root.level < logging.WARN)\n                server.sendmail(\n                    self.sender, [self.recipient], self.message.as_string())\n                server.quit()\n                return True\n        except Exception as e:\n            logging.error(e)\n            if (isinstance(e, IOError)\n                    and e.errno in (errno.ENETUNREACH, errno.ECONNREFUSED)):\n                logging.error(\n                    'Please check that port {} is open'.format(self.port))\n            if logging.root.level < logging.WARN:\n                raise e\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dispatch(self, requestProtocol, requestPayload):\n        # method decoding\n        method = requestPayload[\"method\"].split(\".\")\n        if len(method) != 3:\n            requestProtocol.failRequestWithErrors([\"InvalidMethod\"])\n            return\n\n        # parsing method name\n        methodModule = method[0]\n        methodController = method[1]\n        methodAction = method[2]\n\n        # checking if module exists\n        if not self.application.isModuleLoaded(methodModule):\n            requestProtocol.failRequestWithErrors([\"InvalidMethodModule\"])\n            return\n\n        # checking if controller exists\n        controllerPath = os.path.join(\n            \"application\",\n            \"module\",\n            methodModule,\n            \"controller\",\n            \"{}.py\".format(methodController)\n        )\n        if not os.path.isfile(controllerPath):\n            requestProtocol.failRequestWithErrors([\"InvalidMethodController\"])\n            return\n\n        # importing controller\n        controllerSpec = importlib.util.spec_from_file_location(\n            methodController,\n            controllerPath\n        )\n        controller = importlib.util.module_from_spec(controllerSpec)\n        controllerSpec.loader.exec_module(controller)\n\n        # instancing controller\n        controllerInstance = controller.Controller(\n            self.application,\n            requestProtocol,\n            requestPayload[\"version\"],\n            requestPayload[\"parameters\"]\n        )\n\n        # checking if action exists\n        action = getattr(\n            controllerInstance,\n            \"{}Action\".format(methodAction),\n            None\n        )\n        if not callable(action):\n            requestProtocol.failRequestWithErrors([\"InvalidMethodAction\"])\n            return\n\n        # executing action\n        requestProtocol.requestPassedDispatcherValidation()\n\n        preDispatchAction = getattr(controllerInstance, \"preDispatch\")\n        postDispatchAction = getattr(controllerInstance, \"postDispatch\")\n\n        preDispatchAction()\n        action()\n        postDispatchAction()", "response": "Dispatch the request to the appropriate handler."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prepare(self, configuration_folder, args_dict, environment):\n        self.configuration_folder = configuration_folder\n        if not os.path.isdir(configuration_folder):\n            raise BadOption(\"Specified configuration folder is not a directory!\", wanted=configuration_folder)\n        available = [os.path.join(configuration_folder, name) for name in os.listdir(configuration_folder)]\n        available_environments = [os.path.basename(path) for path in available if os.path.isdir(path)]\n        available_environments = [e for e in available_environments if not e.startswith('.')]\n\n        # Make sure the environment exists\n        if environment and environment not in available_environments:\n            raise BadOption(\"Specified environment doesn't exist\", available=available_environments, wanted=environment)\n\n        if environment:\n            environment_files = [os.path.join(configuration_folder, \"accounts.yaml\")]\n            for root, dirs, files in os.walk(os.path.join(configuration_folder, environment)):\n                environment_files.extend(os.path.join(root, filename) for filename in files)\n\n            with tempfile.NamedTemporaryFile() as fle:\n                contents = json.dumps({\"includes\": environment_files})\n                fle.write(contents.encode('utf-8'))\n                fle.flush()\n                args_dict['aws_syncr']['environment'] = os.path.split(environment)[-1]\n                super(Collector, self).prepare(fle.name, args_dict)", "response": "Make a temporary configuration file from the files in our folder"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling before the configuration. converters are activated", "response": "def extra_prepare(self, configuration, args_dict):\n        \"\"\"Called before the configuration.converters are activated\"\"\"\n        aws_syncr = args_dict.pop(\"aws_syncr\")\n\n        self.configuration.update(\n            { \"$@\": aws_syncr.get(\"extra\", \"\")\n            , \"aws_syncr\": aws_syncr\n            , \"templates\": {}\n            , \"config_folder\": self.configuration_folder\n            }\n        , source = \"<args_dict>\"\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nusing to add a file to the configuration", "response": "def add_configuration(self, configuration, collect_another_source, done, result, src):\n        \"\"\"Used to add a file to the configuration, result here is the yaml.load of the src\"\"\"\n        if \"includes\" in result:\n            for include in result[\"includes\"]:\n                collect_another_source(include)\n        configuration.update(result, source=src)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhook to do any extra configuration collection or converter registration", "response": "def extra_configuration_collection(self, configuration):\n        \"\"\"Hook to do any extra configuration collection or converter registration\"\"\"\n        aws_syncr_spec = AwsSyncrSpec()\n        registered = {}\n        directory = pkg_resources.resource_filename(\"aws_syncr\", \"option_spec\")\n\n        for location in sorted(os.listdir(directory)):\n            import_name = os.path.splitext(location)[0]\n            if import_name != '__pycache__':\n                try:\n                    args = imp.find_module(import_name, [directory])\n                except ImportError as error:\n                    raise BadImport(directory=directory, importing=import_name, error=error)\n\n                try:\n                    module = imp.load_module(import_name, *args)\n                except SyntaxError as error:\n                    raise BadImport(directory=self.directory, importing=self.import_name, error=error)\n\n                if hasattr(module, \"__register__\"):\n                    registered.update(module.__register__())\n\n        configuration['__registered__'] = [name for _, name in sorted(registered.keys())]\n        by_name = dict((r[1], registered[r]) for r in registered)\n        for thing in ['aws_syncr', 'accounts', 'templates'] + list(by_name.keys()):\n            def make_converter(thing):\n                def converter(p, v):\n                    log.info(\"Converting %s\", p)\n                    meta = Meta(p.configuration, [(thing, \"\")])\n                    configuration.converters.started(p)\n                    if thing in by_name:\n                        return by_name[thing].normalise(meta, v)\n                    else:\n                        return getattr(aws_syncr_spec, \"{0}_spec\".format(thing)).normalise(meta, v)\n                return converter\n            configuration.add_converter(Converter(convert=make_converter(thing), convert_path=[thing]))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing command - line arguments and return a list of available template names.", "response": "def docopt_arguments():\n    \"\"\" Creates beautiful command-line interfaces.\n        See https://github.com/docopt/docopt \"\"\"\n    doc = \"\"\"Projy: Create templated project.\n\n    Usage: projy <template> <project> [<substitution>...]\n           projy -i | --info <template>\n           projy -l | --list\n           projy -h | --help\n           projy -v | --version\n\n    Options:\n        -i, --info      Print information on a specific template.\n        -l, --list      Print available template list.\n        -h, --help      Show this help message and exit.\n        -v, --version   Show program's version number and exit.\n    \"\"\"\n    from projy.docopt import docopt\n    return docopt(doc, argv=sys.argv[1:], version='0.1')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove the last Template from the class name.", "response": "def template_name_from_class_name(class_name):\n    \"\"\" Remove the last 'Template' in the name. \"\"\"\n    suffix = 'Template'\n    output = class_name\n    if (class_name.endswith(suffix)):\n        output = class_name[:-len(suffix)]\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint the list of all available templates.", "response": "def run_list():\n    \"\"\" Print the list of all available templates. \"\"\"\n    term = TerminalView()\n    term.print_info(\"These are the available templates:\")\n    import pkgutil, projy.templates\n    pkgpath = os.path.dirname(projy.templates.__file__)\n    templates = [name for _, name, _ in pkgutil.iter_modules([pkgpath])]\n    for name in templates:\n        # the father of all templates, not a real usable one\n        if (name != 'ProjyTemplate'):\n            term.print_info(term.text_in_color(template_name_from_class_name(name), TERM_PINK))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run_info(template):\n    template.project_name = 'TowelStuff' # fake project name, always the same\n    name = template_name_from_class_name(template.__class__.__name__)\n    term = TerminalView()\n    term.print_info(\"Content of template {} with an example project \" \\\n          \"named 'TowelStuff':\".format(term.text_in_color(name, TERM_GREEN)))\n\n    dir_name = None\n    for file_info in sorted(template.files(), key=lambda dir: dir[0]):\n        directory = file_name = template_name = ''\n        if file_info[0]:\n            directory = file_info[0]\n        if file_info[1]:\n            file_name = file_info[1]\n        if file_info[2]:\n            template_name = '\\t\\t - ' + file_info[2]\n        if (directory != dir_name):\n            term.print_info('\\n\\t' + term.text_in_color(directory + '/', TERM_PINK))\n            dir_name = directory\n\n        term.print_info('\\t\\t' + term.text_in_color(file_name, TERM_YELLOW) + template_name)\n\n    # print substitutions\n    try:\n        subs = template.substitutes().keys()\n        if len(subs) > 0:\n            subs.sort()\n            term.print_info(\"\\nSubstitutions of this template are: \")\n            max_len = 0\n            for key in subs:\n                if max_len < len(key):\n                    max_len = len(key)\n            for key in subs:\n                term.print_info(u\"\\t{0:{1}} -> {2}\".\n                format(key, max_len, template.substitutes()[key]))\n    except AttributeError:\n        pass", "response": "Print information about a specific template."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef template_class_from_name(name):\n    # import the right template module\n    term = TerminalView()\n    template_name = name + 'Template'\n    try:\n        __import__('projy.templates.' + template_name)\n        template_mod = sys.modules['projy.templates.' + template_name]\n    except ImportError:\n        term.print_error_and_exit(\"Unable to find {}\".format(name))\n\n    # import the class from the module\n    try:\n        template_class = getattr(template_mod, template_name)\n    except AttributeError:\n        term.print_error_and_exit(\"Unable to create a template {}\".format(name))\n    return template_class()", "response": "Return the template class object from agiven name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a new namedspace class that is a simple object that can be used as a base for the namedspace class.", "response": "def namedspace(typename, required_fields=(), optional_fields=(), mutable_fields=(),\n        default_values=frozendict(), default_value_factories=frozendict(),\n        return_none=False):\n    \"\"\"Builds a new class that encapsulates a namespace and provides\n    various ways to access it.\n\n\n    The typename argument is required and is the name of the\n    namedspace class that will be generated.\n\n    The required_fields and optional_fields arguments can be a string\n    or sequence of strings and together specify the fields that\n    instances of the namedspace class have.\n\n    Values for the required fields must be provided somehow when the\n    instance is created. Values for optional fields may be provided\n    later, or maybe not at all.\n\n    If an optional field is queried before its value has been set,\n    an AttributeError will be raised. This behavior can be altered\n    to cause None to be returned instead by setting the return_none\n    keyword argument to True.\n\n    The mutable_fields argument specifies which fields will be mutable,\n    if any. By default, all fields are immutable and all instances are\n    hashable and can be used as dictionary keys. If any fields are set\n    as mutable, all instances are not hashable and cannot be used as\n    dictionary keys.\n\n    The default_values mapping provides simple default values for the\n    fields.\n\n    The default_value_factories mapping provides a more flexible, but\n    more complex, mechanism for providing default values. The value of\n    each item is a callable that takes a single argument, the\n    namedspace instance, and returns the default value for the field.\n\n    The default_values_factories mapping is only consulted if there\n    is no default value for the field in the default_values mapping.\n\n\n    Here is a simple example, using only the required fields argument:\n\n    >>> SimpleNS = namedspace(\"SimpleNS\", (\"id\", \"name\", \"description\"))\n\n    >>> SimpleNS\n    <class 'namedspace.SimpleNS'>\n\n    There are built-in properties to access collections and iterators\n    associated with the namespace class.\n\n    >>> SimpleNS._field_names\n    ('id', 'name', 'description')\n\n    >>> tuple(SimpleNS._field_names_iter)\n    ('id', 'name', 'description')\n\n    Once the class has been created, it can be instantiated like any\n    other class. However, a value for all of the required fields must\n    be provided.\n\n    >>> simple_ns = SimpleNS(id=1, description=\"Simple Description\")\n    Traceback (most recent call last):\n        <snip/>\n    ValueError: A value for field 'name' is required.\n\n    >>> simple_ns = SimpleNS(id=1, name=\"Simple Name\", description=\"Simple Description\")\n\n    >>> simple_ns\n    SimpleNS(id=1, name='Simple Name', description='Simple Description')\n\n\n    An instance of a namedspace class provides standard attribute\n    access to its fields.\n\n    >>> simple_ns.id\n    1\n    \n    >>> simple_ns.name\n    'Simple Name'\n    \n    >>> simple_ns.description\n    'Simple Description'\n\n\n    In addition to standard attribute access, instances of a namedspace\n    class implement a MutableMapping interface.\n\n    >>> 'id' in simple_ns\n    True\n\n    >>> for field_name in simple_ns:\n    ...     print field_name\n    id\n    name\n    description\n\n    >>> len(simple_ns)\n    3\n\n    >>> simple_ns[\"id\"]\n    1\n\n    >>> simple_ns[\"name\"]\n    'Simple Name'\n\n    >>> simple_ns[\"description\"]\n    'Simple Description'\n\n\n    There are built-in properties to access collections and iterators\n    associated with the namespace.\n\n    The namespace encapsulated by a namedspace class is stored in an\n    OrderedDict, so order of the collections is the same as the order\n    that the fields were specified.\n\n    All of these properties use the standard \"non-public\" naming\n    convention in order to not pollute the public namespace.\n\n    >>> simple_ns._field_names\n    ('id', 'name', 'description')\n\n    >>> tuple(simple_ns._field_names_iter)\n    ('id', 'name', 'description')\n\n    >>> simple_ns._field_values\n    (1, 'Simple Name', 'Simple Description')\n\n    >>> tuple(simple_ns._field_values_iter)\n    (1, 'Simple Name', 'Simple Description')\n\n    >>> simple_ns._field_items\n    [('id', 1), ('name', 'Simple Name'), ('description', 'Simple Description')]\n\n    >>> list(simple_ns._field_items_iter)\n    [('id', 1), ('name', 'Simple Name'), ('description', 'Simple Description')]\n\n    >>> simple_ns._as_dict\n    OrderedDict([('id', 1), ('name', 'Simple Name'), ('description', 'Simple Description')])\n\n\n    Here is a more complex example, using most of the other arguments:\n\n    >>> from itertools import count\n\n    >>> ComplexNS = namedspace(\"ComplexNS\", \"id\", optional_fields=(\"name\", \"description\", \"extra\"),\n    ...     mutable_fields=(\"description\", \"extra\"), default_values={\"description\": \"None available\"},\n    ...     default_value_factories={\"id\": lambda self, counter=count(start=1): counter.next(),\n    ...         \"name\": lambda self: \"Name for id={id}\".format(id=self.id)})\n\n    >>> complex_ns1 = ComplexNS()\n\n    >>> complex_ns1.id\n    1\n\n    The value of 1 was automatically assigned by the\n    default_value_factory for the 'id' field, in this case a lambda\n    closure that hooks up an instance of itertools.count.\n\n    >>> complex_ns1.name\n    'Name for id=1'\n\n    This value was also generated by a default value factory. In this\n    case, the factory for the 'name' attribute uses the value of the\n    'id' attribute to compute the default value.\n\n    >>> complex_ns1.description\n    'None available'\n\n    This value came from the default_values mapping.\n\n\n    The description field was set as a mutable field, which allows\n    it to be modified.\n\n    >>> complex_ns1.description = \"Some fancy description\"\n    >>> complex_ns1.description\n    'Some fancy description'\n\n    Its value can also be deleted.\n\n    >>> del complex_ns1.description\n    >>> complex_ns1.description\n    'None available'\n\n    Since its modified value was deleted, and it has a default value,\n    it has reverted to its default value.\n\n\n    The extra field is a valid field in this namedspace, but it has not\n    yet been assigned a value and does not have a default.\n     \n    >>> complex_ns1.extra\n    Traceback (most recent call last):\n        <snip/>\n    AttributeError: \"Field 'extra' does not yet exist in this ComplexNS namedspace instance.\"\n\n    Sometimes, having an exception raised if an optional field is\n    missing, and being forced to handle it, is annoying. A namedspace\n    class can be configured at creation time to return None instead of\n    raising exceptions for optional fields by setting the `return_none`\n    parameter to `True`. Here is a trivial example:\n\n    >>> QuietNS = namedspace(\"QuietNS\", optional_fields=(\"might_be_none\",), return_none=True)\n\n    >>> quiet_ns1 = QuietNS(might_be_none=\"Nope, not this time\")\n    >>> quiet_ns1.might_be_none\n    'Nope, not this time'\n\n    >>> quiet_ns2 = QuietNS()\n    >>> quiet_ns2.might_be_none\n    >>>\n\n    Having the namedspace quietly return `None` makes sense in some\n    situations. But be careful. Understand the full implications of\n    this alternate behavior on the code that uses it. Subtle data-\n    dependent bugs can be introduced by this behavior, which is why it\n    is not enabled by default.\n\n    Now, back to our \"complex\" example.\n\n    Since the 'extra' field is one of the mutable fields, we can give it a value.\n\n    >>> complex_ns1.extra = \"Lasts a long, long time\"\n    >>> complex_ns1.extra\n    'Lasts a long, long time'\n\n    Only fields that have been declared as either required or optional\n    are allowed.\n\n    >>> complex_ns1.some_other_field = \"some other value\"\n    Traceback (most recent call last):\n        <snip/>\n    FieldNameError: \"Field 'some_other_field' does not exist in ComplexNS namedspace.\"\n\n    Finally, to illustrate that our counter is working as it should, if\n    we instantiate another instance, our id field will get the next\n    counter value.\n\n    >>> complex_ns2 = ComplexNS()\n    >>> complex_ns2.id\n    2\n\n    A common use case for a namedspace class is as a base class for\n    another custom class that has additional members such as properties\n    and methods. This way, the custom class gets all of the namedspace\n    behavior through declarative configuration, instead of having\n    to re-define that behavior imperatively.\n\n    The following is an example where one of the required fields is\n    generated at instantiation time, and the values for the two\n    optional fields are calculated values provided by properties in\n    the subclass.\n\n    >>> from collections import Counter\n    >>> class Widget(namedspace(\"_Widget\", (\"mfg_code\", \"model_code\", \"serial_number\"), optional_fields=(\"sku\", \"pk\"),\n    ...         return_none=True)):\n    ...     _sn_map = Counter()\n    ...     def __init__(self, *args, **kwargs):\n    ...         sn_key = (kwargs[\"mfg_code\"], kwargs[\"model_code\"])\n    ...         self._sn_map[sn_key] += 1\n    ...         kwargs[\"serial_number\"] = \"{:010}\".format(self._sn_map[sn_key])\n    ...         super(Widget, self).__init__(*args, **kwargs)\n    ...     @property\n    ...     def sku(self):\n    ...         return \"{}_{}\".format(self.mfg_code, self.model_code)\n    ...     @property\n    ...     def pk(self):\n    ...         return \"{}_{}\".format(self.sku, self.serial_number)\n    >>> widget1 = Widget(mfg_code=\"ACME\", model_code=\"X-500\")\n    >>> widget1\n    Widget(mfg_code='ACME', model_code='X-500', serial_number='0000000001', sku='ACME_X-500', pk='ACME_X-500_0000000001')\n    >>> widget1._as_dict\n    OrderedDict([('mfg_code', 'ACME'), ('model_code', 'X-500'), ('serial_number', '0000000001'), ('sku', 'ACME_X-500'), ('pk', 'ACME_X-500_0000000001')])\n    >>> widget2 = Widget(mfg_code=\"ACME\", model_code=\"X-500\")\n    >>> widget2\n    Widget(mfg_code='ACME', model_code='X-500', serial_number='0000000002', sku='ACME_X-500', pk='ACME_X-500_0000000002')\n    >>> widget2._as_dict\n    OrderedDict([('mfg_code', 'ACME'), ('model_code', 'X-500'), ('serial_number', '0000000002'), ('sku', 'ACME_X-500'), ('pk', 'ACME_X-500_0000000002')])\n    \"\"\"\n\n    # Initialize the list of arguments that will get put into the\n    # doc string of the generated class\n    arg_list_items = []\n\n    #\n    # Validate parameters\n    #\n    for arg_name in (\"required_fields\", \"optional_fields\", \"mutable_fields\"):\n        arg_value = locals()[arg_name]\n\n        if isinstance(arg_value, basestring):\n            arg_value = (arg_value,)\n            exec \"{arg_name} = arg_value\".format(arg_name=arg_name)\n        elif not isinstance(arg_value, Container):\n            raise ValueError(\"Value for argument '{arg_name}' must be a string or container of strings.\".format(\n                    arg_name=arg_name))\n\n        for field_name in arg_value:\n            if not isinstance(field_name, basestring):\n                raise ValueError(\"Items of container argument '{arg_name}' must be strings.\".format(arg_name=arg_name))\n\n        if len(arg_value) != len(frozenset(arg_value)):\n            raise ValueError(\"Value for argument '{arg_name}' contains duplicate fields.\".format(\n                    arg_name=arg_name))\n\n        arg_list_items.append(\"{arg_name}={arg_value!r}\".format(arg_name=arg_name, arg_value=tuple(arg_value)))\n\n        exec \"{arg_name}_set = frozenset(arg_value)\".format(arg_name=arg_name)\n\n    all_fields = tuple(required_fields + optional_fields)\n\n    if not all_fields:\n        raise ValueError(\"At least one required or optional field must be provided.\")\n\n    all_fields_set = frozenset(all_fields)\n\n    for field_name in mutable_fields:\n        if field_name not in all_fields_set:\n            raise ValueError(\"Mutable field '{field_name}' is not a required or optional field.\".format(\n                    field_name=field_name))\n\n    for arg_name in (\"default_values\", \"default_value_factories\"):\n        arg_value = locals()[arg_name]\n        if not isinstance(arg_value, Mapping):\n            raise ValueError(\"Value for argument '{arg_name}' must be a mapping.\".format(arg_name=arg_name))\n\n        default_field_names = frozenset(arg_value.iterkeys())\n        if not default_field_names.issubset(all_fields_set):\n            bad_default_field_names = default_field_names - all_fields_set\n            raise ValueError(\"Value for argument '{arg_name}' contains invalid field(s) '{field_names}'.\".format(\n                    arg_name=arg_name, field_names=\", \".join(bad_default_field_names)))\n\n        arg_list_items.append(\"{arg_name}={arg_value!r}\".format(arg_name=arg_name, arg_value=dict(arg_value)))\n\n        exec \"{arg_name} = frozendict(arg_value)\".format(arg_name=arg_name)\n\n    for field_name, factory in default_value_factories.iteritems():\n        if not callable(factory):\n            raise ValueError(\"Default value factory for '{field_name}' is not callable.\".format(field_name=field_name))\n\n    # Fill-in the class template\n    class_definition = _class_template.format(\n        typename=typename,\n        arg_list=\", \".join(arg_list_items),\n        )\n\n    # Execute the template string in a temporary namespace and support\n    # tracing utilities by setting a value for frame.f_globals['__name__']\n    namespace = dict(\n        __name__='namedspace_{typename}'.format(typename=typename),\n        all_fields=all_fields,\n        all_fields_set=all_fields_set,\n        required_fields_set=locals()[\"required_fields_set\"],\n        mutable_fields_set=locals()[\"mutable_fields_set\"],\n        default_values=default_values,\n        default_value_factories=default_value_factories,\n        Hashable=Hashable,\n        MutableMapping=MutableMapping,\n        OrderedDict=OrderedDict,\n        return_none=return_none,\n        NamedspaceMeta=NamedspaceMeta,\n        )\n\n    #\n    # Code from here down copied verbatim from namedtuple\n    #\n    try:\n        exec class_definition in namespace\n    except SyntaxError as e:\n        raise SyntaxError(e.message + ':\\n' + class_definition)\n    result = namespace[typename]\n\n    # For pickling to work, the __module__ variable needs to be set to the frame\n    # where the named tuple is created.  Bypass this step in enviroments where\n    # sys._getframe is not defined (Jython for example) or sys._getframe is not\n    # defined for arguments greater than 0 (IronPython).\n    try:\n        result.__module__ = _sys._getframe(1).f_globals.get('__name__', '__main__')\n    except (AttributeError, ValueError):\n        pass\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef configure(self, config):\n        self._dependency_resolver.configure(config)\n        self._logger.configure(config)", "response": "Configures the component by passing configuration parameters."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconsumes N items from iter.", "response": "def consume(iter, N=None):\n    '''Consumes N items from iter.  If N is None (or not given), consumes all.\n    '''\n    i = iter\n    if N is not None:\n        i = islice(iter, N)\n\n    for x in i:\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iteration_length(N, start=0, step=1):\n    '''Return the number of iteration steps over a list of length N,\nstarting at index start, proceeding step elements at a time.\n    '''\n    if N < 0:\n        raise ValueError('N cannot be negative')\n\n    if start < 0:\n        start += N\n        if start < 0:\n            raise ValueError('Invalid start value')\n\n    if step < 0:\n        step = -step\n        new_N = start + 1\n        if new_N > N:\n            raise ValueError('Invalid parameters')\n        N = new_N\n        start = 0\n\n    ret = int(math.ceil((N - start) / float(step)))\n    return max(0, ret)", "response": "Return the number of iteration steps over a list of length N starting at index start proceeding step elements at a time."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self, **kwargs):\n        '''\n        Run all benchmarks.\n\n        Extras kwargs are passed to benchmarks construtors.\n        '''\n        self.report_start()\n        for bench in self.benchmarks:\n            bench = bench(before=self.report_before_method,\n                      after=self.report_after_method,\n                      after_each=self.report_progress,\n                      debug=self.debug,\n                      **kwargs)\n            self.report_before_class(bench)\n            bench.run()\n            self.report_after_class(bench)\n            self.runned.append(bench)\n        self.report_end()", "response": "Run all benchmarks.\n\n        Extras kwargs are passed to benchmarks construtors."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads a benchmark module from file", "response": "def load_module(self, filename):\n        '''Load a benchmark module from file'''\n        if not isinstance(filename, string_types):\n            return filename\n        basename = os.path.splitext(os.path.basename(filename))[0]\n        basename = basename.replace('.bench', '')\n        modulename = 'benchmarks.{0}'.format(basename)\n        return load_module(modulename, filename)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading all benchmarks from a given module", "response": "def load_from_module(self, module):\n        '''Load all benchmarks from a given module'''\n        benchmarks = []\n        for name in dir(module):\n            obj = getattr(module, name)\n            if (inspect.isclass(obj) and issubclass(obj, Benchmark)\n                    and obj != Benchmark):\n                benchmarks.append(obj)\n        return benchmarks"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning indices of the smallest bounding box enclosing all non - zero values within an array", "response": "def boundingBox(booleanArray):\n    \"\"\"\n    return indices of the smallest bounding box enclosing all\n    non-zero values within an array\n\n    >>> a = np.array([ [0,0,0,0],\n    ...                [0,1,0,1],\n    ...                [0,0,1,0],\n    ...                [1,0,0,0],\n    ...                [0,0,0,0] ])\n    >>> print ( boundingBox(a) ) \n    (slice(1, 3, None), slice(0, 3, None))\n    \"\"\"\n\n    w = np.where(booleanArray)\n    p = []\n    for i in w:\n        if len(i):\n            p.append(slice(i.min(), i.max()))\n        else:\n            p.append(slice(0, 0))\n#             return None\n    return tuple(p)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the WSDLTools. OperationBinding instance is RPC.", "response": "def IsRPC(item):\n    \"\"\"item -- OperationBinding instance.\n    \"\"\"\n    if not isinstance(item, WSDLTools.OperationBinding):\n        raise TypeError, 'IsRPC takes 1 argument of type WSDLTools.OperationBinding'\n    soapbinding = item.getBinding().findBinding(WSDLTools.SoapBinding)\n    sob = item.findBinding(WSDLTools.SoapOperationBinding)\n    style = soapbinding.style\n    if sob is not None:\n        style = sob.style or soapbinding.style\n    return style == 'rpc'"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if the WSDL is literal.", "response": "def IsLiteral(item):\n    \"\"\"item -- MessageRoleBinding instance.\n    \"\"\"\n    if not isinstance(item, WSDLTools.MessageRoleBinding):\n        raise TypeError, 'IsLiteral takes 1 argument of type WSDLTools.MessageRoleBinding'\n    sbb = None\n    if item.type == 'input' or item.type == 'output':\n        sbb = item.findBinding(WSDLTools.SoapBodyBinding)\n    if sbb is None:\n        raise ValueError, 'Missing soap:body binding.'\n    return sbb.use == 'literal'"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a string representing the python type of the simpleType of the element. If the message contains only one part with an element attribute the python type is returned. Otherwise return None.", "response": "def FromMessageGetSimpleElementDeclaration(message):\n    '''If message consists of one part with an element attribute,\n    and this element is a simpleType return a string representing \n    the python type, else return None.\n\n    '''\n    assert isinstance(message, WSDLTools.Message), 'expecting WSDLTools.Message'\n\n    if len(message.parts) == 1 and message.parts[0].element is not None:\n       part = message.parts[0]\n       nsuri,name = part.element\n       wsdl = message.getWSDL()\n       types = wsdl.types\n       if types.has_key(nsuri) and types[nsuri].elements.has_key(name):\n            e = types[nsuri].elements[name]\n            if isinstance(e, XMLSchema.ElementDeclaration) is True and e.getAttribute('type'):\n                typ = e.getAttribute('type')\n                bt = BaseTypeInterpreter()\n                ptype = bt.get_pythontype(typ[1], typ[0])\n                return ptype\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _setAttributes(self, attributes):\n        '''parameters\n        attributes -- a flat list of all attributes, \n        from this list all items in attribute_typecode_dict will\n        be generated into attrComponents.\n        \n        returns a list of strings representing the attribute_typecode_dict.\n        '''\n        atd = self.attribute_typecode\n        atd_list = formatted_attribute_list = []\n        if not attributes:\n            return formatted_attribute_list\n        \n        atd_list.append('# attribute handling code')\n        idx = 0\n        while(idx < len(attributes)):\n            a = attributes[idx] \n            idx += 1\n            if a.isWildCard() and a.isDeclaration():\n                atd_list.append(\\\n                    '%s[(\"%s\",\"anyAttribute\")] = ZSI.TC.AnyElement()'\\\n                    % (atd, SCHEMA.XSD3)\n                    )\n            elif a.isDeclaration():\n                tdef = a.getTypeDefinition('type')\n                if tdef is not None:\n                    tc = '%s.%s(None)' %(NAD.getAlias(tdef.getTargetNamespace()),\n                        self.mangle(type_class_name(tdef.getAttributeName()))\n                        )\n                else:\n                    # built-in\n                    t = a.getAttribute('type')\n                    try:\n                        tc = BTI.get_typeclass(t[1], t[0])\n                    except:\n                        # hand back a string by default.\n                        tc = ZSI.TC.String\n                            \n                    if tc is not None: \n                        tc = '%s()' %tc\n                            \n                key = None\n                if a.getAttribute('form') == 'qualified':\n                    key = '(\"%s\",\"%s\")' % ( a.getTargetNamespace(),\n                                            a.getAttribute('name') )\n                elif a.getAttribute('form') == 'unqualified':\n                    key = '\"%s\"' % a.getAttribute('name')\n                else:\n                    raise ContainerError, \\\n                          'attribute form must be un/qualified %s' \\\n                          % a.getAttribute('form')\n                          \n                atd_list.append(\\\n                    '%s[%s] = %s' % (atd, key, tc)\n                    )\n            elif a.isReference() and a.isAttributeGroup():\n                # flatten 'em out....\n                for ga in a.getAttributeGroup().getAttributeContent():\n                    attributes += (ga,)\n\n            elif a.isReference():\n                try:\n                    ga = a.getAttributeDeclaration()\n                except XMLSchema.SchemaError:\n                    key = a.getAttribute('ref')\n                    self.logger.debug('No schema item for attribute ref (%s, %s)' %key)\n                    if key in self.built_in_refs: continue\n                    raise\n                        \n                tp = None\n                if ga is not None:\n                    tp = ga.getTypeDefinition('type')           \n                    key = '(\"%s\",\"%s\")' %(ga.getTargetNamespace(),\n                             ga.getAttribute('name'))\n                             \n                if ga is None:\n                    # TODO: probably SOAPENC:arrayType\n                    key = '(\"%s\",\"%s\")' %(\n                             a.getAttribute('ref').getTargetNamespace(),\n                             a.getAttribute('ref').getName())\n                    atd_list.append(\\\n                        '%s[%s] = ZSI.TC.String()' %(atd, key)\n                        )\n                elif tp is None:\n                    # built in simple type\n                    try:\n                        namespace,typeName = ga.getAttribute('type')\n                    except TypeError, ex:\n                        # TODO: attribute declaration could be anonymous type\n                        # hack in something to work\n                        atd_list.append(\\\n                            '%s[%s] = ZSI.TC.String()' %(atd, key)\n                            )\n                    else:\n                        atd_list.append(\\\n                            '%s[%s] = %s()' %(atd, key, \n                                 BTI.get_typeclass(typeName, namespace))\n                            )\n                else:\n                    typeName = tp.getAttribute('name')\n                    namespace = tp.getTargetNamespace()\n                    alias = NAD.getAlias(namespace)\n                    key = '(\"%s\",\"%s\")' \\\n                          % (ga.getTargetNamespace(),ga.getAttribute('name'))\n                    atd_list.append(\\\n                        '%s[%s] = %s.%s(None)' \\\n                        % (atd, key, alias, type_class_name(typeName))\n                        )\n            else:\n                raise TypeError, 'expecting an attribute: %s' %a.getItemTrace()\n            \n        return formatted_attribute_list", "response": "method sets the attributes of the attribute_typecode_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nappends additional import statement.", "response": "def appendImport(self, statement):\n        '''append additional import statement(s).\n        import_stament -- tuple or list or str \n        '''\n        if type(statement) in (list,tuple):\n            self.extras += statement\n        else:\n            self.extras.append(statement)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset up the object attributes.", "response": "def setUp(self, item):\n        '''\n        Parameters:\n            item -- WSDLTools BindingOperation instance.\n        '''\n        if not isinstance(item, WSDLTools.OperationBinding):\n            raise TypeError, 'Expecting WSDLTools Operation instance'\n\n        if not item.input:\n            raise WSDLFormatError('No <input/> in <binding name=\"%s\"><operation name=\"%s\">' %(\n                item.getBinding().name, item.name))\n        \n        self.name = None\n        self.port = None\n        self.soapaction = None\n        self.inputName  = None\n        self.outputName = None\n        self.inputSimpleType  = None\n        self.outputSimpleType = None\n        self.inputAction  = None\n        self.outputAction = None\n        self.port = port = item.getBinding().getPortType()\n        self._wsdl = item.getWSDL()\n        self.name = name = item.name\n        self.binding_operation = bop = item\n        \n        self.soap_input_headers = None\n        self.soap_output_headers = None\n        \n        op = port.operations.get(name)\n        if op is None:\n            raise WSDLFormatError(\n                '<portType name=\"%s\"/> no match for <binding name=\"%s\"><operation name=\"%s\">' %(\n                port.name, item.getBinding().name, item.name))\n\n        soap_bop = bop.findBinding(WSDLTools.SoapOperationBinding)\n        if soap_bop is None: \n            raise SOAPBindingError, 'expecting SOAP Bindings'\n\n        self.soapaction = soap_bop.soapAction\n        sbody = bop.input.findBinding(WSDLTools.SoapBodyBinding)\n        if not sbody:\n            raise SOAPBindingError('Missing <binding name=\"%s\"><operation name=\"%s\"><input><soap:body>' %(\n                port.binding.name, bop.name))\n\n        self.encodingStyle = None\n        if sbody.use == 'encoded':\n            assert sbody.encodingStyle == SOAP.ENC,\\\n                'Supporting encodingStyle=%s, not %s'%(SOAP.ENC, sbody.encodingStyle)\n            self.encodingStyle = sbody.encodingStyle\n\n        self.inputName  = op.getInputMessage().name\n        self.inputSimpleType = \\\n            FromMessageGetSimpleElementDeclaration(op.getInputMessage())\n        self.inputAction = op.getInputAction()\n        self.soap_input_headers = bop.input.findBindings(WSDLTools.SoapHeaderBinding)\n\n        if bop.output is not None:\n            sbody = bop.output.findBinding(WSDLTools.SoapBodyBinding)\n            if not item.output:\n                raise WSDLFormatError, \"Operation %s, no match for output binding\"  %name\n\n            self.outputName = op.getOutputMessage().name\n            self.outputSimpleType = \\\n                FromMessageGetSimpleElementDeclaration(op.getOutputMessage())\n            self.outputAction = op.getOutputAction()\n            self.soap_output_headers = bop.output.findBindings(WSDLTools.SoapHeaderBinding)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _setContent(self):\n        '''create string representation of operation.\n        '''\n        kwstring = 'kw = {}'\n        tCheck = 'if isinstance(request, %s) is False:' % self.inputName\n        bindArgs = ''\n        if self.encodingStyle is not None:\n            bindArgs = 'encodingStyle=\"%s\", ' %self.encodingStyle\n\n        if self.useWSA:\n            wsactionIn = 'wsaction = \"%s\"' % self.inputAction\n            wsactionOut = 'wsaction = \"%s\"' % self.outputAction\n            bindArgs += 'wsaction=wsaction, endPointReference=self.endPointReference, '\n            responseArgs = ', wsaction=wsaction'\n        else:\n            wsactionIn = '# no input wsaction'\n            wsactionOut = '# no output wsaction'\n            responseArgs = ''\n\n        bindArgs += '**kw)'\n\n        if self.do_extended:\n            inputName = self.getOperation().getInputMessage().name\n            wrap_str = \"\"\n            partsList = self.getOperation().getInputMessage().parts.values()\n            try:\n                subNames = GetPartsSubNames(partsList, self._wsdl)\n            except TypeError, ex:\n                raise Wsdl2PythonError,\\\n                    \"Extended generation failure: only supports doc/lit, \"\\\n                    +\"and all element attributes (<message><part element=\"\\\n                    +\"\\\"my:GED\\\"></message>) must refer to single global \"\\\n                    +\"element declaration with complexType content.  \"\\\n                    +\"\\n\\n**** TRY WITHOUT EXTENDED ****\\n\"\n                \n            args = []\n            for pa in subNames:\n                args += pa\n\n            for arg in args:\n                wrap_str += \"%srequest.%s = %s\\n\" % (ID2,\n                                                     self.getAttributeName(arg),\n                                                     self.mangle(arg))\n\n            #args = [pa.name for pa in self.getOperation().getInputMessage().parts.values()]\n            argsStr = \",\".join(args)\n            if len(argsStr) > 1: # add inital comma if args exist\n                argsStr = \", \" + argsStr\n\n            method = [\n                '%s# op: %s' % (ID1, self.getOperation().getInputMessage()),\n                '%sdef %s(self%s):' % (ID1, self.name, argsStr),\n                '\\n%srequest = %s()' % (ID2, self.inputName),\n                '%s' % (wrap_str),\n                '%s%s' % (ID2, kwstring),\n                '%s%s' % (ID2, wsactionIn),\n                '%sself.binding.Send(None, None, request, soapaction=\"%s\", %s'\\\n                %(ID2, self.soapaction, bindArgs),\n            ]\n        elif self.soap_input_headers:\n            method = [\n                '%s# op: %s' % (ID1, self.name),\n                '%sdef %s(self, request, soapheaders=(), **kw):' % (ID1, self.name),\n                '%s%s' % (ID2, tCheck),\n                '%sraise TypeError, \"%%s incorrect request type\" %% (%s)' %(ID3, 'request.__class__'),\n                '%s%s' % (ID2, wsactionIn),\n                '%s# TODO: Check soapheaders' % (ID2),\n                '%sself.binding.Send(None, None, request, soapaction=\"%s\", soapheaders=soapheaders, %s'\\\n                %(ID2, self.soapaction, bindArgs),\n            ]\n        else:\n            method = [\n                '%s# op: %s' % (ID1, self.name),\n                '%sdef %s(self, request, **kw):' % (ID1, self.name),\n                '%s%s' % (ID2, tCheck),\n                '%sraise TypeError, \"%%s incorrect request type\" %% (%s)' %(ID3, 'request.__class__'),\n                '%s%s' % (ID2, wsactionIn),\n                '%sself.binding.Send(None, None, request, soapaction=\"%s\", %s'\\\n                %(ID2, self.soapaction, bindArgs),\n            ]\n        #\n        # BP 1.0: rpc/literal\n        # WSDL 1.1 Section 3.5 could be interpreted to mean the RPC response \n        # wrapper element must be named identical to the name of the \n        # wsdl:operation.\n        # R2729\n\n        #    \n        # SOAP-1.1 Note: rpc/encoded\n        # Each parameter accessor has a name corresponding to the name of the \n        # parameter and type corresponding to the type of the parameter. The name of \n        # the return value accessor is not significant. Likewise, the name of the struct is \n        # not significant. However, a convention is to name it after the method name \n        # with the string \"Response\" appended.\n        #   \n        if not self.outputName:\n            method.append('%s#check for soap, assume soap:fault' %(ID2,))\n            method.append('%sif self.binding.IsSOAP(): self.binding.Receive(None, **kw)' % (ID2,))\n            self.writeArray(method)\n            return\n        \n        response = ['%s%s' % (ID2, wsactionOut),]\n        if self.isRPC() and not self.isLiteral():\n            # rpc/encoded Replace wrapper name with None\n            response.append(\\\n                '%stypecode = Struct(pname=None, ofwhat=%s.typecode.ofwhat, pyclass=%s.typecode.pyclass)' %(\n                     ID2, self.outputName, self.outputName)\n                )\n            response.append(\\\n                '%sresponse = self.binding.Receive(typecode%s)' %(\n                     ID2, responseArgs)\n                )\n        else:\n            response.append(\\\n                '%sresponse = self.binding.Receive(%s.typecode%s)' %(\n                     ID2, self.outputName, responseArgs)\n                )\n\n        # only support lit\n        if self.soap_output_headers:\n            sh = '['\n            for shb in self.soap_output_headers:\n                #shb.encodingStyle, shb.use, shb.namespace\n                shb.message\n                shb.part\n                try:\n                    msg = self._wsdl.messages[shb.message]\n                    part = msg.parts[shb.part]\n                    if part.element is not None:\n                        sh += 'GED%s,' %str(part.element)\n                    else:\n                        warnings.warn('skipping soap output header in Message \"%s\"' %str(msg))\n                except:\n                    raise WSDLFormatError(\n                      'failure processing output header typecodes, ' +\n                      'could not find message \"%s\" or its part \"%s\"' %(\n                               shb.message, shb.part)\n                    )\n                                 \n            sh += ']'\n            if len(sh) > 2:\n                response.append(\\\n                '%sself.soapheaders = self.binding.ps.ParseHeaderElements(%s)' %(ID2, sh)\n                )\n\n        if self.outputSimpleType:\n            response.append('%sreturn %s(response)' %(ID2, self.outputName))\n        else: \n            if self.do_extended:\n                partsList = self.getOperation().getOutputMessage().parts.values()\n                subNames = GetPartsSubNames(partsList, self._wsdl)\n                args = []\n                for pa in subNames:\n                    args += pa\n\n                for arg in args:\n                    response.append('%s%s = response.%s' % (ID2, self.mangle(arg), self.getAttributeName(arg)) )\n                margs = \",\".join(args)\n                response.append(\"%sreturn %s\" % (ID2, margs) )\n            else:\n                response.append('%sreturn response' %ID2)\n        method += response\n\n        self.writeArray(method)", "response": "create string representation of operation."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setUp(self, item):\n        '''This method finds all SOAP Binding Operations, it will skip \n        all bindings that are not SOAP.  \n        item -- WSDL.Binding instance\n        '''\n        assert isinstance(item, WSDLTools.Binding), \\\n              'expecting WSDLTools Binding instance'\n\n        portType = item.getPortType()\n        self._kwargs = KW.copy()\n        self._kwargs['bind'] = NC_to_CN(item.name)\n        self.operations = []\n        self.rProp = portType.getResourceProperties() \n        soap_binding = item.findBinding(WSDLTools.SoapBinding)\n        if soap_binding is None:\n            raise Wsdl2PythonError,\\\n                'Binding(%s) missing WSDLTools.SoapBinding' %item.name\n\n        for bop in item.operations:\n            soap_bop = bop.findBinding(WSDLTools.SoapOperationBinding)\n            if soap_bop is None:\n                self.logger.warning(\\\n                    'Skip Binding(%s) operation(%s) no SOAP Binding Operation'\\\n                    %(item.name, bop.name),\n                )\n                continue\n\n            #soapAction = soap_bop.soapAction\n            if bop.input is not None:\n                soapBodyBind = bop.input.findBinding(WSDLTools.SoapBodyBinding)\n                if soapBodyBind is None:\n                    self.logger.warning(\\\n                        'Skip Binding(%s) operation(%s) Bindings(%s) not supported'\\\n                        %(item.name, bop.name, bop.extensions)\n                    )\n                    continue\n                \n            op = portType.operations.get(bop.name)\n            if op is None:\n                raise Wsdl2PythonError,\\\n                    'no matching portType/Binding operation(%s)' % bop.name\n                    \n            c = self.operationclass(useWSA=self.useWSA, \n                    do_extended=self.do_extended)\n            c.setUp(bop)\n            self.operations.append(c)", "response": "This method will set up all WSDLTools. SOAPBinding and WSDLTools. SOAPOperationBinding objects that are not WSDL. Binding instances. It will skip \n all WSDLTools. Binding instances that are not WSDL. Binding instances. It will skip \n all WSDLTools. Binding instances that are not WSDL. Binding instances."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates string representation of doc / lit message container.", "response": "def _setContent(self):\n        '''create string representation of doc/lit message container.  If \n        message element is simple(primitive), use python type as base class.\n        '''\n        try:\n            simple = self._simple\n        except AttributeError:\n            raise RuntimeError, 'call setUp first'\n        \n        # TODO: Hidden contract.  Must set self.ns before getNSAlias...\n        #  File \"/usr/local/python/lib/python2.4/site-packages/ZSI/generate/containers.py\", line 625, in _setContent\n        #    kw['message'],kw['prefix'],kw['typecode'] = \\\n        #  File \"/usr/local/python/lib/python2.4/site-packages/ZSI/generate/containers.py\", line 128, in getNSAlias\n        #    raise ContainerError, 'no self.ns attr defined in %s' % self.__class__\n        # ZSI.generate.containers.ContainerError: no self.ns attr defined in ZSI.generate.containers.ServiceDocumentLiteralMessageContainer\n        #            \n#        self.ns = self.content.ns\n        \n        \n        kw = KW.copy()\n        kw.update(dict(message=self.content.mName, nsuri=self.content.ns,\n                       name=self.content.pName))\n        \n#        kw['message'],kw['prefix'],kw['typecode'] = \\\n#            self.content.mName, self.getNSAlias(), element_class_name(self.content.pName)\n#        \n        # These messsages are just global element declarations\n#        self.writeArray(['%(message)s = %(prefix)s.%(typecode)s().pyclass' %kw])\n        self.writeArray(['%(message)s = GED(\"%(nsuri)s\", \"%(name)s\").pyclass' %kw])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setUp(self, port, soc, input):\n        '''\n        Instance Data: \n           op    -- WSDLTools Operation instance\n           bop   -- WSDLTools BindingOperation instance\n           input -- boolean input/output\n        '''\n        name = soc.getOperationName()\n        bop = port.getBinding().operations.get(name)\n        op = port.getBinding().getPortType().operations.get(name)\n\n        assert op is not None, 'port has no operation %s' %name\n        assert bop is not None, 'port has no binding operation %s' %name\n\n        self.input = input\n        self.op = op\n        self.bop = bop", "response": "Sets up the internal state of the object based on the operation name and port and the WSDLTools BindingOperation instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the name of the generated inner class that will be specified as pyclass.", "response": "def getPyClass(self):\n        '''Name of generated inner class that will be specified as pyclass.\n        '''\n        # --> EXTENDED\n        if self.hasExtPyClass():\n            classInfo = self.extPyClasses[self.name]\n            return \".\".join(classInfo)\n        # <-- \n        \n        return 'Holder'"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list containing pyclass definition.", "response": "def getPyClassDefinition(self):\n        '''Return a list containing pyclass definition.\n        '''\n        kw = KW.copy()\n        \n        # --> EXTENDED\n        if self.hasExtPyClass():\n            classInfo = self.extPyClasses[self.name]\n            kw['classInfo'] = classInfo[0]\n            return [\"%(ID3)simport %(classInfo)s\" %kw ]\n        # <--\n        \n        kw['pyclass'] = self.getPyClass()\n        definition = []\n        definition.append('%(ID3)sclass %(pyclass)s:' %kw)\n        if self.metaclass is not None:\n            kw['type'] = self.metaclass\n            definition.append('%(ID4)s__metaclass__ = %(type)s' %kw)\n        definition.append('%(ID4)stypecode = self' %kw)\n        \n        #TODO: Remove pyclass holder __init__ -->\n        definition.append('%(ID4)sdef __init__(self):' %kw)\n        definition.append('%(ID5)s# pyclass' %kw)\n\n        # JRB HACK need to call _setElements via getElements\n        self._setUpElements()\n        \n        # JRB HACK need to indent additional one level\n        for el in self.elementAttrs:\n            kw['element'] = el\n            definition.append('%(ID2)s%(element)s' %kw)\n        definition.append('%(ID5)sreturn' %kw)\n        # <--\n        \n        # pyclass descriptive name\n        if self.name is not None:\n            kw['name'] = self.name\n            definition.append(\\\n                '%(ID3)s%(pyclass)s.__name__ = \"%(name)s_Holder\"' %kw\n                )\n\n        return definition"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nsuriLogic(self):\n        '''set a variable \"ns\" that represents the targetNamespace in\n        which this item is defined.  Used for namespacing local elements.\n        '''\n        if self.parentClass:\n            return 'ns = %s.%s.schema' %(self.parentClass, self.getClassName())\n        return 'ns = %s.%s.schema' %(self.getNSAlias(), self.getClassName())", "response": "set a variable ns that represents the targetNamespace in\n        which this item is defined. Used for namespacing local elements."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets up the elements of the item.", "response": "def _setUpElements(self):\n        \"\"\"TODO: Remove this method\n        \n        This method ONLY sets up the instance attributes.\n        Dependency instance attribute:\n            mgContent -- expected to be either a complex definition\n                with model group content, a model group, or model group \n                content.  TODO: should only support the first two.\n        \"\"\"\n        self.logger.debug(\"_setUpElements: %s\" %self._item.getItemTrace())\n        if hasattr(self, '_done'):\n            #return '\\n'.join(self.elementAttrs)\n            return\n        \n        self._done = True\n        flat = []\n        content = self.mgContent\n        if type(self.mgContent) is not tuple:\n            mg = self.mgContent\n            if not mg.isModelGroup(): \n                mg = mg.content\n                \n            content = mg.content\n            if mg.isAll():\n                flat = content\n                content = [] \n            elif mg.isModelGroup() and mg.isDefinition():\n                mg = mg.content\n                content = mg.content            \n    \n        idx = 0\n        content = list(content)\n        while idx < len(content):\n            c = orig = content[idx]\n            if c.isElement():\n                flat.append(c)\n                idx += 1\n                continue\n            \n            if c.isReference() and c.isModelGroup():\n                c = c.getModelGroupReference()\n                \n            if c.isDefinition() and c.isModelGroup():\n                c = c.content\n\n            if c.isSequence() or c.isChoice():\n                begIdx = idx\n                endIdx = begIdx + len(c.content)\n                for i in range(begIdx, endIdx):\n                    content.insert(i, c.content[i-begIdx])\n                    \n                content.remove(orig)\n                continue\n            \n            raise ContainerError, 'unexpected schema item: %s' %c.getItemTrace()\n                \n        for c in flat:\n            if c.isDeclaration() and c.isElement():\n                defaultValue = \"None\"\n                parent = c\n                defs = []\n                # stop recursion via global ModelGroupDefinition \n                while defs.count(parent) <= 1:\n                    maxOccurs = parent.getAttribute('maxOccurs')\n                    if maxOccurs == 'unbounded' or int(maxOccurs) > 1:\n                        defaultValue = \"[]\"\n                        break\n                        \n                    parent = parent._parent()\n                    if not parent.isModelGroup():\n                        break\n                    \n                    if parent.isReference():\n                        parent = parent.getModelGroupReference()\n                        \n                    if parent.isDefinition():\n                        parent = parent.content\n                        defs.append(parent)                \n                \n                if None ==  c.getAttribute('name') and c.isWildCard():\n                    e = '%sself.%s = %s' %(ID3, \n                            self.getAttributeName('any'), defaultValue)\n                else:\n                    e = '%sself.%s = %s' %(ID3, \n                            self.getAttributeName(c.getAttribute('name')), defaultValue)\n                self.elementAttrs.append(e)\n                continue\n                        \n            # TODO: This seems wrong \n            if c.isReference():\n                e = '%sself._%s = None' %(ID3,\n                        self.mangle(c.getAttribute('ref')[1]))\n                self.elementAttrs.append(e)\n                continue\n            \n            raise ContainerError, 'unexpected item: %s' % c.getItemTrace()\n\n        #return '\\n'.join(self.elementAttrs)\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _setTypecodeList(self):\n        self.logger.debug(\"_setTypecodeList(%r): %s\" %\n                          (self.mgContent, self._item.getItemTrace()))\n        \n        flat = []\n        content = self.mgContent\n        \n        #TODO: too much slop permitted here, impossible\n        # to tell what is going on.\n        \n        if type(content) is not tuple:\n            mg = content\n            if not mg.isModelGroup():\n                raise Wsdl2PythonErr(\"Expecting ModelGroup: %s\" %\n                                     mg.getItemTrace())\n                \n            self.logger.debug(\"ModelGroup(%r) contents(%r): %s\" %\n                  (mg, mg.content, mg.getItemTrace()))\n            \n            #<group ref>\n            if mg.isReference():\n                raise RuntimeError(\"Unexpected modelGroup reference: %s\" %\n                                   mg.getItemTrace())\n            \n            #<group name>\n            if mg.isDefinition():\n                mg = mg.content\n                \n            if mg.isAll():\n                flat = mg.content\n                content = [] \n            elif mg.isSequence():\n                content = mg.content\n            elif mg.isChoice():\n                content = mg.content\n            else:\n                raise RuntimeError(\"Unknown schema item\")\n                \n        idx = 0\n        content = list(content)\n        self.logger.debug(\"content: %r\" %content)\n        while idx < len(content):\n            c = orig = content[idx]\n            if c.isElement():\n                flat.append(c)\n                idx += 1\n                continue\n            \n            if c.isReference() and c.isModelGroup():\n                c = c.getModelGroupReference()\n                \n            if c.isDefinition() and c.isModelGroup():\n                c = c.content\n                \n            if c.isSequence() or c.isChoice():\n                begIdx = idx\n                endIdx = begIdx + len(c.content)\n                for i in range(begIdx, endIdx):\n                    content.insert(i, c.content[i-begIdx])\n                    \n                content.remove(orig)\n                continue\n            \n            raise ContainerError, 'unexpected schema item: %s' %c.getItemTrace()\n\n        # TODO: Need to store \"parents\" in a dict[id] = list(),\n        #    because cannot follow references, but not currently\n        #    a big concern. \n        \n        self.logger.debug(\"flat: %r\" %list(flat))\n        for c in flat:\n            tc = TcListComponentContainer()\n            # TODO: Remove _getOccurs\n            min,max,nil = self._getOccurs(c)\n            min = max = None\n            maxOccurs = 1\n            \n            parent = c\n            defs = []\n            # stop recursion via global ModelGroupDefinition \n            while defs.count(parent) <= 1:\n                max = parent.getAttribute('maxOccurs')\n                if max == 'unbounded':\n                    maxOccurs = '\"%s\"' %max \n                    break\n                \n                maxOccurs = int(max) * maxOccurs\n                parent = parent._parent()\n                if not parent.isModelGroup():\n                    break\n                \n                if parent.isReference():\n                    parent = parent.getModelGroupReference()\n                    \n                if parent.isDefinition():\n                    parent = parent.content\n                    defs.append(parent)\n                \n            del defs\n            parent = c\n            while 1:\n                minOccurs = int(parent.getAttribute('minOccurs'))\n                if minOccurs == 0 or parent.isChoice():\n                    minOccurs = 0\n                    break\n                \n                parent = parent._parent()\n                if not parent.isModelGroup():\n                    minOccurs = int(c.getAttribute('minOccurs'))\n                    break\n                \n                if parent.isReference():\n                    parent = parent.getModelGroupReference()\n                    \n                if parent.isDefinition():\n                    parent = parent.content       \n            \n            tc.setOccurs(minOccurs, maxOccurs, nil)\n            processContents = self._getProcessContents(c)\n            tc.setProcessContents(processContents)\n            if c.isDeclaration() and c.isElement():\n                global_type = c.getAttribute('type')\n                content = getattr(c, 'content', None)\n                if c.isLocal() and c.isQualified() is False:\n                    tc.unQualified()\n\n                if c.isWildCard():\n                    tc.setStyleAnyElement()\n                elif global_type is not None:\n                    tc.name = c.getAttribute('name')\n                    ns = global_type[0]\n                    if ns in SCHEMA.XSD_LIST:\n                        tpc = BTI.get_typeclass(global_type[1],global_type[0])\n                        tc.klass = tpc\n#                    elif (self.ns,self.name) == global_type:\n#                        # elif self._isRecursiveElement(c)\n#                        # TODO: Remove this, it only works for 1 level.\n#                        tc.setStyleRecursion()\n                    else:\n                        tc.setGlobalType(*global_type)\n#                        tc.klass = '%s.%s' % (NAD.getAlias(ns),\n#                            type_class_name(global_type[1]))\n                    del ns\n                elif content is not None and content.isLocal() and content.isComplex():\n                    tc.name = c.getAttribute('name')\n                    tc.klass = 'self.__class__.%s' % (element_class_name(tc.name))\n                    #TODO: Not an element reference, confusing nomenclature\n                    tc.setStyleElementReference()\n                    self.localTypes.append(c)\n                elif content is not None and content.isLocal() and content.isSimple():\n                    # Local Simple Type\n                    tc.name = c.getAttribute('name')\n                    tc.klass = 'self.__class__.%s' % (element_class_name(tc.name))\n                    #TODO: Not an element reference, confusing nomenclature\n                    tc.setStyleElementReference()\n                    self.localTypes.append(c)\n                else:\n                    raise ContainerError, 'unexpected item: %s' % c.getItemTrace()\n\n            elif c.isReference():\n                # element references\n                ref = c.getAttribute('ref')\n#                tc.klass = '%s.%s' % (NAD.getAlias(ref[0]),\n#                                          element_class_name(ref[1]) )\n                tc.setStyleElementReference()\n                tc.setGlobalType(*ref)\n            else:\n                raise ContainerError, 'unexpected item: %s' % c.getItemTrace()\n\n            self.tcListElements.append(tc)", "response": "generates ofwhat content minOccurs maxOccurs facet generation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _getOccurs(self, e):\n        '''return a 3 item tuple \n        '''\n        minOccurs = maxOccurs = '1'\n        nillable = True\n        return minOccurs,maxOccurs,nillable", "response": "return a 3 item tuple \n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getAttributeNames(self):\n        '''returns a list of anames representing the parts\n        of the message.\n        '''\n        return map(lambda e: self.getAttributeName(e.name), self.tcListElements)", "response": "returns a list of anames representing the parts\n        of the message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset up the object from the given item.", "response": "def setUp(self, tp):\n        '''\n        {'xsd':['annotation', 'simpleContent', 'complexContent',\\\n        'group', 'all', 'choice', 'sequence', 'attribute', 'attributeGroup',\\\n        'anyAttribute', 'any']}\n        '''\n        # \n        # TODO: Need a Recursive solution, this is incomplete will ignore many\n        #  extensions, restrictions, etc.\n        # \n        self._item = tp\n        # JRB HACK SUPPORTING element/no content.\n        assert tp.isElement() is True and \\\n            (tp.content is None or (tp.content.isComplex() is True and tp.content.isLocal() is True)),\\\n            'expecting element w/local complexType not: %s' %tp.content.getItemTrace()\n\n        self.name = tp.getAttribute('name')\n        self.ns = tp.getTargetNamespace()\n        self.local = tp.isLocal()\n\n        complex = tp.content\n        # JRB HACK SUPPORTING element/no content.\n        if complex is None:\n            self.mgContent = ()\n            return\n        \n        #attributeContent = complex.getAttributeContent()\n        #self.mgContent = None\n        if complex.content is None:\n            self.mgContent = ()\n            self.attrComponents = self._setAttributes(complex.getAttributeContent())\n            return \n\n        is_simple = complex.content.isSimple()\n        if is_simple and complex.content.content.isExtension():\n            # TODO: Not really supported just passing thru\n            self.mgContent = ()\n            self.attrComponents = self._setAttributes(complex.getAttributeContent())\n            return\n\n        if is_simple and complex.content.content.isRestriction():\n            # TODO: Not really supported just passing thru\n            self.mgContent = ()\n            self.attrComponents = self._setAttributes(complex.getAttributeContent())\n            return\n\n        if is_simple:\n            raise ContainerError, 'not implemented local complexType/simpleContent: %s'\\\n               %tp.getItemTrace()\n\n        is_complex = complex.content.isComplex()\n        if is_complex and complex.content.content is None:\n            # TODO: Recursion...\n            self.mgContent = ()\n            self.attrComponents = self._setAttributes(complex.getAttributeContent())\n            return\n\n        if (is_complex and complex.content.content.isExtension() and \n            complex.content.content.content is not None and\n            complex.content.content.content.isModelGroup()):\n\n            self.mgContent = complex.content.content.content.content\n            self.attrComponents = self._setAttributes(\n                    complex.content.content.getAttributeContent()\n                )\n            return\n\n        if (is_complex and complex.content.content.isRestriction() and\n            complex.content.content.content is not None and \n            complex.content.content.content.isModelGroup()):\n\n            self.mgContent = complex.content.content.content.content\n            self.attrComponents = self._setAttributes(\n                    complex.content.content.getAttributeContent()\n                )\n            return\n\n        if is_complex:\n            self.mgContent = ()\n            self.attrComponents = self._setAttributes(complex.getAttributeContent())\n            return\n\n        if complex.content.isModelGroup():\n            self.mgContent = complex.content.content\n            self.attrComponents = self._setAttributes(complex.getAttributeContent())\n            return\n\n        # TODO: Scary Fallthru\n        self.mgContent = ()\n        self.attrComponents = self._setAttributes(complex.getAttributeContent())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _setContent(self):\n        '''GED defines element name, so also define typecode aname\n        '''\n        kw = KW.copy()\n        try:\n            kw.update(dict(klass=self.getClassName(),\n                       element='ElementDeclaration',\n                       literal=self.literalTag(),\n                       substitutionGroup=self._substitutionGroupTag(),\n                       schema=self.schemaTag(), \n                       init=self.simpleConstructor(),\n                       ns=self.ns, name=self.name,\n                       aname=self.getAttributeName(self.name),  \n                       baseslogic=self.getBasesLogic(ID3),\n                       #ofwhat=self.getTypecodeList(),\n                       #atypecode=self.attribute_typecode,\n                       #pyclass=self.getPyClass(),\n                       alias=NAD.getAlias(self.sKlassNS),\n                       subclass=type_class_name(self.sKlass),\n                       ))\n        except Exception, ex:\n            args = ['Failure processing an element w/local complexType: %s' %(\n                          self._item.getItemTrace())]\n            args += ex.args\n            ex.args = tuple(args)\n            raise\n        \n        if self.local:\n            kw['element'] = 'LocalElementDeclaration'\n        \n        element = [\n            '%(ID1)sclass %(klass)s(%(element)s):',\n            '%(ID2)s%(literal)s',\n            '%(ID2)s%(schema)s',\n            '%(ID2)s%(substitutionGroup)s',\n            '%(ID2)s%(init)s',\n            '%(ID3)skw[\"pname\"] = (\"%(ns)s\",\"%(name)s\")',\n            '%(ID3)skw[\"aname\"] = \"%(aname)s\"',\n            '%(baseslogic)s',\n            '%(ID3)s%(alias)s.%(subclass)s.__init__(self, **kw)',\n            '%(ID3)sif self.pyclass is not None: self.pyclass.__name__ = \"%(klass)s_Holder\"',\n            ]\n\n        self.writeArray(map(lambda l: l %kw, element))", "response": "Set content of the object to the content of the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset up the object based on the properties of the item.", "response": "def setUp(self, tp):\n        '''complexContent/[extension,restriction]\n            restriction\n            extension\n            extType -- used in figuring attrs for extensions\n        '''\n        self._item = tp\n        assert tp.content.isComplex() is True and \\\n            (tp.content.content.isRestriction() or tp.content.content.isExtension() is True),\\\n            'expecting complexContent/[extension,restriction]'\n            \n        self.extType = None\n        self.restriction = False\n        self.extension = False\n        self._kw_array = None\n        self._is_array = False\n        self.name = tp.getAttribute('name')\n        self.ns = tp.getTargetNamespace()\n        \n        # xxx: what is this for?\n        #self.attribute_typecode = 'attributes'\n        \n        derivation = tp.content.content\n        # Defined in Schema instance?\n        try:\n            base = derivation.getTypeDefinition('base')\n        except XMLSchema.SchemaError, ex:\n            base = None\n\n        # anyType, arrayType, etc...\n        if base is None:\n            base = derivation.getAttributeQName('base')\n            if base is None:\n                raise ContainerError, 'Unsupported derivation: %s'\\\n                        %derivation.getItemTrace()\n                        \n            if base != (SOAP.ENC,'Array') and base != (SCHEMA.XSD3,'anyType'):\n                raise ContainerError, 'Unsupported base(%s): %s' %(\n                    base, derivation.getItemTrace()\n                    )\n                \n        if base == (SOAP.ENC,'Array'):\n            # SOAP-ENC:Array expecting arrayType attribute reference\n            self.logger.debug(\"Derivation of soapenc:Array\")\n            self._is_array = True\n            self._kw_array = {'atype':None, 'id3':ID3, 'ofwhat':None}\n            self.sKlass = BTI.get_typeclass(base[1], base[0])\n            self.sKlassNS = base[0]\n\n            for a in derivation.getAttributeContent():\n\n                assert a.isAttribute() is True,\\\n                    'only attribute content expected: %s' %a.getItemTrace()\n\n                if a.isReference() is False:\n                    continue\n\n                if a.getAttribute('ref') != (SOAP.ENC,'arrayType'):\n                    continue\n\n                attr = a.getAttributeQName((WSDL.BASE, 'arrayType'))\n                if attr is None:\n                    warnings.warn('soapenc:array derivation declares attribute reference (\"%s\",\"%s\"), does not define attribute (\"%s\",\"%s\")' %(\n                        SOAP.ENC,'arrayType',WSDL.BASE, 'arrayType'))\n                    break\n                \n                self._kw_array['atype'] = attr\n                qname = self._kw_array.get('atype')\n                if a is not None:\n                    ncname = qname[1].strip('[]')\n                    namespace = qname[0]\n                    try:\n                        ofwhat = a.getSchemaItem(XMLSchema.TYPES, namespace, ncname)\n                    except XMLSchema.SchemaError, ex:\n                        ofwhat = None\n\n                    if ofwhat is None:\n                        self._kw_array['ofwhat'] = BTI.get_typeclass(ncname, namespace)\n                    else:\n                        self._kw_array['ofwhat'] = GetClassNameFromSchemaItem(ofwhat, do_extended=self.do_extended)\n\n                    if self._kw_array['ofwhat'] is None:\n                        raise ContainerError, 'For Array could not resolve ofwhat typecode(%s,%s): %s'\\\n                            %(namespace, ncname, derivation.getItemTrace())\n                    \n                    self.logger.debug('Attribute soapenc:arrayType=\"%s\"' %\n                                      str(self._kw_array['ofwhat']))\n\n                    break\n\n            #else:\n            #    raise Wsdl2PythonError, \\\n            #        'derivation of soapenc:array must declare attribute reference (\"%s\",\"%s\")' %(\n            #        SOAP.ENC,'arrayType')\n\n       \n        elif isinstance(base, XMLSchema.XMLSchemaComponent):\n            self.sKlass = base.getAttribute('name')\n            self.sKlassNS = base.getTargetNamespace()\n        else:\n            # TypeDescriptionComponent\n            self.sKlass = base.getName()\n            self.sKlassNS = base.getTargetNamespace()\n\n        attrs = []\n        if derivation.isRestriction():\n            self.restriction = True\n            self.extension = False\n            # derivation.getAttributeContent subset of tp.getAttributeContent \n            attrs += derivation.getAttributeContent() or ()\n        else:\n            self.restriction = False\n            self.extension = True\n            attrs += tp.getAttributeContent() or ()\n            if isinstance(derivation, XMLSchema.XMLSchemaComponent):\n                attrs += derivation.getAttributeContent() or ()\n                \n        # XXX: not sure what this is doing\n        if attrs:\n            self.extType = derivation\n\n        if derivation.content is not None \\\n            and derivation.content.isModelGroup():\n            group = derivation.content\n            if group.isReference():\n                group = group.getModelGroupReference()\n            self.mgContent = group.content\n        elif derivation.content:\n            raise Wsdl2PythonError, \\\n                'expecting model group, not: %s' %derivation.content.getItemTrace()\n        else:\n            self.mgContent = ()\n\n        self.attrComponents = self._setAttributes(tuple(attrs))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _setContent(self):\n        '''JRB What is the difference between instance data\n        ns, name, -- type definition?\n        sKlass, sKlassNS? -- element declaration?\n        '''\n        kw = KW.copy()\n        definition = []\n        if self._is_array:\n            # SOAP-ENC:Array\n            if _is_xsd_or_soap_ns(self.sKlassNS) is False and self.sKlass == 'Array':\n                raise ContainerError, 'unknown type: (%s,%s)'\\\n                    %(self.sKlass, self.sKlassNS)\n                    \n            # No need to xsi:type array items since specify with\n            # SOAP-ENC:arrayType attribute.\n            definition += [\\\n                '%sclass %s(ZSI.TC.Array, TypeDefinition):' % (ID1, self.getClassName()),\n                '%s#complexType/complexContent base=\"SOAP-ENC:Array\"' %(ID2),\n                '%s%s' % (ID2, self.schemaTag()),\n                '%s%s' % (ID2, self.typeTag()),\n                '%s%s' % (ID2, self.pnameConstructor()),\n                ]\n\n            append = definition.append\n            if  self._kw_array.get('ofwhat') is None:\n                append('%s%s.__init__(self, None, None, pname=pname, childnames=\\'item\\', undeclared=True, **kw)' %(ID3, self.sKlass))\n            else:\n                append('%(id3)sofwhat = %(ofwhat)s(None, typed=False)' %self._kw_array)\n                append('%(id3)satype = %(atype)s' %self._kw_array)\n                append('%s%s.__init__(self, atype, ofwhat, pname=pname, childnames=\\'item\\', **kw)' %(ID3, self.sKlass))\n\n            self.writeArray(definition)\n            return\n    \n        definition += [\\\n            '%sclass %s(TypeDefinition):' % (ID1, self.getClassName()),\n            '%s%s' % (ID2, self.schemaTag()),\n            '%s%s' % (ID2, self.typeTag()),\n            '%s%s' % (ID2, self.pnameConstructor()),\n            '%s%s' % (ID3, self.nsuriLogic()),\n            '%sTClist = [%s]' % (ID3, self.getTypecodeList()),\n            ]\n                \n        definition.append(\n            '%(ID3)sattributes = %(atc)s = attributes or {}' %{\n                'ID3':ID3, 'atc':self.attribute_typecode}\n        )\n\n        #\n        # Special case: anyType restriction\n        isAnyType = (self.sKlassNS, self.sKlass) == (SCHEMA.XSD3, 'anyType')\n        if isAnyType:\n            del definition[0]\n            definition.insert(0,\n                '%sclass %s(ZSI.TC.ComplexType, TypeDefinition):' % (\n                             ID1, self.getClassName())\n            )\n            definition.insert(1, \n                '%s#complexType/complexContent restrict anyType' %(\n                               ID2)\n            )\n        \n        # derived type support\n        definition.append('%sif extend: TClist += ofwhat'%(ID3))\n        definition.append('%sif restrict: TClist = ofwhat' %(ID3))\n        if len(self.attrComponents) > 0:\n            definition.append('%selse:' %(ID3))\n            for l in self.attrComponents: \n                definition.append('%s%s'%(ID4, l))\n                \n        if isAnyType:\n            definition.append(\\\n                '%sZSI.TC.ComplexType.__init__(self, None, TClist, pname=pname, **kw)' %(\n                    ID3),\n            )\n            \n            # pyclass class definition\n            definition += self.getPyClassDefinition()\n            kw['pyclass'] = self.getPyClass()\n            definition.append('%(ID3)sself.pyclass = %(pyclass)s' %kw)  \n            self.writeArray(definition)\n            return\n            \n        definition.append('%s'   % self.getBasesLogic(ID3))\n        prefix = NAD.getAlias(self.sKlassNS)\n        typeClassName = type_class_name(self.sKlass)\n        if self.restriction:\n            definition.append(\\\n                '%s%s.%s.__init__(self, pname, ofwhat=TClist, restrict=True, **kw)' %(\n                    ID3, prefix, typeClassName),\n            )\n            definition.insert(1, '%s#complexType/complexContent restriction' %ID2)\n            self.writeArray(definition)\n            return\n        \n        if self.extension:\n            definition.append(\\\n                '%s%s.%s.__init__(self, pname, ofwhat=TClist, extend=True, attributes=attributes, **kw)'%(\n                    ID3, prefix, typeClassName),\n            )\n            definition.insert(1, '%s#complexType/complexContent extension' %(ID2))\n            self.writeArray(definition)\n            return\n            \n        raise Wsdl2PythonError,\\\n            'ComplexContent must be a restriction or extension'", "response": "Internal method to set the content of the current object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setUp(self, tp, empty=False):\n        '''Problematic, loose all model group information.\n        <all>, <choice>, <sequence> ..\n\n           tp -- type definition\n           empty -- no model group, just use as a dummy holder.\n        '''\n        self._item = tp\n        \n        self.name = tp.getAttribute('name')\n        self.ns = tp.getTargetNamespace()\n        self.mixed = tp.isMixed()\n        self.mgContent = ()\n        self.attrComponents = self._setAttributes(tp.getAttributeContent())\n        \n        # Save reference to type for debugging\n        self._item = tp\n        \n        if empty:\n            return\n        \n        model = tp.content\n        if model.isReference(): \n            model = model.getModelGroupReference()\n        \n        if model is None:\n            return\n        \n        if model.content is None:\n            return\n       \n        # sequence, all or choice\n        #self.mgContent = model.content\n        self.mgContent = model", "response": "Set up the object attributes and attributes of the type definition."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset up the object properties from a complexType or simpleContent", "response": "def setUp(self, tp):\n        '''tp -- complexType/simpleContent/[Exention,Restriction]\n        '''\n        self._item = tp\n        \n        assert tp.isComplex() is True and tp.content.isSimple() is True,\\\n            'expecting complexType/simpleContent not: %s' %tp.content.getItemTrace()\n\n        simple = tp.content\n        dv = simple.content\n        assert dv.isExtension() is True or dv.isRestriction() is True,\\\n            'expecting complexType/simpleContent/[Extension,Restriction] not: %s' \\\n            %tp.content.getItemTrace()\n\n        self.name = tp.getAttribute('name')\n        self.ns = tp.getTargetNamespace()\n        # TODO: Why is this being set?\n        self.content.attributeContent = dv.getAttributeContent()\n        \n        base = dv.getAttribute('base')\n        if base is not None:\n            self.sKlass = BTI.get_typeclass( base[1], base[0] )\n            if not self.sKlass:\n                self.sKlass,self.sKlassNS = base[1], base[0]\n                \n            self.attrComponents = self._setAttributes(\n                                      self.content.attributeContent\n                                      )\n            return\n\n        raise Wsdl2PythonError,\\\n            'simple content derivation bad base attribute: ' %tp.getItemTrace()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _resolve_model(obj):\n    if isinstance(obj, six.string_types) and len(obj.split('.')) == 2:\n        app_name, model_name = obj.split('.')\n        resolved_model = apps.get_model(app_name, model_name)\n        if resolved_model is None:\n            msg = \"Django did not return a model for {0}.{1}\"\n            raise ImproperlyConfigured(msg.format(app_name, model_name))\n        return resolved_model\n    elif inspect.isclass(obj) and issubclass(obj, models.Model):\n        return obj\n    raise ValueError(\"{0} is not a Django model\".format(obj))", "response": "Resolve supplied obj to a Django model class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_field_info(model):\n    opts = model._meta.concrete_model._meta\n\n    pk = _get_pk(opts)\n    fields = _get_fields(opts)\n    forward_relations = _get_forward_relationships(opts)\n    reverse_relations = _get_reverse_relationships(opts)\n    fields_and_pk = _merge_fields_and_pk(pk, fields)\n    relationships = _merge_relationships(forward_relations, reverse_relations)\n\n    return FieldInfo(pk, fields, forward_relations, reverse_relations,\n                     fields_and_pk, relationships)", "response": "Given a model class returns a FieldInfo instance which is a namedtuple containing metadata about the fields forward_relations reverse_relations and the fields and reverse_relations."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an OrderedDict of field names to RelationInfo.", "response": "def _get_forward_relationships(opts):\n    \"\"\"\n    Returns an `OrderedDict` of field names to `RelationInfo`.\n    \"\"\"\n    forward_relations = OrderedDict()\n    for field in [field for field in opts.fields if field.serialize and field.rel]:\n        forward_relations[field.name] = RelationInfo(\n            model_field=field,\n            related_model=_resolve_model(field.rel.to),\n            to_many=False,\n            to_field=_get_to_field(field),\n            has_through_model=False\n        )\n\n    # Deal with forward many-to-many relationships.\n    for field in [field for field in opts.many_to_many if field.serialize]:\n        forward_relations[field.name] = RelationInfo(\n            model_field=field,\n            related_model=_resolve_model(field.rel.to),\n            to_many=True,\n            # manytomany do not have to_fields\n            to_field=None,\n            has_through_model=(\n                not field.rel.through._meta.auto_created\n            )\n        )\n\n    return forward_relations"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn an OrderedDict of field names to RelationInfo.", "response": "def _get_reverse_relationships(opts):\n    \"\"\"\n    Returns an `OrderedDict` of field names to `RelationInfo`.\n    \"\"\"\n    # Note that we have a hack here to handle internal API differences for\n    # this internal API across Django 1.7 -> Django 1.8.\n    # See: https://code.djangoproject.com/ticket/24208\n\n    reverse_relations = OrderedDict()\n    for relation in get_all_related_objects(opts):\n        accessor_name = relation.get_accessor_name()\n        related = getattr(relation, 'related_model', relation.model)\n        reverse_relations[accessor_name] = RelationInfo(\n            model_field=None,\n            related_model=related,\n            to_many=relation.field.rel.multiple,\n            to_field=_get_to_field(relation.field),\n            has_through_model=False\n        )\n\n    # Deal with reverse many-to-many relationships.\n    for relation in get_all_related_many_to_many_objects(opts):\n        accessor_name = relation.get_accessor_name()\n        related = getattr(relation, 'related_model', relation.model)\n        reverse_relations[accessor_name] = RelationInfo(\n            model_field=None,\n            related_model=related,\n            to_many=True,\n            # manytomany do not have to_fields\n            to_field=None,\n            has_through_model=(\n                (getattr(relation.field.rel, 'through', None) is not None) and\n                not relation.field.rel.through._meta.auto_created\n            )\n        )\n\n    return reverse_relations"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a boolean True if the given model is abstract and False otherwise.", "response": "def is_abstract_model(model):\n    \"\"\"\n    Given a model class, returns a boolean True if it is abstract and False if it is not.\n    \"\"\"\n    return hasattr(model, '_meta') and hasattr(model._meta, 'abstract') and model._meta.abstract"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef linRegressUsingMasked2dArrays(xVals, arrays, badMask=None, \n                                  zeroOffset=False,\n                                  calcError=False):\n    \"\"\"\n    if you have multiple 2d arrays each with position given by\n    xVals[array-index]\n    and you want to do a linear regression on all cells\n    but you also might mask different areas in each 2darray\n\n    zeroOffset - whether plot goest through origin\n\n    returns ascent, offset, RMS-error\n    \"\"\"\n    assert arrays.ndim == 3, 'need multiple 2d arrays'\n    if badMask is not None:\n        assert arrays.shape == badMask.shape, 'mask needs to have same shape'\n\n    s = arrays.shape\n    # flatten to create array of 1d arrays:\n    y = arrays.reshape(s[0], s[1] * s[2]).astype(float)\n    s = s[1:]\n    if zeroOffset:\n        A = np.array(xVals)[:,np.newaxis]\n        ascent = solution = np.linalg.lstsq(A, y)[0].reshape(s)\n        offset = 0\n    else:\n        A = np.vstack([xVals, np.ones(len(xVals))]).T\n        # solve linear regression:\n        solution = np.linalg.lstsq(A, y)[0]   \n        offset = solution[1].reshape(s)\n        ascent = solution[0].reshape(s)\n    \n    if badMask is not None:\n        # do linear regression for all masked areas\n        # trying to find multiple 2d arrays that are not masked together\n        x, y = np.where(np.sum(badMask, axis=0))\n        for xi, yi in zip(x, y):\n            valid = ~badMask[:, xi, yi]\n            try:\n                if zeroOffset:\n                    A = x[valid,np.newaxis]\n                    asc = np.linalg.lstsq(A, arrays[valid, xi, yi])[0]\n                else:\n                    asc, offs = linregress(x[valid], arrays[valid, xi, yi])[:2]\n                    offset[xi, yi] = offs\n                ascent[xi, yi] = asc\n                \n            except ValueError:\n                #if e.g. input is empty\n                ascent[xi, yi] = np.nan\n                if not zeroOffset:\n                    offset[xi, yi] = np.nan\n    if calcError:\n        # calculate RMSE of the regression:\n        error = np.empty(shape=arrays.shape)\n        for n, (y, x) in enumerate(zip(arrays, xVals)):\n            error[n] = (y - (x * ascent + offset))**2\n        error = error.mean(axis=0)**0.5\n    else:\n        error = None\n\n    return ascent, offset, error", "response": "linear regression of 2d arrays using masked 2d arrays"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate an LXC object and returns it.", "response": "def create(cls, *args, **kwargs):\n        \"\"\"Creates an LXC\"\"\"\n        container = LXC.create(*args, **kwargs)\n        return container"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef angleDiff(angle1, angle2, take_smaller=True):\n    a = np.arctan2(np.sin(angle1 - angle2), np.cos(angle1 - angle2))\n    if isinstance(a, np.ndarray) and take_smaller:\n        a = np.abs(a)\n        # take smaller of both possible angles:\n        ab = np.abs(np.pi - a)\n        with np.errstate(invalid='ignore'):\n            i = a > ab\n        a[i] = ab[i]\n    return a", "response": "returns the angle difference between two angles"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninvoking callback that should return a ( request response ) tuple. represents the SOAP request and response respectively.", "response": "def processRequest(cls, ps, **kw):\n        \"\"\"invokes callback that should return a (request,response) tuple.\n        representing the SOAP request and response respectively.\n        ps -- ParsedSoap instance representing HTTP Body.\n        request -- twisted.web.server.Request\n        \"\"\"\n        resource = kw['resource']\n        request = kw['request']\n\n        root = _get_element_nsuri_name(ps.body_root)\n        for key,method in inspect.getmembers(resource, inspect.ismethod):\n            if (getattr(method, 'soapmethod', False) and method.root == root):\n                break\n        else:\n            raise RuntimeError, 'Missing soap callback method for root \"%s\"' %root\n\n        try:\n            req = ps.Parse(method.requesttypecode)\n        except Exception, ex:\n            raise\n        try:\n            rsp = method.responsetypecode.pyclass()\n        except Exception, ex:\n            raise\n        \n        try:\n            req,rsp = method(req, rsp)\n        except Exception, ex:\n            raise\n\n        return rsp"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _request_cb(self, env, start_response):\n        if env['REQUEST_METHOD'] == 'GET':\n            return self._handle_GET(env, start_response)\n\n        if env['REQUEST_METHOD'] == 'POST':\n            return self._handle_POST(env, start_response)\n            \n        start_response(\"500 ERROR\", [('Content-Type','text/plain')])\n        s = StringIO()\n        h = env.items(); h.sort()\n        for k,v in h:\n            print >>s, k,'=',`v`\n        return [s.getvalue()]", "response": "process request and return list of available user names"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndispatch method called by twisted render creates a request and returns a list of SOAP messages.", "response": "def _handle_POST(self, env, start_response):\n        \"\"\"Dispatch Method called by twisted render, creates a\n        request/response handler chain.\n        request -- twisted.web.server.Request\n        \"\"\"\n        input = env['wsgi.input']\n        data = input.read( int(env['CONTENT_LENGTH']) )\n        mimeType = \"text/xml\"\n        if self.encoding is not None:\n            mimeType = 'text/xml; charset=\"%s\"' % self.encoding\n\n        request = None\n        resource = self.delegate or self\n        chain = self.factory.newInstance()\n        try:\n            pyobj = chain.processRequest(data, request=request, resource=resource)\n        except Exception, ex:\n            start_response(\"500 ERROR\", [('Content-Type',mimeType)])\n            return [fault.FaultFromException(ex, False, sys.exc_info()[2]).AsSOAP()]\n\n        try:\n            soap = chain.processResponse(pyobj, request=request, resource=resource)\n        except Exception, ex:\n            start_response(\"500 ERROR\", [('Content-Type',mimeType)])\n            return [fault.FaultFromException(ex, False, sys.exc_info()[2]).AsSOAP()]\n        \n        start_response(\"200 OK\", [('Content-Type',mimeType)])\n        return [soap]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self, target, payload, instance_id=None, hook_id=None, **kwargs):\n        requests.post(\n            url=target,\n            data=json.dumps(payload),\n            headers={\n                'Content-Type': 'application/json',\n                'Authorization': 'Token %s' % settings.HOOK_AUTH_TOKEN\n            }\n        )", "response": "target:     the url to receive the payload.\n        payload:    a python primitive data structure\n        instance_id:   a possibly None \"trigger\" instance ID\n        hook_id:       the ID of defining Hook object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nqueuing all services to be polled. Should be run via beat.", "response": "def run(self):\n        \"\"\"\n        Queues all services to be polled. Should be run via beat.\n        \"\"\"\n        services = Service.objects.all()\n        for service in services:\n            poll_service.apply_async(kwargs={\"service_id\": str(service.id)})\n        return \"Queued <%s> Service(s) for Polling\" % services.count()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(self, service_id, **kwargs):\n        log = self.get_logger(**kwargs)\n\n        log.info(\"Loading Service for healthcheck\")\n        try:\n            service = Service.objects.get(id=service_id)\n            log.info(\"Getting health for <%s>\" % (service.name))\n            status = self.get_health(service.url, service.token)\n            try:\n                result = status.json()\n\n                if (not service.up and result['up']):\n                    last_up_at = service.get_last_up_time()\n                    if last_up_at:\n                        downtime = timezone.now() - last_up_at\n                        fire_metric.apply_async(kwargs={\n                            \"metric_name\": 'services.downtime.%s.sum' % (\n                                utils.normalise_string(service.name)),\n                            \"metric_value\": downtime.seconds // 60\n                        })\n\n                service.up = result[\"up\"]\n                service.save()\n                Status.objects.create(\n                    service=service,\n                    up=result[\"up\"],\n                    result=result[\"result\"]\n                )\n                log.info(\"Service <%s> up: <%s>\" % (service.name, service.up))\n            except Exception:\n                # can't decode means there was not a valid response\n                log.info(\"Failed to parse response from <%s>\" % (service.name))\n                Status.objects.create(\n                    service=service,\n                    up=False,\n                    result={\"error\": \"No parseable response from service\"}\n                )\n                service.up = False\n                service.save()\n            return \"Completed healthcheck for <%s>\" % (service.name)\n        except ObjectDoesNotExist:\n            logger.error('Missing Service', exc_info=True)\n\n        except SoftTimeLimitExceeded:\n            logger.error(\n                'Soft time limit exceed processing poll of service \\\n                 via Celery.',\n                exc_info=True)", "response": "Retrieve a status from remote service. Set up state and log."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(self, service_id, user_id, email, **kwargs):\n        log = self.get_logger(**kwargs)\n\n        log.info(\"Loading Service for token creation\")\n        try:\n            service = Service.objects.get(id=service_id)\n            log.info(\"Getting token for <%s> on <%s>\" % (email, service.name))\n            response = self.create_token(service.url, email, service.token)\n            try:\n                result = response.json()\n                ust, created = UserServiceToken.objects.get_or_create(\n                    service=service, user_id=user_id, email=email)\n                ust.token = result[\"token\"]\n                ust.save()\n                log.info(\n                    \"Token saved for <%s> on <%s>\" % (email, service.name))\n            except Exception:\n                # can't decode means there was not a valid response\n                log.info(\"Failed to parse response from <%s>\" % (service.name))\n            return \"Completed getting token for <%s>\" % (email)\n        except ObjectDoesNotExist:\n            logger.error('Missing Service', exc_info=True)\n\n        except SoftTimeLimitExceeded:\n            logger.error(\n                'Soft time limit exceed processing getting service token \\\n                 via Celery.',\n                exc_info=True)", "response": "Create and retrieve a token from remote service. Save to DB."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nqueuing all services to be polled for metrics. Should be run via beat.", "response": "def run(self):\n        \"\"\"\n        Queues all services to be polled for metrics. Should be run via beat.\n        \"\"\"\n\n        services = Service.objects.all()\n        for service in services:\n            service_metric_sync.apply_async(\n                kwargs={\"service_id\": str(service.id)})\n\n            key = \"services.downtime.%s.sum\" % (\n                utils.normalise_string(service.name))\n            check = WidgetData.objects.filter(service=None, key=key)\n            if not check.exists():\n                WidgetData.objects.create(\n                    key=key,\n                    title=\"TEMP - Pending update\"\n                )\n\n        return \"Queued <%s> Service(s) for Metric Sync\" % services.count()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve a list of metrics. Ensure they are set as metric data sources.", "response": "def run(self, service_id, **kwargs):\n        \"\"\"\n        Retrieve a list of metrics. Ensure they are set as metric data sources.\n        \"\"\"\n        log = self.get_logger(**kwargs)\n\n        log.info(\"Loading Service for metric sync\")\n        try:\n            service = Service.objects.get(id=service_id)\n            log.info(\"Getting metrics for <%s>\" % (service.name))\n            metrics = self.get_metrics(service.url, service.token)\n            result = metrics.json()\n            if \"metrics_available\" in result:\n                for key in result[\"metrics_available\"]:\n                    check = WidgetData.objects.filter(service=service, key=key)\n                    if not check.exists():\n                        WidgetData.objects.create(\n                            service=service,\n                            key=key,\n                            title=\"TEMP - Pending update\"\n                        )\n                        log.info(\"Add WidgetData for <%s>\" % (key,))\n            return \"Completed metric sync for <%s>\" % (service.name)\n        except ObjectDoesNotExist:\n            logger.error('Missing Service', exc_info=True)\n\n        except SoftTimeLimitExceeded:\n            logger.error(\n                'Soft time limit exceed processing pull of service metrics \\\n                 via Celery.',\n                exc_info=True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if token is valid.", "response": "def check_token(request):\n    \"\"\"\n    Resource check is token valid.\n    ---\n    request_serializer: serializers.CheckToken\n    type:\n        username:\n            required: true\n            type: string\n            description: token related user\n\n    responseMessages:\n        - code: 200\n          message: Token is valid\n\n        - code: 400\n          message: Token is not valid\n\n        - code: 401\n          message: Unauthorized\n    \"\"\"\n    serializer = serializers.CheckToken(data=request.data)\n    serializer.is_valid(raise_exception=True)\n    token = serializer.validated_data['token']\n    logger.debug('Token correct', extra={'token': token, 'username': token.user.username})\n    return Response({'username': token.user.username})"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_login_password(request):\n    serializer = serializers.CheckLoginPassword(request=request, data=request.data)\n    serializer.is_valid(raise_exception=True)\n    username = serializer.validated_data['username']\n    logger.debug('Username and password correct', extra={'username': username})\n    user_serializer = serializers.User(instance=serializers.AuthUser.objects.get(username=username))\n    return Response(user_serializer.data)", "response": "Check login and password combination is valid."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_perm(request):\n    serializer = serializers.CheckPerm(data=request.query_params)\n    serializer.is_valid(raise_exception=True)\n    logger.debug('User have perm', extra=serializer.data)\n    return Response({'result': 'ok'})", "response": "Check user permission.\n    ---\n    request_serializer: serializers.CheckPerm\n\n    parameters:\n        - name: user\n          type: string\n          required: true\n          description: username\n          paramType: query\n\n        - name: perm\n          type: string\n          required: true\n          description: permission code\n          paramType: query\n\n    type:\n        result:\n            required: true\n            type: string\n            description: user have permission\n\n    responseMessages:\n        - code: 200\n          message: User have permission\n\n        - code: 400\n          message: User have not permission\n\n        - code: 401\n          message: Unauthorized"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nending timing of an execution block.", "response": "def end_timing(self):\n        \"\"\"\n        Ends timing of an execution block, calculates elapsed time and updates the associated counter.\n        \"\"\"\n\n        if self._callback != None:\n            elapsed = time.perf_counter() * 1000 - self._start\n            self._callback.end_timing(self._counter, elapsed)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndeletes any objects that can be loaded and are expired according to the current lifetime setting.", "response": "def prune_directory(self):\n        \"\"\"Delete any objects that can be loaded and are expired according to\n        the current lifetime setting.\n\n        A file will be deleted if the following conditions are met:\n\n        - The file extension matches :py:meth:`bucketcache.backends.Backend.file_extension`\n        - The object can be loaded by the configured backend.\n        - The object's expiration date has passed.\n\n        Returns:\n            File size and number of files deleted.\n\n        :rtype: :py:class:`~bucketcache.utilities.PrunedFilesInfo`\n\n        .. note::\n\n            For any buckets that share directories, ``prune_directory`` will\n            affect files saved with both, if they use the same backend class.\n\n            This is not destructive, because only files that have expired\n            according to the lifetime of the original bucket are deleted.\n        \"\"\"\n        glob = '*.{ext}'.format(ext=self.backend.file_extension)\n        totalsize = 0\n        totalnum = 0\n        for f in self._path.glob(glob):\n            filesize = f.stat().st_size\n            key_hash = f.stem\n            in_cache = key_hash in self._cache\n            try:\n                self._get_obj_from_hash(key_hash)\n            except KeyExpirationError:\n                # File has been deleted by `_get_obj_from_hash`\n                totalsize += filesize\n                totalnum += 1\n            except KeyInvalidError:\n                pass\n            except Exception:\n                raise\n            else:\n                if not in_cache:\n                    del self._cache[key_hash]\n        return PrunedFilesInfo(size=totalsize, num=totalnum)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unload_key(self, key):\n        key_hash = self._hash_for_key(key)\n        if key in self:\n            del self._cache[key_hash]", "response": "Remove key from memory leaving file in place."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nunloads a key from memory leaving file in place.", "response": "def unload_key(self, key):\n        \"\"\"Remove key from memory, leaving file in place.\n\n        This forces :py:meth:`~bucketcache.buckets.DeferredWriteBucket.sync`.\n        \"\"\"\n        self.sync()\n        return super(DeferredWriteBucket, self).unload_key(key)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sync(self):\n        for key_hash, obj in six.iteritems(self._cache):\n            # Objects are checked for expiration in __getitem__,\n            # but we can check here to avoid unnecessary writes.\n            if not obj.has_expired():\n                file_path = self._path_for_hash(key_hash)\n                with open(str(file_path), self._write_mode) as f:\n                    obj.dump(f)", "response": "Commit deferred writes to file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates the difference between two datetime. time values.", "response": "def diff_time(t1, t2):\n    \"\"\"\n    Calculates datetime.timedelta between two datetime.time values.\n    :param t1: First time\n    :type t1: datetime.time\n    :param t2: Second time\n    :type t2: datetime.time\n    :return: Differences between t1 and t2 or None when t1 or t2 is None\n    :rtype: datetime.timedelta/None\n    :raise: ValueError when t1 or t2 is not datetime.time or None\n    \"\"\"\n    if t1 is None or t2 is None:\n        return None\n\n    if not isinstance(t1, time):\n        raise ValueError('\"t1\" must be a datetime.time')\n    if not isinstance(t2, time):\n        raise ValueError('\"t2\" must be a datetime.time')\n\n    dt1 = datetime(1, 1, 1,\n                   t1.hour, t1.minute, t1.second, t1.microsecond, t1.tzinfo)\n    dt2 = datetime(1, 1, 1,\n                   t2.hour, t2.minute, t2.second, t2.microsecond, t2.tzinfo)\n\n    return dt1 - dt2"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsmooth [ arr ] using moving average", "response": "def staticMovingAverage(arr, fineness=10):\n    \"\"\"\n    smooth [arr] using moving average\n    \"\"\"\n    s0 = arr.shape[0]\n    window_len = int(round(s0 / fineness))\n\n    start = arr[0] + arr[0] - arr[window_len - 1:0:-1]\n    end = arr[-1] + arr[-1] - arr[-1:-window_len:-1]\n    s = np.r_[start, arr, end]\n    w = np.ones(window_len, 'd')\n    w /= w.sum()\n    a0 = np.convolve(w, s, mode='valid')[:s0]\n    a1 = np.convolve(w, s[::-1], mode='valid')[:s0][::-1]\n    return 0.5 * (a0 + a1)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef staticMovingAverage2(x, N=3, mode='reflect'):\n    assert N > 1\n    x2 = np.empty(shape=x.shape[0] + N, dtype=x.dtype)\n\n    start = N - 2\n    if N == 2:\n        start = 1\n    end = N - start\n\n    x2[start:-end] = x\n    # boundaries\n    if mode == 'reflect':\n        x2[:start] = x[0] + x[0] - x[start - 1::-1]\n        x2[-end:] = x[-1] + x[-1] - x[-2:-end - 2:-1]\n    elif mode == 'nearest':\n        x2[:start] = x[0]\n        x2[-end:] = x[-1]\n    else:\n        raise NotImplementedError(\"mode='%s' not supported\" % mode)\n    a1 = np.cumsum(x2)\n    a1 = (a1[N:] - a1[:-N]) / N\n\n    a2 = np.cumsum(x2[::-1])\n    a2 = (a2[N:] - a2[:-N]) / N\n\n    return 0.5 * (a1 + a2[::-1])\n    # TODO: unreachable code\n    cumsum = np.cumsum(x2)\n    return (cumsum[N:] - cumsum[:-N]) / N", "response": "static moving average filter for 1d arrays"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate url for request", "response": "def get_url(self, resource, params=None):\n        \"\"\"\n            Generate url for request\n        \"\"\"\n\n        # replace placeholders\n\n        pattern = r'\\{(.+?)\\}'\n\n        resource = re.sub(pattern, lambda t: str(params.get(t.group(1), '')), resource)\n\n        # build url\n\n        parts = (self.endpoint, '/api/', resource)\n        return '/'.join(map(lambda x: str(x).strip('/'), parts))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef request(self, method, resource, params=None):\n\n        url = self.get_url(resource, params)\n\n        # headers\n\n        headers = {\n            'Content-Type': 'application/json'\n        }\n\n        auth = requests.auth.HTTPBasicAuth(self.username, self.password)\n\n        # request\n\n        log.info('Request to %s. Data: %s' % (url, params))\n\n        response = requests.request(method, url, data=json.dumps(params), headers=headers, auth=auth)\n        response.raise_for_status()\n\n        # response\n\n        log.info('Response from %s: %s' % (url, response.text))\n        content = response.json()\n\n        self.parse_status(content.get('status'))\n\n        return content", "response": "Make a request to the server and parse the response"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef main():\n\tcommands = ['update', 'list', 'get', 'info', 'count', 'search', 'download']\n\tparser = argparse.ArgumentParser(description=\"Command line access to software repositories for TI calculators, primarily ticalc.org and Cemetech\")\n\tparser.add_argument(\"action\", metavar=\"ACTION\", type=str, help=\"The calcpkg command to execute (count, get, info, list, update)\")\n\tparser.add_argument(\"string\", metavar=\"STRING\", type=str, help=\"The string to search for when using count, get, info, or list commands\", nargs=\"?\", default=\"\")\n\t\n\tparser.add_argument(\"-c\", \"--category\", dest=\"category\", help=\"Limit searching to a specified category\", default=\"\")\n\tparser.add_argument(\"-e\", \"--extension\", dest=\"extension\", help=\"Limit searching to a specified file extension\", default=\"\")\n\tparser.add_argument(\"-f\", \"--filename\", dest=\"searchFiles\", action=\"store_true\", help=\"Search by archive filenames rather than descriptive package name\")\n\tparser.add_argument(\"-g\", \"--game\", dest=\"game\", action=\"store_true\", help=\"Limit searching to games only\")\n\tparser.add_argument(\"-m\", \"--math\", dest=\"math\", action=\"store_true\", help=\"Limit searching to math and science programs only\")\n\tparser.add_argument(\"-r\", \"--repository\", dest=\"repo\", help=\"Limit searching by one repository- default is to use all\", default=\"\")\n\tparser.add_argument(\"-v\", \"--verbose\", dest=\"verbose\", action=\"store_true\", help=\"Always provide verbose output\")\n\tparser.add_argument(\"-x\", \"--extract\", dest=\"extract\", action=\"store_true\", help=\"After downloading, autoextract archive files when possible\")\n\tparser.add_argument(\"-y\", \"--assume-yes\", dest=\"prompt\", action=\"store_false\", help=\"Never prompt for verification of command\")\n\targs = parser.parse_args()\n\n\t#Verify that a valid command was specified\n\tif not args.action in commands:\n\t\tprint \"Error: Invalid action specified, action must be one of \" + str(commands)\n\t\treturn\n\t\n\t#args.category is special\n\tif args.category != \"\":\n\t\tcategory = \"/\" + args.category + \"/\"\n\telse:\n\t\tcategory = \"\"\n\t\n\t#Initialize repositories; all behind-the-scene processing is done by plugins in calcrepo.repos\n\trepositories = createRepoObjects()\n\tif args.repo != \"\":\n\t\tfor repoName, repository in repositories.iteritems():\n\t\t\tif repoName != args.repo:\n\t\t\t\trepositories[repoName] = None\n\t\n\t#Now, run commands for each repo\t\t\n\tfor name, repository in repositories.iteritems():\n\t\tif repository != None:\n\t\t\trepository.setRepoData(args.string, category, args.extension, args.math, args.game, args.searchFiles)\n\t\t\tif args.action == \"update\":\n\t\t\t\trepository.updateRepoIndexes(args.verbose)\n\t\t\telif (args.action == \"list\" or args.action == \"search\"):\n\t\t\t\trepository.searchIndex()\n\t\t\telif (args.action == \"get\" or args.action == \"download\"):\n\t\t\t\trepository.searchIndex()\n\t\t\t\trepository.downloadFiles(args.prompt, args.extract)\n\t\t\telif args.action == \"info\":\n\t\t\t\trepository.getFileInfos()\n\t\t\telif args.action == \"count\":\n\t\t\t\trepository.countIndex()", "response": "Main function for the script"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef modify_attached_policies(self, role_name, new_policies):\n        parts = role_name.split('/', 1)\n        if len(parts) == 2:\n            prefix, name = parts\n            prefix = \"/{0}/\".format(prefix)\n        else:\n            prefix = \"/\"\n            name = parts[0]\n\n        current_attached_policies = []\n        with self.ignore_missing():\n            current_attached_policies = self.client.list_attached_role_policies(RoleName=name)\n            current_attached_policies = [p['PolicyArn'] for p in current_attached_policies[\"AttachedPolicies\"]]\n\n        new_attached_policies = [\"arn:aws:iam::aws:policy/{0}\".format(p) for p in new_policies]\n\n        changes = list(Differ.compare_two_documents(current_attached_policies, new_attached_policies))\n        if changes:\n            with self.catch_boto_400(\"Couldn't modify attached policies\", role=role_name):\n                for policy in new_attached_policies:\n                    if policy not in current_attached_policies:\n                        for _ in self.change(\"+\", \"attached_policy\", role=role_name, policy=policy):\n                            self.client.attach_role_policy(RoleName=name, PolicyArn=policy)\n\n                for policy in current_attached_policies:\n                    if policy not in new_attached_policies:\n                        for _ in self.change(\"-\", \"attached_policy\", role=role_name, changes=changes, policy=policy):\n                            self.client.detach_role_policy(RoleName=name, PolicyArn=policy)", "response": "Modify the attached policies of a role."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef assume_role_credentials(self, arn):\n        log.info(\"Assuming role as %s\", arn)\n\n        # Clear out empty values\n        for name in ['AWS_ACCESS_KEY_ID', 'AWS_SECRET_ACCESS_KEY', 'AWS_SECURITY_TOKEN', 'AWS_SESSION_TOKEN']:\n            if name in os.environ and not os.environ[name]:\n                del os.environ[name]\n\n        sts = self.amazon.session.client(\"sts\")\n        with self.catch_boto_400(\"Couldn't assume role\", arn=arn):\n            creds = sts.assume_role(RoleArn=arn, RoleSessionName=\"aws_syncr\")\n\n        return {\n              'AWS_ACCESS_KEY_ID': creds[\"Credentials\"][\"AccessKeyId\"]\n            , 'AWS_SECRET_ACCESS_KEY': creds[\"Credentials\"][\"SecretAccessKey\"]\n            , 'AWS_SECURITY_TOKEN': creds[\"Credentials\"][\"SessionToken\"]\n            , 'AWS_SESSION_TOKEN': creds[\"Credentials\"][\"SessionToken\"]\n            }", "response": "Return the environment variables for an assumed role"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _validate_token(self):\n        \n        ''' a method to validate active access token '''\n        \n        title = '%s._validate_token' % self.__class__.__name__\n    \n    # construct access token url\n        import requests\n        url = 'https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=%s' % self.access_token\n    \n    # retrieve access token details\n        try:\n            token_details = requests.get(url).json()\n        except:\n            raise DriveConnectionError(title)\n        if 'error' in token_details.keys():\n            raise ValueError('access_token for google drive account is %s' % token_details['error_description'])\n    \n    # determine collection space\n    # https://developers.google.com/drive/v3/web/about-organization\n        if 'scope' in token_details.keys():\n            service_scope = token_details['scope']\n            if service_scope.find('drive.appfolder') > -1:\n                self.drive_space = 'appDataFolder'\n                if not self.collection_name:\n                    self.collection_name = 'App Data Folder'\n            elif service_scope.find('drive.photos.readonly') > -1:\n                self.drive_space = 'photos'\n                if not self.collection_name:\n                    self.collection_name = 'Photos'\n    \n    # determine permissions\n    # https://developers.google.com/drive/v3/web/about-auth\n            if service_scope.find('readonly') > -1:\n                self.permissions_write = False\n            if service_scope.find('readonly.metadata') > -1:\n                self.permissions_content = False\n          \n    # TODO refresh token\n        if 'expires_in' in token_details.keys():\n            from time import time\n            expiration_date = time() + token_details['expires_in']\n        if 'issued_to' in token_details.keys():\n            client_id = token_details['issued_to']\n    \n        return token_details", "response": "a method to validate active access token"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _list_directory(self, folder_id=''):\n    \n        ''' a generator method for listing the contents of a directory '''\n        \n        title = '%s._list_directory' % self.__class__.__name__\n        \n    # construct default response\n        file_list = []\n    \n    # construct request kwargs\n        list_kwargs = {\n            'spaces': self.drive_space,\n            'fields': 'nextPageToken, files(id, name, parents, mimeType)'\n        }\n    \n    # add query field for parent\n        if folder_id:\n            list_kwargs['q'] = \"'%s' in parents\" % folder_id\n    \n    # retrieve space id\n        if not self.space_id:\n            self._get_space()\n        \n    # send request\n        page_token = 1\n        while page_token:\n            try:\n                response = self.drive.list(**list_kwargs).execute()\n            except:\n                raise DriveConnectionError(title)\n        \n        # populate list from response\n            results = response.get('files', [])\n            for file in results:\n                if not folder_id and file.get('parents', [])[0] != self.space_id:\n                    pass\n                else:\n                    yield file.get('id', ''), file.get('name', ''), file.get('mimeType', '')\n    \n        # get page token\n            page_token = response.get('nextPageToken', None)\n            if page_token:\n                list_kwargs['pageToken'] = page_token\n        \n        return file_list", "response": "a generator method for listing the contents of a directory"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load(self, record_key, secret_key=''):\n\n        ''' \n            a method to retrieve byte data of appdata record\n\n        :param record_key: string with name of record\n        :param secret_key: [optional] string used to decrypt data\n        :return: byte data for record body\n        '''\n\n        title = '%s.load' % self.__class__.__name__\n    \n    # validate inputs\n        input_fields = {\n            'record_key': record_key,\n            'secret_key': secret_key\n        }\n        for key, value in input_fields.items():\n            if value:\n                object_title = '%s(%s=%s)' % (title, key, str(value))\n                self.fields.validate(value, '.%s' % key, object_title)\n\n    # verify permissions\n        if not self.permissions_content:\n            raise Exception('%s requires an access_token with file content permissions.' % title)\n            \n    # retrieve file id\n        file_id, parent_id = self._get_id(record_key)\n        if not file_id:\n            raise Exception('%s(record_key=%s) does not exist.' % (title, record_key))\n    \n    # request file data\n        try:\n            record_data = self.drive.get_media(fileId=file_id).execute()\n        except:\n            raise DriveConnectionError(title)\n    \n    # retrieve data from response\n    #     import io\n    #     from googleapiclient.http import MediaIoBaseDownload\n    #     file_header = io.BytesIO\n    #     record_data = MediaIoBaseDownload(file_header, response)\n    #     done = False\n    #     while not done:\n    #         status, done = record_data.next_chunk()\n    \n    # TODO export google document to other format\n            \n    # decrypt (if necessary)\n        if secret_key:\n            from labpack.encryption import cryptolab\n            record_data = cryptolab.decrypt(record_data, secret_key)\n    \n        return record_data", "response": "a method to retrieve byte data of appdata record with the specified key"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove(self):\n        \n        ''' \n            a method to remove all records in the collection\n\n        NOTE:   this method removes all the files in the collection, but the\n                collection folder itself created by oauth2 cannot be removed.\n                only the user can remove access to the app folder\n                \n        :return: string with confirmation of deletion\n        '''\n\n        title = '%s.remove' % self.__class__.__name__\n    \n    # get contents of root\n        for id, name, mimetype in self._list_directory():\n            try:\n                self.drive.delete(fileId=id).execute()\n            except Exception as err:\n                if str(err).find('File not found') > -1:\n                    pass\n                else:\n                    raise DriveConnectionError(title)\n    \n    # return outcome\n        insert = 'collection'\n        if self.collection_name:\n            insert = self.collection_name\n        exit_msg = 'Contents of %s will be removed from Google Drive.' % insert\n        return exit_msg", "response": "a method to remove all records in the collection"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef export(self, storage_client, overwrite=True):\n        \n        '''\n            a method to export all the records in collection to another platform\n            \n        :param storage_client: class object with storage client methods\n        :return: string with exit message\n        '''\n        \n        title = '%s.export' % self.__class__.__name__\n        \n    # validate storage client\n        method_list = [ 'save', 'load', 'list', 'export', 'delete', 'remove', '_import', 'collection_name' ]\n        for method in method_list:\n            if not getattr(storage_client, method, None):\n                from labpack.parsing.grammar import join_words\n                raise ValueError('%s(storage_client=...) must be a client object with %s methods.' % (title, join_words(method_list)))\n            \n    # walk collection folder to find files\n        import os\n        count = 0\n        skipped = 0\n        for file_path, file_id in self._walk():\n            path_segments = file_path.split(os.sep)\n            record_key = os.path.join(*path_segments)\n            record_key = record_key.replace('\\\\','/')\n            \n    # retrieve data and metadata\n            try:\n                record_data = self.drive.get_media(fileId=file_id).execute()\n            except:\n                raise DriveConnectionError(title)\n            try:\n                file = self.drive.get(fileId=file_id, fields='modifiedTime').execute()\n                client_modified = file.get('modifiedTime', '')\n            except:\n                raise DriveConnectionError(title)\n            \n    # import record into storage client\n            last_modified = 0.0\n            if client_modified:\n                from labpack.records.time import labDT\n                last_modified = labDT.fromISO(client_modified).epoch()\n            outcome = storage_client._import(record_key, record_data, overwrite=overwrite, last_modified=last_modified)\n            if outcome:\n                count += 1\n            else:\n                skipped += 1\n            \n    # report outcome\n        plural = ''\n        skip_insert = ''\n        new_folder = storage_client.collection_name\n        if count != 1:\n            plural = 's'\n        if skipped > 0:\n            skip_plural = ''\n            if skipped > 1:\n                skip_plural = 's'\n            skip_insert = ' %s record%s skipped to avoid overwrite.' % (str(skipped), skip_plural)\n        exit_msg = '%s record%s exported to %s.%s' % (str(count), plural, new_folder, skip_insert)\n        return exit_msg", "response": "a method to export all the records in collection to another platform"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntries to read a message from the buffered data.", "response": "def read_message(self):\n        \"\"\"Try to read a message from the buffered data. A message is defined \n        as a 32-bit integer size, followed that number of bytes. First we try\n        to non-destructively read the integer. Then, we try to non-\n        destructively read the remaining bytes. If both are successful, we then\n        go back to remove the span from the front of the buffers.\n        \"\"\"\n\n        with self.__class__.__locker:\n            result = self.__passive_read(4)\n            if result is None:\n                return None\n\n            (four_bytes, last_buffer_index, updates1) = result\n            (length,) = unpack('>I', four_bytes)\n\n            result = self.__passive_read(length, last_buffer_index)\n            if result is None:\n                return None\n\n            (data, last_buffer_index, updates2) = result\n\n            # If we get here, we found a message. Remove it from the buffers.\n\n            for updates in (updates1, updates2):\n                for update in updates:\n                    (buffer_index, buffer_, length_consumed) = update\n                    self.__buffers[buffer_index] = buffer_ if buffer_ else ''\n                    self.__length -= length_consumed\n\n            self.__read_buffer_index = last_buffer_index\n            self.__hits += 1\n        \n            if self.__hits >= self.__class__.__cleanup_interval:\n                self.__cleanup()\n                self.__hits = 0\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __passive_read(self, length, start_buffer_index=None):\n\n        if length > self.__length:\n            return None\n    \n        with self.__class__.__locker:\n            collected = []\n            need_bytes = length\n            i = start_buffer_index if start_buffer_index is not None \\\n                                   else self.__read_buffer_index\n\n            updates = []\n            while need_bytes > 0:\n                len_current_buffer = len(self.__buffers[i])\n                \n                if need_bytes >= len_current_buffer:\n                    # We need at least as many bytes as are in the current \n                    # buffer. Consume them all.\n                \n                    collected.append(self.__buffers[i][:])\n                    updates.append((i, [], len_current_buffer))\n                    need_bytes -= len_current_buffer\n                else:\n                    # We need less bytes than are in the current buffer. Slice\n                    # the current buffer in half, even if the data isn't going\n                    # anywhere [yet].\n                \n                    first_half = self.__buffers[i][:need_bytes]\n                    second_half = self.__buffers[i][need_bytes:]\n\n                    self.__buffers[i] = first_half\n                    self.__buffers.insert(i + 1, second_half)\n                    \n                    # We only mark the buffer that came from the first half as\n                    # having an update (the second half of the buffer wasn't \n                    # touched).\n                    collected.append(first_half)\n                    updates.append((i, [], need_bytes))\n                    need_bytes = 0\n\n                i += 1\n\n        sequence = ''.join(collected)\n\n        return (sequence, i, updates)", "response": "Read the given length of bytes and return the sequence number and index of the next bytes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclip buffers that have been completely exhausted.", "response": "def __cleanup(self):\n        \"\"\"Clip buffers that the top of our list that have been completely \n        exhausted.\n        \"\"\"\n# TODO: Test this.\n        with self.__class__.__locker:\n\n            while self.__read_buffer_index > 0:\n                del self.__buffers[0]\n                self.__read_buffer_index -= 1"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites a log message to the logger destination.", "response": "def _write(self, level, correlation_id, error, message):\n        \"\"\"\n        Writes a log message to the logger destination.\n\n        :param level: a log level.\n\n        :param correlation_id: (optional) transaction id to trace execution through call chain.\n\n        :param error: an error object associated with this message.\n\n        :param message: a human-readable message to log.\n        \"\"\"\n        if (self._level < level):\n            return\n\n        output = \"[\"\n        output += correlation_id if correlation_id != None else \"---\"\n        output += \":\"\n        output += LogLevelConverter.to_string(level)\n        output += \":\"\n        output += datetime.datetime.utcnow().isoformat()\n        output += \"] \"\n\n        output += message\n\n        if error != None:\n            if len(message) == 0:\n                output += \"Error: \"\n            else:\n                output += \": \"\n\n            output += self._compose_error(error)\n\n        output += \"\\n\"\n\n        if level >= LogLevel.Fatal and level <= LogLevel.Warn:\n            sys.stderr.write(output)\n        else:\n            sys.stdout.write(output)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ls(dataset_uri):\n    dataset = dtoolcore.DataSet.from_uri(dataset_uri)\n    for overlay_name in dataset.list_overlay_names():\n        click.secho(overlay_name)", "response": "List all overlays in the dataset."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nshowing the content of a specific overlay.", "response": "def show(dataset_uri, overlay_name):\n    \"\"\"\n    Show the content of a specific overlay.\n    \"\"\"\n    dataset = dtoolcore.DataSet.from_uri(dataset_uri)\n    try:\n        overlay = dataset.get_overlay(overlay_name)\n    except:  # NOQA\n        click.secho(\n            \"No such overlay: {}\".format(overlay_name),\n            fg=\"red\",\n            err=True\n        )\n        sys.exit(11)\n\n    formatted_json = json.dumps(overlay, indent=2)\n    colorful_json = pygments.highlight(\n        formatted_json,\n        pygments.lexers.JsonLexer(),\n        pygments.formatters.TerminalFormatter())\n    click.secho(colorful_json, nl=False)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the canonicalized header name for the header name provided as an argument.", "response": "def canonicalize_header(key):\n    \"\"\"Returns the canonicalized header name for the header name provided as an argument.\n    The canonicalized header name according to the HTTP RFC is Kebab-Camel-Case.\n\n    Keyword arguments:\n    key -- the name of the header\n    \"\"\"\n    bits = key.split('-')\n    for idx, b in enumerate(bits):\n        bits[idx] = b.capitalize()\n    return '-'.join(bits)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nvalidate the URL object. Returns True or False based on this.", "response": "def validate(self):\n        \"\"\"Validates the URL object. The URL object is invalid if it does not represent an absolute URL.\n        Returns True or False based on this.\n        \"\"\"\n        if (self.scheme is None or self.scheme != '') \\\n          and (self.host is None or self.host == ''):\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef request_uri(self):\n        result = '/{0}'.format(self.path.lstrip('/'))\n        if self.query is not None and self.query != '' and self.query != {}:\n            result += '?{0}'.format(self.encoded_query())\n        if self.fragment is not None and self.fragment != '':\n            result += '#{0}'.format(self.fragment)\n        return result", "response": "Returns the request URI of the URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef encoded_query(self):\n        if self.query is not None and self.query != '' and self.query != {}:\n            try:\n                return urlencode(self.query, doseq=True, quote_via=urlquote)\n            except TypeError:\n                return '&'.join([\"{0}={1}\".format(urlquote(k), urlquote(self.query[k][0])) for k in self.query])\n        else:\n            return ''", "response": "Returns the encoded query string of the URL."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef with_url(self, url):\n        self.url = URL(url)\n        self.header[\"Host\"] = self.url.host\n        return self", "response": "Sets the request s URL and returns the request itself."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset a header on the request and returns the request itself.", "response": "def with_header(self, key, value):\n        \"\"\"Sets a header on the request and returns the request itself.\n        The header key will be canonicalized before use. (see also: canonicalize_header)\n\n        Keyword arguments:\n        key -- the header's name\n        value -- the string value for the header\n        \"\"\"\n        self.header[canonicalize_header(key)] = value\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef with_headers(self, headers):\n        for key, value in headers.items():\n            self.with_header(key, value)\n        return self", "response": "Sets multiple headers on the request and returns the request itself."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the time headers used by Acquia signature versions to the appropriate value and returns the request itself.", "response": "def with_time(self):\n        \"\"\"Sets the time headers used by Acquia signature versions to the appropriate value and returns the request itself.\n        These headers are X-Authorization-Timestamp (v2) and Date (v1).\n        \"\"\"\n        self.header[\"X-Authorization-Timestamp\"] = str(int(time.time()))\n        self.header[\"Date\"] = str(int(time.time()))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the request body to the provided value and returns the request itself.", "response": "def with_body(self, body):\n        # @todo take encoding into account\n        \"\"\"Sets the request body to the provided value and returns the request itself.\n\n        Keyword arguments:\n        body -- A UTF-8 string or bytes-like object which represents the request body.\n        \"\"\"\n        try:\n            self.body = body.encode('utf-8')\n        except:\n            try:\n                self.body = bytes(body)\n            except:\n                raise ValueError(\"Request body must be a string or bytes-like object.\")\n        hasher = hashlib.sha256()\n        hasher.update(self.body)\n        digest = base64.b64encode(hasher.digest()).decode('utf-8')\n        self.with_header(\"X-Authorization-Content-Sha256\", digest)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef with_json_body(self, body):\n        try:\n            self.with_body(json.dumps(dict(body)))\n        except:\n            try:\n                self.with_body(body)\n            except:\n                raise ValueError(\"Request body must be a string, bytes object, or a dict structure corresponding to a valid JSON.\")\n        self.header[\"Content-Type\"] = \"application/json\"\n        return self", "response": "Sets the request body to the provided value and returns the request itself."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the requested header or an empty string if the header is not set.", "response": "def get_header(self, key):\n        \"\"\"Returns the requested header, or an empty string if the header is not set.\n\n        Keyword arguments:\n        key -- The header name. It will be canonicalized before use.\n        \"\"\"\n        key = canonicalize_header(key)\n        if key in self.header:\n            return self.header[key]\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef do(self):\n        data = None\n        if self.body is not None and self.body != b'':\n            data = self.body\n        return requests.request(self.method, str(self.url), data=data, headers=self.header)", "response": "Executes the request represented by this object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconnect sysout to the qtSignal", "response": "def setWriteToShell(self, writeToShell=True):\r\n        \"\"\"connect sysout to the qtSignal\"\"\"\r\n        if writeToShell and not self._connected:\r\n            self.message.connect(self.stdW)\r\n            self._connected = True\r\n        elif not writeToShell and self._connected:\r\n            try:\r\n                self.message.disconnect(self.stdW)\r\n            except TypeError:\r\n                pass  # was not connected\r\n            self._connected = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a Django orm query from json input", "response": "def query(self, jsonq, operator=\"and\", count=False):\n        \"\"\"\n        returns a Django orm query from json input:\n        {\n        \"app\": \"auth\",\n        \"model\": \"User\",\n        \"filters\": {\n            \"is_superuser\": False,\n            \"username__icontains\": \"foo\"\n        }\n        \"\"\"\n        model = self._get_model(jsonq[\"app\"], jsonq[\"model\"])\n        fdict = jsonq[\"filters\"]\n        filters = []\n        try:\n            q = model.objects.none()\n        except Exception as e:\n            self.err(e)\n        for label in fdict:\n            kwargs = {label: fdict[label]}\n            filters.append(Q(**kwargs))\n        if filters == []:\n            try:\n                q = model.objects.all()\n                return q\n            except Exception as e:\n                self.err(e)\n        else:\n            fq = Q()\n            for f in filters:\n                if operator == \"and\":\n                    fq = fq & f\n                elif operator == \"or\":\n                    fq = fq | f\n            if count is False:\n                try:\n                    q = model.objects.filter(fq)\n                except Exception as e:\n                    self.err(e)\n            else:\n                try:\n                    q = model.objects.filter(fq).count()\n                except Exception as e:\n                    self.err(e)\n        return q"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _models(self, appname):\n        try:\n            app = self._get_app(appname)\n        except Exception as e:\n            self.err(\"Can not get app \" + appname, e)\n            return\n        if appname not in self.appnames:\n            self.err(\"App \" + appname + \" not found in settings\")\n            return\n        models = self._get_models(app)\n        return models", "response": "Get the models for a given app name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting app object from app name", "response": "def _get_app(self, appname):\n        \"\"\"\n        returns app object or None\n        \"\"\"\n        try:\n            app = APPS.get_app_config(appname)\n        except Exception as e:\n            self.err(e)\n            return\n        return app"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_model(self, appname, modelname):\n        app = self._get_app(appname)\n        models = app.get_models()\n        model = None\n        for mod in models:\n            if mod.__name__ == modelname:\n                model = mod\n                return model\n        msg = \"Model \" + modelname + \" not found\"", "response": "Get the model object for the given modelname."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_models(self, app):\n        try:\n            app_models = app.get_models()\n            appmods = []\n            for model in app_models:\n                appmods.append(model)\n        except Exception as e:\n            self.err(e)\n            return\n        return appmods", "response": "Get the list of models from the app"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncounting the number of items in the model", "response": "def _count_model(self, model):\n        \"\"\"\n        return model count\n        \"\"\"\n        try:\n            res = model.objects.all().count()\n        except Exception as e:\n            self.err(e)\n            return\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds the setup. py file name.", "response": "def find_setup_file_name(self):  # type: () ->None\n        \"\"\"\n        Usually setup.py or setup\n        \"\"\"\n        for file_path in [\n            x\n            for x in os.listdir(\".\")\n            if os.path.isfile(x) and x in [\"setup.py\", \"setup\"]\n        ]:\n            if self.file_opener.is_python_inside(file_path):\n                self.setup_file_name = file_path\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading any file and deal with encoding.", "response": "def _read_file(self, file):  # type: (str) -> Optional[str]\n        \"\"\"\n        Read any file, deal with encoding.\n        :param file:\n        :return:\n        \"\"\"\n        if not self.setup_file_name:\n            return None\n        source = None\n        if os.path.isfile(file):\n            with self.file_opener.open_this(file, \"r\") as setup_py:\n                source = setup_py.read()\n        return source"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_setup_py_source(self):  # type: () -> None\n        if not self.setup_file_name:\n            self.setup_source = \"\"\n        if not self.setup_source:\n            self.setup_source = self._read_file(self.setup_file_name)", "response": "Read setup. py to string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse likley module name from setup. py", "response": "def parse_package_name(self):  # type: () -> Optional[str]\n        \"\"\"\n        Extract likley module name from setup.py args\n        :return:\n        \"\"\"\n        if not self.setup_source:\n            return None\n        for row in self.setup_source.split(\"\\n\"):\n            simplified_row = row.replace(\" \", \"\").replace(\"'\", '\"').strip(\" \\t\\n\")\n            if \"name=\" in simplified_row:\n                if '\"' in simplified_row:\n                    return simplified_row.split('\"')[1]\n\n        name = self.execute_setup_name()\n        if name:\n            return name\n\n        return \"\""}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef execute_setup_name(self):  # type: () -> Optional[str]\n        try:\n            name = execute_get_text(\"python setup.py --name\")\n        except subprocess.CalledProcessError:\n            # setup.py is not always in an executable state\n            return None\n        if not name:\n            return None\n        name = name.strip(\" \\n\\t\")\n        if \" \" in name or \"\\n\" in name:\n            # likely includes print() that ruin results\n            return None\n        return name", "response": "Runs code to get the name of the current user s log file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_central_module(self):  # type: () -> Optional[str]\n        # find modules.\n        mf = ModuleFinder(self.file_opener)\n\n        candidates = mf.find_by_any_method()\n\n        sub_modules = []\n        root_modules = []\n\n        for candidate in candidates:\n            if \".\" in candidate:\n                sub_modules.append(candidate)\n            else:\n                root_modules.append(candidate)\n\n        candidates = root_modules\n\n        # remove junk. Junk only has meaning in the sense of finding the central module.\n        candidates = self.remove_likely_non_central(candidates)\n        if len(candidates) == 1:\n            return candidates[0]\n\n        # see if there is 1 out of the many with same name pkg_foo, module_foo\n        if self.package_name:\n            if self.package_name in candidates:\n                return self.package_name\n\n        # I don't understand the _ to - transformations.\n        if self.package_name:\n            if self.package_name.replace(\"-\", \"_\") in candidates:\n                return self.package_name.replace(\"-\", \"_\")\n\n        if self.package_name:\n            if self.package_name.replace(\"-\", \"\") in candidates:\n                return self.package_name.replace(\"-\", \"\")\n\n        if self.package_name:\n            if self.package_name.replace(\"_\", \"\") in candidates:\n                return self.package_name.replace(\"_\", \"\")\n        # see if there is 1 out of the many with version in sync- pkg_foo v1.2.3, module_bar v1.2.3\n        # TODO:\n\n        return None", "response": "Finds the central module that matches the package name and version."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_likely_non_central(self, candidates):  # type: (List[str]) -> List[str]\n        if len(candidates) > 1:\n            for unlikely in [\n                \"test\",\n                \"tests\",\n                \"example\",\n                \"examples\",\n                \"demo\",\n                \"demos\",\n                \"test_files\",\n                \"doc\",\n                \"docs\",\n            ]:\n                if unlikely in candidates:\n                    logger.warning(\"Assuming {0} is not the project\".format(unlikely))\n                    candidates.remove(unlikely)\n                for candidate in candidates:\n                    if candidate.startswith(unlikely + \".\"):\n                        logger.warning(\n                            \"Assuming {0} is not the project\".format(candidate)\n                        )\n                        candidates.remove(candidate)\n        return candidates", "response": "Removes the unlikely ones from a list of packages that are not central."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sent_tokenize(context):\n\n    # Define the regular expression\n    paired_symbols = [(\"(\", \")\"),\n                  (\"[\", \"]\"),\n                  (\"{\", \"}\")]\n    paired_patterns = [\"%s.*?%s\" % (re.escape(lt), re.escape(rt)) for lt, rt in paired_symbols]\n    number_pattern = ['\\d+\\.\\d+']\n    arr_pattern = ['(?: \\w\\.){2,3}|(?:\\A|\\s)(?:\\w\\.){2,3}|[A-Z]\\. [a-z]|\\svs\\. |et al\\.|Fig\\. \\d|approx\\.|(?:Prof|Dr)\\. (?:[A-Z]\\.)?']\n\n    # Find the string which matches the above pattern, and remove than from the context, to get a stem string\n    escape_re = re.compile(\"|\".join(paired_patterns + number_pattern + arr_pattern))\n    escapes = escape_re.findall(context)\n    escaped_stem = escape_re.sub('{}', context)\n\n    escaped_escaped_stem = escaped_stem.replace('{','{{').replace('}', '}}')\n\n    # Find the linebreaks\n    sent_re = re.compile(r'([A-Z0-9]..+?(?:[.!?]\\s+|[\\n$]+))')\n    linebreaks = sent_re.findall(escaped_escaped_stem)\n    sent_stem = sent_re.sub(r'\\1###linebreak###', escaped_escaped_stem)\n    recovered_sent_stem = sent_stem.replace('{{}}', '{}')\n    result = recovered_sent_stem.format(*escapes)\n    return [r for r in result.split('###linebreak###') if r is not '']", "response": "Takes a string and returns a list of sentences."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clause_tokenize(sentence):\n    clause_re = re.compile(r'((?:\\S+\\s){2,}\\S+,|(?:\\S+\\s){3,}(?=\\((?:\\S+\\s){2,}\\S+\\)))')\n    clause_stem = clause_re.sub(r'\\1###clausebreak###', sentence)\n    return [c for c in clause_stem.split('###clausebreak###') if c != '']", "response": "Split on comma or parenthesis if there are more then three words for each clause\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef word_tokenize(sentence):\n    date_pattern = r'\\d\\d(\\d\\d)?[\\\\-]\\d\\d[\\\\-]\\d\\d(\\d\\d)?'\n    number_pattern = r'[\\+-]?(\\d+\\.\\d+|\\d{1,3},(\\d{3},)*\\d{3}|\\d+)'\n    arr_pattern = r'(?: \\w\\.){2,3}|(?:\\A|\\s)(?:\\w\\.){2,3}|[A-Z]\\. [a-z]'\n    word_pattern = r'[\\w]+'\n    non_space_pattern = r'[{}]|\\w'.format(re.escape('!\"#$%&()*,./:;<=>?@[\\]^_-`{|}~'))\n    space_pattern = r'\\s'\n    anything_pattern = r'.'\n    patterns = [date_pattern, number_pattern, arr_pattern, word_pattern, non_space_pattern, space_pattern, anything_pattern]\n    big_pattern = r'|'.join([('(' + pattern + ')') for pattern in patterns])\n    for match in re.finditer(big_pattern, sentence):\n        yield match.group(0)", "response": "A generator which yields tokens based on the given sentence without deleting anything."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef slim_stem(token):\n    target_sulfixs = ['ic', 'tic', 'e', 'ive', 'ing', 'ical', 'nal', 'al', 'ism', 'ion', 'ation', 'ar', 'sis', 'us', 'ment']\n    for sulfix in sorted(target_sulfixs, key=len, reverse=True):\n        if token.endswith(sulfix):\n            token = token[0:-len(sulfix)]\n            break\n    if token.endswith('ll'):\n        token = token[:-1]\n    return token", "response": "A very simple stemmer for entity of GO stemming."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ngram(n, iter_tokens):\n    z = len(iter_tokens)\n    return (iter_tokens[i:i+n] for i in range(z-n+1))", "response": "Return a generator of n - grams from an iterable"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate unigram bigram trigram... and the max - gram...", "response": "def power_ngram(iter_tokens):\n    \"\"\"\n    Generate unigram, bigram, trigram ... and the max-gram,\n    different from powerset(), this function will not generate skipped combinations such as (1,3)\n    \"\"\"\n    return chain.from_iterable(ngram(j, iter_tokens) for j in range(1, len(iter_tokens) + 1))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_url(self, bucket=None, asset_key=None, asset_url=None, operations=['identity'], secure=True):\n        if len(operations) < 1:\n            raise OperationError('You didn\\'t provide any operations to perform on the image')\n\n        protocol = 'https://' if secure else 'http://'\n        base_url = '%s%s' % (protocol, self.cloudfront_hostname)\n\n        if asset_key is not None:\n            if bucket is None:\n                if self.default_bucket is None:\n                    raise OperationError('No S3 bucket has been provided.')\n                else:\n                    bucket = self.default_bucket\n\n            path = '/%s/%s/%s/%s' % (\n                bucket,\n                asset_key,\n                '/'.join(operations),\n                self.account_id,\n            )\n\n            request_hash = self._generate_hash(path)\n\n            adept_url = ('%s%s/%s' % (\n                base_url,\n                path,\n                request_hash)\n            )\n\n        elif asset_url is not None:\n\n            path = '/loader/%s/%s' % (\n                '/'.join(operations),\n                self.account_id\n            )\n            loader_uri = '%s?url=%s' % (path, asset_url)\n            request_hash = self._generate_hash(loader_uri)\n\n            adept_url = '%s%s/%s?url=%s' % (\n                base_url,\n                path,\n                request_hash,\n                urlquote(asset_url)\n            )\n        else:\n            raise OperationError(\"Asset key or URL must be provided\")\n\n        return adept_url", "response": "Generate a URL for an image."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nliking where but returns an iterator.", "response": "def iwhere( filename ):\r\n    \"\"\" Like where() but returns an iterator. \"\"\"\r\n\r\n    possible_paths =      _gen_possible_matches( filename )\r\n    existing_file_paths = filter( os.path.isfile, possible_paths )\r\n    return existing_file_paths"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding the passwords to the parameters dictionary.", "response": "def set_overcloud_passwords(self, parameters, parsed_args):\n        \"\"\"Add passwords to the parameters dictionary\n\n        :param parameters: A dictionary for the passwords to be added to\n        :type parameters: dict\n        \"\"\"\n\n        undercloud_ceilometer_snmpd_password = utils.get_config_value(\n            \"auth\", \"undercloud_ceilometer_snmpd_password\")\n\n        self.passwords = passwords = utils.generate_overcloud_passwords()\n        ceilometer_pass = passwords['OVERCLOUD_CEILOMETER_PASSWORD']\n        ceilometer_secret = passwords['OVERCLOUD_CEILOMETER_SECRET']\n        if parsed_args.templates:\n            parameters['AdminPassword'] = passwords['OVERCLOUD_ADMIN_PASSWORD']\n            parameters['AdminToken'] = passwords['OVERCLOUD_ADMIN_TOKEN']\n            parameters['CeilometerPassword'] = ceilometer_pass\n            parameters['CeilometerMeteringSecret'] = ceilometer_secret\n            parameters['CinderPassword'] = passwords[\n                'OVERCLOUD_CINDER_PASSWORD']\n            parameters['GlancePassword'] = passwords[\n                'OVERCLOUD_GLANCE_PASSWORD']\n            parameters['HeatPassword'] = passwords['OVERCLOUD_HEAT_PASSWORD']\n            parameters['HeatStackDomainAdminPassword'] = passwords[\n                'OVERCLOUD_HEAT_STACK_DOMAIN_PASSWORD']\n            parameters['NeutronPassword'] = passwords[\n                'OVERCLOUD_NEUTRON_PASSWORD']\n            parameters['NovaPassword'] = passwords['OVERCLOUD_NOVA_PASSWORD']\n            parameters['SwiftHashSuffix'] = passwords['OVERCLOUD_SWIFT_HASH']\n            parameters['SwiftPassword'] = passwords['OVERCLOUD_SWIFT_PASSWORD']\n            parameters['SnmpdReadonlyUserPassword'] = (\n                undercloud_ceilometer_snmpd_password)\n        else:\n            parameters['Controller-1::AdminPassword'] = passwords[\n                'OVERCLOUD_ADMIN_PASSWORD']\n            parameters['Controller-1::AdminToken'] = passwords[\n                'OVERCLOUD_ADMIN_TOKEN']\n            parameters['Compute-1::AdminPassword'] = passwords[\n                'OVERCLOUD_ADMIN_PASSWORD']\n            parameters['Controller-1::SnmpdReadonlyUserPassword'] = (\n                undercloud_ceilometer_snmpd_password)\n            parameters['Cinder-Storage-1::SnmpdReadonlyUserPassword'] = (\n                undercloud_ceilometer_snmpd_password)\n            parameters['Swift-Storage-1::SnmpdReadonlyUserPassword'] = (\n                undercloud_ceilometer_snmpd_password)\n            parameters['Compute-1::SnmpdReadonlyUserPassword'] = (\n                undercloud_ceilometer_snmpd_password)\n            parameters['Controller-1::CeilometerPassword'] = ceilometer_pass\n            parameters[\n                'Controller-1::CeilometerMeteringSecret'] = ceilometer_secret\n            parameters['Compute-1::CeilometerPassword'] = ceilometer_pass\n            parameters[\n                'Compute-1::CeilometerMeteringSecret'] = ceilometer_secret\n            parameters['Controller-1::CinderPassword'] = (\n                passwords['OVERCLOUD_CINDER_PASSWORD'])\n            parameters['Controller-1::GlancePassword'] = (\n                passwords['OVERCLOUD_GLANCE_PASSWORD'])\n            parameters['Controller-1::HeatPassword'] = (\n                passwords['OVERCLOUD_HEAT_PASSWORD'])\n            parameters['Controller-1::HeatStackDomainAdminPassword'] = (\n                passwords['OVERCLOUD_HEAT_STACK_DOMAIN_PASSWORD'])\n            parameters['Controller-1::NeutronPassword'] = (\n                passwords['OVERCLOUD_NEUTRON_PASSWORD'])\n            parameters['Compute-1::NeutronPassword'] = (\n                passwords['OVERCLOUD_NEUTRON_PASSWORD'])\n            parameters['Controller-1::NovaPassword'] = (\n                passwords['OVERCLOUD_NOVA_PASSWORD'])\n            parameters['Compute-1::NovaPassword'] = (\n                passwords['OVERCLOUD_NOVA_PASSWORD'])\n            parameters['Controller-1::SwiftHashSuffix'] = (\n                passwords['OVERCLOUD_SWIFT_HASH'])\n            parameters['Controller-1::SwiftPassword'] = (\n                passwords['OVERCLOUD_SWIFT_PASSWORD'])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the ID for the current deployed overcloud stack if it exists.", "response": "def _get_stack(self, orchestration_client, stack_name):\n        \"\"\"Get the ID for the current deployed overcloud stack if it exists.\"\"\"\n\n        try:\n            stack = orchestration_client.stacks.get(stack_name)\n            self.log.info(\"Stack found, will be doing a stack update\")\n            return stack\n        except HTTPNotFound:\n            self.log.info(\"No stack found, will be doing a stack create\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeploys a stack to the Baremetal nodes and do a stack update", "response": "def _heat_deploy(self, stack, stack_name, template_path, parameters,\n                     environments, timeout):\n        \"\"\"Verify the Baremetal nodes are available and do a stack update\"\"\"\n\n        self.log.debug(\"Processing environment files\")\n        env_files, env = (\n            template_utils.process_multiple_environments_and_files(\n                environments))\n\n        self.log.debug(\"Getting template contents\")\n        template_files, template = template_utils.get_template_contents(\n            template_path)\n\n        files = dict(list(template_files.items()) + list(env_files.items()))\n\n        clients = self.app.client_manager\n        orchestration_client = clients.rdomanager_oscplugin.orchestration()\n\n        self.log.debug(\"Deploying stack: %s\", stack_name)\n        self.log.debug(\"Deploying template: %s\", template)\n        self.log.debug(\"Deploying parameters: %s\", parameters)\n        self.log.debug(\"Deploying environment: %s\", env)\n        self.log.debug(\"Deploying files: %s\", files)\n\n        stack_args = {\n            'stack_name': stack_name,\n            'template': template,\n            'parameters': parameters,\n            'environment': env,\n            'files': files\n        }\n\n        if timeout:\n            stack_args['timeout_mins'] = timeout\n\n        if stack is None:\n            self.log.info(\"Performing Heat stack create\")\n            orchestration_client.stacks.create(**stack_args)\n        else:\n            self.log.info(\"Performing Heat stack update\")\n            # Make sure existing parameters for stack are reused\n            stack_args['existing'] = 'true'\n            orchestration_client.stacks.update(stack.id, **stack_args)\n\n        create_result = utils.wait_for_stack_ready(\n            orchestration_client, stack_name)\n        if not create_result:\n            if stack is None:\n                raise Exception(\"Heat Stack create failed.\")\n            else:\n                raise Exception(\"Heat Stack update failed.\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _pre_heat_deploy(self):\n        clients = self.app.client_manager\n        compute_client = clients.compute\n\n        self.log.debug(\"Checking hypervisor stats\")\n        if utils.check_hypervisor_stats(compute_client) is None:\n            raise exceptions.DeploymentError(\n                \"Expected hypervisor stats not met\")\n        return True", "response": "Setup before the Heat stack create or update has been done."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeploying the fixed templates in TripleO Heat Templates", "response": "def _deploy_tripleo_heat_templates(self, stack, parsed_args):\n        \"\"\"Deploy the fixed templates in TripleO Heat Templates\"\"\"\n        clients = self.app.client_manager\n        network_client = clients.network\n\n        parameters = self._update_paramaters(\n            parsed_args, network_client, stack)\n\n        utils.check_nodes_count(\n            self.app.client_manager.rdomanager_oscplugin.baremetal(),\n            stack,\n            parameters,\n            {\n                'ControllerCount': 1,\n                'ComputeCount': 1,\n                'ObjectStorageCount': 0,\n                'BlockStorageCount': 0,\n                'CephStorageCount': 0,\n            }\n        )\n\n        tht_root = parsed_args.templates\n\n        print(\"Deploying templates in the directory {0}\".format(\n            os.path.abspath(tht_root)))\n\n        self.log.debug(\"Creating Environment file\")\n        env_path = utils.create_environment_file()\n\n        if stack is None:\n            self.log.debug(\"Creating Keystone certificates\")\n            keystone_pki.generate_certs_into_json(env_path, False)\n\n        resource_registry_path = os.path.join(tht_root, RESOURCE_REGISTRY_NAME)\n\n        environments = [resource_registry_path, env_path]\n        if parsed_args.rhel_reg:\n            reg_env = self._create_registration_env(parsed_args)\n            environments.extend(reg_env)\n        if parsed_args.environment_files:\n            environments.extend(parsed_args.environment_files)\n\n        overcloud_yaml = os.path.join(tht_root, OVERCLOUD_YAML_NAME)\n\n        self._heat_deploy(stack, parsed_args.stack, overcloud_yaml, parameters,\n                          environments, parsed_args.timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngather a map of profile capability -> [ node_uuid... ] for ironic boot profiles", "response": "def _collect_node_profiles(self):\n        \"\"\"Gather a map of profile -> [node_uuid] for ironic boot profiles\"\"\"\n        bm_client = self.app.client_manager.rdomanager_oscplugin.baremetal()\n\n        # map of profile capability -> [node_uuid, ...]\n        profile_map = collections.defaultdict(list)\n\n        for node in bm_client.node.list(maintenance=False):\n            node = bm_client.node.get(node.uuid)\n            profiles = re.findall(r'profile:(.*?)(?:,|$)',\n                                  node.properties.get('capabilities', ''))\n            if not profiles:\n                profile_map[None].append(node.uuid)\n            for p in profiles:\n                profile_map[p].append(node.uuid)\n\n        return dict(profile_map)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _check_flavors_exist(self, parsed_args):\n        compute_client = self.app.client_manager.compute\n\n        flavors = {f.name: f for f in compute_client.flavors.list()}\n\n        message = \"Provided --{}-flavor, '{}', does not exist\"\n\n        for target, flavor, scale in (\n            ('control', parsed_args.control_flavor,\n                parsed_args.control_scale),\n            ('compute', parsed_args.compute_flavor,\n                parsed_args.compute_scale),\n            ('ceph-storage', parsed_args.ceph_storage_flavor,\n                parsed_args.ceph_storage_scale),\n            ('block-storage', parsed_args.block_storage_flavor,\n                parsed_args.block_storage_scale),\n            ('swift-storage', parsed_args.swift_storage_flavor,\n                parsed_args.swift_storage_scale),\n        ):\n            if flavor is None or scale == 0:\n                self.log.debug(\"--{}-flavor not used\".format(target))\n            elif flavor not in flavors:\n                self.predeploy_errors += 1\n                self.log.error(message.format(target, flavor))", "response": "Ensure that selected flavors exist in nova."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef well_fields(self, well_x=1, well_y=1):\n        xpath = './ScanFieldArray/ScanFieldData'\n        xpath += _xpath_attrib('WellX', well_x)\n        xpath += _xpath_attrib('WellY', well_y)\n        return self.root.findall(xpath)", "response": "Returns the list of ScanFieldData elements of given well."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef well(self, well_x=1, well_y=1):\n        xpath = './ScanWellData'\n        xpath += _xpath_attrib('WellX', well_x)\n        xpath += _xpath_attrib('WellY', well_y)\n        # assume we find only one\n        return self.well_array.find(xpath)", "response": "ScanWellData of specific well."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the ScanFieldData element of specified field.", "response": "def field(self, well_x=1, well_y=1, field_x=1, field_y=1):\n        \"\"\"ScanFieldData of specified field.\n\n        Parameters\n        ----------\n        well_x : int\n        well_y : int\n        field_x : int\n        field_y : int\n\n        Returns\n        -------\n        lxml.objectify.ObjectifiedElement\n            ScanFieldArray/ScanFieldData element.\n        \"\"\"\n        xpath = './ScanFieldArray/ScanFieldData'\n        xpath += _xpath_attrib('WellX', well_x)\n        xpath += _xpath_attrib('WellY', well_y)\n        xpath += _xpath_attrib('FieldX', field_x)\n        xpath += _xpath_attrib('FieldY', field_y)\n        # assume we find only one\n        return self.root.find(xpath)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_start_position(self):\n        \"Set start position of experiment to position of first field.\"\n        x_start = self.field_array.ScanFieldData.FieldXCoordinate\n        y_start = self.field_array.ScanFieldData.FieldYCoordinate\n\n        # empty template have all fields positions set to zero\n        # --> avoid overwriting start position\n        if x_start != 0 and y_start != 0:\n            self.properties.ScanFieldStageStartPositionX = int(x_start * 1e6) # in um\n            self.properties.ScanFieldStageStartPositionY = int(y_start * 1e6)", "response": "Set start position of experiment to position of first field."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_well_positions(self):\n        for well in self.wells:\n            well_x = well.attrib['WellX']\n            well_y = well.attrib['WellY']\n\n            first_field = self.well_fields(well_x, well_y)[0]\n\n            x_start = first_field.FieldXCoordinate.text\n            y_start = first_field.FieldYCoordinate.text\n\n            well.attrib['FieldXStartCoordinate'] = x_start\n            well.attrib['FieldYStartCoordinate'] = y_start", "response": "Update the X and Y start coordinates of all wells in the current class."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the number of wells in x and y - direction of template.", "response": "def count_of_wells(self):\n        \"\"\"Number of wells in x/y-direction of template.\n\n        Returns\n        -------\n        tuple\n            (xs, ys) number of wells in x and y direction.\n        \"\"\"\n        xs = set([w.attrib['WellX'] for w in self.wells])\n        ys = set([w.attrib['WellY'] for w in self.wells])\n        return (len(xs), len(ys))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nnumbering of fields that have attrib [ JobAssigned ] set to true.", "response": "def count_of_assigned_jobs(self):\n        \"Number of fields that have attrib['JobAssigned'] set to true.\"\n        assigned = len([x.attrib['JobAssigned'] for x in self.fields\n                            if x.attrib['JobAssigned'] == 'true'])\n        return assigned"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate counts of fields and wells.", "response": "def update_counts(self):\n        \"Update counts of fields and wells.\"\n        # Properties.attrib['TotalCountOfFields']\n        fields = str(len(self.fields))\n        self.properties.attrib['TotalCountOfFields'] = fields\n\n        # Properties.CountOfWellsX/Y\n        wx, wy = (str(x) for x in self.count_of_wells)\n\n        self.properties.CountOfWellsX = wx\n        self.properties.CountOfWellsY = wy\n\n        # Properties.attrib['TotalCountOfWells']\n        wells = str(len(self.wells))\n        self.properties.attrib['TotalCountOfWells'] = wells\n\n        # Properties.attrib['TotalAssignedJobs']\n        self.properties.attrib['TotalAssignedJobs'] = str(self.count_of_assigned_jobs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_well(self, well_x, well_y):\n        well = self.well(well_x, well_y)\n        if well == None:\n            raise AttributeError('Well not found')\n        self.well_array.remove(well)\n\n        # remove associated fields\n        fields = self.well_fields(well_x, well_y)\n        for f in fields:\n            self.field_array.remove(f)", "response": "Removes well and associated scan fields."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef field_exists(self, well_x, well_y, field_x, field_y):\n        \"Check if field exists ScanFieldArray.\"\n        return self.field(well_x, well_y, field_x, field_y) != None", "response": "Check if field exists ScanFieldArray.\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_well(self, well_x, well_y, start_x, start_y):\n        # raise ValueError if well already exists\n        if self.well_exists(well_x, well_y):\n            raise ValueError('Well already exists in ScanWellArray')\n\n        if len(self.well_fields(well_x, well_y)) != 0:\n            raise ValueError('Fields belonging to well already exists in ScanFieldArray')\n\n        base_well = deepcopy(self.wells[0])\n\n        # append well to ScanWellArray\n        base_well.attrib['WellX'] = str(well_x)\n        base_well.attrib['WellY'] = str(well_y)\n        base_well.attrib['FieldXStartCoordinate'] = str(start_x)\n        base_well.attrib['FieldYStartCoordinate'] = str(start_y)\n        self.well_array.append(base_well)\n\n        # append fields to ScanFieldArray\n        x_fields = int(self.properties.CountOfScanFieldsX)\n        y_fields = int(self.properties.CountOfScanFieldsY)\n        x_dist = float(self.properties.ScanFieldStageDistanceX) * 1e-6 # in um\n        y_dist = float(self.properties.ScanFieldStageDistanceY) * 1e-6\n        x_label = str(self.properties.TextWellPlateHorizontal[well_x - 1])\n        y_label = str(self.properties.TextWellPlateVertical[well_y - 1])\n\n        for i in range(x_fields):\n            for j in range(y_fields):\n                base_field = deepcopy(self.fields[0])\n\n                base_field.FieldXCoordinate = start_x + i*x_dist\n                base_field.FieldYCoordinate = start_y + j*y_dist\n\n                base_field.attrib['WellX'] = str(well_x)\n                base_field.attrib['WellY'] = str(well_y)\n\n                base_field.attrib['FieldX'] = str(i+1)\n                base_field.attrib['FieldY'] = str(j+1)\n\n                base_field.attrib['LabelX'] = x_label\n                base_field.attrib['LabelY'] = y_label\n\n                self.field_array.append(base_field)", "response": "Adds a well with associated scan fields to the base ScanWellArray and ScanFieldData."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmoves well and associated scan fields. Spacing between fields will be what Properties / ScanFieldStageDistance is set to.", "response": "def move_well(self, well_x, well_y, start_x, start_y):\n        \"\"\"Move well and associated scan fields. Spacing between\n        fields will be what Properties/ScanFieldStageDistance is set to.\n\n        Parameters\n        ----------\n        well_x : int\n        well_y : int\n        start_x : int\n            In meters. FieldXCoordinate of first field in well.\n        start_y : int\n            In meters. FieldYCoordinate of first field in well.\n\n        Raises\n        ------\n        ValueError\n            If specified well or associated fields does not exist.\n        \"\"\"\n        # raise ValueError if well or fields doesnt exist\n        if not self.well_exists(well_x, well_y):\n            raise ValueError('Well not found in ScanWellArray')\n\n        fields = self.well_fields(well_x, well_y)\n        if len(fields) == 0:\n            raise ValueError('Fields belonging to well not found in ScanFieldArray')\n\n        well = self.well(well_x, well_y)\n\n        # update well start coordinate\n        well.attrib['FieldXStartCoordinate'] = str(start_x)\n        well.attrib['FieldYStartCoordinate'] = str(start_y)\n\n        # update fields coordinates\n        x_dist = float(self.properties.ScanFieldStageDistanceX) * 1e-6 # in um\n        y_dist = float(self.properties.ScanFieldStageDistanceY) * 1e-6\n\n        for field in fields:\n            i = int(field.attrib['FieldX'])\n            j = int(field.attrib['FieldY'])\n            field.FieldXCoordinate = start_x + (i - 1)*x_dist\n            field.FieldYCoordinate = start_y + (j - 1)*y_dist"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write(self, filename=None):\n        if not filename:\n            filename = self.filename\n\n        # update time\n        self.properties.CurrentDate = _current_time()\n\n        # set rubber band to true\n        self.properties.EnableRubberBand = 'true'\n\n        # update start position\n        self.update_start_position()\n\n        # update well postions\n        self.update_well_positions()\n\n        # update counts\n        self.update_counts()\n\n        # remove py:pytype attributes\n        objectify.deannotate(self.root)\n\n        # remove namespaces added by lxml\n        for child in self.root.iterchildren():\n            etree.cleanup_namespaces(child)\n\n        xml = etree.tostring(self.root, encoding='utf8',\n                             xml_declaration=True, pretty_print=True)\n\n        # fix format quirks\n        # add carriage return character\n        xml = u'\\r\\n'.join(l.decode(encoding='utf8') for l in xml.splitlines())\n        # add space at \"end/>\" --> \"end />\"\n        xml = re.sub(r'([\"a-z])/>', r'\\1 />', xml)\n        xml = xml.replace(\"version='1.0' encoding='utf8'\", 'version=\"1.0\"')\n\n        with open(filename, 'wb') as f:\n            f.write(xml.encode('utf8'))", "response": "Save template to xml."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npreserves attr data for combining A into B.", "response": "def preserve_attr_data(A, B):\n    '''Preserve attr data for combining B into A.\n    '''\n    for attr, B_data in B.items(): # defined object attrs\n        if getattr(B_data, 'override_parent', True):\n            continue\n        if attr in A:\n            A_data = A[attr]\n            for _attr in getattr(A_data, '_attrs', []): # Attr attrs, like type, default, & doc\n                if hasattr(A_data, _attr):\n                    if getattr(B_data, _attr, None) is not None:\n                        if _attr in getattr(B_data, '_set_by_default', []):\n                            setattr(B_data, _attr, getattr(A_data, _attr))\n                    else:\n                        setattr(B_data, _attr, getattr(A_data, _attr))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef graft(coll, branch, index):\n    '''Graft list branch into coll at index\n    '''\n    pre = coll[:index]\n    post = coll[index:]\n    ret = pre + branch + post\n    return ret", "response": "Graft list branch into coll at index"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the proper metaclasses for the classes in bases", "response": "def metaclasses(bases):\n    ''' Returns 'proper' metaclasses for the classes in bases\n    '''\n    ret = []\n    metas = [type(base) for base in bases]\n    for k,meta in enumerate(metas):\n        if not any(issubclass(m, meta) for m in metas[k+1:]):\n            ret.append(meta)\n\n    if type in ret:\n        ret.remove(type)\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sorted_bases(bases):\n    '''If a class subclasses each class in bases (in that order), then\n    this function returns the would-be python mro for the created class,\n    minus <object>.\n    '''\n    ret = []\n\n    for base in bases:\n        # lst = [super(base), super(super(base)), ..., highest_base]\n        lst = _bases(base)\n\n        if not ret:\n            ret = lst\n        elif not any(b in ret for b in lst):\n            ret += lst\n        else:\n            buf = []\n            for b in lst:\n                if b in ret:\n                    if buf:\n                        ret = graft(ret, buf, ret.index(b))\n                        buf = []\n                else:\n                    buf.append(b)\n            if buf:\n                ret += buf\n\n    return ret", "response": "This function returns the would - be python mro for the created class and the would - be python mro minus <object.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\navoids having to call _update for each intermediate base. Only works for class attr of type UpdateDict.", "response": "def _combine_attr_fast_update(self, attr, typ):\n        '''Avoids having to call _update for each intermediate base.  Only\n        works for class attr of type UpdateDict.\n\n        '''\n        values = dict(getattr(self, attr, {}))\n        \n        for base in self._class_data.bases:\n            vals = dict(getattr(base, attr, {}))\n            preserve_attr_data(vals, values)\n            values = combine(vals, values)\n            \n        setattr(self, attr, typ(values))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cli(ctx, collections, threads, debug):\n    ctx.obj = {\n        'collections': collections,\n        'debug': debug,\n        'threads': threads\n    }\n    if debug:\n        logging.basicConfig(level=logging.DEBUG)\n    else:\n        logging.basicConfig(level=logging.INFO)", "response": "A configurable data and document processing tool."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngive a list of nodes and a set of dependencies find the nodes that satisfy all requirements.", "response": "def resolve_dependencies(nodes):\n    \"\"\" Figure out which order the nodes in the graph can be executed\n    in to satisfy all requirements. \"\"\"\n    done = set()\n    while True:\n        if len(done) == len(nodes):\n            break\n        for node in nodes:\n            if node.name not in done:\n                match = done.intersection(node.requires)\n                if len(match) == len(node.requires):\n                    done.add(node.name)\n                    yield node\n                    break\n        else:\n            raise ConfigException('Invalid requirements in pipeline!')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing configuration in YAML format into a Python dict", "response": "def read_yaml_configuration(filename):\n    '''Parse configuration in YAML format into a Python dict\n\n    :param filename: filename of a file with configuration in YAML format\n    :return: unprocessed configuration object\n    :rtype: dict\n    '''\n    with open(filename, 'r') as f:\n        config = yaml.load(f.read())\n    return config"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndetermine the file type and return it.", "response": "def determine_type(filename):\n    '''Determine the file type and return it.'''\n    ftype = magic.from_file(filename, mime=True).decode('utf8')\n    if ftype == 'text/plain':\n        ftype = 'text'\n    elif ftype == 'image/svg+xml':\n        ftype = 'svg'\n    else:\n        ftype = ftype.split('/')[1]\n    return ftype"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_configuration(config):\n    '''\n    Parse and fix configuration:\n        - processed file should end up being same as input\n        - pipelines should contain CLI commands to run\n        - add missing sections\n\n    :param config: raw configuration object\n    :type config: dict\n    :return: configuration ready for `diet()`\n    :rtype: dict\n    '''\n    new_config = copy.deepcopy(config)\n\n    required_parts = ('commands', 'parameters', 'pipelines')\n    for part in required_parts:\n        new_config.setdefault(part, {})\n\n    # Parse only if it hasn't been parsed yet so it is safe to run it more than\n    # once.\n    if not new_config.get('parsed'):\n        try:\n            # Always end up with input file. If app outputs to a different one,\n            # then replace old one with it\n            for prog in new_config['parameters']:\n                if '{output_file}' in new_config['parameters'][prog]:\n                    new_config['parameters'][prog] += \" && mv '{output_file}' '{file}'\"\n\n            # Build pipelines\n            for label, raw_pipeline in new_config['pipelines'].items():\n                commands = []\n                for app in raw_pipeline:\n                    full_command = \" \".join([new_config['commands'][app],\n                                             new_config['parameters'][app]])\n                    commands.append(full_command)\n                new_config['pipelines'][label] = \" && \".join(commands)\n        except KeyError as e:\n            error_msg = \"Missing key(s) in configuration: {0}.\".format(\n                \",\".join(e.args))\n            raise ConfigurationErrorDietException(error_msg)\n\n        new_config['parsed'] = True\n\n    return new_config", "response": "Parse and fix configuration."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating existing configuration with new values. Used because nested dicts are shallow.", "response": "def update_configuration(orig, new):\n    '''Update existing configuration with new values. Needed because\n    dict.update is shallow and would overwrite nested dicts.\n\n    Function updates sections commands, parameters and pipelines and adds any\n    new items listed in updates.\n\n    :param orig: configuration to update\n    :type orig: dict\n    :param new: new updated values\n    :type orig: dict\n    '''\n    dicts = ('commands', 'parameters', 'pipelines')\n    for key in dicts:\n        if key in new:\n            orig[key].update(new[key])\n\n    for key in new:\n        if key not in dicts:\n            orig[key] = new[key]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if configuration object is not malformed.", "response": "def check_configuration(config):\n    '''Check if configuration object is not malformed.\n\n    :param config: configuration\n    :type config: dict\n    :return: is configuration correct?\n    :rtype: bool\n    '''\n    sections = ('commands', 'parameters', 'pipelines')\n    # Check all sections are there and contain dicts\n    for section in sections:\n        if section not in config:\n            error_msg = 'Error: Section {0} is missing.'.format(section)\n            raise ConfigurationErrorDietException(error_msg)\n        if not isinstance(config[section], dict):\n            error_msg = 'Error: Section {0} is malformed.'.format(section)\n            raise ConfigurationErrorDietException(error_msg)\n\n    # Check every command has a corresponding parameters entry\n    commands_cmds = set(list(config['commands'].keys()))\n    parameters_cmds = set(list(config['parameters'].keys()))\n    if commands_cmds != parameters_cmds:\n        error_msg = ('Every command in commands and parameters section has to '\n                     'have a corresponding entry in the other section.')\n        raise ConfigurationErrorDietException(error_msg)\n\n    # Check pipelines section contains lists as values and each of them only\n    # has entries listed in commands section\n    for cmd in config['pipelines']:\n        pipeline = config['pipelines'][cmd]\n        if not isinstance(pipeline, list):\n            error_msg = ('Error: Pipeline {0} is malformed. Values have to '\n                         'be a list of command names.').format(cmd)\n            raise ConfigurationErrorDietException(error_msg)\n        for tool in pipeline:\n            if tool not in commands_cmds:\n                error_msg = ('Error in pipeline {0}. \"{1}\" cannot be found '\n                             'among commands listed in commands '\n                             'section').format(cmd, tool)\n                raise ConfigurationErrorDietException(error_msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef backup_file(filename, backup_ext):\n    '''\n    Make a file backup if:\n    - backup extension is defined\n    - backup file does not exist yet\n    If backup file exists:\n    - do nothing if it is same\n    - complain loudly otherwise\n\n    Return file name of the back up if successful. None otherwise.\n    '''\n    ext = backup_ext.strip(\" .\")\n    if ext:\n        backup_filename = \".\".join([filename, ext])\n        if not exists(backup_filename):\n            shutil.copyfile(filename, backup_filename)\n        else:\n            if not filecmp.cmp(filename, backup_filename):\n                raise DietException('Cannot make backup because a different'\n                                    'file with that name already exists.')\n        return backup_filename\n    return None", "response": "Make a backup file if it does not already exist."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsqueezing files if there is a pipeline defined for them or leave them be otherwise. :param filename: filename of the file to process :param configuration: configuration dict describing commands and pipelines :type configuration: dict :return: has file changed :rtype: bool", "response": "def diet(filename, configuration):\n    '''\n    Squeeze files if there is a pipeline defined for them or leave them be\n    otherwise.\n\n    :param filename: filename of the file to process\n    :param configuration: configuration dict describing commands and pipelines\n    :type configuration: dict\n    :return: has file changed\n    :rtype: bool\n    '''\n    changed = False\n\n    if not isfile(filename):\n        raise NotFileDietException('Passed filename does not point to a file')\n\n\n    conf = copy.deepcopy(DEFAULT_CONFIG)\n    if not configuration.get('parsed'):\n        new_config = parse_configuration(configuration)\n    else:\n        new_config = configuration\n    update_configuration(conf, new_config)\n\n    filetype = determine_type(filename)\n    squeeze_cmd = conf['pipelines'].get(filetype)\n    if squeeze_cmd:\n        tmpbackup_ext = 'diet_internal'\n        ext = conf.get('backup', tmpbackup_ext)\n        backup = backup_file(filename, ext)\n\n        size = os.stat(filename).st_size\n        new_size = squeeze(squeeze_cmd, filename, backup)\n\n        if not conf.get('keep_processed', False) and new_size > size:\n            copy_if_different(backup, filename)\n\n        # Delete backup, if it was internal\n        if not conf.get('backup'):\n            os.remove(backup)\n        changed = True\n\n    return changed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef countLines(paths, exclude_files_containing=[],\n               exclude_folders_containing=[],\n               exclude_blank_lines=True,\n               exclude_commented_lines=True,\n               count_only_py_files=True):\n    \"\"\"\n    count and return lines  of all *.py files in the given directory/-ies\n\n    [paths] --> file path or list of paths to recursively count code line\n    [exclude_(files/folders)_containing]\n            --> list of phases in folder/file name to be excluded\n                e.g. ['test', 'build']\n    \"\"\"\n    exclude_files_containing = list(exclude_files_containing)\n    #exclude this file:\n    exclude_files_containing.append(\"countLines.py\")\n\n    loclist = []  # number of lines, filepath\n\n    if isinstance(paths, string_types):\n        paths = [paths]\n\n    if not len(paths):\n        raise Exception('need one or more paths to count lines')\n\n    ignore = []  # ignore these signs ...\n    excl = []  # exclude line if first sign is...\n    if exclude_blank_lines or exclude_commented_lines:\n        ignore.extend([' ', '\\t', '\\n'])\n    if exclude_commented_lines:\n        excl.append('#')\n\n    for cur_path in paths:\n        print('Check path %s' % cur_path)\n\n        for pydir, _, pyfiles in os.walk(cur_path):\n            for pyfile in pyfiles:\n                if ((not count_only_py_files or pyfile.endswith(\".py\"))\n                    and not sum([ex in pydir for ex in exclude_folders_containing])\n                    and not sum([ex in pyfile for ex in exclude_files_containing])\n                    ):\n                    totalpath = os.path.join(pydir, pyfile)\n                    lines = open(totalpath, \"r\").readlines()\n                    # count lines:\n                    if ignore:\n                        n = 0\n                        for l in lines:\n                            for i, sign in enumerate(l):\n                                if sign not in ignore:\n                                    if sign in excl:\n                                        i = len(l)\n                                    break\n                            if i and i < len(l):\n                                n += 1\n                    else:\n                        n = len(lines)\n                    loclist.append((n,\n                                    totalpath.split(cur_path)[1]))\n\n    for linenumbercount, filename in loclist:\n        print(\"%05d lines in %s\" % (linenumbercount, filename))\n\n    print(\"\\nTotal: %s lines (%s paths)\" %\n          (sum([x[0] for x in loclist]), len(paths)))", "response": "count and return lines of all. py files in the given directory"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the scheme of the authorization header", "response": "def auth_scheme(self):\n        \"\"\" If an Authorization header is present get the scheme\n\n        It is expected to be the first string in a space separated\n        list & will always be returned lowercase.\n\n        :return: str or None\n        \"\"\"\n\n        try:\n            auth = getattr(self, 'auth')\n            return naked(auth.split(' ')[0]).lower()\n        except (AttributeError, IndexError):\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _init_content_type_params(self):\n\n        ret = {}\n\n        if self.content_type:\n            params = self.content_type.split(';')[1:]\n            for param in params:\n                try:\n                    key, val = param.split('=')\n                    ret[naked(key)] = naked(val)\n                except ValueError:\n                    continue\n\n        return ret", "response": "Return the Content - Type request header parameters into a dict of key = val pairs."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle a match message.", "response": "def _handle_match(client, channel, nick, message, matches):\n    \"\"\" Match stores all channel info. If helga is asked something to\n    stimulate a markov response about channel data, then we shall graciously\n    provide it.\n    \"\"\"\n    generate_interrogative = _CHANNEL_GENERATE_REGEX.match(message)\n    if generate_interrogative:\n        return generate(_DEFAULT_TOPIC, _ADD_PUNCTUATION)\n    current_topic = db.markovify.find_one({'topic': _DEFAULT_TOPIC})\n    if current_topic:\n        message = punctuate(current_topic['text'], message, _ADD_PUNCTUATION)\n    try:\n        ingest(_DEFAULT_TOPIC, message)\n    except ValueError as e:\n        # not good, but this is done every message so just move along\n        print str(e)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef require_root(fn):\n    @wraps(fn)\n    def xex(*args, **kwargs):\n        assert os.geteuid() == 0, \\\n            \"You have to be root to run function '%s'.\" % fn.__name__\n        return fn(*args, **kwargs)\n\n    return xex", "response": "Decorator to make sure that user is root."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef recursive_chmod(path, mode=0755):\n    passwd_reader.set_permissions(path, mode=mode)\n    if os.path.isfile(path):\n        return\n\n    # recursively change mode of all subdirectories\n    for root, dirs, files in os.walk(path):\n        for fn in files + dirs:\n            passwd_reader.set_permissions(os.path.join(root, fn), mode=mode)", "response": "Recursively change the permissions of a directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate lock file filled with settings. LOCK_FILE_CONTENT and PROFTPD_USERS_GID.", "response": "def create_lock_file(path):\n    \"\"\"\n    Create lock file filled with :attr:`LOCK_FILE_CONTENT\n    <ftp.settings.LOCK_FILE_CONTENT>`.\n\n    Args:\n        path (str): Path to the lock file. Made from users home directory and\n                    :attr:`LOCK_FILENAME <ftp.settings.LOCK_FILENAME>`.\n    \"\"\"\n    with open(path, \"w\") as f:\n        f.write(settings.LOCK_FILE_CONTENT)\n\n    passwd_reader.set_permissions(path, gid=settings.PROFTPD_USERS_GID)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a user to the passwd - like file for ProFTPD.", "response": "def add_user(username, password):\n    \"\"\"\n    Adds record to passwd-like file for ProFTPD, creates home directory and\n    sets permissions for important files.\n\n    Args:\n        username (str): User's name.\n        password (str): User's password.\n    \"\"\"\n    assert _is_valid_username(username), \\\n            \"Invalid format of username '%s'!\" % username\n\n    assert username not in passwd_reader.load_users(), \\\n            \"User '%s' is already registered!\" % username\n\n    assert password, \"Password is reqired!\"\n\n    # add new user to the proftpd's passwd file\n    home_dir = settings.DATA_PATH + username\n    sh.ftpasswd(\n        passwd=True,                    # passwd file, not group file\n        name=username,\n        home=home_dir,                  # chroot in DATA_PATH\n        shell=\"/bin/false\",\n        uid=settings.PROFTPD_USERS_GID, # TODO: parse dynamically?\n        gid=settings.PROFTPD_USERS_GID,\n        stdin=True,                 # tell ftpasswd to read password from stdin\n        file=settings.LOGIN_FILE,\n        _in=password\n    )\n\n    # create home dir if not exists\n    if not os.path.exists(home_dir):\n        os.makedirs(home_dir, 0775)\n\n    # I am using PROFTPD_USERS_GID (2000) for all our users - this GID\n    # shouldn't be used by other than FTP users!\n    passwd_reader.set_permissions(home_dir, gid=settings.PROFTPD_USERS_GID)\n    passwd_reader.set_permissions(settings.LOGIN_FILE, mode=0600)\n\n    create_lock_file(home_dir + \"/\" + settings.LOCK_FILENAME)\n\n    reload_configuration()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves user from passwd file and so on..", "response": "def remove_user(username):\n    \"\"\"\n    Remove user, his home directory and so on..\n\n    Args:\n        username (str): User's name.\n    \"\"\"\n    users = passwd_reader.load_users()\n\n    assert username in users, \"Username '%s' not found!\" % username\n\n    # remove user from passwd file\n    del users[username]\n    passwd_reader.save_users(users)\n\n    # remove home directory\n    home_dir = settings.DATA_PATH + username\n    if os.path.exists(home_dir):\n        shutil.rmtree(home_dir)\n\n    reload_configuration()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef change_password(username, new_password):\n    assert username in passwd_reader.load_users(),\\\n           \"Username '%s' not found!\" % username\n\n    sh.ftpasswd(\n        \"--change-password\",\n        passwd=True,        # passwd file, not group file\n        name=username,\n        stdin=True,         # tell ftpasswd to read password from stdin\n        file=settings.LOGIN_FILE,\n        _in=new_password\n    )\n\n    reload_configuration()", "response": "Change password for given username."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting an appropriate path for storing some local data such as TLS credentials.", "response": "def getDataPath(_system=thisSystem, _FilePath=FilePath):\n    \"\"\"Gets an appropriate path for storing some local data, such as TLS\n    credentials.\n\n    If the path doesn't exist, it is created.\n\n    \"\"\"\n    if _system == \"Windows\":\n        pathName = \"~/Crypto101/\"\n    else:\n        pathName = \"~/.crypto101/\"\n\n    path = _FilePath(expanduser(pathName))\n    if not path.exists():\n        path.makedirs()\n\n    return path"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_zoneID(self, headers, zone):\n        zoneIDurl = self.BASE_URL + '?name=' + zone\n        zoneIDrequest = requests.get(zoneIDurl, headers=headers)\n        zoneID = zoneIDrequest.json()['result'][0]['id']\n        return zoneID", "response": "Get the zone id for the zone."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_recordInfo(self, headers, zoneID, zone, records):\n        if 'None' in records: #If ['None'] in record argument, query all.\n            recordQueryEnpoint = '/' + zoneID + '/dns_records&per_page=100'\n            recordUrl = self.BASE_URL + recordQueryEnpoint\n            recordRequest = requests.get(recordUrl, headers=headers)\n            recordResponse = recordRequest.json()['result']\n            dev = []\n            num = 0\n            for value in recordResponse:\n                recordName = recordResponse[num]['name']\n                dev.append(recordName)\n                num = num + 1\n            records = dev\n        updateRecords = []\n        for record in records:\n            if zone in record:\n                recordFullname = record\n            else:\n                recordFullname = record + '.' + zone\n            recordQuery = '/' + zoneID + '/dns_records?name=' + recordFullname\n            recordUrl = self.BASE_URL + recordQuery\n            recordInfoRequest = requests.get(recordUrl, headers=headers)\n            recordInfoResponse = recordInfoRequest.json()['result'][0]\n            recordID = recordInfoResponse['id']\n            recordType = recordInfoResponse['type']\n            recordProxy = str(recordInfoResponse['proxied'])\n            recordContent = recordInfoResponse['content']\n            if recordProxy == 'True':\n                recordProxied = True\n            else:\n                recordProxied = False\n            updateRecords.append([recordID, recordFullname, recordType,\n                recordContent, recordProxied])\n        return updateRecords", "response": "Get the information of the records."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a Fault object created from a ZSI exception object.", "response": "def FaultFromZSIException(ex, actor=None):\n    '''Return a Fault object created from a ZSI exception object.\n    '''\n    mystr = getattr(ex, 'str', None) or str(ex)\n    mytrace = getattr(ex, 'trace', '')\n    elt = '''<ZSI:ParseFaultDetail>\n<ZSI:string>%s</ZSI:string>\n<ZSI:trace>%s</ZSI:trace>\n</ZSI:ParseFaultDetail>\n''' % (mystr, mytrace)\n    if getattr(ex, 'inheader', 0):\n        detail, headerdetail = None, elt\n    else:\n        detail, headerdetail = elt, None\n    return Fault(Fault.Client, 'Unparseable message',\n                actor, detail, headerdetail)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a Fault object created from a Python exception.", "response": "def FaultFromException(ex, inheader, tb=None, actor=None):\n    '''Return a Fault object created from a Python exception.\n\n    <SOAP-ENV:Fault>\n      <faultcode>SOAP-ENV:Server</faultcode>\n      <faultstring>Processing Failure</faultstring>\n      <detail>\n        <ZSI:FaultDetail>\n          <ZSI:string></ZSI:string>\n          <ZSI:trace></ZSI:trace>\n        </ZSI:FaultDetail>\n      </detail>\n    </SOAP-ENV:Fault>\n    '''\n    tracetext = None\n    if tb:\n        try:\n            lines = '\\n'.join(['%s:%d:%s' % (name, line, func)\n                        for name, line, func, text in traceback.extract_tb(tb)])\n        except:\n            pass\n        else:\n            tracetext = lines\n  \n    exceptionName = \"\"\n    try:\n        exceptionName = \":\".join([ex.__module__, ex.__class__.__name__])\n    except: pass\n    elt = ZSIFaultDetail(string=exceptionName + \"\\n\" + str(ex), trace=tracetext)\n    if inheader:\n        detail, headerdetail = None, elt\n    else:\n        detail, headerdetail = elt, None\n    return Fault(Fault.Server, 'Processing Failure',\n                actor, detail, headerdetail)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef FaultFromFaultMessage(ps):\n    '''Parse the message as a fault.\n    '''\n    pyobj = ps.Parse(FaultType.typecode)\n\n    if pyobj.detail == None:  detailany = None\n    else:  detailany = pyobj.detail.any\n\n    return Fault(pyobj.faultcode, pyobj.faultstring,\n                pyobj.faultactor, detailany)", "response": "Parse the message as a fault.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse(page_to_parse):\n    global _parsed\n    if not isinstance(page_to_parse, page.Page):\n        raise TypeError(\"parser.parse requires a parker.Page object.\")\n\n    if page_to_parse.content is None:\n        raise ValueError(\"parser.parse requires a fetched parker.Page object.\")\n\n    try:\n        parsed = _parsed[page_to_parse]\n    except KeyError:\n        parsed = parsedpage.ParsedPage(\n            page=page_to_parse,\n            parsed=PyQuery(page_to_parse.content, parser='html')\n        )\n        _parsed[page_to_parse] = parsed\n\n    return parsed", "response": "Return a parse of page. content. Wraps PyQuery."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_settings(file_path, module_name='', secret_key=''):\r\n\r\n    ''' a method to load data from json valid files\r\n\r\n    :param file_path: string with path to settings file\r\n    :param module_name: [optional] string with name of module containing file path\r\n    :param secret_key: [optional] string with key to decrypt drep file\r\n    :return: dictionary with settings data\r\n    '''\r\n\r\n# validate inputs\r\n    title = 'load_settings'\r\n    try:\r\n        _path_arg = '%s(file_path=%s)' % (title, str(file_path))\r\n    except:\r\n        raise ValueError('%s(file_path=...) must be a string.' % title)\r\n\r\n# find relative path from module\r\n    from os import path\r\n    if module_name:\r\n        try:\r\n            _path_arg = _path_arg.replace(')', ', module_name=%s)' % str(module_name))\r\n        except:\r\n            raise ValueError('%s(module_name=...) must be a string.' % title)\r\n        from importlib.util import find_spec\r\n        module_path = find_spec(module_name).submodule_search_locations[0]\r\n        file_path = path.join(module_path, file_path)\r\n\r\n# validate existence of file\r\n    if not path.exists(file_path):\r\n        raise ValueError('%s is not a valid file path.' % _path_arg)\r\n\r\n# parse extension type\r\n    ext_map = {}\r\n    file_extensions = {\r\n        \"json\": \".+\\\\.json$\",\r\n        \"json.gz\": \".+\\\\.json\\\\.gz$\",\r\n        \"yaml\": \".+\\\\.ya?ml$\",\r\n        \"yaml.gz\": \".+\\\\.ya?ml\\\\.gz$\",\r\n        \"drep\": \".+\\\\.drep$\"\r\n    }\r\n    import re\r\n    for key, value in file_extensions.items():\r\n        file_pattern = re.compile(value)\r\n        if file_pattern.findall(file_path):\r\n            ext_map[key] = True\r\n        else:\r\n            ext_map[key] = False\r\n\r\n# retrieve file details\r\n    if ext_map['json']:\r\n        import json\r\n        try:\r\n            file_data = open(file_path, 'rt')\r\n            file_details = json.loads(file_data.read())\r\n        except:\r\n            raise ValueError('%s is not valid json data.' % _path_arg)\r\n    elif ext_map['yaml']:\r\n        import yaml\r\n        try:\r\n            file_data = open(file_path, 'rt')\r\n            file_details = yaml.load(file_data.read())\r\n        except:\r\n            raise ValueError('%s is not valid yaml data.' % _path_arg)\r\n    elif ext_map['json.gz']:\r\n        import gzip\r\n        import json\r\n        try:\r\n            file_data = gzip.open(file_path, 'rb')\r\n        except:\r\n            raise ValueError('%s is not valid gzip compressed data.' % _path_arg)\r\n        try:\r\n            file_details = json.loads(file_data.read().decode())\r\n        except:\r\n            raise ValueError('%s is not valid json data.' % _path_arg)\r\n    elif ext_map['yaml.gz']:\r\n        import gzip\r\n        import yaml\r\n        try:\r\n            file_data = gzip.open(file_path, 'rb')\r\n        except:\r\n            raise ValueError('%s is not valid gzip compressed data.' % _path_arg)\r\n        try:\r\n            file_details = yaml.load(file_data.read().decode())\r\n        except:\r\n            raise ValueError('%s is not valid yaml data.' % _path_arg)\r\n    elif ext_map['drep']:\r\n        from labpack.compilers import drep\r\n        try:\r\n            file_data = open(file_path, 'rb').read()\r\n            file_details = drep.load(encrypted_data=file_data, secret_key=secret_key)\r\n        except:\r\n            raise ValueError('%s is not valid drep data.' % _path_arg)\r\n    else:\r\n        raise ValueError('%s must be one of %s file types.' % (_path_arg, list(ext_map.keys())))\r\n\r\n    return file_details", "response": "a method to load data from json valid files\r\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save_settings(file_path, record_details, overwrite=False, secret_key=''):\r\n\r\n    ''' a method to save dictionary typed data to a local file\r\n\r\n    :param file_path: string with path to settings file\r\n    :param record_details: dictionary with record details\r\n    :param overwrite: [optional] boolean to overwrite existing file data\r\n    :param secret_key: [optional] string with key to decrypt drep file\r\n    :return: string with file path\r\n    '''\r\n\r\n# validate inputs\r\n    title = 'save_settings'\r\n    try:\r\n        _path_arg = '%s(file_path=%s)' % (title, str(file_path))\r\n    except:\r\n        raise ValueError('%s(file_path=...) must be a string.' % title)\r\n    _details_arg = '%s(record_details={...})' % title\r\n    if not isinstance(record_details, dict):\r\n        raise ValueError('%s must be a dictionary.' % _details_arg)\r\n    if secret_key:\r\n        try:\r\n            _secret_arg = '%s(secret_key=%s)' % (title, str(secret_key))\r\n        except:\r\n            raise ValueError('%s(secret_key=...) must be a string.' % title)\r\n\r\n# parse extension type\r\n    ext_map = {}\r\n    file_extensions = {\r\n        \"json\": \".+\\\\.json$\",\r\n        \"json.gz\": \".+\\\\.json\\\\.gz$\",\r\n        \"yaml\": \".+\\\\.ya?ml$\",\r\n        \"yaml.gz\": \".+\\\\.ya?ml\\\\.gz$\",\r\n        \"drep\": \".+\\\\.drep$\"\r\n    }\r\n    import re\r\n    for key, value in file_extensions.items():\r\n        file_pattern = re.compile(value)\r\n        if file_pattern.findall(file_path):\r\n            ext_map[key] = True\r\n        else:\r\n            ext_map[key] = False\r\n\r\n# construct file data\r\n    file_time = 0\r\n    file_data = ''.encode('utf-8')\r\n    if ext_map['json']:\r\n        import json\r\n        file_data = json.dumps(record_details, indent=2).encode('utf-8')\r\n    elif ext_map['yaml']:\r\n        import yaml\r\n        file_data = yaml.dump(record_details).encode('utf-8')\r\n    elif ext_map['json.gz']:\r\n        import json\r\n        import gzip\r\n        file_bytes = json.dumps(record_details).encode('utf-8')\r\n        file_data = gzip.compress(file_bytes)\r\n    elif ext_map['yaml.gz']:\r\n        import yaml\r\n        import gzip\r\n        file_bytes = yaml.dump(record_details).encode('utf-8')\r\n        file_data = gzip.compress(file_bytes)\r\n    elif ext_map['drep']:\r\n        from labpack.compilers import drep\r\n        file_data = drep.dump(record_details, secret_key)\r\n        file_time = 1\r\n    else:\r\n        raise ValueError('%s must be one of %s file types.' % (_path_arg, list(ext_map.keys())))\r\n\r\n# check overwrite exception\r\n    import os\r\n    if not overwrite:\r\n        if os.path.exists(file_path):\r\n            raise Exception('%s already exists. To overwrite %s, set overwrite=True' % (_path_arg, _path_arg))\r\n\r\n# create directories in path to file\r\n    dir_path = os.path.split(file_path)\r\n    if dir_path[0]:\r\n        if not os.path.exists(dir_path[0]):\r\n            os.makedirs(dir_path[0])\r\n\r\n# write data to file\r\n    with open(file_path, 'wb') as f:\r\n        f.write(file_data)\r\n        f.close()\r\n\r\n# eliminate update and access time metadata (for drep files)\r\n    if file_time:\r\n        os.utime(file_path, times=(file_time, file_time))\r\n\r\n# TODO add windows creation time wiping\r\n# http://stackoverflow.com/questions/4996405/how-do-i-change-the-file-creation-date-of-a-windows-file-from-python\r\n\r\n    return file_path", "response": "a method to save dictionary typed data to a local file\r\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_settings(file_path, retry_count=10, remove_dir=False):\r\n\r\n    '''\r\n        a method to remove a file using a child process\r\n\r\n        http://www.petercollingridge.co.uk/blog/running-multiple-processes-python\r\n        https://docs.python.org/3.5/library/multiprocessing.html\r\n\r\n    :param file_path: string with path to file to remove\r\n    :param retry_count: integer with number of attempts to remove before error is thrown\r\n    :param remove_dir: [optional] boolean to remove empty parent directories\r\n    :return: None\r\n    '''\r\n\r\n# validate inputs\r\n    title = 'remove_settings'\r\n    try:\r\n        _path_arg = '%s(file_path=%s)' % (title, str(file_path))\r\n    except:\r\n        raise ValueError('%s(file_path=...) must be a string.' % title)\r\n    if not isinstance(retry_count, int):\r\n        raise ValueError('%s(retry_count=...) must be an integer.' % title)\r\n    elif retry_count < 1:\r\n        raise ValueError('%s(retry_count=%s) must be greater than 0.' % (title, retry_count))\r\n\r\n# create a child process to remove file\r\n    from multiprocessing import Process\r\n    child_process = Process(target=_remove_settings, args=(file_path, retry_count, remove_dir))\r\n    child_process.start()", "response": "a method to remove a file using a child process"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ingest_environ(model_path=''):\r\n\r\n    ''' a method to convert environment variables to a python dictionary\r\n\r\n    :param model_path: [optional] string with path to jsonmodel of data to ingest\r\n    :return: dictionary with environmental variables\r\n\r\n    NOTE:   if a model is provided, then only those fields in the model will be\r\n            added to the output and the value of any environment variable which\r\n            matches the uppercase name of each field in the model will be added\r\n            to the dictionary if its value is valid according to the model. if\r\n            a value is not valid, the method will throw a InputValidationError\r\n    '''\r\n\r\n# convert environment variables into json typed data\r\n    from os import environ, path\r\n    typed_dict = {}\r\n    environ_variables = dict(environ)\r\n    for key, value in environ_variables.items():\r\n        if value.lower() == 'true':\r\n            typed_dict[key] = True\r\n        elif value.lower() == 'false':\r\n            typed_dict[key] = False\r\n        elif value.lower() == 'null':\r\n            typed_dict[key] = None\r\n        elif value.lower() == 'none':\r\n            typed_dict[key] = None\r\n        else:\r\n            try:\r\n                try:\r\n                    typed_dict[key] = int(value)\r\n                except:\r\n                    typed_dict[key] = float(value)\r\n            except:\r\n                typed_dict[key] = value\r\n\r\n# feed environment variables through model\r\n    if model_path:\r\n        if not path.exists(model_path):\r\n            raise ValueError('%s is not a valid file path.' % model_path)\r\n        model_dict = load_settings(model_path)\r\n        from jsonmodel.validators import jsonModel\r\n        model_object = jsonModel(model_dict)\r\n        default_dict = model_object.ingest(**{})\r\n        for key in default_dict.keys():\r\n            if key.upper() in typed_dict:\r\n                valid_kwargs = {\r\n                    'input_data': typed_dict[key.upper()],\r\n                    'object_title': 'Environment variable %s' % key.upper(),\r\n                    'path_to_root': '.%s' % key\r\n                }\r\n                default_dict[key] = model_object.validate(**valid_kwargs)\r\n        return default_dict\r\n\r\n    return typed_dict", "response": "a method to convert environment variables into a python dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef compile_settings(model_path, file_path, ignore_errors=False):\r\n\r\n    ''' a method to compile configuration values from different sources\r\n\r\n        NOTE:   method searches the environment variables, a local\r\n                configuration path and the default values for a jsonmodel\r\n                object for valid configuration values. if an environmental\r\n                variable or key inside a local config file matches the key\r\n                for a configuration setting declared in the jsonmodel schema,\r\n                its value will be added to the configuration file as long\r\n                as the value is model valid. SEE jsonmodel module.\r\n\r\n        NOTE:   the order of assignment:\r\n                    first:  environment variable\r\n                    second: configuration file\r\n                    third:  default value\r\n                    fourth: empty value\r\n\r\n        NOTE:   method is guaranteed to produce a full set of top-level keys\r\n\r\n    :param model_path: string with path to jsonmodel valid model data\r\n    :param file_path: string with path to local configuration file\r\n    :param ignore_errors: [optional] boolean to ignore any invalid values\r\n    :return: dictionary with settings\r\n    '''\r\n\r\n# construct configuration model and default details\r\n    from jsonmodel.validators import jsonModel\r\n    config_model = jsonModel(load_settings(model_path))\r\n    default_details = config_model.ingest(**{})\r\n\r\n# retrieve environmental variables and file details\r\n    environ_details = ingest_environ()\r\n\r\n    try:\r\n        file_details = load_settings(file_path)\r\n    except:\r\n        file_details = {}\r\n\r\n# construct config details from (first) envvar, (second) file, (third) default\r\n    config_details = {}\r\n    for key in default_details.keys():\r\n        test_file = True\r\n        test_default = True\r\n        if key.upper() in environ_details.keys():\r\n            test_file = False\r\n            test_default = False\r\n            try:\r\n                config_details[key] = config_model.validate(environ_details[key.upper()], '.%s' % key)\r\n            except:\r\n                if ignore_errors:\r\n                    test_file = True\r\n                    test_default = True\r\n                else:\r\n                    raise\r\n        if key in file_details.keys() and test_file:\r\n            test_default = False\r\n            try:\r\n                config_details[key] = config_model.validate(file_details[key], '.%s' % key)\r\n            except:\r\n                if ignore_errors:\r\n                    test_default = True\r\n                else:\r\n                    raise\r\n        if test_default:\r\n            config_details[key] = default_details[key]\r\n\r\n    return config_details", "response": "a method to compile configuration values from different sources into a dictionary with settings"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef search(api_key, query, offset=0, type='personal'):\n\n    if not isinstance(api_key, str):\n        raise InvalidAPIKeyException('API key must be a string')\n\n    if not api_key or len(api_key) < 40:\n        raise InvalidAPIKeyException('Invalid API key.')\n\n    url = get_endpoint(api_key, query, offset, type)\n\n    try:\n        return requests.get(url).json()\n    except requests.exceptions.RequestException as err:\n        raise PunterException(err)", "response": "Search for a domain."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef substitutes(self):\n        substitute_dict = dict(\n            project = self.project_name,\n            template = self.project_name + 'Template',\n            file = self.project_name + 'FileTemplate',\n        )\n        return substitute_dict", "response": "Return the substitutions for the templating replacements."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tick(self):\n        if self.state == AuctionState.NOMINATE:\n            # if no nominee submitted, exception\n            if self.nominee is None:\n                raise InvalidActionError(\"Tick was invoked during nomination but no nominee was selected.\")\n            self.state = AuctionState.BID\n            # initialize bids array to hold each owner's bid\n            # this holds the latest bids submitted for the current bidding phase\n            self.bids = [self.bid if i == self.turn_index else 0 for i in range(len(self.owners))]\n            # this holds the bids submitted on a given tick\n            self.tickbids = [0] * len(self.owners)\n        elif self.state == AuctionState.BID:\n            # If no new bids submitted, we're done with this bid and the player gets what they bid for\n            if not any(bid > 0 for bid in self.tickbids):\n                winner = self._winning_owner()\n                winner.buy(self.nominee, self.bid)\n                self._player_ownership[self._nominee_index] = self.winning_owner_index()\n                self.undrafted_players.remove(self.nominee)\n                self.nominee = None\n                self._nominee_index = -1\n                # check if we're done, or move to the next player who still has space\n                done = True\n                for i in range(len(self.owners)):\n                    next_turn = (self.turn_index + 1 + i) % len(self.owners)\n                    if self.owners[next_turn].remaining_picks() > 0:\n                        self.turn_index = next_turn\n                        done = False\n                        break\n                # if we didn't move on, we're done\n                if done:\n                    self.state = AuctionState.DONE\n                else:\n                    self.state = AuctionState.NOMINATE\n            else:\n                # new bids have been submitted,\n                # randomly pick the bid to accept from the highest,\n                # then everyone gets a chance to submit more\n                top_idxs = [i for i, bid in enumerate(self.tickbids) if bid == max(self.tickbids)]\n                accept_idx = random.choice(top_idxs)\n                # set this as the new bid\n                self.bid = self.tickbids[accept_idx]\n                # update the bids for this round\n                self.bids[accept_idx] = self.bid\n                # clear this for the next tick\n                self.tickbids = [0] * len(self.owners)", "response": "This method is called by the game when a new item is submitted for the current item."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nplaces a bid for this player.", "response": "def place_bid(self, owner_id, bid):\n        \"\"\"\n        Submits a bid for this tick for current player. This is not a guarantee that it will be accepted!\n        If other players submit a higher bid this same tick, the bid won't be counted. Try again next tick if it's not\n        too high!\n        :param int owner_id: id of owner who is submitting the bid\n        :param int bid: bid amount\n\n        :raise InvalidActionError: if the action is not allowed according to the rules. See the error message\n            for details.\n        \"\"\"\n\n        if self.state != AuctionState.BID:\n            raise InvalidActionError(\"Bid was attempted, but it is not currently time to submit bids.\")\n        elif self.bid >= bid:\n            raise InvalidActionError(\"Bid amount \" + str(bid) + \" must be greater than current bid of \" + str(self.bid))\n        elif not self.owners[owner_id].can_buy(self.nominee, bid):\n            raise InvalidActionError(\"The owner with index \" + str(owner_id) +\n                                     \" cannot afford a bid of \" + str(bid) + \" for player \" + self.nominee.name +\n                                     \" or cannot actually buy this player (due to \"\n                                     \"not having any free slots)\")\n\n        # success, add their bid to the current tick\n        self.tickbids[owner_id] = bid"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef nominate(self, owner_id, player_idx, bid):\n\n        owner = self.owners[owner_id]\n        nominated_player = self.players[player_idx]\n\n        if self.state != AuctionState.NOMINATE:\n            raise InvalidActionError(\"Owner \" + str(owner_id) +\n                                     \" tried to nominate, but Auction state \"\n                                     \"is not NOMINATE, so nomination is not allowed\")\n        elif self.turn_index != owner_id:\n            raise InvalidActionError(\"Owner \" + str(owner_id) + \" tried to nominate, but it is currently \" +\n                                     str(self.turn_index) + \"'s turn\")\n        elif nominated_player not in self.undrafted_players:\n            raise InvalidActionError(\"Owner \" + str(owner_id) + \"tried to nominate the player with index \" + str(player_idx) + \", named \" +\n                                     nominated_player.name +\n                                     \", but they have already been purchased and cannot be nominated.\")\n        elif bid > owner.max_bid():\n            raise InvalidActionError(\"Bid amount was \" + str(bid) + \" but this owner (Owner \" + str(owner_id) +\n                                     \" can only bid a maximum of \" +\n                                     str(owner.max_bid()))\n        elif bid < 1:\n            raise InvalidActionError(\"Owner \" + str(owner_id) + \"'s bid amount was \" + str(bid) +\n                                     \" but must be greater than 1\")\n        elif not owner.can_buy(nominated_player, bid):\n            raise InvalidActionError(\"Owner \" + str(owner_id) + \" cannot make this nomination for player with index \"\n                                     + str(player_idx) + \", named \" +\n                                     nominated_player.name + \", because they cannot slot or cannot\"\n                                     \" afford the player for the specified bid amount\")\n\n        # nomination successful, bidding time\n        self.nominee = nominated_player\n        self._nominee_index = player_idx\n        self.bid = bid\n        self.tickbids[owner_id] = bid", "response": "nominate the player for auctioning."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_post(self, req, resp):\n\n        grant_type = req.get_param('grant_type')\n        password = req.get_param('password')\n        username = req.get_param('username')\n\n        # errors or not, disable client caching along the way\n        # per the spec\n        resp.disable_caching()\n\n        if not grant_type or not password or not username:\n            resp.status = falcon.HTTP_400\n            resp.serialize({\n                'error': 'invalid_request',\n                'error_description': 'A grant_type, username, & password '\n                                     'parameters are all required when '\n                                     'requesting an OAuth access_token',\n                'error_uri': 'tools.ietf.org/html/rfc6749#section-4.3.2',\n            })\n        elif grant_type != 'password':\n            resp.status = falcon.HTTP_400\n            resp.serialize({\n                'error': 'unsupported_grant_type',\n                'error_description': 'The grant_type parameter MUST be set '\n                                     'to \"password\" not \"%s\"' % grant_type,\n                'error_uri': 'tools.ietf.org/html/rfc6749#section-4.3.2',\n            })\n        else:\n            try:\n                token = self.auth_creds(username, password)\n                resp.serialize({\n                    'access_token': token,\n                    'token_type': 'Bearer',\n                })\n            except AuthRejected as exc:\n                resp.status = falcon.HTTP_401\n                resp.set_header('WWW-Authenticate', self._realm)\n                resp.serialize({\n                    'error': 'invalid_client',\n                    'error_description': exc.detail,\n                })", "response": "Validate the access token request for the application and return the access token."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating an anomaly. This is done by a Psuedo - random number generator.", "response": "def generate_anomaly(self, input_word, list_of_dict_words, num):\n        \"\"\" Generate an anomaly. This is done\n        via a Psuedo-random number generator.\n        \"\"\"\n\n        results = []\n        for i in range(0,num):\n            index = randint(0,len(list_of_dict_words)-1)\n            name = list_of_dict_words[index]\n            if name != input_word and name not in results:\n                results.append(PataLib().strip_underscore(name))\n            else:\n                i = i +1\n        results = {'input' : input_word, 'results' : results, 'category' : 'anomaly'} \n        return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconnect a boolean callback property with a Qt button widget.", "response": "def connect_checkable_button(instance, prop, widget):\n    \"\"\"\n    Connect a boolean callback property with a Qt button widget.\n\n    Parameters\n    ----------\n    instance : object\n        The class instance that the callback property is attached to\n    prop : str\n        The name of the callback property\n    widget : QtWidget\n        The Qt widget to connect. This should implement the ``setChecked``\n        method and the ``toggled`` signal.\n    \"\"\"\n    add_callback(instance, prop, widget.setChecked)\n    widget.toggled.connect(partial(setattr, instance, prop))\n    widget.setChecked(getattr(instance, prop) or False)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconnect a string callback property with a Qt widget containing text.", "response": "def connect_text(instance, prop, widget):\n    \"\"\"\n    Connect a string callback property with a Qt widget containing text.\n\n    Parameters\n    ----------\n    instance : object\n        The class instance that the callback property is attached to\n    prop : str\n        The name of the callback property\n    widget : QtWidget\n        The Qt widget to connect. This should implement the ``setText`` and\n        ``text`` methods as well optionally the ``editingFinished`` signal.\n    \"\"\"\n\n    def update_prop():\n        val = widget.text()\n        setattr(instance, prop, val)\n\n    def update_widget(val):\n        if hasattr(widget, 'editingFinished'):\n            widget.blockSignals(True)\n            widget.setText(val)\n            widget.blockSignals(False)\n            widget.editingFinished.emit()\n        else:\n            widget.setText(val)\n\n    add_callback(instance, prop, update_widget)\n\n    try:\n        widget.editingFinished.connect(update_prop)\n    except AttributeError:\n        pass\n\n    update_widget(getattr(instance, prop))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef connect_combo_data(instance, prop, widget):\n\n    def update_widget(value):\n        try:\n            idx = _find_combo_data(widget, value)\n        except ValueError:\n            if value is None:\n                idx = -1\n            else:\n                raise\n        widget.setCurrentIndex(idx)\n\n    def update_prop(idx):\n        if idx == -1:\n            setattr(instance, prop, None)\n        else:\n            setattr(instance, prop, widget.itemData(idx))\n\n    add_callback(instance, prop, update_widget)\n    widget.currentIndexChanged.connect(update_prop)\n\n    update_widget(getattr(instance, prop))", "response": "Connect a callback property with a QComboBox widget based on the userData."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect_combo_text(instance, prop, widget):\n\n    def update_widget(value):\n        try:\n            idx = _find_combo_text(widget, value)\n        except ValueError:\n            if value is None:\n                idx = -1\n            else:\n                raise\n        widget.setCurrentIndex(idx)\n\n    def update_prop(idx):\n        if idx == -1:\n            setattr(instance, prop, None)\n        else:\n            setattr(instance, prop, widget.itemText(idx))\n\n    add_callback(instance, prop, update_widget)\n    widget.currentIndexChanged.connect(update_prop)\n\n    update_widget(getattr(instance, prop))", "response": "Connect a callback property with a QComboBox widget based on the text of the item."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef connect_float_text(instance, prop, widget, fmt=\"{:g}\"):\n\n    if callable(fmt):\n        format_func = fmt\n    else:\n        def format_func(x):\n            return fmt.format(x)\n\n    def update_prop():\n        val = widget.text()\n        try:\n            setattr(instance, prop, float(val))\n        except ValueError:\n            setattr(instance, prop, 0)\n\n    def update_widget(val):\n        if val is None:\n            val = 0.\n        widget.setText(format_func(val))\n\n    add_callback(instance, prop, update_widget)\n\n    try:\n        widget.editingFinished.connect(update_prop)\n    except AttributeError:\n        pass\n\n    update_widget(getattr(instance, prop))", "response": "Connect a numerical callback property with a Qt widget containing text."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconnects a numerical callback property with a Qt widget representing a value.", "response": "def connect_value(instance, prop, widget, value_range=None, log=False):\n    \"\"\"\n    Connect a numerical callback property with a Qt widget representing a value.\n\n    Parameters\n    ----------\n    instance : object\n        The class instance that the callback property is attached to\n    prop : str\n        The name of the callback property\n    widget : QtWidget\n        The Qt widget to connect. This should implement the ``setText`` and\n        ``text`` methods as well optionally the ``editingFinished`` signal.\n    value_range : iterable, optional\n        A pair of two values representing the true range of values (since\n        Qt widgets such as sliders can only have values in certain ranges).\n    log : bool, optional\n        Whether the Qt widget value should be mapped to the log of the callback\n        property.\n    \"\"\"\n\n    if log:\n        if value_range is None:\n            raise ValueError(\"log option can only be set if value_range is given\")\n        else:\n            value_range = math.log10(value_range[0]), math.log10(value_range[1])\n\n    def update_prop():\n        val = widget.value()\n        if value_range is not None:\n            imin, imax = widget.minimum(), widget.maximum()\n            val = (val - imin) / (imax - imin) * (value_range[1] - value_range[0]) + value_range[0]\n        if log:\n            val = 10 ** val\n        setattr(instance, prop, val)\n\n    def update_widget(val):\n        if val is None:\n            widget.setValue(0)\n            return\n        if log:\n            val = math.log10(val)\n        if value_range is not None:\n            imin, imax = widget.minimum(), widget.maximum()\n            val = (val - value_range[0]) / (value_range[1] - value_range[0]) * (imax - imin) + imin\n        widget.setValue(val)\n\n    add_callback(instance, prop, update_widget)\n    widget.valueChanged.connect(update_prop)\n\n    update_widget(getattr(instance, prop))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef connect_button(instance, prop, widget):\n    widget.clicked.connect(getattr(instance, prop))", "response": "Connect a button with a callback method"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _find_combo_data(widget, value):\n    # Here we check that the result is True, because some classes may overload\n    # == and return other kinds of objects whether true or false.\n    for idx in range(widget.count()):\n        if widget.itemData(idx) is value or (widget.itemData(idx) == value) is True:\n            return idx\n    else:\n        raise ValueError(\"%s not found in combo box\" % (value,))", "response": "Find the index in a combo box where itemData == value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding the index in a combo box where text == value", "response": "def _find_combo_text(widget, value):\n    \"\"\"\n    Returns the index in a combo box where text == value\n\n    Raises a ValueError if data is not found\n    \"\"\"\n    i = widget.findText(value)\n    if i == -1:\n        raise ValueError(\"%s not found in combo box\" % value)\n    else:\n        return i"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new node based on the path", "response": "async def factory(self, request, path = \"/\", as_ = None):\n    \"\"\"\n    The user will ask for /path/to/the/parent/new/member-list\n    Where member-list is the list where the parent saves the children order\n    So in the test model MinimalMongoTree the only factory will be /new/children\n    \"\"\"\n    counter, time = perf_counter(), process_time()\n    if not path.startswith(\"/\"):\n      path = \"/{}\".format(path)\n\n    resp = await self.resolve_path(path)\n    if resp:\n      if \"path\" not in request.json:\n        request.json[\"path\"] = path\n\n      method = getattr(resp[\"model\"], resp[\"model\"].factories[as_] if hasattr(resp[\"model\"], \"factories\") and as_ in resp[\"model\"].factories else \"create_child\")\n      result = await method(request, as_)\n      code = result.code if issubclass(result.__class__, ErrorSchema) else 201\n      result = result.to_plain_dict()\n\n      result['pref_counter'] = (perf_counter() - counter) * 1000\n      result['process_time'] = (process_time() - time) * 1000\n      return response.json(result, code)\n    else:\n      error = self.models.ErrorSchema()\n      error.load({\"message\": \"{} not found\".format(path), \"code\": 404})\n      return response.json(error.to_plain_dict(), 404)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef class_repr(value):\n    klass = value\n    if not isinstance(value, type):\n        klass = klass.__class__\n    return '.'.join([klass.__module__, klass.__name__])", "response": "Returns a representation of the value class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rand_unicode(min_char=MIN_UNICHR, max_char=MAX_UNICHR, min_len=MIN_STRLEN,\n                 max_len=MAX_STRLEN, **kwargs):\n    '''For values in the unicode range, regardless of Python version.\n    '''\n    from syn.five import unichr\n    return unicode(rand_str(min_char, max_char, min_len, max_len, unichr))", "response": "For values in the unicode range regardless of Python version."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new User object and add it to the Users collection.", "response": "def create(self, email, device_name, passphrase=None,\n               api_token=None, redirect_uri=None, **kwargs):\n        \"\"\"Create a new User object and add it to this Users collection.\n\n        In addition to creating a user, this call will create a device for that\n        user, whose device_token will be returned from this call. Store the\n        device_token, as it's required to complete Gem-Device authentication\n        after the user approves the device at the end of their signup flow.\n\n        If you lose the device_token returned from users.create, you'll have to\n        create a new device for the user to gain access to their account again.\n\n        Also, after this call, be sure to redirect the user to the location in\n        `mfa_uri` (second return value of this function) to complete their\n        account.\n\n        If you get a 409 Conflict error, then the user already exists in the Gem\n        system and you'll want to do a\n        `client.user(email).devices.create(device_name)`\n\n        Args:\n          email (str)\n          device_name (str): Human-readable name for the device through which\n            your Application will be authorized to access the new User's account.\n          passphrase (str, optional): A passphrase with which to encrypt a user\n            wallet. If not provided, a default_wallet parameter must be passed in\n            kwargs.\n          api_token (str, optional): Your app's API token. This is optional if\n            and only if the Client which will be calling this function already\n            has Gem-Application or Gem-Identify authentication.\n          redirect_uri (str, optional): A URI to which to redirect the User after\n            they confirm their Gem account.\n          **kwargs\n\n        Returns: device_token\n        \"\"\"\n\n        if not passphrase and u'default_wallet' not in kwargs:\n            raise ValueError(\"Usage: users.create(email, passphrase, device_name\"\n                             \", api_token, redirect_uri)\")\n        elif passphrase:\n            default_wallet = generate(passphrase, ['primary'])['primary']\n        else:\n            default_wallet = kwargs['default_wallet']\n\n        default_wallet['name'] = 'default'\n        default_wallet['primary_private_seed'] = default_wallet['encrypted_seed']\n        default_wallet['primary_public_seed'] = default_wallet['public_seed']\n        del default_wallet['encrypted_seed']\n        del default_wallet['public_seed']\n        del default_wallet['private_seed']\n\n        # If not supplied, we assume the client already has an api_token param.\n        if api_token:\n            self.client.authenticate_identify(api_token)\n\n        user_data = dict(email=email,\n                         default_wallet=default_wallet,\n                         device_name=device_name)\n\n        if redirect_uri:\n            user_data['redirect_uri'] = redirect_uri\n        if 'first_name' in kwargs:\n            user_data['first_name'] = kwargs['first_name']\n        if 'last_name' in kwargs:\n            user_data['last_name'] = kwargs['last_name']\n\n        try:\n            resource = self.resource.create(user_data)\n        except ResponseError as e:\n            if \"conflict\" in e.message:\n                raise ConflictError(\n                    \"This user already exists. Use \"\n                    \"client.user(email).devices.create(name) to request \"\n                    \"authorization from the user.\")\n            raise e\n\n        return resource.attributes['metadata']['device_token']"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wallet(self):\n        if not hasattr(self, '_wallet'):\n            wallet_resource = self.resource.default_wallet.get()\n            self._wallet = Wallet(wallet_resource, self.client)\n        return self._wallet", "response": "Fetch and return this user s default ( only ) Wallet."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfetch and return Subscriptions associated with this user.", "response": "def subscriptions(self):\n        \"\"\"Fetch and return Subscriptions associated with this user.\"\"\"\n        if not hasattr(self, '_subscriptions'):\n            subscriptions_resource = self.resource.subscriptions\n            self._subscriptions = Subscriptions(\n                subscriptions_resource, self.client)\n        return self._subscriptions"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nverify an SMS or TOTP MFA token for this user.", "response": "def verify_mfa(self, mfa_token):\n        \"\"\"Verify an SMS or TOTP MFA token for this user.\n\n        Args:\n          mfa_token (str): An alphanumeric code from either a User's TOTP\n            application or sent to them via SMS.\n\n        Returns:\n          True if the mfa_token is valid, False otherwise.\n        \"\"\"\n        response = self.resource.verify_mfa({'mfa_token': mfa_token})\n        return (response['valid'] == True or response['valid'] == 'true')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreset the primary key sequence for the tables in an application.", "response": "def reset_sequence(app_label):\n    \"\"\"\n    Reset the primary key sequence for the tables in an application.\n    This is necessary if any local edits have happened to the table.\n    \"\"\"\n\n    puts(\"Resetting primary key sequence for {0}\".format(app_label))\n\n    cursor = connection.cursor()\n    cmd = get_reset_command(app_label)\n    cursor.execute(cmd)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef search(cls, name, lookup=None):\n\n        for spath in lookup:\n            spath = os.path.abspath(spath) + os.sep\n            fname = os.path.abspath(os.path.join(spath, name))\n            if not fname.startswith(spath): continue\n            if os.path.isfile(fname): return fname\n            for ext in cls.extensions:\n                if os.path.isfile('%s.%s' % (fname, ext)):\n                    return '%s.%s' % (fname, ext)", "response": "Search name in all directories specified in lookup. First without common extensions. Return first hit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fallbackPackage(package_name, fallback_package_name):\n    '''\n    if an import cannot be resolved\n    import from fallback package\n    \n    example:\n    from [package_name].doesnt_exist import Foo\n    \n    results in \n    from [fallback_package_name].doesnt_exist import Foo\n    \n    '''\n    importer = Finder(package_name, fallback_package_name)\n    sys.meta_path.append(importer)", "response": "Add a fallback package to sys. meta_path."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef array_indented(level, l, quote_char='\\'', comma_after=False):\n    # type: (int, List[str], str, bool) -> str\n    \"\"\"\n    return an array indented according to indent level\n    :param level:\n    :param l:\n    :param quote_char:\n    :param comma_after:\n    :return:\n    \"\"\"\n    out = \"[\\n\"\n    for x in l:\n        out += (((level+1) * 4) * \" \") + '{}{}{}'.format(quote_char, x, quote_char) + \",\\n\"\n    out += ((level * 4) * \" \") + \"]\"\n    if comma_after:\n        out += \",\"\n    return out", "response": "returns an array indented according to indent level\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _validate_install(self):\r\n\r\n        ''' a method to validate docker is installed '''\r\n\r\n        from subprocess import check_output, STDOUT\r\n        sys_command = 'docker --help'\r\n        try:\r\n            check_output(sys_command, shell=True, stderr=STDOUT).decode('utf-8')\r\n            # call(sys_command, stdout=open(devnull, 'wb'))\r\n        except Exception as err:\r\n            raise Exception('\"docker\" not installed. GoTo: https://www.docker.com')\r\n    \r\n        return True", "response": "a method to validate docker is installed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _ps(self, sys_output):\r\n        \r\n        ''' a helper method for parsing docker ps output '''\r\n        \r\n        import re\r\n        gap_pattern = re.compile('\\t|\\s{2,}')\r\n        container_list = []\r\n        output_lines = sys_output.split('\\n')\r\n        column_headers = gap_pattern.split(output_lines[0])\r\n        for i in range(1,len(output_lines)):\r\n            columns = gap_pattern.split(output_lines[i])\r\n            container_details = {}\r\n            if len(columns) > 1:\r\n                for j in range(len(column_headers)):\r\n                    container_details[column_headers[j]] = ''\r\n                    if j <= len(columns) - 1:\r\n                        container_details[column_headers[j]] = columns[j]\r\n        # stupid hack for possible empty port column\r\n                if container_details['PORTS'] and not container_details['NAMES']:\r\n                    from copy import deepcopy\r\n                    container_details['NAMES'] = deepcopy(container_details['PORTS'])\r\n                    container_details['PORTS'] = ''\r\n                container_list.append(container_details)\r\n    \r\n        return container_list", "response": "a helper method for parsing docker ps output"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _synopsis(self, container_settings, container_status=''):\r\n\r\n        ''' a helper method for summarizing container settings '''\r\n    \r\n    # compose default response\r\n        settings = {\r\n            'container_status': container_settings['State']['Status'],\r\n            'container_exit': container_settings['State']['ExitCode'],\r\n            'container_ip': container_settings['NetworkSettings']['IPAddress'],\r\n            'image_name': container_settings['Config']['Image'],\r\n            'container_alias': container_settings['Name'].replace('/',''),\r\n            'container_variables': {},\r\n            'mapped_ports': {},\r\n            'mounted_volumes': {},\r\n            'container_networks': []\r\n        }\r\n    \r\n    # parse fields nested in container settings\r\n        import re\r\n        num_pattern = re.compile('\\d+')\r\n        if container_settings['NetworkSettings']['Ports']:\r\n            for key, value in container_settings['NetworkSettings']['Ports'].items():\r\n                if value:\r\n                    port = num_pattern.findall(value[0]['HostPort'])[0]\r\n                    settings['mapped_ports'][port] = num_pattern.findall(key)[0]\r\n        elif container_settings['HostConfig']['PortBindings']:\r\n            for key, value in container_settings['HostConfig']['PortBindings'].items():\r\n                port = num_pattern.findall(value[0]['HostPort'])[0]\r\n                settings['mapped_ports'][port] = num_pattern.findall(key)[0]\r\n        if container_settings['Config']['Env']:\r\n            for variable in container_settings['Config']['Env']:\r\n                k, v = variable.split('=')\r\n                settings['container_variables'][k] = v\r\n        for volume in container_settings['Mounts']:\r\n            system_path = volume['Source']\r\n            container_path = volume['Destination']\r\n            settings['mounted_volumes'][system_path] = container_path\r\n        if container_settings['NetworkSettings']:\r\n            if container_settings['NetworkSettings']['Networks']:\r\n                for key in container_settings['NetworkSettings']['Networks'].keys():\r\n                    settings['container_networks'].append(key)\r\n\r\n    # determine stopped status\r\n        if settings['container_status'] == 'exited':\r\n            if not container_status:\r\n                try:\r\n                    from subprocess import check_output, STDOUT\r\n                    sys_command = 'docker logs --tail 1 %s' % settings['container_alias']\r\n                    check_output(sys_command, shell=True, stderr=STDOUT).decode('utf-8')\r\n                    settings['container_status'] = 'stopped'\r\n                except:\r\n                    pass\r\n            else:\r\n                settings['container_status'] = container_status\r\n\r\n        return settings", "response": "a helper method for summarizing container settings"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ps(self):\r\n\r\n        '''\r\n            a method to list the local active docker containers \r\n            \r\n        :return: list of dictionaries with active container fields\r\n\r\n        [{\r\n            'CREATED': '6 minutes ago',\r\n            'NAMES': 'flask',\r\n            'PORTS': '0.0.0.0:5000->5000/tcp',\r\n            'CONTAINER ID': '38eb0bbeb2e5',\r\n            'STATUS': 'Up 6 minutes',\r\n            'COMMAND': '\"gunicorn --chdir ser\"',\r\n            'IMAGE': 'rc42/flaskserver'\r\n        }]\r\n        '''\r\n\r\n        sys_command = 'docker ps -a'\r\n        sys_output = self.command(sys_command)\r\n        container_list = self._ps(sys_output)\r\n\r\n        return container_list", "response": "a method to list the local active docker containers\r\n            a list of dictionaries with active container fields"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef inspect_image(self, image_name, image_tag=''):\r\n        \r\n        '''\r\n            a method to retrieve the settings of an image\r\n\r\n        :param image_name: string with name or id of image\r\n        :param image_tag: [optional] string with tag associated with image \r\n        :return: dictionary of settings of image\r\n\r\n        { TOO MANY TO LIST }\r\n        '''\r\n\r\n        title = '%s.inspect_image' % self.__class__.__name__\r\n\r\n    # validate inputs\r\n        input_fields = {\r\n            'image_name': image_name,\r\n            'image_tag': image_tag\r\n        }\r\n        for key, value in input_fields.items():\r\n            if value:\r\n                object_title = '%s(%s=%s)' % (title, key, str(value))\r\n                self.fields.validate(value, '.%s' % key, object_title)\r\n\r\n    # determine system command argument\r\n        sys_arg = image_name\r\n        if image_tag:\r\n            sys_arg += ':%s' % image_tag\r\n\r\n    # run inspect command\r\n        import json\r\n        sys_command = 'docker inspect %s' % sys_arg\r\n        output_dict = json.loads(self.command(sys_command))\r\n        image_settings = output_dict[0]\r\n\r\n        return image_settings", "response": "a method to retrieve the settings of an image"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef command(self, sys_command):\r\n\r\n        '''\r\n            a method to run a system command in a separate shell\r\n\r\n        :param sys_command: string with docker command\r\n        :return: string output from docker\r\n        '''\r\n\r\n        title = '%s.command' % self.__class__.__name__\r\n\r\n    # validate inputs\r\n        input_fields = {\r\n            'sys_command': sys_command\r\n        }\r\n        for key, value in input_fields.items():\r\n            object_title = '%s(%s=%s)' % (title, key, str(value))\r\n            self.fields.validate(value, '.%s' % key, object_title)\r\n\r\n        from subprocess import check_output, STDOUT, CalledProcessError\r\n        try:\r\n            output = check_output(sys_command, shell=True, stderr=STDOUT).decode('utf-8')\r\n        except CalledProcessError as err:\r\n            raise Exception(err.output.decode('ascii', 'ignore'))\r\n\r\n        return output", "response": "a method to run a system command in a separate shell"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef synopsis(self, container_alias):\r\n\r\n        '''\r\n            a method to summarize key configuration settings required for docker compose\r\n\r\n        :param container_alias: string with name or id of container\r\n        :return: dictionary with values required for module configurations\r\n        '''\r\n\r\n        title = '%s.synopsis' % self.__class__.__name__\r\n        \r\n    # validate inputs\r\n        input_fields = {\r\n            'container_alias': container_alias\r\n        }\r\n        for key, value in input_fields.items():\r\n            object_title = '%s(%s=%s)' % (title, key, str(value))\r\n            self.fields.validate(value, '.%s' % key, object_title)\r\n            \r\n    # retrieve container settings\r\n        container_settings = self.inspect_container(container_alias)\r\n    \r\n    # summarize settings\r\n        settings = self._synopsis(container_settings)\r\n        \r\n        return settings", "response": "a method to summarize key configuration settings required for docker compose\r\n\r\nApps"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\niterate over a given iterable by n elements at a time.", "response": "def chunk_by(n, iterable, fillvalue=None):\n    \"\"\"\n    Iterate over a given ``iterable`` by ``n`` elements at a time.\n\n        >>> for x, y in chunk_by(2, [1, 2, 3, 4, 5]):\n        ... # iteration no 1: x=1, y=2\n        ... # iteration no 2: x=3, y=4\n        ... # iteration no 3: x=5, y=None\n\n    :param n: (int) a chunk size number\n    :param iterable: (iterator) an input iterator\n    :param fillvalue: (any) a value to be used to fit chunk size if there\n                      not enough values in input iterator\n    :returns: (iterator) an output iterator that iterates over the input\n              one by chunks of size ``n``\n    \"\"\"\n    args = [iter(iterable)] * n\n    return zip_longest(*args, fillvalue=fillvalue)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef configure(self, config):\n        parameters = config.get_section(\"parameters\")\n        if len(parameters) > 0:\n            self._parameters = parameters", "response": "Configures the component by passing configuration parameters."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding a new backend class from a DSN.", "response": "def build_backend(self, conn_string):\n        \"\"\"\n        Given a DSN, returns an instantiated backend class.\n\n        Ex::\n\n            backend = gator.build_backend('locmem://')\n            # ...or...\n            backend = gator.build_backend('redis://127.0.0.1:6379/0')\n\n        :param conn_string: A DSN for connecting to the queue. Passed along\n            to the backend.\n        :type conn_string: string\n\n        :returns: A backend ``Client`` instance\n        \"\"\"\n        backend_name, _ = conn_string.split(':', 1)\n        backend_path = 'alligator.backends.{}_backend'.format(backend_name)\n        client_class = import_attr(backend_path, 'Client')\n        return client_class(conn_string)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef push(self, task, func, *args, **kwargs):\n        task.to_call(func, *args, **kwargs)\n        data = task.serialize()\n\n        if task.async:\n            task.task_id = self.backend.push(\n                self.queue_name,\n                task.task_id,\n                data\n            )\n        else:\n            self.execute(task)\n\n        return task", "response": "Pushes a configured task onto the queue."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npop a task off the front of the queue & runs it.", "response": "def pop(self):\n        \"\"\"\n        Pops a task off the front of the queue & runs it.\n\n        Typically, you'll favor using a ``Worker`` to handle processing the\n        queue (to constantly consume). However, if you need to custom-process\n        the queue in-order, this method is useful.\n\n        Ex::\n\n            # Tasks were previously added, maybe by a different process or\n            # machine...\n            finished_topmost_task = gator.pop()\n\n        :returns: The completed ``Task`` instance\n        \"\"\"\n        data = self.backend.pop(self.queue_name)\n\n        if data:\n            task = self.task_class.deserialize(data)\n            return self.execute(task)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a specific task by task_id off the queue and runs it.", "response": "def get(self, task_id):\n        \"\"\"\n        Gets a specific task, by ``task_id`` off the queue & runs it.\n\n        Using this is not as performant (because it has to search the queue),\n        but can be useful if you need to specifically handle a task *right now*.\n\n        Ex::\n\n            # Tasks were previously added, maybe by a different process or\n            # machine...\n            finished_task = gator.get('a-specific-uuid-here')\n\n        :param task_id: The identifier of the task to process\n        :type task_id: string\n\n        :returns: The completed ``Task`` instance\n        \"\"\"\n        data = self.backend.get(self.queue_name, task_id)\n\n        if data:\n            task = self.task_class.deserialize(data)\n            return self.execute(task)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncanceling a task from the queue.", "response": "def cancel(self, task_id):\n        \"\"\"\n        Takes an existing task & cancels it before it is processed.\n\n        Returns the canceled task, as that could be useful in creating a new\n        task.\n\n        Ex::\n\n            task = gator.task(add, 18, 9)\n\n            # Whoops, didn't mean to do that.\n            gator.cancel(task.task_id)\n\n        :param task_id: The identifier of the task to process\n        :type task_id: string\n\n        :returns: The canceled ``Task`` instance\n        \"\"\"\n        data = self.backend.get(self.queue_name, task_id)\n\n        if data:\n            task = self.task_class.deserialize(data)\n            task.to_canceled()\n            return task"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive a task instance, this runs it. This includes handling retries & re-raising exceptions. Ex:: task = Task(async=False, retries=5) task.to_call(add, 101, 35) finished_task = gator.execute(task) :param task_id: The identifier of the task to process :type task_id: string :returns: The completed ``Task`` instance", "response": "def execute(self, task):\n        \"\"\"\n        Given a task instance, this runs it.\n\n        This includes handling retries & re-raising exceptions.\n\n        Ex::\n\n            task = Task(async=False, retries=5)\n            task.to_call(add, 101, 35)\n            finished_task = gator.execute(task)\n\n        :param task_id: The identifier of the task to process\n        :type task_id: string\n\n        :returns: The completed ``Task`` instance\n        \"\"\"\n        try:\n            return task.run()\n        except Exception:\n            if task.retries > 0:\n                task.retries -= 1\n                task.to_retrying()\n\n                if task.async:\n                    # Place it back on the queue.\n                    data = task.serialize()\n                    task.task_id = self.backend.push(\n                        self.queue_name,\n                        task.task_id,\n                        data\n                    )\n                else:\n                    return self.execute(task)\n            else:\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npushing a task onto the queue.", "response": "def task(self, func, *args, **kwargs):\n        \"\"\"\n        Pushes a task onto the queue.\n\n        This will instantiate a ``Gator.task_class`` instance, configure\n        the callable & its arguments, then push it onto the queue.\n\n        You'll typically want to use either this method or the ``Gator.options``\n        context manager (if you need to configure the ``Task`` arguments, such\n        as retries, async, task_id, etc.)\n\n        Ex::\n\n            on_queue = gator.task(increment, incr_by=2)\n\n        :param func: The callable with business logic to execute\n        :type func: callable\n\n        :param args: Positional arguments to pass to the callable task\n        :type args: list\n\n        :param kwargs: Keyword arguments to pass to the callable task\n        :type kwargs: dict\n\n        :returns: The ``Task`` instance\n        \"\"\"\n        task = self.task_class()\n        return self.push(task, func, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef task(self, func, *args, **kwargs):\n        task = self.gator.task_class(**self.task_kwargs)\n        return self.gator.push(task, func, *args, **kwargs)", "response": "Pushes a task onto the queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_simple_callable(obj):\n    function = inspect.isfunction(obj)\n    method = inspect.ismethod(obj)\n\n    if not (function or method):\n        return False\n\n    args, _, _, defaults = inspect.getargspec(obj)\n    len_args = len(args) if function else len(args) - 1\n    len_defaults = len(defaults) if defaults else 0\n    return len_args <= len_defaults", "response": "Returns True if the object is a simple callable that takes no arguments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the value of the attribute attr from the object instance.", "response": "def get_attribute(instance, attrs):\n    \"\"\"\n    Similar to Python's built in `getattr(instance, attr)`,\n    but takes a list of nested attributes, instead of a single attribute.\n\n    Also accepts either attribute lookup on objects or dictionary lookups.\n    \"\"\"\n    for attr in attrs:\n        if instance is None:\n            # Break out early if we get `None` at any point in a nested lookup.\n            return None\n        try:\n            if isinstance(instance, collections.Mapping):\n                instance = instance[attr]\n            else:\n                instance = getattr(instance, attr)\n        except ObjectDoesNotExist:\n            return None\n        if is_simple_callable(instance):\n            try:\n                instance = instance()\n            except (AttributeError, KeyError) as exc:\n                # If we raised an Attribute or KeyError here it'd get treated\n                # as an omitted field in `Field.get_attribute()`. Instead we\n                # raise a ValueError to ensure the exception is not masked.\n                raise ValueError('Exception raised in callable attribute \"{0}\"; original exception was: {1}'.format(attr, exc))\n\n    return instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_value(dictionary, keys, value):\n    if not keys:\n        dictionary.update(value)\n        return\n\n    for key in keys[:-1]:\n        if key not in dictionary:\n            dictionary[key] = {}\n        dictionary = dictionary[key]\n\n    dictionary[keys[-1]] = value", "response": "Sets the value of a key in a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_choices_dict(choices):\n    # Allow single, paired or grouped choices style:\n    # choices = [1, 2, 3]\n    # choices = [(1, 'First'), (2, 'Second'), (3, 'Third')]\n    # choices = [('Category', ((1, 'First'), (2, 'Second'))), (3, 'Third')]\n    ret = OrderedDict()\n    for choice in choices:\n        if (not isinstance(choice, (list, tuple))):\n            # single choice\n            ret[choice] = choice\n        else:\n            key, value = choice\n            if isinstance(value, (list, tuple)):\n                # grouped choices (category, sub choices)\n                ret[key] = to_choices_dict(value)\n            else:\n                # paired choice (key, display value)\n                ret[key] = value\n    return ret", "response": "Convert choices into key - value dicts."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef flatten_choices_dict(choices):\n    ret = OrderedDict()\n    for key, value in choices.items():\n        if isinstance(value, dict):\n            # grouped choices (category, sub choices)\n            for sub_key, sub_value in value.items():\n                ret[sub_key] = sub_value\n        else:\n            # choice (key, display value)\n            ret[key] = value\n    return ret", "response": "Convert a group choices dict into a flat dict of choices."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nyielding all options in the order of the given choices.", "response": "def iter_options(grouped_choices, cutoff=None, cutoff_text=None):\n    \"\"\"\n    Helper function for options and option groups in templates.\n    \"\"\"\n    class StartOptionGroup(object):\n        start_option_group = True\n        end_option_group = False\n\n        def __init__(self, label):\n            self.label = label\n\n    class EndOptionGroup(object):\n        start_option_group = False\n        end_option_group = True\n\n    class Option(object):\n        start_option_group = False\n        end_option_group = False\n\n        def __init__(self, value, display_text, disabled=False):\n            self.value = value\n            self.display_text = display_text\n            self.disabled = disabled\n\n    count = 0\n\n    for key, value in grouped_choices.items():\n        if cutoff and count >= cutoff:\n            break\n\n        if isinstance(value, dict):\n            yield StartOptionGroup(label=key)\n            for sub_key, sub_value in value.items():\n                if cutoff and count >= cutoff:\n                    break\n                yield Option(value=sub_key, display_text=sub_value)\n                count += 1\n            yield EndOptionGroup()\n        else:\n            yield Option(value=key, display_text=value)\n            count += 1\n\n    if cutoff and count >= cutoff and cutoff_text:\n        cutoff_text = cutoff_text.format(count=cutoff)\n        yield Option(value='n/a', display_text=cutoff_text, disabled=True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_value(self, dictionary):\n        if html.is_html_input(dictionary):\n            # HTML forms will represent empty fields as '', and cannot\n            # represent None or False values directly.\n            if self.field_name not in dictionary:\n                if getattr(self.root, 'partial', False):\n                    return empty\n                return self.default_empty_html\n            ret = dictionary[self.field_name]\n            if ret == '' and self.allow_null:\n                # If the field is blank, and null is a valid value then\n                # determine if we should use null instead.\n                return '' if getattr(self, 'allow_blank', False) else None\n            elif ret == '' and not self.required:\n                # If the field is blank, and emptyness is valid then\n                # determine if we should use emptyness instead.\n                return '' if getattr(self, 'allow_blank', False) else empty\n            return ret\n        return dictionary.get(self.field_name, empty)", "response": "Returns the value for this field from the given primitive data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_attribute(self, instance):\n        try:\n            return get_attribute(instance, self.source_attrs)\n        except (KeyError, AttributeError) as exc:\n            if not self.required and self.default is empty:\n                raise SkipField()\n            msg = (\n                'Got {exc_type} when attempting to get a value for field '\n                '`{field}` on serializer `{serializer}`.\\nThe serializer '\n                'field might be named incorrectly and not match '\n                'any attribute or key on the `{instance}` instance.\\n'\n                'Original exception text was: {exc}.'.format(\n                    exc_type=type(exc).__name__,\n                    field=self.field_name,\n                    serializer=self.parent.__class__.__name__,\n                    instance=instance.__class__.__name__,\n                    exc=exc\n                )\n            )\n            raise type(exc)(msg)", "response": "Given an instance of a class instance return the value that should be used for this field."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the default value to use when validating data for this field.", "response": "def get_default(self):\n        \"\"\"\n        Return the default value to use when validating data if no input\n        is provided for this field.\n\n        If a default has not been set for this field then this will simply\n        return `empty`, indicating that no value should be set in the\n        validated data for this field.\n        \"\"\"\n        if self.default is empty:\n            raise SkipField()\n        if callable(self.default):\n            if hasattr(self.default, 'set_context'):\n                self.default.set_context(self)\n            return self.default()\n        return self.default"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nvalidates empty values and return a list of valid values.", "response": "def validate_empty_values(self, data):\n        \"\"\"\n        Validate empty values, and either:\n\n        * Raise `ValidationError`, indicating invalid data.\n        * Raise `SkipField`, indicating that the field should be ignored.\n        * Return (True, data), indicating an empty value that should be\n          returned without any further validation being applied.\n        * Return (False, data), indicating a non-empty value, that should\n          have validation applied as normal.\n        \"\"\"\n        if self.read_only:\n            return (True, self.get_default())\n\n        if data is empty:\n            if getattr(self.root, 'partial', False):\n                raise SkipField()\n            if self.required:\n                self.fail('required')\n            return (True, self.get_default())\n\n        if data is None:\n            if not self.allow_null:\n                self.fail('null')\n            return (True, None)\n\n        return (False, data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run_validators(self, value):\n        errors = []\n        for validator in self.validators:\n            if hasattr(validator, 'set_context'):\n                validator.set_context(self)\n\n            try:\n                validator(value)\n            except ValidationError as exc:\n                # If the validation error contains a mapping of fields to\n                # errors then simply raise it immediately rather than\n                # attempting to accumulate a list of errors.\n                if isinstance(exc.detail, dict):\n                    raise\n                errors.extend(exc.detail)\n            except DjangoValidationError as exc:\n                errors.extend(exc.messages)\n        if errors:\n            raise ValidationError(errors)", "response": "Run all the validators on the field and return the value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntransform the outgoing native value into primitive data.", "response": "def to_representation(self, value):\n        \"\"\"\n        Transform the *outgoing* native value into primitive data.\n        \"\"\"\n        raise NotImplementedError(\n            '{cls}.to_representation() must be implemented for field '\n            '{field_name}. If you do not need to support write operations '\n            'you probably want to subclass `ReadOnlyField` instead.'.format(\n                cls=self.__class__.__name__,\n                field_name=self.field_name,\n            )\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the top - level serializer for this field.", "response": "def root(self):\n        \"\"\"\n        Returns the top-level serializer for this field.\n        \"\"\"\n        root = self\n        while root.parent is not None:\n            root = root.parent\n        return root"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalidates that the input is a decimal number and return a Decimal instance.", "response": "def to_internal_value(self, data):\n        \"\"\"\n        Validate that the input is a decimal number and return a Decimal\n        instance.\n        \"\"\"\n        data = smart_text(data).strip()\n        if len(data) > self.MAX_STRING_LENGTH:\n            self.fail('max_string_length')\n\n        try:\n            value = decimal.Decimal(data)\n        except decimal.DecimalException:\n            self.fail('invalid')\n\n        # Check for NaN. It is the only value that isn't equal to itself,\n        # so we can use this to identify NaN values.\n        if value != value:\n            self.fail('invalid')\n\n        # Check for infinity and negative infinity.\n        if value in (decimal.Decimal('Inf'), decimal.Decimal('-Inf')):\n            self.fail('invalid')\n\n        return self.validate_precision(value)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef validate_precision(self, value):\n        sign, digittuple, exponent = value.as_tuple()\n\n        if exponent >= 0:\n            # 1234500.0\n            total_digits = len(digittuple) + exponent\n            whole_digits = total_digits\n            decimal_places = 0\n        elif len(digittuple) > abs(exponent):\n            # 123.45\n            total_digits = len(digittuple)\n            whole_digits = total_digits - abs(exponent)\n            decimal_places = abs(exponent)\n        else:\n            # 0.001234\n            total_digits = abs(exponent)\n            whole_digits = 0\n            decimal_places = total_digits\n\n        if self.max_digits is not None and total_digits > self.max_digits:\n            self.fail('max_digits', max_digits=self.max_digits)\n        if self.decimal_places is not None and decimal_places > self.decimal_places:\n            self.fail('max_decimal_places', max_decimal_places=self.decimal_places)\n        if self.max_whole_digits is not None and whole_digits > self.max_whole_digits:\n            self.fail('max_whole_digits', max_whole_digits=self.max_whole_digits)\n\n        return value", "response": "Validate that the number is not too long and that there are no more than max_digits digits after the decimal point."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef enforce_timezone(self, value):\n        field_timezone = getattr(self, 'timezone', self.default_timezone())\n\n        if (field_timezone is not None) and not timezone.is_aware(value):\n            return timezone.make_aware(value, field_timezone)\n        elif (field_timezone is None) and timezone.is_aware(value):\n            return timezone.make_naive(value, timezone.UTC())\n        return value", "response": "Enforces the timezone of the data."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts data to internal value.", "response": "def to_internal_value(self, data):\n        \"\"\"\n        List of dicts of native values <- List of dicts of primitive datatypes.\n        \"\"\"\n        if html.is_html_input(data):\n            data = html.parse_html_list(data)\n        if isinstance(data, type('')) or isinstance(data, collections.Mapping) or not hasattr(data, '__iter__'):\n            self.fail('not_a_list', input_type=type(data).__name__)\n        if not self.allow_empty and len(data) == 0:\n            self.fail('empty')\n        return [self.child.run_validation(item) for item in data]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a dictionary to internal value.", "response": "def to_internal_value(self, data):\n        \"\"\"\n        Dicts of native values <- Dicts of primitive datatypes.\n        \"\"\"\n        if html.is_html_input(data):\n            data = html.parse_html_dict(data)\n        if not isinstance(data, dict):\n            self.fail('not_a_dict', input_type=type(data).__name__)\n        return {\n            six.text_type(key): self.child.run_validation(value)\n            for key, value in data.items()\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_representation(self, value):\n        return {\n            six.text_type(key): self.child.to_representation(val)\n            for key, val in value.items()\n        }", "response": "Converts a dictionary of object instances to a list of dicts of primitive datatypes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nusing internally for requests.", "response": "def _query_(self, path, method, params={}):\n        \"\"\"Used internally for requests.\n\n        :param str path: The path to hit.\n        :param str method: The method to use, either `'GET'` or `'POST.`\n        :param dict data:\n            The optional paramters to the `GET` or the data to `POST`.\n\n        :returns:\n            Requests object -- Requires you to handle the status codes yourself.\n        \"\"\"\n\n        if method == \"POST\":\n            url = '{API_URL}{API_PATH}'.format(API_URL=self.api_url,\n                                               API_PATH=path)\n\n            r = requests.post(url, data=json.dumps(params),\n                              headers=self.headers)\n            return r\n        elif method == \"GET\":\n            url = '{API_URL}{API_PATH}'.format(API_URL=self.api_url,\n                                               API_PATH=path)\n            r = requests.get(url, params=params, headers=self.headers)\n            return r"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef authenticate(self, username, password):\n\n        r = self._query_('/users/authenticate', 'POST',\n                         params={'username': username,\n                                 'password': password})\n        if r.status_code == 201:\n            return r.text.strip('\"')\n        else:\n            raise ValueError('Authentication invalid.')", "response": "Authenticates your user and returns an auth token."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfetch the Anime Object of the given id or slug.", "response": "def get_anime(self, anime_id, title_language='canonical'):\n        \"\"\"Fetches the Anime Object of the given id or slug.\n\n        :param anime_id: The Anime ID or Slug.\n        :type anime_id: int or str\n        :param str title_language: The PREFERED title language can be any of\n            `'canonical'`, `'english'`, `'romanized'`\n        :returns: Anime Object -- The Anime you requested.\n        \"\"\"\n\n        r = self._query_('/anime/%s' % anime_id, 'GET',\n                         params={'title_language_preference': title_language})\n        return Anime(r.json())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching a users library.", "response": "def get_library(self, username, status=None):\n        \"\"\"Fetches a users library.\n\n        :param str username: The user to get the library from.\n        :param str status: only return the items with the supplied status.\n            Can be one of `currently-watching`, `plan-to-watch`, `completed`,\n            `on-hold` or `dropped`.\n\n        :returns: List of Library objects.\n        \"\"\"\n\n        r = self._query_('/users/%s/library' % username, 'GET',\n                         params={'status': status})\n\n        results = [LibraryEntry(item) for item in r.json()]\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_user(self, username):\n\n        r = self._query_('/users/%s' % username, 'GET')\n\n        result = User(r.json())\n        return result", "response": "Get user information.\n\n        :param str username: User to get info on."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a user s feed.", "response": "def get_feed(self, username):\n        \"\"\"Gets a user's feed.\n\n        :param str username: User to fetch feed from.\n        \"\"\"\n\n        r = self._query_('/users/%s/feed' % username, 'GET')\n\n\n        results = [Story(item) for item in r.json()]\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_favorites(self, username):\n\n        r = self._query_('/users/%s/favorite_anime' % username, 'GET')\n\n        results = [Favorite(item) for item in r.json()]\n        return results", "response": "Get a user s favorite anime."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_entry(self, anime_id, status=None, privacy=None, rating=None,\n                     sane_rating_update=None, rewatched_times=None, notes=None,\n                     episodes_watched=None, increment_episodes=None):\n        \"\"\"Creates or updates the Library entry with the provided values.\n\n        :param anime_id: The Anime ID or Slug.\n        :type anime_id: int or str\n        :param str auth_token: User authentication token.\n        :param str status:\n            Can be one of `'currently-watching'`, `'plan-to-watch'`,\n            `'completed'`, `'on-hold'`, `'dropped'`.\n        :param str privacy: Can be one of `'public'`, `'private'`. Making an\n            entry private will hide it from public view.\n        :param rating: Can be one of `0`, `0.5`, `1`, `1.5`, `2`, `2.5`, `3`,\n             `3.5`, `4`, `4.5`, `5`. Setting it to the current value or 0 will\n             remove the rating.\n        :type rating: str, int or float\n        :param sane_rating_update: Can be any one of the values for rating.\n            Setting it to 0 will remove the rating. This should be used instead\n            of rating if you don't want to unset the rating when setting it to\n            its current value.\n        :type sane_rating_update: str, int or float\n        :param int rewatched_times: Number of rewatches. Can be 0 or above.\n        :param str notes: The personal notes for the entry.\n        :param int episodes_watched: Number of watched episodes.\n            Can be between 0 and the total number of episodes. If equal to\n            total number of episodes, status should be set to completed.\n        :param bool increment_episodes: If set to true, increments watched\n            episodes by one. If used along with episodes_watched, provided\n            value will be incremented.\n\n        :raises: ValueError -- if Authentication Token is invalid\n            (it shouldn't be), or if there is a `500 Internal Server Error`\n            or if the response is `Invalid JSON Object`.\n        \"\"\"\n\n        r = self._query_('/libraries/%s' % anime_id, 'POST', {\n            'auth_token': self.auth_token,\n            'status': status,\n            'privacy': privacy,\n            'rating': rating,\n            'sane_rating_update': sane_rating_update,\n            'rewatched_times': rewatched_times,\n            'notes': notes,\n            'episodes_watched': episodes_watched,\n            'increment_episodes': increment_episodes})\n\n        if not (r.status_code == 200 or r.status_code == 201):\n            raise ValueError", "response": "Creates or updates the entry with the provided values."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves an entry from the user s library.", "response": "def remove_entry(self, anime_id):\n        \"\"\"Removes an entry from the user's library.\n\n        :param anime_id: The Anime ID or slug.\n        \"\"\"\n\n        r = self._query_('libraries/%s/remove' % anime_id, 'POST')\n\n        if not r.status_code == 200:\n            raise ValueError"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef script(self, commands, synopsis=True):\n\n        '''\n            a method to run a list of shell command scripts on AWS instance\n\n        :param commands: list of strings with shell commands to pass through connection\n        :param synopsis: [optional] boolean to simplify progress messages to one line\n        :return: string with response to last command\n        '''\n\n        title = '%s.script' % self.__class__.__name__\n\n    # validate inputs\n        if isinstance(commands, str):\n            commands = [commands]\n        input_fields = {\n            'commands': commands\n        }\n        for key, value in input_fields.items():\n            object_title = '%s(%s=%s)' % (title, key, str(value))\n            self.fields.validate(value, '.%s' % key, object_title)\n\n    # run commands through paramiko on Windows\n        response = ''\n        if self.localhost.os.sysname in ('Windows'):\n            ssh_key = paramiko.RSAKey.from_private_key_file(self.pem_file)\n            client = paramiko.SSHClient()\n            client.load_system_host_keys()\n            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            client.connect(hostname=self.instance_ip, username=self.ec2.iam.user_name, pkey=ssh_key)\n            for i in range(len(commands)):\n                self.ec2.iam.printer('[%s@%s]: %s ... ' % (self.login_name, self.instance_ip, commands[i]), flush=True)\n                std_in, std_out, std_err = client.exec_command(commands[i], get_pty=True)\n                if std_err:\n                    self.ec2.iam.printer('ERROR.')\n                    raise Exception('Failure running [%s@%s]: %s\\n%s' % (self.login_name, self.instance_ip, commands[i], std_err.decode('utf-8').strip()))\n                else:\n                    response = std_out.decode('utf-8')\n                    if synopsis:\n                        self.ec2.iam.printer('done.')\n                    else:\n                        if response:\n                            self.ec2.iam.printer('\\n%s' % response)\n                        else:\n                            self.ec2.iam.printer('done.')\n            client.close()\n\n    # run command through ssh on other platforms\n        else:\n            from subprocess import Popen, PIPE, STDOUT\n            for i in range(len(commands)):\n                self.ec2.iam.printer('[%s@%s]: %s ... ' % (self.login_name, self.instance_ip, commands[i]), flush=True)\n                sys_command = 'ssh -i %s %s@%s %s' % (self.pem_file, self.login_name, self.instance_ip, commands[i])\n                # DEBUG print(sys_command)\n                pipes = Popen(sys_command.split(), stdout=PIPE, stderr=STDOUT)\n            # automatically accept keys\n                std_out, std_err = pipes.communicate('yes\\n'.encode('utf-8'))\n                if pipes.returncode != 0:\n                    self.ec2.iam.printer('ERROR.')\n                    raise Exception('Failure running [%s@%s]: %s\\n%s' % (self.login_name, self.instance_ip, commands[i], std_out.decode('utf-8').strip()))\n\n        # report response to individual commands\n                else:\n                    response = std_out.decode('utf-8')\n                    if synopsis:\n                        self.ec2.iam.printer('done.')\n                    else:\n                        if response:\n                            self.ec2.iam.printer('\\n%s' % response)\n                        else:\n                            self.ec2.iam.printer('done.')\n\n    # close connection and return last response\n        return response", "response": "a method to run a list of shell command scripts on AWS instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef responsive(self, port=80, timeout=600):\n\n        '''\n            a method for waiting until web server on AWS instance has restarted\n\n        :param port: integer with port number to check\n        :param timeout: integer with number of seconds to continue to check\n        :return: string with response code\n        '''\n\n        title = '%s.wait' % self.__class__.__name__\n\n        from time import sleep\n\n    # validate inputs\n        input_fields = {\n            'port': port,\n            'timeout': timeout\n        }\n        for key, value in input_fields.items():\n            object_title = '%s(%s=%s)' % (title, key, str(value))\n            self.fields.validate(value, '.%s' % key, object_title)\n\n    # construct parameters for request loop\n        import requests\n        waiting_msg = 'Waiting for http 200 response from %s' % self.instance_ip\n        nonres_msg = 'Instance %s is not responding to requests at %s.' % ( self.instance_id, self.instance_ip)\n        server_url = 'http://%s' % self.instance_ip\n        if port:\n            server_url += ':%s' % str(port)\n\n    # initiate waiting loop\n        self.ec2.iam.printer(waiting_msg, flush=True)\n        t0 = timer()\n        while True:\n            t1 = timer()\n            self.ec2.iam.printer('.', flush=True)\n            try:\n                response = requests.get(server_url, timeout=2)\n                response_code = response.status_code\n                if response_code >= 200 and response_code < 300:\n                    self.ec2.iam.printer(' done.')\n                    return response_code\n            except:\n                pass\n            t2 = timer()\n            if t2 - t0 > timeout:\n                timeout_msg = 'Timeout [%ss]: %s' % (timeout, nonres_msg)\n                raise TimeoutError(timeout_msg)\n            response_time = t2 - t1\n            if 3 - response_time > 0:\n                delay = 3 - response_time\n            else:\n                delay = 0\n            sleep(delay)", "response": "a method for waiting until web server on AWS instance has restarted"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_instance(uri):\n    global _instances\n    try:\n        instance = _instances[uri]\n    except KeyError:\n        instance = MediaFile(\n            uri,\n            client.get_instance()\n        )\n        _instances[uri] = instance\n\n    return instance", "response": "Return an instance of MediaFile."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fetch_to_file(self, filename):\n        self.filename = filename\n        stream = self.client.get_iter_content(self.uri)\n        content_type = self.client.response_headers['content-type']\n\n        if content_type in _content_type_map:\n            self.fileext = _content_type_map[content_type]\n            self.filename = \"%s.%s\" % (self.filename, self.fileext)\n\n        with open(self.filename, 'wb') as file_handle:\n            for chunk in stream:\n                file_handle.write(chunk)", "response": "Stream the MediaFile to the filesystem."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_unique(seq):\n    '''Returns True if every item in the seq is unique, False otherwise.'''\n    try:\n        s = set(seq)\n        return len(s) == len(seq)\n    except TypeError:\n        buf = []\n        for item in seq:\n            if item in buf:\n                return False\n            buf.append(item)\n        return True", "response": "Returns True if every item in the seq is unique False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a copy of lst with each index in idxs removed.", "response": "def indices_removed(lst, idxs):\n    '''Returns a copy of lst with each index in idxs removed.'''\n    ret = [item for k,item in enumerate(lst) if k not in idxs]\n    return type(lst)(ret)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the derivative of f x = x1 + x2", "response": "def _deriv_logaddexp(x1, x2):\n    \"\"\"The derivative of f(x, y) = log(e^x + e^y)\"\"\"\n    y1 = np.exp(x1)\n    y2 = np.exp(x2)\n    df_dx1 = y1 / (y1 + y2)\n    df_dx2 = y2 / (y1 + y2)\n    return np.vstack([df_dx1, df_dx2]).T"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _forward_mode(self, *args):\n        # Evaluate inner function self.f\n        X: np.ndarray\n        dX: np.ndarray\n        X, dX = self.f._forward_mode(*args)\n        # The function value\n        val = self.func(X)\n        # The derivative\n        diff = self.deriv(X) * dX\n        return (val, diff)", "response": "Forward mode differentiation for a constant"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _forward_mode(self, *args):\n        # Evaluate inner function self.f\n        X: np.ndarray\n        dX: np.ndarray\n        X, dX = self.f._forward_mode(*args)\n        Y: np.ndarray\n        dY: np.ndarray\n        Y, dY = self.g._forward_mode(*args)\n        # The function value\n        val = self.func(X,Y)\n        # The derivative (user is responsible for chain rule, etc.)\n        diff = self.deriv(X,Y)\n        return (val, diff)", "response": "Forward mode differentiation for a constant"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef default_classify_function(data):\n    # data[0] indicate the filename of the data\n    rootname, basename = os.path.split(data[0])\n    filename, ext = os.path.splitext(basename)\n    if '_' in filename:\n        filename = filename.rsplit('_', 1)[0]\n    filename = os.path.join(rootname, filename + ext)\n    return filename", "response": "A default classify_function which recieve data and return filename without any underscore"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef classify_dataset(dataset, fn):\n    if fn is None:\n        fn = default_classify_function\n    # classify dataset via classify_fn\n    classified_dataset = OrderedDict()\n    for data in dataset:\n        classify_name = fn(data)\n        if classify_name not in classified_dataset:\n            classified_dataset[classify_name] = []\n        classified_dataset[classify_name].append(data)\n    return classified_dataset", "response": "Classify a list of data using a function which recieve data and return a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts an edit script to a pair of strings representing the operation in a human readable way.", "response": "def to_strings(self, use_colors=True):\n        \"\"\"Convert an edit script to a pair of strings representing the operation in a human readable way.\n\n        :param use_colors: Boolean indicating whether to use terminal color codes to color the output.\n        :return: Tuple with text corresponding to the first pronunciation and the text of the second one.\n        \"\"\"\n\n        edit_script = self.to_primitive()\n\n        colors = collections.defaultdict(str)\n\n        if use_colors:\n            colors['red'] = '\\x1b[31m'\n            colors['normal'] = '\\x1b[m'\n            colors['green'] = '\\x1b[32m'\n            colors['on_red'] = '\\x1b[41m'\n\n        src_txt = ''\n        dst_txt = ''\n        for op in edit_script:\n            if op['op_code'] == 'match':\n                width = max(len(op['from_symbol']), len(op['to_symbol']))\n                if op['from_symbol'] == op['to_symbol']:\n                    src_txt += u'{green}{from_symbol: ^{width}}{normal}'.format(**_combine_dicts(colors,\n                                                                                                 op,\n                                                                                                 {'width': width}))\n                    dst_txt += u'{green}{to_symbol: ^{width}}{normal}'.format(**_combine_dicts(colors,\n                                                                                               op,\n                                                                                               {'width': width}))\n                else:\n                    src_txt += u'{red}{from_symbol: ^{width}}{normal}'.format(**_combine_dicts(colors,\n                                                                                               op,\n                                                                                               {'width': width}))\n                    dst_txt += u'{red}{to_symbol: ^{width}}{normal}'.format(**_combine_dicts(colors,\n                                                                                             op,\n                                                                                             {'width': width}))\n\n            elif op['op_code'] == 'insert':\n                space = ' '*len(op['to_symbol'])\n                src_txt += u'{on_red}{space}{normal}'.format(space=space, **_combine_dicts(colors,  op))\n                dst_txt += u'{red}{to_symbol}{normal}'.format(**_combine_dicts(colors, op))\n\n            elif op['op_code'] == 'delete':\n                space = ' '*len(op['from_symbol'])\n                src_txt += u'{red}{from_symbol}{normal}'.format(**_combine_dicts(colors, op))\n                dst_txt += u'{on_red}{space}{normal}'.format(space=space, **_combine_dicts(colors, op))\n\n            elif op['op_code'] == 'noninsert':\n                continue\n\n            src_txt += ' '\n            dst_txt += ' '\n\n        return src_txt, dst_txt"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_apod(cls, date=None, hd=False):\n        instance = cls('planetary/apod')\n        filters = {\n            'date': date,\n            'hd': hd\n        }\n\n        return instance.get_resource(**filters)", "response": "Returns Astronomy Picture of the Day"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_assets(cls, lat, lon, begin=None, end=None):\n        instance = cls('planetary/earth/assets')\n\n        filters = {\n            'lat': lat,\n            'lon': lon,\n            'begin': begin,\n            'end': end,\n        }\n\n        return instance.get_resource(**filters)", "response": "Returns date and ids of flyovers"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_imagery(cls, lat, lon, date=None, dim=None, cloud_score=False):\n        instance = cls('planetary/earth/imagery')\n\n        filters = {\n            'lat': lat,\n            'lon': lon,\n            'date': date,\n            'dim': dim,\n            'cloud_score': cloud_score\n        }\n\n        return instance.get_resource(**filters)", "response": "Returns satellite image of a specific image"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef valid_station(station: str):\n    station = station.strip()\n    if len(station) != 4:\n        raise BadStation('ICAO station idents must be four characters long')\n    uses_na_format(station)", "response": "Checks the validity of a station idents"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef uses_na_format(station: str) -> bool:\n    if station[0] in NA_REGIONS:\n        return True\n    if station[0] in IN_REGIONS:\n        return False\n    if station[:2] in M_NA_REGIONS:\n        return True\n    if station[:2] in M_IN_REGIONS:\n        return False\n    raise BadStation(\"Station doesn't start with a recognized character set\")", "response": "Returns True if the station uses the North American format False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_unknown(val: str) -> bool:\n    for char in ('/', 'X'):\n        if val == char * len(val):\n            return True\n    return False", "response": "Returns True if val contains only X characters and if it contains only a slash characters."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unpack_fraction(num: str) -> str:\n    nums = [int(n) for n in num.split('/') if n]\n    if len(nums) == 2 and nums[0] > nums[1]:\n        over = nums[0] // nums[1]\n        rem = nums[0] % nums[1]\n        return f'{over} {rem}/{nums[1]}'\n    return num", "response": "Unpacks a fraction string 5 to 2"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstripping zeros while handling - M and empty strings Strips zeros while handling - M and empty strings", "response": "def remove_leading_zeros(num: str) -> str:\n    \"\"\"\n    Strips zeros while handling -, M, and empty strings\n    \"\"\"\n    if not num:\n        return num\n    if num.startswith('M'):\n        ret = 'M' + num[1:].lstrip('0')\n    elif num.startswith('-'):\n        ret = '-' + num[1:].lstrip('0')\n    else:\n        ret = num.lstrip('0')\n    return '0' if ret in ('', 'M', '-') else ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef spoken_number(num: str) -> str:\n    ret = []\n    for part in num.split(' '):\n        if part in FRACTIONS:\n            ret.append(FRACTIONS[part])\n        else:\n            ret.append(' '.join([NUMBER_REPL[char] for char in part if char in NUMBER_REPL]))\n    return ' and '.join(ret)", "response": "Returns the spoken version of a number"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_number(num: str, repr_: str = None, speak: str = None):\n    if not num or is_unknown(num):\n        return\n    # Check CAVOK\n    if num == 'CAVOK':\n        return Number('CAVOK', 9999, 'ceiling and visibility ok')  # type: ignore\n    # Check special\n    if num in SPECIAL_NUMBERS:\n        return Number(repr_ or num, None, SPECIAL_NUMBERS[num])  # type: ignore\n    # Create Fraction\n    if '/' in num:\n        nmr, dnm = [int(i) for i in num.split('/')]\n        unpacked = unpack_fraction(num)\n        spoken = spoken_number(unpacked)\n        return Fraction(repr_ or num, nmr / dnm, spoken, nmr, dnm, unpacked)  # type: ignore\n    # Create Number\n    val = num.replace('M', '-')\n    val = float(val) if '.' in num else int(val)  # type: ignore\n    return Number(repr_ or num, val, spoken_number(speak or str(val)))", "response": "Create a Number or Fraction dataclass for a number string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the index of the first occurence of an item in a list in a string", "response": "def find_first_in_list(txt: str, str_list: [str]) -> int:  # type: ignore\n    \"\"\"\n    Returns the index of the earliest occurence of an item from a list in a string\n\n    Ex: find_first_in_list('foobar', ['bar', 'fin']) -> 3\n    \"\"\"\n    start = len(txt) + 1\n    for item in str_list:\n        if start > txt.find(item) > -1:\n            start = txt.find(item)\n    return start if len(txt) + 1 > start > -1 else -1"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_remarks(txt: str) -> ([str], str):  # type: ignore\n    txt = txt.replace('?', '').strip()\n    # First look for Altimeter in txt\n    alt_index = len(txt) + 1\n    for item in [' A2', ' A3', ' Q1', ' Q0', ' Q9']:\n        index = txt.find(item)\n        if len(txt) - 6 > index > -1 and txt[index + 2:index + 6].isdigit():\n            alt_index = index\n    # Then look for earliest remarks 'signifier'\n    sig_index = find_first_in_list(txt, METAR_RMK)\n    if sig_index == -1:\n        sig_index = len(txt) + 1\n    if sig_index > alt_index > -1:\n        return txt[:alt_index + 6].strip().split(' '), txt[alt_index + 7:]\n    if alt_index > sig_index > -1:\n        return txt[:sig_index].strip().split(' '), txt[sig_index + 1:]\n    return txt.strip().split(' '), ''", "response": "Returns the report split into components and the remarks string"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_taf_remarks(txt: str) -> (str, str):  # type: ignore\n    remarks_start = find_first_in_list(txt, TAF_RMK)\n    if remarks_start == -1:\n        return txt, ''\n    remarks = txt[remarks_start:]\n    txt = txt[:remarks_start].strip()\n    return txt, remarks", "response": "Returns report and remarks separated if found\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsanitizing a string for use in a report.", "response": "def sanitize_report_string(txt: str) -> str:\n    \"\"\"\n    Provides sanitization for operations that work better when the report is a string\n\n    Returns the first pass sanitized report string\n    \"\"\"\n    if len(txt) < 4:\n        return txt\n    # Standardize whitespace\n    txt = ' '.join(txt.split())\n    # Prevent changes to station ID\n    stid, txt = txt[:4], txt[4:]\n    # Replace invalid key-value pairs\n    for key, rep in STR_REPL.items():\n        txt = txt.replace(key, rep)\n    # Check for missing spaces in front of cloud layers\n    # Ex: TSFEW004SCT012FEW///CBBKN080\n    for cloud in CLOUD_LIST:\n        if cloud in txt and ' ' + cloud not in txt:\n            start, counter = 0, 0\n            while txt.count(cloud) != txt.count(' ' + cloud):\n                cloud_index = start + txt[start:].find(cloud)\n                if len(txt[cloud_index:]) >= 3:\n                    target = txt[cloud_index + len(cloud):cloud_index + len(cloud) + 3]\n                    if target.isdigit() or not target.strip('/'):\n                        txt = txt[:cloud_index] + ' ' + txt[cloud_index:]\n                start = cloud_index + len(cloud) + 1\n                # Prevent infinite loops\n                if counter > txt.count(cloud):\n                    break\n                counter += 1\n    return stid + txt"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsanitize a line of text so that it can be recognized by the user.", "response": "def sanitize_line(txt: str) -> str:\n    \"\"\"\n    Fixes common mistakes with 'new line' signifiers so that they can be recognized\n    \"\"\"\n    for key in LINE_FIXES:\n        index = txt.find(key)\n        if index > -1:\n            txt = txt[:index] + LINE_FIXES[key] + txt[index + len(key):]\n    # Fix when space is missing following new line signifiers\n    for item in ['BECMG', 'TEMPO']:\n        if item in txt and item + ' ' not in txt:\n            index = txt.find(item) + len(item)\n            txt = txt[:index] + ' ' + txt[index:]\n    return txt"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if a space should be created between two items.", "response": "def extra_space_exists(str1: str, str2: str) -> bool:  # noqa\n    \"\"\"\n    Return True if a space shouldn't exist between two items\n    \"\"\"\n    ls1, ls2 = len(str1), len(str2)\n    if str1.isdigit():\n        # 10 SM\n        if str2 in ['SM', '0SM']:\n            return True\n        # 12 /10\n        if ls2 > 2 and str2[0] == '/' and str2[1:].isdigit():\n            return True\n    if str2.isdigit():\n        # OVC 040\n        if str1 in CLOUD_LIST:\n            return True\n        # 12/ 10\n        if ls1 > 2 and str1.endswith('/') and str1[:-1].isdigit():\n            return True\n        # 12/1 0\n        if ls2 == 1 and ls1 > 3 and str1[:2].isdigit() and '/' in str1 and str1[3:].isdigit():\n            return True\n        # Q 1001\n        if str1 in ['Q', 'A']:\n            return True\n    # 36010G20 KT\n    if str2 == 'KT' and str1[-1].isdigit() \\\n            and (str1[:5].isdigit() or (str1.startswith('VRB') and str1[3:5].isdigit())):\n        return True\n    # 36010K T\n    if str2 == 'T' and ls1 >= 6 \\\n            and (str1[:5].isdigit() or (str1.startswith('VRB') and str1[3:5].isdigit())) and str1[-1] == 'K':\n        return True\n    # OVC022 CB\n    if str2 in CLOUD_TRANSLATIONS and str2 not in CLOUD_LIST and ls1 >= 3 and str1[:3] in CLOUD_LIST:\n        return True\n    # FM 122400\n    if str1 in ['FM', 'TL'] and (str2.isdigit() or (str2.endswith('Z') and str2[:-1].isdigit())):\n        return True\n    # TX 20/10\n    if str1 in ['TX', 'TN'] and str2.find('/') != -1:\n        return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsanitizing a list of wx report data.", "response": "def sanitize_report_list(wxdata: [str],  # type: ignore  # noqa\n                         remove_clr_and_skc: bool = True\n                         ) -> ([str], [str], str):  # type: ignore\n    \"\"\"\n    Sanitize wxData\n\n    We can remove and identify \"one-off\" elements and fix other issues before parsing a line\n\n    We also return the runway visibility and wind shear since they are very easy to recognize\n    and their location in the report is non-standard\n    \"\"\"\n    shear = ''\n    runway_vis = []\n    for i, item in reversed(list(enumerate(wxdata))):\n        ilen = len(item)\n        # Remove elements containing only '/'\n        if is_unknown(item):\n            wxdata.pop(i)\n        # Identify Runway Visibility\n        elif ilen > 4 and item[0] == 'R' \\\n                and (item[3] == '/' or item[4] == '/') and item[1:3].isdigit():\n            runway_vis.append(wxdata.pop(i))\n        # Remove RE from wx codes, REVCTS -> VCTS\n        elif ilen in [4, 6] and item.startswith('RE'):\n            wxdata[i] = item[2:]\n        # Fix a slew of easily identifiable conditions where a space does not belong\n        elif i and extra_space_exists(wxdata[i - 1], item):\n            wxdata[i - 1] += wxdata.pop(i)\n        # Remove spurious elements\n        elif item in ITEM_REMV:\n            wxdata.pop(i)\n        # Remove 'Sky Clear' from METAR but not TAF\n        elif remove_clr_and_skc and item in ['CLR', 'SKC']:\n            wxdata.pop(i)\n        # Replace certain items\n        elif item in ITEM_REPL:\n            wxdata[i] = ITEM_REPL[item]\n        # Remove ammend signifier from start of report ('CCA', 'CCB',etc)\n        elif ilen == 3 and item.startswith('CC') and item[2].isalpha():\n            wxdata.pop(i)\n        # Identify Wind Shear\n        elif ilen > 6 and item.startswith('WS') and item[5] == '/':\n            shear = wxdata.pop(i).replace('KT', '')\n        # Fix inconsistant 'P6SM' Ex: TP6SM or 6PSM -> P6SM\n        elif ilen > 3 and item[-4:] in VIS_PERMUTATIONS:\n            wxdata[i] = 'P6SM'\n        # Fix wind T\n        elif (ilen == 6 and item[5] in ['K', 'T'] and (item[:5].isdigit() or item.startswith('VRB'))) \\\n                or (ilen == 9 and item[8] in ['K', 'T'] and item[5] == 'G' and (\n                item[:5].isdigit() or item.startswith('VRB'))):\n            wxdata[i] = item[:-1] + 'KT'\n        # Fix joined TX-TN\n        elif ilen > 16 and len(item.split('/')) == 3:\n            if item.startswith('TX') and 'TN' not in item:\n                tn_index = item.find('TN')\n                wxdata.insert(i + 1, item[:tn_index])\n                wxdata[i] = item[tn_index:]\n            elif item.startswith('TN') and item.find('TX') != -1:\n                tx_index = item.find('TX')\n                wxdata.insert(i + 1, item[:tx_index])\n                wxdata[i] = item[tx_index:]\n    return wxdata, runway_vis, shear"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the report list and the removed altimeter item", "response": "def get_altimeter(wxdata: [str], units: Units, version: str = 'NA') -> ([str], Number):  # type: ignore  # noqa\n    \"\"\"\n    Returns the report list and the removed altimeter item\n\n    Version is 'NA' (North American / default) or 'IN' (International)\n    \"\"\"\n    if not wxdata:\n        return wxdata, None\n    altimeter = ''\n    target = wxdata[-1]\n    if version == 'NA':\n        # Version target\n        if target[0] == 'A':\n            altimeter = wxdata.pop()[1:]\n        # Other version but prefer normal if available\n        elif target[0] == 'Q':\n            if wxdata[-2][0] == 'A':\n                wxdata.pop()\n                altimeter = wxdata.pop()[1:]\n            else:\n                units.altimeter = 'hPa'\n                altimeter = wxdata.pop()[1:].lstrip('.')\n        # Else grab the digits\n        elif len(target) == 4 and target.isdigit():\n            altimeter = wxdata.pop()\n    elif version == 'IN':\n        # Version target\n        if target[0] == 'Q':\n            altimeter = wxdata.pop()[1:].lstrip('.')\n            if '/' in altimeter:\n                altimeter = altimeter[:altimeter.find('/')]\n        # Other version but prefer normal if available\n        elif target[0] == 'A':\n            if wxdata[-2][0] == 'Q':\n                wxdata.pop()\n                altimeter = wxdata.pop()[1:]\n            else:\n                units.altimeter = 'inHg'\n                altimeter = wxdata.pop()[1:]\n    # Some stations report both, but we only need one\n    if wxdata and (wxdata[-1][0] == 'A' or wxdata[-1][0] == 'Q'):\n        wxdata.pop()\n    # convert to Number\n    if not altimeter:\n        return wxdata, None\n    if units.altimeter == 'inHg':\n        value = altimeter[:2] + '.' + altimeter[2:]\n    else:\n        value = altimeter\n    return wxdata, make_number(value, altimeter)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the report list and removed Altimeter string Icing list and Turbulance list", "response": "def get_taf_alt_ice_turb(wxdata: [str]) -> ([str], str, [str], [str]):  # type: ignore\n    \"\"\"\n    Returns the report list and removed: Altimeter string, Icing list, Turbulance list\n    \"\"\"\n    altimeter = ''\n    icing, turbulence = [], []\n    for i, item in reversed(list(enumerate(wxdata))):\n        if len(item) > 6 and item.startswith('QNH') and item[3:7].isdigit():\n            altimeter = wxdata.pop(i)[3:7]\n        elif item.isdigit():\n            if item[0] == '6':\n                icing.append(wxdata.pop(i))\n            elif item[0] == '5':\n                turbulence.append(wxdata.pop(i))\n    return wxdata, altimeter, icing, turbulence"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if the given string is a valid temperature.", "response": "def is_possible_temp(temp: str) -> bool:\n    \"\"\"\n    Returns True if all characters are digits or 'M' (for minus)\n    \"\"\"\n    for char in temp:\n        if not (char.isdigit() or char == 'M'):\n            return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_temp_and_dew(wxdata: str) -> ([str], Number, Number):  # type: ignore\n    for i, item in reversed(list(enumerate(wxdata))):\n        if '/' in item:\n            # ///07\n            if item[0] == '/':\n                item = '/' + item.lstrip('/')\n            # 07///\n            elif item[-1] == '/':\n                item = item.rstrip('/') + '/'\n            tempdew = item.split('/')\n            if len(tempdew) != 2:\n                continue\n            valid = True\n            for j, temp in enumerate(tempdew):\n                if temp in ['MM', 'XX']:\n                    tempdew[j] = ''\n                elif not is_possible_temp(temp):\n                    valid = False\n                    break\n            if valid:\n                wxdata.pop(i)  # type: ignore\n                return (wxdata, *[make_number(t) for t in tempdew])\n    return wxdata, None, None", "response": "Returns the report list and removed temperature and dewpoint strings"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the report list and removed station ident and time strings", "response": "def get_station_and_time(wxdata: [str]) -> ([str], str, str):  # type: ignore\n    \"\"\"\n    Returns the report list and removed station ident and time strings\n    \"\"\"\n    station = wxdata.pop(0)\n    qtime = wxdata[0]\n    if wxdata and qtime.endswith('Z') and qtime[:-1].isdigit():\n        rtime = wxdata.pop(0)\n    elif wxdata and len(qtime) == 6 and qtime.isdigit():\n        rtime = wxdata.pop(0) + 'Z'\n    else:\n        rtime = ''\n    return wxdata, station, rtime"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the list of winds in the wxdata.", "response": "def get_wind(wxdata: [str], units: Units) -> ([str], Number, Number, Number, [Number]):  # type: ignore  # noqa\n    \"\"\"\n    Returns the report list and removed:\n    Direction string, speed string, gust string, variable direction list\n    \"\"\"\n    direction, speed, gust = '', '', ''\n    variable = []  # type: ignore\n    if wxdata:\n        item = copy(wxdata[0])\n        for rep in ['(E)']:\n            item = item.replace(rep, '')\n        item = item.replace('O', '0')\n        # 09010KT, 09010G15KT\n        if item.endswith('KT') \\\n                or item.endswith('KTS') \\\n                or item.endswith('MPS') \\\n                or item.endswith('KMH') \\\n                or ((len(item) == 5 or (len(item) >= 8 and item.find('G') != -1) and item.find('/') == -1)\n                    and (item[:5].isdigit() or (item.startswith('VRB') and item[3:5].isdigit()))):  # noqa\n            # In order of frequency\n            if item.endswith('KT'):\n                item = item.replace('KT', '')\n            elif item.endswith('KTS'):\n                item = item.replace('KTS', '')\n            elif item.endswith('MPS'):\n                units.wind_speed = 'm/s'\n                item = item.replace('MPS', '')\n            elif item.endswith('KMH'):\n                units.wind_speed = 'km/h'\n                item = item.replace('KMH', '')\n            direction = item[:3]\n            if 'G' in item:\n                g_index = item.find('G')\n                gust = item[g_index + 1:]\n                speed = item[3:g_index]\n            else:\n                speed = item[3:]\n            wxdata.pop(0)\n    # Separated Gust\n    if wxdata and 1 < len(wxdata[0]) < 4 and wxdata[0][0] == 'G' and wxdata[0][1:].isdigit():\n        gust = wxdata.pop(0)[1:]\n    # Variable Wind Direction\n    if wxdata and len(wxdata[0]) == 7 and wxdata[0][:3].isdigit() \\\n            and wxdata[0][3] == 'V' and wxdata[0][4:].isdigit():\n        variable = [make_number(i, speak=i) for i in wxdata.pop(0).split('V')]\n    # Convert to Number\n    direction = make_number(direction, speak=direction)  # type: ignore\n    speed = make_number(speed)  # type: ignore\n    gust = make_number(gust)  # type: ignore\n    return wxdata, direction, speed, gust, variable"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the report list and removed visibility string", "response": "def get_visibility(wxdata: [str], units: Units) -> ([str], Number):  # type: ignore\n    \"\"\"\n    Returns the report list and removed visibility string\n    \"\"\"\n    visibility = ''  # type: ignore\n    if wxdata:\n        item = copy(wxdata[0])\n        # Vis reported in statue miles\n        if item.endswith('SM'):  # 10SM\n            if item in ('P6SM', 'M1/4SM'):\n                visibility = item[:-2]\n            elif '/' not in item:\n                visibility = str(int(item[:item.find('SM')]))\n            else:\n                visibility = item[:item.find('SM')]  # 1/2SM\n            wxdata.pop(0)\n            units.visibility = 'sm'\n        # Vis reported in meters\n        elif len(item) == 4 and item.isdigit():\n            visibility = wxdata.pop(0)\n            units.visibility = 'm'\n        elif 7 >= len(item) >= 5 and item[:4].isdigit() \\\n                and (item[4] in ['M', 'N', 'S', 'E', 'W'] or item[4:] == 'NDV'):\n            visibility = wxdata.pop(0)[:4]\n            units.visibility = 'm'\n        elif len(item) == 5 and item[1:].isdigit() and item[0] in ['M', 'P', 'B']:\n            visibility = wxdata.pop(0)[1:]\n            units.visibility = 'm'\n        elif item.endswith('KM') and item[:item.find('KM')].isdigit():\n            visibility = item[:item.find('KM')] + '000'\n            wxdata.pop(0)\n            units.visibility = 'm'\n        # Vis statute miles but split Ex: 2 1/2SM\n        elif len(wxdata) > 1 and wxdata[1].endswith('SM') and '/' in wxdata[1] and item.isdigit():\n            vis1 = wxdata.pop(0)  # 2\n            vis2 = wxdata.pop(0).replace('SM', '')  # 1/2\n            visibility = str(int(vis1) * int(vis2[2]) + int(vis2[0])) + vis2[1:]  # 5/2\n            units.visibility = 'sm'\n    return wxdata, make_number(visibility)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef starts_new_line(item: str) -> bool:\n    if item in TAF_NEWLINE:\n        return True\n\n    for start in TAF_NEWLINE_STARTSWITH:\n        if item.startswith(start):\n            return True\n\n    return False", "response": "Returns True if the given element should start a new report line False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsplits a TAF report into a list of distinct time period lines.", "response": "def split_taf(txt: str) -> [str]:  # type: ignore\n    \"\"\"\n    Splits a TAF report into each distinct time period\n    \"\"\"\n    lines = []\n    split = txt.split()\n    last_index = 0\n    for i, item in enumerate(split):\n        if starts_new_line(item) and i != 0 and not split[i - 1].startswith('PROB'):\n            lines.append(' '.join(split[last_index:i]))\n            last_index = i\n    lines.append(' '.join(split[last_index:]))\n    return lines"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the report list and removed", "response": "def get_type_and_times(wxdata: [str]) -> ([str], str, str, str):  # type: ignore\n    \"\"\"\n    Returns the report list and removed:\n    Report type string, start time string, end time string\n    \"\"\"\n    report_type, start_time, end_time = 'FROM', '', ''\n    if wxdata:\n        # TEMPO, BECMG, INTER\n        if wxdata[0] in TAF_NEWLINE:\n            report_type = wxdata.pop(0)\n        # PROB[30,40]\n        elif len(wxdata[0]) == 6 and wxdata[0].startswith('PROB'):\n            report_type = wxdata.pop(0)\n    if wxdata:\n        # 1200/1306\n        if len(wxdata[0]) == 9 and wxdata[0][4] == '/' \\\n                and wxdata[0][:4].isdigit() and wxdata[0][5:].isdigit():\n            start_time, end_time = wxdata.pop(0).split('/')\n        # FM120000\n        elif len(wxdata[0]) > 7 and wxdata[0].startswith('FM'):\n            report_type = 'FROM'\n            if '/' in wxdata[0] and wxdata[0][2:].split('/')[0].isdigit() \\\n                    and wxdata[0][2:].split('/')[1].isdigit():\n                start_time, end_time = wxdata.pop(0)[2:].split('/')\n            elif wxdata[0][2:8].isdigit():\n                start_time = wxdata.pop(0)[2:6]\n            # TL120600\n            if wxdata and len(wxdata[0]) > 7 and wxdata[0].startswith('TL') \\\n                    and wxdata[0][2:8].isdigit():\n                end_time = wxdata.pop(0)[2:6]\n    return wxdata, report_type, start_time, end_time"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if report type is TEMPO or PROB", "response": "def _is_tempo_or_prob(report_type: str) -> bool:\n    \"\"\"\n    Returns True if report type is TEMPO or PROB__\n    \"\"\"\n    if report_type == 'TEMPO':\n        return True\n    if len(report_type) == 6 and report_type.startswith('PROB'):\n        return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the next FROM target value or an empty string if no next FROM target value is found.", "response": "def _get_next_time(lines: [dict], target: str) -> str:  # type: ignore\n    \"\"\"\n    Returns the next FROM target value or empty\n    \"\"\"\n    for line in lines:\n        if line[target] and not _is_tempo_or_prob(line['type']):\n            return line[target]\n    return ''"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_missing_taf_times(lines: [dict], start: Timestamp, end: Timestamp) -> [dict]:  # type: ignore\n    if not lines:\n        return lines\n    # Assign start time\n    lines[0]['start_time'] = start\n    # Fix other times\n    last_fm_line = 0\n    for i, line in enumerate(lines):\n        if _is_tempo_or_prob(line['type']):\n            continue\n        last_fm_line = i\n        # Search remaining lines to fill empty end or previous for empty start\n        for target, other, direc in (('start', 'end', -1), ('end', 'start', 1)):\n            target += '_time'\n            if not line[target]:\n                line[target] = _get_next_time(lines[i::direc][1:], other + '_time')\n    # Special case for final forcast\n    if last_fm_line:\n        lines[last_fm_line]['end_time'] = end\n    # Reset original end time if still empty\n    if lines and not lines[0]['end_time']:\n        lines[0]['end_time'] = end\n    return lines", "response": "Find any missing time issues in the TAF file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npulls out Max and Min temp at time items from wx list wxlist", "response": "def get_temp_min_and_max(wxlist: [str]) -> ([str], str, str):  # type: ignore\n    \"\"\"\n    Pull out Max temp at time and Min temp at time items from wx list\n    \"\"\"\n    temp_max, temp_min = '', ''\n    for i, item in reversed(list(enumerate(wxlist))):\n        if len(item) > 6 and item[0] == 'T' and '/' in item:\n            # TX12/1316Z\n            if item[1] == 'X':\n                temp_max = wxlist.pop(i)\n            # TNM03/1404Z\n            elif item[1] == 'N':\n                temp_min = wxlist.pop(i)\n            # TM03/1404Z T12/1316Z -> Will fix TN/TX\n            elif item[1] == 'M' or item[1].isdigit():\n                if temp_min:\n                    if int(temp_min[2:temp_min.find('/')].replace('M', '-')) \\\n                            > int(item[1:item.find('/')].replace('M', '-')):\n                        temp_max = 'TX' + temp_min[2:]\n                        temp_min = 'TN' + item[1:]\n                    else:\n                        temp_max = 'TX' + item[1:]\n                else:\n                    temp_min = 'TN' + item[1:]\n                wxlist.pop(i)\n    return wxlist, temp_max, temp_min"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of items removed from a given list of strings that are all digits from from_index.", "response": "def _get_digit_list(alist: [str], from_index: int) -> ([str], [str]):  # type: ignore\n    \"\"\"\n    Returns a list of items removed from a given list of strings\n    that are all digits from 'from_index' until hitting a non-digit item\n    \"\"\"\n    ret = []\n    alist.pop(from_index)\n    while len(alist) > from_index and alist[from_index].isdigit():\n        ret.append(alist.pop(from_index))\n    return alist, ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget Temperature and Altimeter lists for Oceania TAFs", "response": "def get_oceania_temp_and_alt(wxlist: [str]) -> ([str], [str], [str]):  # type: ignore\n    \"\"\"\n    Get Temperature and Altimeter lists for Oceania TAFs\n    \"\"\"\n    tlist, qlist = [], []  # type: ignore\n    if 'T' in wxlist:\n        wxlist, tlist = _get_digit_list(wxlist, wxlist.index('T'))\n    if 'Q' in wxlist:\n        wxlist, qlist = _get_digit_list(wxlist, wxlist.index('Q'))\n    return wxlist, tlist, qlist"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sanitize_cloud(cloud: str) -> str:\n    if len(cloud) < 4:\n        return cloud\n    if not cloud[3].isdigit() and cloud[3] != '/':\n        if cloud[3] == 'O':\n            cloud = cloud[:3] + '0' + cloud[4:]  # Bad \"O\": FEWO03 -> FEW003\n        else:  # Move modifiers to end: BKNC015 -> BKN015C\n            cloud = cloud[:3] + cloud[4:] + cloud[3]\n    return cloud", "response": "Sanitize a cloud layer."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsplitting a cloud string into a list of strings.", "response": "def split_cloud(cloud: str) -> [str]:  # type: ignore\n    \"\"\"\n    Transforms a cloud string into a list of strings: [Type, Height (, Optional Modifier)]\n    \"\"\"\n    split = []\n    cloud = sanitize_cloud(cloud)\n    if cloud.startswith('VV'):\n        split.append(cloud[:2])\n        cloud = cloud[2:]\n    while len(cloud) >= 3:\n        split.append(cloud[:3])\n        cloud = cloud[3:]\n    if cloud:\n        split.append(cloud)\n    # Nullify unknown elements\n    for i, item in enumerate(split):\n        if is_unknown(item):\n            split[i] = None  # type: ignore\n    # Add null altitude or convert to int\n    if len(split) == 1:\n        split.append(None)  # type: ignore\n    elif isinstance(split[1], str) and split[1].isdigit():\n        split[1] = int(split[1])  # type: ignore\n    return split"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_clouds(wxdata: [str]) -> ([str], list):  # type: ignore\n    clouds = []\n    for i, item in reversed(list(enumerate(wxdata))):\n        if item[:3] in CLOUD_LIST or item[:2] == 'VV':\n            cloud = wxdata.pop(i)\n            clouds.append(make_cloud(cloud))\n    return wxdata, sorted(clouds, key=lambda cloud: (cloud.altitude, cloud.type))", "response": "Returns the report list and removed list of split cloud layers"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_flight_rules(vis: Number, ceiling: Cloud) -> int:\n    # Parse visibility\n    if not vis:\n        return 2\n    if vis.repr == 'CAVOK' or vis.repr.startswith('P6'):\n        vis = 10  # type: ignore\n    elif vis.repr.startswith('M'):\n        vis = 0  # type: ignore\n    # Convert meters to miles\n    elif len(vis.repr) == 4:\n        vis = vis.value * 0.000621371  # type: ignore\n    else:\n        vis = vis.value  # type: ignore\n    # Parse ceiling\n    cld = ceiling.altitude if ceiling else 99\n    # Determine flight rules\n    if (vis <= 5) or (cld <= 30):  # type: ignore\n        if (vis < 3) or (cld < 10):  # type: ignore\n            if (vis < 1) or (cld < 5):  # type: ignore\n                return 3  # LIFR\n            return 2  # IFR\n        return 1  # MVFR\n    return 0", "response": "Returns the current flight rules based on parsed METAR data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_taf_flight_rules(lines: [dict]) -> [dict]:  # type: ignore\n    for i, line in enumerate(lines):\n        temp_vis, temp_cloud = line['visibility'], line['clouds']\n        for report in reversed(lines[:i]):\n            if not _is_tempo_or_prob(report['type']):\n                if temp_vis == '':\n                    temp_vis = report['visibility']\n                if 'SKC' in report['other'] or 'CLR' in report['other']:\n                    temp_cloud = 'temp-clear'\n                elif temp_cloud == []:\n                    temp_cloud = report['clouds']\n                if temp_vis != '' and temp_cloud != []:\n                    break\n        if temp_cloud == 'temp-clear':\n            temp_cloud = []\n        line['flight_rules'] = FLIGHT_RULES[get_flight_rules(temp_vis, get_ceiling(temp_cloud))]\n    return lines", "response": "Get flight rules by looking for missing data in prior reports\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_ceiling(clouds: [Cloud]) -> Cloud:  # type: ignore\n    for cloud in clouds:\n        if cloud.altitude and cloud.type in ('OVC', 'BKN', 'VV'):\n            return cloud\n    return None", "response": "Returns the ceiling layer from a list of clouds"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse a date string in ddhhZ or ddhhmmZ format and returns a new date string", "response": "def parse_date(date: str, hour_threshold: int = 200):\n    \"\"\"\n    Parses a report timestamp in ddhhZ or ddhhmmZ format\n\n    This function assumes the given timestamp is within the hour threshold from current date\n    \"\"\"\n    # Format date string\n    date = date.strip('Z')\n    if len(date) == 4:\n        date += '00'\n    if not (len(date) == 6 and date.isdigit()):\n        return\n    # Create initial guess\n    now = datetime.utcnow()\n    guess = now.replace(day=int(date[0:2]),\n                        hour=int(date[2:4]) % 24,\n                        minute=int(date[4:6]) % 60,\n                        second=0, microsecond=0)\n    hourdiff = (guess - now) / timedelta(minutes=1) / 60\n    # Handle changing months\n    if hourdiff > hour_threshold:\n        guess += relativedelta(months=-1)\n    elif hourdiff < -hour_threshold:\n        guess += relativedelta(months=+1)\n    return guess"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef lookups(self, request, model_admin):\n        return [(q.slug, q.title) for q in Question.objects.all()]", "response": "Returns a list of tuples that are used to identify the question s slug and title."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef queryset(self, request, queryset):\n        if self.value():\n            parent = Question.objects.get(slug=self.value())\n            return Choice.objects.child_of(parent).order_by('-id')\n        return queryset", "response": "Returns the queryset based on the value\n            provided in the query string and retrievable via\n           . value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake sure this bucket exists and has only attributes we want it to have", "response": "def sync_one(self, aws_syncr, amazon, bucket):\n        \"\"\"Make sure this bucket exists and has only attributes we want it to have\"\"\"\n        if bucket.permission.statements:\n            permission_document = bucket.permission.document\n        else:\n            permission_document = \"\"\n\n        bucket_info = amazon.s3.bucket_info(bucket.name)\n        if not bucket_info.creation_date:\n            amazon.s3.create_bucket(bucket.name, permission_document, bucket)\n        else:\n            amazon.s3.modify_bucket(bucket_info, bucket.name, permission_document, bucket)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_python_inside(self, file_path):  # type: (str) -> bool\n        if file_path.endswith(\".py\"):\n            return True  # duh.\n\n        # not supporting surprising extensions, ege. .py2, .python, .corn_chowder\n\n        # extensionless\n        if \".\" not in file_path:\n            try:\n                firstline = self.open_this(file_path, \"r\").readline()\n                if firstline.startswith(\"#\") and \"python\" in firstline:\n                    return True\n            except:\n                pass\n        return False", "response": "Check if python is inside the file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef open_this(self, file, how):  # type: (str,str) -> Any\n        # BUG: risky code here, allowing relative\n        if not file.startswith(\"/\"):\n            # raise TypeError(\"this isn't absolute! We're siths, ya' know.\")\n            pass\n        if file in self.found_encoding:\n\n            encoding = self.found_encoding[file]\n        else:\n            file_bytes = io.open(file, \"rb\").read()\n            if not file_bytes:\n                encoding = \"utf-8\"\n            else:\n                encoding_info = chardet.detect(file_bytes)\n                encoding = encoding_info[\"encoding\"]\n            logger.debug(unicode(encoding))\n            try:\n                io.open(file, how, encoding=encoding).read()\n            except UnicodeDecodeError:\n                print(file)\n                print(file_bytes)\n\n            self.found_encoding[file] = encoding\n\n        return io.open(file, how, encoding=encoding)", "response": "Open file while detecting encoding. Use cached when possible."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_metadata(self, file_path):  # type: (str) ->str\n        config = configparser.ConfigParser()\n        config.read(file_path)\n        try:\n            return unicode(config[\"metadata\"][\"version\"])\n        except KeyError:\n            return \"\"", "response": "Read the version out of a. ini file or. cfg file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef MeanVarEstEQ(y, x, covariates, tol=1e-8):\n\n    pcount = covariates.shape[0] + 2\n    N = y.shape[0]\n    beta_count = pcount * 2\n    X = numpy.ones((N, pcount))\n    X[:, 1] = x\n\n    aprime = [1, 0]\n    idx = 2\n    for cov in covariates:\n        aprime.append(-numpy.mean(cov)/numpy.std(cov))\n        X[:, idx] = cov\n        idx += 1\n    aprime = numpy.matrix(aprime)\n\n    # http://stackoverflow.com/questions/7267226/range-for-floats\n    def frange(x, y, jump):\n        while x < y:\n            yield x\n            x += jump\n        yield 0\n\n    class PhiReturn(object):\n        def __init__(self, phi, dtheta):\n            self.phi = phi\n            self.dtheta = dtheta\n\n    def dot_diag(x, y):\n        \"\"\"This is a conveniance function to perform the following \\\n        in a more efficient manner:\n\n        :param x: arr1\n        :param y: arr2\n\n        x.dot(numpy.diag(y))\n\n        y must be a single dimensioned array\n\n        \"\"\"\n        if len(y.shape) != 1:\n            print >> sys.stderr, \"You can't pass an array of shape %s to dot_diag\" % (y.shape)\n            sys.exit(1)\n\n        result = numpy.empty(x.shape)\n        for i in range(0, x.shape[0]):\n            result[i] = x[i] * y\n\n        return result\n\n    def diag_dot(x, y):\n        \"\"\"diagonal multiply\n        \"\"\"\n        result = numpy.empty(y.shape)\n        for i in range(0, y.shape[0]):\n            result[i] = y[i] * x[i]\n        return result\n\n    def Phi(theta):\n        MM = y - numpy.dot(X, theta[0:pcount])\n        SS = numpy.exp(numpy.dot(-X, theta[pcount:]))\n        DD1 = MM * SS\n        DD2 = 0.5 * MM**2 * SS\n        Phi = numpy.hstack((DD1.dot(X), (DD2-0.5).dot(X)))\n\n        tX = X.transpose()\n\n        t1 = numpy.empty(tX.shape)\n        t2 = numpy.empty(tX.shape)\n        t3 = numpy.empty(tX.shape)\n        for i in range(0,tX.shape[0]):\n            t1[i] = tX[i]*-SS\n            t2[i] = tX[i]*-DD1\n            t3[i] = tX[i]*-DD2\n        t1 = t1.dot(X)\n        t2 = t2.dot(X)\n        t3 = t3.dot(X)\n\n        dtheta = numpy.hstack((numpy.vstack((t1, t2)), numpy.vstack((t2, t3))))\n        return PhiReturn(Phi, dtheta)\n\n\n\n    class MvSolveReturn(object):\n        def __init__(self, theta, dtheta):\n            self.theta = theta\n            self.dtheta = dtheta\n\n    def MVsolve(theta_new):\n        solution_found = False\n\n        mvsolve_iterations = 0\n\n        while not solution_found:\n            theta_old = theta_new.copy()\n            tmp = Phi(theta_old)\n            #print \"ITR\", mvsolve_iterations, numpy.mean(theta_new),numpy.sum(numpy.absolute(theta_new - theta_old))\n            theta_new = theta_old - scipy.linalg.solve(tmp.dtheta, tmp.phi)\n            mvsolve_iterations += 1\n\n            if (numpy.sum(numpy.absolute(theta_new - theta_old)) < tol):\n                tmp = Phi(theta_new)\n                solution_found = True\n            else:\n                if mvsolve_iterations > 25000:\n                    #print >> sys.stderr, mvsolve_iterations, \"failures\"\n                    raise UnsolvedLocus(\"\")\n\n        return MvSolveReturn(theta_new, tmp.dtheta), mvsolve_iterations\n\n    def MVcalcB(theta):\n        MM = y - X.dot(theta[0:pcount])\n        SS = numpy.exp(-X.dot(theta[pcount:]))\n        DD1 = MM * SS\n        DD2 = 0.5 * MM**2 * SS\n        AA = numpy.hstack((diag_dot(DD1, X), diag_dot(DD2-0.5,X)))\n\n        return numpy.transpose(AA).dot(AA)/ N\n\n\n    mod = None\n    itr = 0\n    total_iterations = 0\n    for i in frange(0.00, 1.0, 0.05):\n        theta=numpy.empty((beta_count))\n        theta[:] = i\n\n        try:\n            mod, iterations = MVsolve(theta)\n            total_iterations += iterations\n            if i > 0.05:\n                print >> sys.stderr, \"Completed: \", total_iterations, itr\n            break\n        except exceptions.ValueError as e:\n            pass\n        except numpy.linalg.linalg.LinAlgError as e:\n            pass\n        except Exception as inst:\n            #print type(inst)\n            pass\n        itr += 1\n\n    if not mod:\n        raise UnsolvedLocus(\"\")\n\n    try:\n        ainv = scipy.linalg.inv(mod.dtheta) * N\n    except:\n        raise ValueError(\"Singular Matrix Encountered\")\n    B = MVcalcB(mod.theta)\n    V = ainv.dot(B).dot(ainv.transpose())\n\n\n\n    # Focus on the two parameters of interest\n    theta2 = numpy.array([mod.theta[1], mod.theta[pcount+1]])\n    V2 = V[1:beta_count:pcount,1:beta_count:pcount]\n    pvalt = 1 - scipy.stats.chi2.cdf(theta2.dot(scipy.linalg.inv(V2)).dot(theta2) * N, 2)\n\n\n    ## From Chun's updated code:\n    theta= mod.theta\n    se = numpy.sqrt(numpy.diag(V)/N)\n    pval = 2*scipy.stats.norm.cdf(-numpy.absolute(mod.theta/se))\n    return pvalt, theta, pval, se, V/N", "response": "This function calculates the mean var of a set of genotypes using estimated equestions."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun the actual analysis on all valid loci for each phenotype.", "response": "def RunAnalysis(dataset, pheno_covar):\n    \"\"\"Run the actual analysis on all valid loci for each phenotype\n\n    :param dataset: GWAS parser object\n    :param pheno_covar: holds all of the variables\n\n    This acts as a standard iterator, returning a single MVResult for\n    each locus/phenotype combination.\n\n    Missing is evaluated as anything missing in any of the\n    phenotype, covariate(s) or genotype\n\n    \"\"\"\n    covar_missing = numpy.empty(dataset.ind_count, dtype=bool)\n    covar_missing[:] = False\n\n    total_covar_count = len(pheno_covar.covariate_data)\n    iteration_count = []\n\n    unsolved = []\n\n    pcount = 2+total_covar_count\n\n    std = get_standardizer()\n\n    for snp in dataset:\n        for y in pheno_covar:\n            st = SimpleTimer()\n            (pheno, covariates, nonmissing) = y.get_variables((snp.genotype_data==DataParser.missing_storage))\n\n\n            genotypes  = snp.genotype_data[nonmissing]\n\n            try:\n                pvalt, estimates, pvalues, se, v = RunMeanVar(pheno, genotypes, covariates)\n\n                lmgeno = genotypes\n                for c in covariates:\n                    lmgeno = lmgeno + c\n                lm = scipy.stats.linregress(pheno, lmgeno)[3]\n\n\n                betavars, se, pvalues = y.destandardize(estimates, se, pvalues=pvalues,v=v, nonmissing=nonmissing)\n\n                betas = betavars[0:pcount]\n                betase = se[0:pcount]\n                vars = betavars[pcount:]\n                varse = se[pcount:]\n\n                # Check for invalid output\n                for var in betavars + se + list(pvalues):\n                    if numpy.isnan(var):\n                        raise NanInResult()\n\n                nonmissing_ct = numpy.sum(nonmissing)\n\n                result = MVResult(\n                                snp.chr,\n                                snp.pos,\n                                snp.rsid,\n                                snp.major_allele,\n                                snp.minor_allele,\n                                dataset.get_effa_freq(genotypes),\n                                non_miss_count=nonmissing_ct,\n                                ph_label=y.get_phenotype_name(),\n                                p_mvtest=pvalt,\n                                beta_values=list(betas)+list(vars),\n                                pvalues=pvalues,\n                                stderrors=list(betase) + list(varse),\n                                maf=snp.maf,\n                                covar_labels=y.get_covariate_names(),\n                                lm=lm,\n                                runtime = st.runtime(),\n                )\n\n                result.blin = estimates[0:pcount]\n                result.bvar = estimates[pcount:]\n                yield result\n            except NanInResult as e:\n                print >> sys.stderr, \"\\t\".join([str(x) for x in [\n                                snp.chr,\n                                snp.pos,\n                                snp.rsid,\n                                y.get_phenotype_name(),\n                                \"%d\" % (numpy.sum(nonmissing)),\n                                snp.major_allele,\n                                snp.minor_allele,\n                                snp.allele_count2,\n                                \"NAN-Found\",\n                                \"MAF=%0.4f\" % (snp.maf)]])\n            except ValueError as e:\n                print >> sys.stderr, \"\\t\".join([str(x) for x in [\n                                snp.chr,\n                                snp.pos,\n                                snp.rsid,\n                                y.get_phenotype_name(),\n                                \"%d\" % (numpy.sum(nonmissing)),\n                                snp.major_allele,\n                                snp.minor_allele,\n                                snp.allele_count2,\n                                \"Unsolvable\",\n                                \"MAF=%0.4f\" % (snp.maf)]])\n            except UnsolvedLocus as e:\n                print >> sys.stderr, \"\\t\".join([str(x) for x in [\n                                snp.chr,\n                                snp.pos,\n                                snp.rsid,\n                                y.get_phenotype_name(),\n                                \"%d\" % (numpy.sum(nonmissing)),\n                                snp.major_allele,\n                                snp.minor_allele,\n                                snp.allele_count2,\n                                \"Unsolved\",\n                                \"MAF=%0.4f\" % (snp.maf)]])\n                unsolved.append(snp)\n    if len(unsolved)>0:\n        print >> sys.stderr, \"Total unsolvable loci: \", len(unsolved)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a string to a XML name.", "response": "def toXMLname(string):\n    \"\"\"Convert string to a XML name.\"\"\"\n    if string.find(':') != -1 :\n        (prefix, localname) = string.split(':',1)\n    else:\n        prefix = None\n        localname = string\n    \n    T = unicode(localname)\n\n    N = len(localname)\n    X = [];\n    for i in range(N) :\n        if i< N-1 and T[i]==u'_' and T[i+1]==u'x':\n            X.append(u'_x005F_')\n        elif i==0 and N >= 3 and \\\n                 ( T[0]==u'x' or T[0]==u'X' ) and \\\n                 ( T[1]==u'm' or T[1]==u'M' ) and \\\n                 ( T[2]==u'l' or T[2]==u'L' ):\n            X.append(u'_xFFFF_' + T[0])\n        elif (not _NCNameChar(T[i])) or (i==0 and not _NCNameStartChar(T[i])):\n            X.append(_toUnicodeHex(T[i]))\n        else:\n            X.append(T[i])\n    \n    if prefix:\n        return \"%s:%s\" % (prefix, u''.join(X))\n    return u''.join(X)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert XML name to unicode string.", "response": "def fromXMLname(string):\n    \"\"\"Convert XML name to unicode string.\"\"\"\n\n    retval = sub(r'_xFFFF_','', string )\n\n    def fun( matchobj ):\n        return _fromUnicodeHex( matchobj.group(0) )\n\n    retval = sub(r'_x[0-9A-Za-z]+_', fun, retval )\n        \n    return retval"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a raw string to a FeatureCollection.", "response": "def html_to_fc(html=None, clean_html=None, clean_visible=None, encoding=None, url=None,\n               timestamp=None, other_features=None):\n    '''`html` is expected to be a raw string received over the wire from a\n    remote webserver, and `encoding`, if provided, is used to decode\n    it.  Typically, encoding comes from the Content-Type header field.\n    The :func:`~streamcorpus_pipeline._clean_html.make_clean_html`\n    function handles character encodings.\n\n    '''\n    def add_feature(name, xs):\n        if name not in fc:\n            fc[name] = StringCounter()\n        fc[name] += StringCounter(xs)\n\n    timestamp = timestamp or int(time.time() * 1000)\n    other_features = other_features or {}\n\n    if clean_html is None:\n        if html is not None:\n            try:\n                clean_html_utf8 = make_clean_html(html, encoding=encoding)\n            except: \n                logger.warn('dropping doc because:', exc_info=True)\n                return\n            clean_html = clean_html_utf8.decode('utf-8')\n        else:\n            clean_html_utf8 = u''\n            clean_html = u''\n    else:\n        clean_html_utf8 = u''\n\n    if clean_visible is None or len(clean_visible) == 0:\n        clean_visible = make_clean_visible(clean_html_utf8).decode('utf-8')\n    elif isinstance(clean_visible, str):\n        clean_visible = clean_visible.decode('utf-8')\n\n    fc = FeatureCollection()\n    fc[u'meta_raw'] = html and uni(html, encoding) or u''\n    fc[u'meta_clean_html'] = clean_html\n    fc[u'meta_clean_visible'] = clean_visible\n    fc[u'meta_timestamp'] = unicode(timestamp)\n\n    url = url or u''\n\n    fc[u'meta_url'] = uni(url)\n\n    add_feature(u'icq', features.ICQs(clean_visible))\n    add_feature(u'skype', features.skypes(clean_visible))\n    add_feature(u'phone', features.phones(clean_visible))\n    add_feature(u'email', features.emails(clean_visible))\n    bowNP, normalizations = features.noun_phrases(\n        cleanse(clean_visible), included_unnormalized=True)\n    add_feature(u'bowNP', bowNP)\n    bowNP_unnorm = chain(*normalizations.values())\n    add_feature(u'bowNP_unnorm', bowNP_unnorm)\n\n    add_feature(u'image_url', features.image_urls(clean_html))\n    add_feature(u'a_url', features.a_urls(clean_html))\n\n    ## get parsed versions, extract usernames\n    fc[u'img_url_path_dirs'] = features.path_dirs(fc[u'image_url'])\n    fc[u'img_url_hostnames'] = features.host_names(fc[u'image_url'])\n    fc[u'usernames'] = features.usernames(fc[u'image_url'])\n\n    fc[u'a_url_path_dirs'] = features.path_dirs(fc[u'a_url'])\n    fc[u'a_url_hostnames'] = features.host_names(fc[u'a_url'])\n\n    fc[u'usernames'] += features.usernames(fc[u'a_url'])\n\n    #fc[u'usernames'] += features.usernames2(\n    #    fc[u'meta_clean_visible'])\n\n    # beginning of treating this as a pipeline...\n    xform = features.entity_names()\n    fc = xform.process(fc)\n\n    for feat_name, feat_val in other_features.iteritems():\n        fc[feat_name] += StringCounter(feat_val)\n\n    return fc"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_sip_to_fc(fc, tfidf, limit=40):\n    '''add \"bowNP_sip\" to `fc` using `tfidf` data\n    '''\n    if 'bowNP' not in fc:\n        return\n    if tfidf is None:\n        return\n    sips = features.sip_noun_phrases(tfidf, fc['bowNP'].keys(), limit=limit)\n    fc[u'bowNP_sip'] = StringCounter(sips)", "response": "add bowNP_sip to fc using tfidf data\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef process(self, t_path, name_info, i_str):\n        '''converts each :attr:`streamcorpus.StreamItem.body.clean_html` from\n        `t_path` into a :class:`~dossier.fc.FeatureCollection` and saves it in\n        a :class:`~dossier.store.Store` configured with the global `kvlayer`\n        config.\n\n        '''\n        def cids_and_fcs():\n            count = 0\n            seen = set()\n            for si in Chunk(t_path):\n                clean_html = getattr(si.body, 'clean_html', '')\n                if clean_html is None or len(clean_html.strip()) == 0:\n                    logger.warn('dropping SI lacking clean_html: %r', si.abs_url)\n                    continue\n                if 'other_features' in si.other_content:\n                    other_features = json.loads(si.other_content['other_features'].raw)\n                else:\n                    other_features = None\n                fc = html_to_fc(\n                    clean_html=si.body.clean_html.decode('utf-8'),\n                    clean_visible=si.body.clean_visible.decode('utf-8'),\n                    encoding='utf-8',\n                    url=si.abs_url,\n                    timestamp=si.stream_time.epoch_ticks,\n                    other_features=other_features,\n                )\n                add_sip_to_fc(fc, self.tfidf)\n                content_id = mk_content_id(str(fc.get(u'meta_url')))\n                if content_id in seen:\n                    logger.warn('dropping duplicate content_id=%r', content_id)\n                else:\n                    seen.add(content_id)\n                    yield content_id, fc\n                    count += 1\n            logger.info('saved %d FCs from %d SIs', count, len(seen))\n        self.store.put(cids_and_fcs())\n        ## interface spec of streamcorpus_pipeline writers requires\n        ## returning a list of locally generated paths.\n        return []", "response": "converts each streamitem. body. clean_html from t_path into a ~dossier. fc. FeatureCollection and saves it in self. store."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_password(self):\n\n        '''\n            a method to retrieve the password for the group mosquitto server\n\n        :return: string with group mosquitto server password\n\n        NOTE:   result is added to self.password property \n        '''\n\n        import requests\n        url = '%s/mqtt' % self.endpoint\n        params = {\n            'group': self.group_name\n        }\n        response = requests.put(url, params=params)\n        response_details = response.json()\n        self.password = response_details['password']\n\n        return self.password", "response": "a method to retrieve the password for the group mosquitto server"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_model(self):\n        \n        '''\n             a method to update model with latest training data\n             \n        :return: True\n        '''\n        \n        import requests\n        url = self.endpoint_public + '/calculate'\n        params = {\n            'group': self.group_name\n        }\n        response = requests.get(url, params=params)\n        response_details = response.json()\n        \n        return response_details['success']", "response": "a method to update model with latest training data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_position(self, user_id, track=False, confidence=False):\n\n        '''\n            a method to retrieve the latest position of a user\n\n        :param user_id: string with id of user\n        :param track: [optional] boolean to add user to self.positions\n        :param confidence: [optional] boolean to include the data model confidence scores\n        :return: dictionaries with position details\n\n        NOTE:   if user does not exist, then location and time are null values\n\n        { \n            'time': 0.0, \n            'location': 'location.id', \n            'id': 'user_id', \n            bayes: {}, # if confidence = True \n            svm: None, # if confidence = True \n            rf: {} # if confidence = True \n        }\n        '''\n\n        title = '%s.get_position' % self.__class__.__name__\n    \n    # validate inputs\n        input_fields = {\n            'user_id': user_id\n        }\n        for key, value in input_fields.items():\n            object_title = '%s(%s=%s)' % (title, key, str(value))\n            self.fields.validate(value, '.%s' % key, object_title)\n            \n    # construct empty response\n        position_details = {\n            'location': '',\n            'time': 0.0,\n            'id': user_id\n        }\n\n    # construct empty position history\n        position_history = []\n        \n    # compose request\n        import requests\n        url = self.endpoint + '/location'\n        params = {\n            'group': self.group_name,\n            'user': user_id,\n            'n': 1\n        }\n        response = requests.get(url, params=params)\n\n    # ingest response\n        response_details = response.json()\n        from labpack.records.time import labDT\n        for key in response_details['users'].keys():\n            if key == user_id:\n                for entry in response_details['users'][key]:\n                    if 'time' in entry.keys() and 'location' in entry.keys():\n                        time_string = entry['time'] \n                        time_string = time_string.replace(' +0000 UTC', 'Z')\n                        time_string = time_string.replace(' ', 'T')\n                        time_dt = labDT.fromISO(time_string).epoch()\n                        if confidence:\n                            for key, value in entry.items():\n                                position_details[key] = value\n                        position_details['time'] = time_dt\n                        position_details['location'] = entry['location']\n                        break\n\n        if track:\n            stored_position = {\n                'location': position_details['location'],\n                'time': position_details['time']\n            }\n            self.positions[user_id] = stored_position\n\n        return position_details", "response": "a method to retrieve the latest position of a user"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef publish(self, user_id, wifi_fingerprint, action='track', location_id='', port=1883):\n\n        '''\n            a method to publish wifi fingerprint data to a mosquitto server\n            \n        :param user_id: string with id of user\n        :param wifi_fingerprint: list of dictionaries with wifi fields mac and rssi \n        :param action: string with type of action to perform with data (track or learn)\n        :param location_id: [optional] string with classifier to add to learning data\n        :param port: [optional] integer with port to connect to\n        :return: True\n        '''\n        \n        title = '%s.publish' % self.__class__.__name__\n    \n    # validate inputs\n        input_fields = {\n            'user_id': user_id,\n            'wifi_fingerprint': wifi_fingerprint,\n            'action': action,\n            'location_id': location_id,\n            'port': port\n        }\n        for key, value in input_fields.items():\n            object_title = '%s(%s=%s)' % (title, key, str(value))\n            self.fields.validate(value, '.%s' % key, object_title)\n            \n    # compose message\n        fingerprint_string = ''\n        for signal in wifi_fingerprint:\n            fingerprint_string += signal['mac'].replace(':','')\n            rssi_string = str(signal['rssi']).replace('-','')\n            if len(rssi_string) > 2:\n                fingerprint_string += ' '\n            fingerprint_string += rssi_string\n\n    # compose channel\n        topic_string = '%s/track/%s' % (self.group_name, user_id)\n        if action == 'learn':\n            topic_string = '%s/learn/%s/%s' % (self.group_name, user_id, location_id)\n\n    # send a single message to server\n        import paho.mqtt.publish as mqtt_publish\n        mqtt_publish.single(\n            topic=topic_string,\n            payload=fingerprint_string,\n            auth={ 'username': self.group_name, 'password': self.password },\n            hostname=self.server_url,\n            port=port\n        )\n\n        return True", "response": "a method to publish wifi fingerprint data to a mosquitto server"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the average x y for a set of multiple x y arrays", "response": "def avgMultiplePlots(data, calc_mean=True, calc_std=False,\n                     calc_density=False, nsample=None):\n    \"\"\"\n    return the average (x,y) for a set of multiple x,y arrays\n    which can have a different length and resolution\n\n    data = ((xvals,yvals),(),,,)\n    assumes that x values are sorted\n    \"\"\"\n    xArr, yArr = bringPlotOverSameX(data, nsample)\n    out = [xArr]\n    if calc_mean:\n        out.append(np.nanmean(yArr, axis=0))\n    if calc_std:\n        out.append(np.nanstd(yArr, axis=0))\n    if calc_density:\n        out.append(len(yArr) - np.isnan(yArr).sum(axis=0))\n    return tuple(out)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bringPlotOverSameX(data, nsample=None):\n    x0 = [x[0] for x, _ in data if len(x)]\n    x1 = [x[-1] for x, _ in data if len(x)]\n\n    xmin = min(np.min(x0), np.min(x1))\n    xmax = max(np.max(x0), np.max(x1))\n\n    if nsample is None:\n        # calc from mean point density:\n        pn_per_dist = np.mean([len(x) / (abs(x[0] - x[-1]))\n                               for x, _ in data if len(x)])\n        #...and max distance:\n        nsample = round(pn_per_dist * abs(xmax - xmin))\n\n    xArr = np.linspace(xmin, xmax, nsample)\n\n    if x0[0] > x1[0]:\n        # values are reverse sorted\n        interpol = [np.interp(xArr, x[::-1], y[::-1],\n                              left=np.nan, right=np.nan) for x, y in data if len(x)]\n    else:\n        interpol = [np.interp(xArr, x, y,\n                              left=np.nan, right=np.nan) for x, y in data if len(x)]\n    return xArr, interpol", "response": "bring all plots x y to same x value base\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating and print a new log message and wait for an end log message", "response": "def log_begin_message(message):\n    \"\"\"\n    Create and print a new log message\n    waiting for an end log message\n    \"\"\"\n    global MESSAGE\n    MESSAGE = message\n    sys.stdout.write(\"[....] \")\n    sys.stdout.write(message)\n    sys.stdout.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef log_end_message(log):\n    if not log in MESSAGE_LOG.keys():\n        log = -1\n\n    res = colors.color_text(*MESSAGE_LOG[log][1])\n\n    sys.stdout.write(\"\\r[\" + res + \"] \" + MESSAGE + \"\\n\")", "response": "End a log message with a status\n    defined by log"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a log type to the global log.", "response": "def add_log_type(name, display, color, bcolor):\n    \"\"\"\n    name : call name (A-Z and '_')\n    display : display message in [-]\n    color : text color (see bashutils.colors)\n    bcolor : background color (see bashutils.colors)\n    \"\"\"\n    global MESSAGE_LOG\n    v_name = name.replace(\" \", \"_\").upper()\n    val = 0\n    lkey = MESSAGE_LOG.keys()\n    while val in lkey:\n        val += 1\n\n    MESSAGE_LOG[val] = [v_name, (display, color, bcolor,)]\n    setattr(LOG, v_name, val)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfetching files from the target directory and returns a list of all found files.", "response": "def _fetchFilesFromFolder(self, target, recursive):\n        '''\n            Fetches files from the target directory, and - if recursive\n            mode is on, all subdirectories.\n\n            Returns a list of all found files\n        '''\n        directory_items = os.walk(target)\n\n        # If recursive is false, fetch only the first tuple\n        if not recursive:\n            directory_items = [next(directory_items)]\n\n        targets = []\n        for dir_name, folders, files in directory_items:\n            for f in files:\n                targets.append(os.path.join(dir_name, f))\n\n        return targets"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef secure(self, targets, recursive):\n        '''\n            Saves information about each target file and/or folder and\n            creates a hard link from the file(s) to the vault directory\n        '''\n        for target in targets:\n            if os.path.isfile(target):\n                path, name = os.path.split(os.path.realpath(target))\n\n                target = Target(name, path)\n                target.secure()\n            else:\n                targets += self._fetchFilesFromFolder(target, recursive)", "response": "Saves information about each target file and folder and creates hard links from the file to the vault directory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting file from vault and removes database information", "response": "def remove(self, iid):\n        '''\n            Deletes file from vault and removes database information\n        '''\n        for index in iid:\n            target = Target.getTarget(index)\n\n            target.delete()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef deploy(self, iid):\n        '''\n            Links an item from the vault to the original path\n        '''\n        for index in iid:\n            target = Target.getTarget(index)\n\n            if target:\n                verbose('Deploying id {} from {} to {} with the name {}'\n                        .format(index, target.vault_path, target.path, target.name))\n                target.deploy()\n\n        verbose('Deploy complete')", "response": "Deploy an item from the vault to the original path"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndeploy all the items from the vault. Useful after a format", "response": "def deployAll(self):\n        '''\n            Deploys all the items from the vault. Useful after a format\n        '''\n        targets = [Target.getTarget(iid) for iid, n, p in self.db.listTargets()]\n\n        for target in targets:\n            target.deploy()\n\n        verbose('Deploy all complete')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef on_delete(resc, req, resp, rid):  # pylint: disable=unused-argument\n\n    signals.pre_req.send(resc.model)\n    signals.pre_req_delete.send(resc.model)\n\n    model = find(resc.model, rid)\n    goldman.sess.store.delete(model)\n\n    resp.status = falcon.HTTP_204\n\n    signals.post_req.send(resc.model)\n    signals.post_req_delete.send(resc.model)", "response": "Delete the single item\n    Upon a successful deletion an empty bodied 204 is returned."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind the model by id & serialize it back", "response": "def on_get(resc, req, resp, rid):\n    \"\"\" Find the model by id & serialize it back \"\"\"\n\n    signals.pre_req.send(resc.model)\n    signals.pre_req_find.send(resc.model)\n\n    model = find(resc.model, rid)\n    props = to_rest_model(model, includes=req.includes)\n\n    resp.last_modified = model.updated\n    resp.serialize(props)\n\n    signals.post_req.send(resc.model)\n    signals.post_req_find.send(resc.model)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef on_patch(resc, req, resp, rid):\n\n    signals.pre_req.send(resc.model)\n    signals.pre_req_update.send(resc.model)\n\n    props = req.deserialize()\n    model = find(resc.model, rid)\n\n    from_rest(model, props)\n    goldman.sess.store.update(model)\n\n    props = to_rest_model(model, includes=req.includes)\n    resp.last_modified = model.updated\n    resp.serialize(props)\n\n    signals.post_req.send(resc.model)\n    signals.post_req_update.send(resc.model)", "response": "Deserialize the payload & update the single item"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef decode(data):\n    dom = None\n    try:\n        dom = dhtmlparser.parseString(data)\n    except Exception, e:\n        raise MetaParsingException(\"Can't parse your XML data: %s\" % e.message)\n\n    root = dom.find(\"root\")\n\n    # check whether there is <root>s\n    if not root:\n        raise MetaParsingException(\"All elements have to be inside <root>.\")\n\n    # and make sure, that there is not too many <root>s\n    if len(root) > 1:\n        raise MetaParsingException(\"Too many <root> elements in your XML!\")\n\n    items = root[0].find(\"item\")\n\n    # check for items\n    if not items:\n        raise MetaParsingException(\"There are no <items> in your XML <root>!\")\n\n    decoded = []\n    for item in items:\n        if \"key\" not in item.params:\n            raise MetaParsingException(\n                \"There is no 'key' parameter in %s.\" % str(item)\n            )\n\n        decoded.append([\n            item.params[\"key\"],\n            item.getContent().strip()\n        ])\n\n    decoded = validator.check_structure(decoded)\n\n    return decoded", "response": "Handles decoding of the XML data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset prior values for a given set of entries in the prior sequence.", "response": "def prior(self, m, H):\n        \"\"\"\n    Set prior\n        Set prior values\n    Inputs :    \n        m : \n            mean of the prior\n        H : \n            precision matrix of the prior\n    Hiddens :\n        ln_H_ : log(det(H))/2\n            calculate this once to use everytime log prior is called\n        Hm    : < H, m >\n            calculate this once to use everytime proposal is called\n        \"\"\"\n        if self._prior == True:\n            raise Warning(\"prior information is already set\")\n        else: \n            self._prior = True\n\n        # mean\n        self._m = np.reshape(np.array(m), (-1,1))\n        try : \n            assert np.size(self._m) == self._n\n        except : \n            raise TypeError(\"mean has to be an array of size n\")\n\n        # precision\n        self._H     = np.array(H)\n        try : \n            assert np.shape(self._H) == (self._n, self._n)\n        except : \n            raise TypeError(\"precision has to be a matrix of shape n by n\")\n\n        # precalculations\n        self._ln_H_ = np.log(la.det(self._H))/2.\n        self._Hm    = np.dot(self._H, self._m)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting Back-off to Static Set the sampler parameters for static back off Inputs : max_steps : maximum optimization steps to be taken step_size : the step size of the back-off", "response": "def static(self, max_steps, step_size):\n        \"\"\"\n    Set Back-off to Static\n        Set the sampler parameters for static back off\n    Inputs :\n        max_steps :\n            maximum optimization steps to be taken\n        step_size : \n            the step size of the back-off\n        \"\"\"\n        self._dynamic = False\n        # begin checks      \n        try : \n            self._max_steps = int(max_steps)\n        except :\n            print(\"Error: Input 1 (max_steps) has to be an int.\")\n            return 0\n        try : \n            assert self._max_steps >= 0\n        except : \n            print(\"Warning: Input 1 (max_steps) has to be non-negative.\")\n            print(\"Setting max_steps to 0.\")\n            self._max_steps = 0\n\n        if max_steps > 0 :\n            try : \n                assert step_size == float(step_size)\n            except AssertionError :\n                print(\"Warning: Input 2 (step_size) is not a float. Converted.\")\n                step_size = float(step_size)\n            except :\n                print(\"Error: Input 2 (step_size) has to be a float.\")\n                return 0\n\n            try : \n                assert 0. < step_size < 1.\n            except : \n                print(\"Warning: Input 2 (step_size) has to be between 0 and 1.\")\n                print(\"Setting step_size to 0.2.\")\n                step_size = 0.2\n            self._step_size = step_size\n            if step_size**max_steps < 10**(-15):\n                print(\"Warning: Back-off gets dangerously small.\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dynamic(self, max_steps, opts={}):\n        self._dynamic = True\n\n        # begin checks      \n        try : \n            self._max_steps = int(max_steps)\n        except :\n            raise TypeError(\"input 1 (max_steps) has to be an integer\")\n            return 0\n        try : \n            assert self._max_steps >= 0\n        except : \n            raise Warning(\"input 1 (max_steps) has to be non-negative. Setting (max_steps) to 0.\")\n            self._max_steps = 0\n\n        self._opts = opts", "response": "Dynamic Switch\nAttributeNames Dynamic Switch\nAttributeNames Dynamic Switch\nDynamic Switch\nAttributeNames Dynamic Switch\nAttributeNames Dynamic Switch\nAttributeNames Dynamic Switch\n%"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sample(self, n_samples, divs=1, visual=False, safe=False):\n        if visual: \n            print(\"Sampling: 0%\")\n        for i in xrange(divs):\n            self._sample(int(n_samples/divs))\n            if visual: \n                sys.stdout.write(\"\\033[F\") # curser up\n                print(\"Sampling: \"+str(int(i*100./divs)+1)+'%')\n            if safe: \n                self.save(path=\"chain_{:}.dat\".format(i))\n        if n_samples % divs != 0:\n            self._sample(n_samples % divs)\n            if safe: \n                self.save(path=\"chain_{:}.dat\".format(divs))", "response": "Sample n_samples times from the chain and save them to the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save(self, path=\"chain.dat\"):\n        # create dictionary for data\n        dic = {}\n        dic['chain'] = self._chain.tolist()\n        dic['step_count'] = self._step_count.tolist()\n        dic['n_samples'] = self._n_samples\n        dic['n_accepted'] = self._n_accepted\n        dic['x'] = self._X['x'].tolist()\n        dic['f'] = self._X['f'].tolist()\n        dic['J'] = self._X['J'].tolist()\n\n        # write data to file\n        file = open(path, 'w')\n        json.dump(dic, file)\n        file.close()", "response": "Save the current state of the object to a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads data from file", "response": "def load(self, path=\"chain.dat\"):\n        \"\"\"\n    Load\n        Load data from file\n    Inputs  : \n        path :\n            specifies the path name of the file to be loaded from\n        \"\"\"\n        # read data from file\n        file = open(path, 'r')\n        dic = json.load(file)\n        file.close()\n\n        # get data from dictionary\n        self._chain = np.array(dic['chain'])\n        self._step_count = np.array(dic['step_count'])\n        self._n_samples = dic['n_samples']\n        self._n_accepted = dic['n_accepted']\n        self._X = {}\n        self._X['x'] = dic['x']\n        self._X['f'] = dic['f']\n        self._X['J'] = dic['J']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef acor(self, k = 5):\n        try:\n            import acor\n        except ImportError:\n            print(\"Can't import acor, please download it.\")\n            return 0\n        n = np.shape(self._chain)[1]\n        t = np.zeros(n)\n        for i in xrange(n):\n            t[i] = acor.acor(self._chain[:,i],k)[0]\n        return t", "response": "Returns the autocorrelation time of each parameter in the self - consistent window."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef error_bars(self, n_bins, d_min, d_max):\n        # fetch data\n        chain = self._chain\n        len_chain = len(chain)\n        try:\n            n_dims = np.shape(chain)[1]\n        except:\n            n_dims = 1\n\n        # begin checks\n        try: \n            assert n_bins == int(n_bins)\n        except: \n            raise TypeError(\"number of bins has to be an integer\")\n        d_min = np.reshape(np.array(d_min), (-1,1))\n        d_max = np.reshape(np.array(d_max), (-1,1))\n        try: \n            assert np.size(d_min) == n_dims\n        except: \n            raise TypeError(\"domain minimum has wrong size\")\n        try: \n            assert np.size(d_max) == n_dims\n        except: \n            raise TypeError(\"domain maximum has wrong size\")\n        # end checks\n\n        # initialize outputs\n        p_x = np.zeros(n_bins) # esitmate of posterior\n        error = np.zeros(n_bins) # error bars\n        x = np.zeros((n_dims, n_bins)) # centers of bins\n\n        # set dx\n        v = d_max-d_min\n        v_2 = np.dot(v.T, v)[0][0]\n\n        # bin count\n        for i in xrange(len_chain):\n            bin_no = int(np.floor(np.dot(chain[i].T-d_min,v)/v_2*n_bins)[0])\n            if n_bins > bin_no > -1:\n                p_x[bin_no] += 1.\n        # end count\n        dx = np.sqrt(v_2)/n_bins\n        p_x = p_x/(len_chain*dx)\n        # find error\n        for i in xrange(n_bins):\n            p = p_x[i]\n            error[i] = np.sqrt(p*(1./dx-p)/(len_chain))\n            x[:,i] = (d_min+v*(0.5+i)/n_bins)[0]\n        # end find\n        return x, p_x, error", "response": "Function to create error bars and error bars to plot the posterior for the current domain."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _sample(self, n_samples):\n        try : \n            n_samples = int(n_samples)\n        except :\n            raise TypeError(\"number of samples has to be an integer\")\n            exit()\n\n        # fetch info\n        X = self._proposal_params(self._X)\n        k_max = self._max_steps\n\n        # initialize \n        chain = np.zeros((n_samples, self._n)) \n        n_accepted = 0\n        step_count = np.zeros(k_max+2)\n\n        # begin outer loop\n        for i in xrange(n_samples):\n            accepted  = False       # check if sample is accepted\n            r_        = [1]         # list of step sizes\n            Z_        = [X]         # initialize list of Z s\n            self._r_  = r_ \n            log_P_z_x = 0. + X['log_p'] \n\n            k = 0 # back-off steps taken so far\n            while k <= k_max:\n                # get proposal\n                chi_z = False\n                while not chi_z:\n                    z = multi_normal(X, r_[-1])\n                    chi_z, f_z, J_z = self._f(z)\n                Z = self._proposal_params({'x':z,'f':f_z,'J':J_z})\n                Z_.append(Z)\n                self._Z_ = Z_\n\n                log_P_z_x += log_K(Z, X, r_[-1])\n\n                # N is the Numerator of the acceptance, N = P_x_z\n                self._N_is_0 = False # check to see if N = 0, to use in _log_P\n                log_N = self._log_P(X, Z, k)\n\n                # calculating acceptance probability\n                if self._N_is_0 == True :\n                    A_z_x = 0.\n                elif log_N >= log_P_z_x :\n                    A_z_x = 1.\n                else :\n                    A_z_x = np.exp(log_N - log_P_z_x)\n\n                # acceptance rejection\n                if  np.random.rand() <= A_z_x:\n                    accepted = True\n                    break\n                else : \n                    log_P_z_x += np.log(1. - A_z_x)\n                    self._back_off()\n                    k += 1                     \n            # end of steps for loop\n            if accepted == True :\n                chain[i,:] = z[:,0] \n                X = Z\n                # for statistics\n                n_accepted += 1    \n                step_count[k+1] += 1\n            else :\n                chain[i,:]  = X['x'][:,0]\n                # for statistics\n                step_count[0] += 1\n        # end outer loop\n\n        # update stored info\n        self._X = X\n\n        # outputs\n        if self._n_samples == 0 :\n            self._chain = chain\n            self._step_count = step_count\n        else :\n            self._chain = np.append(self._chain, chain, axis=0)\n            self._step_count = np.add(self._step_count, step_count)\n        self._n_samples += n_samples\n        self._n_accepted += n_accepted", "response": "Generate samples for posterior distribution using Gauss - Newton s algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _proposal_params(self, state):\n        x  = state['x']\n        f  = state['f']\n        J  = state['J']\n        JJ = np.dot(J.T,J)     \n\n        if self._prior: \n            m  = self._m\n            H  = self._H\n            Hm = self._Hm\n            # LL' = P = H+J'J \n            L  = la.cholesky(H+JJ)   \n            # mu = (P^-1)(Hm-J'f+J'Jx)\n            mu = la.solve(L.T,la.solve(L,Hm-np.dot(J.T,f)+np.dot(JJ,x))) \n        else: \n            # P = J'J\n            L = la.cholesky(JJ)\n            # mu = x-(P^-1)J'f\n            mu = x-la.solve(L.T,la.solve(L,np.dot(J.T,f)))\n\n        state['L'] = L        \n        state['mu'] = mu\n        state['log_p'] = self._log_post(x,f)\n        return state", "response": "Calculates the parameters needed for the proposal."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _log_P(self, X , Z, k):\n        r_ = self._r_\n        Z_ = self._Z_\n        # zero case\n        if k == 0 :\n            log_P = Z['log_p'] + log_K(X, Z, r_[k])\n        # recursice case\n        else :\n            P_zk_z = np.exp( self._log_P(Z_[k], Z, k-1) )\n            P_z_zk = np.exp( self._log_P(Z, Z_[k], k-1) ) \n            # flag\n            if P_zk_z <= P_z_zk :\n                self._N_is_0 = True\n                log_P = -np.inf\n            else : \n                log_P = np.log( P_zk_z - P_z_zk ) + log_K(X, Z, r_[k])\n        return log_P", "response": "Returns the log probability of transition from z to x with k steps"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _back_off(self):\n        q = self._step_size\n        r = self._r_[-1]\n        Z_ = self._Z_\n        if self._dynamic:\n            p_0   = la.norm(Z_[0]['f'])\n            dp_0  = p_0*2*la.norm(Z_[0]['J'])\n            p_r   = la.norm(Z_[-1]['f'])\n            dp_r  = p_0*2*la.norm(Z_[-1]['J'])\n            r_new = optimize(r, p_0**2, dp_0, p_r**2, dp_r)\n        else :\n            r_new = r * q  \n        self._r_.append(r_new)", "response": "Calculates the back off step size for the current state and current proposal."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate the log of the posterior density at the given value x and f_x.", "response": "def _log_post(self,x,f_x):\n        \"\"\"\n    Log of the posterior density\n        This is used to calculete acceptance probability for sampling.\n    Inputs  :\n        x   : \n            input value\n        f_x : f(x), \n            function value at x\n    Outputs : \n        log(p_x) : log[pi(x)]-||f(x)||^2/(2)\n            log of the posterior probability\n        \"\"\"\n        # least squares part   -||f(x)||^2/2\n        log_likelihood = (-la.norm(f_x)**2)/(2.)\n\n        # prior part           -(x-m)'H(x-m)/2\n        if self._prior: \n            m = self._m\n            H = self._H\n            log_prior = self._ln_H_-np.dot((x-m).T,np.dot(H,x-m))/2.\n            return log_prior+log_likelihood\n        else:\n            return log_likelihood"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nactivates the plugin. The plugin may override the method to do specific plugin activation handling. ideSettings - reference to the IDE Settings singleton see codimension/src/utils/settings.py ideGlobalData - reference to the IDE global settings see codimension/src/utils/globals.py Note: if overriden do not forget to call the base class activate()", "response": "def activate(self, ideSettings, ideGlobalData):\n        \"\"\"Activates the plugin.\n\n        The plugin may override the method to do specific\n        plugin activation handling.\n\n        ideSettings - reference to the IDE Settings singleton\n                      see codimension/src/utils/settings.py\n        ideGlobalData - reference to the IDE global settings\n                        see codimension/src/utils/globals.py\n\n        Note: if overriden do not forget to call the\n              base class activate()\n        \"\"\"\n        WizardInterface.activate(self, ideSettings, ideGlobalData)\n\n        self.__where = self.__getConfiguredWhere()\n\n        self.ide.editorsManager.sigTabClosed.connect(self.__collectGarbage)\n        self.ide.project.sigProjectChanged.connect(self.__collectGarbage)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef deactivate(self):\n        self.ide.project.sigProjectChanged.disconnect(self.__collectGarbage)\n        self.ide.editorsManager.sigTabClosed.disconnect(self.__collectGarbage)\n\n        WizardInterface.deactivate(self)", "response": "Deactivates the plugin.\n\n        The plugin may override the method to do specific\n        plugin deactivation handling.\n        Note: if overriden do not forget to call the\n              base class deactivate()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef populateMainMenu(self, parentMenu):\n        parentMenu.addAction(\"Configure\", self.configure)\n        parentMenu.addAction(\"Collect garbage\", self.__collectGarbage)", "response": "Populates the main menu with the items from the plugin manager."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npopulate the editing buffer context menu.", "response": "def populateBufferContextMenu(self, parentMenu):\n        \"\"\"Populates the editing buffer context menu.\n\n        The buffer context menu shown for the current edited/viewed file\n        will have an item with a plugin name and subitems which are\n        populated here. If no items were populated then the plugin menu\n        item will not be shown.\n\n        Note: when a buffer context menu is selected by the user it always\n              refers to the current widget. To get access to the current\n              editing widget the plugin can use: self.ide.currentEditorWidget\n              The widget could be of different types and some circumstances\n              should be considered, e.g.:\n              - it could be a new file which has not been saved yet\n              - it could be modified\n              - it could be that the disk file has already been deleted\n              - etc.\n              Having the current widget reference the plugin is able to\n              retrieve the infirmation it needs.\n        \"\"\"\n        parentMenu.addAction(\"Configure\", self.configure)\n        parentMenu.addAction(\"Collect garbage\", self.__collectGarbage)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef configure(self):\n        dlg = GCPluginConfigDialog(self.__where)\n        if dlg.exec_() == QDialog.Accepted:\n            newWhere = dlg.getCheckedOption()\n            if newWhere != self.__where:\n                self.__where = newWhere\n                self.__saveConfiguredWhere()", "response": "Configures the garbage collector plugin"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nproviding the saved configured value", "response": "def __getConfiguredWhere(self):\n        \"\"\"Provides the saved configured value\"\"\"\n        defaultSettings = {'where': GCPluginConfigDialog.SILENT}\n        configFile = self.__getConfigFile()\n        if not os.path.exists(configFile):\n            values = defaultSettings\n        else:\n            values = loadJSON(configFile,\n                              'garbage collector plugin settings',\n                              defaultSettings)\n        try:\n            value = values['where']\n            if value < GCPluginConfigDialog.SILENT or \\\n               value > GCPluginConfigDialog.LOG:\n                return GCPluginConfigDialog.SILENT\n            return value\n        except:\n            return GCPluginConfigDialog.SILENT"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncollects garbage and shows status bar message if needed.", "response": "def __collectGarbage(self, ignored=None):\n        \"\"\"Collects garbage\"\"\"\n        del ignored     # unused argument\n\n        collected = []\n        level0, level1, level2 = gc.get_count()\n\n        if level0 > 0:\n            collected.append(gc.collect(0))\n            if level1 > 0:\n                collected.append(gc.collect(1))\n                if level2 > 0:\n                    collected.append(gc.collect(2))\n\n        if self.__where == GCPluginConfigDialog.SILENT:\n            return\n\n        message = \"\"\n        if collected:\n            for index in range(len(collected)):\n                if collected[index] == 0:\n                    continue\n                if message:\n                    message += \", \"\n                message += \"generation \" + str(index) + \": \" + \\\n                           str(collected[index])\n            if message:\n                message = \"GC objects: \" + message\n        else:\n            message = \"No GC objects\"\n\n        if not message:\n            return\n\n        if self.__where == GCPluginConfigDialog.STATUS_BAR:\n            self.ide.showStatusBarMessage(message)\n        else:\n            logging.info(message)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef polyFitIgnoringOutliers(\n        x, y, deg=2, niter=3, nstd=2, return_outliers=False):\n    \"\"\"Returns:\n        (np.poly1d): callable function of polynomial fit excluding all outliers\n    Args:\n        deg (int): degree of polynomial fit\n        n_iter (int): do linear regression n times\n                      successive removing\n        nstd (float): exclude outliers, if their deviation\n            is > [nstd] * standard deviation\n        return_outliers (bool): also return outlier positions as 2. arg\n    \"\"\"\n    if return_outliers:\n        a = all_outliers = np.zeros_like(y, dtype=bool)\n    for i in range(niter):\n        poly = np.polyfit(x, y, deg)\n        p = np.poly1d(poly)\n        if i == niter - 1:\n            break\n        y_fit = p(x)\n        dy = y - y_fit\n        std = (dy**2).mean()**0.5\n        inliers = abs(dy) < nstd * std\n        if return_outliers:\n            a[~inliers] = True\n\n        if inliers.sum() > deg + 1:\n            x = x[inliers]\n            y = y[inliers]\n            if return_outliers:\n                a = a[inliers]\n        else:\n            break\n    if return_outliers:\n        return p, all_outliers\n    return p", "response": "Function that returns a polynomial fit excluding outliers."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrenders data into JSON returning a bytestring.", "response": "def render(self, data, accepted_media_type=None, renderer_context=None):\n        \"\"\"\n        Render `data` into JSON, returning a bytestring.\n        \"\"\"\n        if data is None:\n            return bytes()\n\n        renderer_context = renderer_context or {}\n        indent = self.get_indent(accepted_media_type, renderer_context)\n\n        if indent is None:\n            separators = SHORT_SEPARATORS if self.compact else LONG_SEPARATORS\n        else:\n            separators = INDENT_SEPARATORS\n\n        ret = json.dumps(\n            data, cls=self.encoder_class,\n            indent=indent, ensure_ascii=self.ensure_ascii,\n            separators=separators\n        )\n\n        # On python 2.x json.dumps() returns bytestrings if ensure_ascii=True,\n        # but if ensure_ascii=False, the return type is underspecified,\n        # and may (or may not) be unicode.\n        # On python 3.x json.dumps() returns unicode strings.\n        if isinstance(ret, six.text_type):\n            # We always fully escape \\u2028 and \\u2029 to ensure we output JSON\n            # that is a strict javascript subset. If bytes were returned\n            # by json.dumps() then we don't have these characters in any case.\n            # See: http://timelessrepo.com/json-isnt-a-javascript-subset\n            ret = ret.replace('\\u2028', '\\\\u2028').replace('\\u2029', '\\\\u2029')\n            return bytes(ret.encode('utf-8'))\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrender the data to HTML using Django s standard template rendering.", "response": "def render(self, data, accepted_media_type=None, renderer_context=None):\n        \"\"\"\n        Renders data to HTML, using Django's standard template rendering.\n\n        The template name is determined by (in order of preference):\n\n        1. An explicit .template_name set on the response.\n        2. An explicit .template_name set on this class.\n        3. The return result of calling view.get_template_names().\n        \"\"\"\n        renderer_context = renderer_context or {}\n        view = renderer_context['view']\n        request = renderer_context['request']\n        response = renderer_context['response']\n\n        if response.exception:\n            template = self.get_exception_template(response)\n        else:\n            template_names = self.get_template_names(response, view)\n            template = self.resolve_template(template_names)\n\n        context = self.resolve_context(data, request, response)\n        return template_render(template, context, request=request)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef render(self, data, accepted_media_type=None, renderer_context=None):\n        form = data.serializer\n\n        style = renderer_context.get('style', {})\n        if 'template_pack' not in style:\n            style['template_pack'] = self.template_pack\n        style['renderer'] = self\n\n        template_pack = style['template_pack'].strip('/')\n        template_name = template_pack + '/' + self.base_template\n        template = loader.get_template(template_name)\n        context = {\n            'form': form,\n            'style': style\n        }\n        return template_render(template, context)", "response": "Render serializer data and return an HTML form as a string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_default_renderer(self, view):\n        renderers = [renderer for renderer in view.renderer_classes\n                     if not issubclass(renderer, BrowsableAPIRenderer)]\n        non_template_renderers = [renderer for renderer in renderers\n                                  if not hasattr(renderer, 'get_template_names')]\n\n        if not renderers:\n            return None\n        elif non_template_renderers:\n            return non_template_renderers[0]()\n        return renderers[0]()", "response": "Return an instance of the first valid renderer."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the content of the object as if it had been rendered by the default renderer.", "response": "def get_content(self, renderer, data,\n                    accepted_media_type, renderer_context):\n        \"\"\"\n        Get the content as if it had been rendered by the default\n        non-documenting renderer.\n        \"\"\"\n        if not renderer:\n            return '[No renderers were found]'\n\n        renderer_context['indent'] = 4\n        content = renderer.render(data, accepted_media_type, renderer_context)\n\n        render_style = getattr(renderer, 'render_style', 'text')\n        assert render_style in ['text', 'binary'], 'Expected .render_style ' \\\n            '\"text\" or \"binary\", but got \"%s\"' % render_style\n        if render_style == 'binary':\n            return '[%d bytes of binary content]' % len(content)\n\n        return content"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_form_for_method(self, view, method, request, obj):\n        if method not in view.allowed_methods:\n            return  # Not a valid method\n\n        try:\n            view.check_permissions(request)\n            if obj is not None:\n                view.check_object_permissions(request, obj)\n        except exceptions.APIException:\n            return False  # Doesn't have permissions\n        return True", "response": "Returns True if a form should be shown for this method."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_rendered_html_form(self, data, view, method, request):\n        # See issue #2089 for refactoring this.\n        serializer = getattr(data, 'serializer', None)\n        if serializer and not getattr(serializer, 'many', False):\n            instance = getattr(serializer, 'instance', None)\n            if isinstance(instance, Page):\n                instance = None\n        else:\n            instance = None\n\n        # If this is valid serializer data, and the form is for the same\n        # HTTP method as was used in the request then use the existing\n        # serializer instance, rather than dynamically creating a new one.\n        if request.method == method and serializer is not None:\n            try:\n                kwargs = {'data': request.data}\n            except ParseError:\n                kwargs = {}\n            existing_serializer = serializer\n        else:\n            kwargs = {}\n            existing_serializer = None\n\n        with override_method(view, request, method) as request:\n            if not self.show_form_for_method(view, method, request, instance):\n                return\n\n            if method in ('DELETE', 'OPTIONS'):\n                return True  # Don't actually need to return a form\n\n            has_serializer = getattr(view, 'get_serializer', None)\n            has_serializer_class = getattr(view, 'serializer_class', None)\n\n            if (\n                (not has_serializer and not has_serializer_class) or\n                not any(is_form_media_type(parser.media_type) for parser in view.parser_classes)\n            ):\n                return\n\n            if existing_serializer is not None:\n                serializer = existing_serializer\n            else:\n                if has_serializer:\n                    if method in ('PUT', 'PATCH'):\n                        serializer = view.get_serializer(instance=instance, **kwargs)\n                    else:\n                        serializer = view.get_serializer(**kwargs)\n                else:\n                    # at this point we must have a serializer_class\n                    if method in ('PUT', 'PATCH'):\n                        serializer = self._get_serializer(view.serializer_class, view,\n                                                          request, instance=instance, **kwargs)\n                    else:\n                        serializer = self._get_serializer(view.serializer_class, view,\n                                                          request, **kwargs)\n\n            if hasattr(serializer, 'initial_data'):\n                serializer.is_valid()\n\n            form_renderer = self.form_renderer_class()\n            return form_renderer.render(\n                serializer.data,\n                self.accepted_media_type,\n                {'style': {'template_pack': 'rest_framework/horizontal'}}\n            )", "response": "Returns a string representing a rendered HTML form for the specified view and method."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_raw_data_form(self, data, view, method, request):\n        # See issue #2089 for refactoring this.\n        serializer = getattr(data, 'serializer', None)\n        if serializer and not getattr(serializer, 'many', False):\n            instance = getattr(serializer, 'instance', None)\n            if isinstance(instance, Page):\n                instance = None\n        else:\n            instance = None\n\n        with override_method(view, request, method) as request:\n            # Check permissions\n            if not self.show_form_for_method(view, method, request, instance):\n                return\n\n            # If possible, serialize the initial content for the generic form\n            default_parser = view.parser_classes[0]\n            renderer_class = getattr(default_parser, 'renderer_class', None)\n            if (hasattr(view, 'get_serializer') and renderer_class):\n                # View has a serializer defined and parser class has a\n                # corresponding renderer that can be used to render the data.\n\n                if method in ('PUT', 'PATCH'):\n                    serializer = view.get_serializer(instance=instance)\n                else:\n                    serializer = view.get_serializer()\n\n                # Render the raw data content\n                renderer = renderer_class()\n                accepted = self.accepted_media_type\n                context = self.renderer_context.copy()\n                context['indent'] = 4\n                content = renderer.render(serializer.data, accepted, context)\n            else:\n                content = None\n\n            # Generate a generic form that includes a content type field,\n            # and a content field.\n            media_types = [parser.media_type for parser in view.parser_classes]\n            choices = [(media_type, media_type) for media_type in media_types]\n            initial = media_types[0]\n\n            class GenericContentForm(forms.Form):\n                _content_type = forms.ChoiceField(\n                    label='Media type',\n                    choices=choices,\n                    initial=initial,\n                    widget=forms.Select(attrs={'data-override': 'content-type'})\n                )\n                _content = forms.CharField(\n                    label='Content',\n                    widget=forms.Textarea(attrs={'data-override': 'content'}),\n                    initial=content\n                )\n\n            return GenericContentForm()", "response": "Returns a form that allows for arbitrary content types to be tunneled via standard HTML forms."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the context used to render the data.", "response": "def get_context(self, data, accepted_media_type, renderer_context):\n        \"\"\"\n        Returns the context used to render.\n        \"\"\"\n        view = renderer_context['view']\n        request = renderer_context['request']\n        response = renderer_context['response']\n\n        renderer = self.get_default_renderer(view)\n\n        raw_data_post_form = self.get_raw_data_form(data, view, 'POST', request)\n        raw_data_put_form = self.get_raw_data_form(data, view, 'PUT', request)\n        raw_data_patch_form = self.get_raw_data_form(data, view, 'PATCH', request)\n        raw_data_put_or_patch_form = raw_data_put_form or raw_data_patch_form\n\n        response_headers = OrderedDict(sorted(response.items()))\n        renderer_content_type = ''\n        if renderer:\n            renderer_content_type = '%s' % renderer.media_type\n            if renderer.charset:\n                renderer_content_type += ' ;%s' % renderer.charset\n        response_headers['Content-Type'] = renderer_content_type\n\n        if getattr(view, 'paginator', None) and view.paginator.display_page_controls:\n            paginator = view.paginator\n        else:\n            paginator = None\n\n        context = {\n            'content': self.get_content(renderer, data, accepted_media_type, renderer_context),\n            'view': view,\n            'request': request,\n            'response': response,\n            'description': self.get_description(view, response.status_code),\n            'name': self.get_name(view),\n            'version': VERSION,\n            'paginator': paginator,\n            'breadcrumblist': self.get_breadcrumbs(request),\n            'allowed_methods': view.allowed_methods,\n            'available_formats': [renderer_cls.format for renderer_cls in view.renderer_classes],\n            'response_headers': response_headers,\n\n            'put_form': self.get_rendered_html_form(data, view, 'PUT', request),\n            'post_form': self.get_rendered_html_form(data, view, 'POST', request),\n            'delete_form': self.get_rendered_html_form(data, view, 'DELETE', request),\n            'options_form': self.get_rendered_html_form(data, view, 'OPTIONS', request),\n\n            'filter_form': self.get_filter_form(data, view, request),\n\n            'raw_data_put_form': raw_data_put_form,\n            'raw_data_post_form': raw_data_post_form,\n            'raw_data_patch_form': raw_data_patch_form,\n            'raw_data_put_or_patch_form': raw_data_put_or_patch_form,\n\n            'display_edit_forms': bool(response.status_code != 403),\n\n            'api_settings': api_settings\n        }\n        return context"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrenders the HTML for the browsable API representation.", "response": "def render(self, data, accepted_media_type=None, renderer_context=None):\n        \"\"\"\n        Render the HTML for the browsable API representation.\n        \"\"\"\n        self.accepted_media_type = accepted_media_type or ''\n        self.renderer_context = renderer_context or {}\n\n        template = loader.get_template(self.template)\n        context = self.get_context(data, accepted_media_type, renderer_context)\n        ret = template_render(template, context, request=renderer_context['request'])\n\n        # Munge DELETE Response code to allow us to return content\n        # (Do this *after* we've rendered the template so that we include\n        # the normal deletion response code in the output)\n        response = renderer_context['response']\n        if response.status_code == status.HTTP_204_NO_CONTENT:\n            response.status_code = status.HTTP_200_OK\n\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_context(self, data, accepted_media_type, renderer_context):\n        context = super(AdminRenderer, self).get_context(\n            data, accepted_media_type, renderer_context\n        )\n\n        paginator = getattr(context['view'], 'paginator', None)\n        if (paginator is not None and data is not None):\n            try:\n                results = paginator.get_results(data)\n            except (TypeError, KeyError):\n                results = data\n        else:\n            results = data\n\n        if results is None:\n            header = {}\n            style = 'detail'\n        elif isinstance(results, list):\n            header = results[0] if results else {}\n            style = 'list'\n        else:\n            header = results\n            style = 'detail'\n\n        columns = [key for key in header.keys() if key != 'url']\n        details = [key for key in header.keys() if key != 'url']\n\n        context['style'] = style\n        context['columns'] = columns\n        context['details'] = details\n        context['results'] = results\n        context['error_form'] = getattr(self, 'error_form', None)\n        context['error_title'] = getattr(self, 'error_title', None)\n        return context", "response": "Render the HTML for the browsable API representation."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef exception_uuid(exc_type, exc_value, exc_traceback):\n    hasher = hashlib.sha256(str(exc_type))\n    for file_name, line_no, func_name, source in traceback.extract_tb(exc_traceback):\n        hasher.update('\\n' + file_name + ':' + func_name + ':' + (source or ''))\n    return hasher.hexdigest()[:8]", "response": "Calculate a 32 - bit UUID for a given exception."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_ticket_for_exception(exc_type=None, exc_value=None, exc_traceback=None, title=None):\n    if exc_type and exc_value and exc_traceback:\n        mini_uuid = exception_uuid(exc_type, exc_value, exc_traceback)\n    else:\n        mini_uuid = None\n        \n    # Get the Shotgun.\n    shotgun = get_shotgun()\n    \n    # Look for an existing ticket, or create a new one.\n    if mini_uuid:\n        ticket = shotgun.find_one('Ticket', [('title', 'contains', '[%s]' % mini_uuid)])\n        if ticket:\n            return ticket['id']\n\n    if title is None:\n        if exc_type and exc_value:\n            title = '%s: %s' % (exc_type.__name__, exc_value)\n        else:\n            title = 'New Ticket'\n\n    uuid_tag = ' [%s]' % mini_uuid if mini_uuid else ''\n\n    # Automatically truncate to 255 escaped chars. Remember that the uuid\n    # tag will consume 11, and another 3 for ellipsis, and a guess as to\n    # how many due to the string escaping.\n    if len(title.encode('string-escape')) + len(uuid_tag) > 255:\n        title = title[:\n            255\n            - (len(title.encode('string-escape')) - len(title))\n            - len(uuid_tag)\n            - 3\n        ] + '...'\n    title = '%s%s' % (title, uuid_tag)\n\n    # Lookup where we are storing this ticket.\n    project_id = siteconfig.get('SGACTIONS_TICKET_PROJECT')\n    if not project_id:\n        raise ValueError('SGACTIONS_TICKET_PROJECT must be set via siteconfig')\n    tool_id = siteconfig.get('SGACTIONS_TICKET_TOOL')\n\n    ticket = shotgun.create('Ticket', dict(\n        title=title,\n        sg_status_list='rev', # Pending Review.\n        project={'type': 'Project', 'id': project_id},\n        sg_tool={'type': 'Tool', 'id': tool_id} if tool_id else None,\n    ))\n    \n    return ticket['id']", "response": "Get or create a ticket for the given exception."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reply_to_ticket(ticket_id, content, user_id=None):\n    \n    user_comment = None\n    exc_type = None\n\n    if isinstance(content, dict):\n        content = sorted(content.iteritems())\n\n    if not isinstance(content, basestring):\n        parts = []\n        for heading, part in content:\n            \n            # This one gets special cased into a Reply.\n            if heading.lower() == 'user comment':\n                user_comment = part\n\n            # Mappings.\n            if isinstance(part, dict):\n                parts.append((heading, '\\n'.join('%s = %r' % x\n                    for x in sorted(part.iteritems())\n                )))\n            \n            # Iterators.\n            elif isinstance(part, (list, tuple)):\n                \n                # Exceptions.\n                if (len(part) == 3 and\n                    issubclass(part[0], Exception) and\n                    isinstance(part[1], Exception) and\n                    isinstance(part[2], types.TracebackType)\n                ):\n                    exc_type = part[0]\n                    parts.append((heading, '\\n'.join(traceback.format_exception(*part)).rstrip()))\n                \n                # Iterators.\n                else:\n                    parts.append((heading, '\\n'.join('- %r' % x for x in part)))\n            \n            # The rest.\n            else:\n                parts.append((heading, str(part)))\n        \n        # Join the parts.\n        content = '\\n\\n'.join('%s\\n%s\\n%s' % (heading, '=' * len(heading), part) for heading, part in parts)\n    \n    # Get the Shotgun and Project.\n    # TODO: Somehow pass this in later.\n    shotgun = get_shotgun()\n\n    # Convert requested user ID to a login.\n    if user_id:\n        user = shotgun.find_one('HumanUser', [('id', 'is', user_id)], ['login'])\n        if user:\n            shotgun.config.sudo_as_login = user['login']\n\n    # Make sure we do have a login.\n    if not shotgun.config.sudo_as_login:\n        user = shotgun.find_one('HumanUser', [('email', 'starts_with', os.getlogin() + '@')], ['login'])\n        if user:\n            shotgun.config.sudo_as_login = user['login']\n    \n    reply = None\n\n    if user_comment:\n        reply = shotgun.create('Reply', {\n            'content': user_comment,\n            'entity': {'type': 'Ticket', 'id': ticket_id},\n        })\n\n    if content.strip():\n        with tempfile.NamedTemporaryFile(suffix='ticket-%d-reply.txt' % ticket_id) as fh:\n            fh.write(content)\n            fh.flush()\n            shotgun.upload('Ticket', ticket_id, fh.name, 'attachments',\n               display_name='Ticket-%d.%s.%s.txt' % (\n                    ticket_id,\n                    exc_type.__name__ if exc_type else 'details',\n                    datetime.datetime.now().strftime('%Y-%m-%dT%H:%M:%S'),\n                ),\n            )\n\n    return reply and reply['id'], content", "response": "Create a structured reply to a ticket."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of breadcrumbs given a url", "response": "def get_breadcrumbs(url, request=None):\n    \"\"\"\n    Given a url returns a list of breadcrumbs, which are each a\n    tuple of (name, url).\n    \"\"\"\n    from wave.reverse import preserve_builtin_query_params\n    from wave.settings import api_settings\n    from wave.views import APIView\n\n    view_name_func = api_settings.VIEW_NAME_FUNCTION\n\n    def breadcrumbs_recursive(url, breadcrumbs_list, prefix, seen):\n        \"\"\"\n        Add tuples of (name, url) to the breadcrumbs list,\n        progressively chomping off parts of the url.\n        \"\"\"\n\n        try:\n            (view, unused_args, unused_kwargs) = resolve(url)\n        except Exception:\n            pass\n        else:\n            # Check if this is a REST framework view,\n            # and if so add it to the breadcrumbs\n            cls = getattr(view, 'cls', None)\n            if cls is not None and issubclass(cls, APIView):\n                # Don't list the same view twice in a row.\n                # Probably an optional trailing slash.\n                if not seen or seen[-1] != view:\n                    suffix = getattr(view, 'suffix', None)\n                    name = view_name_func(cls, suffix)\n                    insert_url = preserve_builtin_query_params(prefix + url, request)\n                    breadcrumbs_list.insert(0, (name, insert_url))\n                    seen.append(view)\n\n        if url == '':\n            # All done\n            return breadcrumbs_list\n\n        elif url.endswith('/'):\n            # Drop trailing slash off the end and continue to try to\n            # resolve more breadcrumbs\n            url = url.rstrip('/')\n            return breadcrumbs_recursive(url, breadcrumbs_list, prefix, seen)\n\n        # Drop trailing non-slash off the end and continue to try to\n        # resolve more breadcrumbs\n        url = url[:url.rfind('/') + 1]\n        return breadcrumbs_recursive(url, breadcrumbs_list, prefix, seen)\n\n    prefix = get_script_prefix().rstrip('/')\n    url = url[len(prefix):]\n    return breadcrumbs_recursive(url, [], prefix, [])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _read_object(self, correlation_id, parameters):\n        path = self.get_path()\n\n        if path == None:\n            raise ConfigException(correlation_id, \"NO_PATH\", \"Missing config file path\")\n        \n        if not os.path.isfile(path):\n            raise FileException(correlation_id, 'FILE_NOT_FOUND', 'Config file was not found at ' + path)\n        \n        try:\n            with open(path, 'r') as file:\n                config = file.read()\n                config = self._parameterize(config, parameters)\n                return yaml.load(config)\n        except Exception as ex:\n            raise FileException(\n                correlation_id,\n                \"READ_FAILED\",\n                \"Failed reading configuration \" + path + \": \" + str(ex)\n            ).with_details(\"path\", path).with_cause(ex)", "response": "Reads the configuration file and converts it into a JSON object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_config(self, correlation_id, parameters):\n        value = self._read_object(correlation_id, parameters)\n        return ConfigParams.from_value(value)", "response": "Reads configuration and parameterize it with given values."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _read_config(correlation_id, path, parameters):\n        value = YamlConfigReader(path)._read_object(correlation_id, parameters)\n        return ConfigParams.from_value(value)", "response": "Reads a configuration file and parameterizes it with given values and returns a new ConfigParams object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self):\n\n        if self.args['add']:\n            self.action_add()\n\n        elif self.args['rm']:\n            self.action_rm()\n\n        elif self.args['show']:\n            self.action_show()\n\n        elif self.args['rename']:\n            self.action_rename()\n\n        else:\n            self.action_run_command()", "response": "Perform the specified action"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef init_db(self):\n\n        # database file\n        db_path = self.get_data_file(\"data.sqlite\")\n\n        # comect and create cursor\n        self.db = sqlite3.connect(db_path)\n        self.cursor = self.db.cursor()\n\n        # prep tables\n        self.db_exec('''\n            CREATE TABLE IF NOT EXISTS shortcuts (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL,\n                path TEXT NOT NULL,\n                command TEXT NOT NULL\n            )\n            ''')", "response": "Init database and prepare tables\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes a query in the DB table.", "response": "def db_query(self, query, args=None):\n        \"\"\"\n        Execute a query in the DB\n        \"\"\"\n        if args is None:\n            self.cursor.execute(query)\n        else:\n            self.cursor.execute(query, args)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexecuting a query in the DB", "response": "def db_exec(self, query, args=None):\n        \"\"\"\n        Execute a query in the DB\n        \"\"\"\n        if args is None:\n            self.db_query(query)\n        else:\n            self.db_query(query, args)\n\n        self.db.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if a shortcut of given name already exists in the DB", "response": "def shortcut_exists(self, name):\n        \"\"\"\n        Check if a shortcut of given name already exists in the DB\n        \"\"\"\n\n        self.db_query('''\n            SELECT * FROM shortcuts WHERE name=?\n            ''', (name,))\n\n        pth = self.db_fetch_one()\n\n        if pth is None or len(pth) == 0:\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef shortcut_str(self, path, cmd):\n\n        s = colored('| path = ', 'cyan') + colored(path, 'yellow') + '\\n' \\\n            + colored('| cmd  = ', 'cyan') + \\\n            colored(cmd, 'green', attrs=['bold'])\n\n        return s", "response": "Get a string with colors describing a shortcut"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef action_add(self):\n\n        # prepare values for new shortcut\n        path = self.args['--workdir'] or os.getcwd()\n        name = self.args['<name>']\n        cmd = self.args['<command>']\n\n        overwrite = self.args['--force']\n\n        # check for conflicts in DB\n        if not overwrite and self.shortcut_exists(name):\n            print_err('The shortcut \"%s\" already exists.' % name)\n            return\n\n        # if cmd has arguments, extract the command only\n        cmd_parts = [x.strip() for x in cmd.split(' ')]\n        cmd_real = cmd_parts[0]\n        cmd_tail = ' '.join(cmd_parts[1:])\n\n        # if cmd_real starts with ./, remove that\n        if cmd_real.startswith('./'):\n            cmd_real = cmd_real[2:]\n\n        # path to the file (if it's in the folder)\n        localfile = os.path.abspath(os.path.join(path, cmd_real))\n\n        # check if the file is present at the path given\n        if os.path.isfile(localfile):\n\n            # file extension\n            ext = os.path.splitext(cmd_real)[1]\n\n            # check for exacutable bit\n            # jar is executable, but cannot be run directly\n            if os.access(localfile, os.X_OK) and not ext == '.jar':\n                # file is executable\n                cmd = ''\n\n                if not cmd_real.startswith('/'):\n                    cmd = './'\n\n                cmd = cmd + cmd_real + ' ' + cmd_tail\n\n            else:\n                # not executable\n                # try to find interpreter for the file\n\n                interpreter = {\n                    '.py': 'python',\n                    '.rb': 'ruby',\n                    '.js': 'node',\n                    '.pl': 'perl',\n                    '.sh': 'sh',\n                    '.php': 'php',\n                    '.jar': 'java -jar',\n                }.get(ext, None)\n\n                # check if interpreter was found\n                if interpreter is None:\n\n                    msg = ('Could not make a shortcut to \"%s\":'\n                           + '\\n - not executable & unknown extension.') % localfile\n\n                    print_err(msg)\n                    return\n\n                cmd = str(interpreter) + ' ' + \\\n                    str(cmd_real) + ' ' + str(cmd_tail)\n        else:\n            # use cmd, as given.\n            pass\n\n        if overwrite:\n            self.db_exec('''\n                    DELETE FROM shortcuts WHERE name=?\n                    ''', (name,))\n        # save to DB\n        self.db_exec('''\n            INSERT INTO shortcuts (name, path, command)\n            VALUES (?, ?, ?)\n            ''', (str(name), str(path), str(cmd)))\n\n        # show OK message\n        msg = ('Shortcut \"%s\" has been created.\\n'\n               + self.shortcut_str(path, cmd)) % name\n\n        print_msg(msg)", "response": "Add a new shortcut to the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes a single or all shortcuts.", "response": "def action_rm(self):\n        \"\"\"\n        Delete a shortcut\n        \"\"\"\n\n        name = self.args['<name>']\n\n        if self.args['all']:\n            # delete all\n\n            if ask_yes_no('Really delete ALL shortcuts?', default='no'):\n                self.db_exec(''' DELETE FROM shortcuts ''')\n                print_msg(\"All shortcuts deleted.\")\n            else:\n                print_err(\"Aborted.\")\n                return\n\n        else:\n            # delete one\n\n            # find by name\n            self.db_exec('''\n                SELECT id FROM shortcuts WHERE name=?\n                ''', (name,))\n\n            q = self.db_fetch_one()\n            id = q[0]\n\n            # delete if exists\n            if q is None:\n                print_err('Shortcut \"%s\" does not exist!' % name)\n\n            else:\n                self.db_exec('''\n                    DELETE FROM shortcuts WHERE id=?\n                    ''', (id,))\n\n                # show OK message\n                print_msg('Shortcut \"%s\" deleted.' % name)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef action_rename(self):\n\n        # get old and new name from args\n        old = self.args['<old>']\n        new = self.args['<new>']\n\n        # select the old shortcut\n        self.db_query('''\n            SELECT id FROM shortcuts WHERE name=?\n            ''', (old,))\n        r = self.db_fetch_one()\n\n        # error if old doesn't exist\n        if r == None:\n            print_err('Shortcut \"%s\" does not exist!' % old)\n            return\n\n        # error if new exists\n        if self.shortcut_exists(new):\n            print_err('Shortcut \"%s\" already exists!' % new)\n            return\n\n        id = r[0]\n\n        # rename in DB\n        self.db_exec('''\n            UPDATE shortcuts SET name=? WHERE id=?\n            ''', (new, id))\n\n        # show OK message\n        print_msg('Shortcut \"%s\" renamed to \"%s\".' % (old, new))", "response": "Rename a shortcut in DB"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef action_show(self):\n\n        # helper function to display one row with colors\n        # r = [name, path, command]\n        def show_a_row(r):\n            msg = colored('Shortcut: ', 'cyan') \\\n                + colored(r[0], 'white', attrs=['bold']) + '\\n' \\\n                + self.shortcut_str(r[1], r[2]) + '\\n'\n\n            print(msg)\n\n        name = self.args['<name>']\n\n        if name is None or name == 'all':\n            # select all shortcuts\n            self.db_query('''\n                SELECT name,path,command FROM shortcuts ORDER BY name\n                ''')\n\n            entries = self.db_fetch_all()\n\n            # show the shortcuts\n            if (entries is None) or (len(entries) == 0):\n                print_err('No shortcuts defined.')\n            else:\n                for row in entries:\n                    show_a_row(row)\n\n        else:\n            # select shortcut by name\n\n            self.db_query('''\n                SELECT name,path,command FROM shortcuts WHERE name=?\n                ''', (name,))\n\n            rec = self.db_fetch_one()\n\n            # show the shortcut\n            if rec is None:\n                print_err('Shortcut \"%s\" does not exist.' % name)\n            else:\n                show_a_row(rec)", "response": "Show the value of a specific key - value entry in the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun a command in a folder", "response": "def action_run_command(self):\n        \"\"\"\n        Run a shortcut, if exists\n        \"\"\"\n\n        name = self.args['<name>']\n\n        # get entry from DB\n        self.db_query('''\n            SELECT path,command FROM shortcuts WHERE name=?\n            ''', (name,))\n\n        row = self.db_fetch_one()\n\n        if row is None:\n            print_err('Shortcut \"%s\" does not exist.' % name)\n            return\n\n        path = row[0]\n        cmd = row[1]\n\n        # show message\n        msg = colored('JumpRun shortcut', 'white', attrs=['bold']) + '\\n' + \\\n            self.shortcut_str(path, cmd) + '\\n'\n        print(msg)\n\n        # cd to the folder & run the command\n        os.chdir(path)\n\n        try:\n            subprocess.call(cmd, shell=True)\n        except KeyboardInterrupt:\n            print('')  # newline\n            return"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _wrap(self, value, priority=0):\n\n        if not callable(value):\n            raise TypeError(\"Only callable values can be stored in CallbackContainer\")\n\n        elif self.is_bound_method(value):\n\n            # We are dealing with a bound method. Method references aren't\n            # persistent, so instead we store a reference to the function\n            # and instance.\n\n            value = (weakref.ref(value.__func__),\n                     weakref.ref(value.__self__, self._auto_remove),\n                     priority)\n\n        else:\n\n            value = (value, priority)\n\n        return value", "response": "Wraps a value in a callback container."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_instance_status(self, instance_id, wait=True):\n\n        '''\n            a method to wait until AWS instance reports an OK status\n\n        :param instance_id: string of instance id on AWS\n        :param wait: [optional] boolean to wait for instance while initializing\n        :return: True\n        '''\n\n        title = '%s.check_instance_status' % self.__class__.__name__\n\n    # validate inputs\n        input_fields = {\n            'instance_id': instance_id\n        }\n        for key, value in input_fields.items():\n            object_title = '%s(%s=%s)' % (title, key, str(value))\n            self.fields.validate(value, '.%s' % key, object_title)\n\n    # notify status check\n        self.iam.printer('Querying AWS region %s for status of instance %s.' % (self.iam.region_name, instance_id))\n        \n    # check state of instance\n        self.iam.printer_on = False\n        self.check_instance_state(instance_id)\n        self.iam.printer_on = True\n\n    # check instance status\n        response = self.connection.describe_instance_status(\n            InstanceIds=[ instance_id ]\n        )\n        if not response['InstanceStatuses']:\n            from time import sleep\n            from timeit import timeit as timer\n            sleep(1)\n            response = self.connection.describe_instance_status(\n                InstanceIds=[ instance_id ]\n            )\n            self.iam.printer(response)\n        instance_status = response['InstanceStatuses'][0]['InstanceStatus']['Status']\n\n    # wait for instance status to be ok\n        if instance_status != 'ok' and wait:\n            from time import sleep\n            from timeit import timeit as timer\n            self.iam.printer('Waiting for initialization of instance %s to stop' % instance_id, flush=True)\n            delay = 3\n            status_timeout = 0\n            while instance_status != 'ok':\n                self.iam.printer('.', flush=True)\n                sleep(delay)\n                t3 = timer()\n                response = self.connection.describe_instance_status(\n                    InstanceIds=[ instance_id ]\n                )\n                t4 = timer()\n                response_time = t4 - t3\n                if 3 - response_time > 0:\n                    delay = 3 - response_time\n                else:\n                    delay = 0\n                status_timeout += 1\n                if status_timeout > 300:\n                    raise Exception('\\nTimeout. Failure initializing instance %s on AWS in less than 15min' % instance_id)\n                instance_status = response['InstanceStatuses'][0]['InstanceStatus']['Status']\n            print(' done.')\n        \n    # report outcome\n        self.iam.printer('Instance %s is %s.' % (instance_id, instance_status))\n        \n        return instance_status", "response": "a method to check the status of an AWS instance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_instance(self, instance_id):\n\n        '''\n            a method to retrieving the details of a single instances on AWS EC2\n\n        :param instance_id: string of instance id on AWS\n        :return: dictionary with instance attributes\n\n        relevant fields:\n        \n        'instance_id': '',\n        'image_id': '',\n        'instance_type': '',\n        'region': '',\n        'state': { 'name': '' },\n        'key_name': '',\n        'public_dns_name': '',\n        'public_ip_address': '',\n        'tags': [{'key': '', 'value': ''}]\n        '''\n\n        title = '%s.read_instance' % self.__class__.__name__\n\n    # validate inputs\n        input_fields = {\n            'instance_id': instance_id\n        }\n        for key, value in input_fields.items():\n            object_title = '%s(%s=%s)' % (title, key, str(value))\n            self.fields.validate(value, '.%s' % key, object_title)\n\n    # report query\n        self.iam.printer('Querying AWS region %s for properties of instance %s.' % (self.iam.region_name, instance_id))\n\n    # check instance state\n        self.iam.printer_on = False\n        self.check_instance_state(instance_id)\n        self.iam.printer_on = True\n\n    # discover details associated with instance id\n        try:\n            response = self.connection.describe_instances(InstanceIds=[ instance_id ])\n        except:\n            raise AWSConnectionError(title)\n        instance_info = response['Reservations'][0]['Instances'][0]\n\n    # repeat request if any instances are currently pending\n        if instance_info['State']['Name'] == 'pending':\n            self.check_instance_state(instance_info['InstanceId'])\n            try:\n                response = self.connection.describe_instances(\n                    InstanceIds=[ instance_id ]\n                )\n            except:\n                raise AWSConnectionError(title)\n            instance_info = response['Reservations'][0]['Instances'][0]\n\n    # create dictionary of instance details\n        instance_details = {\n            'instance_id': '',\n            'image_id': '',\n            'key_name': '',\n            'instance_type': '',\n            'region': self.iam.region_name,\n            'tags': [],\n            'public_ip_address': '',\n            'public_dns_name': '',\n            'security_groups': [],\n            'subnet_id': '',\n            'vpc_id': ''\n        }\n        instance_details = self.iam.ingest(instance_info, instance_details)\n\n        return instance_details", "response": "a method to retrieve the details of a single instance on AWS EC2"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_instance(self, instance_id):\n\n        '''\n            method for removing an instance from AWS EC2\n\n        :param instance_id: string of instance id on AWS\n        :return: string reporting state of instance\n        '''\n\n        title = '%s.delete_instance' % self.__class__.__name__\n\n    # validate inputs\n        input_fields = {\n            'instance_id': instance_id\n        }\n        for key, value in input_fields.items():\n            object_title = '%s(%s=%s)' % (title, key, str(value))\n            self.fields.validate(value, '.%s' % key, object_title)\n\n    # report query\n        self.iam.printer('Removing instance %s from AWS region %s.' % (instance_id, self.iam.region_name))\n\n    # retrieve state\n        old_state = self.check_instance_state(instance_id)\n\n    # discover tags associated with instance id\n        tag_list = []\n        try:\n            response = self.connection.describe_tags(\n                Filters=[ { 'Name': 'resource-id', 'Values': [ instance_id ] } ]\n            )\n            import re\n            aws_tag_pattern = re.compile('aws:')\n            for i in range(0, len(response['Tags'])):\n                if not aws_tag_pattern.findall(response['Tags'][i]['Key']):\n                    tag = {}\n                    tag['Key'] = response['Tags'][i]['Key']\n                    tag['Value'] = response['Tags'][i]['Value']\n                    tag_list.append(tag)\n        except:\n            raise AWSConnectionError(title)\n\n    # remove tags from instance\n        try:\n            self.connection.delete_tags(\n                Resources=[ instance_id ],\n                Tags=tag_list\n            )\n            self.iam.printer('Tags have been deleted from %s.' % instance_id)\n        except:\n            raise AWSConnectionError(title)\n\n    # stop instance\n        try:\n            self.connection.stop_instances(\n                InstanceIds=[ instance_id ]\n            )\n        except:\n            raise AWSConnectionError(title)\n\n    # terminate instance\n        try:\n            response = self.connection.terminate_instances(\n                InstanceIds=[ instance_id ]\n            )\n            new_state = response['TerminatingInstances'][0]['CurrentState']['Name']\n        except:\n            raise AWSConnectionError(title)\n\n    # report outcome and return true\n        self.iam.printer('Instance %s was %s.' % (instance_id, old_state))\n        self.iam.printer('Instance %s is %s.' % (instance_id, new_state))\n        return new_state", "response": "a method to remove an instance from AWS EC2"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_addresses(self, tag_values=None):\n        \n        '''\n            a method to list elastic ip addresses associated with account on AWS\n            \n        :param tag_values: [optional] list of tag values\n        :return: list of strings with ip addresses\n        '''\n        \n        title = '%s.list_addresses' % self.__class__.__name__\n\n    # validate inputs\n        input_fields = {\n            'tag_values': tag_values\n        }\n        for key, value in input_fields.items():\n            if value:\n                object_title = '%s(%s=%s)' % (title, key, str(value))\n                self.fields.validate(value, '.%s' % key, object_title)\n            \n    # add tags to method arguments\n        kw_args = {}\n        tag_text = ''\n        if tag_values:\n            kw_args = {\n                'Filters': [ { 'Name': 'tag-value', 'Values': tag_values } ]\n            }\n            from labpack.parsing.grammar import join_words\n            plural_value = ''\n            if len(tag_values) > 1:\n                plural_value = 's'\n            tag_text = ' with tag value%s %s' % (plural_value, join_words(tag_values))\n    \n    # report query\n        self.iam.printer('Querying AWS region %s for elastic ip addresses%s.' % (self.iam.region_name, tag_text))\n        address_list = []\n        \n    # discover details associated with instance id\n        try:\n            response = self.connection.describe_addresses(**kw_args)\n        except:\n            raise AWSConnectionError(title)\n\n    # populate address list with response\n        response_list = response['Addresses']\n        for address in response_list:\n            address_list.append(address['PublicIp'])\n\n        return address_list", "response": "a method to list elastic ip addresses associated with account on AWS\n            \n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_image_state(self, image_id, wait=True):\n\n        '''\n            method for checking the state of an image on AWS EC2\n\n        :param image_id: string with AWS id of image\n        :param wait: [optional] boolean to wait for image while pending\n        :return: string reporting state of image\n        '''\n\n        title = '%s.check_image_state' % self.__class__.__name__\n\n    # validate inputs\n        input_fields = {\n            'image_id': image_id\n        }\n        for key, value in input_fields.items():\n            object_title = '%s(%s=%s)' % (title, key, str(value))\n            self.fields.validate(value, '.%s' % key, object_title)\n\n    # notify state check\n        self.iam.printer('Querying AWS region %s for state of image %s.' % (self.iam.region_name, image_id))\n        \n    # check connection to API\n        try:\n            self.connection.describe_instances()\n        except:\n            raise AWSConnectionError(title)\n\n    # check existence of image\n        try:\n            response = self.connection.describe_images(ImageIds=[ image_id ])\n        except:\n            raise ValueError('\\nImage %s does not exist in your permission scope.' % image_id)\n        if not 'Images' in response.keys():\n            raise ValueError('\\nImage %s does not exist in your permission scope.' % image_id)\n        elif not response['Images'][0]:\n            raise ValueError('\\nImage %s does not exist in your permission scope.' % image_id)\n\n    # check into state of image\n        elif not 'State' in response['Images'][0].keys():\n            from time import sleep\n            from timeit import timeit as timer\n            self.iam.printer('Checking into the status of image %s' % image_id, flush=True)\n            state_timeout = 0\n            while not 'State' in response['Images'][0].keys():\n                self.iam.printer('.', flush=True)\n                sleep(3)\n                state_timeout += 1\n                response = self.connection.describe_images(\n                    ImageIds=[ image_id ]\n                )\n                if state_timeout > 3:\n                    raise Exception('\\nFailure to determine status of image %s.' % image_id)\n            self.iam.printer(' done.')\n        image_state = response['Images'][0]['State']\n\n    # return None if image has already been deregistered or is invalid\n        if image_state == 'deregistered':\n            self.iam.printer('Image %s has already been deregistered.' % image_id)\n            return None\n        elif image_state == 'invalid' or image_state == 'transient' or image_state == 'failed':\n            self.iam.printer('Image %s is %s.' % (image_id, image_state))\n            return None\n\n    # wait while image is pending\n        elif image_state == 'pending':\n            self.iam.printer('Image %s is %s.' % (image_id, image_state), flush=True)\n            if not wait:\n                return image_state\n            else:\n                from time import sleep\n                from timeit import timeit as timer\n                delay = 3\n                state_timeout = 0\n                while image_state != 'available':\n                    self.iam.printer('.', flush=True)\n                    sleep(delay)\n                    t3 = timer()\n                    response = self.connection.describe_images(\n                        ImageIds=[ image_id ]\n                    )\n                    t4 = timer()\n                    state_timeout += 1\n                    response_time = t4 - t3\n                    if 3 - response_time > 0:\n                        delay = 3 - response_time\n                    else:\n                        delay = 0\n                    if state_timeout > 300:\n                        raise Exception('\\nTimeout. Failure initializing image %s on AWS in less than 15min' % image_id)\n                    image_state = response['Images'][0]['State']\n                self.iam.printer(' done.')\n\n    # report outcome\n        self.iam.printer('Image %s is %s.' % (image_id, image_state))\n        \n        return image_state", "response": "a method to check the state of an image on AWS EC2"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_images(self, tag_values=None):\n\n        '''\n            a method to retrieve the list of images of account on AWS EC2\n\n        :param tag_values: [optional] list of tag values\n        :return: list of image AWS ids\n        '''\n\n        title = '%s.list_images' % self.__class__.__name__\n\n    # validate inputs\n        input_fields = {\n            'tag_values': tag_values\n        }\n        for key, value in input_fields.items():\n            if value:\n                object_title = '%s(%s=%s)' % (title, key, str(value))\n                self.fields.validate(value, '.%s' % key, object_title)\n            \n    # add tags to method arguments\n        kw_args = { 'Owners': [ self.iam.owner_id ] }\n        tag_text = ''\n        if tag_values:\n            kw_args = {\n                'Filters': [ { 'Name': 'tag-value', 'Values': tag_values } ]\n            }\n            from labpack.parsing.grammar import join_words\n            plural_value = ''\n            if len(tag_values) > 1:\n                plural_value = 's'\n            tag_text = ' with tag value%s %s' % (plural_value, join_words(tag_values))\n            \n    # request image details from AWS\n        self.iam.printer('Querying AWS region %s for images%s.' % (self.iam.region_name, tag_text))\n        image_list = []\n        try:\n            response = self.connection.describe_images(**kw_args)\n        except:\n            raise AWSConnectionError(title)\n        response_list = response['Images']\n\n    # repeat request\n        if not response_list:\n            from time import sleep\n            from timeit import default_timer as timer\n            self.iam.printer('No images found initially. Checking again', flush=True)\n            state_timeout = 0\n            delay = 3\n            while not response_list and state_timeout < 12:\n                self.iam.printer('.', flush=True)\n                sleep(delay)\n                t3 = timer()\n                try:\n                    response = self.connection.describe_images(**kw_args)\n                except:\n                    raise AWSConnectionError(title)\n                response_list = response['Images']\n                t4 = timer()\n                state_timeout += 1\n                response_time = t4 - t3\n                if 3 - response_time > 0:\n                    delay = 3 - response_time\n                else:\n                    delay = 0\n            self.iam.printer(' done.')\n\n    # wait until all images are no longer pending\n        for image in response_list:\n            image_list.append(image['ImageId'])\n\n    # report outcome and return results\n        if image_list:\n            print_out = 'Found image'\n            if len(image_list) > 1:\n                print_out += 's'\n            from labpack.parsing.grammar import join_words\n            print_out += ' %s.' % join_words(image_list)\n            self.iam.printer(print_out)\n        else:\n            self.iam.printer('No images found.')\n\n        return image_list", "response": "a method to retrieve the list of images of account on AWS EC2"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_image(self, instance_id, image_name, tag_list=None):\n\n        '''\n            method for imaging an instance on AWS EC2\n\n        :param instance_id: string with AWS id of running instance\n        :param image_name: string with name to give new image\n        :param tag_list: [optional] list of resources tags to add to image\n        :return: string with AWS id of image\n        '''\n\n        title = '%s.create_image' % self.__class__.__name__\n\n    # validate inputs\n        input_fields = {\n            'instance_id': instance_id,\n            'image_name': image_name,\n            'tag_list': tag_list\n        }\n        for key, value in input_fields.items():\n            if value:\n                object_title = '%s(%s=%s)' % (title, key, str(value))\n                self.fields.validate(value, '.%s' % key, object_title)\n\n    # check instance state\n        self.iam.printer('Initiating image of instance %s.' % instance_id)\n        instance_state = self.check_instance_state(instance_id)\n\n    # stop instance\n        if instance_state == 'running':\n            self.iam.printer('Instance %s is %s.\\nStopping instance %s to image it.' % (instance_id, instance_state, instance_id))\n            try:\n                response = self.connection.stop_instances(\n                    InstanceIds=[ instance_id ]\n                )\n                instance_state = response['StoppingInstances'][0]['CurrentState']['Name']\n            except:\n                raise AWSConnectionError(title)\n        if instance_state == 'stopping':\n            from time import sleep\n            from timeit import timeit as timer\n            self.iam.printer('Instance %s is %s' % (instance_id, instance_state), flush=True)\n            delay = 3\n            while instance_state == 'stopping':\n                self.iam.printer('.', flush=True)\n                sleep(delay)\n                t3 = timer()\n                try:\n                    response = self.connection.describe_instances(\n                        InstanceIds=[ instance_id ]\n                    )\n                except:\n                    raise AWSConnectionError(title)\n                t4 = timer()\n                response_time = t4 - t3\n                if 3 - response_time > 0:\n                    delay = 3 - response_time\n                else:\n                    delay = 0\n                instance_state = response['Reservations'][0]['Instances'][0]['State']['Name']\n            self.iam.printer(' done.')\n        if instance_state != 'stopped':\n            raise Exception('Instance %s is currently in a state that cannot be imaged.' % instance_id)\n\n    # discover tags associated with instance\n        old_tags = []\n        try:\n            response = self.connection.describe_instances(\n                    InstanceIds=[ instance_id ]\n                )\n            instance_tags = response['Reservations'][0]['Instances'][0]['Tags']\n            import re\n            aws_tag_pattern = re.compile('aws:')\n            for i in range(0, len(instance_tags)):\n                if not aws_tag_pattern.findall(instance_tags[i]['Key']):\n                    tag = {}\n                    tag['Key'] = instance_tags[i]['Key']\n                    tag['Value'] = instance_tags[i]['Value']\n                    old_tags.append(tag)\n        except:\n            raise AWSConnectionError(title)\n\n    # replace tag list if new tag input\n        new_tags = True\n        if not tag_list:\n            tag_list = self.iam.ingest(old_tags)\n            new_tags = False\n\n    # create image of the instance\n        try:\n            response = self.connection.create_image(\n                InstanceId=instance_id,\n                Name=image_name\n            )\n            image_id = response['ImageId']\n            self.iam.printer('Image %s is being created.' % image_name)\n        except:\n            raise AWSConnectionError(title)\n\n    # add tags to image\n        self.tag_image(image_id, tag_list)\n        if new_tags:\n            self.iam.printer('Tags from input have been added to image %s.' % image_id)\n        else:\n            self.iam.printer('Instance %s tags have been added to image %s.' % (instance_id, image_id))\n\n    # restart instance\n        try:\n            self.connection.start_instances(\n                    InstanceIds=[ instance_id ]\n            )\n            self.iam.printer('Restarting instance %s now.' % instance_id)\n        except:\n            raise AWSConnectionError\n\n        return image_id", "response": "a method to create an image on AWS EC2"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_image(self, image_id):\n\n        '''\n            method for removing an image from AWS EC2\n\n        :param image_id: string with AWS id of instance\n        :return: string with AWS response from snapshot delete\n        '''\n\n        title = '%s.delete_image' % self.__class__.__name__\n\n    # validate inputs\n        input_fields = {\n            'image_id': image_id\n        }\n        for key, value in input_fields.items():\n            object_title = '%s(%s=%s)' % (title, key, str(value))\n            self.fields.validate(value, '.%s' % key, object_title)\n\n    # report query\n        self.iam.printer('Removing image %s from AWS region %s.' % (image_id, self.iam.region_name))\n\n    # retrieve state\n        old_state = self.check_image_state(image_id)\n\n    # discover snapshot id and tags associated with instance id\n        image_details = self.read_image(image_id)\n        tag_list = image_details['tags']\n        snapshot_id = image_details['snapshot_id']\n\n    # remove tags from instance\n        try:\n            delete_kwargs = {\n                'Resources': [ image_id ],\n                'Tags': self.iam.prepare(tag_list)\n            }\n            self.connection.delete_tags(**delete_kwargs)\n            self.iam.printer('Tags have been deleted from %s.' % image_id)\n        except:\n            raise AWSConnectionError(title)\n\n    # deregister image\n        try:\n            self.connection.deregister_image(\n                ImageId=image_id\n            )\n        except:\n            raise AWSConnectionError(title)\n        self.iam.printer('Image %s has been deregistered.' % image_id)\n\n    # delete snapshot\n        try:\n            response = self.connection.delete_snapshot(\n                SnapshotId=snapshot_id\n            )\n        except:\n            raise AWSConnectionError(title)\n        self.iam.printer('Snapshot %s associated with image %s has been deleted.' % (snapshot_id, image_id))\n\n        return response", "response": "a method to remove an image from AWS EC2"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef export_image(self, image_id, region_name):\n\n        '''\n            a method to add a copy of an image to another AWS region\n\n            https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/CopyingAMIs.html\n\n            REQUIRED: iam credentials must have valid access to both regions\n\n        :param image_id: string of AWS id of image to be copied\n        :param region_name: string of AWS region to copy image to\n        :return: string with AWS id of new image\n        '''\n\n        title = '%s.export_image' % self.__class__.__name__\n\n    # validate inputs\n        input_fields = {\n            'image_id': image_id\n        }\n        for key, value in input_fields.items():\n            object_title = '%s(%s=%s)' % (title, key, str(value))\n            self.fields.validate(value, '.%s' % key, object_title)\n        input_fields = {\n            'region_name': region_name\n        }\n        for key, value in input_fields.items():\n            object_title = '%s(%s=%s)' % (title, key, str(value))\n            self.iam.fields.validate(value, '.%s' % key, object_title)\n        if region_name == self.iam.region_name:\n            raise ValueError('%s cannot export an image to the same region.' % title)\n        \n    # construct ec2 client connection for source region\n        client_kwargs = {\n            'service_name': 'ec2',\n            'region_name': region_name,\n            'aws_access_key_id': self.iam.access_id,\n            'aws_secret_access_key': self.iam.secret_key\n        }\n        destination_connection = boto3.client(**client_kwargs)\n\n    # check state of image to be copied\n        self.check_image_state(image_id)\n\n    # discover tags and name associated with image to be copied\n        image_details = self.read_image(image_id)\n        tag_list = image_details['tags']\n        image_name = image_details['name']\n\n    # copy image over to current region\n        self.iam.printer('Copying image %s to region %s.' % (image_id, region_name))\n        try:\n            response = destination_connection.copy_image(\n                SourceRegion=self.iam.region_name,\n                SourceImageId=image_id,\n                Name=image_name\n            )\n        except:\n            raise AWSConnectionError(title)\n        new_id = response['ImageId']\n\n    # check into state of new image\n        try:\n            response = destination_connection.describe_images(\n                ImageIds=[ new_id ]\n            )\n        except:\n            raise AWSConnectionError(title)\n        if not 'State' in response['Images'][0].keys():\n            from time import sleep\n            from timeit import default_timer as timer\n            self.iam.printer('Checking into the status of image %s in AWS region %s' % (new_id, region_name), flush=True)\n            state_timeout = 0\n            while not 'State' in response['Images'][0].keys():\n                self.iam.printer('.', flush=True)\n                sleep(3)\n                state_timeout += 1\n                try:\n                    response = destination_connection.describe_images(\n                        ImageIds=[ new_id ]\n                    )\n                except:\n                    raise AWSConnectionError(title)\n                if state_timeout > 3:\n                    raise Exception('Failure to determine status of image %s in AWS region %s.' % (new_id, region_name))\n            self.iam.printer(' done.')\n        image_state = response['Images'][0]['State']\n\n    # wait while image is pending\n        if image_state == 'pending':\n            from time import sleep\n            from timeit import default_timer as timer\n            self.iam.printer('Image %s in AWS region %s is %s' % (new_id, region_name, image_state), flush=True)\n            delay = 3\n            state_timeout = 0\n            while image_state != 'available':\n                self.iam.printer('.', flush=True)\n                sleep(delay)\n                t3 = timer()\n                try:\n                    response = destination_connection.describe_images(\n                        ImageIds=[ new_id ]\n                    )\n                except:\n                    raise AWSConnectionError(title)\n                t4 = timer()\n                state_timeout += 1\n                response_time = t4 - t3\n                if 3 - response_time > 0:\n                    delay = 3 - response_time\n                else:\n                    delay = 0\n                if state_timeout > 300:\n                    raise Exception('Timeout. Failure initializing image %s in region %s in less than 15min' % (new_id, region_name))\n                image_state = response['Images'][0]['State']\n            self.iam.printer(' done.')\n\n    # add tags from image to image copy\n        try:\n            destination_connection.create_tags(\n                Resources=[ new_id ],\n                Tags=tag_list\n            )\n        except:\n            raise AWSConnectionError(title)\n        self.iam.printer('Tags from image %s have been added to image %s.' % (image_id, new_id))\n\n        return new_id", "response": "a method to add a copy of an image to another AWS region"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_subnets(self, tag_values=None):\n\n        '''\n            a method to discover the list of subnets on AWS EC2\n\n        :param tag_values: [optional] list of tag values\n        :return: list of strings with subnet ids\n        '''\n\n        title = '%s.list_subnets' % self.__class__.__name__\n\n    # validate inputs\n        input_fields = {\n            'tag_values': tag_values\n        }\n        for key, value in input_fields.items():\n            if value:\n                object_title = '%s(%s=%s)' % (title, key, str(value))\n                self.fields.validate(value, '.%s' % key, object_title)\n            \n    # add tags to method arguments\n        kw_args = {}\n        tag_text = ''\n        if tag_values:\n            kw_args = {\n                'Filters': [ { 'Name': 'tag-value', 'Values': tag_values } ]\n            }\n            from labpack.parsing.grammar import join_words\n            plural_value = ''\n            if len(tag_values) > 1:\n                plural_value = 's'\n            tag_text = ' with tag value%s %s' % (plural_value, join_words(tag_values))\n            \n    # request instance details from AWS\n        self.iam.printer('Querying AWS region %s for subnets%s.' % (self.iam.region_name, tag_text))\n        subnet_list = []\n        try:\n            if kw_args:\n                response = self.connection.describe_subnets(**kw_args)\n            else:\n                response = self.connection.describe_subnets()\n        except:\n            raise AWSConnectionError(title)\n        response_list = []\n        if 'Subnets' in response:\n            response_list = response['Subnets']\n\n    # construct list of subnets from response\n        for sub_dict in response_list:\n            subnet_list.append(sub_dict['SubnetId'])\n\n    # report results and return list\n        if subnet_list:\n            print_out = 'Found subnet'\n            if len(subnet_list) > 1:\n                print_out += 's'\n            from labpack.parsing.grammar import join_words\n            print_out += ' %s.' % join_words(subnet_list)\n            self.iam.printer(print_out)\n        else:\n            self.iam.printer('No subnets found.')\n\n        return subnet_list", "response": "a method to discover the list of subnets on AWS EC2"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the set of associated TenantGroups for the given user.", "response": "def get_user_groups(user):\n    \"\"\"Return the set of associated TenantGroups for the given user.\"\"\"\n    if user.is_active and user.is_authenticated():\n        if user.is_superuser:\n            return TenantGroup.objects.all()\n        else:\n            return TenantGroup.objects.filter(tenantrole__user=user).distinct()\n    else:\n        return TenantGroup.objects.none()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the set of associated Tenants for the given user and group.", "response": "def get_user_tenants(user, group):\n    \"\"\"Return the set of associated Tenants for the given user and group.\"\"\"\n    if user.is_active and user.is_authenticated():\n        if user.is_superuser or is_group_manager(user, group.pk):\n            return Tenant.objects.filter(group=group)\n        else:\n            return Tenant.objects.filter(group=group, tenantrole__user=user).distinct()\n    else:\n        return Tenant.objects.none()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of all of the user s roles.", "response": "def get_user_roles(user):\n    \"\"\"Return a list of all of the user's roles.\"\"\"\n    if not hasattr(user, '_role_cache'):\n        user._role_cache = list(TenantRole.objects.filter(user=user).values_list(\n            'group', 'role', 'tenant'))\n    return user._role_cache"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_group_manager(user, group=None):\n    roles = get_user_roles(user)\n    return any(x[1] == TenantRole.ROLE_GROUP_MANAGER and (not group or x[0] == group) for x in roles)", "response": "Returns True if the user is a group manager either for the group or any group."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_tenant_manager(user, group=None, tenant=None):\n    roles = get_user_roles(user)\n    return any(\n        x[1] == TenantRole.ROLE_TENANT_MANAGER and\n        (not group or x[0] == group) and\n        (not tenant or x[2] == tenant)\n        for x in roles\n    )", "response": "Returns True if the user is a tenant manager either for the group or any group or any tenant."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_instance(page_to_consume):\n    global _instances\n    if isinstance(page_to_consume, basestring):\n        uri = page_to_consume\n        page_to_consume = page.get_instance(uri)\n    elif isinstance(page_to_consume, page.Page):\n        uri = page_to_consume.uri\n    else:\n        raise TypeError(\n            \"get_instance() expects a parker.Page or basestring derivative.\"\n        )\n\n    page_to_consume.fetch()\n    parsed_page = parser.parse(page_to_consume)\n\n    try:\n        instance = _instances[uri]\n    except KeyError:\n        instance = ConsumePage(\n            parsed_page\n        )\n        _instances[uri] = instance\n\n    return instance", "response": "Return an instance of ConsumePage."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_key_value_dict_by_selectors(\n        self, key_selector, value_selector, value_sub_selector=None\n    ):\n        \"\"\"Return a dictionary of key value data.\"\"\"\n        key_nodes = self.parsedpage.get_nodes_by_selector(key_selector)\n        keys = [\n            self.parsedpage.get_text_from_node(node)\n            for node in key_nodes\n        ]\n\n        value_nodes = self.parsedpage.get_nodes_by_selector(value_selector)\n        if value_sub_selector is not None:\n            vals = [\n                [\n                    self.parsedpage.get_text_from_node(subnode)\n                    for subnode in node.find(value_sub_selector)\n                ]\n                for node in value_nodes.items()\n            ]\n        else:\n            vals = [\n                self.parsedpage.get_text_from_node(node)\n                for node in value_nodes\n            ]\n\n        return dict(zip(keys, vals))", "response": "Return a dictionary of key value data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of crumbs.", "response": "def get_crumb_list_by_selector(self, crumb_selector):\n        \"\"\"Return a list of crumbs.\"\"\"\n        return [\n            self.parsedpage.get_text_from_node(crumb)\n            for crumb in self.parsedpage.get_nodes_by_selector(crumb_selector)\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_media_list_by_selector(\n        self, media_selector, media_attribute=\"src\"\n    ):\n        \"\"\"Return a list of media.\"\"\"\n        page_url = urlparse.urlparse(self.uri)\n        return [\n            mediafile.get_instance(\n                urlparse.urljoin(\n                    \"%s://%s\" % (\n                        page_url.scheme,\n                        page_url.netloc\n                    ),\n                    urlparse.urlparse(\n                        media.attrib[media_attribute],\n                        scheme=\"http\"\n                    ).geturl()\n                )\n            )\n            for media in self.parsedpage.get_nodes_by_selector(media_selector)\n        ]", "response": "Return a list of media objects that match the given selector."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_data_dict_from_config(self, config_dict):\n        return {\n            key: self.parsedpage.get_filtered_values_by_selector(\n                item_dict['selector'],\n                item_dict.get('regex_filter', None),\n                item_dict.get('regex_group', 1)\n            )\n            for key, item_dict in config_dict.iteritems()\n            if item_dict.get('selector', None) is not None\n        }", "response": "Return a dictionary of data inferred from config_dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_config(self, cls, name):\n        self._configs.add(cls)\n        self._config_names.add(name)", "response": "register a configuration class"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing the args and fill the global data structures.", "response": "def parse_args(self, command_selected, flags, _free_args):\n        # type: (str, Dict[str, str], List[str]) -> bool\n        \"\"\"\n        Parse the args and fill the global data\n        Currently we disregard the free parameters\n        :param command_selected:\n        :param flags:\n        :param _free_args:\n        :return:\n        \"\"\"\n        configs = self.function_name_to_configs[command_selected]\n        suggested_configs = self.function_name_to_suggest_configs[command_selected]\n\n        # create the attribute_to_config map\n        attribute_to_config = dict()  # type: Dict[str, Config]\n        for config in itertools.chain(configs, suggested_configs):\n            for attribute in config.get_attributes():\n                if attribute in attribute_to_config:\n                    raise ValueError(\"attribute [{}] double\".format(attribute))\n                attribute_to_config[attribute] = config\n\n        # set the flags into the \"default\" field\n        unknown_flags = []\n        for flag_raw, value in flags.items():\n            edit = value.startswith('=')\n            if flag_raw not in attribute_to_config:\n                unknown_flags.append(flag_raw)\n            config = attribute_to_config[flag_raw]\n            param = config.get_param_by_name(flag_raw)\n            if edit:\n                v = param.s2t_generate_from_default(value[1:])\n            else:\n                v = param.s2t(value)\n            setattr(config, flag_raw, v)\n\n        # check for missing parameters and show help if there are any missing\n        missing_parameters = []\n        for config in configs:\n            for attribute in config.get_attributes():\n                value = getattr(config, attribute)\n                if value is NO_DEFAULT:\n                    missing_parameters.append(attribute)\n        if unknown_flags or missing_parameters:\n            if missing_parameters:\n                print()\n                print_warn(\"missing parameters [{}]\".format(\",\".join(missing_parameters)))\n            if unknown_flags:\n                print()\n                print_warn(\"unknown flags [{}]\".format(\",\".join(unknown_flags)))\n            print(\"problems found, not running\")\n            print()\n            self.show_help_for_function(command_selected, show_help_full=False, show_help_suggest=False)\n            return False\n\n        # move all default values to place\n        for config in itertools.chain(configs, self._configs):\n            for attribute in config.get_attributes():\n                param = getattr(config, attribute)  # type: Param\n                if isinstance(param, Param):\n                    if param.default is not NO_DEFAULT:\n                        setattr(config, attribute, param.default)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_int(help_string=NO_HELP, default=NO_DEFAULT):\n        # type: (str, Union[int, NO_DEFAULT_TYPE]) -> int\n        \"\"\"\n        Create an int parameter\n        :param help_string:\n        :param default:\n        :return:\n        \"\"\"\n        # noinspection PyTypeChecker\n        return ParamFunctions(\n            help_string=help_string,\n            default=default,\n            type_name=\"int\",\n            function_s2t=convert_string_to_int,\n            function_t2s=convert_int_to_string,\n            function_s2t_generate_from_default=convert_string_to_int_default,\n        )", "response": "Create an int parameter"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_list_int(help_string=NO_HELP, default=NO_DEFAULT):\n        # type: (str, Union[List[int], NO_DEFAULT_TYPE]) -> List[int]\n        \"\"\"\n        Create a List[int] parameter\n        :param help_string:\n        :param default:\n        :return:\n        \"\"\"\n        # noinspection PyTypeChecker\n        return ParamFunctions(\n            help_string=help_string,\n            default=default,\n            type_name=\"List[int]\",\n            function_s2t=convert_string_to_list_int,\n            function_t2s=convert_list_int_to_string,\n        )", "response": "Create a List[int ] parameter"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a List[str] parameter for the nova log entry.", "response": "def create_list_str(help_string=NO_HELP, default=NO_DEFAULT):\n        # type: (str, Union[List[str], NO_DEFAULT_TYPE]) -> List[str]\n        \"\"\"\n        Create a List[str] parameter\n        :param help_string:\n        :param default:\n        :return:\n        \"\"\"\n        # noinspection PyTypeChecker\n        return ParamFunctions(\n            help_string=help_string,\n            default=default,\n            type_name=\"List[str]\",\n            function_s2t=convert_string_to_list_str,\n            function_t2s=convert_list_str_to_string,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate an int parameter", "response": "def create_int_or_none(help_string=NO_HELP, default=NO_DEFAULT):\n        # type: (str, Union[int, None, NO_DEFAULT_TYPE]) -> Union[int, None]\n        \"\"\"\n        Create an int parameter\n        :param help_string:\n        :param default:\n        :return:\n        \"\"\"\n        # noinspection PyTypeChecker\n        return ParamFunctions(\n            help_string=help_string,\n            default=default,\n            type_name=\"Union[int, None]\",\n            function_s2t=convert_string_to_int_or_none,\n            function_t2s=convert_int_or_none_to_string,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_str(help_string=NO_HELP, default=NO_DEFAULT):\n        # type: (str, Union[str, NO_DEFAULT_TYPE]) -> str\n        \"\"\"\n        Create a string parameter\n        :param help_string:\n        :param default:\n        :return:\n        \"\"\"\n        # noinspection PyTypeChecker\n        return ParamFunctions(\n            help_string=help_string,\n            default=default,\n            type_name=\"str\",\n            function_s2t=convert_string_to_string,\n            function_t2s=convert_string_to_string,\n        )", "response": "Create a string parameter."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a bool parameter", "response": "def create_bool(help_string=NO_HELP, default=NO_DEFAULT):\n        # type: (str, Union[bool, NO_DEFAULT_TYPE]) -> bool\n        \"\"\"\n        Create a bool parameter\n        :param help_string:\n        :param default:\n        :return:\n        \"\"\"\n        # noinspection PyTypeChecker\n        return ParamFunctions(\n            help_string=help_string,\n            default=default,\n            type_name=\"bool\",\n            function_s2t=convert_string_to_bool,\n            function_t2s=convert_bool_to_string,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new file parameter.", "response": "def create_new_file(help_string=NO_HELP, default=NO_DEFAULT, suffixes=None):\n        # type: (str, Union[str, NO_DEFAULT_TYPE], Union[List[str], None]) -> str\n        \"\"\"\n        Create a new file parameter\n        :param help_string:\n        :param default:\n        :param suffixes:\n        :return:\n        \"\"\"\n        # noinspection PyTypeChecker\n        return ParamFilename(\n            help_string=help_string,\n            default=default,\n            type_name=\"new_file\",\n            suffixes=suffixes,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_existing_file(help_string=NO_HELP, default=NO_DEFAULT, suffixes=None):\n        # type: (str, Union[str, NO_DEFAULT_TYPE], Union[List[str], None]) -> str\n        \"\"\"\n        Create a new file parameter\n        :param help_string:\n        :param default:\n        :param suffixes:\n        :return:\n        \"\"\"\n        # noinspection PyTypeChecker\n        return ParamFilename(\n            help_string=help_string,\n            default=default,\n            type_name=\"existing_file\",\n            suffixes=suffixes,\n        )", "response": "Create a new file parameter that is not already present in the database."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new folder in the current directory.", "response": "def create_existing_folder(help_string=NO_HELP, default=NO_DEFAULT, suffixes=None):\n        # type: (str, Union[str, NO_DEFAULT_TYPE], Union[List[str], None]) -> str\n        \"\"\"\n        Create a new folder parameter\n        :param help_string:\n        :param default:\n        :param suffixes:\n        :return:\n        \"\"\"\n        # noinspection PyTypeChecker\n        return ParamFilename(\n            help_string=help_string,\n            default=default,\n            type_name=\"existing_folder\",\n            suffixes=suffixes,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a choice config object from a list of choice strings.", "response": "def create_choice(choice_list, help_string=NO_HELP, default=NO_DEFAULT):\n        # type: (List[str], str, Union[Any, NO_DEFAULT_TYPE]) -> str\n        \"\"\"\n        Create a choice config\n        :param choice_list:\n        :param help_string:\n        :param default:\n        :return:\n        \"\"\"\n        # noinspection PyTypeChecker\n        return ParamChoice(\n            help_string=help_string,\n            default=default,\n            choice_list=choice_list,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate an enum config object.", "response": "def create_enum(enum_type, help_string=NO_HELP, default=NO_DEFAULT):\n        # type: (Type[Enum], str, Union[Any, NO_DEFAULT_TYPE]) -> Type[Enum]\n        \"\"\"\n        Create an enum config\n        :param enum_type:\n        :param help_string:\n        :param default:\n        :return:\n        \"\"\"\n        # noinspection PyTypeChecker\n        return ParamEnum(\n            help_string=help_string,\n            default=default,\n            enum_type=enum_type,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating an enum subset", "response": "def create_enum_subset(enum_type, help_string=NO_HELP, default=NO_DEFAULT):\n        # type: (Type[Enum], str, EnumSubset) -> EnumSubset\n        \"\"\"\n        Create an enum config\n        :param enum_type:\n        :param help_string:\n        :param default:\n        :return:\n        \"\"\"\n        # noinspection PyTypeChecker\n        return ParamEnumSubset(\n            help_string=help_string,\n            default=default,\n            enum_type=enum_type,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_and_append(args, flag, new_args):\n    try:\n        v = eval(\"args.%s\" % (flag.replace(\"-\", \"_\")))\n        if v is not None:\n            if v == True:\n                new_args.append(\"--%s\" % (flag))\n            elif v != False:\n                new_args.append(\"--%s %s\" % (flag, str(v)))\n    except:\n        pass", "response": "Checks if a flag is present in args and appends it to new_args"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating actual scripts to be submitted to the cluster", "response": "def generate_jobs(args, job_list, argument_string):\n    \"\"\"Generate actual scripts to be submitted to the cluster\n\n    :param args: argparse argument collection\n    :param job_list: dictionary containing each each job to be submitted\n    :param argument_string: string containing general arguments to be used by mvtest.py during execution\n    :return: None\n    \"\"\"\n    mvtest_path = args.mvpath\n    template = \"\".join(args.template.readlines())\n    logpath = os.path.abspath(args.logpath)\n    respath = os.path.abspath(args.res_path)\n    scriptpath = os.path.abspath(args.script_path)\n    pwd = os.path.abspath(os.getcwd())\n\n    for jobname in job_list.keys():\n        filename = \"%s/%s.sh\" % (scriptpath, jobname)\n        job_body = mvtest_path + \" \" + argument_string + \" \" + job_list[jobname]\n        contents = Template(template).safe_substitute(\n                    logpath=logpath,\n                    respath=respath,\n                    body=job_body,\n                    jobname=jobname,\n                    memory=args.mem,\n                    walltime=args.walltime,\n                    pwd=pwd)\n\n        file = open(filename, \"w\")\n        print >> file,contents"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns valid template file generating the default template file if it doesn t exist.", "response": "def get_template_file(args):\n    \"\"\"Returns valid template file, generating the default template file if it doesn't exist and one wasn't\n     specified on command line.\n\n    :param args: Argument collection as generated by parseargs\n    :return file\"\"\"\n    if args.template is None:\n        template_filename  = os.getenv(\"HOME\") + \"/.mvmany.template\"\n        try:\n            template_filename = open(template_filename, \"r\")\n        except:\n            with open(template_filename, \"w\") as file:\n                print >> file, \"\"\"#SBATCH --job-name=$jobname\n#SBATCH --nodes=1\n#SBATCH --tasks-per-node=1\n#SBATCH --cpus-per-task=1\n#SBATCH --mem=$memory\n#SBATCH --time=$walltime\n#SBATCH --error $logpath/$jobname.e\n#SBATCH --output $respath/$jobname.txt\n\ncd $pwd\n\n$body\n    \"\"\"\n            print >> sys.stderr, \"\"\"PLEASE NOTE: \\n\nA default template file, %s, has been created. You are encouraged to configure it according to work with your cluster\nmanagement software or personalize it with email notifications, etc.\\n\"\"\"\n            template_filename = open(template_filename, \"r\")\n\n    return template_filename"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the MACH file and generate the list of jobs.", "response": "def split_mach_jobs(args, filename):\n    \"\"\"Parse the MACH file and generate the list of jobs.\n\n    :param args: Arguments from parseargs\n    :param filename: name of file containing list of mach dosage files\n    :return jobs to be run\n    \"\"\"\n    max_snp_count = args.snps_per_job\n\n    job_list = {}\n    cur = None\n    last_pos = None\n    job_string = \"\"\n    job_name = \"\"\n\n    mach_count = 1\n    if args.mach_count:\n        mach_count = args.mach_count\n\n    ExitIf(\"mvmany doesn't support splitting mach jobs into pieces at this time\", max_snp_count > 1)\n\n    dosage_files = []\n    for line in open(filename):\n        dosage_files.append(line.strip().split(\"/\")[-1].split(\".\")[0])\n        dosage_files.append(\".\".join(line.strip().split()[-1].split(\"/\")[-1].split(\".\")[0:-1]))\n\n    file_count = len(dosage_files)\n    job_count = int(math.ceil(float(file_count) / mach_count))\n\n    for job_num in range(job_count):\n        job_idx = job_num * mach_count + 1\n        job_string = \"--mach-count %d --mach-offset %d\" % (mach_count, job_idx)\n        job_name = \"job%04d-%s\" % (job_num+1, dosage_files[job_idx - 1])\n        job_list[job_name] = job_string\n\n    return job_list"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the IMPUTE file and generate the list of jobs.", "response": "def split_impute_jobs(args, filename):\n    \"\"\"Parse the IMPUTE file and generate the list of jobs.\n\n     :param args: parsearg object containing command line arguments\n     :filename args: file containing the IMPUTE gen files and chromosome numbers\n     \"\"\"\n    max_snp_count = args.snps_per_job\n\n    if args.impute_count:\n        impute_count = args.impute_count\n    else:\n        impute_count = 1\n\n    ExitIf(\"mvmany doesn't support splitting IMPUTE jobs into pieces at this time\", max_snp_count > 1)\n\n    job_list = {}\n    gen_files = []\n    for line in open(filename):\n        gen_files.append(\".\".join(line.strip().split()[-1].split(\"/\")[-1].split(\".\")[0:-1]))\n\n\n    file_count = len(gen_files)\n    job_count = int(math.ceil(float(file_count) / impute_count))\n\n    for job_num in range(job_count):\n        job_idx = job_num * impute_count + 1\n        job_string = \"--impute-offset %d --impute-count %d\" % (job_idx, impute_count)\n        job_name = \"job%04d-%s\" % (job_num+1, gen_files[job_idx -1])\n        job_list[job_name] = job_string\n        print job_string\n\n    return job_list\n\n    # For now, let's not deal with the complexity of splitting chromosomes in IMPUTE\n    poscol = 2\n    cur = None\n    last_pos = None\n    job_string = \"\"\n    job_name = \"\"\n\n    file_index = 0\n    for line in open(filename):\n        chr, genfile = line.strip().split()\n\n        if max_snp_count > 0:\n            locus_index = 0\n            last_pos = 1\n            for locus in open(genfile):\n                if locus_index >= max_snp_count - 1:\n                    rsid, pos = locus.split()[1:2]\n                    job_name = \"chr%d_%d\" % (chr, last_pos)\n                    job_string = \"--chr %s --from-bp %d --to-bp %d\" % (chr, last_pos, pos)\n                    last_pos = pos + 1\n                    job_list[job_name] = job_string\n                    locus_index = 0\n\n                if cur is None:\n                    cur = pos\n\n    for line in sys_call(\"cut -f 1,%d %s\" % (poscol, chrom_file)):\n        chrom, pos = [int(x) for x in line.split()]\n        if cur is None:     # First line observed\n            cur = chrom\n            job_string = \"--chr %d --from-bp %d\" % (chrom, pos)\n            job_name = \"Chr%d_%d-\" % (chrom, pos)\n            snp_count = 0\n        elif cur != cur:    # Changed chromosome\n            job_string += \" --to-bp %d\" % (last_pos)\n            job_name += str(last_pos)\n            job_list[job_name] = job_string\n            cur = chrom\n            job_string = \"--chr %d --from-bp %d\" % (chrom, pos)\n            job_name = \"Chr%d_%d-\" % (chrom, pos)\n            snp_count = 0\n                            # create new job based on snp count\n        elif snp_count < max_snp_count:\n            snp_count += 1\n        else:\n            job_string += \" --to-bp %d\" % (last_pos)\n            job_name += str(last_pos)\n            job_list[job_name] = job_string\n            job_string = \"--chr %d --from-bp\" % (chrom, pos)\n            job_name = \"Chr%d_%d-\" % (chrom, pos)\n            snp_count = 0\n\n        last_pos = pos\n    if job_string != \"\":\n        job_string += \" --to-bp %d\" % (last_pos)\n        job_name += str(last_pos)\n        job_list[job_name] = job_string\n\n    return job_list"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef split_chrom_jobs(args, chrom_file):\n    max_snp_count = args.snps_per_job\n\n    poscol = 3\n    if args.map3:\n        poscol = 2\n\n    job_list = {}\n    cur = None\n    last_pos = None\n    job_string = \"\"\n    job_name = \"\"\n\n    for line in sys_call(\"cut -f 1,%d %s\" % (poscol, chrom_file)):\n        pos = -1\n\n        values = line.split()\n        if len(values) > 0:\n            chrom, pos = [int(x) for x in values]\n\n        if cur is None:     # First line observed\n            cur = chrom\n            job_string = \"--chr %d --from-bp %d\" % (chrom, pos)\n            job_name = \"Chr%d_%d-\" % (chrom, pos)\n            snp_count = 0\n        elif cur != cur:    # Changed chromosome\n            job_string += \" --to-bp %d\" % (last_pos)\n            job_name += str(last_pos)\n            job_list[job_name] = job_string\n            cur = chrom\n            job_string = \"--chr %d --from-bp %d\" % (chrom, pos)\n            job_name = \"Chr%d_%d-\" % (chrom, pos)\n            snp_count = 0\n                            # create new job based on snp count\n        elif snp_count < max_snp_count:\n            snp_count += 1\n        else:\n            job_string += \" --to-bp %d\" % (last_pos)\n            job_name += str(last_pos)\n            job_list[job_name] = job_string\n            job_string = \"--chr %d --from-bp\" % (chrom, pos)\n            job_name = \"Chr%d_%d-\" % (chrom, pos)\n            snp_count = 0\n\n        last_pos = pos\n    if job_string != \"\":\n        job_string += \" --to-bp %d\" % (last_pos)\n        job_name += str(last_pos)\n        job_list[job_name] = job_string\n\n    return job_list", "response": "Split up GWAS jobs based on portions of a chromosome."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling forward_mode ; discard value only keep the derivative.", "response": "def diff(self, *args):\n        \"\"\"Call forward_mode; discard value, only keep the derivative.\"\"\"\n        arg_dicts = self._parse_args_forward_mode(*args)\n        val, diff = self._forward_mode(*arg_dicts)\n        return diff"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_args_forward_mode(self, *args) -> Tuple[dict, dict]:\n        # Types for arg_vars and arg_seed\n        arg_vars: np.ndarray = {}\n        arg_seed: np.ndarray = {}\n        # Get the number of arguments and inputs\n        argc: int = len(args)\n        m: int = self.m\n        # Check each type in turn\n        # The most common case is two arguments were passed for the vars and seeds\n        # They can both be numpy arrays or dicts\n        if argc == 0:\n            return (None, None)\n        if argc == 1:\n            # The lone argument\n            arg = args[0]\n            # Case zero: None\n            if arg is None:\n                return (None, None)\n            # Case one: a dict\n            elif isinstance(arg, dict):\n                arg_vars = self._parse_var_dict(arg)\n            # Case two: a scalar\n            elif isinstance(arg, scalar_instance_types):\n                arg_vars = self._parse_var_scalar(arg)\n            # Case three: a numpy array\n            elif isinstance(arg, np.ndarray):\n                arg_vars = self._parse_var_array(arg)\n            T_vars = self._check_forward_mode_input_dict(arg_vars)\n            self.T = T_vars\n            return (arg_vars, self._default_seed(arg_vars))\n        if argc == 2:\n            # Case one: a pair of dicts\n            if isinstance(args[0], dict) and isinstance(args[1], dict):\n                arg_vars = self._parse_var_dict(args[0])\n                arg_seed = self._parse_seed_dict(args[1])\n            # Case two: two scalars\n            elif isinstance(args[0], scalar_instance_types) and isinstance(args[1], scalar_instance_types):\n                arg_vars = self._parse_var_scalar(args[0])\n                arg_seed = self._parse_var_scalar(args[1])\n            # Case three: two numpy arrays\n            elif isinstance(args[0], np.ndarray) and isinstance(args[1], np.ndarray):\n                arg_vars = self._parse_var_array(args[0])\n                arg_seed = self._parse_var_array(args[1])\n            else:\n                raise ValueError(f'Input types must either be dict, scalar, or np.ndarray for Fluxion.parse_args.')\n            T_vars = self._check_forward_mode_input_dict(arg_vars)\n            T_seed = self._check_forward_mode_input_dict(arg_seed)\n            self.T = T_vars\n            if T_seed in (1,T_vars):\n                return (arg_vars, arg_seed)\n            else:\n                raise ValueError(f'Bound variables in {args[0]} inconsistent with bound variables in {args[1]}')\n\n        # If we reach here, we either got ARGS or KWARGS\n        if argc == 2 * m:\n            # Initialize X and dX in the correct shape\n            X = np.array(args[0:m],dtype=np.float64)\n            dX = np.array(args[m:2*m],dtype=np.float64)\n            # Reevaluate the two arrays\n            return self._parse_args_forward_mode(X, dX)\n        # KWARGS not yet supported\n        msg = f'argc={argc}'\n        for arg in args:\n            msg += f'{arg}'\n        raise ValueError(f'Unrecognized input type for Fluxion.parse_args.  Details:\\n{msg}')", "response": "Parse the arguments used in forward mode differentiation."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _default_seed(self, var_tbl: dict) -> dict:\n        var_names = {}\n        #for v in self.var_names:\n        #    var_names[v]=1\n        for v in var_tbl:\n            var_names[v]=1\n        return var_names", "response": "Default seed for the variable names."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_var_dict(self, var_tbl: dict) -> dict:\n        var_names = var_tbl.copy()\n        # check that all of the variables are bound\n        for v in self.var_names:\n            if v not in var_tbl:\n                if self.var_names[v] is None:\n                    raise(KeyError(\"variable \" + v + \" is unbound\"))\n                else:\n                    var_names[v] = self.var_names[v]\n        # squeeze the variables\n        return self._squeeze(var_names)", "response": "Parse a dictionary of variable names including any pre - bound ones"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the seed dictionary.", "response": "def _parse_seed_dict(self, var_tbl: dict) -> dict:\n        \"\"\"\n        Create an extended list of variable names including any pre-bound ones\n        Throws an error if a variable is unbound\n        Returns inferred dict of variable: val pairs\n        \"\"\"\n        var_names = var_tbl.copy()\n        # check that all of the variables are bound\n        for v in self.var_names:\n            if v not in var_tbl:\n                raise(KeyError(\"variable \" + v + \" is unbound in seed table\"))\n        # squeeze the variables\n        return self._squeeze(var_names)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _squeeze(self, var_tbl: dict) -> dict:\n        var_names = var_tbl.copy()\n        # squeeze any numpy arrays\n        for v in var_tbl:\n            val = var_tbl[v]\n            if isinstance(val, np.ndarray):\n                var_names[v] = val.squeeze()\n        return var_names", "response": "Squeeze any numpy arrays in the input dict and return the inferred dict of variable names."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_var_scalar(self, X: scalar_type) -> dict:\n        arg_vars = {}\n        #there is only one var name, so this will run once and no sorting is required\n        for var_name in self.var_names:\n            arg_vars[var_name] = X\n        return arg_vars", "response": "Unpack the numpy array and bind each column to one of the variables in self. var_names\n        Returns inferred dict of variable name to val pairs"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_var_array(self, X: np.ndarray) -> dict:\n        arg_vars = {}\n        # Get the shape and tensor rank\n        shape = X.shape\n        tensor_rank = len(shape)\n        T = self._check_forward_mode_input_array(X)\n        if tensor_rank == 0:\n            #there is only 1 var name, so this will only run once\n            for var_name in self.var_names:\n                arg_vars[var_name] = X\n        if tensor_rank == 1 and T == shape[0]:\n            #there is only 1 var name, so this will only run once\n            for var_name in self.var_names:\n                arg_vars[var_name] = X.squeeze()\n        elif tensor_rank == 1:\n            for j, var_name in enumerate(sorted(self.var_names)):\n                arg_vars[var_name] = X[j].squeeze()\n        elif tensor_rank == 2:\n            for j, var_name in enumerate(sorted(self.var_names)):\n                arg_vars[var_name] = X[:,j].squeeze()\n        return arg_vars", "response": "Unpack the numpy array and bind each column to one of the variables in self. var_names\n        Returns inferred dict of variable : val pairs"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _check_forward_mode_input_dict(self, var_tbl: dict) -> int:\n        T: int = 1\n        for var_name in var_tbl:\n            # The bound value to this variable name\n            val = var_tbl[var_name]\n            # case 1: this is a scalar; T=1\n            if isinstance(val, scalar_instance_types):\n                t = 1\n            # case 2: this is an array; calulate T\n            elif isinstance(val, np.ndarray):\n                t = self._calc_T_var(val)\n            #case 3: throw an error\n            else:\n                raise ValueError(f'val={val} in var_tbl; {type(val)} not a recognized value type.')\n            #update T\n            if t > 1 and T == 1:\n                T = t\n            elif t not in (1,T):\n                raise ValueError(f'Bound variable {var_name} has inconsistent shape')\n        return T", "response": "Checks whether one forward mode input dict has elements of valid shape and returns inferred value of T\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck whether one forward mode input array is of valid shape and tensor rank Returns inferred value of T", "response": "def _check_forward_mode_input_array(self, X: np.ndarray) -> int:\n        \"\"\"\n        Check whether one forward mode input array is of valid shape\n        Returns inferred value of T\n        \"\"\"\n        # Find the length of each variable to infer T\n        if not isinstance(X, np.ndarray):\n            raise ValueError('X must be a numpy array, dict, or scalar')\n        # Get the shape and tensor rank\n        shape = X.shape\n        tensor_rank = len(shape)\n        T = 0\n        # Only 1D and 2D arrays are supported\n        if tensor_rank not in (0, 1, 2):\n            raise ValueError(f'Shape of X = {X.shape}. Numpy array must be a 1D vector or 2D matrix')        \n        if tensor_rank == 0:\n            T = 1\n        # If the input was a 1D vector, its length must EITHER (1) be T, or (2) m, with T == 1\n        if tensor_rank == 1 and (shape[0] != self.m) and self.m != 1:\n            raise ValueError(f'Error: X has shape {X.shape}, incompatible with m = {self.m} on fluxion.')\n        # Return the value of T in this situation\n        if tensor_rank == 1 and shape[0] == self.m:\n            T = 1\n        if tensor_rank == 1 and self.m == 1:\n            T = shape[0]\n        # If the input was a 2D vector, it must be of shape Txn\n        if tensor_rank == 2 and (shape[1] != self.m):\n            raise ValueError(f'Error: X has shape {X.shape}, incompatible with m = {self.m} on fluxion.')\n        if tensor_rank == 2:\n            T = shape[0]\n        return T"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _calc_T_var(self,X) -> int:\n        shape = X.shape\n        tensor_rank: int = len(shape)\n        if tensor_rank == 0:\n            return 1\n        if tensor_rank == 1:\n            return shape[0]\n        if tensor_rank == 2:\n            if shape[1] > 1:\n                raise ValueError('Initial value of a variable must have dimension T*1.')\n            return shape[0]", "response": "Calculate the number of samples T from the shape of X."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the bound value and derivative of zero depending on the argumetns passed", "response": "def _forward_mode(self, *args):\n        \"\"\"Forward mode differentiation for a constant\"\"\"\n        # Return the bound value and a derivative of zero regardless of the argumetns passed\n        val: float = self.a\n        diff: float = 0.0\n        return (val, diff)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _forward_mode(self, *args):\n        # Evaluate inner function self.f\n        X: np.ndarray\n        dX: np.ndarray\n        X, dX = self.f._forward_mode(*args)\n        # Alias the power to p for legibility\n        p: float = self.p\n        # The function value\n        val = X ** p\n        # The derivative\n        diff = p * X ** (p-1) * dX\n        return (val, diff)", "response": "Forward mode differentiation for a constant"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nforward mode differentiation for a sum", "response": "def _forward_mode(self, *args):\n        \"\"\"Forward mode differentiation for a sum\"\"\"\n        # (f+g)(x) = f(x) + g(x)\n        f_val, f_diff = self.f._forward_mode(*args)\n        g_val, g_diff = self.g._forward_mode(*args)\n        # The function value and derivative is the sum of f and g\n        val = f_val + g_val\n        diff = f_diff + g_diff\n        return val, diff"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nforward mode differentiation for variables", "response": "def _forward_mode(self, *args):\n        \"\"\"Forward mode differentiation for variables\"\"\"\n        # Parse arguments into two numpy arrays\n        X: np.ndarray\n        dX: np.ndarray\n        X, dX = self._parse_dicts(*args)\n        # The value is X\n        if X is not None:\n            val = X\n        else:\n            val = self.X\n        # The derivative is the seed dX\n        if dX is not None:\n            diff = dX\n        else:\n            diff = np.ones_like(val)\n        # Return both arrays\n        return (val, diff)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_dicts(self, *args) -> Tuple[np.ndarray, np.ndarray]:\n        # initialize the X variable that will be returned\n        X: np.ndarray\n        dX: np.ndarray\n        # get the number of arguments and inputs\n        argc: int = len(args)\n\n        if argc == 2:\n            arg_vars = args[0]\n            arg_seed = args[1]\n            if arg_vars is None:\n                return (None,None)\n            X = self._parse_vars_tbl(arg_vars)\n            dX = self._parse_seed_tbl(arg_seed)\n            # if dX was the default dict, tile dX to match T\n            if X.shape[0] > 1 and dX.shape[0] == 1:\n                dX = np.tile(dX, (X.shape[0], 1))\n            # Return the arrays of argument values\n            return (X,dX)\n        # If we reach here, the contract was broken\n        msg = f'argc={argc}'\n        for arg in args:\n            msg += f'{arg}'\n        raise ValueError(f'Contract broken. Unrecognized input type for Fluxion._parse_dicts.  Details: \\n{msg}')", "response": "Parse input arguments used in function evaluation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_vars_tbl(self, var_tbl):\n\n        # Find the length of each variable to infer T\n        T = self._check_forward_mode_input_dict(var_tbl)\n        # The shape of X based on T and m\n        shape = (T, 1)\n\n        # Initialize X to zeros in the correct shape        \n        X = np.zeros(shape)\n        X[:,0] = var_tbl[self.var_name]\n        return X", "response": "Parse a table of variable bindings"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a table of variable bindings and return a numpy array of the correct shape", "response": "def _parse_seed_tbl(self, var_tbl):\n        \"\"\"Parse a table of variable bindings (dictionary with key = variable name)\"\"\"\n\n        m: int = len(var_tbl)\n        # Find the length of each variable to infer T\n        T = self._check_forward_mode_input_dict(var_tbl)\n\n        # The shape of X based on T and m\n        shape = (T, m)\n\n        # Initialize X to zeros in the correct shape        \n        X = np.zeros(shape)\n        # loop through the bound variables\n        for j, var_name in enumerate(sorted(var_tbl)):\n            if var_name in self.var_names:\n                X[:,j] = var_tbl[var_name]\n        return X"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run():\n    logfilename = os.path.join(current_app.config['CFG_LOGDIR'],\n                               'invenio_upgrader.log')\n    upgrader = InvenioUpgrader()\n    logger = upgrader.get_logger(logfilename=logfilename)\n\n    try:\n        upgrades = upgrader.get_upgrades()\n\n        if not upgrades:\n            logger.info(\"All upgrades have been applied.\")\n            return\n\n        logger.info(\"Following upgrade(s) will be applied:\")\n\n        for u in upgrades:\n            logger.info(\" * %s (%s)\" % (u.name, u.info))\n\n        logger.info(\"Running pre-upgrade checks...\")\n        upgrader.pre_upgrade_checks(upgrades)\n\n        logger.info(\"Calculating estimated upgrade time...\")\n        estimate = upgrader.human_estimate(upgrades)\n\n        click.confirm(\n            \"You are going to upgrade your installation \"\n            \"(estimated time: {0})!\".format(estimate), abort=True)\n\n        for u in upgrades:\n            logger.info(\"Applying %s (%s)\" % (u.name, u.info))\n            upgrader.apply_upgrade(u)\n\n        logger.info(\"Running post-upgrade checks...\")\n        upgrader.post_upgrade_checks(upgrades)\n\n        if upgrader.has_warnings():\n            logger.warning(\"Upgrade completed with %s warnings - please check \"\n                           \"log-file for further information:\\nless %s\"\n                           % (upgrader.get_warnings_count(), logfilename))\n        else:\n            logger.info(\"Upgrade completed successfully.\")\n    except RuntimeError as e:\n        for msg in e.args:\n            logger.error(unicode(msg))\n        logger.info(\"Please check log file for further information:\\n\"\n                    \"less %s\" % logfilename)\n        click.Abort()", "response": "Command for applying upgrades."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncommanding for checking upgrades.", "response": "def check():\n    \"\"\"Command for checking upgrades.\"\"\"\n    upgrader = InvenioUpgrader()\n    logger = upgrader.get_logger()\n\n    try:\n        # Run upgrade pre-checks\n        upgrades = upgrader.get_upgrades()\n\n        # Check if there's anything to upgrade\n        if not upgrades:\n            logger.info(\"All upgrades have been applied.\")\n            return\n\n        logger.info(\"Following upgrade(s) have not been applied yet:\")\n        for u in upgrades:\n            logger.info(\n                \" * {0} {1}\".format(u.name, u.info))\n\n        logger.info(\"Running pre-upgrade checks...\")\n        upgrader.pre_upgrade_checks(upgrades)\n        logger.info(\"Upgrade check successful - estimated time for upgrading\"\n                    \" Invenio is %s...\" % upgrader.human_estimate(upgrades))\n    except RuntimeError as e:\n        for msg in e.args:\n            logger.error(unicode(msg))\n        logger.error(\"Upgrade check failed. Aborting.\")\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pending():\n    upgrader = InvenioUpgrader()\n    logger = upgrader.get_logger()\n\n    try:\n        upgrades = upgrader.get_upgrades()\n\n        if not upgrades:\n            logger.info(\"All upgrades have been applied.\")\n            return\n\n        logger.info(\"Following upgrade(s) are ready to be applied:\")\n\n        for u in upgrades:\n            logger.info(\n                \" * {0} {1}\".format(u.name, u.info))\n    except RuntimeError as e:\n        for msg in e.args:\n            logger.error(unicode(msg))\n        raise", "response": "Command for showing upgrades ready to be applied."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef applied():\n    upgrader = InvenioUpgrader()\n    logger = upgrader.get_logger()\n\n    try:\n        upgrades = upgrader.get_history()\n\n        if not upgrades:\n            logger.info(\"No upgrades have been applied.\")\n            return\n\n        logger.info(\"Following upgrade(s) have been applied:\")\n\n        for u_id, applied in upgrades:\n            logger.info(\" * %s (%s)\" % (u_id, applied))\n    except RuntimeError as e:\n        for msg in e.args:\n            logger.error(unicode(msg))\n        raise", "response": "Command for showing all upgrades already applied."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef release(path, repository):\n    upgrader = InvenioUpgrader()\n    logger = upgrader.get_logger()\n\n    try:\n        endpoints = upgrader.find_endpoints()\n\n        if not endpoints:\n            logger.error(\"No upgrades found.\")\n            click.Abort()\n\n        depends_on = []\n        for repo, upgrades in endpoints.items():\n            depends_on.extend(upgrades)\n\n        return recipe(path,\n                      repository=repository,\n                      depends_on=depends_on,\n                      release=True,\n                      output_path=output_path)\n\n    except RuntimeError as e:\n        for msg in e.args:\n            logger.error(unicode(msg))\n        raise", "response": "Create a new release upgrade recipe for developers."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef recipe(package, repository=None, depends_on=None, release=False,\n           output_path=None, auto=False, overwrite=False, name=None):\n    \"\"\"Create a new upgrade recipe, for developers.\"\"\"\n    upgrader = InvenioUpgrader()\n    logger = upgrader.get_logger()\n\n    try:\n        path, found_repository = _upgrade_recipe_find_path(package)\n\n        if output_path:\n            path = output_path\n\n        if not repository:\n            repository = found_repository\n\n        if not os.path.exists(path):\n            raise RuntimeError(\"Path does not exists: %s\" % path)\n        if not os.path.isdir(path):\n            raise RuntimeError(\"Path is not a directory: %s\" % path)\n\n        # Generate upgrade filename\n        if release:\n            filename = \"%s_release_x_y_z.py\" % repository\n        else:\n            filename = \"%s_%s_%s.py\" % (repository,\n                                        date.today().strftime(\"%Y_%m_%d\"),\n                                        name or 'rename_me')\n\n        # Check if generated repository name can be parsed\n        test_repository = upgrader._parse_plugin_id(filename[:-3])\n        if repository != test_repository:\n            raise RuntimeError(\n                \"Generated repository name cannot be parsed. \"\n                \"Please override it with --repository option.\"\n            )\n\n        upgrade_file = os.path.join(path, filename)\n\n        if os.path.exists(upgrade_file) and not overwrite:\n                raise RuntimeError(\n                    \"Could not generate upgrade - %s already exists.\"\n                    % upgrade_file\n                )\n\n        # Determine latest installed upgrade\n        if depends_on is None:\n            depends_on = [\"CHANGE_ME\"]\n\n            u = upgrader.latest_applied_upgrade(repository=repository)\n            if u:\n                depends_on = [u]\n\n        # Write upgrade template file\n        _write_template(\n            upgrade_file, name or 'rename_me',\n            depends_on, repository, auto=auto)\n\n        logger.info(\"Created new upgrade %s\" % upgrade_file)\n    except RuntimeError as e:\n        for msg in e.args:\n            logger.error(unicode(msg))\n        raise", "response": "Create a new upgrade recipe for developers."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _write_template(upgrade_file, name, depends_on, repository, auto=False):\n    if auto:\n        # Ensure all models are loaded\n        from invenio_db import models\n        list(models)\n        template_args = produce_upgrade_operations()\n        operations_str = template_args['upgrades']\n        import_str = template_args['imports']\n    else:\n        operations_str = \"    pass\"\n        import_str = \"\"\n\n    with open(upgrade_file, 'w') as f:\n        f.write(UPGRADE_TEMPLATE % {\n            'depends_on': depends_on,\n            'repository': repository,\n            'year': date.today().year,\n            'operations': operations_str,\n            'imports': import_str,\n            'cls': ''.join(w.capitalize() or '_' for w in name.split('_'))\n        })", "response": "Write template to upgrade file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _upgrade_recipe_find_path(import_str, create=True):\n    try:\n        # Import package\n        m = import_string(import_str)\n\n        # Check if package or module\n        if m.__package__ is not None and m.__package__ != m.__name__:\n            raise RuntimeError(\n                \"Expected package but found module at '%s'.\" % import_str\n            )\n\n        # Create upgrade directory if it does not exists\n        path = os.path.join(os.path.dirname(m.__file__), \"upgrades\")\n        if not os.path.exists(path) and create:\n            os.makedirs(path)\n\n        # Create init file if it does not exists\n        init = os.path.join(path, \"__init__.py\")\n        if not os.path.exists(init) and create:\n            open(init, 'a').close()\n\n        repository = m.__name__.split(\".\")[-1]\n\n        return (path, repository)\n    except ImportError:\n        raise RuntimeError(\"Could not find module '%s'.\" % import_str)\n    except SyntaxError:\n        raise RuntimeError(\"Module '%s' has syntax errors.\" % import_str)", "response": "Find the path to the upgrade file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns meta information about a video", "response": "def youtube_meta(client, channel, nick, message, match):\n    \"\"\" Return meta information about a video \"\"\"\n    if not API_KEY:\n        return 'You must set YOUTUBE_DATA_API_KEY in settings!'\n    identifier = match[0]\n    params = {\n        'id': identifier,\n        'key': API_KEY,\n        'part': 'snippet,statistics,contentDetails',\n    }\n    response = requests.get(API_ROOT, params=params)\n\n    if response.status_code != 200:\n        return 'Error in response, ' + str(response.status_code) + ' for identifier: ' + identifier\n    try:\n        data = response.json()['items'][0]\n    except:\n        print('Exception requesting info for identifier: ' + identifier)\n        traceback.print_exc()\n\n    response_dict = {\n        'title': data['snippet']['title'],\n        'poster': data['snippet']['channelTitle'],\n        'date': str(parse_date(data['snippet']['publishedAt'])),\n        'views': data['statistics']['viewCount'],\n        'likes': data['statistics']['likeCount'],\n        'dislikes': data['statistics']['dislikeCount'],\n        'duration': parse_duration(data['contentDetails']['duration']),\n    }\n\n    return RESPONSE_TEMPLATE.format(**response_dict).encode('utf-8').strip()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing and prettify duration from youtube duration format", "response": "def parse_duration(duration):\n    \"\"\" Parse and prettify duration from youtube duration format \"\"\"\n    duration_dict = re.search(DURATION_REGEX, duration).groupdict()\n    converted_dict = {}\n    # convert all values to ints, remove nones\n    for a, x in duration_dict.iteritems():\n        if x is not None:\n            converted_dict[a] = int(NON_DECIMAL.sub('', x))\n    return str(timedelta(**converted_dict))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the list name of UW course email list", "response": "def get_course_list_name(curriculum_abbr, course_number, section_id,\n                         quarter, year, joint=False):\n    \"\"\"\n    Return the list address of UW course email list\n    \"\"\"\n    prefix = \"multi_\" if (joint is True) else \"\"\n    return COURSE_LIST_NAME.format(\n        prefix=prefix,\n        curr_abbr=_get_list_name_curr_abbr(curriculum_abbr),\n        course_no=course_number,\n        section_id=section_id.lower(),\n        quarter=quarter.lower()[:2],\n        year=str(year)[-2:]\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if the corresponding mailman list exists for the course", "response": "def exists_course_list(curriculum_abbr, course_number, section_id,\n                       quarter, year, joint=False):\n    \"\"\"\n    Return True if the corresponding mailman list exists for the course\n    \"\"\"\n    return exists(get_course_list_name(curriculum_abbr, course_number,\n                                       section_id, quarter, year, joint))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef web_search(self, query, start=0, limit=100, max_tries=3):\n        '''\n        encapsulates urllib retrieval for fetching JSON results from\n        Google's Custom Search API.  Returns a deserialized result set.\n        '''\n        tries = 0\n        if isinstance(query, unicode):\n            query = query.encode('utf8')\n        url = self.url % dict(key=self.api_key,\n                              query=urllib.quote(query.strip()),\n                              num=min(10, limit - start),\n                              start=start)\n        logger.info(\"fetching: %s\" % url)\n        while 1:\n            try:\n                request = urllib2.Request(url)\n                request.add_header('Accept-encoding', 'gzip')\n                # We do we set this?  Remnant from pre-API version?\n                request.add_header('User-Agent', USER_AGENT)\n                opener = urllib2.build_opener()\n\n                fh = opener.open(request, timeout=60)\n                data = fh.read()\n                if fh.headers.get('Content-Encoding') == 'gzip':\n                    compressedstream = StringIO.StringIO(data)\n                    fh = gzip.GzipFile(fileobj=compressedstream)\n                    data = fh.read()\n                return json.loads(data)\n            except Exception, exc:\n                logger.info(traceback.format_exc(exc))\n                if tries >= max_tries:\n                    sys.exit(\"failed %d times to fetch %s\" % (max_tries, url))\n                else:\n                    logger.info(\"failed to fetch\\n\\t%s\\nwill try \"\n                                \"%d more times\" % (url, max_tries - tries))\n                    tries += 1\n                    time.sleep(2 ** tries)", "response": "This method is used to fetch a list of objects from Google s Custom Search API."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, domain_name, partner_id=None):\n        params = dict(domain_name=domain_name)\n\n        if partner_id: params['partner_id'] = partner_id\n\n        domain = self.wrap(self.resource.create(params))\n\n        self.add(domain)\n        return domain", "response": "Register a domain in netki as a Gem - managed domain."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nregistering a url for a specific domain name", "response": "def create(self, name, domain_name):\n        \"\"\"Register a url (e.g. wallet.gem.co) for\n\n        Args:\n          name (str): human-readable wallet name (e.g. wallet)\n          domain_name (str): the domain name to create subdomain on (e.g. gem.co)\n            this domain must already be registered with Gem\n\n        Returns: The new round.NetkiName\n        \"\"\"\n        name = self.wrap(self.resource.create(dict(name=name,\n                                                   domain_name=domain_name)))\n\n        self.add(name)\n        return name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef can_solve(cls, filter_):\n\n        for solvable_filter in cls.solvable_filters:\n            if isinstance(filter_, solvable_filter):\n                return True\n        return False", "response": "Tells if the current solver class can resolve the given filter."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsolve the given value with the given filter.", "response": "def solve(self, value, filter_):\n        \"\"\"Returns the value of an attribute of the value, or the result of a call to a function.\n\n        Arguments\n        ---------\n        value : ?\n            A value to solve in combination with the given filter.\n        filter_ : dataql.resource.Filter\n            An instance of ``Filter`` to solve with the given value.\n\n        Returns\n        -------\n        Depending on the source, the filter may ask for an attribute of the value, or for the\n        result of a call to a standalone function taking the value as first argument.\n        This method returns this attribute or result.\n\n        Example\n        -------\n\n        >>> from dataql.solvers.registry import Registry\n        >>> registry = Registry()\n        >>> from datetime import date\n        >>> registry.register(date, ['day', 'strftime'])\n        >>> solver = FilterSolver(registry)\n        >>> solver.solve(date(2015, 6, 1), Filter(name='day'))\n        1\n        >>> from dataql.resources import PosArg\n        >>> solver.solve(date(2015, 6, 1), Filter(name='strftime', args=[PosArg('%F')]))\n        '2015-06-01'\n\n        \"\"\"\n\n        args, kwargs = filter_.get_args_and_kwargs()\n        source = self.registry[value]\n        return source.solve(value, filter_.name, args, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef solve(self, value, filter_):\n\n        try:\n            return value[filter_.slice or filter_.index]\n        except IndexError:\n            return None", "response": "Solve the given value for the key - value pair."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting state of instance for cache signature as part of key.", "response": "def get_instance_signature(instance):\n    \"\"\"Get state of instance for cache signature (as part of key).\n\n    Attempts to get state will be done in this order:\n\n    - instance._getsate_bucketcache_()\n    - instance.__getstate__()\n    - instance.__dict__\n    \"\"\"\n    with suppress(AttributeError):\n        return instance._getsate_bucketcache_()\n\n    with suppress(AttributeError):\n        return instance.__getstate__()\n\n    return instance.__dict__"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef normalize_args(f, *args, **kwargs):\n    callargs = inspect.getcallargs(f, *args, **kwargs)\n    original_callargs = callargs.copy()\n    try:\n        argspec = inspect.getargspec(f)\n    except ValueError:\n        argspec = inspect.getfullargspec(f)\n    else:\n        argspec = fullargspec_from_argspec(argspec)\n\n    if hasattr(argspec, 'varkw'):\n        if argspec.varkw:\n            kwargs = callargs.pop(argspec.varkw, {})\n            callargs.update(kwargs)\n\n    if argspec.varargs:\n        varargs = callargs.pop(argspec.varargs, ())\n    else:\n        varargs = ()\n\n    # now callargs is all keywords\n\n    return NormalizedArgs(varargs=varargs,\n                          normargs=callargs,\n                          callargs=original_callargs)", "response": "Normalize call arguments into keyword form and varargs."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_callback(self, f):\n        self.callback = f\n        return self.decorate(self.fref())", "response": "Adds a callback to the cache"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convert_to_struct(value):\n    direct_converts = [dict, OrderedDict, UserDict]\n    if type(value) in direct_converts:\n        # Convert dict-like things to Struct\n        value = Struct(value)\n    elif isinstance(value, list):\n        # Process list elements\n        value = [convert_to_struct(z) for z in value]\n\n    # Done\n    return value", "response": "Convert the value to Struct"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _valid_key(self, key):\n        if not isinstance(key, str):\n            return False\n        elif hasattr({}, key):\n            return False\n        elif key in self._special_names:\n            return False\n        else:\n            return self._valid_key_pattern.match(key)", "response": "Return True if supplied key string serves as a valid attribute name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a recursive dict representation of self", "response": "def asdict(self):\n        \"\"\"Return a recursive dict representation of self\n        \"\"\"\n        d = dict(self._odict)\n\n        for k,v in d.items():\n            if isinstance(v, Struct):\n                d[k] = v.asdict()\n\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nderives from IPython s dict and sequence pretty printer functions.", "response": "def _repr_pretty_(self, p, cycle):\n        \"\"\"Derived from IPython's dict and sequence pretty printer functions,\n        https://github.com/ipython/ipython/blob/master/IPython/lib/pretty.py\n        \"\"\"\n        if cycle:\n            p.text('{...}')\n        else:\n            keys = self.keys()\n\n            if keys:\n                delim_start = '[{'\n                delim_end = '}]'\n\n                wid_max_max = self._repr_max_width\n                wid_max = max([len(k) for k in keys])\n                wid_max = min([wid_max, wid_max_max])\n                key_template = '{{:{:d}s}}: '.format(wid_max)\n\n                with p.group(len(delim_start), delim_start, delim_end):\n                    # Loop over item keys\n                    for idx, key in p._enumerate(keys):\n                        if idx:\n                            p.text(',')\n                            p.breakable()\n\n                        p.text(key_template.format(key))\n                        p.pretty(self[key])\n            else:\n                p.text('{}')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _extract_authenticity_token(data):\n    # Super-cheap Python3 hack.\n    if not isinstance(data, str):\n        data = str(data, 'utf-8')\n    pos = data.find(\"authenticity_token\")\n    # Super-gross.\n    authtok = str(data[pos + 41:pos + 41 + 88])\n    return authtok", "response": "Extract the authenticity token from the data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, arr, mask=None):\n        if mask is not None:\n            refI = np.logical_and(mask, self.n == 0)\n        else:\n            refI = self.n == 0\n        if refI.any():\n            # fill areas of the reference array that where empty before\n            # create initial average value:\n            self.avg[refI] = arr[refI]\n        # the density of the marked array increases by one:\n        self.n[mask] += 1\n        # only consider filled areas:\n        if mask is not None:\n            i = mask  # np.logical_and(mask,self.n>0)\n        else:\n            i = self.n > 0\n        # current value:\n        xn = arr[i]\n        # initial value:\n        x0 = self.avg[i]\n        n = self.n[i]\n        # calculate the new average:\n        new_Avg = self.avg[i] + ((xn - x0) / n)\n\n        if self.var is not None:\n            t = (xn - new_Avg + x0 - self.avg[i]) * (xn - x0) / (n - 1)\n            t = np.nan_to_num(t)\n            self.var[i] += t\n\n        # assign the new average now to remain the old average\n        # for calculating variance above:\n        self.avg[i] = new_Avg", "response": "update the average and variance of the current array with new ndarray"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reorder(\n            miz_file_path: typing.Union[str, Path],\n            target_dir: typing.Union[str, Path],\n            skip_options_file: bool,\n    ):\n        \"\"\"\n        Re-orders a miz file into a folder (flattened)\n\n        Args:\n            miz_file_path: source miz file\n            target_dir: folder to flatten the content into\n            skip_options_file: do not re-order option file\n\n        \"\"\"\n\n        miz_file_path = elib.path.ensure_file(miz_file_path)\n        target_dir_path = elib.path.ensure_dir(target_dir, must_exist=False)\n\n        LOGGER.debug('re-ordering miz file: %s', miz_file_path)\n        LOGGER.debug('destination folder: %s', target_dir)\n        LOGGER.debug('%s option file', \"skipping\" if skip_options_file else \"including\")\n\n        if not target_dir_path.exists():\n            LOGGER.debug('creating directory %s', target_dir_path)\n            target_dir_path.mkdir(exist_ok=True)\n\n        with Miz(miz_file_path, overwrite=True) as miz_:\n\n            def mirror_dir(src: Path, dst: Path):\n                \"\"\"\n                Propagates difference between the original lua tables and the re-ordered one\n\n                Args:\n                    src: source folder\n                    dst: destination folder\n                \"\"\"\n                LOGGER.debug('mirroring: %s -> %s', src, dst)\n\n                LOGGER.debug('comparing directories')\n                diff_ = dircmp(str(src), str(dst), ignore)\n\n                diff_list = diff_.left_only + diff_.diff_files\n                LOGGER.debug('differences: %s', diff_list)\n\n                for __diff in diff_list:\n                    source = Path(diff_.left, __diff)\n                    target = Path(diff_.right, __diff)\n                    LOGGER.debug('looking at: %s', __diff)\n                    if source.is_dir():\n                        LOGGER.debug('isdir: %s', __diff)\n                        if not target.exists():\n                            LOGGER.debug('creating: %s', __diff)\n                            target.mkdir()\n                        mirror_dir(source, target)\n                    else:\n                        LOGGER.debug('copying: %s', __diff)\n                        shutil.copy2(str(source), diff_.right)\n                for sub in diff_.subdirs.values():\n\n                    mirror_dir(Path(sub.left), Path(sub.right))\n\n            # pylint: disable=protected-access\n            miz_._encode()\n\n            if skip_options_file:\n                ignore = ['options']\n            else:\n                ignore = []\n\n            mirror_dir(Path(miz_.temp_dir), target_dir_path)", "response": "Re - orders a miz file into a folder."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites mission dictionary etc. to a MIZ file", "response": "def zip(self, destination: typing.Union[str, Path] = None, encode: bool = True) -> str:\n        \"\"\"\n        Write mission, dictionary etc. to a MIZ file\n\n        Args:\n            destination: target MIZ file (if none, defaults to source MIZ + \"_EMIZ\"\n\n        Returns: destination file\n\n        \"\"\"\n        if encode:\n            self._encode()\n\n        if destination is None:\n            destination_path = self.miz_path.parent.joinpath(f'{self.miz_path.stem}_EMIZ.miz')\n        else:\n            destination_path = elib.path.ensure_file(destination, must_exist=False)\n\n        LOGGER.debug('zipping mission to: %s', destination_path)\n\n        destination_path.write_bytes(dummy_miz)\n\n        with ZipFile(str(destination_path), mode='w', compression=8) as zip_file:\n\n            for root, _, items in os.walk(self.temp_dir.absolute()):\n                for item in items:\n                    item_abs_path = Path(root, item).absolute()\n                    item_rel_path = Path(item_abs_path).relative_to(self.temp_dir)\n                    zip_file.write(item_abs_path, arcname=item_rel_path)\n\n        return str(destination_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ga_context(context_func):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            context = func(self, *args, **kwargs)\n            self.request.google_analytics.update(context_func(context))\n            return context\n        return wrapper\n    return decorator", "response": "A decorator for Cornice views that allows one to set extra parameters for Google Analytics tracking."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cst_now():\n    try:\n        ret = datetime.utcnow() + timedelta(hours=DEFAULT_TIMEZONE)\n        if DEFAULT_TIMEZONE_AWARE:\n            ret = ret.replace(\n                tzinfo=psycopg2.tz.FixedOffsetTimezone(\n                    name=None, offset=DEFAULT_TIMEZONE * 60))\n        return ret\n    except Exception as ex:\n        return datetime.utcnow() + timedelta(hours=DEFAULT_TIMEZONE)", "response": "This will return a datetime of utcnow - 6 hours for\nMimeType Central Standard Time\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef now(years=0, days=0, hours=0, minutes=0, seconds=0):\n    date_time = datetime.utcnow()\n    date_time += timedelta(days=days + years * 365, hours=hours,\n                           minutes=minutes, seconds=seconds)\n    return datetime_to_str(date_time)", "response": "This function returns the datetime of the now timestamp"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_to_timestamp(timestamp, time_delta,\n                     str_format='%Y-%m-%d_%H:%M:%S.fff'):\n    \"\"\"\n        This will convert the timestamp to datetime, add the timedelta\n        and then return it as a timestamp\n    :param timestamp:    str of the date and time\n    :param time_delta:   datetime.timedelta of the time to add\n    :param str_format:   str of the format of the timestamp\n    :return:             str of the new timestamp\n    \"\"\"\n    date_time = str_to_datetime(timestamp, str_format) + time_delta\n    return datetime_to_str(timestamp, str_format)", "response": "This will convert the timestamp to datetime and add the timedelta\n        to the datetime"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a datetime object to a string", "response": "def datetime_to_str(date_time=None, str_format='%Y-%m-%d_%H:%M:%S.fff'):\n    \"\"\"\n    :param   date_time: datetime of the date to convert to string\n    :param   str_format: str of the format to return the string in\n    :return: str of the timestamp\n    \"\"\"\n    date_time = date_time or cst_now()\n    if DEFAULT_TIMEZONE_AWARE:\n        date_time += timedelta(hours=DEFAULT_TIMEZONE)\n    ret = date_time.strftime(str_format.split('.f')[0])\n    if '.f' in str_format:\n        sig_digits = len(str_format.split('.')[-1]) + 1\n        ret += str(date_time.microsecond / 1000000.0\n                   )[1:].ljust(sig_digits, '0')[:sig_digits]\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a string to a datetime object", "response": "def str_to_datetime(timestamp, str_format='%Y-%m-%d_%H:%M:%S.fff'):\n    \"\"\"\n    :param str_format:\n    :param timestamp: str of the timestamp\n    :return:          datetime\n    \"\"\"\n    date_time = datetime.strptime(timestamp.split('.')[0],\n                                  str_format.split('.')[0])\n    if '.' in timestamp:\n        date_time += timedelta(seconds=eval('0.%s' % timestamp.split('.')[1]))\n    if DEFAULT_TIMEZONE_AWARE:\n        date_time = date_time.replace(\n            tzinfo=psycopg2.tz.FixedOffsetTimezone(\n                offset=DEFAULT_TIMEZONE * 60, name=None))\n    return date_time"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nserializing a Python object in SOAP - ENV : Header make sure everything in Header unique.", "response": "def serialize_header(self, pyobj, typecode=None, **kw):\n        '''Serialize a Python object in SOAP-ENV:Header, make\n        sure everything in Header unique (no #href).  Must call\n        serialize first to create a document.\n\n        Parameters: \n            pyobjs -- instances to serialize in SOAP Header\n            typecode -- default typecode\n        '''\n        kw['unique'] = True\n        soap_env = _reserved_ns['SOAP-ENV']\n        #header = self.dom.getElement(soap_env, 'Header')\n        header = self._header\n        if header is None:\n            header = self._header = self.dom.createAppendElement(soap_env, \n                                                                 'Header')\n\n        typecode = getattr(pyobj, 'typecode', typecode)\n        if typecode is None:\n            raise RuntimeError(\n                   'typecode is required to serialize pyobj in header')\n\n        helt = typecode.serialize(header, self, pyobj, **kw)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nserializes a Python object to the output stream.", "response": "def serialize(self, pyobj, typecode=None, root=None, header_pyobjs=(), **kw):\n        '''Serialize a Python object to the output stream.\n           pyobj -- python instance to serialize in body.\n           typecode -- typecode describing body \n           root -- SOAP-ENC:root\n           header_pyobjs -- list of pyobj for soap header inclusion, each\n              instance must specify the typecode attribute.\n        '''\n        self.body = None\n        if self.envelope: \n            soap_env = _reserved_ns['SOAP-ENV']\n            self.dom.createDocument(soap_env, 'Envelope')\n            for prefix, nsuri in _reserved_ns.items():\n                self.dom.setNamespaceAttribute(prefix, nsuri)\n            self.writeNSdict(self.nsdict)\n            if self.encodingStyle:\n                self.dom.setAttributeNS(soap_env, 'encodingStyle', \n                                        self.encodingStyle)\n            if self.header:\n                self._header = self.dom.createAppendElement(soap_env, 'Header')\n\n                for h in header_pyobjs:\n                    self.serialize_header(h, **kw)\n\n            self.body = self.dom.createAppendElement(soap_env, 'Body')\n        else:\n            self.dom.createDocument(None,None)\n\n        if typecode is None: \n            typecode = pyobj.__class__.typecode\n            \n        if self.body is None:\n            elt = typecode.serialize(self.dom, self, pyobj, **kw)\n        else:\n            elt = typecode.serialize(self.body, self, pyobj, **kw)\n            \n        if root is not None:\n            if root not in [ 0, 1 ]:\n                raise ValueError, \"SOAP-ENC root attribute not in [0,1]\"\n            elt.setAttributeNS(SOAP.ENC, 'root', root)\n                        \n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites a namespace dictionary taking care to not clobber the standard prefixes.", "response": "def writeNSdict(self, nsdict):\n        '''Write a namespace dictionary, taking care to not clobber the\n        standard (or reserved by us) prefixes.\n        '''\n        for k,v in nsdict.items():\n            if (k,v) in _standard_ns: continue\n            rv = _reserved_ns.get(k)\n            if rv:\n                if rv != v:\n                    raise KeyError(\"Reserved namespace \" + str((k,v)) + \" used\")\n                continue\n            if k:\n                self.dom.setNamespaceAttribute(k, v)\n            else:\n                self.dom.setNamespaceAttribute('xmlns', v)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef Known(self, obj):\n        '''Seen this object (known by its id()?  Return 1 if so,\n        otherwise add it to our memory and return 0.\n        '''\n        obj = _get_idstr(obj)\n        if obj in self.memo: return 1\n        self.memo.append(obj)\n        return 0", "response": "Return 1 if so 0 otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef Forget(self, obj):\n        '''Forget we've seen this object.\n        '''\n        obj = _get_idstr(obj)\n        try:\n            self.memo.remove(obj)\n        except ValueError:\n            pass", "response": "Forget we ve seen this object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninvoke all the callbacks and close off the SOAP message.", "response": "def close(self):\n        '''Invoke all the callbacks, and close off the SOAP message.\n        '''\n        if self.closed: return\n        for func,arglist in self.callbacks:\n            apply(func, arglist)\n        self.closed = True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup(config_root=''):\n    config = _load_config(root=config_root)\n\n    logging_config = config.get('core', {}).get('logging', {})\n    log_level = logging_config.get('level', 'INFO').upper()\n    log_handlers = logging_config.get('handlers') or ['syslog']\n\n    ulogger.setup_logging(\n        progname='gordon-janitor', level=log_level, handlers=log_handlers)\n\n    return config", "response": "Setup the Gordon service configuration and logging setup."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the key for the given value", "response": "def by_value(self, value, default=None):\n        \"\"\"\n        Returns the key for the given value\n        \"\"\"\n        try:\n            return [k for k, v in self.items() if v == value][0]\n        except IndexError:\n            if default is not None:\n                return default\n            raise ValueError('%s' % value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_folder(self, path, depth=None, source_type=DefaultSourceType):\n        self.add_source(FolderSource(path, depth, **source_type))\n        return self", "response": "Add a folder source to scan recursively from path."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a pattern to the scan list.", "response": "def add_pattern(self, pattern, root=\".\", depth=None, source_type=DefaultSourceType):\n        \"\"\"\n        Add a recursive folder scan using a linux-style patterns.\n\n        :param pattern: pattern or list of patterns to match.\n        :param root: root to start from (default to '.')\n        :param depth: if provided will be depth limit. 0 = first level only.\n        :param source_type: what to return; files only, folders only, or both.\n        \"\"\"\n        self.add_source(PatternSource(pattern, root, depth, **source_type))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a folder source to scan recursively with a regex filter on directories.", "response": "def add_filtered_folder(self, path, regex, depth=None, source_type=DefaultSourceType):\n        \"\"\"\n        Add a folder source to scan recursively, with a regex filter on directories.\n\n        :param regex: regex string to filter folders by.\n        :param depth: if provided will be depth limit. 0 = first level only.\n        :param source_type: what to return; files only, folders only, or both.\n        \"\"\"\n        self.add_source(FilteredFolderSource(path, regex, depth, **source_type))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_filter(self, files_filter, filter_type=DefaultFilterType):\n        self.__filters.append((files_filter, filter_type))\n        return self", "response": "Add a files filter to this iterator."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a filter by linux - style files pattern to this iterator.", "response": "def add_filter_by_pattern(self, pattern, filter_type=DefaultFilterType):\n        \"\"\"\n        Add a files filter by linux-style pattern to this iterator.\n\n        :param pattern: linux-style files pattern (or list of patterns)\n        \"\"\"\n        self.add_filter(FilterPattern(pattern), filter_type)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_filter_by_regex(self, regex_expression, filter_type=DefaultFilterType):\n        self.add_filter(FilterRegex(regex_expression), filter_type)\n        return self", "response": "Add a files filter by regex to this iterator."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a filter by one or more extensions to this iterator.", "response": "def add_filter_by_extension(self, extensions, filter_type=DefaultFilterType):\n        \"\"\"\n        Add a files filter by extensions to this iterator.\n\n        :param extensions: single extension or list of extensions to filter by.\n                            for example: [\"py\", \"js\", \"cpp\", ...]\n        \"\"\"\n        self.add_filter(FilterExtension(extensions), filter_type)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\niterates over files in all sources and process them.", "response": "def next(self, dryrun=False):\n        \"\"\"\n        Iterate over files in all sources.\n        Use this if you want to iterate files externally.\n\n        :param dryrun: if true, will only return all filenames instead of processing them, eg will not\n                        call \"process_file\" at all, and just show all the files it will scan.\n        \"\"\"\n\n        # call the start hook\n        self.on_start(dryrun)\n\n        # store current dir\n        curr_dir = \"\"\n\n        # iterate over sources\n        for src in self.__sources:\n\n            # call the start_source hook\n            self.on_start_source(src, dryrun)\n\n            # iterate over files\n            for filename in src.next():\n\n                # make sure file pass filters\n                if not self.match_filters(filename):\n                    continue\n\n                # get curr dir to call the directory-enter hook\n                new_curr_dir = os.path.dirname(filename)\n                if new_curr_dir != curr_dir:\n                    self.on_enter_dir(new_curr_dir, dryrun)\n                    curr_dir = new_curr_dir\n\n                # process file\n                curr = self.process_file(filename, dryrun)\n\n                # if after process we still want to return file for external iteration, return it\n                if curr is not None:\n                    yield curr\n\n            # call the end-source hook\n            self.on_end_source(src, dryrun)\n\n        # call the end iteration hook and raise stop iteration exception\n        self.on_end(dryrun)\n        raise StopIteration"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef match_filters(self, path):\n        # indicate if all required filters were matched\n        all_required_match = True\n\n        # iterate over filters to match files\n        for filt, ftype in self.__filters:\n\n            # handle \"Required\" filters:\n            if all_required_match and ftype == self.FilterType.Required and not filt.match(path):\n                all_required_match = False\n\n            # handle \"Include\" filters:\n            elif ftype == self.FilterType.Include and filt.match(path):\n                return True\n\n            # handle \"Exclude\" filters:\n            elif ftype == self.FilterType.Exclude and filt.match(path):\n                return False\n\n        # if got here it means we processed all filters, and no include/exclude filter was matched.\n        # return if all required were matched\n        return all_required_match", "response": "Match the filters for a file and return True if all filters pass and false otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_proxy(self, proxy, update=True):\n        update_web_driver = False\n        if self.current_proxy != proxy:\n            # Did we change proxies?\n            update_web_driver = True\n\n        self.current_proxy = proxy\n        if proxy is None:\n            self.driver_args['service_args'] = self.default_service_args\n        else:\n            proxy_parts = cutil.get_proxy_parts(proxy)\n\n            self.driver_args['service_args'].extend(['--proxy={host}:{port}'.format(**proxy_parts),\n                                                     '--proxy-type={schema}'.format(**proxy_parts),\n                                                     ])\n            if proxy_parts.get('user') is not None:\n                self.driver_args['service_args'].append('--proxy-auth={user}:{password}'.format(**proxy_parts))\n\n        # Recreate webdriver with new proxy settings\n        if update is True and update_web_driver is True:\n            self._update()", "response": "Set proxy for requests session session\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new session with no default headers and proxies", "response": "def _create_session(self):\n        \"\"\"\n        Creates a fresh session with no/default headers and proxies\n        \"\"\"\n        logger.debug(\"Create new phantomjs web driver\")\n        self.driver = webdriver.PhantomJS(desired_capabilities=self.dcap,\n                                          **self.driver_args)\n        self.set_cookies(self.current_cookies)\n        self.driver.set_window_size(1920, 1080)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreset the current session and creates a new one with no proxies or headers.", "response": "def reset(self):\n        \"\"\"\n        Kills old session and creates a new one with no proxies or headers\n        \"\"\"\n        # Kill old connection\n        self.quit()\n        # Clear proxy data\n        self.driver_args['service_args'] = self.default_service_args\n        # Clear headers\n        self.dcap = dict(webdriver.DesiredCapabilities.PHANTOMJS)\n        # Create new web driver\n        self._create_session()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef SetPyclassMetaclass(option, opt, value, parser, *args, **kwargs):\n    from pyremotevbox.ZSI.generate.containers import ServiceHeaderContainer,\\\n        TypecodeContainerBase, TypesHeaderContainer\n        \n    TypecodeContainerBase.metaclass = kwargs['metaclass']\n    TypesHeaderContainer.imports.append(\\\n            'from %(module)s import %(metaclass)s' %kwargs\n            )\n    ServiceHeaderContainer.imports.append(\\\n            'from %(module)s import %(metaclass)s' %kwargs\n            )", "response": "set up pyclass metaclass for complexTypes"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef wsdl2py(args=None):\n    op = optparse.OptionParser(usage=\"USAGE: %wsdl2py [options] WSDL\",\n                 description=wsdl2py.__doc__)\n    \n    # Basic options\n    op.add_option(\"-x\", \"--schema\",\n                  action=\"store_true\", dest=\"schema\", default=False,\n                  help=\"process just the schema from an xsd file [no services]\")\n\n    op.add_option(\"-d\", \"--debug\",\n                  action=\"callback\", callback=SetDebugCallback,\n                  help=\"debug output\")\n                  \n    # WS Options\n    op.add_option(\"-a\", \"--address\",\n                  action=\"store_true\", dest=\"address\", default=False,\n                  help=\"ws-addressing support, must include WS-Addressing schema.\")\n                  \n    # pyclass Metaclass \n    op.add_option(\"-b\", \"--complexType\",\n                  action=\"callback\", callback=SetPyclassMetaclass, \n                  callback_kwargs={'module':'ZSI.generate.pyclass', \n                      'metaclass':'pyclass_type'},\n                  help=\"add convenience functions for complexTypes, including Getters, Setters, factory methods, and properties (via metaclass). *** DONT USE WITH --simple-naming ***\")\n    \n    # Lazy Evaluation of Typecodes (done at serialization/parsing when needed).\n    op.add_option(\"-l\", \"--lazy\",\n                  action=\"callback\", callback=SetUpLazyEvaluation, \n                  callback_kwargs={},\n                  help=\"EXPERIMENTAL: recursion error solution, lazy evalution of typecodes\")\n    \n    # Use Twisted\n    op.add_option(\"-w\", \"--twisted\",\n                  action=\"store_true\", dest='twisted', default=False,\n                  help=\"generate a twisted.web client/server, dependencies python>=2.4, Twisted>=2.0.0, TwistedWeb>=0.5.0\")\n    \n    op.add_option(\"-o\", \"--output-dir\",\n                  action=\"store\", dest=\"output_dir\", default=\".\", type=\"string\",\n                  help=\"save files in directory\")\n    \n    op.add_option(\"-s\", \"--simple-naming\",\n                  action=\"store_true\", dest=\"simple_naming\", default=False,\n                  help=\"map element names directly to python attributes\")\n    \n    op.add_option(\"-p\", \"--pydoc\",\n                  action=\"store_true\", dest=\"pydoc\", default=False,\n                  help=\"top-level directory for pydoc documentation.\")\n    \n    \n    is_cmdline = args is None\n    if is_cmdline:\n        (options, args) = op.parse_args()\n    else:\n        (options, args) = op.parse_args(args)\n\n    if len(args) != 1:\n        print>>sys.stderr, 'Expecting a file/url as argument (WSDL).'\n        sys.exit(os.EX_USAGE)\n        \n    location = args[0]\n    if options.schema is True:\n        reader = XMLSchema.SchemaReader(base_url=location)\n    else:\n        reader = WSDLTools.WSDLReader()\n\n    load = reader.loadFromFile\n    if not isfile(location):\n        load = reader.loadFromURL\n\n    try:\n        wsdl = load(location)\n    except Exception, e:\n        print >> sys.stderr, \"Error loading %s: \\n\\t%s\" % (location, e)\n        traceback.print_exc(sys.stderr)\n        # exit code UNIX specific, Windows?\n        if hasattr(os, 'EX_NOINPUT'): sys.exit(os.EX_NOINPUT)\n        sys.exit(\"error loading %s\" %location)\n  \n    if isinstance(wsdl, XMLSchema.XMLSchema): \n        wsdl.location = location\n        files = _wsdl2py(options, wsdl)\n    else:\n        files = _wsdl2py(options, wsdl)\n        files.append(_wsdl2dispatch(options, wsdl))\n    \n    if getattr(options, 'pydoc', False):\n        _writepydoc(os.path.join('docs', 'API'), *files)\n        \n    if is_cmdline:\n        return\n    \n    return files", "response": "Utility for automatically generating client and service interface code from a WSDL file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _wsdl2dispatch(options, wsdl):\n    kw = dict()\n    if options.twisted:\n        from pyremotevbox.ZSI.twisted.WSresource import WSResource\n        kw['base'] = WSResource\n        ss = ServiceDescription(**kw)\n        if options.address is True:\n            raise RuntimeError, 'WS-Address w/twisted currently unsupported, edit the \"factory\" attribute by hand'\n    else:\n        # TODO: make all this handler arch\n        if options.address is True:\n            ss = ServiceDescriptionWSA()\n        else:\n            ss = ServiceDescription(**kw)\n\n    ss.fromWSDL(wsdl)\n    file_name = ss.getServiceModuleName()+'.py'\n    fd = open( join(options.output_dir, file_name), 'w+')\n    ss.write(fd)\n    fd.close()\n    \n    return file_name", "response": "TOOD: Remove ServiceContainer stuff and replace with WSGI.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites HTML documentation to a file in the current directory.", "response": "def _writedoc(doc, thing, forceload=0):\n    \"\"\"Write HTML documentation to a file in the current directory.\n    \"\"\"\n    try:\n        object, name = pydoc.resolve(thing, forceload)\n        page = pydoc.html.page(pydoc.describe(object), pydoc.html.document(object, name))\n        fname = os.path.join(doc, name + '.html')\n        file = open(fname, 'w')\n        file.write(page)\n        file.close()\n    except (ImportError, pydoc.ErrorDuringImport), value:\n        traceback.print_exc(sys.stderr)\n    else:\n        return name + '.html'"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites HTML documentation to a file in the current directory.", "response": "def _writeclientdoc(doc, thing, forceload=0):\n    \"\"\"Write HTML documentation to a file in the current directory.\n    \"\"\"\n    docmodule = pydoc.HTMLDoc.docmodule\n    def strongarm(self, object, name=None, mod=None, *ignored):\n        result = docmodule(self, object, name, mod, *ignored)\n\n        # Grab all the aliases to pyclasses and create links.\n        nonmembers = []\n        push = nonmembers.append\n        for k,v in inspect.getmembers(object, inspect.isclass):\n            if inspect.getmodule(v) is not object and getattr(v,'typecode',None) is not None:\n                push('<a href=\"%s.html\">%s</a>: pyclass alias<br/>' %(v.__name__,k))\n\n        result += self.bigsection('Aliases', '#ffffff', '#eeaa77', ''.join(nonmembers))\n        return result\n\n    pydoc.HTMLDoc.docmodule = strongarm\n    try:\n        object, name = pydoc.resolve(thing, forceload)\n        page = pydoc.html.page(pydoc.describe(object), pydoc.html.document(object, name))\n        name = os.path.join(doc, name + '.html')\n        file = open(name, 'w')\n        file.write(page)\n        file.close()\n    except (ImportError, pydoc.ErrorDuringImport), value:\n        log.debug(str(value))\n\n    pydoc.HTMLDoc.docmodule = docmodule"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite HTML documentation for a class object.", "response": "def _writetypesdoc(doc, thing, forceload=0):\n    \"\"\"Write HTML documentation to a file in the current directory.\n    \"\"\"\n    try:\n        object, name = pydoc.resolve(thing, forceload)\n        name = os.path.join(doc, name + '.html')\n    except (ImportError, pydoc.ErrorDuringImport), value:\n        log.debug(str(value))\n        return\n        \n    # inner classes\n    cdict = {}\n    fdict = {}\n    elements_dict = {}\n    types_dict = {}\n    for kname,klass in inspect.getmembers(thing, inspect.isclass):\n        if thing is not inspect.getmodule(klass):\n            continue\n        \n        cdict[kname] = inspect.getmembers(klass, inspect.isclass)\n        for iname,iklass in cdict[kname]:\n            key = (kname,iname)\n            fdict[key] = _writedoc(doc, iklass)\n            if issubclass(iklass, ElementDeclaration):\n                \n                try:\n                    typecode = iklass()\n                except (AttributeError,RuntimeError), ex:\n                    elements_dict[iname] = _writebrokedoc(doc, ex, iname)\n                    continue\n\n                elements_dict[iname] = None\n                if typecode.pyclass is not None:                        \n                    elements_dict[iname] = _writedoc(doc, typecode.pyclass)\n\n                continue\n\n            if issubclass(iklass, TypeDefinition):\n                try:\n                    typecode = iklass(None)\n                except (AttributeError,RuntimeError), ex:\n                    types_dict[iname] = _writebrokedoc(doc, ex, iname)\n                    continue\n\n                types_dict[iname] = None\n                if typecode.pyclass is not None:\n                    types_dict[iname] = _writedoc(doc, typecode.pyclass)\n\n                continue\n                        \n                \n    def strongarm(self, object, name=None, mod=None, funcs={}, classes={}, *ignored):\n        \"\"\"Produce HTML documentation for a class object.\"\"\"\n        realname = object.__name__\n        name = name or realname\n        bases = object.__bases__\n        object, name = pydoc.resolve(object, forceload)\n        contents = []\n        push = contents.append\n        if name == realname:\n            title = '<a name=\"%s\">class <strong>%s</strong></a>' % (\n                name, realname)\n        else:   \n            title = '<strong>%s</strong> = <a name=\"%s\">class %s</a>' % (\n                name, name, realname)\n                \n        mdict = {}\n        if bases:\n            parents = []\n            for base in bases:\n                parents.append(self.classlink(base, object.__module__))\n            title = title + '(%s)' % pydoc.join(parents, ', ')\n            \n        doc = self.markup(pydoc.getdoc(object), self.preformat, funcs, classes, mdict)\n        doc = doc and '<tt>%s<br>&nbsp;</tt>' % doc\n        for iname,iclass in cdict[name]:\n            fname = fdict[(name,iname)]\n\n            if elements_dict.has_key(iname):\n                push('class <a href=\"%s\">%s</a>: element declaration typecode<br/>'\\\n                    %(fname,iname))\n                pyclass = elements_dict[iname]\n                if pyclass is not None:\n                    push('<ul>instance attributes:')\n                    push('<li><a href=\"%s\">pyclass</a>: instances serializable to XML<br/></li>'\\\n                        %elements_dict[iname])\n                    push('</ul>')\n            elif types_dict.has_key(iname):\n                push('class <a href=\"%s\">%s</a>: type definition typecode<br/>' %(fname,iname))\n                pyclass = types_dict[iname]\n                if pyclass is not None:\n                    push('<ul>instance attributes:')\n                    push('<li><a href=\"%s\">pyclass</a>: instances serializable to XML<br/></li>'\\\n                          %types_dict[iname])\n                    push('</ul>')\n            else:\n                push('class <a href=\"%s\">%s</a>: TODO not sure what this is<br/>' %(fname,iname))\n                \n        contents = ''.join(contents)\n        return self.section(title, '#000000', '#ffc8d8', contents, 3, doc) \n    \n    doclass = pydoc.HTMLDoc.docclass\n    pydoc.HTMLDoc.docclass = strongarm\n            \n    try:\n        page = pydoc.html.page(pydoc.describe(object), pydoc.html.document(object, name))\n        file = open(name, 'w')\n        file.write(page)\n        file.close()\n    except (ImportError, pydoc.ErrorDuringImport), value:\n        log.debug(str(value))\n        \n    pydoc.HTMLDoc.docclass = doclass"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates pydoc html pages doc -- destination directory for documents *args -- modules run thru pydoc", "response": "def _writepydoc(doc, *args):\n    \"\"\"create pydoc html pages\n    doc -- destination directory for documents\n    *args -- modules run thru pydoc\n    \"\"\"\n    ok = True\n    if not os.path.isdir(doc):\n        os.makedirs(doc)\n    \n    if os.path.curdir not in sys.path:\n        sys.path.append(os.path.curdir)\n\n    for f in args:\n        if f.startswith('./'): f = f[2:]\n        name = os.path.sep.join(f.strip('.py').split(os.path.sep))\n        try:\n            e = __import__(name)\n        except Exception,ex:\n            raise\n#            _writebrokedoc(doc, ex, name)\n#            continue\n   \n        if name.endswith('_client'):\n            _writeclientdoc(doc, e)\n            continue\n    \n        if name.endswith('_types'):\n            _writetypesdoc(doc, e)\n            continue\n  \n        try: \n            _writedoc(doc, e)\n        except IndexError,ex:\n            _writebrokedoc(doc, ex, name)\n            continue"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the averaged values in the grid", "response": "def averageValues(self):\n        \"\"\"\n        return the averaged values in the grid\n        \"\"\"\n        assert self.opts['record_density'] and self.opts['method'] == 'sum'\n        # dont increase value of partly filled cells (density 0..1):\n        filled = self.density > 1\n        v = self.values.copy()\n        v[filled] /= self.density[filled]\n\n        # ONLY AS OPTION??:\n        v[~filled] *= self.density[~filled]\n        return v"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a value to the merge matrix.", "response": "def add(self, point, value):\n        \"\"\"\n        Assign all self.merge_values to the self._mergeMatrix\n        Get the position/intensity of a value\n        \"\"\"\n        # check range\n        for p, r in zip(point, self.range):\n            if p < r[0] or p > r[1]:\n                return\n        # check nan\n        if isnan(value):\n            return\n\n        refs = self.opts['references']\n        # for all neighbour points (1, if antialiasting=False):\n        for position, intensity in self.sortMethod.getPositionsIntensities(\n                point):\n            position = tuple(position)\n            if self.mean is not None:\n                old_value = self.values[position]\n                if not np.isnan(old_value):\n                    anz_values = self.density[position]\n                    mean = old_value + intensity * (\n                        ((value - old_value) / (anz_values + intensity)))\n                    self.mean[position] = mean\n\n                    if self.variance is not None:\n                        self.variance[\n                            position] += (abs(value - mean) / (\n                                anz_values + intensity))\n\n            if self.mergeMethod(self.values, position, intensity, value):\n                for a in refs:\n                    a.mergeMethod(a, position, intensity, value)\n            if self.density is not None:\n                self.density[position] += intensity"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef deny_access(self, request, **kwargs):\n        # Raise a 403 for POST/DELETE etc.\n        if request.method != 'GET':\n            return HttpResponseForbidden()\n\n        # Add a message, if one has been defined.\n        message = self.get_access_denied_message(request)\n        if message:\n            messages.info(request, _(message))\n\n        # Return a HTTP 302 redirect.\n        redirect_url = self.get_unauthorised_redirect_url(request)\n        return redirect_to_login(request.get_full_path(), login_url=redirect_url)", "response": "Returns a HttpResponse for forbidden access."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if and only if the resource s URL is not exempt and is protected.", "response": "def is_resource_protected(self, request, **kwargs):\n        \"\"\"\n        Returns true if and only if the resource's URL is *not* exempt and *is* protected.\n        \"\"\"\n        exempt_urls = self.get_exempt_url_patterns()\n        protected_urls = self.get_protected_url_patterns()\n        path = request.path_info.lstrip('/')\n\n        path_is_exempt = any(m.match(path) for m in exempt_urls)\n        if path_is_exempt:\n            return False\n\n        path_is_protected = any(m.match(path) for m in protected_urls)\n        if path_is_protected:\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nusing workdir. options. path as a temporary working directory", "response": "def as_cwd():\n    \"\"\" Use workdir.options.path as a temporary working directory \"\"\"\n    _set_log_level()\n    owd = os.getcwd()\n    logger.debug('entering working directory: ' + options.path)\n    os.chdir(os.path.expanduser(options.path))\n    yield\n    logger.debug('returning to original directory: ' + owd)\n    os.chdir(owd)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntakes a path that you might find in a. gitignore file and turn it into a regex", "response": "def _gitignore_entry_to_regex(entry):\n    \"\"\" Take a path that you might find in a .gitignore file and turn it into a regex \"\"\"\n    ret = entry.strip()\n    ret = ret.replace('.', '\\.')\n    ret = ret.replace('*', '.*')\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sync(sourcedir=None, exclude_gitignore_entries=None, exclude_regex_list=None):\n    _set_log_level()\n    sourcedir = sourcedir or options.sync_sourcedir or os.getcwd()\n    if exclude_gitignore_entries is None:\n        exclude_gitignore_entries = options.sync_exclude_gitignore_entries\n    exclude_regex_list = exclude_regex_list or copy.copy(options.sync_exclude_regex_list)\n    gitignore_path = os.path.join(sourcedir, '.gitignore')\n    if exclude_gitignore_entries and os.path.isfile(gitignore_path):\n        gitignore_lines = []\n        with open(gitignore_path) as gitignore:\n            for line in gitignore.readlines():\n                line = line.strip()\n                if line and not line.startswith('#'):\n                    gitignore_lines.append(_gitignore_entry_to_regex(line))\n        exclude_regex_list += gitignore_lines\n    dirsync_logger = logging.getLogger('dirsync')\n    dirsync_logger.setLevel(logging.INFO if options.debug else logging.FATAL)\n    logger.info('syncing {} to {}'.format(sourcedir, options.path))\n    logger.debug('excluding {} from sync'.format(exclude_regex_list))\n    dirsync.sync(\n        sourcedir=sourcedir,\n        targetdir=options.path,\n        action='sync',\n        create=True,\n        exclude=exclude_regex_list,\n        logger=dirsync_logger\n    )", "response": "Syncs the current directory with the source directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate the directory where the files are stored in the workdir.", "response": "def create():\n    \"\"\" Create workdir.options.path \"\"\"\n    if not os.path.isdir(options.path):\n        logger.info('creating working directory: ' + options.path)\n        os.makedirs(options.path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clean():\n    if os.path.isdir(options.path):\n        logger.info('cleaning working directory: ' + options.path)\n        for filename in os.listdir(options.path):\n            filepath = os.path.join(options.path, filename)\n            if os.path.isdir(filepath):\n                shutil.rmtree(os.path.join(options.path, filename))\n            else:\n                os.remove(filepath)", "response": "Remove all of the files contained in workdir. options. path"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove the workdir. options. path", "response": "def remove():\n    \"\"\" Remove workdir.options.path \"\"\"\n    if os.path.isdir(options.path):\n        logger.info('removing working directory: ' + options.path)\n        shutil.rmtree(options.path)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef query(cls, *args, **kwargs):\n        for doc in cls._coll.find(*args, **kwargs):\n            yield cls.from_storage(doc)", "response": "Query for all the objects in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef query_one(cls, *args, **kwargs):\n        doc = cls._coll.find_one(*args, **kwargs)\n        if doc:\n            return cls.from_storage(doc)", "response": "Same as collection. find_one but return Document then dict"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef upsert(self, null=False):\n        self._pre_save()\n        self.validate()\n\n        filter_ = self._upsert_filter()\n        if filter_:\n            update = self._upsert_update(filter_, null)\n\n            if update['$set']:\n                r = self._coll.find_one_and_update(filter_, update,\n                                                   upsert=True, new=True)\n                self._data['_id'] = r['_id']\n        else:\n            r = self._coll.insert_one(self._data)\n            self._data['_id'] = r.inserted_id", "response": "Insert or update a document with optional upsert = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nqueries the cache for the given class and return a CachedModel instance.", "response": "def cached(cls, timeout=60, cache_none=False):\n        \"\"\" Cache queries\n\n        :param timeout: cache timeout\n        :param cache_none: cache None result\n\n        Usage::\n\n        >>> Model.cached(60).query({...})\n        \"\"\"\n        return CachedModel(cls=cls, timeout=timeout, cache_none=cache_none)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef statusBar(step, total, bar_len=20, onlyReturn=False):\n\n    norm = 100.0 / total\n    step *= norm\n    step = int(step)\n    increment = 100 // bar_len\n    n = step // increment\n    m = bar_len - n\n    text = \"\\r[\" + \"=\" * n + \"o\" + \"-\" * m + \"]\" + str(step) + \"%\"\n    if onlyReturn:\n        return text\n    stdout.write(text)\n    stdout.flush()", "response": "print a statusbar of variable length e. g. showing 25%"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_info(self, client, info):\n        if 'identity' in info:\n            info['stages'] = client.get_stages(restApiId=info['identity'])['item']\n            info['resources'] = client.get_resources(restApiId=info['identity'])['items']\n            for resource in info['resources']:\n                for method in resource.get('resourceMethods', {}):\n                    resource['resourceMethods'][method] = client.get_method(restApiId=info['identity'], resourceId=resource['id'], httpMethod=method)\n                    for status_code, options in resource['resourceMethods'][method]['methodResponses'].items():\n                        options.update(client.get_method_response(restApiId=info['identity'], resourceId=resource['id'], httpMethod=method, statusCode=status_code))\n\n            info['deployment'] = client.get_deployments(restApiId=info['identity'])['items']\n        else:\n            for key in ('stages', 'resources', 'deployment'):\n                info[key] = []\n\n        info['api_keys'] = client.get_api_keys()['items']\n        info['domains'] = client.get_domain_names()['items']\n        for domain in info['domains']:\n            domain['mappings'] = client.get_base_path_mappings(domainName=domain['domainName']).get('items', [])", "response": "Load the information about the gateway"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the names of files to be created.", "response": "def files(self):\n        \"\"\" Return the names of files to be created. \"\"\"\n        files_description = [\n            [ self.project_name,\n              'bootstrap',\n              'BootstrapScriptFileTemplate' ],\n            [ self.project_name,\n              'CHANGES.txt',\n              'PythonPackageCHANGESFileTemplate' ],\n            [ self.project_name,\n              'LICENSE.txt',\n              'GPL3FileTemplate' ],\n            [ self.project_name,\n              'MANIFEST.in',\n              'PythonPackageMANIFESTFileTemplate' ],\n            [ self.project_name,\n              'README.txt',\n              'READMEReSTFileTemplate' ],\n            [ self.project_name,\n              'setup.py',\n              'PythonPackageSetupFileTemplate' ],\n            [ self.project_name + '/' + self.project_name.lower(),\n              '__init__.py',\n              None ],\n            [ self.project_name + '/docs',\n              'index.rst',\n              None ],\n        ]\n        return files_description"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the substitutions for the templating replacements.", "response": "def substitutes(self):\n        \"\"\" Return the substitutions for the templating replacements. \"\"\"\n        author_collector = AuthorCollector()\n        mail_collector = AuthorMailCollector()\n        substitute_dict = dict(\n            project = self.project_name,\n            project_lower = self.project_name.lower(),\n            date = date.today().isoformat(),\n            author = author_collector.collect(),\n            author_email = mail_collector.collect(),\n        )\n        return substitute_dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert an encoded module name to an unencoded source uri", "response": "def module2uri(self, module_name):\n        \"\"\"Convert an encoded module name to an unencoded source uri\"\"\"\n        encoded_str = super(EncodedModuleLoader, self).module2uri(module_name)\n        encoded = encoded_str.encode('ASCII')\n        compressed = base64.b64decode(encoded, b'+&')\n        return zlib.decompress(compressed)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting an unencoded source uri to an encoded module name", "response": "def uri2module(self, uri):\n        \"\"\"Convert an unencoded source uri to an encoded module name\"\"\"\n        # uri is the source code of the module\n        compressed = zlib.compress(uri)\n        encoded = base64.b64encode(compressed, b'+&')\n        encoded_str = encoded.decode('ASCII')\n        return super(EncodedModuleLoader, self).uri2module(encoded_str)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_module(self, name):\n        if name in sys.modules:\n            return sys.modules[name]\n        module_source = self.module2uri(name)\n        module_container = tempfile.NamedTemporaryFile(suffix='.py', delete=False)\n        with module_container:\n            module_container.write(module_source)\n            module_container.file.seek(0)\n            module = imp.load_module(name, module_container.file, module_container.name, ('.py', 'U', imp.PY_SOURCE))\n        module.__source__ = module_container\n        module.__loader__ = self\n        sys.modules[name] = module\n        return module", "response": "Load and return a module with the given name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_user_ip(self, request):\n\n        client_ip_address = None\n\n        # searching the IP address\n        for key in self.configuration.network.ip_meta_precedence_order:\n\n            ip_meta_value = request.META.get(key, '').strip()\n\n            if ip_meta_value != '':\n                ips = [ip.strip().lower() for ip in ip_meta_value.split(',')]\n\n                for ip_str in ips:\n\n                    if ip_str and is_valid_ip(ip_str):\n\n                        if not ip_str.startswith(self.configuration.network.non_public_ip_prefixes):\n                            return ip_str\n\n                        elif not self.configuration.network.real_ip_only:\n                            loopback = ('127.0.0.1', '::1')\n\n                            if client_ip_address is None:\n                                client_ip_address = ip_str\n\n                            elif client_ip_address in loopback and ip_str not in loopback:\n                                client_ip_address = ip_str\n\n        if client_ip_address is None and settings.DEBUG:\n            raise DobermanImproperlyConfigured(\n                \"Unknown IP, maybe you are working on localhost/development, \"\n                \"so please set in your setting: DOBERMAN_REAL_IP_ONLY=False\"\n            )\n\n        return client_ip_address", "response": "get the client IP address bassed on a HTTPRequest"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef raw(self):\n        escape_dict = {'\\a': r'\\a',\n                       '\\b': r'\\b',\n                       '\\c': r'\\c',\n                       '\\f': r'\\f',\n                       '\\n': r'\\n',\n                       '\\r': r'\\r',\n                       '\\t': r'\\t',\n                       '\\v': r'\\v',\n                       #'\\x':r'\\x',#cannot do \\x - otherwise exception\n                       '\\'': r'\\'',\n                       '\\\"': r'\\\"',\n                       #'\\0':r'\\0', #doesnt work\n                       '\\1': r'\\1',\n                       '\\2': r'\\2',\n                       '\\3': r'\\3',\n                       '\\4': r'\\4',\n                       '\\5': r'\\5',\n                       '\\6': r'\\6',\n                       #'\\7':r'\\7',#same as \\a is ASCI\n                       }\n    \n        new_string = ''\n        for char in self:\n            try:\n                new_string += escape_dict[char]\n            except KeyError:\n                new_string += char\n        return new_string", "response": "Try to transform str to raw str... this will not work every time\nAttributeNames is set"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getcwd(moduleName=None):\n        try:\n            p = PathStr(sys._MEIPASS)\n            if moduleName is not None:\n                # pyinstaller create one temp folder\n                # to separate e.g. media directories from each package it is useful\n                # to build its file-tree like this /temp/[mainPackage]/\n                # to get the main package PathStr need a derived instance\n                return p.join(moduleName.split('.')[0])\n            return p\n        except AttributeError:\n            return PathStr(os.getcwd())", "response": "get current path from sys. _MEIPASS or sys. getcwd"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nopening and read the file is existent", "response": "def load(self, size):\n        \"\"\"open and read the file is existent\"\"\"\n        if self.exists() and self.isfile():\n            return eval(open(self).read(size))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef move(self, dst):\n        shutil.move(self, dst)\n        self = PathStr(dst).join(self.basename())\n        return self", "response": "move this file or folder the dst"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef files(self, ftype=None):\n        a = [self.join(i) for i in self]\n        if ftype is not None:\n            return [i for i in a if i.isfile() and i.filetype() == ftype]\n        return [i for i in a if i.isfile()]", "response": "return a first of path to all files within that folder"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mergeDictionaries(sourceDictionary, destinationDictionary):\n        log = Logger()\n        varNamePattern = re.compile(r\"^((__((ENV)|(FILE))__[A-Z]{3,})|(__((ENV)|(FILE))))__(?P<name>.*)$\")\n        varTypePattern = re.compile(r\"^__((ENV)|(FILE))__(?P<type>[A-Z]{3,})__(.*)$\")\n\n        for key, value in sourceDictionary.items():\n            # ignoring comments\n            if key == \"//\":\n                continue\n\n            if isinstance(value, dict):\n                # get node or create one\n                node = destinationDictionary.setdefault(key, {})\n                Config.mergeDictionaries(value, node)\n            elif isinstance(value, str) and (value.startswith(\"__ENV__\") or value.startswith(\"__FILE__\")):\n                # extracting environment variable name\n                nameMatch = varNamePattern.match(value)\n                if nameMatch is None:\n                    log.warn(\"Invalid environmental variable specified: {name}\", name=value)\n                    continue\n                envVariableName = nameMatch.group(\"name\")\n\n                # checking if environment variable is set\n                if envVariableName not in os.environ:\n                    log.warn(\"No environment variable {name} is set.\", name=envVariableName)\n                    continue\n\n                if value.startswith(\"__ENV__\"): # checking if value is set in the environment variable\n                    # checking if variable has a defined cast type\n                    typeMatch = varTypePattern.match(value)\n                    if typeMatch is not None:\n                        envVariableType = typeMatch.group(\"type\")\n\n                        # casting value to the specified type\n                        if envVariableType == \"STR\":\n                            destinationDictionary[key] = str(os.environ[envVariableName])\n                        elif envVariableType == \"BOOL\":\n                            if os.environ[envVariableName] == \"1\":\n                                destinationDictionary[key] = True\n                            elif os.environ[envVariableName] == \"0\":\n                                destinationDictionary[key] = False\n                        elif envVariableType == \"INT\":\n                            destinationDictionary[key] = int(os.environ[envVariableName])\n                        elif envVariableType == \"FLOAT\":\n                            destinationDictionary[key] = float(os.environ[envVariableName])\n                        elif envVariableType == \"JSON\":\n                            try:\n                                destinationDictionary[key] = json.loads(os.environ[envVariableName])\n                            except Exception:\n                                log.warn(\n                                    \"Environment variable {name} contains an invalid JSON value.\",\n                                    name=envVariableName\n                                )\n                        else:\n                            log.warn(\n                                \"Unsupported type {type} specified for variable {name}.\",\n                                name=envVariableName,\n                                type=envVariableType\n                            )\n                            continue\n                    else:\n                        destinationDictionary[key] = os.environ[envVariableName]\n                elif value.startswith(\"__FILE__\"): # checking if value is set in a file\n                    filePath = os.environ[envVariableName]\n\n                    # checking if file exists\n                    if not os.path.isfile(filePath):\n                        log.warn(\n                            \"File {filePath} does not exist.\",\n                            filePath=filePath,\n                        )\n                        continue\n\n                    # checking if file can be read\n                    if not os.access(filePath, os.R_OK):\n                        log.warn(\n                            \"File {filePath} cannot be read.\",\n                            filePath=filePath,\n                        )\n                        continue\n\n                    # load file contents\n                    filePointer = open(filePath, \"r\")\n                    destinationDictionary[key] = filePointer.read().strip()\n                    filePointer.close()\n            elif isinstance(value, str) and value.startswith(\"__FILE__\"):\n                pass\n            else:\n                destinationDictionary[key] = value\n\n        return destinationDictionary", "response": "Deep merge dictionaries recursively."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncanceling a deferred and returns a new one with a timed out error.", "response": "def timeout_deferred(deferred, timeout, clock, deferred_description=None):\n    \"\"\"\n    Time out a deferred - schedule for it to be canceling it after ``timeout``\n    seconds from now, as per the clock.\n    If it gets timed out, it errbacks with a :class:`TimedOutError`, unless a\n    cancelable function is passed to the ``Deferred``'s initialization and it\n    callbacks or errbacks with something else when cancelled.\n    (see the documentation for :class:`twisted.internet.defer.Deferred`)\n    for more details.\n    :param Deferred deferred: Which deferred to time out (cancel)\n    :param int timeout: How long before timing out the deferred (in seconds)\n    :param str deferred_description: A description of the Deferred or the\n        Deferred's purpose - if not provided, defaults to the ``repr`` of the\n        Deferred.  To be passed to :class:`TimedOutError` for a pretty\n        Exception string.\n    :param IReactorTime clock: Clock to be used to schedule the timeout -\n        used for testing.\n    :return: ``None``\n    based on:  https://twistedmatrix.com/trac/ticket/990\n    \"\"\"\n    timed_out = [False]\n\n    def time_it_out():\n        timed_out[0] = True\n        deferred.cancel()\n\n    delayed_call = clock.callLater(timeout, time_it_out)\n\n    def convert_cancelled(f):\n        # if the failure is CancelledError, and we timed it out, convert it\n        # to a TimedOutError.  Otherwise, propagate it.\n        if timed_out[0]:\n            f.trap(defer.CancelledError)\n            raise TimedOutError(timeout, deferred_description)\n        return f\n\n    deferred.addErrback(convert_cancelled)\n\n    def cancel_timeout(result):\n        # stop the pending call to cancel the deferred if it's been fired\n        if delayed_call.active():\n            delayed_call.cancel()\n        return result\n\n    deferred.addBoth(cancel_timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a path to sys. path and remove it after the with block ends", "response": "def add_to_path(p):\n    '''\n        Adds a path to python paths and removes it after the 'with' block ends\n    '''\n    old_path = sys.path\n    if p not in sys.path:\n        sys.path = sys.path[:]\n        sys.path.insert(0, p)\n    try:\n        yield\n    finally:\n        sys.path = old_path"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_file_regex(root_dir,re_expression,return_abs_path = True,search_sub_directories = True):\n    '''\n        Finds all the files with the specified root directory with the name matching the regex expression.\n        Args    :\n            root_dir                : The root directory.\n            re_expression           : The regex expression.\n            return_abs_path         : If set to true, returns the absolute path of the files, else returns the name of the files.\n            search_sub_directories  : If set to true, searches sub directories recursivly.\n    '''\n\n    compiled        = re.compile(re_expression)\n    result          = []\n    for dirpath, dirnames, files in os.walk(root_dir) :\n        #Select files matching the expression\n        for file in files :\n            if compiled.match(file):\n                result.append(os.path.join(dirpath,file) if return_abs_path else file )\n\n        #Break if no sub-directories\n        if not search_sub_directories :\n            break\n    return result", "response": "Finds all the files with the specified root directory with the given regular expression."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_module(path):\n    '''\n        Imports the module specified by the path.\n        Args    :\n            path    : The path to the source file.\n    '''\n    with add_to_path(os.path.dirname(path)):\n        spec    = importlib.util.spec_from_file_location(os.path.basename(path).replace('.py',''), path)\n        module  = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)\n    return module", "response": "Imports the module specified by the path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_modules_with_decorators(path,decorator_module,decorator_name):\n    '''\n        Finds all the modules decorated with the specified decorator in the path, file or module specified.\n        Args    :\n            path      : All modules in the directory and its sub-directories will be scanned.\n            decorator_module    : Then full name of the module defining the decorator.\n            decorator_name      : The name of the decorator.\n    '''\n\n    modules_paths = []\n\n    #If a path to a module file\n    if path[-3:] == '.py':\n        modules_paths.append(path)\n    #If a directory, Get all the .py files\n    else :\n        modules_paths    += find_file_regex(path,'.*\\.py$')\n\n    #Return only modules using the decorator\n    return [module for module in modules_paths if is_module_has_decorated(module,decorator_module,decorator_name)]", "response": "Finds all the modules that have a decorator in the specified path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if a python module has a given decorator.", "response": "def is_module_has_decorated(path,decorator_module,decorator_name):\n    '''\n        Finds out if a python module uses a given decorator.\n        Args    :\n            loaded_module      : The loaded module to be scanned.\n            decorator_module    : Then name of the module defining the decorator.\n            decorator_name      : The name of the decorator.\n    '''\n    #Regular expression for finding decoration in source code\n    expression   = '(?:\\s*@({}\\.)?{}\\s*\\()'.format(decorator_module,decorator_name)\n    #Get the source\n    with open(path) as f:\n        module_source   = f.read()\n\n    #Find at least one use of the decorator\n    regex_result = re.compile(expression).findall(module_source)\n    return len(regex_result) > 0"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef nested_join(array, o_str= '{', c_str= '}'):\n    '''\n        Builds a string out of a given nested list.\n        Args    :\n            array   : An array retruned by pyparsing nestedExpr.\n            o_str   : Opening str.\n            c_str   : Closing str.\n    '''\n    result = ''\n    for x in array :\n        if type(x) == type([])  :\n            result  +=o_str+ nested_join(x)+ c_str\n        else                    :\n            result  +=x\n    return result", "response": "Builds a string out of a given nested list."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_decorated_names(path,decorator_module, decorator_name):\n    '''\n        Get the name of fumctions or methods decorated with the specified decorator.\n        If a method, the name will be as class_name.method_name.\n        Args :\n            path                : The path to the module.\n            decorator_module    : The name of the module defining the decorator.\n            decorator_name      : The name of the decorator.\n    '''\n    #Read the source\n    with open(path) as f:\n        module_source   = f.read()\n\n    expression          = '\\s*@(?:{}\\.)?{}[\\s\\S]+?(?:instance_creator\\s*=\\s*([\\w.]+)[\\s\\S]+?)?\\s*def\\s+(\\w+)\\s*\\(\\s*(self)?'.format(decorator_module, decorator_name)\n    methods             = re.compile(expression).findall(module_source)\n    decorateds          = [x[1] for x in methods]\n    instance_creators   = [x[0] if x[0] != '' else None for x in methods]\n    is_methods          = [x[2]!='' for x in methods]\n    result                      = []\n    class_name_expression       = '\\s*(?:class\\s+(\\w+)\\s*\\(.*\\:\\n[\\s\\S]+?)+?\\s+def\\s+{}\\s*\\('\n\n    #Get class names for methods\n    for i in range(len(decorateds)) :\n        decorated   = decorateds[i]\n        #If a method\n        if is_methods[i] :\n            #Get the class name\n            index           = decorateds[:i].count(decorated)\n            class_name      = re.compile(class_name_expression.format(decorated)).findall(module_source)[index]\n            original_name   = decorated\n            instance_creator= instance_creators[i]\n            if decorated[:2] =='__' :\n                decorated = '_'+ class_name+ decorated\n            result.append({'name': decorated, 'class_name': class_name, 'instance_creator': instance_creator})\n        else :\n            result.append({'name': decorated})\n    if DEBUG :\n        print(\n            decorateds          ,\n            instance_creators   ,\n            is_methods          ,\n            result\n            )\n    return result", "response": "Get the name of fumctions or methods decorated with the specified decorator."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the method from the specified path.", "response": "def load_method(path,method,class_name = None,instance_creator = None):\n    '''\n        Returns an instance of the method specified.\n        Args :\n            path            : The path to the module contianing the method or function.\n            method          : The name of the function.\n            class_name      : The name of the class if the funtion is a method.\n            instance_creator: The name of the method to return the class instance.\n    '''\n    #Load the module\n    module  = load_module(path)\n    if class_name :\n        #If a class, Create an instance\n        class_type  = getattr(module, class_name)\n        if instance_creator:\n            ic_rest     = instance_creator\n            nxt         = module\n            while ('.' in ic_rest)  :\n                nxt         = getattr(nxt    , instance_creator.split('.')[0])\n                ic_rest     = '.'.join(ic_rest.split('.')[1:])\n            instance = getattr(module, instance_creator)()\n        else :\n            instance = class_type()\n        return getattr(instance , method)\n    else :\n        return getattr(module   , method)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a funtion fully quaified name.", "response": "def fn_name(fn):\n    '''\n        Gets a funtion fully quaified name.\n        Args    :\n            fn      : The function.\n        Returns : The name of the function.\n    '''\n    expression = '(\\S+) (?:of|at)'\n    #Checks if the function is a mehtod and should have the self argument passed\n    is_method   = inspect.ismethod(fn)\n\n    #Builds the name of the method,module.class.method or module.method\n    name        = '{}.{}'.format(fn.__module__, re.compile(expression).findall(str(fn))[0])\n\n    return name,is_method"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the name of the types module", "response": "def getTypesModuleName(self):\n        '''return module name.\n        '''\n        assert self.wsdl is not None, 'initialize, call fromWSDL'\n        if self.types_module_name is not None:\n            return self.types_module_name\n\n        wsm = WriteServiceModule(self.wsdl)\n        return wsm.getTypesModuleName()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getServiceModuleName(self):\n        '''return module name.\n        '''\n        name = GetModuleBaseNameFromWSDL(self.wsdl)\n        if not name:\n            raise WsdlGeneratorError, 'could not determine a service name'\n        \n        if self.server_module_suffix is None:\n            return name\n        return '%s%s' %(name, self.server_module_suffix)", "response": "returns the name of the service module."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setUpImports(self):\n        '''set import statements\n        '''\n        i = self.imports\n        print >>i, 'from pyremotevbox.ZSI.schema import GED, GTD'\n        print >>i, 'from pyremotevbox.ZSI.TCcompound import ComplexType, Struct'\n\n        module = self.getTypesModuleName()\n        package = self.getTypesModulePath()\n        if package:\n            module = '%s.%s' %(package, module)\n            \n        print >>i, 'from %s import *' %(module)\n            \n        print >>i, 'from %s import %s' %(self.base_module_name, self.base_class_name)", "response": "set up the imports for this object"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setUpMethods(self, port):\n        '''set up all methods representing the port operations.\n        Parameters:\n            port -- Port that defines the operations.\n        '''\n        assert isinstance(port, WSDLTools.Port), \\\n            'expecting WSDLTools.Port not: ' %type(port)\n\n        sd = self._services.get(port.getService().name)\n        assert sd is not None, 'failed to initialize.'\n\n        binding = port.getBinding()\n        portType = port.getPortType()\n        action_in = ''\n        for bop in binding.operations:\n            try:\n                op = portType.operations[bop.name]\n            except KeyError, ex:\n                raise WsdlGeneratorError,\\\n                    'Port(%s) PortType(%s) missing operation(%s) defined in Binding(%s)' \\\n                    %(port.name,portType.name,bop.name,binding.name)\n\n            for ext in bop.extensions:\n                 if isinstance(ext, WSDLTools.SoapOperationBinding):\n                     action_in = ext.soapAction\n                     break\n            else:\n                warnings.warn('Port(%s) operation(%s) defined in Binding(%s) missing soapAction' \\\n                    %(port.name,op.name,binding.name)\n                )\n\n            msgin = op.getInputMessage()\n            msgin_name = TextProtect(msgin.name)\n            method_name = self.getMethodName(op.name)\n\n            m = sd.newMethod()\n            print >>m, '%sdef %s(self, ps, **kw):' %(self.getIndent(level=1), method_name)\n            if msgin is not None:\n                print >>m, '%srequest = ps.Parse(%s.typecode)' %(self.getIndent(level=2), msgin_name)\n            else:\n                print >>m, '%s# NO input' %self.getIndent(level=2)\n\n            msgout = op.getOutputMessage()\n            if msgout is not None:\n                msgout_name = TextProtect(msgout.name)\n                print >>m, '%sreturn request,%s()' %(self.getIndent(level=2), msgout_name)\n            else:\n                print >>m, '%s# NO output' % self.getIndent(level=2)\n                print >>m, '%sreturn request,None' % self.getIndent(level=2)\n\n            print >>m, ''\n            print >>m, '%ssoapAction[\\'%s\\'] = \\'%s\\'' %(self.getIndent(level=1), action_in, method_name)\n            print >>m, '%sroot[(%s.typecode.nspname,%s.typecode.pname)] = \\'%s\\'' \\\n                     %(self.getIndent(level=1), msgin_name, msgin_name, method_name)\n\n        return", "response": "set up all methods representing the port operations."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite out to file descriptor", "response": "def write(self, fd=sys.stdout):\n        '''write out to file descriptor, \n        should not need to override.\n        '''\n        print >>fd, self.header.getvalue()\n        print >>fd, self.imports.getvalue()\n        \n        print >>fd, '# Messages ',\n        for m in self.messages:\n            print >>fd, m\n        \n        print >>fd, ''\n        print >>fd, ''\n        print >>fd, '# Service Skeletons'\n        for k,v in self._services.items():\n            print >>fd, v.classdef.getvalue()\n            print >>fd, v.initdef.getvalue()\n            for s in v.methods:\n                print >>fd, s.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a tuple containing the body of a method.", "response": "def createMethodBody(msgInName, msgOutName, **kw):\n        '''return a tuple of strings containing the body of a method.\n        msgInName -- None or a str\n        msgOutName --  None or a str\n        '''\n        body = []\n        if msgInName is not None:\n            body.append('request = ps.Parse(%s.typecode)' %msgInName)\n            \n        if msgOutName is not None:\n            body.append('return request,%s()' %msgOutName)\n        else: \n            body.append('return request,None')\n            \n        return tuple(body)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setUpClassDef(self, service):\n        '''use soapAction dict for WS-Action input, setup wsAction\n        dict for grabbing WS-Action output values.\n        '''\n        assert isinstance(service, WSDLTools.Service), \\\n            'expecting WSDLTools.Service instance'\n\n        s = self._services[service.name].classdef\n        print >>s, 'class %s(%s):' %(self.getClassName(service.name), self.base_class_name)\n        print >>s, '%ssoapAction = {}' % self.getIndent(level=1)\n        print >>s, '%swsAction = {}' % self.getIndent(level=1)\n        print >>s, '%sroot = {}' % self.getIndent(level=1)", "response": "use soapAction dict for WS - Action input setup wsAction\n        dict for grabbing WS - Action output values."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting up all methods representing the port operations.", "response": "def setUpMethods(self, port):\n        '''set up all methods representing the port operations.\n        Parameters:\n            port -- Port that defines the operations.\n        '''\n        assert isinstance(port, WSDLTools.Port), \\\n            'expecting WSDLTools.Port not: ' %type(port)\n\n        binding = port.getBinding()\n        portType = port.getPortType()\n        service = port.getService()\n        s = self._services[service.name]\n        for bop in binding.operations:\n            try:\n                op = portType.operations[bop.name]\n            except KeyError, ex:\n                raise WsdlGeneratorError,\\\n                    'Port(%s) PortType(%s) missing operation(%s) defined in Binding(%s)' \\\n                    %(port.name, portType.name, op.name, binding.name)\n\n            soap_action = wsaction_in = wsaction_out = None\n            if op.input is not None:\n                wsaction_in = op.getInputAction()\n            if op.output is not None:\n                wsaction_out = op.getOutputAction()\n\n            for ext in bop.extensions:\n                if isinstance(ext, WSDLTools.SoapOperationBinding) is False: continue\n                soap_action = ext.soapAction\n                if not soap_action: break\n                if wsaction_in is None: break\n                if wsaction_in == soap_action: break\n                if self.strict is False:\n                    warnings.warn(\\\n                        'Port(%s) operation(%s) in Binding(%s) soapAction(%s) != WS-Action(%s)' \\\n                         %(port.name, op.name, binding.name, soap_action, wsaction_in),\n                    )\n                    break\n                raise WsdlGeneratorError,\\\n                    'Port(%s) operation(%s) in Binding(%s) soapAction(%s) MUST match WS-Action(%s)' \\\n                     %(port.name, op.name, binding.name, soap_action, wsaction_in)\n\n            method_name = self.getMethodName(op.name)\n\n            m = s.newMethod()\n            print >>m, '%sdef %s(self, ps, address):' %(self.getIndent(level=1), method_name)\n            \n            msgin_name = msgout_name = None\n            msgin,msgout = op.getInputMessage(),op.getOutputMessage()\n            if msgin is not None: \n                msgin_name = TextProtect(msgin.name)\n            if msgout is not None: \n                msgout_name = TextProtect(msgout.name)\n        \n            indent = self.getIndent(level=2)\n            for l in self.createMethodBody(msgin_name, msgout_name):\n                print >>m, indent + l\n\n            print >>m, ''\n            print >>m, '%ssoapAction[\\'%s\\'] = \\'%s\\'' %(self.getIndent(level=1), wsaction_in, method_name)\n            print >>m, '%swsAction[\\'%s\\'] = \\'%s\\'' %(self.getIndent(level=1), method_name, wsaction_out)\n            print >>m, '%sroot[(%s.typecode.nspname,%s.typecode.pname)] = \\'%s\\'' \\\n                     %(self.getIndent(level=1), msgin_name, msgin_name, method_name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nimport each plugin in this package and creates a repo file from it", "response": "def createRepoObjects():\n\t\"\"\"Imports each 'plugin' in this package and creates a repo file from it\"\"\"\n\trepositories = {}\n\trepodir = os.path.join(getScriptLocation())\n\tfor importer, name, ispkg in pkgutil.iter_modules([repodir]):\n\t\tmodule = importer.find_module(name).load_module(name)\n\t\trepo_name = module.name\n\t\tif module.enabled:\n\t\t\trepositories[repo_name] = module.getRepository()\n\t\n\treturn repositories"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef credibleregions(self, probs):\n\n        return [brentq(lambda l:  self.pdf[self.pdf > l].sum() - p, 0.0, 1.0) for p in probs]", "response": "Calculates the credible regions."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninvokes callback that should return a ( request response ) tuple. represents the SOAP request and response respectively.", "response": "def processRequest(cls, ps, **kw):\n        \"\"\"invokes callback that should return a (request,response) tuple.\n        representing the SOAP request and response respectively.\n        ps -- ParsedSoap instance representing HTTP Body.\n        request -- twisted.web.server.Request\n        \"\"\"\n        resource = kw['resource']\n        request = kw['request']\n        method =  getattr(resource, 'soap_%s' %\n                           _get_element_nsuri_name(ps.body_root)[-1])\n                                              \n        try:\n            req,rsp = method(ps, request=request)\n        except Exception, ex:\n            raise\n        \n        return rsp"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntake a labeled set of feature collections positive and negative and returns a list of tuples ordered by strength.", "response": "def extract(positive_fcs, negative_fcs, features=None):\n    '''Takes a labeled set of feature collections (positive and negative)\n       and the features wanted. And trains a Naive Bayes classifier on\n       the underlying keys of the set of selected features features.\n       If no features are selected, all are used.\n\n       Returns two list of (keywords, strength) tuples ordered by strength. The\n       first are feature keys that were predictive of the positive\n       label and the second are the feature keys are were predictive\n       of the negative label.\n\n    ``*_fcs`` is the list of feature collections, positive label and\n            negative label respectively.\n\n    ``features`` designates which specific feature gets vectorized the\n               other features are ignored.\n\n    '''\n\n    # Vector of labels\n    labels = np.array([1] * len(positive_fcs) + [0] * len(negative_fcs))\n\n    # Used to convert the feature collection keys into a sklearn\n    # compatible format\n    v = DictVectorizer(sparse=False)\n\n    D = list()\n    for fc in (positive_fcs + negative_fcs):\n        feat = StringCounter()\n\n        if not fc:\n            logger.warn('how did we get an empty fc? %r', fc)\n\n        else:\n            # The features used to pull the keys for the classifier\n            for f in features:\n                feat += fc[f]\n\n        D.append(feat)\n\n    # Convert the list of Counters into an sklearn compatible format\n    X = v.fit_transform(D)\n\n    # Fit the sklearn Bernoulli Naive Bayes classifer\n    clf = BernoulliNB()\n    clf.fit(X, labels)\n\n    # Extract the learned features that are predictive of the positive\n    # and negative class\n    positive_keywords = v.inverse_transform(clf.feature_log_prob_[1])[0]\n    negative_keywords = v.inverse_transform(clf.feature_log_prob_[0])[0]\n\n    pos_words = Counter(positive_keywords)\n    neg_words = Counter(negative_keywords)\n\n    ## make a list ordered by their weight\n    pos_ordered = sorted(pos_words.items(),\n                            key=operator.itemgetter(1), reverse=True)\n    neg_ordered = sorted(neg_words.items(),\n                            key=operator.itemgetter(1), reverse=True)\n\n    return pos_ordered, neg_ordered"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles decoding of the YAML data.", "response": "def decode(data):\n    \"\"\"\n    Handles decoding of the YAML `data`.\n\n    Args:\n        data (str): Data which will be decoded.\n\n    Returns:\n        dict: Dictionary with decoded data.\n    \"\"\"\n    decoded = None\n    try:\n        decoded = yaml.load(data)\n    except Exception, e:\n        e = e.message if e.message else str(e)\n        raise MetaParsingException(\"Can't parse your YAML data: %s\" % e)\n\n    decoded = validator.check_structure(decoded)\n\n    return decoded"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a new datetime. datetime object with values that represent a start of a day.", "response": "def start_of_day(val):\n    \"\"\"\n    Return a new datetime.datetime object with values that represent\n    a start of a day.\n    :param val: Date to ...\n    :type val: datetime.datetime | datetime.date\n    :rtype: datetime.datetime\n    \"\"\"\n    if type(val) == date:\n        val = datetime.fromordinal(val.toordinal())\n    return val.replace(hour=0, minute=0, second=0, microsecond=0)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a new datetime. datetime object with values that represent a end of a day.", "response": "def end_of_day(val):\n    \"\"\"\n    Return a new datetime.datetime object with values that represent\n    a end of a day.\n    :param val: Date to ...\n    :type val: datetime.datetime | datetime.date\n    :rtype: datetime.datetime\n    \"\"\"\n    if type(val) == date:\n        val = datetime.fromordinal(val.toordinal())\n    return start_of_day(val) + timedelta(days=1, microseconds=-1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start_of_month(val):\n    if type(val) == date:\n        val = datetime.fromordinal(val.toordinal())\n    return start_of_day(val).replace(day=1)", "response": "Returns a new datetime. datetime object with values that represent\n    a start of a month."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef end_of_month(val):\n    if type(val) == date:\n        val = datetime.fromordinal(val.toordinal())\n    if val.month == 12:\n        return start_of_month(val).replace(year=val.year + 1, month=1) \\\n               - timedelta(microseconds=1)\n    else:\n        return start_of_month(val).replace(month=val.month + 1) \\\n               - timedelta(microseconds=1)", "response": "Returns a new datetime. datetime object with values that represent\n    a end of a month."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset next week day in a node.", "response": "def set_next_week_day(val, week_day, iso=False):\n    \"\"\"\n    Set week day.\n    New date will be greater or equal than input date.\n    :param val: datetime or date\n    :type val: datetime.datetime | datetime.date\n    :param week_day: Week day to set\n    :type week_day: int\n    :param iso: week_day in ISO format, or not\n    :type iso: bool\n    :return: datetime.datetime | datetime.date\n    \"\"\"\n    return _set_week_day(val, week_day,\n                         val.isoweekday() if iso else val.weekday(), sign=1)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nusing this decorator to override an attribute that is specified in blessings sugar dict with your own function that adds some additional additional functionality.", "response": "def _override_sugar(func):\n    '''Use this decorator to override an attribute that is specified in\n    blessings' sugar dict with your own function that adds some additional\n    functionality.\n    '''\n    attr_name = func.__name__\n    @property\n    @wraps(func)\n    def func_that_uses_terminal_sugar(self):\n        func(self)\n        return self.__getattr__(attr_name)\n    return func_that_uses_terminal_sugar"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef draw_lines(self, lines, x=0, y=0):\n        '''Write a collection of lines to the terminal stream at the given\n        location. The lines are written as one 'block' (i.e. each new line\n        starts one line down from the previous, but each starts *at the given x\n        coordinate*).\n\n        :parameter lines: An iterable of strings that should be written to the\n            terminal. They need not all be the same length, but should ideally\n            not extend beyond the right hand side of the terminal screen,\n            otherwise strange linebreaking/overwriting may occur.\n        :parameter x: the column of the terminal display at which the block of\n            lines begins.\n        :parameter y: the row of the terminal display at which the block of\n            lines begins (from top).\n        '''\n        for y, line in enumerate(lines, start=y):\n            self.stream.write(self.move(y, x))\n            self.stream.write(line)", "response": "Write a collection of lines to the terminal stream at the given x y location."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nraise ShCmdError if the return_code is not 0 otherwise return self", "response": "def raise_for_error(self):\n        \"\"\"\n        raise `ShCmdError` if the proc's return_code is not 0\n        otherwise return self\n\n        ..Usage::\n\n            >>> proc = shcmd.run(\"ls\").raise_for_error()\n            >>> proc.return_code == 0\n            True\n\n        \"\"\"\n        if self.ok:\n            return self\n        tip = \"running {0} @<{1}> error, return code {2}\".format(\n            \" \".join(self.cmd), self.cwd, self.return_code\n        )\n        logger.error(\"{0}\\nstdout:{1}\\nstderr:{2}\\n\".format(\n            tip, self._stdout.decode(\"utf8\"), self._stderr.decode(\"utf8\")\n        ))\n        raise ShCmdError(self)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _stream(self):\n        timer = None\n        try:\n            proc = subprocess.Popen(\n                self.cmd, cwd=self.cwd, env=self.env,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE\n            )\n            timer = threading.Timer(\n                self.timeout,\n                kill_proc, [proc, self.cmd, time.time()]\n            )\n            timer.start()\n            yield proc\n        finally:\n            if timer is not None:\n                timer.cancel()", "response": "execute subprocess with timeout"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nyields stdout text line by line.", "response": "def iter_lines(self, warn_only=False):\n        \"\"\"yields stdout text, line by line.\"\"\"\n        remain = \"\"\n        for data in self.iter_content(LINE_CHUNK_SIZE, warn_only=True):\n            line_break_found = data[-1] in (b\"\\n\", b\"\\r\")\n            lines = data.decode(self.codec).splitlines()\n            lines[0] = remain + lines[0]\n            if not line_break_found:\n                remain = lines.pop()\n            for line in lines:\n                yield line\n        if remain:\n            yield remain\n\n        self._state = FINISHED\n        if not warn_only:\n            self.raise_for_error()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef iter_content(self, chunk_size=1, warn_only=False):\n        self._state = \"not finished\"\n        if self.return_code is not None:\n            stdout = io.BytesIO(self._stdout)\n            data = stdout.read(chunk_size)\n            while data:\n                yield data\n                data = stdout.read(chunk_size)\n        else:\n            data = b''\n            started_at = time.time()\n            with self._stream() as proc:\n                while proc.poll() is None:\n                    chunk = proc.stdout.read(chunk_size)\n                    if not chunk:\n                        continue\n                    yield chunk\n                    data += chunk\n\n                if proc.returncode == -9:\n                    elapsed = time.time() - started_at\n                    self._state = \"timeouted\"\n                    raise subprocess.TimeoutExpired(proc.args, elapsed)\n\n                chunk = proc.stdout.read(chunk_size)\n                while chunk:\n                    yield chunk\n                    data += chunk\n                    chunk = proc.stdout.read(chunk_size)\n\n            self._return_code = proc.returncode\n            self._stderr = proc.stderr.read()\n            self._stdout = data\n\n            self._state = FINISHED\n            if not warn_only:\n                self.raise_for_error()", "response": "yields the content of the log file"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef metar(trans: MetarTrans) -> str:\n    summary = []\n    if trans.wind:\n        summary.append('Winds ' + trans.wind)\n    if trans.visibility:\n        summary.append('Vis ' + trans.visibility[:trans.visibility.find(' (')].lower())\n    if trans.temperature:\n        summary.append('Temp ' + trans.temperature[:trans.temperature.find(' (')])\n    if trans.dewpoint:\n        summary.append('Dew ' + trans.dewpoint[:trans.dewpoint.find(' (')])\n    if trans.altimeter:\n        summary.append('Alt ' + trans.altimeter[:trans.altimeter.find(' (')])\n    if trans.other:\n        summary.append(trans.other)\n    if trans.clouds:\n        summary.append(trans.clouds.replace(' - Reported AGL', ''))\n    return ', '.join(summary)", "response": "Returns a string that represents the metar translation"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef taf(trans: TafLineTrans) -> str:\n    summary = []\n    if trans.wind:\n        summary.append('Winds ' + trans.wind)\n    if trans.visibility:\n        summary.append('Vis ' + trans.visibility[:trans.visibility.find(' (')].lower())\n    if trans.altimeter:\n        summary.append('Alt ' + trans.altimeter[:trans.altimeter.find(' (')])\n    if trans.other:\n        summary.append(trans.other)\n    if trans.clouds:\n        summary.append(trans.clouds.replace(' - Reported AGL', ''))\n    if trans.wind_shear:\n        summary.append(trans.wind_shear)\n    if trans.turbulance:\n        summary.append(trans.turbulance)\n    if trans.icing:\n        summary.append(trans.icing)\n    return ', '.join(summary)", "response": "Returns a string that represents the TAF translation"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef findBestDistribution(data, disttype='continuous'):\n\n    if disttype != 'continuous':\n        raise NotImplemented()\n\n    distributions = [st.alpha, st.anglit, st.arcsine,\n                     st.beta, st.betaprime, st.bradford,\n                     st.burr, st.cauchy, st.chi,\n                     st.chi2, st.cosine, st.dgamma,\n                     st.dweibull, st.erlang, st.expon,\n                     st.exponweib, st.exponpow, st.f,\n                     st.fatiguelife,\n                     st.fisk, st.foldcauchy, st.foldnorm,\n                     st.frechet_r, st.frechet_l, st.genlogistic, st.genpareto,\n                     st.genexpon, st.genextreme, st.gausshyper,\n                     st.gamma, st.gengamma, st.genhalflogistic,\n                     st.gilbrat, st.gompertz, st.gumbel_r,\n                     st.gumbel_l, st.halfcauchy, st.halflogistic,\n                     st.halfnorm, st.hypsecant, st.invgamma,\n                     st.invgauss, st.invweibull, st.johnsonsb,\n                     st.johnsonsu, st.ksone, st.kstwobign,\n                     st.laplace, st.logistic, st.loggamma,\n                     st.loglaplace, st.lognorm, st.lomax,\n                     st.maxwell, st.mielke, st.nakagami,\n                     st.ncx2, st.ncf, st.nct,\n                     st.norm, st.pareto, st.pearson3,\n                     st.powerlaw, st.powerlognorm,\n                     st.powernorm, st.rdist, st.reciprocal,\n                     st.rayleigh, st.rice, st.recipinvgauss,\n                     st.semicircular, st.t, st.triang,\n                     st.truncexpon, st.truncnorm, st.tukeylambda,\n                     st.uniform, st.vonmises, st.wald,\n                     st.weibull_min, st.weibull_max, st.wrapcauchy]\n\n    mles = []\n    pars_l = []\n    valid_dist = []\n\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore')\n\n        for distribution in distributions:\n            pars = distribution.fit(data)\n            # maximum-likelihood estimation:\n            mle = distribution.nnlf(pars, data)\n            if np.isfinite(mle):\n                valid_dist.append(distribution)\n                mles.append(abs(mle))\n                pars_l.append(pars)\n\n    best_fit = sorted(zip(valid_dist, mles, pars_l), key=lambda d: d[1])[0]\n    print(\n        'Best fit reached using {}, MLE value: {}'.format(\n            best_fit[0].name,\n            best_fit[1]))\n    print(pars_l)\n    return best_fit[0], best_fit[2]", "response": "find best statistical distribution in a sequence of continuous distributions"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef transform(request, syntax_processor_name=None, var_name=\"text\"):\n    if request.method != 'POST':\n        return HttpResponseNotAllowed(\"Only POST allowed\")\n\n    source = request.POST.get(var_name)\n    if not source:\n        return HttpResponse('')\n\n    processor = TextProcessor.objects.get(name=syntax_processor_name or getattr(settings, \"DEFAULT_MARKUP\", \"markdown\"))\n    output = processor.convert(source)\n\n    try:\n        t = template.Template(output, name='markup_preview')\n        output = t.render(template.Context({'MEDIA_URL' : settings.MEDIA_URL}))\n    except template.TemplateSyntaxError, e:\n        log.warning('Error in preview rendering: %s' % e)\n        output = '<h3 style=\"color:red\">%s</h3><p>%s</p>' % (ugettext('You have an errors in source text!'), e)\n\n    return HttpResponse(output)", "response": "Returns rendered HTML for source text"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rtype_to_model(rtype):\n\n    models = goldman.config.MODELS\n    for model in models:\n        if rtype.lower() == model.RTYPE.lower():\n            return model\n    raise ValueError('%s resource type not registered' % rtype)", "response": "Return a model class object given a string resource type"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck the requirements file against the installed packages in the currentl environment.", "response": "def check_requirements(requirement_files, strict=False, error_on_extras=False, verbose=False,\n                       venv=None, do_colour=False):\n    \"\"\"\n    Given a list of requirements files, checks them against the installed\n    packages in the currentl environment. If any are missing, or do not fit\n    within the version bounds, exits with a code of 1 and outputs information\n    about the missing dependency.\n    \"\"\"\n    colour = TextColours(do_colour)\n\n    version_re = re.compile(r'^([^<>=\\s#]+)\\s*(>=|>|<|<=|==|===)?\\s*([^<>=\\s#]+)?(?:\\s*#.*)?$')\n\n    def parse_package_line(line):\n        try:\n            if line.startswith('-e'):\n                return parse_checkout_line(line)\n            package, compare, version = version_re.split(line)[1:-1]\n        except ValueError:\n            raise ValueError(\"Unknown package line format: %r\" % line)\n        return (package, compare or None, parse_version(version) if version else None, line)\n\n    def parse_checkout_line(whole_line):\n        \"\"\"\n        parse a line that starts with '-e'\n\n        e.g.,\n        -e git://github.com/jcrocholl/pep8.git@bb20999aefc394fb826371764146bf61d8e572e2#egg=pep8-dev\n        \"\"\"\n        # Snip off the '-e' and any leading whitespace\n        line = whole_line[2:].lstrip()\n\n        # Check if there is a revision specified\n        if '@' in line:\n            url, last_bit = line.rsplit('@', 1)\n            rev, eggname = last_bit.split('#', 1)\n            return (url, '==', rev, line)\n        else:\n            (url, eggname) = line.split('#')\n            return (url, None, None, line)\n\n    def is_requirements_line(line):\n        \"\"\"\n        line is a valid requirement in requirements file or pip freeze output\n        \"\"\"\n        if not line:\n            return False\n        if line.startswith('#'):\n            return False\n        if line.endswith(' # optional'):\n            return False\n        if line.startswith('-e'):\n            return True\n        if line.startswith('-'):\n            return False\n        if line.startswith('http://') or line.startswith('https://'):\n            return False\n        return True\n\n    def valid_version(version, compare, r_version):\n        if not all([compare, version]):\n            return True\n        if compare in ('==', '==='):\n            return version == r_version\n        elif compare == '<=':\n            return version <= r_version\n        elif compare == '>=':\n            return version >= r_version\n        elif compare == '<':\n            return version < r_version\n        elif compare == '>':\n            return version > r_version\n        raise ValueError(\"Unknown comparison operator: %r\" % compare)\n\n    frozen_reqs = []\n    unknown_reqs = set()\n    listed_reqs = []\n    args = 'pip freeze'\n    if venv is not None:\n        args = venv + \"/bin/\" + args\n    freeze = Popen([args], stdout=PIPE, shell=True)\n    for line in freeze.communicate()[0].splitlines():\n        line = line.strip()\n        if not is_requirements_line(line):\n            unknown_reqs.add(line)\n            continue\n        frozen_reqs.append(parse_package_line(line))\n\n    # Requirements files may include other requirements files;\n    # if so, add to list.\n    included_files = []\n    for file in requirement_files:\n        path = os.path.dirname(file)\n        args = \"grep '^\\-r' %s\" % file\n        grep = Popen([args], stdout=PIPE, shell=True)\n        for line in grep.communicate()[0].splitlines():\n            included_files.append(os.path.join(path, line[2:].lstrip()))\n    requirement_files.extend(included_files)\n\n    for fname in requirement_files:\n        with open(fname) as fp:\n            for line in fp:\n                line = line.strip()\n                if not is_requirements_line(line):\n                    continue\n\n                listed_reqs.append(parse_package_line(line))\n\n    unknown_reqs.update(set(r[0] for r in frozen_reqs).difference(set(r[0] for r in listed_reqs)))\n\n    errors = []\n\n    for r_package, r_compare, r_version, r_line in listed_reqs:\n        r_package_lower = r_package.lower()\n        found = False\n\n        for package, _, version, line in frozen_reqs:\n            if package.lower() == r_package_lower:\n                found = True\n                if strict and package != r_package:\n                    unknown_reqs.remove(package)\n                    errors.append(\n                        \"%sUnexpected capitalization found: %r is required but %r is installed.%s\"\n                        % (colour.WARNING, r_package, package, colour.ENDC)\n                    )\n                elif valid_version(version, r_compare, r_version):\n                    unknown_reqs.discard(package)\n                    if verbose:\n                        print(\"%sRequirement is installed correctly: %s%s\"\n                              % (colour.OKGREEN, r_line, colour.ENDC))\n                else:\n                    errors.append(\n                        \"%sUnexpected version of %r found: %r is required but %r is installed.%s\"\n                        % (colour.WARNING, r_package, r_line, line, colour.ENDC)\n                    )\n                break\n\n        if not found:\n            errors.append(\"%sRequirement %r not installed in virtualenv.%s\"\n                          % (colour.FAIL, r_package, colour.ENDC))\n\n    code = 0\n    if unknown_reqs:\n        print(\"\\nFor debugging purposes, the following packages are installed but not in the requirements file(s):\")\n        unknown_reqs_with_versions = []\n        for unknown_req in unknown_reqs:\n            for req in frozen_reqs:\n                if unknown_req == req[0]:\n                    unknown_reqs_with_versions.append(req[3])\n                    break\n        print(\"%s%s%s\\n\" % (colour.WARNING,\n                            \"\\n\".join(sorted(unknown_reqs_with_versions)),\n                            colour.ENDC))\n        if error_on_extras:\n            code = 2\n\n    if errors:\n        print(\"Errors found:\")\n        print('\\n'.join(errors))\n        print(\"You must correct your environment before committing (and running tests).\\n\")\n        code = 1\n\n    if not errors and not unknown_reqs:\n        print(\"%sNo errors found; all packages accounted for!%s\"\n              % (colour.OKGREEN, colour.ENDC))\n\n    return code"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite a unicode string txt to file path.", "response": "def spit(path, txt, encoding='UTF-8', append=False):\n    \"\"\"\n    Write a unicode string `txt` to file `path`.\n\n    By default encoded as UTF-8 and truncates the file prior to writing\n\n    Parameters\n    ----------\n\n    path : str\n        File path to file on disk\n    txt : unicode\n        Text content to write to file\n    encoding : str, default `UTF-8`, optional\n        Encoding of the file\n    append : Boolean, default False\n        Append to file instead of truncating before writing\n\n    Returns\n    -------\n\n    The txt written to the file as a unicode string\n    \"\"\"\n    mode = 'a' if append else 'w'\n    with io.open(path, mode, encoding=encoding) as f:\n        f.write(txt)\n        return txt"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads file path and returns the entire contents as a unicode string", "response": "def slurp(path, encoding='UTF-8'):\n    \"\"\"\n    Reads file `path` and returns the entire contents as a unicode string\n\n    By default assumes the file is encoded as UTF-8\n\n    Parameters\n    ----------\n    path : str\n        File path to file on disk\n    encoding : str, default `UTF-8`, optional\n        Encoding of the file\n\n    Returns\n    -------\n\n    The txt read from the file as a unicode string\n    \"\"\"\n    with io.open(path, 'r', encoding=encoding) as f:\n        return f.read()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef download_url(url, destination):\n    from settings import VALID_IMAGE_EXTENSIONS\n    base_name, ext = os.path.splitext(url)\n    ext = ext.lstrip('.')\n\n    if ext not in VALID_IMAGE_EXTENSIONS:\n        raise Exception(\"Invalid image extension\")\n\n    base_path, filename = os.path.split(destination)\n    os.makedirs(base_path)\n    urllib.urlretrieve(url, destination)", "response": "Download an external URL to the destination"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a SHA1 hash based on the KEY and the action string", "response": "def create_securityhash(action_tuples):\n    \"\"\"\n    Create a SHA1 hash based on the KEY and action string\n    \"\"\"\n    from settings import SECRET_KEY\n\n    action_string = \"\".join([\"_%s%s\" % a for a in action_tuples])\n    security_hash = sha1(action_string + SECRET_KEY).hexdigest()\n    return security_hash"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nresolves the path according to the aliases in the request.", "response": "def resolve_request_path(requested_uri):\n    \"\"\"\n    Check for any aliases and alter the path accordingly.\n\n    Returns resolved_uri\n    \"\"\"\n    from settings import PATH_ALIASES\n\n    for key, val in PATH_ALIASES.items():\n        if re.match(key, requested_uri):\n            return re.sub(key, val, requested_uri)\n    return requested_uri"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef process_url(url, server_name=\"\", document_root=None, check_security=True):\n    from .network import Http404\n    from settings import (BASE_PATH, ORIG_BASE_PATH, USE_VHOSTS, VHOST_DOC_BASE, EXTERNAL_PREFIX)\n\n    try:\n        request_uri, security_hash = url.split(\"?\", 1)\n    except ValueError:\n        request_uri, security_hash = url, \"\"\n\n    external_prefix = EXTERNAL_PREFIX\n    is_external = request_uri.startswith(external_prefix)\n    resolved_uri = resolve_request_path(request_uri)\n    resolved_uri = resolved_uri.lstrip(\"/\")\n    resolved_uri = urllib.unquote(resolved_uri)\n    if is_external:\n        external_url = urllib.unquote(resolved_uri.replace(external_prefix.lstrip(\"/\"), ''))\n        resolved_uri = resolved_uri.replace(\"http://\", '').replace('https://', '')\n    else:\n        external_url = ''\n\n    base_path = document_root or BASE_PATH\n    orig_base_path = ORIG_BASE_PATH or base_path\n\n    if USE_VHOSTS:\n        if not os.path.exists(os.path.join(BASE_PATH, server_name)):\n            raise Http404(\"Bad server: %s\" % server_name)\n        parts = (base_path, server_name, VHOST_DOC_BASE,\n                 resolved_uri)\n        requested_path = os.path.join(*parts)\n    else:\n        path = os.path.join(base_path, resolved_uri)\n        if base_path.startswith('s3://'):\n            requested_path = path\n        else:\n            requested_path = os.path.abspath(path)\n\n    if not requested_path.startswith(base_path):\n        # Apparently, there was an attempt to put some directory traversal\n        # hacks into the path. (../../../vulnerable_file.exe)\n        raise Http404(\"Unknown file path.\")\n\n    parent_dir, requested_file = os.path.split(resolved_uri)\n    base_filename, ext = os.path.splitext(requested_file)\n\n    base_file_name, action_tuples = parse_action_tuples(requested_file)\n\n    if USE_VHOSTS:\n        original_file = os.path.join(orig_base_path, server_name, parent_dir, base_file_name + ext)\n    else:\n        original_file = os.path.join(orig_base_path, parent_dir, base_file_name + ext)\n\n    base_uri = os.path.dirname(resolved_uri)\n    original_uri = urlparse.urljoin(base_uri, base_filename + ext)\n\n    if original_file.startswith(u's3://'):\n        from filesystem import s3\n        original_is_missing = not s3.file_exists(original_file)\n    else:\n        original_is_missing = not os.path.exists(original_file)\n\n    if original_is_missing and is_external:\n        try:\n            download_url(external_url, original_file)\n        except Exception as e:\n            msg = \"Error downloading external URL: %s\" % e\n            raise Http404(msg)\n    elif original_is_missing:\n        msg = \"Original file does not exist. %r %r\" % (url, original_file, )\n        raise Http404(msg)\n    if check_security and action_tuples and not is_valid_security(action_tuples, security_hash):\n        raise Http404(\"Invalid security token.\")\n    output = {\n        'actions': action_tuples,\n        'parent_dir': parent_dir,\n        'ext': ext,\n        'base_filename': base_filename,\n        'security_hash': security_hash,\n        'requested_file': requested_path,\n        'original_file': original_file,\n        'orignial_uri': original_uri,\n        'is_external': is_external,\n        'external_url': external_url,\n    }\n    logger.debug(\"Processed {0} into {1}\".format(url, str(output)))\n    return output", "response": "Process a URL and return a dictionary of fields."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_cached_files(url, server_name=\"\", document_root=None):\n    import glob\n    url_info = process_url(url, server_name, document_root, check_security=False)\n\n    # get path to cache directory with basename of file (no extension)\n    filedir = os.path.dirname(url_info['requested_file'])\n    fileglob = '{0}*{1}'.format(url_info['base_filename'], url_info['ext'])\n    return glob.glob(os.path.join(filedir, fileglob))", "response": "Given a URL returns a list of paths of all cached variations of that file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset up the live server and databases and loops over handling http requests.", "response": "def run(self):\n        \"\"\"\n        Sets up the live server and databases, and then loops over handling\n        http requests.\n        \"\"\"\n        server_address = (self.host, self.port)\n        threading = True\n        if threading:\n            httpd_cls = type('WSGIServer', (ThreadingMixIn, WSGIServer), {})\n        else:\n            httpd_cls = WSGIServer\n        self.httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=False)\n        wsgi_handler = get_internal_wsgi_application()\n        self.httpd.set_app(wsgi_handler)\n        self.is_ready.set()\n        self.httpd.serve_forever()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef visit(self, node):\n\n        try:\n            # Get the \"visit_%s\" method, using the lower case version of the rule.\n            method = getattr(self, 'visit_%s' % node.expr_name.lower())\n        except AttributeError:\n            # If the method is not defined, we do nothing for this node.\n            return\n\n        # Below is untouched code from the original ``visit`` method.\n\n        # Call that method, and show where in the tree it failed if it blows up.\n        try:\n            return method(node, [self.visit(n) for n in node])\n        except (VisitationError, UndefinedLabel):\n            # Don't catch and re-wrap already-wrapped exceptions.\n            raise\n        except self.unwrapped_exceptions:\n            raise\n        except Exception:\n            # Catch any exception, and tack on a parse tree so it's easier to\n            # see where it went wrong.\n            exc_class, exc, trace = sys.exc_info()\n            raise VisitationError(exc, exc_class, node).with_traceback(trace)", "response": "Rewrite original method to use lower - case method and not generic function."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an operator as a string. Currently only \"=\" and \":\"", "response": "def visit_oper(self, node, _):\n        \"\"\"Return an operator as a string. Currently only \"=\" and \":\" (both synonyms)\n\n        Arguments\n        ---------\n        node : parsimonious.nodes.Node.\n        _ (children) : list, unused\n\n        Result\n        ------\n        str\n            The operator as a string.\n\n        Example\n        -------\n\n        >>> BaseParser('=', default_rule='OPER').data\n        '='\n        >>> BaseParser(':', default_rule='OPER').data\n        '='\n\n        \"\"\"\n\n        oper = node.text\n        if oper == ':':\n            oper = '='\n        return oper"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef visit_str(self, node, _):\n\n        # remove surrounding quotes and remove single backslashes\n        return self.visit_str.re_single_backslash.sub('', node.text[1:-1])", "response": "Regex rule for string allowing escaped quotes inside."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndumping a string as a line to filepath.", "response": "def dump_string_to_file(string, filepath):\n    \"\"\"Dump @string as a line to @filepath.\"\"\"\n    create_dirs(\n        os.path.dirname(filepath)\n    )\n\n    with open(filepath, 'a') as outfile:\n        outfile.write(string)\n        outfile.write('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndumps a dictionary as a line to filepath.", "response": "def dump_dict_to_file(dictionary, filepath):\n    \"\"\"Dump @dictionary as a line to @filepath.\"\"\"\n    create_dirs(\n        os.path.dirname(filepath)\n    )\n\n    with open(filepath, 'a') as outfile:\n        json.dump(dictionary, outfile)\n        outfile.write('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_chunk_path_from_string(string, chunk=3):\n    return os.path.join(\n        *list(generate_chunks(\n            string,\n            chunk\n        ))\n    )", "response": "Return a chunked path from a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\niterates over all files in folder and return all folders.", "response": "def next(self):\n        \"\"\"\n        Return all files in folder.\n        \"\"\"\n        # get depth of starting root directory\n        base_depth = self.__root.count(os.path.sep)\n\n        # walk files and folders\n        for root, subFolders, files in os.walk(self.__root):\n\n            # apply folder filter\n            if not self.filter_folder(root):\n                continue\n\n            # make sure we don't pass depth limit\n            if self.__depth_limit is not None:\n                curr_depth = root.count(os.path.sep)\n                if curr_depth - base_depth > self.__depth_limit:\n                    continue\n\n            # if need to return folders return it\n            if self.__ret_folders:\n                yield root\n\n            # return files\n            if self.__ret_files:\n                for f in files:\n                    yield os.path.join(root, f)\n\n        # end iterator\n        raise StopIteration"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ticks(\n            cls, request,\n            length: (Ptypes.path, Integer('Duration of the stream, in seconds.')),\n            style: (Ptypes.path, String('Tick style.', enum=['compact', 'extended']))\n        ) -> [\n            (200, 'Ok', TickStream),\n            (400, 'Invalid parameters')\n        ]:\n        '''A streaming Lord Vetinari clock...'''\n        try:\n            length = int(length)\n            style = cls._styles[style]\n        except (ValueError, KeyError):\n            Respond(400)\n        def vetinari_clock():\n            start = time()\n            while time() - start <= length:\n                sleep(randint(25, 400) / 100)\n                yield strftime(style, localtime())\n        Respond(200, vetinari_clock())", "response": "A streaming Lord Vetinari clock."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef convert_blocks_to_string(self):\n        taxa_ids = [[]] * int(self.data.number_taxa)\n        sequences = [''] * int(self.data.number_taxa)\n\n        for block in self._blocks:\n            for index, seq_record in enumerate(block):\n                taxa_ids[index] = '{0}_{1}_{2}'.format(seq_record.voucher_code,\n                                                       seq_record.taxonomy['genus'],\n                                                       seq_record.taxonomy['species'],\n                                                       )\n                sequence = get_seq(seq_record, self.codon_positions,\n                                   aminoacids=self.aminoacids,\n                                   degenerate=self.degenerate)\n                sequences[index] += sequence.seq\n                if sequence.warning:\n                    self.warnings.append(sequence.warning)\n\n        out = ''\n        for index, value in enumerate(taxa_ids):\n            out += '#{0}\\n{1}\\n'.format(taxa_ids[index], sequences[index])\n        return out", "response": "Convert the flattened data blocks into a string"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the given text into MetarData and Units dataclasses with parsed data and their associated units.", "response": "def parse(station: str, txt: str) -> (MetarData, Units):  # type: ignore\n    \"\"\"\n    Returns MetarData and Units dataclasses with parsed data and their associated units\n    \"\"\"\n    core.valid_station(station)\n    return parse_na(txt) if core.uses_na_format(station[:2]) else parse_in(txt)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_na(txt: str) -> (MetarData, Units):  # type: ignore\n    units = Units(**NA_UNITS)  # type: ignore\n    clean = core.sanitize_report_string(txt)\n    wxresp = {'raw': txt, 'sanitized': clean}\n    wxdata, wxresp['remarks'] = core.get_remarks(clean)\n    wxdata, wxresp['runway_visibility'], _ = core.sanitize_report_list(wxdata)\n    wxdata, wxresp['station'], wxresp['time'] = core.get_station_and_time(wxdata)\n    wxdata, wxresp['clouds'] = core.get_clouds(wxdata)\n    wxdata, wxresp['wind_direction'], wxresp['wind_speed'], \\\n        wxresp['wind_gust'], wxresp['wind_variable_direction'] = core.get_wind(wxdata, units)\n    wxdata, wxresp['altimeter'] = core.get_altimeter(wxdata, units, 'NA')\n    wxdata, wxresp['visibility'] = core.get_visibility(wxdata, units)\n    wxresp['other'], wxresp['temperature'], wxresp['dewpoint'] = core.get_temp_and_dew(wxdata)\n    condition = core.get_flight_rules(wxresp['visibility'], core.get_ceiling(wxresp['clouds']))  # type: ignore\n    wxresp['flight_rules'] = FLIGHT_RULES[condition]\n    wxresp['remarks_info'] = remarks.parse(wxresp['remarks'])  # type: ignore\n    wxresp['time'] = core.make_timestamp(wxresp['time'])  # type: ignore\n    return MetarData(**wxresp), units", "response": "Parses the North American METAR report into a MetarData object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef with_mfa(self, mfa_token):\n        if hasattr(mfa_token, '__call__'): # callable() is unsupported by 3.1 and 3.2\n            self.context.mfa_token = mfa_token.__call__()\n        else:\n            self.context.mfa_token = mfa_token\n        return self", "response": "Set the MFA token for the next request."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a HttpResponse that implements the TinyMCE spellchecker protocol.", "response": "def spellcheck(request):\n    \"\"\"\nReturns a HttpResponse that implements the TinyMCE spellchecker protocol.\n\"\"\"\n    try:\n        raw = request.raw_post_data\n        input = json.loads(raw)\n        id = input['id']\n        method = input['method']\n        params = input['params']\n        lang = params[0]\n        arg = params[1]\n\n        if not enchant.dict_exists(str(lang)):\n            raise RuntimeError(\"dictionary not found for language '%s'\" % lang)\n\n        checker = enchant.Dict(str(lang))\n\n        if method == 'checkWords':\n            result = [word for word in arg if word and not checker.check(word)]\n        elif method == 'getSuggestions':\n            result = checker.suggest(arg)\n        else:\n            raise RuntimeError(\"Unkown spellcheck method: '%s'\" % method)\n        output = {\n            'id': id,\n            'result': result,\n            'error': None,\n        }\n    except Exception:\n        return HttpResponse(\"Error running spellchecker\")\n    return HttpResponse(json.dumps(output),\n            content_type='application/json')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef resolved_row(objs, geomatcher):\n    def get_locations(lst):\n        for elem in lst:\n            try:\n                yield elem['location']\n            except TypeError:\n                yield elem\n\n    geomatcher['RoW'] = geomatcher.faces.difference(\n        reduce(\n            set.union,\n            [geomatcher[obj] for obj in get_locations(objs)]\n        )\n    )\n    yield geomatcher\n    del geomatcher['RoW']", "response": "A generator that yields the topo faces not used in objs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntranslate provided key into the actual key used in the topology.", "response": "def _actual_key(self, key):\n        \"\"\"Translate provided key into the key used in the topology. Tries the unmodified key, the key with the default namespace, and the country converter. Raises a ``KeyError`` if none of these finds a suitable definition in ``self.topology``.\"\"\"\n        if key in self or key in (\"RoW\", \"GLO\"):\n            return key\n        elif (self.default_namespace, key) in self:\n            return (self.default_namespace, key)\n\n        if isinstance(key, str) and self.coco:\n            new = coco.convert(names=[key], to='ISO2', not_found=None)\n            if new in self:\n                if new not in self.__seen:\n                    self.__seen.add(key)\n                    print(\"Geomatcher: Used '{}' for '{}'\".format(new, key))\n                return new\n\n        raise KeyError(\"Can't find this location\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinishes filtering a GIS operation. Can optionally exclude the input key sort results and exclude overlapping results. Internal function not normally called directly.", "response": "def _finish_filter(self, lst, key, include_self, exclusive, biggest_first):\n        \"\"\"Finish filtering a GIS operation. Can optionally exclude the input key, sort results, and exclude overlapping results. Internal function, not normally called directly.\"\"\"\n        key = self._actual_key(key)\n        locations = [x[0] for x in lst]\n\n        if not include_self and key in locations:\n            lst.pop(locations.index(key))\n\n        lst.sort(key=lambda x: x[1], reverse=biggest_first)\n        lst = [x for x, y in lst]\n\n        # RoW in both key and lst, but not defined; only RoW remains if exclusive\n        if key == 'RoW' and 'RoW' not in self and exclusive:\n            return ['RoW'] if 'RoW' in lst else []\n        elif exclusive:\n            removed, remaining = set(), []\n            while lst:\n                current = lst.pop(0)\n                faces = self[current]\n                if not faces.intersection(removed):\n                    removed.update(faces)\n                    remaining.append(current)\n            lst = remaining\n\n        # If RoW not resolved, make it the smallest\n        if 'RoW' not in self and 'RoW' in lst:\n            lst[-1 if biggest_first else 0] = lst.pop(lst.index('RoW'))\n\n        return lst"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets all locations that intersect this location.", "response": "def intersects(self, key, include_self=False, exclusive=False, biggest_first=True, only=None):\n        \"\"\"Get all locations that intersect this location.\n\n        Note that sorting is done by first by number of faces intersecting ``key``; the total number of faces in the intersected region is only used to break sorting ties.\n\n        If the ``resolved_row`` context manager is not used, ``RoW`` doesn't have a spatial definition, and therefore nothing intersects it. ``.intersects(\"RoW\")`` returns a list with with ``RoW`` or nothing.\n\n        \"\"\"\n        possibles = self.topology if only is None else {k: self[k] for k in only}\n\n        if key == 'RoW' and 'RoW' not in self:\n            return ['RoW'] if 'RoW' in possibles else []\n\n        faces = self[key]\n        lst = [\n            (k, (len(v.intersection(faces)), len(v)))\n            for k, v in possibles.items()\n            if (faces.intersection(v))\n        ]\n        return self._finish_filter(lst, key, include_self, exclusive, biggest_first)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of all locations that are completely within this location.", "response": "def contained(self, key, include_self=True, exclusive=False, biggest_first=True, only=None):\n        \"\"\"Get all locations that are completely within this location.\n\n        If the ``resolved_row`` context manager is not used, ``RoW`` doesn't have a spatial definition. Therefore, ``.contained(\"RoW\")`` returns a list with either ``RoW`` or nothing.\n\n        \"\"\"\n        if 'RoW' not in self:\n            if key == 'RoW':\n                return ['RoW'] if 'RoW' in (only or []) else []\n            elif only and 'RoW' in only:\n                only.pop(only.index('RoW'))\n\n        possibles = self.topology if only is None else {k: self[k] for k in only}\n\n        faces = self[key]\n        lst = [\n            (k, len(v))\n            for k, v in possibles.items()\n            if v and faces.issuperset(v)\n        ]\n        return self._finish_filter(lst, key, include_self, exclusive, biggest_first)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef within(self, key, include_self=True, exclusive=False, biggest_first=True, only=None):\n        possibles = self.topology if only is None else {k: self[k] for k in only}\n        _ = lambda key: [key] if key in possibles else []\n        if 'RoW' not in self and key == 'RoW':\n            answer = [] + _('RoW') + _('GLO')\n            return list(reversed(answer)) if biggest_first else answer\n\n        faces = self[key]\n        lst = [\n            (k, len(v))\n            for k, v in possibles.items()\n            if faces.issubset(v)\n        ]\n        return self._finish_filter(lst, key, include_self, exclusive, biggest_first)", "response": "Get all locations that completely contain this location."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef split_face(self, face, number=None, ids=None):\n        assert face in self.faces\n\n        if ids:\n            ids = set(ids)\n        else:\n            max_int = max(x for x in self.faces if isinstance(x, int))\n            ids = set(range(max_int + 1, max_int + 1 + (number or 2)))\n\n        for obj in self.topology.values():\n            if face in obj:\n                obj.discard(face)\n                obj.update(ids)\n\n        self.faces.discard(face)\n        self.faces.update(ids)\n\n        return ids", "response": "Splits a topological face into a number of small faces."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd new topological definitions to self. topology.", "response": "def add_definitions(self, data, namespace, relative=True):\n        \"\"\"Add new topological definitions to ``self.topology``.\n\n        If ``relative`` is true, then ``data`` is defined relative to the existing locations already in ``self.topology``, e.g. IMAGE:\n\n        .. code-block:: python\n\n            {\"Russia Region\": [\n                \"AM\",\n                \"AZ\",\n                \"GE\",\n                \"RU\"\n            ]}\n\n        Otherwise, ``data`` is a dictionary with string keys and values of integer topology face id sets:\n\n        .. code-block:: python\n\n            {\n                'A': {1, 2, 3},\n                'B': {2, 3, 4},\n            }\n\n        \"\"\"\n        if not relative:\n            self.topology.update({(namespace, k): v for k, v in data.items()})\n            self.faces.update(set.union(*data.values()))\n        else:\n            self.topology.update({\n                (namespace, k): set.union(*[self[o] for o in v])\n                for k, v in data.items()\n            })"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload and return a module", "response": "def load_module(self, name):\n        \"\"\"Load and return a module\"\"\"\n        if name in sys.modules:\n            return sys.modules[name]\n        # load the actual import hook module\n        module_name = self.mount2name(name)\n        __import__(module_name)\n        # alias the import hook module to the mount, so both can be used interchangeably\n        module = sys.modules[name] = sys.modules[module_name]\n        module.install()\n        return module"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntest that name is a module name", "response": "def is_module(self, name):\n        \"\"\"Test that `name` is a module name\"\"\"\n        if self.module_prefix.startswith(self.mount_prefix):\n            return name.startswith(self.module_prefix)\n        return name.startswith(self.module_prefix) and not name.startswith(self.mount_prefix)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntests that name is a mount name", "response": "def is_mount(self, name):\n        \"\"\"Test that `name` is a mount name\"\"\"\n        if self.mount_prefix.startswith(self.module_prefix):\n            return name.startswith(self.mount_prefix)\n        return name.startswith(self.mount_prefix) and not name.startswith(self.module_prefix)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a module name to a mount name", "response": "def name2mount(self, name):\n        \"\"\"Convert a module name to a mount name\"\"\"\n        if not self.is_module(name):\n            raise ValueError('%r is not a supported module name' % (name, ))\n        return name.replace(self.module_prefix, self.mount_prefix)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mount2name(self, mount):\n        if not self.is_mount(mount):\n            raise ValueError('%r is not a supported mount name' % (mount,))\n        return mount.replace(self.mount_prefix, self.module_prefix)", "response": "Convert a mount name to a module name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn CSS class attributes for the body.", "response": "def body_class_tag(context):\n    \"\"\"\n    Return CSS \"class\" attributes for <body>.\n\n    Allows to provide a CSS namespace using urlpatterns namespace (as ``.ns-*``) and view name (as ``.vw-*``).\n\n    Usage: ``{% body_class %}``\n    Example: ``ns-my-app vw-my-view`` or ``ns-contacts vw-list``\n    Requires: ``apps.core.middlewares.CoreMiddleware``.\n    \"\"\"\n    request = context.get(\"request\")\n    if not hasattr(request, \"ROUTE\"):\n        return \"\"\n\n    css_classes = []\n\n    namespace = request.ROUTE[\"namespace\"]\n    if namespace:\n        namespace = RE_CLEAN_CSS_NAME.sub(\"-\", namespace.lower())\n        css_classes.append(\"ns-{}\".format(namespace))\n\n    view = request.ROUTE[\"url_name\"]  # Use ``url_name`` as ``view_name`` includes the namespace.\n    if view:\n        view = RE_CLEAN_CSS_NAME.sub(\"-\", view.lower())\n        css_classes.append(\"vw-{}\".format(view))\n\n    return \" \".join(css_classes)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef static_absolute_tag(context, path):\n    request = context.get(\"request\")\n    return urljoin(request.ABSOLUTE_ROOT, static_url(path))", "response": "Return the absolute URL of a static file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the URL of a static file with handling of offline mode.", "response": "def static_cdn_tag(path, cdn, cdn_only=False):\n    \"\"\"\n    Return the URL of a static file, with handling of offline mode.\n\n    Usage: ``{%  %}``\n    \"\"\"\n    clean_path = path.lstrip(\"/\")\n    if getattr(settings, \"OFFLINE\", False):\n        return static_url(join(\"vendor\", clean_path))\n    elif cdn_only:\n        return cdn\n    return urljoin(cdn, clean_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the models identified by query parameters", "response": "def on_get(resc, req, resp):\n    \"\"\" Get the models identified by query parameters\n\n    We return an empty list if no models are found.\n    \"\"\"\n\n    signals.pre_req.send(resc.model)\n    signals.pre_req_search.send(resc.model)\n\n    models = goldman.sess.store.search(resc.rtype, **{\n        'filters': req.filters,\n        'pages': req.pages,\n        'sorts': req.sorts,\n    })\n\n    props = to_rest_models(models, includes=req.includes)\n    resp.serialize(props)\n\n    signals.post_req.send(resc.model)\n    signals.post_req_search.send(resc.model)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_credentials(self, credentials):\n        self._items.clear()\n        for key in credentials.get_key_names():\n            value = credentials.get_as_nullable_string(key)\n            self._items.append(CredentialParams.from_tuples([key, value]))", "response": "Reads credentials from configuration parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef store(self, correlation_id, key, credential):\n        if credential != None:\n            self._items.put(key, credential)\n        else:\n            self._items.remove(key)", "response": "Stores credential parameters into the store."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a key from a list of possible error codes.", "response": "def helpful_error_list_get(lst, index):\n    \"\"\"\n    >>> helpful_error_list_get([1, 2, 3], 1)\n    2\n    >>> helpful_error_list_get([1, 2, 3], 4)\n    Traceback (most recent call last):\n    ...\n    IndexError: Tried to access 4, length is only 3\n    \"\"\"\n    try:\n        return lst[index]\n    except IndexError:\n        raise IndexError('Tried to access %r, length is only %r' % (index, len(lst)))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef only(it):\n\n    if isinstance(it, Sized):\n        if len(it) != 1:\n            raise AssertionError('Expected one value, found %s' % len(it))\n        # noinspection PyUnresolvedReferences\n        return list(it)[0]\n\n    lst = tuple(islice(it, 2))\n    if len(lst) == 0:\n        raise AssertionError('Expected one value, found 0')\n    if len(lst) > 1:\n        raise AssertionError('Expected one value, found several')\n    return lst[0]", "response": "Return the first non - empty element of a sequence."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef strip_optional_prefix(string, prefix, log=None):\n    if string.startswith(prefix):\n        return string[len(prefix):]\n    if log:\n        log.warn('String starts with %r, not %r', string[:len(prefix)], prefix)\n    return string", "response": "Strip optional prefix from a string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef strip_required_prefix(string, prefix):\n    if string.startswith(prefix):\n        return string[len(prefix):]\n    raise AssertionError('String starts with %r, not %r' % (string[:len(prefix)], prefix))", "response": "Returns the first occurrence of prefix in string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef strip_optional_suffix(string, suffix, log=None):\n    if string.endswith(suffix):\n        return string[:-len(suffix)]\n    if log:\n        log.warn('String ends with %r, not %r', string[-len(suffix):], suffix)\n    return string", "response": "Strip optional suffix from a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the first non - empty suffix from the given string.", "response": "def strip_required_suffix(string, suffix):\n    \"\"\"\n    >>> strip_required_suffix('abcdef', 'def')\n    'abc'\n    >>> strip_required_suffix('abcdef', '123')\n    Traceback (most recent call last):\n    ...\n    AssertionError: String ends with 'def', not '123'\n    \"\"\"\n    if string.endswith(suffix):\n        return string[:-len(suffix)]\n    raise AssertionError('String ends with %r, not %r' % (string[-len(suffix):], suffix))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ensure_list_if_string(x):\n    if isinstance(x, basestring):\n        x = list(filter(None, re.split('[,\\s]+', x)))\n    return x", "response": "Ensures that an argument is passed either as a list of strings or a single string delimited by spaces and or commas."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nselect keys from a dictionary.", "response": "def select_keys(d, keys, helpful_error=True):\n    \"\"\"\n    >>> d = dict(a=1, b=2, c=3)\n    >>> print(json.dumps(select_keys(d, 'a c'), sort_keys=True))\n    {\"a\": 1, \"c\": 3}\n    >>> select_keys(d, 'a d')\n    Traceback (most recent call last):\n    ...\n    KeyError: \"Tried to access 'd', only keys are: ['a', 'b', 'c']\"\n    >>> select_keys(d, 'a d', helpful_error=False)\n    Traceback (most recent call last):\n    ...\n    KeyError: 'd'\n    \"\"\"\n    keys = ensure_list_if_string(keys)\n    if helpful_error:\n        return {k: helpful_error_dict_get(d, k) for k in keys}\n    else:\n        return {k: d[k] for k in keys}"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a dictionary that maps each element of an iterable to a list of elements.", "response": "def group_by_key_func(iterable, key_func):\n    \"\"\"\n    Create a dictionary from an iterable such that the keys are the result of evaluating a key function on elements\n    of the iterable and the values are lists of elements all of which correspond to the key.\n\n    >>> def si(d): return sorted(d.items())\n    >>> si(group_by_key_func(\"a bb ccc d ee fff\".split(), len))\n    [(1, ['a', 'd']), (2, ['bb', 'ee']), (3, ['ccc', 'fff'])]\n    >>> si(group_by_key_func([-1, 0, 1, 3, 6, 8, 9, 2], lambda x: x % 2))\n    [(0, [0, 6, 8, 2]), (1, [-1, 1, 3, 9])]\n    \"\"\"\n    result = defaultdict(list)\n    for item in iterable:\n        result[key_func(item)].append(item)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setattrs(obj, **kwargs):\n    for key, value in kwargs.items():\n        setattr(obj, key, value)\n    return obj", "response": "Set attributes of object to match the given kwargs."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a pretty table representation of the given rows.", "response": "def pretty_table(rows, header=None):\n    \"\"\"\n    Returns a string with a simple pretty table representing the given rows.\n    Rows can be:\n     - Sequences such as lists or tuples\n     - Mappings such as dicts\n     - Any object with a __dict__ attribute (most plain python objects) which is\n       equivalent to passing the __dict__ directly.\n    If no header is given then either all or none of the rows must be sequences\n    to ensure the correct order. If there are no sequences then the header will be\n    derived from the keys of the mappings.\n\n    >>> print(pretty_table([['a', 'hello', 'c', 1], ['world', 'b', 'd', 2]]))\n    a     | hello | c | 1\n    world | b     | d | 2\n    >>> print(pretty_table([['a', 'hello', 'c', 1], ['world', 'b', 'd', 2]], header='col1 col2 col3 col4'))\n    col1  | col2  | col3 | col4\n    ---------------------------\n    a     | hello | c    | 1\n    world | b     | d    | 2\n    >>> print(pretty_table([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}]))\n    a | b\n    -----\n    1 | 2\n    3 | 4\n    >>> class C(object):\n    ...     def __init__(self, a, b):\n    ...         self.a = a\n    ...         self.b = b\n    ...\n    >>> print(pretty_table([{'a': 1, 'b': 2}, C(3, 4), [5, 6]], header=['b', 'a']))\n    b | a\n    -----\n    2 | 1\n    4 | 3\n    5 | 6\n    >>> print(pretty_table([{'a': 1, 'b': 2}, C(3, 4), [5, 6]]))\n    Traceback (most recent call last):\n    ...\n    ValueError: Cannot mix sequences and other types of rows without specifying a header\n    >>> print(pretty_table([[1, 2], [3, 4, 5]]))\n    Traceback (most recent call last):\n    ...\n    ValueError: Mismatched lengths.\n    First row (len = 2):\n    [1, 2]\n    Current row (len = 3):\n    [3, 4, 5]\n    >>> print(pretty_table([{'a': 1, 'b': 2}], header='c d'))\n    Traceback (most recent call last):\n    ....\n    KeyError: \"Tried to access 'c', only keys are: ['a', 'b']\"\n    \"\"\"\n    rows2 = []\n    if header:\n        header = ensure_list_if_string(header)\n        rows2.insert(0, header)\n        row_type = ['any']\n    else:\n        header = []\n        row_type = [None]\n\n    def require_type(t):\n        if row_type[0] not in (None, t, 'any'):\n            raise ValueError('Cannot mix sequences and other types of rows without specifying a header')\n        if row_type[0] is None:\n            row_type[0] = t\n\n    def handle_dict(d):\n        require_type('mapping')\n        if not header:\n            header[:] = sorted(d.keys())\n            rows2.insert(0, header)\n        return [helpful_error_dict_get(d, key) for key in header]\n\n    for row in rows:\n        if isinstance(row, Mapping):\n            row = handle_dict(row)\n        elif isinstance(row, Sequence):\n            require_type('sequence')\n            if rows2 and len(row) != len(rows2[0]):\n                raise ValueError('Mismatched lengths.\\n'\n                                 'First row (len = %s):\\n%s\\n'\n                                 'Current row (len = %s):\\n%s' %\n                                 (len(rows2[0]), rows2[0], len(row), row))\n        else:\n            row = handle_dict(row.__dict__)\n        rows2.append(row)\n\n    rows = [[str(cell) for cell in row] for row in rows2]\n    widths = [max(len(row[i]) for row in rows) for i in range(len(rows[0]))]\n    lines = [' | '.join(cell.ljust(width) for cell, width in zip(row, widths)).strip()\n             for row in rows]\n    if header:\n        lines.insert(1, '-' * len(lines[0]))\n    return '\\n'.join(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef date_to_datetime(d):\n    if not isinstance(d, datetime):\n        d = datetime.combine(d, datetime.min.time())\n    return d", "response": "Convert a date to a datetime object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninstall other packages based on the server and environment", "response": "def other_dependancies(server, environment):\n    \"\"\"\n    Installs things that need to be in place before installing the main package\n    \"\"\"\n    print('  ** Other Dependancides, based on server', server, '**')\n    server = server.lower()\n    # Pillow is not on TestPyPI\n    if server is \"local\":\n        pass\n    elif server in [\"testpypi\", \"pypitest\"]:\n        # these are packages not available on the test server, so install them\n        # off the regular pypi server\n        print(\"  **Install Pillow**\")\n        subprocess.call([environment + '\\\\Scripts\\\\pip.exe', 'install', 'Pillow'], shell=True)\n    elif server in [\"pypi\"]:\n        print(\"  **Install Pillow**\")\n        subprocess.call([environment + '\\\\Scripts\\\\pip.exe', 'install', 'Pillow'], shell=True)\n    else:\n        print(\"  **Nothing more to install**\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_release(cts):\n    '''Make and upload the release.\n\n    Changelog:\n     - v0.2.1 -- 2016-11-18 -- specify downloading of non-cached version of the\n                               package for multiple formats can be properly and\n                               individually tested.\n     - 0.2.2 -- 2016-11028 -- move configuration to top of file\n    '''\n\n    make_release_version = __version__\n    colorama.init()\n    text.title(\"Minchin 'Make Release' for Python v{}\".format(make_release_version))\n    print()\n    text.subtitle(\"Configuration\")\n    print(\"base dir     -> {}\".format(here_directory()))\n    print(\"source       -> .\\{}\\\\\".format(source_directory().relative_to(here_directory())))\n    print(\"test dir     -> .\\{}\\\\\".format(test_directory().relative_to(here_directory())))\n    #print(\"doc dir      -> .\\{}\\\\\".format(doc_directory().relative_to(here_directory())))\n    print(\"version file -> .\\{}\".format(version_file().relative_to(here_directory())))\n    print()\n    text.subtitle(\"Git -- Clean directory?\")\n    print()\n    text.subtitle(\"Sort Import Statements\")\n    print()\n    text.subtitle(\"Run Tests\")\n    print()\n    text.subtitle(\"Update Version Number\")\n    new_version = update_version_number(None)\n    print()\n    text.subtitle(\"Add Release to Changelog\")\n    print()\n    text.subtitle(\"Build Documentation\")\n    print()\n    text.query_yes_quit('All good and ready to go?')\n\n    text.subtitle(\"Build Distributions\")\n    build_distribution()\n\n    for server in [\n                    #\"local\",\n                    #\"testpypi\",\n                    \"pypi\",\n                  ]:\n        for file_format in [\"tar.gz\", \"whl\"]:\n            print()\n            text.subtitle(\"Test {} Build {}\".format(file_format, server))\n            check_local_install(new_version, file_format, server)", "response": "Make and upload the release."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef formatedTime(ms):\n\n    if ms:\n        s = ms / 1000.0\n        m, s = divmod(s, 60)\n        h, m = divmod(m, 60)\n        d, h = divmod(h, 24)\n        out = ''\n        if d:\n            out += '%gd ' % d\n        if h:\n            out += '%gh ' % h\n        if m:\n            out += '%gm ' % m\n        if s:\n            out += '%gs ' % s\n        return out[:-1]\n    return ''", "response": "convert milliseconds in a human readable time"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _check_connectivity(self, err):\r\n\r\n        ''' a method to check connectivity as source of error '''\r\n        \r\n        try:\r\n            import requests\r\n            requests.get(self.uptime_ssl)\r\n        except:\r\n            from requests import Request\r\n            request_object = Request(method='GET', url=self.uptime_ssl)\r\n            request_details = self.handle_requests(request_object)\r\n            self.printer('ERROR.')\r\n            raise ConnectionError(request_details['error'])\r\n        self.printer('ERROR.')\r\n        raise err", "response": "a method to check connectivity as source of error"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _request(self, **kwargs):\r\n        \r\n        ''' a helper method for processing all request types '''\r\n        \r\n        response = None\r\n        error = ''\r\n        code = 0\r\n        \r\n    # send request\r\n        from requests import request\r\n        try:\r\n            response = request(**kwargs)\r\n        # handle response\r\n            if self.handle_response:\r\n                response, error, code = self.handle_response(response)\r\n            else:\r\n                code = response.status_code\r\n    # handle errors\r\n        except Exception as err:\r\n            from requests import Request\r\n            request_object = Request(**kwargs)\r\n            try:\r\n                request_details = self.handle_requests(request_object)\r\n                error = request_details['error']\r\n            except:\r\n                error = str(err)\r\n                \r\n        return response, error, code", "response": "a helper method for processing all request types"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _post_request(self, url, data=None, json=None, **kwargs):\r\n        \r\n        ''' a method to catch and report http post request connectivity errors '''\r\n        \r\n    # construct request kwargs\r\n        request_kwargs = {\r\n            'method': 'POST',\r\n            'url': url,\r\n            'data': data,\r\n            'json': json\r\n        }\r\n        for key, value in kwargs.items():\r\n            request_kwargs[key] = value\r\n\r\n    # send request and handle response\r\n        return self._request(**request_kwargs)", "response": "a method to catch and report http post request connectivity errors"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef onBinaryMessage(self, msg, fromClient):\n\t\tdata = bytearray()\n\t\tdata.extend(msg)\n\n\t\t\"\"\"\n\t\tself.print_debug(\"message length: {}\".format(len(data)))\n\t\tself.print_debug(\"message data: {}\".format(hexlify(data)))\n\t\t\"\"\"\n\n\t\ttry:\n\t\t\tself.queue.put_nowait(data)\n\t\texcept asyncio.QueueFull:\n\t\t\tpass", "response": "Called when a binary message is received from the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, *args, **kwargs):\n        super(DictProxy, self).update(*args, **kwargs)\n        return self", "response": "A handy update method which returns self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntaking a list of unicode strings that are clean_visible texts and creates n - grams using the n - grams of the texts.", "response": "def make_ngram_corpus(corpus_clean_visibles, num_tokens, filter_punctuation,\n                      zoning_rules=False):\n    '''takes a list of clean_visible texts, such as from StreamItems or\n    FCs, tokenizes all the texts, and constructs n-grams using\n    `num_tokens` sized windows.\n\n    ``corpus_clean_visibles`` -- list of unicode strings\n    ``num_tokens`` --- the n of the n-grams\n    ``filter_punctuation`` --- if True, punctuation is filtered\n    '''\n    ## TODO: generatlize this zoning code, so that it works on many\n    ## sites in the HT domain; consider finishing streamcorpus-zoner\n    ## to do this.\n    if filter_punctuation:\n        ## word tokenizer that removes punctuation\n        tokenize = RegexpTokenizer(r'\\w+').tokenize\n        backpage_string = 'backpage'\n        end_string = 'Poster'\n    else:\n        #tokenize = word_tokenize\n        tokenize = lambda s: string.split(s)\n        backpage_string = 'backpage.com'\n        end_string = 'Poster\\'s'\n\n    corpus = list()\n    for clean_vis in corpus_clean_visibles:\n        ## crudely skip pages that have \"error\"\n        if re.search(u'error', clean_vis, re.I & re.UNICODE):\n            continue\n\n        ## make tokens\n        tokens = tokenize(clean_vis) ## already a unicode string\n\n        if zoning_rules:\n            ## filter out non backpage pages\n            if backpage_string not in tokens:\n                continue\n\n            ## string that signals the beginning of the body\n            try:\n                idx0 = tokens.index('Reply')\n            except:\n                continue\n            ## string that signals the end of the body\n            try:\n                idx1 = tokens.index(end_string)\n            except:\n                continue\n\n            tokens = tokens[idx0:idx1]\n\n        ## make ngrams, attach to make strings\n        ngrams_strings = list()\n\n\n        for ngram_tuple in ngrams(tokens, num_tokens):\n            # ## attempt to remove unwanted phrases\n            ## score with many_stop_words and drop bad tuples\n            # stop_count = sum([int(bool(tok.lower() in stop_words))\n            #                   for tok in ngram_tuple])\n            # if stop_count > num_tokens / 1.5:\n            #     continue\n\n            ## remove ones with many repeated words\n            if len(set(ngram_tuple)) < len(ngram_tuple) / 2:\n                continue\n\n            ## this adds ngrams for the current doc\n            ngrams_strings.append(' '.join(ngram_tuple))\n\n\n        ## this adds a list of all the ngrams from the current doc\n        ## to the corpus list\n        corpus.append(ngrams_strings)\n    return corpus"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a streamcorpus. Chunk file into the structure that is passed by the search engine to find_soft_selectors", "response": "def ids_and_clean_visible_from_streamcorpus_chunk_path(corpus_path):\n    '''converts a streamcorpus.Chunk file into the structure that is\n    passed by the search engine to find_soft_selectors\n\n    '''\n    ch = clean_html(clean_html.default_config)\n    cv = clean_visible(clean_visible.default_config)\n    ids_and_clean_visible = []\n    for si in streamcorpus.Chunk(path=corpus_path):\n        if not si.body.clean_visible:\n            ## attempt to make clean_visible\n            if not si.body.raw:\n                logger.critical('no raw content, so skipping: %r', si.abs_url)\n                continue\n            abs_url = si.abs_url\n            si = ch(si, {})\n            if not si:\n                logger.critical(\n                    'failed to make clean_html, so skipping: %r', abs_url)\n                continue\n            si = cv(si, {})\n            if not si or not si.body.clean_visible:\n                logger.critical(\n                    'failed to make clean_visible, so skipping: %r', abs_url)\n                continue\n        rec = (si.stream_id, si.body.clean_visible.decode('utf8'), {})\n        ids_and_clean_visible.append(rec)\n    return ids_and_clean_visible"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iglob(pathname):\n    dirname = os.path.dirname(pathname)\n    basename_pattern = os.path.basename(pathname)\n    for root, dirs, files in os.walk(dirname):\n        for basename in files:\n            if fnmatch.fnmatch(basename, basename_pattern):\n                yield os.path.join(root, basename)", "response": "Returns an iterator which yields the same values as glob() without actually\n    storing them all simultaneously."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhashes the salt and password if being changed", "response": "def pre_save(sender, model):\n    \"\"\" Hash the password if being changed \"\"\"\n\n    if isinstance(model, Model) and 'password' in model.dirty_fields:\n        model.salt, model.password = gen_salt_and_hash(model.password)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nvalidates a username & password and return a token if auth is successful.", "response": "def auth_creds(cls, username, password):\n        \"\"\" Validate a username & password\n\n        A token is returned if auth is successful & can be\n        used to authorize future requests or ignored entirely\n        if the authorization mechanizm does not need it.\n\n        :return: string token\n        \"\"\"\n\n        store = goldman.sess.store\n        login = store.find(cls.RTYPE, 'username', username)\n\n        if not login:\n            msg = 'No login found by that username. Spelling error?'\n            raise AuthRejected(**{'detail': msg})\n        elif login.locked:\n            msg = 'The login account is currently locked out.'\n            raise AuthRejected(**{'detail': msg})\n        elif not cmp_val_salt_hash(password, login.salt, login.password):\n            msg = 'The password provided is incorrect. Spelling error?'\n            raise AuthRejected(**{'detail': msg})\n        else:\n            if not login.token:\n                login.token = random_str()\n            login.post_authenticate()\n            return login.token"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the login_date timestamp with the authenticated login model.", "response": "def post_authenticate(self):\n        \"\"\" Update the login_date timestamp\n\n        Initialize the thread local sess.login property with\n        the authenticated login model.\n\n        The login_date update will be debounced so writes don't\n        occur on every hit of the the API. If the login_date\n        was modified within 15 minutes then don't update it.\n        \"\"\"\n\n        goldman.sess.login = self\n        now = dt.now()\n\n        if not self.login_date:\n            self.login_date = now\n        else:\n            sec_since_updated = (now - self.login_date).seconds\n            min_since_updated = sec_since_updated / 60\n\n            if min_since_updated > 15:\n                self.login_date = now\n\n        if self.dirty:\n            store = goldman.sess.store\n            store.update(self)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nensure the username is unique", "response": "def validate_username(self, data, value):\n        \"\"\" Ensure the username is unique\n\n        If the login is being created then simply check if\n        the username is in the store & fail.\n\n        Otherwise if the login is being updated check if the\n        existing rid on a username match is the same as the\n        login being updated otherwise fail.\n        \"\"\"\n\n        store = goldman.sess.store\n        existing = store.find(data['rtype'], 'username', value)\n\n        if existing:\n            if not data['rid'] or data['rid'] != existing.rid:\n                raise ValidationError('username is already taken')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a string value to a standard log level value.", "response": "def to_log_level(value):\n        \"\"\"\n        Converts numbers and strings to standard log level values.\n\n        :param value: a value to be converted\n\n        :return: converted log level\n        \"\"\"\n        if value == None:\n            return LogLevel.Info\n\n        value = str(value).upper()\n        if (\"0\" == value) or (\"NOTHING\" == value) or (\"NONE\" == value):\n            return LogLevel.Nothing\n        elif (\"1\" == value) or (\"FATAL\" == value):\n            return LogLevel.Fatal\n        elif (\"2\" == value) or (\"ERROR\" == value):\n            return LogLevel.Error\n        elif (\"3\" == value) or (\"WARN\" == value) or (\"WARNING\" == value):\n            return LogLevel.Warn\n        elif (\"4\" == value) or (\"INFO\" == value):\n            return LogLevel.Info\n        elif (\"5\" == value) or (\"DEBUG\" == value):\n            return LogLevel.Debug\n        elif (\"6\" == value) or (\"TRACE\" == value):\n            return LogLevel.Trace\n        else:\n            return LogLevel.Info"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a log level to a string.", "response": "def to_string(level):\n        \"\"\"\n        Converts log level to a string.\n\n        :param level: a log level to convert\n\n        :return: log level name string.\n        \"\"\"\n        if level == LogLevel.Fatal:\n            return \"FATAL\" \n        if level == LogLevel.Error:\n            return \"ERROR\" \n        if level == LogLevel.Warn:\n            return \"WARN\" \n        if level == LogLevel.Info:\n            return \"INFO\" \n        if level == LogLevel.Debug:\n            return \"DEBUG\" \n        if level == LogLevel.Trace:\n            return \"TRACE\"\n        return \"UNDEF\""}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef commit(message=COMMON_COMMIT_MESSAGE, capture=True):\n    env.warn_only = True\n    local(u'git commit -am\"{}\"'.format(message))", "response": "git commit with common commit message when omit."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning an instance of FileStore.", "response": "def get_filestore_instance(img_dir=None, data_dir=None):\n    \"\"\"Return an instance of FileStore.\"\"\"\n    global _filestore_instances\n\n    key = \"%s:%s\" % (img_dir, data_dir)\n\n    try:\n        instance = _filestore_instances[key]\n    except KeyError:\n        instance = FileStore(\n            img_dir=img_dir, data_dir=data_dir\n        )\n        _filestore_instances[key] = instance\n\n    return instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_s3store_instance(bucket):\n    global _s3store_instances\n\n    key = \"%s\" % bucket\n\n    try:\n        instance = _s3store_instances[key]\n    except KeyError:\n        instance = S3Store(\n            bucket=bucket\n        )\n        _s3store_instances[key] = instance\n\n    return instance", "response": "Return an instance of S3Store."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _compare_list(new_list, old_list, change_list=None, root=None):\n\n    '''\n        a method for recursively listing changes made to a list\n\n    :param new_list: list with new value\n    :param old_list: list with old values\n    :param change_list: list of differences between old and new\n    :param root: string with record of path to the root of the main object\n    :return: list of differences between old and new\n    '''\n\n    from copy import deepcopy\n    if len(old_list) > len(new_list):\n        same_len = len(new_list)\n        for i in reversed(range(len(new_list), len(old_list))):\n            new_path = deepcopy(root)\n            new_path.append(i)\n            change_list.append({'action': 'REMOVE', 'value': None, 'path': new_path})\n    elif len(new_list) > len(old_list):\n        same_len = len(old_list)\n        append_list = []\n        path = deepcopy(root)\n        for i in range(len(old_list), len(new_list)):\n            append_list.append(new_list[i])\n        change_list.append({'action': 'APPEND', 'value': append_list, 'path': path})\n    else:\n        same_len = len(new_list)\n    for i in range(0, same_len):\n        new_path = deepcopy(root)\n        new_path.append(i)\n        if new_list[i].__class__ != old_list[i].__class__:\n            change_list.append({'action': 'UPDATE', 'value': new_list[i], 'path': new_path})\n        elif isinstance(new_list[i], dict):\n            _compare_dict(new_list[i], old_list[i], change_list, new_path)\n        elif isinstance(new_list[i], list):\n            _compare_list(new_list[i], old_list[i], change_list, new_path)\n        elif isinstance(new_list[i], set):\n            _compare_set(new_list[i], old_list[i], change_list, new_path)\n        elif new_list[i] != old_list[i]:\n            change_list.append({'action': 'UPDATE', 'value': new_list[i], 'path': new_path})\n    return change_list", "response": "a method for recursively listing changes made to a list of entries"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _compare_set(new_set, old_set, change_list, root):\n\n    '''\n        a method for list changes made to a set\n\n    :param new_set: set with new values\n    :param old_set: set with old values\n    :param change_list: list of differences between old and new\n    :patam root: string with record of path to the root of the main object\n    :return: list of differences between old and new\n    '''\n\n    from copy import deepcopy\n    path = deepcopy(root)\n    missing_items = old_set - new_set\n    extra_items = new_set - old_set\n    for item in missing_items:\n        change_list.append({'action': 'REMOVE', 'key': None, 'value': item, 'path': path})\n    for item in extra_items:\n        change_list.append({'action': 'ADD', 'key': None, 'value': item, 'path': path})\n    return change_list", "response": "method for list changes made to a set of objects"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntransforms a simple query with one or more filter expressions into a MongoDB query expression.", "response": "def to_mongo(qry):\n    \"\"\"Transform a simple query with one or more filter expressions\n    into a MongoDB query expression.\n\n    :param qry: Filter expression(s), see function docstring for details.\n    :type qry: str or list\n    :return: MongoDB query\n    :rtype: dict\n    :raises: BadExpression, if one of the input expressions cannot be parsed\n\n    Expressions have three parts, called in order ``field``, ``operator``,\n    and ``value``.\n\n        - `field` is the name of a field in a MongoDB document\n        - `value` is the value to compare against:\n            * numeric\n            * string, you MUST use 'single' or \"double\" quotes\n            * boolean: true, false\n        - `operator` is a comparison operator:\n            * inequalities: >, <, =, <=, >=, !=\n            * PCRE regular expression: ~\n            * data type: int, float, string, or bool\n            * exists: boolean (true/false) whether field exists in record\n            * size: for array fields, an inequality for the array size, given as\n              a suffix to the operator: size>, size<\n\n    Multiple expressions can be a single string, or a list.\n    In either case, the form is a \"disjunction of conjunctions\".\n\n    In the string form:\n\n        * \"and\" joins expressions into groups\n        * \"or\" joins one or more expression groups\n\n    In the list form:\n\n        * The inner list is a group of \"and\"ed expressions\n        * The outer list \"or\"s the expression groups together.\n\n    In the string form, parentheses before or after the \"or\"ed expression\n    groups [note: even non-sensical ones like '((('], are ignored.\n    So these can be used to clarify the groupings.\n\n    **Examples**\n\n    Two sets of filters, return records where either is true:\n\n    >>> to_mongo('(a > 3 and b = \"hello\") or (c > 1 and d = \"goodbye\")')\n    {'$or': [{'a': {'$gt': 3}, 'b': 'hello'}, {'c': {'$gt': 1}, 'd': 'goodbye'}]}\n\n    Same as previous, but without parentheses:\n\n    >>> to_mongo('a > 3 and b = \"hello\" or c > 1 and d = \"goodbye\"')\n    {'$or': [{'a': {'$gt': 3}, 'b': 'hello'}, {'c': {'$gt': 1}, 'd': 'goodbye'}]}\n\n    Same as previous, but using lists rather than \"and\"/\"or\":\n\n    >>> to_mongo([['a > 3', 'b = \"hello\"'], ['c > 1', 'd = \"goodbye\"']])\n    {'$or': [{'a': {'$gt': 3}, 'b': 'hello'}, {'c': {'$gt': 1}, 'd': 'goodbye'}]}\n    \"\"\"\n    rev = False     # filters, not constraints\n    # special case for empty string/list\n    if qry == \"\" or qry == []:\n        return {}\n    # break input into groups of filters\n    unpar = lambda s: s.strip().strip('()')\n    if isinstance(qry, str):\n        groups = []\n        if _TOK_OR in qry:\n            groups = [unpar(g).split(_TOK_AND) for g in qry.split(_TOK_OR)]\n        else:\n            groups = [unpar(qry).split(_TOK_AND)]\n    else:\n        if isinstance(qry[0], list) or isinstance(qry[0], tuple):\n            groups = qry\n        else:\n            groups = [qry]\n    # generate mongodb queries for each filter group\n    filters = []\n    for filter_exprs in groups:\n        mq = MongoQuery()\n        for e in filter_exprs:\n            try:\n                e = unpar(e)\n            except AttributeError:\n                raise BadExpression(e, \"expected string, got '{t}'\".format(t=type(e)))\n            try:\n                constraint = Constraint(*parse_expr(e))\n            except ValueError as err:\n                raise BadExpression(e, err)\n            clause = MongoClause(constraint, rev=rev)\n            mq.add_clause(clause)\n        filters.append(mq.to_mongo(rev))\n    # combine together filters, or strip down the one filter\n    if len(filters) > 1:\n        result = {'$or': filters}\n    else:\n        result = filters[0]\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_expr(e):\n    m = relation_re.match(e)\n    if m is None:\n        raise ValueError(\"error parsing expression '{}'\".format(e))\n    field, op, val = m.groups()\n    # Try different types\n    try:\n        # Integer\n        val_int = int(val)\n        val = val_int\n    except ValueError:\n        try:\n            # Float\n            val_float = float(val)\n            val = val_float\n        except ValueError:\n            try:\n                # Boolean\n                val = {'true': True, 'false': False}[val.lower()]\n            except KeyError:\n                # String\n                if re.match(r'\".*\"|\\'.*\\'', val):\n                    # strip quotes from strings\n                    val = val[1:-1]\n    return field, op, val", "response": "Parse a single constraint expression."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main():\n    import sys, signal\n\n    def _exit():\n        print(\"Thank you for playing Simple Mongo Query!\")\n        sys.exit(0)\n\n    signal.signal(signal.SIGINT, lambda s, f: sys.stdout.write(\"\\n\") or _exit())\n\n    while 1:\n        expr = input(\"Enter query: \").strip()\n        if not expr:\n            break\n        try:\n            q = to_mongo(expr)\n        except BadExpression as e:\n            print((\"Error! Cannot parse '{}'\".format(e.expr)))\n            continue\n        print((\"Result: {}\".format(q)))\n    _exit()", "response": "Run an interactive CLI program that prints the output of running query on the input string."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the code for a size operation.", "response": "def _set_size_code(self):\n        \"\"\"Set the code for a size operation.\n        \"\"\"\n        if not self._op.startswith(self.SIZE):\n            self._size_code = None\n            return\n\n        if len(self._op) == len(self.SIZE):\n            self._size_code = self.SZ_EQ\n        else:\n            suffix = self._op[len(self.SIZE):]\n            self._size_code = self.SZ_MAPPING.get(suffix, None)\n            if self._size_code is None:\n                raise ValueError('invalid \"{}\" suffix \"{}\"'.format(self.SIZE, suffix))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compare(self, lhs_value, rhs_value):\n        if self.is_eq():\n            # simple {field:value}\n            return lhs_value is not None and lhs_value == rhs_value\n        if self.is_neq():\n            return lhs_value is not None and lhs_value != rhs_value  # XXX: 'or'?\n        if self.is_exists():\n            if rhs_value:\n                return lhs_value is not None\n            else:\n                return lhs_value is None\n        if self.is_size():\n            if self.is_size_eq() or self.is_size_var():\n                return lhs_value == rhs_value\n            if self.is_size_gt():\n                return lhs_value > rhs_value\n            if self.is_size_lt():\n                return lhs_value < rhs_value\n            raise RuntimeError('unexpected size operator: {}'.format(self._op))\n        if self.is_inequality():\n            if not isinstance(lhs_value, Number):\n                return False\n            py_op = self.PY_INEQ.get(self._op, self._op)\n            return eval('{} {} {}'.format(lhs_value, py_op, rhs_value))\n        if self.is_type():\n            ltype = type(lhs_value)\n            if rhs_value is Number:\n                return ltype in (int, float)\n            elif rhs_value is str:\n                return ltype is str\n            elif rhs_value is bool:\n                return ltype is bool\n            return False\n        if self.is_regex():\n            m = rhs_value.match(lhs_value)\n            return m is not None", "response": "Compare the left and right size of the key value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndoing the given value pass this constraint?", "response": "def passes(self, value):\n        \"\"\"Does the given value pass this constraint?\n\n        :return: True,None if so; False,<expected> if not\n        :rtype: tuple\n        \"\"\"\n        try:\n            if self._op.compare(value, self.value):\n                return True, None\n            else:\n                return False, self.value\n        except ValueError as err:\n            return False, str(err)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a constraint to the set of constraints.", "response": "def add_constraint(self, op, val):\n        \"\"\"Add new constraint.\n\n        :param op: Constraint operator\n        :type op: ConstraintOperator\n        :param val: Constraint value\n        :type val: str,Number\n        :raise: ValueError if combination of constraints is illegal\n        \"\"\"\n        if len(self.constraints) > 0:\n            if op.is_equality():\n                clist = ', '.join(map(str, self.constraints))\n                raise ValueError('Field {}: equality operator cannot be combined '\n                                 'with others: {}'.format(self._field.name, clist))\n            elif op.is_exists():\n                raise ValueError('Field {}: existence is implied '\n                                 'by other operators'.format(self._field.name))\n        constraint = Constraint(self._field, op, val)\n        self.constraints.append(constraint)\n        if self._field.has_subfield():\n            self._array = True\n        elif op.is_inequality():\n            self._range = True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_conflicts(self):\n        conflicts = []\n        if self._array and self._range:\n            conflicts.append('cannot use range expressions on arrays')\n        return conflicts", "response": "Get conflicts in constraints if any."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_existence(self, rev):\n        if len(self.constraints) == 1 and (\n            # both 'exists' and strict equality don't require the extra clause\n            self.constraints[0].op.is_exists() or\n                self.constraints[0].op.is_equality()):\n            return\n        value = not rev   # value is False if reversed, otherwise True\n        constraint = Constraint(self._field, ConstraintOperator.EXISTS, value)\n        self._existence_constraints.append(constraint)", "response": "Add existence constraint for the field."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _create(self, constraint, exists_main):\n        c = constraint  # alias\n        op = self._reverse_operator(c.op) if self._rev else c.op\n        mop = self._mongo_op_str(op)\n        # build the clause parts: location and expression\n        loc = MongoClause.LOC_MAIN  # default location\n        if op.is_exists():\n            loc = MongoClause.LOC_MAIN2 if exists_main else MongoClause.LOC_MAIN\n            assert (isinstance(c.value, bool))\n            # for exists, reverse the value instead of the operator\n            not_c_val = not c.value if self._rev else c.value\n            expr = {c.field.name: {mop: not_c_val}}\n        elif op.is_size():\n            if op.is_variable():\n                # variables only support equality, and need to be in $where\n                loc = MongoClause.LOC_WHERE\n                js_op = '!=' if self._rev else '=='\n                expr = 'this.{}.length {} this.{}'.format(c.field.name, js_op, c.value)\n            elif op.is_size_eq() and not self._rev:\n                expr = {c.field.name: {'$size': c.value}}\n            else:\n                # inequalities also need to go into $where clause\n                self._check_size(op, c.value)\n                loc = MongoClause.LOC_WHERE\n                szop = ConstraintOperator(op.size_op)\n                if self._rev:\n                    szop.reverse()\n                js_op = self._js_op_str(szop)\n                expr = 'this.{}.length {} {}'.format(c.field.name, js_op, c.value)\n        elif op.is_type():\n            loc = MongoClause.LOC_WHERE\n            type_name = self.JS_TYPES.get(c.value, None)\n            if type_name is None:\n                raise RuntimeError('Could not get JS type for {}'.format(c.value))\n            typeop = '!=' if self._rev else '=='\n            expr = 'typeof this.{} {} \"{}\"'.format(c.field.name, typeop, type_name)\n        elif op.is_regex():\n            expr = {c.field.name: {mop: c.value.pattern}}\n        else:\n            if mop is None:\n                expr = {c.field.name: c.value}\n            elif isinstance(c.value, bool):\n                # can simplify boolean {a: {'$ne': True/False}} to {a: False/True}\n                not_c_val = not c.value if self._rev else c.value\n                expr = {c.field.name: not_c_val}\n            else:\n                expr = {c.field.name: {mop: c.value}}\n        return loc, expr", "response": "Create a MongoDB query clause for a specific constraint."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _reverse_operator(self, op):\n        op = copy.copy(op)\n        op.reverse()\n        # check that we can map it\n        if not str(op) in self.MONGO_OPS:\n            raise ValueError('unknown operator: {}'.format(op))\n        return op", "response": "Reverse the operation e. g. since the conditions\n        you provide are assertions of how things should be"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a new clause to the existing query.", "response": "def add_clause(self, clause):\n        \"\"\"Add a new clause to the existing query.\n\n        :param clause: The clause to add\n        :type clause: MongoClause\n        :return: None\n        \"\"\"\n        if clause.query_loc == MongoClause.LOC_MAIN:\n            self._main.append(clause)\n        elif clause.query_loc == MongoClause.LOC_MAIN2:\n            self._main2.append(clause)\n        elif clause.query_loc == MongoClause.LOC_WHERE:\n            self._where.append(clause)\n        else:\n            raise RuntimeError('bad clause location: {}'.format(clause.query_loc))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_mongo(self, disjunction=True):\n        q = {}\n        # add all the main clauses to `q`\n        clauses = [e.expr for e in self._main]\n        if clauses:\n            if disjunction:\n                if len(clauses) + len(self._where) > 1:\n                    q['$or'] = clauses\n                else:\n                    # simplify 'or' of one thing\n                    q.update(clauses[0])\n            else:\n                for c in clauses:\n                    q.update(c)\n        # add all the main2 clauses; these are not or'ed\n        for c in (e.expr for e in self._main2):\n            # add to existing stuff for the field\n            for field in c:\n                if field in q:\n                    q[field].update(c[field])\n                else:\n                    q.update(c)\n        # add where clauses, if any, to `q`\n        if self._where:\n            wsep = ' || ' if self._where[0].is_reversed else ' && '\n            where_clause = wsep.join([w.expr for w in self._where])\n            if disjunction:\n                if not '$or' in q:\n                    q['$or'] = []\n                q['$or'].append({'$where': where_clause})\n            else:\n                q['$where'] = where_clause\n        return q", "response": "Create from current state a valid MongoDB query expression."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convert(element):\n    element = linker.LinkPrimitives().convert(element)\n    if isinstance(element, link.ChainLink.chain_types.base_bundle_type):\n        return ThreadLinkPrimitives.base_bundle_type(element.elements)\n    elif isinstance(element, link.ChainLink.chain_types.base_chain_type):\n        return ThreadLinkPrimitives.base_chain_type(element.elements)\n    return element", "response": "Convert a regular chainlink to a thread based version of element if possible."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsubmit a call to the scheduler and return the future", "response": "def submit(self, call, *args, **kwargs):\n        \"\"\"\n        Submit a call for future execution\n\n        :return: future for the call execution\n        :rtype: StoredFuture\n        \"\"\"\n        future = StoredFuture(call, *args, **kwargs)\n        self._queue.put(future)\n        self._ensure_worker()\n        return future"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _dismiss_worker(self, worker):\n        self._workers.remove(worker)\n        if len(self._workers) < self._min_workers:\n            self._workers.add(worker)\n            return False\n        return True", "response": "Dismiss worker unless it is still required."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nensure there are enough workers available and start them if necessary.", "response": "def _ensure_worker(self):\n        \"\"\"Ensure there are enough workers available\"\"\"\n        while len(self._workers) < self._min_workers or len(self._workers) < self._queue.qsize() < self._max_workers:\n            worker = threading.Thread(\n                target=self._execute_futures,\n                name=self.identifier + '_%d' % time.time(),\n            )\n            worker.daemon = True\n            self._workers.add(worker)\n            worker.start()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupload an object to an S3 bucket.", "response": "def s3_upload(acl, bucket, conn, content, content_type, path):\n    \"\"\" Store an object in our an S3 bucket.\n\n    :param acl:\n        S3 ACL for the object\n    :param bucket:\n        S3 bucket to upload to\n    :param content:\n        a string representation of the object to upload\n    :param content_type:\n        a string MIMETYPE of the object that S3 should\n        be informed of\n    :param path:\n        an object specific portion of the S3 key name\n        to be passed to gen_url to generate the the location\n        in S3 of the new object\n\n    :raise:\n        IOError on any failure\n    :return:\n        S3 generated URL of the uploaded object\n    \"\"\"\n\n    # obj is the object that will be uploaded\n    obj = Key(conn.get_bucket(bucket))\n    obj.content_type = content_type\n    obj.key = path\n\n    obj.set_contents_from_string(content)\n    obj.set_acl(acl)\n\n    return gen_url(bucket, path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef match(self, filepath):\n        # no extension?\n        if filepath.find(\".\") == -1:\n            return False\n\n        # match extension\n        return filepath.lower().split(\".\")[-1] in self.__extensions", "response": "Returns True if filepath matches the current file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_storyline(self, timezone_offset, first_date, start=0.0, end=0.0, track_points=False):\r\n\r\n        ''' a method to retrieve storyline details for a period of time\r\n\r\n        NOTE: start and end must be no more than 30 days, 1 second apart\r\n\r\n        NOTE: if track_points=True, start and end must be no more than 6 days, 1 second apart\r\n\r\n        :param timezone_offset: integer with timezone offset from user profile details\r\n        :param first_date: string with ISO date from user profile details firstDate\r\n        :param start: [optional] float with starting datetime for daily summaries\r\n        :param end: [optional] float with ending datetime for daily summaries\r\n        :param track_points: [optional] boolean to provide detailed tracking of user movement\r\n        :return: dictionary of response details with storyline list inside json key\r\n\r\n         {\r\n            'headers': { ... },\r\n            'code': 200,\r\n            'error': '',\r\n            'url': 'https://api.moves-app.com/api/1.1/user/storyline/daily'\r\n            'json': [ SEE RESPONSE in https://dev.moves-app.com/docs/api_storyline ]\r\n        }\r\n        '''\r\n\r\n        title = '%s.get_storyline' % self.__class__.__name__\r\n\r\n    # validate scope\r\n        if {'location', 'activity'} - set(self.service_scope):\r\n            raise ValueError('%s requires service scope to contain \"location\" and \"activity\".' % title)\r\n\r\n    # construct request fields\r\n        url_string = '%s/user/storyline/daily' % self.endpoint\r\n        parameters = self._process_dates(timezone_offset, first_date, start, end, title, track_points)\r\n        if track_points:\r\n            parameters['trackPoints'] = 'true'\r\n\r\n    # send request\r\n        storyline_details = self._get_request(url_string, params=parameters)\r\n\r\n        return storyline_details", "response": "a method to retrieve the list of storylines for a given period of time"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_list(self, list_of_colours, normalized_rgb=False):\n        colour_for_type = Colour()\n        self._colours = []\n\n        for c in list_of_colours:\n            if type(c) is type(colour_for_type):\n                self._colours.append(c)\n            else:\n                self._colours.append(Colour(c, normalized_rgb))\n\n        self._start = self._colours[0]\n        self._end = self._colours[-1]", "response": "This method takes a list of colours and creates a Colours object from it."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_image(self, filename='palette.png', band_width=1, length=60,\n                 max_width=0, vertical=True, alpha_channel=False):\n        \"\"\"\n        Creates an image from the palette.\n\n        Args:\n            filename(Optional[string]): filename of saved file. Defaults to\n                ``palette.png`` in the current working directory.\n            band_width(optional[int]): how wide each colour band should be.\n                Defaults to 1 pixel.\n            length(Optional[int]): the length of the overall image in pixels.\n                This is the dimension orthogonal to ``band_width``. Defaults\n                to 60 pixels.\n            max_width(Optional[int]): if ``band_width`` is not set and this is,\n                this determines how wide the whole image should be.\n            vertical(Optional[bool]): if the image runs vertical (``True``,\n                default) or horizontal (``False``).\n            alpha_channel(Optional[bool]): if ``True``, the created image will\n                have an Alpha channel. Defaults to ``False``.\n        \"\"\"\n        # max_width is approximate\n        # generate output pictures for documentation automatically\n\n        if max_width < 1:\n            pass\n        else:\n            band_width = int(max_width/len(self._colours))\n\n        image_width = band_width * len(self._colours)\n\n        if alpha_channel:\n            my_image = Image.new('RGBA', (image_width, length))\n        else:\n            my_image = Image.new('RGB', (image_width, length))\n        image_loaded = my_image.load()\n\n        x = 0\n        for my_colour in self._colours:\n            for x1 in range(band_width):\n                for y in range(length):\n                    image_loaded[x, y] = my_colour.rgb()\n                x = x + 1\n\n        if vertical:\n            my_image = my_image.rotate(270)\n\n        my_image.save(filename)", "response": "Creates an image from the palette."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef blend(self, cycles=1):\n\n        for j in range(int(cycles)):\n            new_colours = []\n            for i, c in enumerate(self._colours):\n                if i != 0:\n                    c2 = blend(c, self._colours[i-1])\n                    new_colours.append(c2)\n                new_colours.append(c)\n\n            self._colours = new_colours", "response": "Blends the existing Colours between all Colours in the current Palette and all other Colours in the current Palette."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _create_component(tag_name, allow_children=True, callbacks=[]):\n    def _component(*children, **kwargs):\n        if 'children' in kwargs:\n            children = kwargs.pop('children')\n        else:\n            # Flatten children under specific circumstances\n            # This supports the use case of div([a, b, c])\n            # And allows users to skip the * operator\n            if len(children) == 1 and isinstance(children[0], list):\n                # We want children to be tuples and not lists, so\n                # they can be immutable\n                children = tuple(children[0])\n        if 'style' in kwargs:\n            style = kwargs.pop('style')\n        else:\n            style = None\n        if 'attributes' in kwargs:\n            attributes = kwargs['attributes']\n        else:\n            attributes = dict(**kwargs)\n\n        if (tag_name == 'a') and ('href' not in attributes):\n            attributes['href'] = '#'\n\n        if not allow_children and children:\n            # We don't allow children, but some were passed in\n            raise ValueError(\n                '<{tag_name} /> cannot have children'.format(tag_name=tag_name))\n\n        for cb in callbacks:\n            cbname = cb['name']\n            if cbname in attributes:\n                if attributes[cbname] is not None:\n                    from google.colab import output as colab_output\n                    callback_id = cbname+'callback-' + str(uuid.uuid4())\n                    register_callback(callback_id, attributes[cbname])\n                    #js=\"google.colab.kernel.invokeFunction('{callback_id}', [], {kwargs})\"\n                    js = \"window.vdomr_invokeFunction('{callback_id}', [], {kwargs})\"\n                    js = js.replace('{callback_id}', callback_id)\n                    js = js.replace('{kwargs}', cb['kwargs'])\n                    attributes[cbname] = js\n                else:\n                    attributes[cbname] = ''\n\n        v = VDOM(tag_name, attributes, style, children)\n        return v\n\n    return _component", "response": "Create a component for an HTML Tag."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef bump(dev=False, patch=False, minor=False, major=False, nocommit=False):\n    if sum([int(x) for x in (patch, minor, major)]) > 1:\n        raise ValueError('Only one of patch, minor, major can be incremented.')\n\n    if check_staged():\n        raise EnvironmentError('There are staged changes, abort.')\n\n    with open(str(INIT_PATH)) as f:\n        lines = f.readlines()\n\n    for i, line in enumerate(lines):\n        varmatch = re.match(\"__([a-z]+)__ = '([^']+)'\", line)\n        if varmatch:\n            if varmatch.group(1) == 'version':\n                version = Version(varmatch.group(2))\n                vdict = version._version._asdict()\n                print('Current version:', version)\n                increment_release = True\n                if dev:\n                    if vdict['dev']:\n                        vdict['dev'] = (vdict['dev'][0], vdict['dev'][1] + 1)\n                        increment_release = False\n                        if sum([int(x) for x in (patch, minor, major)]) > 0:\n                            raise ValueError('Cannot increment patch, minor, or major between dev versions.')\n                    else:\n                        vdict['dev'] = ('dev', 0)\n                else:\n                    if vdict['dev']:\n                        vdict['dev'] = None\n                        increment_release = False\n\n                if increment_release:\n                    rel = vdict['release']\n                    if major:\n                        vdict['release'] = (rel[0] + 1, 0, 0)\n                    elif patch:\n                        vdict['release'] = (rel[0], rel[1], rel[2] + 1)\n                    else:  # minor is default\n                        vdict['release'] = (rel[0], rel[1] + 1, 0)\n\n                version._version = _Version(**vdict)\n                print('Version bumped to:', version)\n                lines[i] = \"__version__ = '{!s}'\\n\".format(version)\n                break\n\n    with open(str(INIT_PATH), 'w') as f:\n        f.writelines(lines)\n\n    if not nocommit:\n        call(['git', 'add', 'bucketcache/__init__.py'])\n        call(['git', 'commit', '-m', 'Bumped version number to {!s}'.format(version)])\n    return version", "response": "Bump version number and commit change."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef upload():\n    try:\n        o = check_output(['twine', 'upload'] + glob('dist/*'))\n    except CalledProcessError:\n        call(['twine', 'upload'] + glob('dist/*'))\n        raise\n    print(o.decode('utf-8'))", "response": "Upload source to PyPI using twine."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreleases the current version tag build and gen docs.", "response": "def release():\n    \"\"\"Bump version, tag, build, gen docs.\"\"\"\n    if check_staged():\n        raise EnvironmentError('There are staged changes, abort.')\n    if check_unstaged():\n        raise EnvironmentError('There are unstaged changes, abort.')\n    bump()\n    tag()\n    build()\n    doc_gen()\n    puts(colored.yellow(\"Remember to upload documentation and package:\"))\n    with indent(2):\n        puts(colored.cyan(\"shovel doc.upload\"))\n        puts(colored.cyan(\"shovel version.upload\"))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate_rid(model, rid):\n\n    rid_field = getattr(model, model.rid_field)\n\n    if isinstance(rid_field, IntType):\n        try:\n            int(rid)\n        except (TypeError, ValueError):\n            abort(exceptions.InvalidURL(**{\n                'detail': 'The resource id {} in your request is not '\n                          'syntactically correct. Only numeric type '\n                          'resource id\\'s are allowed'.format(rid)\n            }))", "response": "Ensure the resource id is proper"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind a model from the store by resource id", "response": "def find(model, rid):\n    \"\"\" Find a model from the store by resource id \"\"\"\n\n    validate_rid(model, rid)\n\n    rid_field = model.rid_field\n    model = goldman.sess.store.find(model.RTYPE, rid_field, rid)\n\n    if not model:\n        abort(exceptions.DocumentNotFound)\n\n    return model"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _from_rest_blank(model, props):\n\n    blank = model.get_fields_by_prop('allow_blank', True)\n\n    for field in blank:\n        try:\n            if props[field] == '':\n                props[field] = None\n        except KeyError:\n            continue", "response": "Set empty strings to None where allowed\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _from_rest_hide(model, props):\n\n    hide = model.get_fields_by_prop('from_rest', False)\n\n    for field in hide:\n        try:\n            del props[field]\n        except KeyError:\n            continue", "response": "Remove fields not allowed during a REST deserialization\nWorkItem"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _from_rest_ignore(model, props):\n\n    fields = model.all_fields\n\n    for prop in props.keys():\n        if prop not in fields:\n            del props[prop]", "response": "Remove all unknown properties from the given dict."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _from_rest_lower(model, props):\n\n    for field in model.to_lower:\n        try:\n            props[field] = props[field].lower()\n        except (AttributeError, KeyError):\n            continue", "response": "Lowercase fields requesting it during a REST deserialization"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _from_rest_on_create(model, props):\n\n    fields = model.get_fields_with_prop('on_create')\n\n    for field in fields:\n        props[field[0]] = field[1]", "response": "Assign the default values when creating a model"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nassigns the default values when updating a model", "response": "def _from_rest_on_update(model, props):\n    \"\"\" Assign the default values when updating a model\n\n    This is done on fields with `on_update=<value>`.\n    \"\"\"\n\n    fields = model.get_fields_with_prop('on_update')\n\n    for field in fields:\n        props[field[0]] = field[1]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _from_rest_reject_update(model):\n\n    dirty = model.dirty_fields\n    fields = model.get_fields_by_prop('reject_update', True)\n    reject = []\n\n    for field in fields:\n        if field in dirty:\n            reject.append(field)\n\n    if reject:\n        mod_fail('These fields cannot be updated: %s' % ', '.join(reject))", "response": "Reject any field updates not allowed on POST\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_rest(model, props):\n\n    req = goldman.sess.req\n\n    _from_rest_blank(model, props)\n    _from_rest_hide(model, props)\n    _from_rest_ignore(model, props)\n    _from_rest_lower(model, props)\n\n    if req.is_posting:\n        _from_rest_on_create(model, props)\n    elif req.is_patching:\n        _from_rest_on_update(model, props)\n\n    model.merge(props, validate=True)\n\n    if req.is_patching:\n        _from_rest_reject_update(model)", "response": "Map the REST data onto the current object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove fields not allowed during a REST serialization", "response": "def _to_rest_hide(model, props):\n    \"\"\" Purge fields not allowed during a REST serialization\n\n    This is done on fields with `to_rest=False`.\n    \"\"\"\n\n    hide = model.get_fields_by_prop('to_rest', False)\n\n    for field in hide:\n        try:\n            del props[field]\n        except KeyError:\n            continue"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _to_rest_includes(models, includes):\n\n    included = []\n    includes = includes or []\n\n    if not isinstance(models, list):\n        models = [models]\n\n    for include in includes:\n        for model in models:\n            rel = getattr(model, include)\n\n            if hasattr(rel, 'model') and rel.model:\n                rel_models = [rel.model]\n            elif hasattr(rel, 'models') and rel.models:\n                rel_models = rel.models\n\n            for rel_model in rel_models:\n                if rel_model in models or rel_model in included:\n                    continue\n                else:\n                    included.append(rel_model)\n\n    for idx, val in enumerate(included):\n        included[idx] = _to_rest(val)\n\n    return included", "response": "Convert the models to the restified version of the includes"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _to_rest_rels(model, props):\n\n    props['to_many'] = {}\n    props['to_one'] = {}\n\n    for key in model.to_one:\n        try:\n            props['to_one'][key] = props.pop(key)\n        except KeyError:\n            continue\n\n    for key in model.to_many:\n        try:\n            props['to_many'][key] = props.pop(key)\n        except KeyError:\n            continue", "response": "Move the relationships to appropriate location in the props"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a model into a dict for serialization", "response": "def _to_rest(model, includes=None):\n    \"\"\" Convert the model into a dict for serialization\n\n    Notify schematics of the sparse fields requested while\n    also forcing the resource id & resource type fields to always\n    be present no matter the request. Additionally, any includes\n    are implicitly added as well & automatically loaded.\n\n    Then normalize the includes, hide private fields, & munge\n    the relationships into a format the serializers are\n    expecting.\n    \"\"\"\n\n    includes = includes or []\n    sparse = goldman.sess.req.fields.get(model.rtype, [])\n\n    if sparse:\n        sparse += [model.rid_field, model.rtype_field]\n        sparse += includes\n\n    props = model.to_primitive(\n        load_rels=includes,\n        sparse_fields=sparse,\n    )\n\n    props['rid'] = props.pop(model.rid_field)\n    props['rtype'] = props.pop(model.rtype_field)\n\n    _to_rest_hide(model, props)\n    _to_rest_rels(model, props)\n\n    return props"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_rest_model(model, includes=None):\n\n    props = {}\n    props['data'] = _to_rest(model, includes=includes)\n    props['included'] = _to_rest_includes(model, includes=includes)\n\n    return props", "response": "Convert the single model into a dict for serialization"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_rest_models(models, includes=None):\n\n    props = {}\n    props['data'] = []\n\n    for model in models:\n        props['data'].append(_to_rest(model, includes=includes))\n\n    props['included'] = _to_rest_includes(models, includes=includes)\n\n    return props", "response": "Convert the models into a dict for serialization\n    models should be an array of single model objects that can be serialized."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting proxy for chrome session", "response": "def set_proxy(self, proxy, update=True):\n        \"\"\"\n        Set proxy for chrome session\n        \"\"\"\n        update_web_driver = False\n        if self.current_proxy != proxy:\n            # Did we change proxies?\n            update_web_driver = True\n\n        self.current_proxy = proxy\n        if proxy is None:\n            # TODO: Need to be able to remove a proxy if one is set\n            pass\n        else:\n            proxy_parts = cutil.get_proxy_parts(proxy)\n\n            if proxy_parts.get('user') is not None:\n                # Proxy has auth, create extension to add to driver\n                self.opts.add_extension(self._proxy_extension(proxy_parts))\n            else:\n                # Use the full proxy address passed in\n                self.opts.add_argument('--proxy-server={}'.format(proxy))\n\n        # Recreate webdriver with new proxy settings\n        if update_web_driver is True:\n            self._update()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _create_session(self):\n        self.driver = webdriver.Chrome(chrome_options=self.opts, **self.driver_args)\n        self.driver.set_window_size(1920, 1080)", "response": "Creates a fresh session with no default headers and proxies"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reset(self):\n        # Kill old connection\n        self.quit()\n        # Clear chrome configs\n        self.opts = webdriver.ChromeOptions()\n        # Create new web driver\n        self._create_session()", "response": "Reset chrome session and create new one"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _proxy_extension(self, proxy_parts):\n        import zipfile\n        manifest_json = \"\"\"\n                        {\n                            \"version\": \"1.0.0\",\n                            \"manifest_version\": 2,\n                            \"name\": \"Chrome Proxy\",\n                            \"permissions\": [\n                                \"proxy\",\n                                \"tabs\",\n                                \"unlimitedStorage\",\n                                \"storage\",\n                                \"<all_urls>\",\n                                \"webRequest\",\n                                \"webRequestBlocking\"\n                            ],\n                            \"background\": {\n                                \"scripts\": [\"background.js\"]\n                            },\n                            \"minimum_chrome_version\":\"22.0.0\"\n                        }\n                        \"\"\"\n\n        background_js = \"\"\"\n                        var config = {{\n                                mode: \"fixed_servers\",\n                                rules: {{\n                                  singleProxy: {{\n                                    scheme: \"{schema}\",\n                                    host: \"{host}\",\n                                    port: parseInt({port})\n                                  }},\n                                  bypassList: []\n                                }}\n                              }};\n\n                        chrome.proxy.settings.set({{value: config, scope: \"regular\"}}, function() {{}});\n\n                        function callbackFn(details) {{\n                            return {{\n                                authCredentials: {{\n                                    username: \"{user}\",\n                                    password: \"{password}\"\n                                }}\n                            }};\n                        }}\n\n                        chrome.webRequest.onAuthRequired.addListener(\n                                    callbackFn,\n                                    {{urls: [\"<all_urls>\"]}},\n                                    ['blocking']\n                        );\n                        \"\"\".format(**proxy_parts)\n\n        plugin_file = 'proxy_auth_plugin.zip'\n        with zipfile.ZipFile(plugin_file, 'w') as zp:\n            zp.writestr(\"manifest.json\", manifest_json)\n            zp.writestr(\"background.js\", background_js)\n\n        return plugin_file", "response": "Creates a chrome extension for the proxy"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates modheaders extension Source: https://vimmaniac.com/blog/bangal/modify-and-add-custom-headers-in-selenium-chrome-driver/ kwargs: remove_headers (list): headers name to remove add_or_modify_headers (dict): ie. {\"Header-Name\": \"Header Value\"} return str -> plugin path", "response": "def _header_extension(self, remove_headers=[], add_or_modify_headers={}):\n        \"\"\"Create modheaders extension\n\n        Source: https://vimmaniac.com/blog/bangal/modify-and-add-custom-headers-in-selenium-chrome-driver/\n\n        kwargs:\n            remove_headers (list): headers name to remove\n            add_or_modify_headers (dict): ie. {\"Header-Name\": \"Header Value\"}\n\n        return str -> plugin path\n        \"\"\"\n        import string\n        import zipfile\n\n        plugin_file = 'custom_headers_plugin.zip'\n\n        if remove_headers is None:\n            remove_headers = []\n\n        if add_or_modify_headers is None:\n            add_or_modify_headers = {}\n\n        if isinstance(remove_headers, list) is False:\n            logger.error(\"remove_headers must be a list\")\n            return None\n\n        if isinstance(add_or_modify_headers, dict) is False:\n            logger.error(\"add_or_modify_headers must be dict\")\n            return None\n\n        # only keeping the unique headers key in remove_headers list\n        remove_headers = list(set(remove_headers))\n\n        manifest_json = \"\"\"\n                        {\n                            \"version\": \"1.0.0\",\n                            \"manifest_version\": 2,\n                            \"name\": \"Chrome HeaderModV\",\n                            \"permissions\": [\n                                \"webRequest\",\n                                \"tabs\",\n                                \"unlimitedStorage\",\n                                \"storage\",\n                                \"<all_urls>\",\n                                \"webRequestBlocking\"\n                            ],\n                            \"background\": {\n                                \"scripts\": [\"background.js\"]\n                            },\n                            \"minimum_chrome_version\":\"22.0.0\"\n                        }\n                        \"\"\"\n\n        background_js = string.Template(\"\"\"\n                                        function callbackFn(details) {\n                                            var remove_headers = ${remove_headers};\n                                            var add_or_modify_headers = ${add_or_modify_headers};\n\n                                            function inarray(arr, obj) {\n                                                return (arr.indexOf(obj) != -1);\n                                            }\n\n                                            // remove headers\n                                            for (var i = 0; i < details.requestHeaders.length; ++i) {\n                                                if (inarray(remove_headers, details.requestHeaders[i].name)) {\n                                                    details.requestHeaders.splice(i, 1);\n                                                    var index = remove_headers.indexOf(5);\n                                                    remove_headers.splice(index, 1);\n                                                }\n                                                if (!remove_headers.length) break;\n                                            }\n\n                                            // modify headers\n                                            for (var i = 0; i < details.requestHeaders.length; ++i) {\n                                                if (add_or_modify_headers.hasOwnProperty(details.requestHeaders[i].name)) {\n                                                    details.requestHeaders[i].value = add_or_modify_headers[details.requestHeaders[i].name];\n                                                    delete add_or_modify_headers[details.requestHeaders[i].name];\n                                                }\n                                            }\n\n                                            // add modify\n                                            for (var prop in add_or_modify_headers) {\n                                                details.requestHeaders.push(\n                                                    {name: prop, value: add_or_modify_headers[prop]}\n                                                );\n                                            }\n\n                                            return {requestHeaders: details.requestHeaders};\n                                        }\n\n                                        chrome.webRequest.onBeforeSendHeaders.addListener(\n                                                    callbackFn,\n                                                    {urls: [\"<all_urls>\"]},\n                                                    ['blocking', 'requestHeaders']\n                                        );\n                                        \"\"\"\n                                        ).substitute(remove_headers=remove_headers,\n                                                     add_or_modify_headers=add_or_modify_headers,\n                                                     )\n\n        with zipfile.ZipFile(plugin_file, 'w') as zp:\n            zp.writestr(\"manifest.json\", manifest_json)\n            zp.writestr(\"background.js\", background_js)\n\n        return plugin_file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_file(self, input_file):\n        pyimg = imp.load_source('image2py_taf', input_file)\n        self.files = pyimg.data\n        self.set_template(templates.templateByName(pyimg.template))", "response": "Loads data array from file"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the template to be used when generating output", "response": "def set_template(self, template):\n        \"\"\" Sets template to be used when generating output\n\n        :param template TEmplate instance\n        :type instance of BasicTemplate\n        \"\"\"\n        if isinstance(template, templates.BasicTemplate):\n            self.template = template\n        else:\n            raise TypeError('converter#set_template:'\n                            'Template must inherit from BasicTemplate')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates output and saves to given file", "response": "def save(self, filename=None):\n        \"\"\" Generates output and saves to given file\n\n        :param filename File name\n        :type str or unicode\n        \"\"\"\n        if filename is None:\n            raise IOError('Converter#save: Undefined filename')\n        cnt = self.output()\n        with (open(filename, 'wb+')) as f:\n            f.write(cnt.encode('utf-8'))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads and add given file to data array that will be used to generate output", "response": "def add_file(self, filename):\n        \"\"\" Read and adds given file's content to data array\n        that will be used to generate output\n\n        :param filename File name to add\n        :type str or unicode\n        \"\"\"\n        with (open(filename, 'rb')) as f:\n            data = f.read()\n        # below won't handle the same name files\n        # in different paths\n        fname = os.path.basename(filename)\n        self.files[fname] = base64.b64encode(data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating output from data array", "response": "def output(self):\n        \"\"\" Generates output from data array\n\n        :returns Pythoned file\n        :rtype str or unicode\n        \"\"\"\n        if len(self.files) < 1:\n            raise Exception('Converter#output: No files to convert')\n        return self.template.render(self.files)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if filepath matches any of the patterns.", "response": "def match(self, filepath):\n        \"\"\"\n        The function to check file.\n        Should return True if match, False otherwise.\n        \"\"\"\n        for pattern in self.__pattern:\n            if len(fnmatch.filter([filepath], pattern)) > 0:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the contents of the current screen.", "response": "def update(self):\n        \"\"\"\n        Update the screens contents in every loop.\n        \"\"\"\n        # this is not really neccesary because the surface is black after initializing\n        self.corners.fill(BLACK)\n        self.corners.draw_dot((0, 0), self.colors[0])\n        self.corners.draw_dot((self.screen.width - 1, 0), self.colors[0])\n        self.corners.draw_dot((self.screen.width - 1, self.screen.height - 1),\n                              self.colors[0])\n        self.corners.draw_dot((0, self.screen.height - 1), self.colors[0])\n\n        self.lines.fill(BLACK)\n        self.lines.draw_line((1, 0), (self.lines.width - 1, 0), self.colors[1])\n        self.lines.draw_line((0, 1), (0, self.lines.height - 1), self.colors[3])\n        self.lines.draw_line((0, 0), (self.lines.width - 1,\n                                      self.lines.height - 1), self.colors[2])\n\n        self.rects.fill(BLACK)\n        self.rects.draw_rect((0, 0), (int(self.rects.width / 2) - 1,\n                                      self.rects.height),\n                             self.colors[2], self.colors[3])\n        self.rects.draw_rect((int(self.rects.width / 2) + 1, 0),\n                             (int(self.rects.width / 2) - 1,\n                              self.rects.height),\n                             self.colors[3], self.colors[2])\n\n        self.circle.fill(BLACK)\n        radius = int(min(self.circle.width, self.circle.height) / 2) - 1\n        self.circle.draw_circle((int(self.circle.width / 2) - 1,\n                                 int(self.circle.height / 2) - 1), radius,\n                                self.colors[4], self.colors[5])\n\n        self.filled.fill(self.colors[6])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends the current screen content to Mate Light.", "response": "def render(self):\n        \"\"\"\n        Send the current screen content to Mate Light.\n        \"\"\"\n        self.screen.reset()\n        self.screen.blit(self.corners)\n        self.screen.blit(self.lines, (1, 1))\n        self.screen.blit(self.rects, (int(self.screen.width / 2) + 1, 1))\n        self.screen.blit(self.circle, (0, int(self.screen.height / 2) + 1))\n        self.screen.blit(self.filled, (int(self.screen.width / 2) + 1,\n                                       int(self.screen.height / 2) + 1))\n\n        self.screen.update()\n        self.clock.tick()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef handle_events(self):\n        for event in pymlgame.get_events():\n            if event.type == E_NEWCTLR:\n                #print(datetime.now(), '### new player connected with uid', event.uid)\n                self.players[event.uid] = {'name': 'alien_{}'.format(event.uid), 'score': 0}\n            elif event.type == E_DISCONNECT:\n                #print(datetime.now(), '### player with uid {} disconnected'.format(event.uid))\n                self.players.pop(event.uid)\n            elif event.type == E_KEYDOWN:\n                #print(datetime.now(), '###', self.players[event.uid]['name'], 'pressed', event.button)\n                self.colors.append(self.colors.pop(0))\n            elif event.type == E_KEYUP:\n                #print(datetime.now(), '###', self.players[event.uid]['name'], 'released', event.button)\n                self.colors.append(self.colors.pop(0))\n            elif event.type == E_PING:\n                #print(datetime.now(), '### ping from', self.players[event.uid]['name'])\n                pass", "response": "Loop through all events and add them to the internal list of available player objects."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprocesses the request after routing.", "response": "def process_resource(self, req, resp, resource):\n        \"\"\" Process the request after routing.\n\n        The resource is required to determine if a model based\n        resource is being used for validations so skip\n        processing if no `resource.model` attribute is present.\n        \"\"\"\n\n        try:\n            model = resource.model\n\n            req.fields = fields.init(req, model)\n            req.filters = filters.init(req, model)\n            req.includes = includes.init(req, model)\n            req.pages = pages.init(req, model)\n            req.sorts = sorts.init(req, model)\n        except AttributeError:\n            pass\n        except InvalidQueryParams as exc:\n            abort(exc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets all comments for a specific locale.", "response": "def get_all_comments(self):\n        \"\"\" :pagination_param: 'page_number', 'page_size'\n        \"\"\"\n        return bind_api(\n            api=self,\n            path='/comments',\n            payload_type='comment',\n            payload_list=True,\n            pagination_param=['page_number', 'page_size']\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the iaaS icaas in review.", "response": "def get_ideas_in_review(self, **kwargs):\n        \"\"\" :pagination_param: 'page_number', 'page_size', 'order_key'\n        \"\"\"\n        return bind_api(\n            api=self,\n            path='/ideas/inreview',\n            payload_type='idea',\n            payload_list=True,\n            pagination_param=['page_number', 'page_size', 'order_key']\n        )(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_idea(self, *args, **kwargs):\n        kwargs.update({'headers': {'content-type':'application/json'}})\n        return bind_api(\n            api=self,\n            path='/idea',\n            method='POST',\n            payload_type='idea',\n            post_param=['title', 'text', 'campaignId', 'tags', 'customFields']\n        )(*args, **kwargs)", "response": ":allowed_param: 'title', 'text', 'campaignId', 'tags' (optional), 'customFields' (optional)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nattaching a file to an existing IDA.", "response": "def attach_file_to_idea(self, filename, *args, **kwargs):\n        \"\"\" :allowed_param: ideaId\n        \"\"\"\n        kwargs.update({'file': {'attachment': open(filename, 'rb')}})\n        return bind_api(\n            api=self,\n            path='/ideas/{ideaId}/attach',\n            method='POST',\n            payload_type='idea',\n            allowed_param=['ideaId']\n        )(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nvote up an ica", "response": "def vote_up_idea(self, *args, **kwargs):\n        \"\"\" :allowed_param: 'ideaId', 'myVote' (optional)\n        \"\"\"\n        kwargs.update({'headers': {'content-type':'application/json'}})\n        return bind_api(\n            api=self,\n            path='/ideas/{ideaId}/vote/up',\n            method='POST',\n            payload_type='vote',\n            allowed_param=['ideaId'],\n            post_param=['myVote']\n        )(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_comment(self, *args, **kwargs):\n        return bind_api(\n            api=self,\n            path='/comments/{commentId}/delete',\n            method='DELETE',\n            payload_type='comment',\n            allowed_param=['commentId']\n        )(*args, **kwargs)", "response": "Delete a comment from the specified resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the votes of a specific comment.", "response": "def get_votes_comment(self, *args, **kwargs):\n        \"\"\" :allowed_param: 'commentId'\n        \"\"\"\n        return bind_api(\n            api=self,\n            path='/comments/{commentId}/votes',\n            payload_type='vote',\n            payload_list=True,\n            allowed_param=['commentId']\n        )(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_member_info_by_email(self, *args, **kwargs):\n        return bind_api(\n            api=self,\n            path='/members/email/{email}',\n            payload_type='author',\n            allowed_param=['email']\n        )(*args, **kwargs)", "response": "Get member info by email."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the members ica as a list of dictionaries.", "response": "def get_member_ideas(self, *args, **kwargs):\n        \"\"\" :allowed_param: 'memberId'\n            :pagination_param: 'page_number', 'page_size'\n        \"\"\"\n        return bind_api(\n            api=self,\n            path='/members/{memberId}/ideas',\n            payload_type='idea',\n            payload_list=True,\n            allowed_param=['memberId'],\n            pagination_param=['page_number', 'page_size']\n        )(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef logWrite(self, string):\n\t\tlogFile = open(self.logFile, 'at')\n\t\tlogFile.write(string + '\\n')\n\t\tlogFile.close()", "response": "Only write text to the log file do not print"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets up the logging file for a new session- include date and some whitespace", "response": "def setupLogFile(self):\n\t\t\"\"\"Set up the logging file for a new session- include date and some whitespace\"\"\"\n\t\tself.logWrite(\"\\n###############################################\")\n\t\tself.logWrite(\"calcpkg.py log from \" + str(datetime.datetime.now()))\n\t\tself.changeLogging(True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getLoggingLocation(self):\n\t\tif sys.platform == \"win32\":\n\t\t\tmodulePath = os.path.realpath(__file__)\n\t\t\tmodulePath = modulePath[:modulePath.rfind(\"/\")]\n\t\t\treturn modulePath\n\t\telse:\n\t\t\treturn \"/tmp\"\n\t\treturn \"\"", "response": "Return the path for the calcpkg. log file - at the moment only use a Linux path since I don t know where Windows thinks logs should go."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef twitter_timeline(screen_name, since_id=None):\n    consumer_key = twitter_credential('consumer_key')\n    consumer_secret = twitter_credential('consumer_secret')\n    access_token = twitter_credential('access_token')\n    access_token_secret = twitter_credential('access_secret')\n    auth = tweepy.OAuthHandler(consumer_key, consumer_secret)\n    auth.set_access_token(access_token, access_token_secret)\n    api = tweepy.API(auth)\n    return get_all_tweets(screen_name, api, since_id)", "response": "Return relevant twitter timeline"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget all tweets for the givens screen_name. Returns list of text and created_at pairs.", "response": "def get_all_tweets(screen_name, api, since_id):\n    \"\"\" Get all tweets for the givens screen_name. Returns list of text/created_at pairs. \"\"\"\n    # Twitter only allows access to a users most recent 3240 tweets with this method\n    all_tweets = []\n    # initial request for most recent tweets (200 is the maximum allowed count)\n    new_tweets = api.user_timeline(screen_name=screen_name, count=200, since_id=since_id)\n    all_tweets.extend(new_tweets)\n    if len(all_tweets) == 0:\n        raise Exception(\"tweets up to date for screen_name: %s\" % (screen_name))\n    oldest = all_tweets[-1].id - 1\n    while len(new_tweets) > 0:\n        print(\"getting tweets before %s\" % (oldest))\n        new_tweets = api.user_timeline(screen_name=screen_name, count=200, max_id=oldest, since_id=since_id)\n        all_tweets.extend(new_tweets)\n        oldest = all_tweets[-1].id - 1\n        print(\"...%s tweets downloaded so far\" % (len(all_tweets)))\n    return [tweet.text.encode(\"utf-8\") for tweet in all_tweets], all_tweets[0].id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngrabbing twitter credential from settings", "response": "def twitter_credential(name):\n    \"\"\" Grab twitter credential from settings \"\"\"\n    credential_name = 'TWITTER_' + name.upper()\n    if hasattr(settings, credential_name):\n        return getattr(settings, credential_name)\n    else:\n        raise AttributeError('Missing twitter credential in settings: ' + credential_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_slug(obj, text, tail_number=0):\n    from panya.models import ModelBase\n    \"\"\"\n    Returns a new unique slug. Object must provide a SlugField called slug.\n    URL friendly slugs are generated using django.template.defaultfilters' slugify.\n    Numbers are added to the end of slugs for uniqueness.\n    \"\"\"\n    # use django slugify filter to slugify\n    slug = slugify(text)\n    \n    existing_slugs = [item.slug for item in ModelBase.objects.filter(slug__regex=r'^%s(-\\d+)?' % slug).exclude(id=obj.id)]\n    \n    tail_number = 0\n    new_slug = slug\n    while new_slug in existing_slugs:\n        new_slug = slugify(\"%s-%s\" % (slug, tail_number))\n        tail_number += 1\n    \n    return new_slug", "response": "Generate a unique slug for the given object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef modify_class(original_class, modifier_class, override=True):\n    # get members to add\n    modifier_methods = inspect.getmembers(modifier_class, inspect.ismethod)\n    \n    # set methods\n    for method_tuple in modifier_methods:\n        name = method_tuple[0]\n        method = method_tuple[1]\n        if isinstance(method, types.UnboundMethodType):\n            if hasattr(original_class, name) and not override:\n                return None\n            else:\n                setattr(original_class, name, method.im_func)", "response": "Modify the original_class by adding class methods from modifier_class to original_class."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_query(query_string, search_fields):\n    query = None # Query to search for every search term        \n    terms = normalize_query(query_string)\n    for term in terms:\n        or_query = None # Query to search for a given term in each field\n        for field in search_fields:\n            q = Q(**{\"%s__%s\" % (field[0], field[1]): term})\n            if or_query is None:\n                or_query = q\n            else:\n                or_query = or_query | q\n        if query is None:\n            query = or_query\n        else:\n            query = query & or_query\n    return query", "response": "Returns a query that can be used to search for a given search term in a given list of search fields."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef format_datetime(date):\n    # todo: test me\n    if date.utcoffset() is None:\n        return date.isoformat() + 'Z'\n\n    utc_offset_sec = date.utcoffset()\n    utc_date = date - utc_offset_sec\n    utc_date_without_offset = utc_date.replace(tzinfo=None)\n    return utc_date_without_offset.isoformat() + 'Z'", "response": "Convert datetime to UTC ISO 8601"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_emails(self, mailinglist_dir, all, exclude_lists):\n        self.log(\"Getting emails dumps from: %s\" % mailinglist_dir)\n\n        # Get the list of directories ending with .mbox\n        mailing_lists_mboxes = (mbox for mbox in os.listdir(mailinglist_dir)\n                                if mbox.endswith('.mbox'))\n\n        # Get messages from each mbox\n        for mbox in mailing_lists_mboxes:\n            mbox_path = os.path.join(mailinglist_dir, mbox, mbox)\n            mailinglist_name = mbox.split('.')[0]\n\n            # Check if the mailinglist is set not to be imported\n            if exclude_lists and mailinglist_name in exclude_lists:\n                continue\n\n            # Find the index of the last imported message\n            if all:\n                n_msgs = 0\n            else:\n                try:\n                    mailinglist = MailingList.objects.get(\n                        name=mailinglist_name\n                    )\n                    n_msgs = mailinglist.last_imported_index\n                except MailingList.DoesNotExist:\n                    n_msgs = 0\n\n            for index, msg in self.parse_emails(mbox_path, n_msgs):\n                yield mailinglist_name, msg, index", "response": "Generator function that returns the emails from each mailinglist in the mailinglist_dir."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngroups messages by thread looking for similar subjects", "response": "def get_thread(self, email, mailinglist):\n        \"\"\"Group messages by thread looking for similar subjects\"\"\"\n\n        subject_slug = slugify(email.subject_clean)\n        thread = self.THREAD_CACHE.get(subject_slug, {}).get(mailinglist.id)\n        if thread is None:\n            thread = Thread.all_objects.get_or_create(\n                mailinglist=mailinglist,\n                subject_token=subject_slug\n            )[0]\n\n            if self.THREAD_CACHE.get(subject_slug) is None:\n                self.THREAD_CACHE[subject_slug] = dict()\n            self.THREAD_CACHE[subject_slug][mailinglist.id] = thread\n\n        thread.latest_message = email\n        thread.update_keywords()\n        thread.save()\n        return thread"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save_email(self, list_name, email_msg, index):\n\n        msg_id = email_msg.get('Message-ID')\n        if not msg_id:\n            return\n\n        # Update last imported message into the DB\n        mailinglist, created = MailingList.objects.get_or_create(\n            name=list_name\n        )\n        mailinglist.last_imported_index = index\n\n        if created:\n            # if the mailinglist is newly created it's sure that the message\n            #   is not in the DB yet.\n            self.create_email(mailinglist, email_msg)\n\n        else:\n            # If the message is already at the database don't do anything\n            try:\n                Message.all_objects.get(\n                    message_id=msg_id,\n                    thread__mailinglist=mailinglist\n                )\n\n            except Message.DoesNotExist:\n                self.create_email(mailinglist, email_msg)\n\n        mailinglist.save()", "response": "Save an email message into the database."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef import_emails(self, archives_path, all, exclude_lists=None):\n\n        count = 0\n        email_generator = self.get_emails(archives_path, all, exclude_lists)\n        for mailinglist_name, msg, index in email_generator:\n            try:\n                self.save_email(mailinglist_name, msg, index)\n            except:\n                # This anti-pattern is needed to avoid the transations to\n                #   get stuck in case of errors.\n                transaction.rollback()\n                raise\n\n            count += 1\n            if count % 1000 == 0:\n                transaction.commit()\n\n        transaction.commit()", "response": "Get emails from the filesystem from the archives_path and store them into the database."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_managers(sender, **kwargs):\n    cls = sender\n   \n    if issubclass(cls, ModelBase):\n        cls.add_to_class('permitted', PermittedManager())", "response": "Set the managers for the given object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the class of the calling instance as a leaf class.", "response": "def as_leaf_class(self):\n        \"\"\"\n        Returns the leaf class no matter where the calling instance is in the inheritance hierarchy.\n        Inspired by http://www.djangosnippets.org/snippets/1031/\n        \"\"\"\n        try:\n            return self.__getattribute__(self.class_name.lower())\n        except AttributeError:\n            content_type = self.content_type\n            model = content_type.model_class()\n            if(model == ModelBase):\n                return self\n            return model.objects.get(id=self.id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef can_vote(self, request):\n        modelbase_obj = self.modelbase_obj\n\n        # can't vote if liking is closed\n        if modelbase_obj.likes_closed:\n            return False, 'closed'\n        \n        # can't vote if liking is disabled\n        if not modelbase_obj.likes_enabled:\n            return False, 'disabled'\n\n        # anonymous users can't vote if anonymous likes are disabled\n        if not request.user.is_authenticated() and not modelbase_obj.anonymous_likes:\n            return False, 'auth_required'\n          \n        # return false if existing votes are found\n        if Vote.objects.filter(object_id=modelbase_obj.id, token=request.secretballot_token).count() == 0:\n            return True, 'can_vote'\n        else:\n            return False, 'voted'", "response": "Returns a bool indicating whether or not the current user can vote."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the total number of votes for this object.", "response": "def vote_total(self):\n        \"\"\"\n        Calculates vote total as total_upvotes - total_downvotes. We are adding a method here instead of relying on django-secretballot's addition since that doesn't work for subclasses.\n        \"\"\"\n        modelbase_obj = self.modelbase_obj\n        return modelbase_obj.votes.filter(vote=+1).count() - modelbase_obj.votes.filter(vote=-1).count()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef comment_count(self):\n        # Get the comment model.\n        comment_model = comments.get_model()\n\n        modelbase_content_type = ContentType.objects.get(app_label=\"panya\", model=\"modelbase\")\n\n        # Create a qs filtered for the ModelBase or content_type objects.\n        qs = comment_model.objects.filter(\n            content_type__in = [self.content_type, modelbase_content_type],\n            object_pk    = smart_unicode(self.pk),\n            site__pk     = settings.SITE_ID,\n        )\n\n        # The is_public and is_removed fields are implementation details of the\n        # built-in comment model's spam filtering system, so they might not\n        # be present on a custom comment model subclass. If they exist, we\n        # should filter on them.\n        field_names = [f.name for f in comment_model._meta.fields]\n        if 'is_public' in field_names:\n            qs = qs.filter(is_public=True)\n        if getattr(settings, 'COMMENTS_HIDE_REMOVED', True) and 'is_removed' in field_names:\n            qs = qs.filter(is_removed=False)\n\n        # Return ammount of items in qs.\n        return qs.count()", "response": "Counts the number of comments on the object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate_syzygy(self, input_word):\n        results = []\n        synset = wordnet.synsets(input_word)\n        for i in synset:\n            if i.hypernyms():\n                hyp = i.hypernyms()[0].name.split('.')\n                if '_' in hyp[0]:\n                    hyp[0] = PataLib().strip_underscore(hyp[0])\n                syns = wordnet.synsets(hyp[0])\n                if len(syns) > 0:\n                    name = syns[0].name.split('.')[0]\n                    results.append(PataLib().strip_underscore(name))\n        results = {'input' : input_word, 'results' : results, 'category' : 'syzygy'} \n        return results", "response": "Generate a list of hypernyms associated with a word and generate a list of hypernyms associated with a word."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndeploy a lambda function", "response": "def deploy_lambda(collector):\n    \"\"\"Deploy a lambda function\"\"\"\n    amazon = collector.configuration['amazon']\n    aws_syncr = collector.configuration['aws_syncr']\n    find_lambda_function(aws_syncr, collector.configuration).deploy(aws_syncr, amazon)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeploys the apigateway to a particular stage", "response": "def deploy_gateway(collector):\n    \"\"\"Deploy the apigateway to a particular stage\"\"\"\n    configuration = collector.configuration\n    aws_syncr = configuration['aws_syncr']\n    aws_syncr, amazon, stage, gateway = find_gateway(aws_syncr, configuration)\n    gateway.deploy(aws_syncr, amazon, stage)\n\n    if not configuration['amazon'].changes:\n        log.info(\"No changes were made!!\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sync_and_deploy_gateway(collector):\n    configuration = collector.configuration\n    aws_syncr = configuration['aws_syncr']\n    find_gateway(aws_syncr, configuration)\n\n    artifact = aws_syncr.artifact\n    aws_syncr.artifact = \"\"\n    sync(collector)\n\n    aws_syncr.artifact = artifact\n    deploy_gateway(collector)", "response": "Do a sync followed by deploying the gateway"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites encrypted values for your certificate to the configuration", "response": "def encrypt_certificate(collector):\n    \"\"\"Write encrypted values for your certificate to the configuration\"\"\"\n    configuration = collector.configuration\n    amazon = configuration['amazon']\n    aws_syncr = configuration['aws_syncr']\n    certificate = aws_syncr.artifact\n\n    available = []\n\n    for gateway_name, gateway in configuration.get('apigateway', {}, ignore_converters=True).items():\n        for name, options in gateway.get(\"domain_names\", {}).items():\n            if \"zone\" in options:\n                location = '.'.join(['apigateway', gateway_name, 'domain_names'])\n                formatter = MergedOptionStringFormatter(configuration, location, value=options['zone'])\n                available.append((gateway_name, \"{0}.{1}\".format(name, formatter.format())))\n\n    if not available:\n        raise AwsSyncrError(\"Please specify apigateway.<gateway_name>.domain_names.<domain_name>.name in the configuration\")\n\n    if not certificate:\n        raise AwsSyncrError(\"Please specify certificate to encrypt with --artifact\", available=[a[1] for a in available])\n\n    if certificate not in [a[1] for a in available]:\n        raise AwsSyncrError(\"Unknown certificate\", available=[a[1] for a in available], got=certificate)\n\n    gateway = [name for name, cert in available if cert == certificate][0]\n    location, source = find_certificate_source(configuration, gateway, certificate)\n\n    log.info(\"Gonna edit {0} in {1}\".format(location, source))\n    current = MergedOptions.using(yaml.load(open(source)))\n    dest = current[location]\n\n    try:\n        key_id = input(\"Which kms key do you want to use? \")\n        region = input(\"What region is this key in? \")\n    except EOFError:\n        raise UserQuit()\n\n    # Make the filename completion work\n    setup_completer()\n\n    # Create the datakey to encrypt with\n    data_key = amazon.kms.generate_data_key(region, key_id)\n    plaintext_data_key = data_key[\"Plaintext\"]\n    encrypted_data_key = base64.b64encode(data_key[\"CiphertextBlob\"]).decode('utf-8')\n\n    # Encrypt our secrets\n    secrets = {}\n    for name, desc in ((\"body\", \"certificate's crt file\"), (\"key\", \"private key file\"), (\"chain\", \"certificate chain\")):\n        location = None\n        while not location or not os.path.isfile(location):\n            location = os.path.expanduser(filename_prompt(\"Where is the {0}? \".format(desc)))\n            if not location or not os.path.isfile(location):\n                print(\"Please give a location to a file that exists!\")\n\n        with open(location, 'rb') as fle:\n            data = fle.read()\n\n        counter = Counter.new(128)\n        encryptor = AES.new(plaintext_data_key[:32], AES.MODE_CTR, counter=counter)\n        secrets[name] = base64.b64encode(encryptor.encrypt(data)).decode('utf-8')\n\n    # Add in the encrypted values\n    dest['body'] = {\"kms\": secrets['body'], \"location\": region, \"kms_data_key\": encrypted_data_key}\n    dest['key'] = {\"kms\": secrets['key'], \"location\": region, \"kms_data_key\": encrypted_data_key}\n    dest['chain'] = {\"kms\": secrets['chain'], \"location\": region, \"kms_data_key\": encrypted_data_key}\n\n    # And write to the file!\n    yaml.dump(current.as_dict(), open(source, 'w'), explicit_start=True, indent=2, default_flow_style=False)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexecute a command as an assumed role", "response": "def execute_as(collector):\n    \"\"\"Execute a command (after the --) as an assumed role (specified by --artifact)\"\"\"\n    # Gonna assume role anyway...\n    collector.configuration['amazon']._validated = True\n\n    # Find the arn we want to assume\n    account_id = collector.configuration['accounts'][collector.configuration['aws_syncr'].environment]\n    arn = \"arn:aws:iam::{0}:role/{1}\".format(account_id, collector.configuration['aws_syncr'].artifact)\n\n    # Determine the command to run\n    parts = shlex.split(collector.configuration[\"aws_syncr\"].extra)\n    if not parts:\n        suggestion = \" \".join(sys.argv) + \" -- /path/to/command_to_run\"\n        msg = \"No command was provided. Try something like:\\n\\t\\t{0}\".format(suggestion)\n        raise AwsSyncrError(msg)\n\n    # Get our aws credentials environment variables from the assumed role\n    env = dict(os.environ)\n    env.update(collector.configuration['amazon'].iam.assume_role_credentials(arn))\n\n    # Turn into the command we want to execute\n    os.execvpe(parts[0], parts, env)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef print_header(self, f=sys.stdout, verbose=False):\n        self.var_count = 2 + len(self.covar_labels)\n\n        if verbose:\n            header = [\n                \"Chr\",\n                \"Pos\",\n                \"RSID\",\n                \"Phenotype\",\n                \"N\",\n                \"Ref_allele\",\n                \"Eff_allele\",\n                \"Eff_Allele_Freq\",\n                \"P-Value\",\n                \"LM_PValue\"\n            ]\n            for var in [\"Intercept\",\"Geno\"] + self.covar_labels:\n                for t in [\"mean\", \"mean_stder\", \"mean_pval\", \"var\", \"var_stder\", \"var_pval\"]:\n                    header.append(\"%s_%s\" % (var.lower(), t))\n            print >> f, \"\\t\".join(header)\n        else:\n            print >> f, \"\\t\".join([\n                \"Chr\",\n                \"Pos\",\n                \"RSID\",\n                \"Phenotype\",\n                \"N\",\n                \"Ref_allele\",\n                \"Eff_allele\",\n                \"Eff_Allele_Freq\",\n                \"P-Value\",\n                \"geno_mean\",\n                \"geno_mean_stderr\",\n                \"geno_mean_pval\",\n                \"geno_var\",\n                \"geno_var_stderr\",\n                \"geno_var_pval\",\n            ])", "response": "Prints the header of the current object to f."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef print_result(self, f=sys.stdout, verbose=False):\n        var_count = len(self.betas)/2\n        if verbose:\n            results = [str(x) for x in [\n                self.chr,\n                self.pos,\n                self.rsid,\n                self.ph_label,\n                self.non_miss,\n                self.maj_allele,\n                self.min_allele,\n                \"%.4e\" % self.eff_alcount,\n                \"%.4e\" % self.p_mvtest,\n                \"%.4e\" % self.lmpv\n            ]]\n\n            for i in range(var_count):\n                results.append(\"%.3e\" % self.betas[i])\n                results.append(self.stringify(self.beta_stderr[i]))\n                results.append(self.stringify(self.beta_pvalues[i]))\n                results.append(self.stringify(self.betas[i+var_count]))\n                results.append(self.stringify(self.beta_stderr[i+var_count]))\n                results.append(self.stringify(self.beta_pvalues[i+var_count]))\n            print >> f, \"\\t\".join([str(x) for x in results])\n\n        else:\n            print >> f, \"\\t\".join(str(x) for x in [\n                self.chr,\n                self.pos,\n                self.rsid,\n                self.ph_label,\n                self.non_miss,\n                self.maj_allele,\n                self.min_allele,\n                \"%.3e\" % self.eff_alcount,\n                \"%.3e\" % self.p_mvtest,\n                \"%.3e\" % self.betas[1],\n                self.stringify(self.beta_stderr[1]),\n                \"%.3e\" % self.beta_pvalues[1],\n                \"%.3e\" % self.betas[1+var_count],\n                self.stringify(self.beta_stderr[1+var_count]),\n                \"%.3e\" % self.beta_pvalues[1+var_count],\n            ])", "response": "Print the result of the current object to f"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate Synonym using a WordNet synset.", "response": "def generate_synonym(self, input_word):\n         \"\"\" Generate Synonym using a WordNet\n         synset.\n         \"\"\"\n         results = []\n         results.append(input_word)\n         synset = wordnet.synsets(input_word)\n         for i in synset:\n             index = 0\n             syn = i.name.split('.')\n             if syn[index]!= input_word:\n                 name = syn[0]\n                 results.append(PataLib().strip_underscore(name))\n             else:\n                 index = index + 1\n         results = {'input' : input_word, 'results' : results, 'category' : 'synonym'} \n         return results"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_canonical(version, loosedev=False):  # type: (str, bool) -> bool\n    if loosedev:\n        return loose440re.match(version) is not None\n    return pep440re.match(version) is not None", "response": "Returns whether or not the version string is canonical according to Pep 440."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef diff(x, y, x_only=False, y_only=False):\n    # Validate both lists, confirm neither are empty\n    if len(x) == 0 and len(y) > 0:\n        return y  # All y values are unique if x is empty\n    elif len(y) == 0 and len(x) > 0:\n        return x  # All x values are unique if y is empty\n    elif len(y) == 0 and len(x) == 0:\n        return []\n\n    # Convert dictionaries to lists of tuples\n    if isinstance(x, dict):\n        x = list(x.items())\n    if isinstance(y, dict):\n        y = list(y.items())\n\n    # Get the input type to convert back to before return\n    try:\n        input_type = type(x[0])\n    except IndexError:\n        input_type = type(y[0])\n\n    # Dealing with a 2D dataset (list of lists)\n    if input_type not in (str, int, float):\n        # Immutable and Unique - Convert list of tuples into set of tuples\n        first_set = set(map(tuple, x))\n        secnd_set = set(map(tuple, y))\n\n    # Dealing with a 1D dataset (list of items)\n    else:\n        # Unique values only\n        first_set = set(x)\n        secnd_set = set(y)\n\n    # Determine which list is longest\n    longest = first_set if len(first_set) > len(secnd_set) else secnd_set\n    shortest = secnd_set if len(first_set) > len(secnd_set) else first_set\n\n    # Generate set of non-shared values and return list of values in original type\n    uniques = {i for i in longest if i not in shortest}\n\n    # Add unique elements from shorter list\n    for i in shortest:\n        if i not in longest:\n            uniques.add(i)\n\n    # Return unique values from x, y or both\n    if x_only:\n        return [input_type(i) for i in uniques if input_type(i) in x]\n    elif y_only:\n        return [input_type(i) for i in uniques if input_type(i) in y]\n    else:\n        return [input_type(i) for i in uniques]", "response": "Return a unique list of elements that do not exist in both x and y."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef decode(data):\n    decoded = None\n    try:\n        decoded = json.loads(data)\n    except Exception, e:\n        raise MetaParsingException(\"Can't parse your JSON data: %s\" % e.message)\n\n    decoded = validator.check_structure(decoded)\n\n    return decoded", "response": "Handles decoding of the JSON data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialize PyMLGame. This creates a controller thread that listens for game controllers and events. :param host: Bind to this address :param port: Bind to this port :type host: str :type port: int", "response": "def init(host='0.0.0.0', port=1338):\n    \"\"\"\n    Initialize PyMLGame. This creates a controller thread that listens for game controllers and events.\n\n    :param host: Bind to this address\n    :param port: Bind to this port\n    :type host: str\n    :type port: int\n    \"\"\"\n    CONTROLLER.host = host\n    CONTROLLER.port = port\n    CONTROLLER.setDaemon(True)  # because it's a deamon it will exit together with the main thread\n    CONTROLLER.start()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets all events since the last time you asked for them.", "response": "def get_events(maximum=10):\n    \"\"\"\n    Get all events since the last time you asked for them. You can define a maximum which is 10 by default.\n\n    :param maximum: Maximum number of events\n    :type maximum: int\n    :return: List of events\n    :rtype: list\n    \"\"\"\n    events = []\n    for ev in range(0, maximum):\n        try:\n            if CONTROLLER.queue.empty():\n                break\n            else:\n                events.append(CONTROLLER.queue.get_nowait())\n        except NameError:\n            print('PyMLGame is not initialized correctly. Use pymlgame.init() first.')\n            events = False\n            break\n    return events"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconsolidate some entry attributes and rename some others.", "response": "def clean_entry(entry):\n    \"\"\"Consolidate some entry attributes and rename a few others.\n\n    Consolidate address attributes into a single field and replace some field\n    names with others as described in FIELD_TRANSFORM_INDEX.\n\n    @param entry: The entry attributes to update.\n    @type entry: dict\n    @return: Entry copy after running clean operations\n    @rtype: dict\n    \"\"\"\n    newEntry = {}\n\n    if 'Address1' in entry:\n        address = str(entry['Address1'])\n        if entry['Address2'] != '':\n            address = address + ' ' + str(entry['Address2'])\n        newEntry['address'] = address\n        del entry['Address1']\n        del entry['Address2']\n\n    for key in entry.keys():\n\n        if key != None:\n        \n            if key in FIELD_TRANSFORM_INDEX:\n                newKey = FIELD_TRANSFORM_INDEX[key]\n            else:\n                newKey = key\n            \n            newKey = newKey[:1].lower() + newKey[1:]\n            newEntry[newKey] = entry[key]\n\n    return newEntry"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates a record of a contribution report in the provided MongoDB database.", "response": "def update_contribution_entry(database, entry):\n    \"\"\"Update a record of a contribution report in the provided database.\n\n    @param database: The MongoDB database to operate on. The contributions\n        collection will be used from this database.\n    @type db: pymongo.database.Database\n    @param entry: The entry to insert into the database, updating the entry with\n        the same recordID if one exists.\n    @type entry: dict\n    \"\"\"\n    entry = clean_entry(entry)\n    database.contributions.update(\n        {'recordID': entry['recordID']},\n        {'$set': entry},\n        upsert=True\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating a record of a expenditure report in the provided database.", "response": "def update_expenditure_entry(database, entry):\n    \"\"\"Update a record of a expenditure report in the provided database.\n\n    @param db: The MongoDB database to operate on. The expenditures collection\n        will be used from this database.\n    @type db: pymongo.database.Database\n    @param entry: The entry to insert into the database, updating the entry with\n        the same recordID if one exists.\n    @type entry: dict\n    \"\"\"\n    entry = clean_entry(entry)\n    database.expenditures.update(\n        {'recordID': entry['recordID']},\n        {'$set': entry},\n        upsert=True\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_loan_entry(database, entry):\n    entry = clean_entry(entry)\n    database.loans.update(\n        {'recordID': entry['recordID']},\n        {'$set': entry},\n        upsert=True\n    )", "response": "Update a record of a loan report in the provided database."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninserts a set of new records into the provided database.", "response": "def insert_contribution_entries(database, entries):\n    \"\"\"Insert a set of records of a contribution report in the provided database.\n\n    Insert a set of new records into the provided database without checking\n    for conflicting entries.\n\n    @param database: The MongoDB database to operate on. The contributions\n        collection will be used from this database.\n    @type db: pymongo.database.Database\n    @param entries: The entries to insert into the database.\n    @type entries: dict\n    \"\"\"\n    entries = map(clean_entry, entries)\n    database.contributions.insert(entries, continue_on_error=True)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef insert_expenditure_entries(database, entries):\n    entries = map(clean_entry, entries)\n    database.expenditures.insert(entries, continue_on_error=True)", "response": "Insert a set of new records of a expenditure report into the provided database."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninserts a set of new records of a loan report in the provided database.", "response": "def insert_loan_entries(database, entries):\n    \"\"\"Insert a set of records of a loan report in the provided database.\n\n    Insert a set of new records into the provided database without checking\n    for conflicting entries.\n\n    @param db: The MongoDB database to operate on. The loans collection will be\n        used from this database.\n    @type db: pymongo.database.Database\n    @param entries: The entries to insert into the database.\n    @type entries: dict\n    \"\"\"\n    entries = map(clean_entry, entries)\n    database.loans.insert(entries, continue_on_error=True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate a record of a contribution report in the provided MongoDB database.", "response": "def update_entry(database, entry, report_type):\n    \"\"\"Update a record of a contribution report in the provided database.\n\n    @param db: The MongoDB database to operate on. The contributions collection\n        will be used from this database.\n    @type db: pymongo.database.Database\n    @param entry: The entry to insert into the database, updating the entry with\n        the same recordID if one exists.\n    @type entry: dict\n    @param report_type: The type of report being updated. Should be one of the\n        strings in constants.REPORT_TYPES.\n    @type report_type: str\n    @raise ValueError: Raised if the requested report type could not be found.\n    \"\"\"\n    factory = UpdateStrategyFactory.get_instance()\n    strategy = factory.get_strategy(report_type)\n    if not strategy:\n        raise ValueError('%s not a recognized report type.' % report_type)\n\n    return strategy(database, entry, reassign_id=reassign_id,\n        force_copy=force_copy)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef modify_classes():\n    import copy\n    from django.conf import settings\n    from django.contrib.admin.sites import site\n    from django.utils.importlib import import_module\n    from django.utils.module_loading import module_has_submodule\n\n    for app in settings.INSTALLED_APPS:\n        mod = import_module(app)\n        # Attempt to import the app's class_modifier module.\n        try:\n            before_import_registry = copy.copy(site._registry)\n            import_module('%s.class_modifiers' % app)\n        except:\n            site._registry = before_import_registry\n            # Decide whether to bubble up this error. If the app just\n            # doesn't have an class_modifier module, we can ignore the error\n            # attempting to import it, otherwise we want it to bubble up.\n            if module_has_submodule(mod, 'class_modifiers'):\n                raise", "response": "Auto - discover INSTALLED_APPS class_modifiers. py modules and fail silently when there is no class_modifiers module present."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncatch exceptions raised by the decorated function. Call check() to raise any caught exceptions.", "response": "def exception_catcher(fn):\n    \"\"\" Catch exceptions raised by the decorated function.\n        Call check() to raise any caught exceptions.\n    \"\"\"\n    exceptions = Queue.Queue()\n\n    @wraps(fn)\n    def wrapped(*args, **kwargs):\n        try:\n            ret = fn(*args, **kwargs)\n        except Exception:\n            exceptions.put(sys.exc_info())\n            raise\n        return ret\n\n    def check():\n        try:\n            item = exceptions.get(block=False)\n            klass, value, tb = item\n            raise klass, value, tb\n        except Queue.Empty:\n            pass\n\n    setattr(wrapped, 'check', check)\n    return wrapped"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwraps the text object to width breaking at whitespaces.", "response": "def wrap(self, text):\n        '''Wraps the text object to width, breaking at whitespaces. Runs of\n        whitespace characters are preserved, provided they do not fall at a\n        line boundary. The implementation is based on that of textwrap from the\n        standard library, but we can cope with StringWithFormatting objects.\n\n        :returns: a list of string-like objects.\n        '''\n        result = []\n        chunks = self._chunk(text)\n        while chunks:\n            self._lstrip(chunks)\n            current_line = []\n            current_line_length = 0\n            current_chunk_length = 0\n            while chunks:\n                current_chunk_length = len(chunks[0])\n                if current_line_length + current_chunk_length <= self.width:\n                    current_line.append(chunks.pop(0))\n                    current_line_length += current_chunk_length\n                else:\n                    # Line is full\n                    break\n            # Handle case where chunk is bigger than an entire line\n            if current_chunk_length > self.width:\n                space_left = self.width - current_line_length\n                current_line.append(chunks[0][:space_left])\n                chunks[0] = chunks[0][space_left:]\n            self._rstrip(current_line)\n            if current_line:\n                result.append(reduce(\n                    lambda x, y: x + y, current_line[1:], current_line[0]))\n            else:\n                # FIXME: should this line go? Removing it makes at least simple\n                # cases like wrap('    ', 10) actually behave like\n                # textwrap.wrap...\n                result.append('')\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef chainable(fn):\n    @functools.wraps(fn)\n    def wrapper(nxt=lambda x: x):\n        if hasattr(nxt, '__call__'):\n            return lambda x: nxt(fn(x))\n        # Value has been passsed directly, so we don't chain\n        return fn(nxt)\n    return wrapper", "response": "Make function a chainable validator\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntakes a list of chainable validators and returns a chained validator.", "response": "def make_chain(fns):\n    \"\"\" Take a list of chainable validators and return a chained validator\n\n    The functions should be decorated with ``chainable`` decorator.\n\n    Any exceptions raised by any of the validators are propagated except for\n    ``ReturnEarly`` exception which is trapped. When ``ReturnEarly`` exception\n    is trapped, the original value passed to the chained validator is returned\n    as is.\n    \"\"\"\n    chain = lambda x: x\n    for fn in reversed(fns):\n        chain = fn(chain)\n\n    def validator(v):\n        try:\n            return chain(v)\n        except ReturnEarly:\n            return v\n\n    return validator"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nregisters a component using a factory method.", "response": "def register(self, locator, factory):\n        \"\"\"\n        Registers a component using a factory method.\n\n        :param locator: a locator to identify component to be created.\n\n        :param factory: a factory function that receives a locator and returns a created component.\n        \"\"\"\n        if locator == None:\n            raise Exception(\"Locator cannot be null\")\n        if factory == None:\n            raise Exception(\"Factory cannot be null\")\n\n        self._registrations.append(Registration(locator, factory))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_as_type(self, locator, object_factory):\n        if locator == None:\n            raise Exception(\"Locator cannot be null\")\n        if object_factory == None:\n            raise Exception(\"Factory cannot be null\")\n\n        def factory(locator):\n            return object_factory()\n\n        self._registrations.append(Registration(locator, factory))", "response": "Registers a component using its type."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if this factory is able to create a component by given locator.", "response": "def can_create(self, locator):\n        \"\"\"\n        Checks if this factory is able to create component by given locator.\n\n        This method searches for all registered components and returns\n        a locator for component it is able to create that matches the given locator.\n        If the factory is not able to create a requested component is returns null.\n\n        :param locator: a locator to identify component to be created.\n\n        :return: a locator for a component that the factory is able to create.\n        \"\"\"\n        for registration in self._registrations:\n            this_locator = registration.locator\n            if this_locator == locator:\n                return this_locator\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a component identified by given locator.", "response": "def create(self, locator):\n        \"\"\"\n        Creates a component identified by given locator.\n\n        :param locator: a locator to identify component to be created.\n\n        :return: the created component.\n        \"\"\"\n        for registration in self._registrations:\n            this_locator = registration.locator\n\n            if this_locator == locator:\n                try:\n                    return registration.factory(locator)\n                except Exception as ex:\n                    if isinstance(ex, CreateException):\n                        raise ex\n                    \n                    raise CreateException(\n                        None,\n                        \"Failed to create object for \" + str(locator)\n                    ).with_cause(ex)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun [cmdLine] as admin specify the location from where the code is executed through [target_dir]", "response": "def runAsAdmin(cmdLine=None, target_dir='', wait=True):\n    \"\"\"\n    run [cmdLine] as admin\n    specify the location from where the code is executed through [target_dir]\n    \"\"\"\n    if os.name != 'nt':\n        raise RuntimeError(\"This function is only implemented on Windows.\")\n    # import win32api,\n    import win32con\n    import win32event\n    import win32process\n    from win32com.shell.shell import ShellExecuteEx\n\n    from win32com.shell import shellcon\n\n    python_exe = sys.executable\n\n    if cmdLine is None:\n        cmdLine = [python_exe] + sys.argv\n    elif type(cmdLine) not in (tuple, list):\n        raise ValueError(\"cmdLine is not a sequence.\")\n\n    cmd = '\"%s\"' % (cmdLine[0],)\n    # XXX TODO: isn't there a function or something we can call to message\n    # command line params?\n    params = \" \".join(['\"%s\"' % (x,) for x in cmdLine[1:]])\n    #cmdDir = ''\n    showCmd = win32con.SW_SHOWNORMAL\n    #showCmd = win32con.SW_HIDE\n    lpVerb = 'runas'  # causes UAC elevation prompt.\n\n    # print \"Running\", cmd, params\n\n    # ShellExecute() doesn't seem to allow us to fetch the PID or handle\n    # of the process, so we can't get anything useful from it. Therefore\n    # the more complex ShellExecuteEx() must be used.\n\n    # procHandle = win32api.ShellExecute(0, lpVerb, cmd, params, cmdDir, showCmd)\n    print(target_dir, cmd, params)\n    procInfo = ShellExecuteEx(nShow=showCmd,\n                              fMask=shellcon.SEE_MASK_NOCLOSEPROCESS,\n                              lpVerb=lpVerb,\n                              lpFile=cmd,\n                              lpParameters=params,\n                              lpDirectory=target_dir)\n    if wait:\n        procHandle = procInfo['hProcess']\n        obj = win32event.WaitForSingleObject(procHandle, win32event.INFINITE)\n        rc = win32process.GetExitCodeProcess(procHandle)\n        # print \"Process handle %s returned code %s\" % (procHandle, rc)\n    else:\n        rc = None\n    return rc"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, catalog=None, dependencies=None, allow_overwrite=False):\n        '''\n        Convenience method to update this Di instance with the specified contents.\n\n        :param catalog: ICatalog supporting class or mapping\n        :type catalog: ICatalog or collections.Mapping\n        :param dependencies: Mapping of dependencies\n        :type dependencies: collections.Mapping\n        :param allow_overwrite: If True, allow overwriting existing keys. Only applies to providers.\n        :type allow_overwrite: bool\n        '''\n        if catalog:\n            self._providers.update(catalog, allow_overwrite=allow_overwrite)\n        if dependencies:\n            self._dependencies.update(dependencies)", "response": "Update this Di instance with the specified contents."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns missing dependencies for provider key.", "response": "def get_missing_deps(self, obj):\n        '''\n        Returns missing dependencies for provider key.\n        Missing meaning no instance can be provided at this time.\n\n        :param key: Provider key\n        :type key: object\n        :return: Missing dependencies\n        :rtype: list\n        '''\n        deps = self.get_deps(obj)\n        ret = []\n        for key in deps:\n            provider = self._providers.get(key)\n            if provider and provider.providable:\n                continue\n            ret.append(key)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\niterate over resolved instances for given provider keys. :param keys: Provider keys :type keys: tuple :return: Iterator of resolved instances :rtype: generator", "response": "def iresolve(self, *keys):\n        '''\n        Iterates over resolved instances for given provider keys.\n\n        :param keys: Provider keys\n        :type keys: tuple\n        :return: Iterator of resolved instances\n        :rtype: generator\n        '''\n        for key in keys:\n            missing = self.get_missing_deps(key)\n            if missing:\n                raise UnresolvableError(\"Missing dependencies for %s: %s\" % (key, missing))\n\n            provider = self._providers.get(key)\n            if not provider:\n                raise UnresolvableError(\"Provider does not exist for %s\" % key)\n\n            yield provider()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resolve(self, *keys):\n        '''\n        Returns resolved instances for given provider keys.\n\n        If only one positional argument is given, only one is returned.\n\n        :param keys: Provider keys\n        :type keys: tuple\n        :return: Resolved instance(s); if only one key given, otherwise list of them.\n        :rtype: object or list\n        '''\n        instances = list(self.iresolve(*keys))\n        if len(keys) == 1:\n            return instances[0]\n        return instances", "response": "Returns resolved instances for given provider keys."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning list of resolved dependencies for given object.", "response": "def resolve_deps(self, obj):\n        '''\n        Returns list of resolved dependencies for given obj.\n\n        :param obj: Object to lookup dependencies for\n        :type obj: object\n        :return: Resolved dependencies\n        :rtype: list\n        '''\n        deps = self.get_deps(obj)\n        return list(self.iresolve(*deps))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_factory(self, key, factory=_sentinel, scope=NoneScope, allow_overwrite=False):\n        '''\n        Creates and registers a provider using the given key, factory, and scope.\n        Can also be used as a decorator.\n\n        :param key: Provider key\n        :type key:  object\n        :param factory: Factory callable\n        :type factory: callable\n        :param scope: Scope key, factory, or instance\n        :type scope: object or callable\n        :return: Factory (or None if we're creating a provider without a factory)\n        :rtype: callable or None\n        '''\n        if factory is _sentinel:\n            return functools.partial(self.register_factory, key, scope=scope, allow_overwrite=allow_overwrite)\n        if not allow_overwrite and key in self._providers:\n            raise KeyError(\"Key %s already exists\" % key)\n        provider = self.provider(factory, scope)\n        self._providers[key] = provider\n        return factory", "response": "Creates and registers a provider using the given key and scope."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the instance under the specified provider key. If no provider for the specified key exists a new instance is created with the given scope.", "response": "def set_instance(self, key, instance, default_scope=GlobalScope):\n        '''\n        Sets instance under specified provider key. If a provider for specified key does not exist, one is created\n        without a factory using the given scope.\n\n        :param key: Provider key\n        :type key: object\n        :param instance: Instance\n        :type instance: object\n        :param default_scope: Scope key, factory, or instance\n        :type default_scope: object or callable\n        '''\n        if key not in self._providers:\n            # We don't know how to create this kind of instance at this time, so add it without a factory.\n            factory = None\n            self.register_factory(key, factory, default_scope)\n        self._providers[key].set_instance(instance)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef inject_classproperty(self, key, name=None, replace_on_access=False):\n        '''\n        Decorator that injects the specified key as a classproperty.\n\n        If replace_on_access is True, then it replaces itself with the instance on first lookup.\n\n        :param key: Provider key\n        :type key: object\n        :param name: Name of classproperty, defaults to key\n        :type name: str\n        :param replace_on_access: If True, replace the classproperty with the actual value on first lookup\n        :type replace_on_access: bool\n        '''\n        return ClassPropertyInjector(self, key, name=name, replace_on_access=replace_on_access)", "response": "Decorator that injects the specified key as a classproperty."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, _create=False, **ctx_options):\n        if _create:\n            return self._kind_factory.create(key=self)\n        else:\n            return self._kind_factory(key=self)", "response": "Get a new instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getTarget(iid):\n        '''\n            A static method which returns a Target object identified by\n            iid. Returns None if a Target object was not found\n        '''\n        db = getDataCommunicator()\n\n        verbose('Loading target with id {}'.format(iid))\n        data = db.getTarget(iid)\n\n        if data:\n            verbose('Found target')\n            return Target(data['name'], data['path'], _id=iid)\n        \n        verbose('Could not find target belonging to id {}'.format(iid))\n        return data", "response": "A static method which returns a Target object identified by iid. Returns None if no object was found."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete(self):\n        '''\n            Deletes link from vault and removes database information\n        '''\n        if not self._id:\n            verbose('This target does not have an id')\n            return False\n\n        # Removes link from vault directory\n        verbose('Removing link from vault directory')\n        os.remove(self.vault_path)\n\n        verbose('Removing information from database')\n        # Removing information from database\n        self.db.removeTarget(self._id) \n        self._id = -1\n\n        return True", "response": "Deletes link from vault and removes database information from target"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef secure(self):\n        '''\n            Creates a hard link to the target file in the vault directory\n            and saves information about the target file in the database\n        '''\n        verbose('Saving information about target into conman database')\n        self._id = self.db.insertTarget(self.name, self.path)\n\n        verbose('Creating a hard link from {} to {} directory'.format(\n            str(self), config.CONMAN_PATH   \n        ))\n        link(self.real_path, self.vault_path)", "response": "Creates a hard link to the target file in the vault directory\n            and saves information about the target file in the database\n           "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a link at the original path of this target", "response": "def deploy(self):\n        '''\n            Creates a link at the original path of this target\n        '''\n        if not os.path.exists(self.path):\n            makedirs(self.path)\n\n        link(self.vault_path, self.real_path)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unite_dataset(dataset, basecolumn, fn=None):\n    # create default unite_fn\n    if fn is None:\n        fn = default_unite_function\n    # classify dataset via unite_fn\n    united_dataset = OrderedDict()\n    for data in dataset:\n        unite_name = fn(data)\n        if unite_name not in united_dataset:\n            united_dataset[unite_name] = []\n        united_dataset[unite_name].append(data[1:])\n    # unite dataset via maidenhair.loaders.base.unite_dataset\n    for name, dataset in united_dataset.items():\n        united_dataset[name] = _unite_dataset(dataset, basecolumn)[0]\n    # create new dataset (respect the order of the dataset)\n    dataset = []\n    for name, _dataset in united_dataset.items():\n        dataset.append([name] + _dataset)\n    return dataset", "response": "Unite dataset via fn\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_data(self, file_url, file_name='', method_title='', argument_title=''):\r\n\r\n        ''' a helper method to retrieve data buffer for a file url\r\n\r\n        :param file_url: string with url to file\r\n        :param file_name: [optional] string with name to affix to file buffer\r\n        :param method_title: [optional] string with name of class method calling\r\n        :param argument_title: [optional] string with name of method argument key\r\n        :return: byte data buffer with file data\r\n        '''\r\n\r\n        # https://docs.python.org/3/library/io.html#io.BytesIO\r\n\r\n        import io\r\n        import requests\r\n\r\n    # fill empty values\r\n        if not file_name:\r\n            file_name = 'file'\r\n        if not method_title:\r\n            method_title = '%s._get_data' % self.__class__.__name__\r\n        if not argument_title:\r\n            argument_title = 'file_url'\r\n\r\n    # request file from url\r\n        try:\r\n            remote_file = requests.get(file_url)\r\n        except requests.exceptions.ConnectionError as err:\r\n            if self.requests_handler:\r\n                return self.requests_handler(err)\r\n            else:\r\n                raise\r\n        except:\r\n            raise ValueError('%s(%s=%s) is not a valid url.' % (method_title, argument_title, file_url))\r\n\r\n    # add contents to buffer\r\n        file_buffer = io.BytesIO(remote_file.content)\r\n        file_buffer.name = '%s' % file_name\r\n\r\n        return file_buffer", "response": "a helper method to retrieve data buffer for a file url"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _create_folder(self):\r\n\r\n        ''' a helper method for creating a temporary audio clip folder '''\r\n\r\n    # import dependencies\r\n        import os\r\n        from labpack.platforms.localhost import localhostClient\r\n        from labpack.records.id import labID\r\n\r\n    # create folder in user app data\r\n        record_id = labID()\r\n        collection_name = 'Watson Speech2Text'\r\n        localhost_client = localhostClient()\r\n        app_folder = localhost_client.app_data(org_name=__team__, prod_name=__module__)\r\n        if localhost_client.os in ('Linux', 'FreeBSD', 'Solaris'):\r\n            collection_name = collection_name.replace(' ', '-').lower()\r\n        collection_folder = os.path.join(app_folder, collection_name)\r\n        clip_folder = os.path.join(collection_folder, record_id.id24)\r\n        if not os.path.exists(clip_folder):\r\n            os.makedirs(clip_folder)\r\n\r\n        return clip_folder", "response": "a helper method for creating a temporary audio clip folder"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convert_audio(self, file_path, new_mimetype, overwrite=False):\r\n\r\n        '''\r\n            a method to convert an audio file into a different codec\r\n            \r\n        :param file_path: string with path to file on localhost \r\n        :param new_mimetype: string with mimetype for new file\r\n        :param overwrite: [optional] boolean to overwrite existing file\r\n        :return: string with path to new file on localhost\r\n        \r\n            SEE: https://github.com/Ch00k/ffmpy\r\n        '''\r\n\r\n        title = '%s.convert_audio' % self.__class__.__name__\r\n\r\n    # validate inputs\r\n        input_fields = {\r\n            'file_path': file_path,\r\n            'new_mimetype': new_mimetype\r\n        }\r\n        for key, value in input_fields.items():\r\n            object_title = '%s(%s=%s)' % (title, key, str(value))\r\n            self.fields.validate(value, '.%s' % key, object_title)\r\n\r\n    # retrieve file extension\r\n        new_extension = ''\r\n        mimetype_list = []\r\n        mime_arg = '%s(new_mimetype=%s)' % (title, new_mimetype)\r\n        for key, value in self.fields.schema['audio_extensions'].items():\r\n            mimetype_list.append(value['mimetype'])\r\n            if value['mimetype'] == new_mimetype:\r\n                new_extension = value['extension']\r\n                break\r\n        if not new_extension:\r\n            raise ValueError('%s must be one of %s mimetypes' % (mime_arg, mimetype_list))\r\n\r\n    # import dependencies\r\n        from os import path\r\n        import ffmpy\r\n\r\n    # validate existence of file\r\n        file_arg = '%s(file_path=%s)' % (title, file_path)\r\n        if not path.exists(file_path):\r\n            raise ValueError('%s is not a valid path', file_arg)\r\n\r\n    # construct new file\r\n        file_name, file_extension = path.splitext(file_path)\r\n        output_path = file_name + new_extension\r\n\r\n    # construct inputs\r\n        ffmpeg_kwargs = {\r\n            'inputs': {file_path: None},\r\n            'outputs': {output_path: None},\r\n            'global_options': [ '-v error']\r\n        }\r\n        if overwrite:\r\n            ffmpeg_kwargs['global_options'].append('-y')\r\n        ffmpeg_client = ffmpy.FFmpeg(**ffmpeg_kwargs)\r\n\r\n    # run conversion\r\n        ffmpeg_client.run()\r\n\r\n        return output_path", "response": "a method to convert an audio file into a different codec"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef transcribe_file(self, file_path, clip_length=10, compress=True):\r\n\r\n        '''\r\n            a method to transcribe the text from an audio file\r\n        \r\n        EXAMPLE: https://github.com/dannguyen/watson-word-watcher\r\n        \r\n        :param file_path: string with path to audio file on localhost\r\n        :param clip_length: [optional] integer with seconds to divide clips into\r\n        :param compress: [optional] boolean to convert file to audio/ogg\r\n        :return: dictionary with transcribed text segments in 'segments' key\r\n        '''\r\n\r\n        title = '%s.transcribe_file' % self.__class__.__name__\r\n\r\n    # validate inputs\r\n        input_fields = {\r\n            'file_path': file_path,\r\n            'clip_length': clip_length\r\n        }\r\n        for key, value in input_fields.items():\r\n            object_title = '%s(%s=%s)' % (title, key, str(value))\r\n            self.fields.validate(value, '.%s' % key, object_title)\r\n\r\n    # run conversion\r\n        import os\r\n        if compress:\r\n            file_name, file_extension = os.path.splitext(file_path)\r\n            if file_extension != '.ogg':\r\n                file_path = self.convert_audio(file_path, 'audio/ogg', True)\r\n\r\n    # construct empty file details\r\n        file_details = {\r\n            'name': '',\r\n            'mimetype': '',\r\n            'extension': ''\r\n        }\r\n\r\n    # retrieve file name\r\n        file_arg = '%s(file_path=%s)' % (title, str(file_path))\r\n        split_file = os.path.split(file_path)\r\n        file_details['name'] = split_file[0]\r\n        if len(split_file) > 1:\r\n            file_details['name'] = split_file[1]\r\n        if not file_details['name']:\r\n            raise ValueError('%s must have a file name.' % file_arg)\r\n\r\n    # validate file extension\r\n        ext_kwargs = {\r\n            'file_name': file_details['name'],\r\n            'extension_map': self.fields.schema['audio_extensions'],\r\n            'method_title': title,\r\n            'argument_title': file_path\r\n        }\r\n        regex_details = self._validate_extension(**ext_kwargs)\r\n        file_details.update(**regex_details)\r\n\r\n    # retrieve byte data\r\n        if not os.path.exists(file_path):\r\n            raise ValueError('%s is not a valid file path.' % file_arg)\r\n\r\n    # validate file mimetype\r\n        if self.magic:\r\n            magic_details = self.magic.analyze(file_path)\r\n            mimetype_text = file_details['mimetype'][6:]\r\n            if mimetype_text not in magic_details['mimetype']:\r\n                raise ValueError('%s byte data mimetype %s does not match %s file extension.' % (file_arg, magic_details['mimetype'], file_details['extension']))\r\n\r\n    # import dependencies\r\n        from math import ceil\r\n        from moviepy.editor import AudioFileClip\r\n\r\n    # open audio file\r\n        audio = AudioFileClip(file_path)\r\n        audio_duration = audio.duration\r\n\r\n    # construct list of files to transcribe\r\n        file_list = []\r\n        if audio_duration < clip_length:\r\n            file_list.append(file_path)\r\n        else:\r\n    # create temporary audio files\r\n            clip_folder = self._create_folder()\r\n            count = 0\r\n            t_start = 0\r\n            while t_start < audio_duration:\r\n                t_end = t_start + clip_length\r\n                if t_end > audio_duration:\r\n                    t_end = ceil(audio_duration)\r\n                    segment = audio.subclip(t_start)\r\n                else:\r\n                    segment = audio.subclip(t_start, t_end)\r\n                clip_name = 'audio%s.%s' % (count, file_details['extension'])\r\n                clip_path = os.path.join(clip_folder, clip_name)\r\n                segment.write_audiofile(clip_path, verbose=False)\r\n                file_list.append(clip_path)\r\n                count += 1\r\n                t_start = t_end\r\n\r\n    # run file transcription method\r\n        transcription_result = self._transcribe_files(file_list, file_details['mimetype'])\r\n\r\n    # remove temp files\r\n        if len(file_list) > 1:\r\n            from labpack.records.settings import remove_settings\r\n            for file in file_list:\r\n                remove_settings(file, remove_dir=True)\r\n\r\n        return transcription_result", "response": "a method to transcribe the text from an audio file on the local machine"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef transcribe_bytes(self, byte_data, clip_length=None, audio_mimetype='', compress=True):\r\n\r\n        '''\r\n            a method to transcribe text from audio byte data\r\n            \r\n        :param byte_data: byte data in buffer with audio data \r\n        :param clip_length: [optional] integer with seconds to divide clips into\r\n        :param compress: [optional] boolean to convert file to audio/ogg\r\n        :param audio_mimetype: [optional] string with byte data mimetype\r\n        :return: dictionary with transcribed text segments in 'segments' key\r\n        '''\r\n\r\n        title = '%s.transcribe_bytes' % self.__class__.__name__\r\n        bytes_arg = \"%s(byte_data=b'...')\" % title\r\n\r\n    # validate inputs\r\n        input_fields = {\r\n            'clip_length': clip_length,\r\n            'audio_mimetype': audio_mimetype\r\n        }\r\n        for key, value in input_fields.items():\r\n            if value:\r\n                object_title = '%s(%s=%s)' % (title, key, str(value))\r\n                self.fields.validate(value, '.%s' % key, object_title)\r\n\r\n    # validate data mimetype\r\n        if audio_mimetype:\r\n            file_extension = ''\r\n            for key, value in self.fields.schema['audio_extensions'].items():\r\n                if value['mimetype'] == audio_mimetype:\r\n                    file_extension = value['extension']\r\n        else:\r\n            if self.magic:\r\n                magic_details = self.magic.analyze(byte_data=byte_data)\r\n                file_name = magic_details['name']\r\n                if not file_name:\r\n                    file_name = 'audio'\r\n                file_name += magic_details['extension']\r\n                ext_kwargs = {\r\n                    'file_name': file_name,\r\n                    'extension_map': self.fields.schema['audio_extensions'],\r\n                    'method_title': title,\r\n                    'argument_title': 'byte_data'\r\n                }\r\n                file_details = self._validate_extension(**ext_kwargs)\r\n                audio_mimetype = file_details['mimetype']\r\n                file_extension = file_details['extension']\r\n            else:\r\n                raise ValueError('%s argument requires audio_mimetype (or magic) to determine its mimetype.' % bytes_arg)\r\n\r\n    # construct default return\r\n        transcript_details = {\r\n            'error': '',\r\n            'segments': []\r\n        }\r\n\r\n    # transcribe entire buffer\r\n        if clip_length is None:\r\n            try:\r\n                transcript = self.client.recognize(byte_data, audio_mimetype, continuous=True)\r\n                if transcript['results']:\r\n                    for result in transcript['results']:\r\n                        transcript_details['segments'].append(result['alternatives'][0])\r\n            except Exception as err:\r\n                transcript_details['error'] = err\r\n\r\n    # save buffer to disk, segment and transcribe in multiple threads\r\n        else:\r\n            import os\r\n            from time import sleep\r\n            from math import ceil\r\n            from moviepy.editor import AudioFileClip\r\n\r\n        # save buffer to disk\r\n            clip_folder = self._create_folder()\r\n            full_name = 'audio_full.%s' % file_extension\r\n            full_path = os.path.join(clip_folder, full_name)\r\n            with open(full_path, 'wb') as f:\r\n                f.write(byte_data)\r\n                f.close()\r\n\r\n        # convert file\r\n            if compress:\r\n                file_name, file_extension = os.path.splitext(full_path)\r\n                if file_extension != '.ogg':\r\n                    full_path = self.convert_audio(full_path, 'audio/ogg', True)\r\n                    file_details = {\r\n                        'name': 'audio_full.ogg',\r\n                        'extension': '.ogg',\r\n                        'mimetype': 'audio/ogg'\r\n                    }\r\n                    audio_mimetype = file_details['mimetype']\r\n                    file_extension = file_details['extension']\r\n\r\n        # open audio file\r\n            count = 0\r\n            retry_count = 10\r\n            while True:\r\n                try:\r\n                    audio = AudioFileClip(full_path)\r\n                    break\r\n                except PermissionError:\r\n                    sleep(.05)\r\n                    count += 1\r\n                    if count > retry_count:\r\n                        raise\r\n            audio_duration = audio.duration\r\n\r\n        # construct list of files to transcribe\r\n            file_list = []\r\n            if audio_duration < clip_length:\r\n                file_list.append(full_path)\r\n            else:\r\n\r\n        # create temporary audio files\r\n                count = 0\r\n                t_start = 0\r\n                while t_start < audio_duration:\r\n                    t_end = t_start + clip_length\r\n                    if t_end > audio_duration:\r\n                        t_end = ceil(audio_duration)\r\n                        segment = audio.subclip(t_start)\r\n                    else:\r\n                        segment = audio.subclip(t_start, t_end)\r\n                    clip_name = 'audio%s.%s' % (count, file_extension)\r\n                    clip_path = os.path.join(clip_folder, clip_name)\r\n                    segment.write_audiofile(clip_path, verbose=False)\r\n                    file_list.append(clip_path)\r\n                    count += 1\r\n                    t_start = t_end\r\n\r\n        # run file transcription method\r\n            transcript_details = self._transcribe_files(file_list, audio_mimetype)\r\n\r\n        # remove temp files\r\n            if len(file_list) > 1:\r\n                from labpack.records.settings import remove_settings\r\n                for file in file_list:\r\n                    remove_settings(file, remove_dir=True)\r\n\r\n        return transcript_details", "response": "a method to transcribe text from audio byte data into audio segments in the segments dictionary"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef lazy_enumerate(self, **kwargs):\n        '''Enumerate without evaluating any sets.\n        '''\n        kwargs['lazy'] = True\n        for item in self.enumerate(**kwargs):\n            yield item", "response": "Enumerate without evaluating any sets."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef group_selection(request):\n\n    groups = get_user_groups(request.user)\n    count = len(groups)\n    if count == 1:\n        # Redirect to the detail page for this group\n        return redirect(groups[0])\n    context = {\n        'groups': groups,\n        'count': count,\n    }\n    return render(request, 'multitenancy/group-landing.html', context)", "response": "Allow user to select a TenantGroup if they have more than one."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread all the configuration parameters from the specified configuration parameters. Each section represents an individual Connectionparams", "response": "def read_connections(self, connections):\n        \"\"\"\n        Reads connections from configuration parameters.\n        Each section represents an individual Connectionparams\n\n        :param connections: configuration parameters to be read\n        \"\"\"\n        del self._items[:]\n        for key in connections.get_key_names():\n            item = DiscoveryItem()\n            item.key = key\n            value = connections.get_as_nullable_string(key)\n            item.connection = ConnectionParams.from_string(value)\n            self._items.append(item)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register(self, correlation_id, key, connection):\n        item = DiscoveryItem()\n        item.key = key\n        item.connection = connection\n        self._items.append(item)", "response": "Registers a connection parameter into the discovery service."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nresolve a single connection parameter by its key.", "response": "def resolve_one(self, correlation_id, key):\n        \"\"\"\n        Resolves a single connection parameters by its key.\n\n        :param correlation_id: (optional) transaction id to trace execution through call chain.\n\n        :param key: a key to uniquely identify the connection.\n\n        :return: a resolved connection.\n        \"\"\"\n        connection = None\n        for item in self._items:\n            if item.key == key and item.connection != None:\n                connection = item.connection\n                break\n        return connection"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_chunks(string, num_chars):\n    for start in range(0, len(string), num_chars):\n        yield string[start:start+num_chars]", "response": "Yield num_chars - character chunks from string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _load_package_config(reload_=False):\n    global _packages\n    from acorn.config import settings\n    packset = settings(\"acorn\", reload_)\n    if packset.has_section(\"acorn.packages\"):\n        for package, value in packset.items(\"acorn.packages\"):\n            _packages[package] = value.strip() == \"1\"", "response": "Loads the package configurations from the global acorn. cfg file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_decorate(package):\n    # We import the decoration logic from acorn and then overwrite the sys.module\n    # for this package with the decorated, original pandas package.\n    from acorn.logging.decoration import set_decorating, decorating\n    \n    #Before we do any imports, we need to set that we are decorating so that\n    #everything works as if `acorn` wasn't even here.\n    origdecor = decorating\n    set_decorating(True)\n\n    #If we try and import the module directly, we will get stuck in a loop; at\n    #some point we must invoke the built-in module loader from python. We do\n    #this by removing our sys.path hook.\n    import sys    \n    from importlib import import_module\n    apack = import_module(package)    \n    from acorn.logging.decoration import decorate\n    decorate(apack)\n\n    sys.modules[\"acorn.{}\".format(package)] = apack\n\n    #Set the decoration back to what it was.\n    from acorn.logging.decoration import set_decorating\n    set_decorating(origdecor)\n    \n    return apack", "response": "Imports and decorates the package with the specified name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the index closest to point pt in an array arr that is not zero", "response": "def closestNonZeroIndex(pt, arr, kSize=21):\n    \"\"\"\n    return the index closest to point [pt] in an array [arr]\n    within a given kernel size [kSize] that is not zero\n    \"\"\"\n    assert kSize % 2 == 1, 'need odd kernel size'\n\n    hk = int(kSize / 2)\n    ipt = np.asarray(pt, dtype=int)\n    # array slice of shape kSize around ipt:\n    r = [slice(max(0, p - hk),\n               min(s, p + hk + 1)) for p, s in zip(ipt, arr.shape)]\n\n    # sliced array:\n    arrr = arr[tuple(r)]\n    # all indices that are non zero:\n    ind = np.transpose(np.nonzero(arrr))\n    if not len(ind):\n        # nothing found\n        return None\n    # pos of ipt within array slice:\n    center = [p - s.start for p, s in zip(ipt, r)]\n    ind -= center\n    # index of minimum distance:\n    m = np.argmin(norm(ind, axis=-1))\n    return ipt + ind[m]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process_file(self, path, dryrun):\n        # if dryrun just return file path\n        if dryrun:\n            return path\n\n        # remove and return file\n        if self.__force or raw_input(\"Remove file '%s'? [y/N]\" % path).lower() == \"y\":\n            os.remove(path)\n            return path", "response": "Process a file and return the path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef module2uri(self, module_name):\n        assert module_name.startswith(self.module_prefix), 'incompatible module name'\n        path = module_name[len(self.module_prefix):]\n        path = path.replace('&#DOT', '.')\n        return path.replace('&#SEP', os.sep)", "response": "Convert an encoded module name to an unencoded source uri"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef uri2module(self, uri):\n        module_name = uri.replace('.', '&#DOT')\n        module_name = module_name.replace(os.sep, '&#SEP')\n        return self.module_prefix + module_name", "response": "Convert an unencoded source uri to an encoded module name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind the appropriate loader for the given module name.", "response": "def find_module(self, fullname, path=None):\n        \"\"\"\n        Find the appropriate loader for module ``name``\n\n        :param fullname: ``__name__`` of the module to import\n        :type fullname: str\n        :param path: ``__path__`` of the *parent* package already imported\n        :type path: str or None\n        \"\"\"\n        # path points to the top-level package path if any\n        # and we can only import sub-modules/-packages\n        if path is None:\n            return\n        if fullname.startswith(self.module_prefix):\n            return self\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nevaluates the command line arguments performing the appropriate MimeType actions so the application can be started.", "response": "def run(self):\n        \"\"\"Evaluate the command line arguments, performing the appropriate\n        actions so the application can be started.\n\n        \"\"\"\n        # The list command prevents any other processing of args\n        if self._args.list:\n            self._print_installed_apps(self._args.controller)\n            sys.exit(0)\n\n        # If app is not specified at this point, raise an error\n        if not self._args.application:\n            sys.stderr.write('\\nerror: application not specified\\n\\n')\n            self._arg_parser.print_help()\n            sys.exit(-1)\n\n        # If it's a registered app reference by name, get the module name\n        app_module = self._get_application_module(self._args.controller,\n                                                  self._args.application)\n\n        # Configure logging based upon the flags\n        self._configure_logging(app_module,\n                                self._args.verbose,\n                                self._args.syslog)\n\n        # Try and run the controller\n        try:\n            self._controllers[self._args.controller].main(app_module,\n                                                          self._args)\n        except TypeError as error:\n            sys.stderr.write('error: could not start the %s controller for %s'\n                             ': %s\\n\\n' % (self._args.controller,\n                                           app_module,\n                                           str(error)))\n            sys.exit(-1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _add_cli_args(self):\n\n        # Optional cli arguments\n        self._arg_parser.add_argument('-l', '--list',\n                                      action='store_true',\n                                      help='List installed sprockets apps')\n\n        self._arg_parser.add_argument('-s', '--syslog',\n                                      action='store_true',\n                                      help='Log to syslog')\n\n        self._arg_parser.add_argument('-v', '--verbose',\n                                      action='count',\n                                      help=('Verbose logging output, use -vv '\n                                            'for DEBUG level logging'))\n\n        self._arg_parser.add_argument('--version',\n                                      action='version',\n                                      version='sprockets v%s ' % __version__)\n\n        # Controller sub-parser\n        subparsers = self._arg_parser.add_subparsers(dest='controller',\n                                                          help=DESCRIPTION)\n\n        # Iterate through the controllers and add their cli arguments\n        for key in self._controllers:\n            help_text = self._get_controller_help(key)\n            sub_parser = subparsers.add_parser(key, help=help_text)\n            try:\n                self._controllers[key].add_cli_arguments(sub_parser)\n            except AttributeError:\n                LOGGER.debug('%s missing add_cli_arguments()', key)\n\n        # The application argument\n        self._arg_parser.add_argument('application',\n                                      action=\"store\",\n                                      help='The sprockets app to run')", "response": "Add the cli arguments to the argument parser."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _configure_logging(application, verbosity=0, syslog=False):\n        # Create a new copy of the logging config that will be modified\n        config = dict(LOGGING)\n\n        # Increase the logging verbosity\n        if verbosity == 1:\n            config['loggers']['sprockets']['level'] = logging.INFO\n        elif verbosity == 2:\n            config['loggers']['sprockets']['level'] = logging.DEBUG\n\n        # Add syslog if it's enabled\n        if syslog:\n            config['loggers']['sprockets']['handlers'].append('syslog')\n\n        # Copy the sprockets logger to the application\n        config['loggers'][application] = dict(config['loggers']['sprockets'])\n\n        # Configure logging\n        logging_config.dictConfig(config)", "response": "Configure logging for the application setting the appropriate\n        verbosity and adding syslog if it s enabled."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_application_module(self, controller, application):\n        for pkg in self._get_applications(controller):\n            if pkg.name == application:\n                return pkg.module_name\n        return application", "response": "Return the module name for an application."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_controllers(self):\n        controllers = dict()\n        for pkg in pkg_resources.iter_entry_points(group=self.CONTROLLERS):\n            LOGGER.debug('Loading %s controller', pkg.name)\n            controllers[pkg.name] = importlib.import_module(pkg.module_name)\n        return controllers", "response": "Iterate through the installed controller entry points and import the module and assign the handle to the CLI. _controllers dict."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_controller_help(self, controller):\n        if hasattr(self._controllers[controller], 'HELP'):\n            return self._controllers[controller].HELP\n        return None", "response": "Returns the value of the HELP attribute for a controller that should\n        describe the functionality of the controller."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting out a list of installed sprockets applications for the given controller.", "response": "def _print_installed_apps(self, controller):\n        \"\"\"Print out a list of installed sprockets applications\n\n        :param str controller: The name of the controller to get apps for\n        \"\"\"\n        print('\\nInstalled Sprockets %s Apps\\n' % controller.upper())\n        print(\"{0:<25} {1:>25}\".format('Name', 'Module'))\n        print(string.ljust('', 51, '-'))\n        for app in self._get_applications(controller):\n            print('{0:<25} {1:>25}'.format(app.name, '(%s)' % app.module_name))\n        print('')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rslv(self, interface: str, name: str=None) -> Tuple[str, int, Optional[str]]:\n\t\tif name is None:\n\t\t\tname = self.name\n\t\tkey = '{}-{}'.format(name, interface)\n\t\thost = None\n\t\tif 'host' in self.interfaces[key]:\n\t\t\thost = self.interfaces[key]['host']\n\t\treturn self.interfaces[key]['ip'], self.interfaces[key]['port'], host", "response": "Return the IP address port and optionally host IP for one of this Nodes interfaces."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef trigger(self, target: str, trigger: str, parameters: Dict[str, Any]={}):\n\t\tpass", "response": "Calls the specified Trigger of another Area with the optionally given parameters."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef benchmark(f, n_repeats=3, warmup=True, name=\"\"):\n    if warmup:\n        f()\n\n    total_time = 0\n    for i in range(n_repeats):\n        iter_name = \"%s (iter #%d)\" % (name, i + 1,)\n        with Timer(iter_name) as t:\n            f()\n        total_time += t.elapsed\n    return total_time / n_repeats", "response": "Run the given function f repeatedly return the average elapsed time."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexamining an item of any type and return a true dictionary.", "response": "def convert_to_dict(item):\n    '''Examine an item of any type and return a true dictionary.\n\n    If the item is already a dictionary, then the item is returned as-is. Easy.\n\n    Otherwise, it attempts to interpret it. So far, this routine can handle:\n    \n    * a class, function, or anything with a .__dict__ entry\n    * a legacy mongoEngine document (a class for MongoDb handling)\n    * a list (index positions are used as keys)\n    * a generic object that is iterable\n    * a generic object with members\n\n    .. versionadded:: 0.0.4\n\n    :param item:\n        Any object such as a variable, instance, or function.\n    :returns:\n        A true dictionary. If unable to get convert 'item', then an empty dictionary '{}' is returned.\n    '''\n    # get type\n    actual_type = detect_type(item)\n    # given the type, do conversion\n    if actual_type==\"dict\":\n        return item\n    elif actual_type==\"list\":\n        temp = {}\n        ctr = 0\n        for entry in item:\n            temp[ctr]=entry\n            ctr += 1\n        return temp\n    elif actual_type==\"mongoengine\":\n        return item.__dict__['_data']\n    elif actual_type==\"class\":\n        return item.__dict__\n    elif actual_type==\"iterable_dict\":\n        # for a 'iterable_dict' create a real dictionary for a ALMOST-dict object.\n        d = {}\n        for key in item: # NO, you can't use iteritems(). The method might not exist.\n            d[key] = item[key]\n        return d\n    elif actual_type==\"object\":\n        tuples = getmembers(item)\n        d = {}\n        for (key, value) in tuples:\n            d[key] = value\n        return d\n    return {}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dict_crawl(entry, key):\n    ''' returns a triple tuple representing the location of the key/key-list.\n    returns: (parent_dictionary, final_key, value_found)\n    If unable to locate the key, then (None, None, None) is returned.\n    '''\n    value = None\n    key_list = make_list(key)\n    try:\n        result = None\n        success_flag = True\n        temp = entry\n        for next_key in key_list:\n            parent = temp\n            actual_type = detect_type(temp)\n            if actual_type==\"mongoengine\":\n                if next_key in temp.__dict__['_data']:\n                    temp = temp.__dict__['_data'][next_key]\n                else:\n                    break\n            elif actual_type==\"class\":\n                if next_key in temp.__dict__:\n                    temp = temp.__dict__[next_key]\n                else:\n                    break\n            elif actual_type==\"dict\":\n                if next_key in temp:\n                    temp = temp[next_key]\n                else:\n                    break\n            elif actual_type==\"iterable_dict\":\n                if next_key in convert_to_dict(temp): # 'contains' method might not be there\n                    temp = temp[next_key]\n                else:\n                    break\n            elif actual_type==\"list\":\n                if next_key in temp:\n                    temp = temp[next_key]\n                else:\n                    break\n            else:  ## I'm unsure we can really 'crawl' an 'object'\n                break\n        else:\n            return (parent, key_list[-1], temp)\n        return (None, None, None)\n    except:\n        pass\n    return (None, None, None)", "response": "crawl a dictionary entry for a specific key"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef detect_member(row, key):\n    ''' properly detects if a an attribute exists '''\n    (target, tkey, tvalue) = dict_crawl(row, key)\n    if target:\n        return True\n    return False", "response": "detects if a member exists in the tree"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_member(row, key):\n    ''' properly detects if a an attribute exists '''\n    (target, tkey, tvalue) = dict_crawl(row, key)\n    if target:\n        return tvalue\n    return None", "response": "detects if a member exists in the dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do_op(field, op, value):\n    ''' used for comparisons '''\n    if op==NOOP:\n        return True\n    if field==None:\n        if value==None:\n            return True\n        else:\n            return False\n    if value==None:\n        return False\n    if op==LESS:\n        return (field < value)\n    if op==LESSorEQUAL:\n        return (field <= value)\n    if op==GREATERorEQUAL:\n        return (field >= value)\n    if op==GREATER:\n        return (field > value)\n    # for the EQUAL and NOT_EQUAL conditions, additional factors are considered.\n    # for EQUAL,\n    #    if they don't match AND the types don't match,\n    #    then the STR of the field and value is also tried\n    if op==EQUAL:\n        if (field == value):\n            return True\n        if type(field)==type(value):\n            return False\n        try:\n            field = str(field)\n            value = str(value)\n            return (field == value)\n        except:\n            return False\n    # for NOT_EQUAL,\n    #    if they match, then report False\n    #    if they don't match AND the types don't match,\n    #       then the STR equivalents are also tried.\n    if op==NOT_EQUAL:\n        if (field == value):\n            return False\n        if type(field)==type(value):\n            return True\n        try:\n            field = str(field)\n            value = str(value)\n            return (field != value)\n        except:\n            return True\n    return False", "response": "returns True if the field is equal to value"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the index of the first list entry that matches the given operation and value.", "response": "def get_index(table, field_name, op, value):\n    ''' \n    Returns the index of the first list entry that matches. If no matches\n    are found, it returns None\n    NOTE: it is not returning a list. It is returning an integer in range 0..LEN(target)\n    NOTE: both 'None' and 0 evaluate as False in python. So, if you are checking for a\n       None being returned, be explicit. \"if myindex==None:\" not simply \"if not myindex:\"\n    '''\n    counter = 0\n    for row in table:\n        dict_row = convert_to_dict(row)\n        if do_op(dict_row.get(field_name, None), op, value):\n            return counter\n        counter += 1\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_value(row, field_name):\n    '''\n    Returns the value found in the field_name attribute of the row dictionary.\n    '''\n    result = None\n    dict_row = convert_to_dict(row)\n    if detect_list(field_name):\n        temp = row\n        for field in field_name:\n            dict_temp = convert_to_dict(temp)\n            temp = dict_temp.get(field, None)\n        result = temp\n    else:\n        result = dict_row.get(field_name, None)\n    return result", "response": "Returns the value found in the field_name attribute of the row dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef select(table, index_track, field_name, op, value, includeMissing):\n    '''Modifies the table and index_track lists based on the comparison.\n    '''\n    result = []\n    result_index = []\n    counter = 0\n    for row in table:\n        if detect_fields(field_name, convert_to_dict(row)):\n            final_value = get_value(row, field_name)\n            if do_op(final_value, op, value):\n                result.append(row)\n                result_index.append(index_track[counter])\n        else:\n            if includeMissing:\n                result.append(row)\n                result_index.append(index_track[counter])\n        counter += 1\n    #table = result\n    #index_track = result_index\n    return (result, result_index)", "response": "Modifies the table and index_track lists based on the comparison."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncapturing log messages for the given modules and archive them to a LogFile resource.", "response": "def capture(package, prefix, modules=[], level=logging.DEBUG):\n    \"\"\" Capture log messages for the given modules and archive\n    them to a ``LogFile`` resource. \"\"\"\n    handler = LogFileHandler(package, prefix)\n    formatter = logging.Formatter(FORMAT)\n    handler.setFormatter(formatter)\n    modules = set(modules + ['loadkit'])\n\n    for logger in modules:\n        if not hasattr(logger, 'addHandler'):\n            logger = logging.getLogger(logger)\n        logger.setLevel(level=level)\n        logger.addHandler(handler)\n\n    return handler"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load(package, prefix, offset=0, limit=1000):\n    logs = package.all(LogFile, unicode(prefix))\n    logs = sorted(logs, key=lambda l: l.name, reverse=True)\n    seen = 0\n    record = None\n    tmp = tempfile.NamedTemporaryFile(suffix='.log')\n    for log in logs:\n        shutil.copyfileobj(log.fh(), tmp)\n        tmp.seek(0)\n        for line in reversed(list(tmp)):\n            seen += 1\n            if seen < offset:\n                continue\n            if seen > limit:\n                tmp.close()\n                return\n            try:\n                d, mo, l, m = line.split(' %s ' % SEP, 4)\n                if record is not None:\n                    yield record\n                record = {'time': d, 'module': mo, 'level': l, 'message': m}\n            except ValueError:\n                if record is not None:\n                    record['message'] += '\\n' + line\n        tmp.seek(0)\n    tmp.close()\n    if record is not None:\n        yield record", "response": "Load lines from the log file with pagination support."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _validate_type(self, file_name, extension_map, method_title, argument_title):\r\n\r\n        ''' a helper method to validate extension type of file\r\n\r\n        :param file_name: string with file name to test\r\n        :param extension_map: dictionary with extensions names and regex patterns\r\n        :param method_title: string with title of feeder method\r\n        :param argument_title: string with title of argument key from feeder method\r\n        :return: string with file extension\r\n        '''\r\n\r\n    # validate file extension\r\n        from labpack.parsing.regex import labRegex\r\n        file_extension = ''\r\n        ext_types = labRegex(extension_map)\r\n        file_mapping = ext_types.map(file_name)[0]\r\n        extension_list = []\r\n        for key, value in file_mapping.items():\r\n            if isinstance(value, bool):\r\n                extension_list.append('.%s' % key)\r\n            if value and isinstance(value, bool):\r\n                file_extension = '.%s' + key\r\n        if not file_extension:\r\n            raise ValueError('%s(%s=%s) must be one of %s file types.' % (method_title, argument_title, file_name, extension_list))\r\n\r\n        return file_extension", "response": "a helper method to validate file extension type of file\r\n Gas"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _compile_buttons(self, button_list, small_buttons, persist_buttons):\r\n\r\n        ''' a helper method to compile buttons to telegram api format\r\n\r\n        :param button_list: list of strings with button values\r\n        :param small_buttons: boolean to resize buttons to fit text size\r\n        :param persist_buttons: boolean to keep buttons around after exiting\r\n        :return: string in json serial format\r\n        '''\r\n\r\n        import json\r\n        keyboard_list = []\r\n        for item in button_list:\r\n            keyboard_list.append([{'text': item}])\r\n        keyboard_kwargs = {\r\n            'keyboard': keyboard_list,\r\n            'one_time_keyboard': not persist_buttons,\r\n            'resize_keyboard': small_buttons\r\n        }\r\n        json_data = json.dumps(keyboard_kwargs)\r\n        return json_data", "response": "a helper method to compile buttons to telegram api format\r\n           "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _compile_keypad(self, keypad_type, persist_buttons):\r\n        \r\n        ''' a helper method to compile keypad buttons to telegram api format\r\n\r\n        :param keypad_type: string with type of keypad to emulate\r\n        :param persist_buttons: boolean to keep buttons around after exiting\r\n        :return: string in json serial format\r\n        '''\r\n\r\n        import json\r\n        keyboard_list = []\r\n        if keypad_type == 'phone':\r\n            row_list = [ {'text': '1'}, {'text': '2'}, {'text': '3'} ]\r\n            keyboard_list.append(row_list)\r\n            row_list = [ {'text': '4'}, {'text': '5'}, {'text': '6'} ]\r\n            keyboard_list.append(row_list)\r\n            row_list = [ {'text': '7'}, {'text': '8'}, {'text': '9'} ]\r\n            keyboard_list.append(row_list)\r\n            row_list = [ {'text': '*'}, {'text': '0'}, {'text': '#'} ]\r\n            keyboard_list.append(row_list)\r\n        elif keypad_type == 'calculator':\r\n            row_list = [ {'text': '7'}, {'text': '8'}, {'text': '9'}, {'text': '/'} ]\r\n            keyboard_list.append(row_list)\r\n            row_list = [ {'text': '4'}, {'text': '5'}, {'text': '6'}, {'text': '*'} ]\r\n            keyboard_list.append(row_list)\r\n            row_list = [ {'text': '1'}, {'text': '2'}, {'text': '3'}, {'text': '-'} ]\r\n            keyboard_list.append(row_list)\r\n            row_list = [ {'text': '0'}, {'text': '.'}, {'text': '='}, {'text': '+'} ]\r\n            keyboard_list.append(row_list)\r\n        keyboard_kwargs = {\r\n            'keyboard': keyboard_list,\r\n            'one_time_keyboard': not persist_buttons,\r\n            'resize_keyboard': True\r\n        }\r\n        json_data = json.dumps(keyboard_kwargs)\r\n        return json_data", "response": "a helper method to compile the keypad buttons to telegram api format\r\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_updates(self, last_update=0):\r\n\r\n        ''' a method to retrieve messages for bot from telegram api\r\n\r\n        :param last_update: integer with update id of last message received\r\n        :return: dictionary of response details with update list in [json][result]\r\n\r\n        {\r\n            'headers': { ... },\r\n            'url': 'https://api.telegram.org/bot.../getUpdates',\r\n            'code': 200,\r\n            'error': '',\r\n            'json': {\r\n                'ok': True,\r\n                'result': [\r\n                    {\r\n                        'update_id': 667652176,\r\n                        'message': {\r\n                            'chat': {\r\n                                'first_name': 'First',\r\n                                'type': 'private',\r\n                                'id': 1234567890,\r\n                                'last_name': 'Last'\r\n                            },\r\n                            'text': 'Hey',\r\n                            'from': {\r\n                                'first_name': 'First',\r\n                                'id': 1234567890,\r\n                                'last_name': 'Last'\r\n                            },\r\n                            'message_id': 173,\r\n                            'date': 1478729313\r\n                        }\r\n                    },\r\n                    {\r\n                        'update_id': 667652176,\r\n                        'message': {\r\n                            'chat': {\r\n                                'first_name': 'First',\r\n                                'type': 'private',\r\n                                'id': 1234567890,\r\n                                'last_name': 'Last'\r\n                            },\r\n                            'caption': 'Interesting song',\r\n                            'photo': [\r\n                                {\r\n                                    'file_id': 'AgADAQ...EC',\r\n                                    'width': 51,\r\n                                    'file_size': 1238,\r\n                                    'height': 90\r\n                                },\r\n                                {\r\n                                    'file_id': 'AgADAQ...Ag',\r\n                                    'width': 180,\r\n                                    'file_size': 13151,\r\n                                    'height': 320\r\n                                },\r\n                                {\r\n                                    'file_id': 'AgADAQ...VC',\r\n                                    'width': 449,\r\n                                    'file_size': 51134,\r\n                                    'height': 800\r\n                                },\r\n                                {\r\n                                    'file_id': 'AgADAQ...AC',\r\n                                    'width': 719,\r\n                                    'file_size': 82609,\r\n                                    'height': 1280\r\n                                }\r\n                            ],\r\n                            'from': {\r\n                                'first_name': 'First',\r\n                                'id': 1234567890,\r\n                                'last_name': 'Last'\r\n                            },\r\n                            'message_id': 175,\r\n                            'date': 1478729799\r\n                        }\r\n                    },\r\n                    {\r\n                        'update_id': 667652179,\r\n                        'message': {\r\n                            'chat': {\r\n                                'first_name': 'First',\r\n                                'type': 'private',\r\n                                'id': 1234567890,\r\n                                'last_name': 'Last'\r\n                            },\r\n                            'caption': 'Snow in slow mo',\r\n                            'document': {\r\n                                'file_name': 'IMG_0010.MOV',\r\n                                'thumb': {\r\n                                    'file_id': 'AAQB...IC',\r\n                                    'file_size': 2547,\r\n                                    'width': 90,\r\n                                    'height': 50\r\n                                },\r\n                                'file_size': 51588899,\r\n                                'file_id': 'BQAD...QI'\r\n                            }\r\n                            'from': {\r\n                                'first_name': 'First',\r\n                                'id': 1234567890,\r\n                                'last_name': 'Last'\r\n                            },\r\n                            'message_id': 176,\r\n                            'date': 1478729313\r\n                        }\r\n                    },\r\n                    {\r\n                        'update_id': 667652180,\r\n                        'message': {\r\n                            'chat': {\r\n                                'first_name': 'First',\r\n                                'type': 'private',\r\n                                'id': 1234567890,\r\n                                'last_name': 'Last'\r\n                            },\r\n                            'location': {\r\n                                'latitude': 12.345678,\r\n                                'longitude': -23.456789\r\n                            },\r\n                            'venue': {'\r\n                                location': {\r\n                                    'latitude': 12.345678,\r\n                                    'longitude': -23.456789\r\n                                },\r\n                                'address': '1 Laboratory Rd',\r\n                                'title': 'Collective Acuity Labs',\r\n                                'foursquare_id': '4a...e3'\r\n                            },\r\n                            'from': {\r\n                                'first_name': 'First',\r\n                                'id': 1234567890,\r\n                                'last_name': 'Last'\r\n                            },\r\n                            'message_id': 177,\r\n                            'date': 1478729313\r\n                        }\r\n                    },\r\n                    {\r\n                        'update_id': 667652191,\r\n                        'message': {\r\n                            'chat': {\r\n                                'first_name': 'First',\r\n                                'type': 'private',\r\n                                'id': 1234567890,\r\n                                'last_name': 'Last'\r\n                            },\r\n                            'voice': {\r\n                                'duration': 3,\r\n                                'mime_type': 'audio/ogg',\r\n                                'file_id': 'AwADAQADAgADXGbcC3hOFYsqDDtKAg',\r\n                                'file_size': 7008\r\n                            },\r\n                            'from': {\r\n                                'first_name': 'First',\r\n                                'id': 1234567890,\r\n                                'last_name': 'Last'\r\n                            },\r\n                            'message_id': 224,\r\n                            'date': 1478729313\r\n                        }\r\n                    }\r\n                ]\r\n            }\r\n        }\r\n        '''\r\n\r\n        title = '%s.get_updates' % self.__class__.__name__\r\n\r\n    # construct request fields\r\n        request_kwargs = {\r\n            'url': '%s/getUpdates' % self.api_endpoint\r\n        }\r\n\r\n    # add offset to kwargs\r\n        if last_update:\r\n            object_title = '%s(last_update=%s)' % (title, str(last_update))\r\n            self.fields.validate(last_update, '.last_update', object_title)\r\n            request_kwargs['data'] = {\r\n                'offset': last_update + 1\r\n            }\r\n\r\n    # send request\r\n        response_details = self._post_request(**request_kwargs)\r\n\r\n        return response_details", "response": "a method to retrieve updates for a given last message received from the Telegram API"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_message(self, user_id, message_text, message_style='', button_list=None, small_buttons=True, persist_buttons=False, link_preview=True):\r\n\r\n        ''' a method to send a message using telegram api\r\n\r\n        :param user_id: integer with id of telegram user\r\n        :param message_text: string with message to user\r\n        :param message_style: [optional] string with style to apply to text, only 'markdown'\r\n        :param button_list: [optional] list of string to include as buttons in message\r\n        :param small_buttons: [optional] boolean to resize buttons to single line\r\n        :param persist_buttons: [optional] boolean to keep buttons around after exiting\r\n        :param link_preview: [optional] boolean to open up a preview window of a link in message\r\n        :return: dictionary of response details with message details in [json][result]\r\n\r\n        {\r\n            'headers': { ... },\r\n            'url': 'https://api.telegram.org/bot.../sendMessage',\r\n            'code': 200,\r\n            'error': '',\r\n            'json': {\r\n                'ok': True,\r\n                'result': {\r\n                    'chat': {\r\n                        'first_name': 'First',\r\n                        'type': 'private',\r\n                        'id': 1234567890,\r\n                        'last_name': 'Last'\r\n                    },\r\n                    'text': 'text me again',\r\n                    'from': {\r\n                        'first_name': 'my Bot',\r\n                        'id': 987654310,\r\n                        'username': 'myBot'\r\n                    },\r\n                    'message_id': 178,\r\n                    'date': 1478729313\r\n                }\r\n            }\r\n        }\r\n        '''\r\n\r\n        title = '%s.send_message' % self.__class__.__name__\r\n\r\n    # validate inputs\r\n        input_fields = {\r\n            'user_id': user_id,\r\n            'message_text': message_text,\r\n            'message_style': message_style,\r\n            'button_list': button_list\r\n        }\r\n        for key, value in input_fields.items():\r\n            if value:\r\n                object_title = '%s(%s=%s)' % (title, key, str(value))\r\n                self.fields.validate(value, '.%s' % key, object_title)\r\n\r\n    # construct key word arguments\r\n        request_kwargs = {\r\n            'url': '%s/sendMessage' % self.api_endpoint,\r\n            'data': {\r\n                'chat_id': user_id,\r\n                'text': message_text\r\n            }\r\n        }\r\n        if message_style:\r\n            if message_style == 'markdown':\r\n                request_kwargs['data']['parse_mode'] = 'Markdown'\r\n            elif message_style == 'html':\r\n                request_kwargs['data']['parse_mode'] = 'HTML'\r\n        if button_list:\r\n            request_kwargs['data']['reply_markup'] = self._compile_buttons(button_list, small_buttons, persist_buttons)\r\n        # elif keypad_type:\r\n        #     request_kwargs['data']['reply_markup'] = self._compile_keypad(keypad_type, persist_buttons)\r\n        if not link_preview:\r\n            request_kwargs['data']['disable_web_page_preview'] = True\r\n\r\n    # send request\r\n        response_details = self._post_request(**request_kwargs)\r\n\r\n        return response_details", "response": "a method to send a message using telegram api"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send_photo(self, user_id, photo_id='', photo_path='', photo_url='', caption_text='', button_list=None, small_buttons=True, persist_buttons=False):\r\n\r\n        ''' a method to send a photo using telegram api\r\n\r\n        :param user_id: integer with id of telegram user\r\n        :param photo_id: [optional] string with id of file stored with telegram api\r\n        :param photo_path: [optional] string with local path to file\r\n        :param photo_url: [optional] string with url of file\r\n        :param caption_text: [optional] string with caption to add to photo\r\n        :return: dictionary of response details with message detail in [json][result]\r\n\r\n        {\r\n            'headers': { ... },\r\n            'url': 'https://api.telegram.org/bot.../sendPhoto',\r\n            'code': 200,\r\n            'error': '',\r\n            'json': {\r\n                'ok': True,\r\n                'result': {\r\n                    'chat': {\r\n                        'first_name': 'First',\r\n                        'type': 'private',\r\n                        'id': 1234567890,\r\n                        'last_name': 'Last'\r\n                    },\r\n                    'caption': 'lab logo',\r\n                    'photo': [\r\n                        {\r\n                            'file_id': 'AgADAQ...EC',\r\n                            'width': 51,\r\n                            'file_size': 1238,\r\n                            'height': 90\r\n                        },\r\n                        {\r\n                            'file_id': 'AgADAQ...Ag',\r\n                            'width': 180,\r\n                            'file_size': 13151,\r\n                            'height': 320\r\n                        },\r\n                        {\r\n                            'file_id': 'AgADAQ...VC',\r\n                            'width': 449,\r\n                            'file_size': 51134,\r\n                            'height': 800\r\n                        },\r\n                        {\r\n                            'file_id': 'AgADAQ...AC',\r\n                            'width': 719,\r\n                            'file_size': 82609,\r\n                            'height': 1280\r\n                        }\r\n                    ],\r\n                    'from': {\r\n                        'first_name': 'my Bot',\r\n                        'id': 987654310,\r\n                        'username': 'myBot'\r\n                    },\r\n                    'message_id': 179,\r\n                    'date': 1478729413\r\n                }\r\n            }\r\n        }\r\n        '''\r\n\r\n        title = '%s.send_photo' % self.__class__.__name__\r\n\r\n    # validate inputs\r\n        input_fields = {\r\n            'user_id': user_id,\r\n            'caption_text': caption_text,\r\n            'photo_id': photo_id,\r\n            'photo_path': photo_path,\r\n            'photo_url': photo_url,\r\n            'button_list': button_list\r\n        }\r\n        for key, value in input_fields.items():\r\n            if value:\r\n                object_title = '%s(%s=%s)' % (title, key, str(value))\r\n                self.fields.validate(value, '.%s' % key, object_title)\r\n\r\n    # construct extension map\r\n        extension_map = self.fields.schema['photo_extensions']\r\n\r\n    # construct key word arguments\r\n        request_kwargs = {\r\n            'url': '%s/sendPhoto' % self.api_endpoint,\r\n            'data': {\r\n                'chat_id': user_id\r\n            }\r\n        }\r\n        if caption_text:\r\n            request_kwargs['data']['caption'] = caption_text\r\n        if button_list:\r\n            request_kwargs['data']['reply_markup'] = self._compile_buttons(button_list, small_buttons, persist_buttons)\r\n\r\n    # add photo to request keywords\r\n        if photo_path:\r\n            import os\r\n            self._validate_type(photo_path, extension_map, title, 'photo_path')\r\n            if not os.path.exists(photo_path):\r\n                raise ValueError('%s is not a valid file path.' % photo_path)\r\n            request_kwargs['files'] = { 'photo': open(photo_path, 'rb') }\r\n        elif photo_id:\r\n            request_kwargs['data']['photo'] = photo_id\r\n        elif photo_url:\r\n            file_extension = self._validate_type(photo_url, extension_map, title, 'photo_url')\r\n            file_buffer = self._get_data(photo_url, 'photo%s' % file_extension, title, 'photo_url')\r\n            request_kwargs['files'] = { 'photo': file_buffer }\r\n        else:\r\n            raise IndexError('%s(...) requires either a photo_path, photo_id or photo_url argument' % title)\r\n\r\n    # send request\r\n        response_details = self._post_request(**request_kwargs)\r\n\r\n        return response_details", "response": "a method to send a photo using telegram api"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clean():\n    for queue in MyQueue.collection().instances():\n        queue.delete()\n    for job in MyJob.collection().instances():\n        job.delete()\n    for person in Person.collection().instances():\n        person.delete()", "response": "Clean data created by this script\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run(self, queue):\n        # add some random time to simulate a long job\n        time.sleep(random.random())\n\n        # compute the fullname\n        obj = self.get_object()\n        obj.fullname.hset('%s %s' % tuple(obj.hmget('firstname', 'lastname')))\n\n        # this will the \"result\" of the job\n        result = 'Created fullname for Person %s: %s' % (obj.pk.get(), obj.fullname.hget())\n\n        # save the result of the callback in the job itself\n        self.result.set(result)\n\n        # return the result for future use in the worker\n        return result", "response": "Create the fullname and store a message serving as result in the job itself"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the queue s dates and number of jobs managed and save into the queue s jobs counter.", "response": "def job_success(self, job, queue, job_result):\n        \"\"\"\n        Update the queue's dates and number of jobs managed, and save into the\n        job the result received by the callback.\n        \"\"\"\n\n        # display what was done\n        obj = job.get_object()\n        message = '[%s|%s] %s [%s]' % (queue.name.hget(),\n                                       obj.pk.get(),\n                                       job_result,\n                                       threading.current_thread().name)\n        self.log(message)\n\n        # default stuff: update job and queue statuses, and do logging\n        super(FullNameWorker, self).job_success(job, queue, job_result)\n\n        # update the queue's dates\n        queue_fields_to_update = {\n            'last_job_date': str(datetime.utcnow())\n        }\n        if not queue.first_job_date.hget():\n            queue_fields_to_update['first_job_date'] = queue_fields_to_update['last_job_date']\n        queue.hmset(**queue_fields_to_update)\n\n        # update the jobs counter on the queue\n        queue.jobs_counter.hincrby(1)\n\n        # save a ref to the job to display at the end of this example script\n        self.jobs.append(int(job.pk.get()))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef resource_listing(cls, request) -> [(200, 'Ok', ResourceListingModel)]:\n        '''Return the list of all available resources on the system.\n\n        Resources are filtered according to the permission system, so querying\n        this resource as different users may bare different results.'''\n        apis = [api.get_swagger_fragment() for api in Api if not api.private]\n        Respond(200, {\n            'apiVersion': cls.api.version,\n            'swaggerVersion': cls.api.swagger_version,\n            'apis': apis\n        })", "response": "Return the list of all available resources on the system."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef api_declaration(\n            cls, request,\n            api_path: (Ptypes.path,\n                       String('The path for the info on the resource.'))) -> [\n            (200, 'Ok', ApiDeclarationModel),\n            (404, 'Not a valid resource.')]:\n        '''Return the complete specification of a single API.\n\n        Resources are filtered according to the permission system, so querying\n        this resource as different users may bare different results.\n        '''\n        if api_path in cls.__cache:\n            Respond(200, cls.__cache[api_path])\n        # Select the resources belonging to this API\n        resources = tuple(filter(lambda ep: ep.api.path == api_path, Resource))\n        if not resources:\n            Respond(404)\n        apis = [r.get_swagger_fragment() for r in resources if not r.private]\n        cls.__cache[api_path] = {\n            'apiVersion': cls.api.version,\n            'swaggerVersion': cls.api.swagger_version,\n            'basePath': request.url_root[:-1],  # Remove trailing slash\n            'resourcePath': '/{}'.format(api_path),\n            'apis': apis,\n            'models': cls._extract_models(apis),\n            'consumes': ['application/json'],\n            'produces': ['application/json']\n        }\n        Respond(200, cls.__cache[api_path])", "response": "Return the complete specification of a single API."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning information about the current URL.", "response": "def _get_route_info(self, request):\n        \"\"\"Return information about the current URL.\"\"\"\n        resolve_match = resolve(request.path)\n\n        app_name = resolve_match.app_name    # The application namespace for the URL pattern that matches the URL.\n        namespace = resolve_match.namespace  # The instance namespace for the URL pattern that matches the URL.\n        url_name = resolve_match.url_name    # The name of the URL pattern that matches the URL.\n        view_name = resolve_match.view_name  # Name of the view that matches the URL, incl. namespace if there's one.\n\n        return {\n            \"app_name\": app_name or None,\n            \"namespace\": namespace or None,\n            \"url_name\": url_name or None,\n            \"view_name\": view_name or None,\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef validate_account(self):\n        self._validating = True\n        with self.catch_invalid_credentials():\n            log.info(\"Finding a role to check the account id\")\n            a_role = list(self.iam.resource.roles.limit(1))\n            if not a_role:\n                raise AwsSyncrError(\"Couldn't find an iam role, can't validate the account....\")\n            account_id = a_role[0].meta.data['Arn'].split(\":\", 5)[4]\n\n        chosen_account = self.accounts[self.environment]\n        if chosen_account != account_id:\n            raise BadCredentials(\"Don't have credentials for the correct account!\", wanted=chosen_account, got=account_id)\n\n        self._validating = False\n        self._validated = True", "response": "Check that we are able to connect to the right account"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndispatching a parsed SOAP instance to a ServiceContainer.", "response": "def _Dispatch(ps, server, SendResponse, SendFault, post, action, nsdict={}, **kw):\n    '''Send ParsedSoap instance to ServiceContainer, which dispatches to\n    appropriate service via post, and method via action.  Response is a\n    self-describing pyobj, which is passed to a SoapWriter.\n\n    Call SendResponse or SendFault to send the reply back, appropriately.\n        server -- ServiceContainer instance\n\n    '''\n    localURL = 'http://%s:%d%s' %(server.server_name,server.server_port,post)\n    address = action\n    service = server.getNode(post)\n    isWSResource = False\n    if isinstance(service, WSAResource):\n        isWSResource = True\n        service.setServiceURL(localURL)\n        address = Address()\n        try:\n            address.parse(ps)\n        except Exception, e:\n            return SendFault(FaultFromException(e, 0, sys.exc_info()[2]), **kw)\n        if action and action != address.getAction():\n            e = WSActionException('SOAP Action(\"%s\") must match WS-Action(\"%s\") if specified.' \\\n                %(action,address.getAction()))\n            return SendFault(FaultFromException(e, 0, None), **kw)\n        action = address.getAction()\n\n    if isinstance(service, ServiceInterface) is False:\n        e = NoSuchService('no service at POST(%s) in container: %s' %(post,server))\n        return SendFault(FaultFromException(e, 0, sys.exc_info()[2]), **kw)\n\n    if not service.authorize(None, post, action):\n        return SendFault(Fault(Fault.Server, \"Not authorized\"), code=401)\n        #try:\n        #    raise NotAuthorized()\n        #except Exception, e:\n            #return SendFault(FaultFromException(e, 0, None), code=401, **kw)\n            ##return SendFault(FaultFromException(NotAuthorized(), 0, None), code=401, **kw)\n\n    try:\n        method = service.getOperation(ps, address)\n    except Exception, e:\n        return SendFault(FaultFromException(e, 0, sys.exc_info()[2]), **kw)\n\n    try:\n        if isWSResource is True: \n            request,result = method(ps, address)\n        else: \n            request,result = method(ps)\n    except Exception, e:\n        return SendFault(FaultFromException(e, 0, sys.exc_info()[2]), **kw)\n\n    # Verify if Signed\n    service.verify(ps)\n\n    # If No response just return.\n    if result is None:\n        return SendResponse('', **kw)\n\n    sw = SoapWriter(nsdict=nsdict)\n    try:\n        sw.serialize(result)\n    except Exception, e:\n        return SendFault(FaultFromException(e, 0, sys.exc_info()[2]), **kw)\n\n    if isWSResource is True:\n        action = service.getResponseAction(ps, action)\n        addressRsp = Address(action=action)\n        try:\n            addressRsp.setResponseFromWSAddress(address, localURL)\n            addressRsp.serialize(sw)\n        except Exception, e:\n            return SendFault(FaultFromException(e, 0, sys.exc_info()[2]), **kw)\n\n    # Create Signatures\n    service.sign(sw)\n\n    try:\n        soapdata = str(sw)\n        return SendResponse(soapdata, **kw)\n    except Exception, e:\n        return SendFault(FaultFromException(e, 0, sys.exc_info()[2]), **kw)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef AsServer(port=80, services=()):\n    '''port --\n       services -- list of service instances\n    '''\n    address = ('', port)\n    sc = ServiceContainer(address, services)\n    sc.serve_forever()", "response": "port --\n       services -- list of service instances"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a method of class. action -- soapAction value", "response": "def getOperation(self, ps, action):\n        '''Returns a method of class.\n           action -- soapAction value\n        '''\n        opName = self.getOperationName(ps, action)\n        return getattr(self, opName)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getOperationName(self, ps, action):\n        '''Returns operation name.\n           action -- soapAction value\n        '''\n        method = self.root.get(_get_element_nsuri_name(ps.body_root)) or \\\n            self.soapAction.get(action)\n        if method is None:\n            raise UnknownRequestException, \\\n                'failed to map request to a method: action(%s), root%s' %(action,_get_element_nsuri_name(ps.body_root))\n        return method", "response": "Returns operation name.\n           action -- soapAction value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a method of class. address -- ws - address", "response": "def getOperation(self, ps, address):\n        '''Returns a method of class.\n        address -- ws-address \n        '''\n        action = address.getAction()\n        opName = self.getOperationName(ps, action)\n        return getattr(self, opName)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getResponseAction(self, ps, action):\n        '''Returns response WS-Action if available\n           action -- request WS-Action value.\n        '''\n        opName = self.getOperationName(ps, action)\n        if self.wsAction.has_key(opName) is False:\n            raise WSActionNotSpecified, 'wsAction dictionary missing key(%s)' %opName\n        return self.wsAction[opName]", "response": "Returns response WS - Action if available\n           action -- request WS - Action value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do_POST(self):\n        '''The POST command.  This is called by HTTPServer, not twisted.\n        action -- SOAPAction(HTTP header) or wsa:Action(SOAP:Header)\n        '''\n        global _contexts\n\n        soapAction = self.headers.getheader('SOAPAction')\n        post = self.path\n        if not post:\n            raise PostNotSpecified, 'HTTP POST not specified in request'\n        if soapAction:\n            soapAction = soapAction.strip('\\'\"')\n        post = post.strip('\\'\"')\n        try:\n            ct = self.headers['content-type']\n            if ct.startswith('multipart/'):\n                cid = resolvers.MIMEResolver(ct, self.rfile)\n                xml = cid.GetSOAPPart()\n                ps = ParsedSoap(xml, resolver=cid.Resolve, readerclass=DomletteReader)\n            else:\n                length = int(self.headers['content-length'])\n                ps = ParsedSoap(self.rfile.read(length), readerclass=DomletteReader)\n        except ParseException, e:\n            self.send_fault(FaultFromZSIException(e))\n        except Exception, e:\n            # Faulted while processing; assume it's in the header.\n            self.send_fault(FaultFromException(e, 1, sys.exc_info()[2]))\n        else:\n            # Keep track of calls\n            thread_id = thread.get_ident()\n            _contexts[thread_id] = SOAPContext(self.server, xml, ps,\n                                               self.connection,\n                                               self.headers, soapAction)\n\n            try:\n                _Dispatch(ps, self.server, self.send_xml, self.send_fault,\n                    post=post, action=soapAction)\n            except Exception, e:\n                self.send_fault(FaultFromException(e, 0, sys.exc_info()[2]))\n\n            # Clean up after the call\n            if _contexts.has_key(thread_id):\n                del _contexts[thread_id]", "response": "The HTTP POST command. This is called by HTTPServer not twisted."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getCallBack(self, ps, post, action):\n        '''post -- POST HTTP value\n           action -- SOAP Action value\n        '''\n        node = self.getNode(post)\n        if node is None:\n            raise NoSuchFunction\n        if node.authorize(None, post, action):\n            return node.getOperation(ps, action)\n        else:\n            raise NotAuthorized, \"Authorization failed for method %s\" % action", "response": "Returns the callback value for the given method and post and SOAP Action."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_notebook_names(self, path=''):\n        path = path.strip('/')\n        spec = {'path': path,\n                'type': 'notebook'}\n        fields = {'name': 1}\n        notebooks = list(self._connect_collection(self.notebook_collection).find(spec,fields))\n        names = [n['name'] for n in notebooks]\n        return names", "response": "List all notebook names in the notebook dir and path."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef path_exists(self, path):\n\n        path = path.strip('/')\n        if path != '':\n            spec = {'path': path}\n            count = self._connect_collection(self.notebook_collection).find(spec).count()\n        else:\n            count = 1\n        return count > 0", "response": "Does the API - style path actually exist?"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new notebook and return its model with no content.", "response": "def create_notebook(self, model=None, path=''):\n        \"\"\"Create a new notebook and return its model with no content.\"\"\"\n        path = path.strip('/')\n        if model is None:\n            model = {}\n        if 'content' not in model:\n            metadata = current.new_metadata(name=u'')\n            model['content'] = current.new_notebook(metadata=metadata)\n        if 'name' not in model:\n            model['name'] = self.increment_filename('Untitled', path)\n\n        model['path'] = path\n        model['type'] = 'notebook'\n        model = self.save_notebook(model, model['name'], model['path'])\n\n        return model"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the python type for a given string describtion for a type.", "response": "def _get_type(stype):\n    ''' Get the python type for a given string describtion for a type.\n\n        @param stype: The string representing the type to return\n        @return: The python type if available\n    '''\n    stype = stype.lower()\n    if stype == 'str':\n        return str\n    if stype == 'unicode':\n        if PY2:\n            return unicode\n        else:\n            return str\n    if stype == 'int':\n        return int\n    if stype == 'float':\n        return float\n    if stype == 'bool':\n        return bool\n    raise AppConfigValueException('Unsuported type given: {0}'.format(stype))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a string with newlines so that the given string fits into line_length.", "response": "def _format_message(value, line_length, indent=\"\", first_indent=None):\n    ''' Return a string with newlines so that the given string fits into this\n        line length. At the start of the line the indent is added. This can\n        be used for commenting the message out within a file or to indent your\n        text.\n\n        All \\\\t will be replaced with 4 spaces.\n\n        @param value: The string to get as a commented multiline comment.\n        @param line_length: The length of the line to fill.\n        @param indent: The indent to use for printing or charcter to put in\n                front\n        @param first_indent: The first indent might be shorter. If None then\n                the first line uses the normal indent as the rest of the\n                string.\n\n        @return: The string with newlines\n    '''\n    if indent.find('\\t'):\n        indent = indent.replace('\\t', '    ')\n\n    result = []\n    if first_indent is None:\n        first_indent = indent\n    cindent = first_indent\n    tmp = \"*\" * line_length\n    for ele in value.split(' '):\n        if ele.find('\\t') >= 0:\n            ele = ele.replace('\\t', '    ')\n        if (len(ele) + len(tmp)) >= line_length:\n            result.append(tmp)\n            tmp = '{0}{1}'.format(cindent, ele)\n            cindent = indent\n        else:\n            tmp = \"{0} {1}\".format(tmp, ele)\n    result.append(tmp)\n    result = result[1:]\n    return \"\\n\".join(result)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing the config object and load the default configuration.", "response": "def init_default_config(self, path):\n        ''' Initialize the config object and load the default configuration.\n            The path to the config file must be provided. The name of the\n            application is read from the config file.\n            The config file stores the description and the default values for\n            all configurations including the application name.\n\n            @param path: The path to the config config file.\n        '''\n        if not (os.path.exists(path) and os.path.isfile(path)):\n            raise AppConfigValueException('The given config config file does '\n                    'not exist. ({0})'.format(path))\n        cfl = open(path, 'r')\n        data = json.load(cfl)\n        cfl.close()\n        for key in data.keys():\n            if 'application_name' == key:\n                self.application_name = data[key].lower()\n                continue\n            if 'application_author' == key:\n                self.application_author = data[key].lower()\n                continue\n            if 'application_version' == key:\n                self.application_version = data[key].lower()\n                continue\n            self._add_section_default(key, data[key])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the description of a config key.", "response": "def get_description(self, section, key):\n        ''' Get the description of a config key. If it does not exist an\n            Exception will be thrown.\n\n            @param section: the section where the key is stored.\n            @param key:     the key to get the description for.\n            @return: A tuple with three elements (description, type, default)\n        '''\n        if section in self.config_description:\n            if key in self.config_description[section]:\n                desc, value_type, default = \\\n                        self.config_description[section][key]\n                return (desc, value_type, default)\n            else:\n                if self.has_option(section, key):\n                    # return an empty string since it is possible that a\n                    # section is not initialized, this happens if a plugin\n                    # that has some config values but is not initialized.\n                    return \"\", str, \"\"\n                else:\n                    raise AppConfigValueException('Key ({0}) does not exist '\n                            'in section: {1}'.format(key, section))\n        else:\n            if self.has_section(section):\n                # return an empty string since it is possible that a section\n                # is not initialized, this happens if a plugin that has some\n                # config values but is not initialized.\n                return \"\", str, \"\"\n            else:\n                raise AppConfigValueException('Section does not exist '\n                        '[{0}]'.format(section))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_default(self):\n        ''' Load the default config files.\n            First the global config file then the user config file.\n        '''\n        appdir = AppDirs(self.application_name, self.application_author,\n                version=self.application_version)\n        file_name = os.path.join(appdir.site_data_dir, \"{0}.conf\".format(\n                self.application_name.lower()))\n        if os.path.exists(file_name):\n            self.load(file_name)\n        if os.name is not 'posix' or os.getuid() > 0:\n            config_file = os.path.join(appdir.user_data_dir, '{0}.conf'.format(\n                    self.application_name.lower()))\n            if os.path.exists(config_file):\n                self.load(config_file)", "response": "Load the default config files."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load(self, filename):\n        ''' Load the given config file.\n\n            @param filename: the filename including the path to load.\n        '''\n        if not os.path.exists(filename):\n            #print 'Could not load config file [%s]' % (filename)\n            raise AppConfigValueException('Could not load config file {0}'.\n                    format(filename))\n        cfl = open(filename, 'r')\n        if PY2:\n            self.readfp(cfl)\n        else:\n            self.read_file(cfl)\n        cfl.close()", "response": "Load the given config file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the value of a key in the given section.", "response": "def get(self, section, key):\n        ''' Get the value of a key in the given section. It will automatically\n            translate the paramter type if the parameter has a type specified\n            with the description.\n\n            @param section: the section where the key can be found.\n            @param key: the key the value is stored under.\n            @return the value as a string or the specified type.\n            @exception: if the type is specified and the value could not be\n                    translated to the given type.\n        '''\n        section = section.lower()\n        key = key.lower()\n        descr, value_type, default = self.get_description(section, key)\n        value = ConfigParser.get(self, section, key)\n        if value_type == bool:\n            if PY2:\n                if value.lower() not in self._boolean_states:\n                    raise AppConfigValueException('Not a boolean: {0}'.\n                            format(value))\n                return self._boolean_states[value.lower()]\n            else:\n                try:\n                    return self._convert_to_boolean(value)\n                except ValueError:\n                    raise AppConfigValueException('Not a boolean: {0}'.\n                            format(value))\n\n        return value_type(value)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set(self, section, key, value):\n        ''' Set the value for a key in the given section. It will check the\n            type of the value if it is available. If the value is not from\n            the given type it will be transformed to the type.\n            An exception will be thrown if there is a problem with the\n            conversion.\n\n            @param section: the section of the key\n            @param key: the key where to store the valu\n            @param value: the value to store\n            @exception: If there is a problem with the conversation of the\n                    value type.\n        '''\n        value_type = str\n        if self.has_option(section, key):\n            descr, value_type, default = self.get_description(section, key)\n\n        if value_type != type(value):\n            if value_type == bool:\n                if ((type(value) in string_types and\n                        value.lower() in ('true', 't')) or\n                        (type(value) == int and value > 0)):\n                    value = True\n                elif ((type(value) in string_types and\n                        value.lower() in ('false', 'f')) or\n                        (type(value) == int and value == 0)):\n                    value = False\n                else:\n                    raise AppConfigValueException('Could not convert '\n                            'boolean type: {0}'.format(value))\n            else:\n                value = value_type(value)\n\n        if not self.has_section(section):\n            self.add_section(section)\n\n        ConfigParser.set(self, section, key, str(value))", "response": "Set the value for a key in the given section. It will check the type of the value if it is available."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves the config to the given file or to the default location.", "response": "def save(self, filename=None, verbose=False):\n        ''' Save the config to the given file or to given default location.\n\n            @param filename: the file to write the config\n            @param verbose: If set to true the config file will have all values\n                    and all descriptions\n        '''\n        if filename is None:\n            if (not self.has_section(self.application_name) or\n                    not self.has_option(self.application_name, 'config_file')):\n                if not self.has_section(self.application_name):\n                    self.add_section(self.application_name)\n                if not self.application_name in self.config_description:\n                    self.config_description[self.application_name] = {}\n\n                appdir = AppDirs(self.application_name,\n                        self.application_author,\n                        version=self.application_version)\n                value = os.path.join(appdir.user_data_dir, '{0}.conf'.format(\n                    self.application_name.lower()))\n                if not self.has_option(self.application_name, 'config_file'):\n                    self.set(self.application_name, 'config_file', value)\n                if not ('config_file' in\n                        self.config_description[self.application_name]):\n                    self.config_description[self.application_name]\\\n                            ['config_file'] = ('The config file to '\n                                'overwrite on change of the config values. '\n                                '[$HOME/.{0}/{0}.conf]'.format(\n                                    self.application_name), str, value)\n\n            filename = self.get(self.application_name, 'config_file')\n\n        if not os.path.exists(os.path.dirname(filename)):\n            os.makedirs(os.path.dirname(filename))\n\n        hidden = None\n        if self.has_section('hidden'):\n            hidden = self.items('hidden')\n            self.remove_section('hidden')\n\n        cfp = open(filename, 'w')\n        self._write_config(cfp, verbose)\n        cfp.close()\n\n        if hidden is not None:\n            for key, value in hidden:\n                self.set('hidden', key, value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite the current config to the given filedescriptor which has must be opened for writing.", "response": "def _write_config(self, filedesc, verbose=False):\n        ''' Write the current config to the given filedescriptor which has must\n            be opened for writing.\n            Only the config values different from the default value are written\n\n            If the verbose switch is turned on the config file generated will\n            have all values including the default values shown but they will\n            be commented out. In addition the description of each paramters\n            is stored before the value.\n\n            @param filedesc: The file to write the config into\n            @param verbose: The switch between the minimalistic and the more\n                    verbose config file.\n        '''\n        desc = []\n        for section in self.sections():\n            if section.lower() in ('', 'hidden'):\n                continue\n            desc.append(\"\")\n            desc.append('[{0}]'.format(section))\n            for key in self.options(section):\n                descr, value_type, default = self.get_description(section, key)\n                if verbose:\n                    desc.append(_format_message(descr, 78, \"# \"))\n                    desc.append(\"# Type: [{0}]\".format(str(value_type)))\n                    desc.append(\"# {0}={1}\".format(key, default))\n                if not self.get(section, key) == default:\n                    desc.append('{0}={1}'.format(key,\n                        self.get(section, key)))\n                if verbose:\n                    desc.append(\"\")\n\n        filedesc.write(\"{0}\\n\".format(\"\\n\".join(desc[1:])))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding the given section with the given paramters to the config.", "response": "def _add_section_default(self, section, parameters):\n        ''' Add the given section with the given paramters to the config. The\n            parameters must be a dictionary with all the keys to add. Each key\n            must be specified as an other dictionary with the following\n            parameters: default, description, type\n\n            @param section: The section to add\n            @param parameters: The paramters dictionary\n        '''\n        section = section.lower()\n        if not self.has_section(section):\n            self.add_section(section)\n\n        if not section in self.config_description:\n            self.config_description[section] = {}\n\n        for key, value in parameters.items():\n            key = key.lower()\n            if not ('default' in value and 'type' in value and\n                    'description' in value):\n                raise AppConfigValueException('For the given key not all '\n                        'required values are defined.')\n            if not self.has_option(section, key):\n                self.set(section, key, value['default'])\n            vtype = _get_type(value['type'])\n            self.config_description[section][key] = (value['description'],\n                    vtype, value['default'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef serialize(self, data):\n\n        super(Serializer, self).serialize(data)\n        self.resp.body = json.dumps(data)", "response": "Call json. dumps & let it rip"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef surround_previous_word(input_str):\n    '''\n    Surround last word in string with parentheses. If last non-whitespace character\n    is delimiter, do nothing\n    '''\n    start = None\n    end = None\n    for i, char in enumerate(reversed(input_str)):\n        if start is None:\n            if char in '{}()[]<>?|':\n                return input_str\n            elif char != ' ':\n                start = i\n        else:\n            if char in '{}()[]<>?| ':\n                end = i\n                break\n    if start is None:\n        return input_str\n    if end is None:\n        end = len(input_str)\n    new_str = ''\n    for i, char in enumerate(reversed(input_str)):\n        if char == ' ' and i + 1 == start:\n            continue\n        if i == start:\n            new_str += ') '\n        elif i == end:\n            new_str += '('\n        new_str += char\n    if end == len(input_str):\n        new_str += '('\n    return new_str[::-1]", "response": "Surround last word in string with parentheses. If last non - whitespace character is delimiter do nothing\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake a list of items and return a list of groups of size n.", "response": "def _grouped(iterable, n):\n        \"\"\"\n        take a list of items and return a list of groups of size n.\n        :param n: the size of the groups to return\n        \"\"\"\n        args = [iter(iterable)] * n\n        return [[e for e in t if not e is None] for t in zip_longest(*args, fillvalue=None)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _limit_call_handler(self):\n        # acquire a lock on our threading.Lock() object\n        with self.limit_lock:\n            # if we have no configured limit, exit.  the lock releases based on scope\n            if self.limit_per_min <= 0:\n                return\n\n            now = time.time()\n            # self.limits is a list of query times + 60 seconds.  In essence it is a list of times\n            # that queries time out of the 60 second query window.\n\n            # this check expires any limits that have passed\n            self.limits = [l for l in self.limits if l > now]\n            # and we tack on the current query\n            self.limits.append(now + 60)\n\n            # if we have more than our limit of queries (and remember, we call this before we actually\n            # execute a query) we sleep until the oldest query on the list (element 0 because we append\n            # new queries) times out.  We don't worry about cleanup because next time this routine runs\n            # it will clean itself up.\n            if len(self.limits) >= self.limit_per_min:\n                time.sleep(self.limits[0] - now)", "response": "Ensure we don t exceed the N requests a minute limit by leveraging a thread lock and then sleep until the oldest query is reached."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncategorizing the thing it gets passed into one of the items VT supports Returns a sting representation of the type of parameter passed in. \\n :param thing: a parameter to identify. this can be a list of string or a string :return: a string representing the identified type of the input thing. If the input thing is a list the first element of the list is used to identify.", "response": "def _whatis(self, thing):\n        \"\"\"\n        Categorizes the thing it gets passed into one of the items VT supports\n        Returns a sting representation of the type of parameter passed in. \\n\n        :param thing: a parameter to identify. this can be a list of string or a string\n        :return: a string representing the identified type of the input thing. If the input thing is a list the\n         first element of the list is used to identify.\n        \"\"\"\n        # per the API, bulk requests must be of the same type\n        # ignore that you can intersperse scan IDs and hashes for now\n        # ...although, does that actually matter given the API semantics?\n        if isinstance(thing, list):\n            thing = thing[0]\n\n        # implied failure case, thing is neither a list or a file, so we assume string\n        if not isinstance(thing, str):\n            return \"%s\" % API_Constants.UNKNOWN\n\n        if os.path.isfile(thing):\n            if thing.endswith(\".base64\"):\n                    return API_Constants.BASE64\n            else:\n                return API_Constants.FILE_NAME\n\n        elif API_Constants.HASH_RE.match(thing):\n            return API_Constants.HASH\n\n        elif API_Constants.IP_RE.match(thing):\n            return API_Constants.IP\n\n        elif API_Constants.DOMAIN_RE.match(thing):\n            return API_Constants.DOMAIN\n\n        elif API_Constants.SCAN_ID_RE.match(thing):\n            return API_Constants.SCANID\n\n        elif urllib.parse.urlparse(thing).scheme:\n            return API_Constants.URL\n\n        else:\n            return API_Constants.UNKNOWN"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsubmit a GET request to the VT API", "response": "def _get_query(self, query, params):\n        \"\"\"\n        Submit a GET request to the VT API\n        :param query: The query (see https://www.virustotal.com/en/documentation/private-api/ for types of queries)\n        :param params: parameters of the query\n        :return: JSON formatted response from the API\n        \"\"\"\n        if \"apikey\" not in params:\n            params[\"apikey\"] = self.api_key\n\n        response = requests.get(query, params=params)\n        return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _post_query(self, query, params):\n        if \"apikey\" not in params:\n            params[\"apikey\"] = self.api_key\n\n        response = requests.post(query, data=params)\n        return response.json()", "response": "Submit a POST request to the VT API"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef retrieve(self, thing, thing_type=None):\n        # trust the user-supplied type over the automatic identification\n        thing_id = self._whatis(thing)\n        if thing_type is None:\n            thing_type = thing_id\n\n        query_parameters = {}\n\n        # Query API for URL(s)\n        if thing_type == API_Constants.URL:  # Get the scan results for a given URL or list of URLs.\n            query = API_Constants.CONST_API_URL + API_Constants.API_ACTION_GET_URL_REPORT\n            if not isinstance(thing, list):\n                thing = [thing]\n            grouped_urls = self._grouped(thing, self._urls_per_retrieve)  # break list of URLS down to API limits\n            results = {}\n\n            for group in grouped_urls:\n                query_parameters = {\"resource\": \"\\n\".join([url for url in group])}\n                self._limit_call_handler()\n                try:\n                    response = self._post_query(query, query_parameters)\n                except:\n                    raise TypeError\n\n                # If we get a list of URLs that has N urls and N mod '_url_per_retrieve' is 1\n                # for example  [url, url, url], when limit is 2, the last query will not return a list\n                if not isinstance(response, list):\n                    response = [response]\n\n                for index, scanid in enumerate(group):\n                    results[scanid] = response[index]\n\n            result = results\n\n        # Query API for domain(s)\n        elif thing_type == API_Constants.DOMAIN:\n\n            query = API_Constants.CONST_API_URL + API_Constants.API_ACTION_GET_DOMAIN_REPORT\n            if not isinstance(thing, list):\n                thing = [thing]\n            results = {}\n            for domain in thing:\n                query_parameters[\"domain\"] = domain\n                self._limit_call_handler()\n                response = self._get_query(query, query_parameters)\n                results[domain] = response\n\n            result = results\n\n        # Query API for IP(s)\n        elif thing_type == API_Constants.IP:\n\n            query = API_Constants.CONST_API_URL + API_Constants.API_ACTION_GET_IP_REPORT\n\n            if not isinstance(thing, list):\n                thing = [thing]\n\n            results = {}\n            for ip in thing:\n                query_parameters[\"ip\"] = ip\n                self._limit_call_handler()\n                try:\n                    response = self._get_query(query, query_parameters)\n                except:\n                    raise TypeError\n                results[ip] = response\n\n            result = results\n\n        # Query API for HASH, bulk HASH queries not possible\n        elif thing_type == API_Constants.HASH:\n\n            query = API_Constants.CONST_API_URL + API_Constants.API_ACTION_GET_FILE_REPORT\n\n            results = {}\n            if not isinstance(thing, list):\n                thing = [thing]\n            query_parameters[\"resource\"] = \", \".join(thing)\n            self._limit_call_handler()\n            response = self._get_query(query, query_parameters)\n\n            if not isinstance(response, list):\n                response = [response]\n\n            for index, hash in enumerate(thing):\n                results[hash] = response[index]\n            result = results\n\n        elif thing_type == \"scanid\":\n            query = API_Constants.CONST_API_URL + API_Constants.API_ACTION_GET_URL_REPORT\n            if not isinstance(thing, list):\n                thing = [thing]\n            results = {}\n\n            for scanid in thing:\n                query_parameters[\"resource\"] = scanid\n                self._limit_call_handler()\n                try:\n                    response = self._post_query(query, query_parameters)\n                except:\n                    raise TypeError\n                results[scanid] = response\n\n            result = results\n        else:\n            raise TypeError(\"Unimplemented '%s'.\" % thing_type)\n\n        return result", "response": "Retrieve a report from VirusTotal based on a given thing."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_form_media_type(media_type):\n    base_media_type, params = parse_header(media_type.encode(HTTP_HEADER_ENCODING))\n    return (base_media_type == 'application/x-www-form-urlencoded' or\n            base_media_type == 'multipart/form-data')", "response": "Return True if the media type is a valid form media type."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clone_request(request, method):\n    ret = Request(request=request._request,\n                  parsers=request.parsers,\n                  authenticators=request.authenticators,\n                  negotiator=request.negotiator,\n                  parser_context=request.parser_context)\n    ret._data = request._data\n    ret._files = request._files\n    ret._full_data = request._full_data\n    ret._content_type = request._content_type\n    ret._stream = request._stream\n    ret.method = method\n    if hasattr(request, '_user'):\n        ret._user = request._user\n    if hasattr(request, '_auth'):\n        ret._auth = request._auth\n    if hasattr(request, '_authenticator'):\n        ret._authenticator = request._authenticator\n    if hasattr(request, 'accepted_renderer'):\n        ret.accepted_renderer = request.accepted_renderer\n    if hasattr(request, 'accepted_media_type'):\n        ret.accepted_media_type = request.accepted_media_type\n    if hasattr(request, 'version'):\n        ret.version = request.version\n    if hasattr(request, 'versioning_scheme'):\n        ret.versioning_scheme = request.versioning_scheme\n    return ret", "response": "Internal helper method to clone a request with a different HTTP method."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the user on the current request.", "response": "def user(self, value):\n        \"\"\"\n        Sets the user on the current request. This is necessary to maintain\n        compatibility with django.contrib.auth where the user property is\n        set in the login and logout functions.\n\n        Note that we also set the user on Django's underlying `HttpRequest`\n        instance, ensuring that it is available to any middleware in the stack.\n        \"\"\"\n        self._user = value\n        self._request.user = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef auth(self, value):\n        self._auth = value\n        self._request.auth = value", "response": "Sets any non - user authentication information associated with the current request."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads the data and files into self. data.", "response": "def _load_data_and_files(self):\n        \"\"\"\n        Parses the request content into `self.data`.\n        \"\"\"\n        if not _hasattr(self, '_data'):\n            self._data, self._files = self._parse()\n            if self._files:\n                self._full_data = self._data.copy()\n                self._full_data.update(self._files)\n            else:\n                self._full_data = self._data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _load_stream(self):\n        meta = self._request.META\n        try:\n            content_length = int(\n                meta.get('CONTENT_LENGTH', meta.get('HTTP_CONTENT_LENGTH', 0))\n            )\n        except (ValueError, TypeError):\n            content_length = 0\n\n        if content_length == 0:\n            self._stream = None\n        elif hasattr(self._request, 'read'):\n            self._stream = self._request\n        else:\n            self._stream = six.BytesIO(self.raw_post_data)", "response": "Load the content of the request as a stream."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the request content returning a two - tuple of data and files.", "response": "def _parse(self):\n        \"\"\"\n        Parse the request content, returning a two-tuple of (data, files)\n\n        May raise an `UnsupportedMediaType`, or `ParseError` exception.\n        \"\"\"\n        stream = self.stream\n        media_type = self.content_type\n\n        if stream is None or media_type is None:\n            empty_data = QueryDict('', encoding=self._request._encoding)\n            empty_files = MultiValueDict()\n            return (empty_data, empty_files)\n\n        parser = self.negotiator.select_parser(self, self.parsers)\n\n        if not parser:\n            raise exceptions.UnsupportedMediaType(media_type)\n\n        try:\n            parsed = parser.parse(stream, media_type, self.parser_context)\n        except:\n            # If we get an exception during parsing, fill in empty data and\n            # re-raise.  Ensures we don't simply repeat the error when\n            # attempting to render the browsable renderer response, or when\n            # logging the request or similar.\n            self._data = QueryDict('', encoding=self._request._encoding)\n            self._files = MultiValueDict()\n            self._full_data = self._data\n            raise\n\n        # Parser classes may return the raw data, or a\n        # DataAndFiles object.  Unpack the result as required.\n        try:\n            return (parsed.data, parsed.files)\n        except AttributeError:\n            empty_files = MultiValueDict()\n            return (parsed, empty_files)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _authenticate(self):\n        for authenticator in self.authenticators:\n            try:\n                user_auth_tuple = authenticator.authenticate(self)\n            except exceptions.APIException:\n                self._not_authenticated()\n                raise\n\n            if user_auth_tuple is not None:\n                self._authenticator = authenticator\n                self.user, self.auth = user_auth_tuple\n                return\n\n        self._not_authenticated()", "response": "Attempts to authenticate the request using each authentication instance in turn."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _not_authenticated(self):\n        self._authenticator = None\n\n        if api_settings.UNAUTHENTICATED_USER:\n            self.user = api_settings.UNAUTHENTICATED_USER()\n        else:\n            self.user = None\n\n        if api_settings.UNAUTHENTICATED_TOKEN:\n            self.auth = api_settings.UNAUTHENTICATED_TOKEN()\n        else:\n            self.auth = None", "response": "Return a three - tuple representing\n        an unauthenticated request."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates an antonym using a Synset and its lemmas.", "response": "def generate_antonym(self, input_word):\n        \"\"\" Generate an antonym using a Synset\n        and its lemmas.\n        \"\"\"\n        results = []\n        synset = wordnet.synsets(input_word)\n        for i in synset:\n            if i.pos in ['n','v']:\n                for j in i.lemmas:\n                   if j.antonyms():\n                       name = j.antonyms()[0].name\n                       results.append(PataLib().strip_underscore(name))\n        results = {'input' : input_word, 'results' : results, 'category' : 'antonym'} \n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an instance of the extension with a given name.", "response": "def get(self, name, default=None):\n        \"\"\"\n        Returns an extension instance with a given name.\n\n        In case there are few extensions with a given name, the first one\n        will be returned. If no extensions with a given name are exist,\n        the `default` value will be returned.\n\n        :param name: (str) an extension name\n        :param default: (object) a fallback value\n        :returns: (object) an extension instance\n        \"\"\"\n        try:\n            value = self[name]\n        except KeyError:\n            value = default\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncut line so it fits into polygon", "response": "def cutToFitIntoPolygon(line, polygon):\n    \"\"\"\n    cut line so it fits into polygon\n    polygon = (( x0,y0), (x1,y1) ,...)\n    \"\"\"\n    p0_inside = pointInsidePolygon(line[0], line[1], polygon)\n    p1_inside = pointInsidePolygon(line[2], line[3], polygon)\n\n    if not p0_inside or not p1_inside:\n        for (i0, j0), (i1, j1) in zip(polygon[:-1], polygon[1:]):\n\n            isec = segmentIntersection(line, (i0, j0, i1, j1))\n\n            if isec is not None:\n                if not p0_inside:\n                    line = (isec[0], isec[1], line[2], line[3])\n                    p0_inside = True\n                elif not p1_inside:\n                    line = (line[0], line[1], isec[0], isec[1])\n                    p1_inside = True\n\n            if p0_inside and p1_inside:\n                break\n    return line"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sort(line):\n    x0, y0, x1, y1 = line\n    #     if (x0**2+y0**2)**0.5 < (x1**2+y1**2)**0.5:\n    #         return (x1,y1,x0,y0)\n    #     return line\n    #\n    #     if x1 < x0:\n    #         return (x1,y1,x0,y0)\n    #     return line\n\n    turn = False\n\n    if abs(x1 - x0) > abs(y1 - y0):\n        if x1 < x0:\n            turn = True\n    elif y1 < y0:\n        turn = True\n\n    if turn:\n        return (x1, y1, x0, y0)\n        #  return line[(2,3,0,1)]\n    return line", "response": "sorts a line according to the current position"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns normalised ascent vector", "response": "def dxdy(line):\n    \"\"\"\n    return normalised ascent vector\n    \"\"\"\n    x0, y0, x1, y1 = line\n    dx = float(x1 - x0)\n    dy = float(y1 - y0)\n    f = hypot(dx, dy)\n    return dx / f, dy / f"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fromAttr(mid, ang, dist):\n    mx, my = mid\n    dx = cos(ang) * dist * 0.5\n    dy = sin(ang) * dist * 0.5\n    return mx - dx, my - dy, mx + dx, my + dy", "response": "create from middle angle and distance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate from start angle and distance", "response": "def fromAttr2(start, ang, dist):\n    \"\"\"\n    create from start, angle and distance\n    \"\"\"\n    sx, sy = start\n    dx = cos(ang) * dist\n    dy = sin(ang) * dist\n    return sx, sy, sx + dx, sy + dy"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef merge(l1, l2):\n    x1, y1, x2, y2 = l1\n    xx1, yy1, xx2, yy2 = l2\n\n    comb = ((x1, y1, xx1, yy1),\n            (x1, y1, xx2, yy2),\n            (x2, y2, xx1, yy1),\n            (x2, y2, xx2, yy2))\n\n    d = [length(c) for c in comb]\n    i = argmax(d)\n\n    dist = d[i]\n    mid = middle(comb[i])\n\n    a = (angle(l1) + angle(l2)) * 0.5\n    return fromAttr(mid, a, dist)", "response": "merge two lines together"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resize(line, factor):\n    a = angle(line)\n    mx, my = middle(line)\n    d = length(line) * factor * 0.5\n    dx = cos(a) * d\n    dy = sin(a) * d\n    return mx - dx, my - dy, mx + dx, my + dy", "response": "resize a single line in a random order"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the distance between line and point", "response": "def distance(line, point):\n    \"\"\"\n    infinite line to point or line to line distance\n    is point is given as line - use middle point of that liune\n    \"\"\"\n    x0, y0, x1, y1 = line\n    try:\n        p1, p2 = point\n    except ValueError:\n        # line is given instead of point\n        p1, p2 = middle(point)\n    n1 = ascent(line)\n    n2 = -1\n    n0 = y0 - n1 * x0\n    return abs(n1 * p1 + n2 * p2 + n0) / (n1 ** 2 + n2 ** 2) ** 0.5"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pointIsBetween(startP, endP, p):\n    return (distancePoint(startP, p) + distancePoint(p, endP)\n            - distancePoint(startP, endP) < 1e-6)", "response": "Returns True if point is on a straight\n    line in - between two other points."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the coordinates of a point of intersection given two lines.", "response": "def intersection(line1, line2):\n    \"\"\"\n    Return the coordinates of a point of intersection given two lines.\n    Return None if the lines are parallel, but non-colli_near.\n    Return an arbitrary point of intersection if the lines are colli_near.\n\n    Parameters:\n    line1 and line2: lines given by 4 points (x0,y0,x1,y1).\n    \"\"\"\n    x1, y1, x2, y2 = line1\n    u1, v1, u2, v2 = line2\n    (a, b), (c, d) = (x2 - x1, u1 - u2), (y2 - y1, v1 - v2)\n    e, f = u1 - x1, v1 - y1\n    # Solve ((a,b), (c,d)) * (t,s) = (e,f)\n    denom = float(a * d - b * c)\n    if _near(denom, 0):\n        # parallel\n        # If colli_near, the equation is solvable with t = 0.\n        # When t=0, s would have to equal e/b and f/d\n        if b == 0 or d == 0:\n            return None\n        if _near(e / b, f / d):\n            # colli_near\n            px = x1\n            py = y1\n        else:\n            return None\n    else:\n        t = (e * d - b * f) / denom\n        # s = (a*f - e*c)/denom\n        px = x1 + t * (x2 - x1)\n        py = y1 + t * (y2 - y1)\n    return px, py"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef translate(line, ascent, offs=0):\n    # TODO: why do I have thuis factor here?\n    ascent *= -2\n    offs *= -2\n\n    l0 = length(line)\n\n    # change relative to line:\n    t0 = offs  # -h+offs\n    t1 = l0 * ascent + offs\n    return translate2P(line, t0, t1)", "response": "translate line to ascent and offs"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef split(line, lines):\n    out = empty((len(lines) + 1, 4))\n\n    p1 = line[:2]\n    for n, l2 in enumerate(lines):\n        p2 = intersection(line, l2)\n        out[n][:2] = p1\n        out[n][2:] = p2\n        p1 = p2\n    out[n + 1][:2] = p2\n    out[n + 1][2:] = line[2:]\n    return out", "response": "split <line > into multiple sublines\n    using intersection with lines"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef splitN(line, n):\n    x0, y0, x1, y1 = line\n\n    out = empty((n, 4), dtype=type(line[0]))\n    px, py = x0, y0\n    dx = (x1 - x0) / n\n    dy = (y1 - y0) / n\n\n    for i in range(n):\n        o = out[i]\n        o[0] = px\n        o[1] = py\n        px += dx\n        py += dy\n        o[2] = px\n        o[3] = py\n    return out", "response": "split a line n times\n    returns n sublines"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _same_named(fn, fn_list):\n    fn = _just_name(fn)\n\n    return filter(\n        lambda (i, filename): fn == _just_name(filename),\n        enumerate(fn_list)\n    )", "response": "Returns a list of filenames from fn_list which have same name as fn."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _remove_files(files):\n    logger.debug(\"Request for file removal (_remove_files()).\")\n\n    for fn in files:\n        if os.path.exists(fn):\n            logger.debug(\"Removing '%s'.\" % fn)\n            os.remove(fn)", "response": "Remove all given files."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _safe_read_meta_file(fn, error_protocol):\n    try:\n        return MetadataFile(fn)\n    except Exception, e:\n        error_protocol.append(\n            \"Can't read MetadataFile '%s':\\n\\t%s\\n\" % (fn, e.message)\n        )", "response": "Try to read a MetadataFile and return the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _process_pair(first_fn, second_fn, error_protocol):\n    ebook = None\n    metadata = None\n\n    if _is_meta(first_fn) and not _is_meta(second_fn):    # 1st meta, 2nd data\n        logger.debug(\n            \"Parsed: '%s' as meta, '%s' as data.\" % (first_fn, second_fn)\n        )\n        metadata, ebook = first_fn, second_fn\n    elif not _is_meta(first_fn) and _is_meta(second_fn):  # 1st data, 2nd meta\n        logger.debug(\n            \"Parsed: '%s' as meta, '%s' as data.\" % (second_fn, first_fn)\n        )\n        metadata, ebook = second_fn, first_fn\n    elif _is_meta(first_fn) and _is_meta(second_fn):      # both metadata\n        logger.debug(\n            \"Parsed: both '%s' and '%s' as meta.\" % (first_fn, second_fn)\n        )\n        return [\n            _safe_read_meta_file(first_fn, error_protocol),\n            _safe_read_meta_file(second_fn, error_protocol)\n        ]\n    else:                                                 # both data\n        logger.debug(\n            \"Parsed: both '%s' and '%s' as data.\" % (first_fn, second_fn)\n        )\n        return [\n            EbookFile(first_fn),\n            EbookFile(second_fn)\n        ]\n\n    # process pairs, which were created in first two branches of the if\n    # statement above\n    pair = DataPair(\n        metadata_file=_safe_read_meta_file(metadata, error_protocol),\n        ebook_file=EbookFile(ebook)\n    )\n    if not pair.metadata_file:\n        logger.error(\n            \"Can't parse MetadataFile '%s'. Continuing with data file '%s'.\" % (\n                metadata, ebook\n            )\n        )\n        return [pair.ebook_file]\n\n    return [pair]", "response": "Process pairs of EbookFile and DataPair objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _process_directory(files, user_conf, error_protocol):\n    items = []\n\n    banned = [settings.USER_IMPORT_LOG, settings.USER_ERROR_LOG]\n    files = filter(lambda x: not os.path.basename(x) in banned, files)\n\n    if len(files) == 2 and conf_merger(user_conf, \"SAME_DIR_PAIRING\"):\n        logger.debug(\"There are only two files.\")\n\n        items.extend(_process_pair(files[0], files[1], error_protocol))\n        files = []\n\n    while files:\n        same_names = []\n        fn = files.pop()\n\n        logger.debug(\"Processing '%s'.\" % fn)\n\n        # get files with same names (ignore paths and suffixes)\n        if conf_merger(user_conf, \"SAME_NAME_DIR_PAIRING\"):\n            same_names = _same_named(fn, files)  # returns (index, name)\n            indexes = map(lambda (i, fn): i, same_names)  # get indexes\n            same_names = map(lambda (i, fn): fn, same_names)  # get names\n\n            # remove `same_names` from `files` (they are processed in this\n            # pass)\n            for i in sorted(indexes, reverse=True):\n                del files[i]\n\n        # has exactly one file pair\n        SDP = conf_merger(user_conf, \"SAME_NAME_DIR_PAIRING\")\n        if len(same_names) == 1 and SDP:\n            logger.debug(\n                \"'%s' can be probably paired with '%s'.\" % (fn, same_names[0])\n            )\n            items.extend(_process_pair(fn, same_names[0], error_protocol))\n        elif not same_names:  # there is no similar files\n            logger.debug(\"'%s' can't be paired. Adding standalone file.\" % fn)\n            if _is_meta(fn):\n                items.append(_safe_read_meta_file(fn, error_protocol))\n            else:\n                items.append(EbookFile(fn))\n        else:  # error - there is too many similar files\n            logger.error(\n                \"Too many files with same name: %s\" % \", \".join(same_names)\n            )\n            error_protocol.append(\n                \"Too many files with same name:\" +\n                \"\\n\\t\".join(same_names) + \"\\n\\n---\\n\"\n            )\n\n    return filter(lambda x: x, items)", "response": "Process a directory and return a list of items."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _index(array, item, key=None):\n    for i, el in enumerate(array):\n        resolved_el = key(el) if key else el\n\n        if resolved_el == item:\n            return i\n\n    return -1", "response": "Array search function.\n\n    Written, because ``.index()`` method for array doesn't have `key` parameter\n    and raises `ValueError`, if the item is not found.\n\n    Args:\n        array (list): List of items, which will be searched.\n        item (whatever): Item, which will be matched to elements in `array`.\n        key (function, default None): Function, which will be used for lookup\n                                      into each element in `array`.\n\n    Return:\n        Index of `item` in `array`, if the `item` is in `array`, else `-1`."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _isbn_pairing(items):\n    NameWrapper = namedtuple(\"NameWrapper\", [\"name\", \"obj\"])\n    metas = map(\n        lambda x: NameWrapper(_just_name(x.filename), x),\n        filter(lambda x: isinstance(x, MetadataFile), items)\n    )\n    ebooks = map(\n        lambda x: NameWrapper(_just_name(x.filename), x),\n        filter(lambda x: isinstance(x, EbookFile), items)\n    )\n\n    # simple pairing mechanism, which shouldn't be O^2 complex, but something\n    # slightly better\n    metas = sorted(metas, key=lambda x: x.name)\n    ebooks = sorted(ebooks, key=lambda x: x.name, reverse=True)\n    while metas:\n        meta = metas.pop()\n\n        if not isbn_validator.is_valid_isbn(meta.name):\n            continue\n\n        if not ebooks:\n            break\n\n        ebook_index = _index(ebooks, meta.name, key=lambda x: x.name)\n\n        if ebook_index >= 0:\n            logger.debug(\n                \"Pairing '%s' and '%s'.\" % (\n                    meta.obj.filename,\n                    ebooks[ebook_index].obj.filename\n                )\n            )\n            items.append(\n                DataPair(\n                    metadata_file=meta.obj,\n                    ebook_file=ebooks[ebook_index].obj\n                )\n            )\n            items.remove(meta.obj)\n            items.remove(ebooks[ebook_index].obj)\n            ebooks = ebooks[ebook_index+1:]\n\n    return items", "response": "Pair items with same ISBN into DataPair objects."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _create_import_log(items):\n    log = []\n\n    for item in items:\n        if isinstance(item, MetadataFile):\n            log.append(\n                \"Metadata file '%s' successfully imported.\" % item.filename\n            )\n        elif isinstance(item, EbookFile):\n            log.append(\n                \"Ebook file '%s' successfully imported.\" % item.filename\n            )\n        elif isinstance(item, DataPair):\n            meta = item.metadata_file.filename\n            data = item.ebook_file.filename\n            log.extend([\n                \"Metadata and data files paired to epub. import request:\",\n                \"\\tMetadata file '%s' successfully imported.\" % meta,\n                \"\\tEbook file '%s' successfully imported.\" % data\n            ])\n\n    return log", "response": "Create a list of log entries that were successfully imported."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _process_items(items, user_conf, error_protocol):\n    def process_meta(item, error_protocol):\n        try:\n            return item._parse()\n        except Exception, e:\n            error_protocol.append(\n                \"Can't parse %s: %s\" % (item._get_filenames()[0], e.message)\n            )\n\n            if isinstance(item, DataPair):\n                return item.ebook_file\n\n    # process all items and put them to output queue\n    out = []\n    for item in items:\n        if isinstance(item, EbookFile):\n            out.append(item)\n        else:\n            out.append(process_meta(item, error_protocol))\n    out = filter(lambda x: x, out)  # remove None items (process_meta() fails)\n\n    # remove processed files\n    fn_pool = []\n    soon_removed = out if conf_merger(user_conf, \"LEAVE_BAD_FILES\") else items\n    for item in soon_removed:\n        fn_pool.extend(item._get_filenames())\n\n    _remove_files(fn_pool)\n\n    return out", "response": "Process items and return a list of items."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprocesses an import request.", "response": "def process_import_request(username, path, timestamp, logger_handler):\n    \"\"\"\n    React to import request. Look into user's directory and react to files\n    user uploaded there.\n\n    Behavior of this function can be set by setting variables in\n    :mod:`ftp.settings`.\n\n    Args:\n        username (str): Name of the user who triggered the import request.\n        path (str): Path to the file, which triggered import request.\n        timestamp (float): Timestamp of the event.\n        logger_handler (object): Python logger. See :py:mod:`logging` for\n                                 details.\n\n    Returns:\n        ::class:`.ImportRequest`.\n    \"\"\"\n    items = []\n    error_protocol = []\n\n    # import logger into local namespace\n    global logger\n    logger = logger_handler\n\n    # read user configuration\n    user_conf = passwd_reader.read_user_config(username)\n\n    # lock directory to prevent user to write during processing of the batch\n    logger.info(\"Locking user\u00b4s directory.\")\n    recursive_chmod(path, 0555)\n\n    try:\n        # pick up pairs in directories\n        for root, dirs, files in os.walk(path):\n            for dn in dirs + [path]:\n                dn = os.path.join(root, dn)\n                dir_list = map(lambda fn: dn + \"/\" + fn, os.listdir(dn))\n                files = _filter_files(dir_list)\n\n                logger.info(\"Processing directory '%s'.\" % dn)\n\n                items.extend(\n                    _process_directory(\n                        files,\n                        user_conf,\n                        error_protocol,\n                    )\n                )\n\n        if conf_merger(user_conf, \"ISBN_PAIRING\"):\n            logger.debug(\"ISBN_PAIRING is ON.\")\n            logger.info(\"Pairing user's files by ISBN filename.\")\n            items = _isbn_pairing(items)\n\n        # parse metadata and remove files from disk\n        items = _process_items(items, user_conf, error_protocol)\n\n        # unlink blank directories left by processing files\n        logger.info(\"Removing blank directories.\")\n        all_dirs = []\n        for root, dirs, files in os.walk(path):\n            all_dirs.extend(\n                map(lambda x: os.path.join(root, x), dirs)\n            )\n\n        for dn in sorted(all_dirs, reverse=True):\n            content = os.listdir(dn)\n            if not content:\n                logger.debug(\"Removing blank directory '%s'.\" % dn)\n                shutil.rmtree(dn)\n            else:\n                logger.debug(\"Leaving non-blank directory: '%s'\" % dn)\n                logger.debug(\"Content:\\n\\t%s\" % \"\\n\\t\".join(content))\n\n    finally:\n        # unlock directory\n        logger.info(\"Unlocking user\u00b4s directory.\")\n        recursive_chmod(path, 0775)\n        logger.info(\"Creating lock file '%s'.\" % settings.LOCK_FILENAME)\n        create_lock_file(path + \"/\" + settings.LOCK_FILENAME)\n\n        # process errors if found\n        if error_protocol:\n            logger.error(\n                \"Found %d error(s).\" % len(error_protocol)\n            )\n\n            err_path = path + \"/\" + settings.USER_ERROR_LOG\n            with open(err_path, \"w\") as fh:\n                fh.write(\"\\n\".join(error_protocol))\n\n            logger.error(\"Error protocol saved to '%s'.\" % err_path)\n\n        # process import log\n        import_log = _create_import_log(items)\n        if import_log and conf_merger(user_conf, \"CREATE_IMPORT_LOG\"):\n            logger.debug(\"CREATE_IMPORT_LOG is on.\")\n\n            imp_path = path + \"/\" + settings.USER_IMPORT_LOG\n            with open(imp_path, \"w\") as f:\n                if error_protocol:\n                    f.write(\"Status: Error\\n\\n\")\n                    f.write(\"Error: Import only partially successful.\\n\")\n                    f.write(\n                        \"See '%s' for details.\\n\" % settings.USER_ERROR_LOG\n                    )\n                    f.write(\"\\n--- Errors ---\\n\")\n                    f.write(\"\\n\".join(error_protocol))\n                    f.write(\"\\n\\n--- Successfully imported files ---\\n\")\n                else:\n                    f.write(\"Status: Ok\\n\\n\")\n                    f.write(\"--- Sucess ---\\n\")\n                f.write(\"\\n\".join(import_log))\n\n            logger.info(\"Created import protocol '%s'.\" % imp_path)\n\n    return ImportRequest(\n        username=username,\n        requests=items,\n        import_log=\"\\n\".join(import_log),\n        error_log=\"\\n\".join(error_protocol)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstart driving the chain asynchronously return immediately", "response": "def start(self, daemon=True):\n        \"\"\"\n        Start driving the chain asynchronously, return immediately\n\n        :param daemon: ungracefully kill the driver when the program terminates\n        :type daemon: bool\n        \"\"\"\n        if self._run_lock.acquire(False):\n            try:\n                # there is a short race window in which `start` release the lock,\n                # but `run` has not picked it up yet, but the thread exists anyway\n                if self._run_thread is None:\n                    self._run_thread = threading.Thread(target=self._run_in_thread)\n                    self._run_thread.daemon = daemon\n                    self._run_thread.start()\n            finally:\n                self._run_lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(self):\n        with self._run_lock:\n            while self.mounts:\n                for mount in self.mounts:\n                    try:\n                        next(mount)\n                    except StopIteration:\n                        self.mounts.remove(mount)", "response": "Start driving the chain until done."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fill(self, color):\n        self.matrix = [[color for _ in range(self.height)] for _ in range(self.width)]", "response": "Fill the whole screen with the given color."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndrawing one single dot with the given color on the screen.", "response": "def draw_dot(self, pos, color):\n        \"\"\"\n        Draw one single dot with the given color on the screen.\n\n        :param pos: Position of the dot\n        :param color: COlor for the dot\n        :type pos: tuple\n        :type color: tuple\n        \"\"\"\n        if 0 <= pos[0] < self.width and 0 <= pos[1] < self.height:\n            self.matrix[pos[0]][pos[1]] = color"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndraw a line on the screen.", "response": "def draw_line(self, start, end, color):\n        \"\"\"\n        Draw a line with the given color on the screen.\n\n        :param start: Start point of the line\n        :param end: End point of the line\n        :param color: Color of the line\n        :type start: tuple\n        :type end: tuple\n        :type color: tuple\n        \"\"\"\n        def dist(p, a, b):\n            return (abs((b[0] - a[0]) * (a[1] - p[1]) - (a[0] - p[0]) * (b[1] - a[1])) /\n                    math.sqrt((b[0] - a[0])**2 + (b[1] - a[1])**2))\n\n        points = []\n        for x in range(min(start[0], end[0]), max(start[0], end[0]) + 1):\n            for y in range(min(start[1], end[1]), max(start[1], end[1]) + 1):\n                if dist((x, y), start, end) < 0.5:\n                    points.append((x, y))\n        for point in points:\n            self.draw_dot(point, color)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndraws a rectangle on the screen.", "response": "def draw_rect(self, pos, size, color, fillcolor=None):\n        \"\"\"\n        Draw a rectangle with the given color on the screen and optionally fill it with fillcolor.\n\n        :param pos: Top left corner of the rectangle\n        :param size: Sieze of the rectangle\n        :param color: Color for borders\n        :param fillcolor: Color for infill\n        :type pos: tuple\n        :type size: tuple\n        :type color: tuple\n        :type fillcolor: tuple\n        \"\"\"\n        # draw top and botton line\n        for x in range(size[0]):\n            self.draw_dot((pos[0] + x, pos[1]), color)\n            self.draw_dot((pos[0] + x, pos[1] + size[1] - 1), color)\n        # draw left and right side\n        for y in range(size[1]):\n            self.draw_dot((pos[0], pos[1] + y), color)\n            self.draw_dot((pos[0] + size[0] - 1, pos[1] + y), color)\n        # draw filled rect\n        if fillcolor and size[0] >= 3 and size[1] >= 3:\n            for x in range(size[0] - 2):\n                for y in range(size[1] - 2):\n                    self.draw_dot((pos[0] + 1 + x, pos[1] + 1 + y), fillcolor)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndraws a circle on the screen and optionally fill it with fillcolor.", "response": "def draw_circle(self, pos, radius, color, fillcolor=None):\n        \"\"\"\n        Draw a circle with the given color on the screen and optionally fill it with fillcolor.\n\n        :param pos: Center of the circle\n        :param radius: Radius\n        :param color: Color for border\n        :param fillcolor: Color for infill\n        :type pos: tuple\n        :type radius: int\n        :type color: tuple\n        :type fillcolor: tuple\n        \"\"\"\n        #TODO: This still produces rubbish but it's on a good way to success\n        def dist(d, p, r):\n            return abs(math.sqrt((p[0] - d[0])**2 + (p[1] - d[1])**2) - r)\n\n        points = []\n        for x in range(pos[0] - radius, pos[0] + radius):\n            for y in range(pos[1] - radius, pos[1] + radius):\n                if 0 < x < self.width and 0 < y < self.height:\n                    if dist((x, y), pos, radius) < 1.3:\n                        points.append((x, y))\n\n        # draw fill color\n        if fillcolor:\n            for point in points:\n                pass\n        # draw outline\n        for point in points:\n            self.draw_dot(point, color)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef blit(self, surface, pos=(0, 0)):\n        for x in range(surface.width):\n            for y in range(surface.height):\n                px = x + pos[0]\n                py = y + pos[1]\n                if 0 < px < self.width and 0 < py < self.height:\n                    self.matrix[px][py] = surface.matrix[x][y]", "response": "Blits a surface on this surface at pos"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef replace_color(self, before, after):\n        #TODO: find out if this actually works\n        #((self.matrix[x][y] = after for y in range(self.height) if self.matrix[x][y] == before) for x in range(self.width))\n        for x in range(self.width):\n            for y in range(self.height):\n                if self.matrix[x][y] == before:\n                    self.matrix[x][y] = after", "response": "Replaces a color on a surface with another color."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mypy():\n    if sys.version_info < (3, 4):\n        print(\"Mypy doesn't work on python < 3.4\")\n        return\n    if IS_TRAVIS:\n        command = \"{0} -m mypy {1} --ignore-missing-imports --strict\".format(PYTHON, PROJECT_NAME).strip()\n    else:\n        command = \"{0} mypy {1} --ignore-missing-imports --strict\".format(PIPENV, PROJECT_NAME).strip()\n\n    bash_process = subprocess.Popen(command.split(\" \"),\n                                    # shell=True,\n                                    stdout=subprocess.PIPE,\n                                    stderr=subprocess.PIPE\n                                    )\n    out, err = bash_process.communicate()  # wait\n    mypy_file = \"mypy_errors.txt\"\n    with open(mypy_file, \"w+\") as lint_file:\n        lines = out.decode().split(\"\\n\")\n        for line in lines:\n            if \"build_utils.py\" in line:\n                continue\n            if \"test.py\" in line:\n                continue\n            if \"tests.py\" in line:\n                continue\n            if \"/test_\" in line:\n                continue\n            if \"/tests_\" in line:\n                continue\n            else:\n                lint_file.writelines([line + \"\\n\"])\n\n    num_lines = sum(1 for line in open(mypy_file) if line and line.strip(\" \\n\"))\n    max_lines = 25\n    if num_lines > max_lines:\n        raise TypeError(\"Too many lines of mypy : {0}, max {1}\".format(num_lines, max_lines))", "response": "Check if the mypy is ok and if not then run it"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gemfury():\n    # fury login\n    # fury push dist/*.gz --as=YOUR_ACCT\n    # fury push dist/*.whl --as=YOUR_ACCT\n\n    cp = subprocess.run((\"fury login --as={0}\".format(GEM_FURY).split(\" \")),\n                        stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                        shell=False, check=True)\n    print(cp.stdout)\n\n    about = {}\n    with open(os.path.join(SRC, PROJECT_NAME, \"__version__.py\")) as f:\n        exec(f.read(), about)\n    version = Version(about[\"__version__\"])\n    print(\"Have version : \" + str(version))\n    print(\"Preparing to upload\")\n\n    if version not in get_versions():\n        for kind in [\"gz\", \"whl\"]:\n            try:\n                files = glob.glob(\"{0}dist/*.{1}\".format(SRC.replace(\".\", \"\"), kind))\n                for file_name in files:\n                    cp = subprocess.run((\"fury push {0} --as={1}\".format(file_name, GEM_FURY).split(\" \")),\n                                        stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                                        shell=False, check=True)\n                    print(\"result of fury push\")\n                    for stream in [cp.stdout, cp.stderr]:\n                        if stream:\n                            for line in stream.decode().split(\"\\n\"):\n                                print(line)\n\n            except subprocess.CalledProcessError as cpe:\n                print(\"result of fury push- got error\")\n                for stream in [cp.stdout, cp.stderr]:\n                    if stream:\n                        for line in stream.decode().split(\"\\n\"):\n                            print(line)\n                print(cpe)\n                raise", "response": "Push to gem fury"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef needs_label(model_field, field_name):\n    default_label = field_name.replace('_', ' ').capitalize()\n    return capfirst(model_field.verbose_name) != default_label", "response": "Returns True if the label based on the model s verbose name is not equal to the default label."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_field_kwargs(field_name, model_field):\n    kwargs = {}\n    validator_kwarg = list(model_field.validators)\n\n    # The following will only be used by ModelField classes.\n    # Gets removed for everything else.\n    kwargs['model_field'] = model_field\n\n    if model_field.verbose_name and needs_label(model_field, field_name):\n        kwargs['label'] = capfirst(model_field.verbose_name)\n\n    if model_field.help_text:\n        kwargs['help_text'] = model_field.help_text\n\n    max_digits = getattr(model_field, 'max_digits', None)\n    if max_digits is not None:\n        kwargs['max_digits'] = max_digits\n\n    decimal_places = getattr(model_field, 'decimal_places', None)\n    if decimal_places is not None:\n        kwargs['decimal_places'] = decimal_places\n\n    if isinstance(model_field, models.TextField):\n        kwargs['style'] = {'base_template': 'textarea.html'}\n\n    if isinstance(model_field, models.AutoField) or not model_field.editable:\n        # If this field is read-only, then return early.\n        # Further keyword arguments are not valid.\n        kwargs['read_only'] = True\n        return kwargs\n\n    if model_field.has_default() or model_field.blank or model_field.null:\n        kwargs['required'] = False\n\n    if model_field.null and not isinstance(model_field, models.NullBooleanField):\n        kwargs['allow_null'] = True\n\n    if model_field.blank and (isinstance(model_field, models.CharField) or\n                              isinstance(model_field, models.TextField)):\n        kwargs['allow_blank'] = True\n\n    if isinstance(model_field, models.FilePathField):\n        kwargs['path'] = model_field.path\n\n        if model_field.match is not None:\n            kwargs['match'] = model_field.match\n\n        if model_field.recursive is not False:\n            kwargs['recursive'] = model_field.recursive\n\n        if model_field.allow_files is not True:\n            kwargs['allow_files'] = model_field.allow_files\n\n        if model_field.allow_folders is not False:\n            kwargs['allow_folders'] = model_field.allow_folders\n\n    if model_field.choices:\n        # If this model field contains choices, then return early.\n        # Further keyword arguments are not valid.\n        kwargs['choices'] = model_field.choices\n        return kwargs\n\n    # Our decimal validation is handled in the field code, not validator code.\n    # (In Django 1.9+ this differs from previous style)\n    if isinstance(model_field, models.DecimalField):\n        validator_kwarg = [\n            validator for validator in validator_kwarg\n            if DecimalValidator and not isinstance(validator, DecimalValidator)\n        ]\n\n    # Ensure that max_length is passed explicitly as a keyword arg,\n    # rather than as a validator.\n    max_length = getattr(model_field, 'max_length', None)\n    if max_length is not None and (isinstance(model_field, models.CharField) or\n                                   isinstance(model_field, models.TextField)):\n        kwargs['max_length'] = max_length\n        validator_kwarg = [\n            validator for validator in validator_kwarg\n            if not isinstance(validator, validators.MaxLengthValidator)\n        ]\n\n    # Ensure that min_length is passed explicitly as a keyword arg,\n    # rather than as a validator.\n    min_length = next((\n        validator.limit_value for validator in validator_kwarg\n        if isinstance(validator, validators.MinLengthValidator)\n    ), None)\n    if min_length is not None and isinstance(model_field, models.CharField):\n        kwargs['min_length'] = min_length\n        validator_kwarg = [\n            validator for validator in validator_kwarg\n            if not isinstance(validator, validators.MinLengthValidator)\n        ]\n\n    # Ensure that max_value is passed explicitly as a keyword arg,\n    # rather than as a validator.\n    max_value = next((\n        validator.limit_value for validator in validator_kwarg\n        if isinstance(validator, validators.MaxValueValidator)\n    ), None)\n    if max_value is not None and isinstance(model_field, NUMERIC_FIELD_TYPES):\n        kwargs['max_value'] = max_value\n        validator_kwarg = [\n            validator for validator in validator_kwarg\n            if not isinstance(validator, validators.MaxValueValidator)\n        ]\n\n    # Ensure that max_value is passed explicitly as a keyword arg,\n    # rather than as a validator.\n    min_value = next((\n        validator.limit_value for validator in validator_kwarg\n        if isinstance(validator, validators.MinValueValidator)\n    ), None)\n    if min_value is not None and isinstance(model_field, NUMERIC_FIELD_TYPES):\n        kwargs['min_value'] = min_value\n        validator_kwarg = [\n            validator for validator in validator_kwarg\n            if not isinstance(validator, validators.MinValueValidator)\n        ]\n\n    # URLField does not need to include the URLValidator argument,\n    # as it is explicitly added in.\n    if isinstance(model_field, models.URLField):\n        validator_kwarg = [\n            validator for validator in validator_kwarg\n            if not isinstance(validator, validators.URLValidator)\n        ]\n\n    # EmailField does not need to include the validate_email argument,\n    # as it is explicitly added in.\n    if isinstance(model_field, models.EmailField):\n        validator_kwarg = [\n            validator for validator in validator_kwarg\n            if validator is not validators.validate_email\n        ]\n\n    # SlugField do not need to include the 'validate_slug' argument,\n    if isinstance(model_field, models.SlugField):\n        validator_kwarg = [\n            validator for validator in validator_kwarg\n            if validator is not validators.validate_slug\n        ]\n\n    # IPAddressField do not need to include the 'validate_ipv46_address' argument,\n    if isinstance(model_field, models.GenericIPAddressField):\n        validator_kwarg = [\n            validator for validator in validator_kwarg\n            if validator is not validators.validate_ipv46_address\n        ]\n\n    if getattr(model_field, 'unique', False):\n        unique_error_message = model_field.error_messages.get('unique', None)\n        if unique_error_message:\n            unique_error_message = unique_error_message % {\n                'model_name': model_field.model._meta.object_name,\n                'field_label': model_field.verbose_name\n            }\n        validator = UniqueValidator(\n            queryset=model_field.model._default_manager,\n            message=unique_error_message)\n        validator_kwarg.append(validator)\n\n    if validator_kwarg:\n        kwargs['validators'] = validator_kwarg\n\n    return kwargs", "response": "Returns a dictionary of keyword arguments for a given field."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_relation_kwargs(field_name, relation_info):\n    model_field, related_model, to_many, to_field, has_through_model = relation_info\n    kwargs = {\n        'queryset': related_model._default_manager,\n        'view_name': get_detail_view_name(related_model)\n    }\n\n    if to_many:\n        kwargs['many'] = True\n\n    if to_field:\n        kwargs['to_field'] = to_field\n\n    if has_through_model:\n        kwargs['read_only'] = True\n        kwargs.pop('queryset', None)\n\n    if model_field:\n        if model_field.verbose_name and needs_label(model_field, field_name):\n            kwargs['label'] = capfirst(model_field.verbose_name)\n        help_text = model_field.help_text\n        if help_text:\n            kwargs['help_text'] = help_text\n        if not model_field.editable:\n            kwargs['read_only'] = True\n            kwargs.pop('queryset', None)\n        if kwargs.get('read_only', False):\n            # If this field is read-only, then return early.\n            # No further keyword arguments are valid.\n            return kwargs\n\n        if model_field.has_default() or model_field.blank or model_field.null:\n            kwargs['required'] = False\n        if model_field.null:\n            kwargs['allow_null'] = True\n        if model_field.validators:\n            kwargs['validators'] = model_field.validators\n        if getattr(model_field, 'unique', False):\n            validator = UniqueValidator(queryset=model_field.model._default_manager)\n            kwargs['validators'] = kwargs.get('validators', []) + [validator]\n        if to_many and not model_field.blank:\n            kwargs['allow_empty'] = False\n\n    return kwargs", "response": "Returns a dictionary of keyword arguments for a flat relational field."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating the JS code for the API using one or more bases.", "response": "def create_api(bases, url, **kwargs):\n    \"\"\"Create the JS code for the API using one or more :class:`Bases <pyextdirect.configuration.Base>`\n\n    :param bases: configuration bases\n    :type bases: :class:`~pyextdirect.configuration.Base` or list of :class:`~pyextdirect.configuration.Base`\n    :param string url: see :func:`create_api_dict`\n    :param \\*\\*kwargs: see :func:`create_api_dict`\n\n    \"\"\"\n    return 'Ext.app.REMOTING_API = %s;' % json.dumps(create_api_dict(bases, url, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_api_dict(bases, url, **kwargs):\n    api = kwargs or {}\n    api.update({'type': 'remoting', 'url': url, 'actions': defaultdict(list), 'enableUrlEncode': 'data'})\n    if not isinstance(bases, list):\n        bases = [bases]\n    configuration = merge_configurations([b.configuration for b in bases])\n    for action, methods in configuration.iteritems():\n        for method, element in methods.iteritems():\n            if isinstance(element, tuple):\n                func = getattr(element[0], element[1])\n                attrs = len(inspect.getargspec(func)[0]) - 1\n            else:\n                func = element\n                attrs = len(inspect.getargspec(func)[0])\n            spec = {'name': method, 'len': attrs}\n            if func.exposed_kind == SUBMIT:\n                spec['formHandler'] = True\n            api['actions'][action].append(spec)\n    return api", "response": "Create an API dict for the base class."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a random OID from the given length.", "response": "def generate_uuid_based_oid(length=None):\n    \"\"\"\n    OID generator which uses uuid.uuid4 (random UUIDs) to produce result.\n    \"\"\"\n    length = min(length or OID_LENGTH, OID_MAX_LENGTH)\n\n    while True:\n        yield uuid.uuid4().hex.upper()[:length]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting sequence types to bundles", "response": "def bundle_sequences(element):\n    \"\"\"\n    Convert sequence types to bundles\n\n    This converter automatically constructs a :py:class:`~.Bundle`\n    from any :py:class:`tuple`, :py:class:`list` or :py:class:`set`\n    encountered during linking.\n    The following two lines produce the same chain:\n\n    .. code:: python\n\n        a >> [b, c, d] >> e\n        a >> Bundle((b, c, d)) >> e\n    \"\"\"\n    if isinstance(element, (tuple, list, set)):\n        return Bundle(element)\n    return NotImplemented"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of all the components that match the regex.", "response": "def chunk(self, regex):\n        '''FIXME:\n        '''\n        chunks = []\n        for component in self._content:\n            chunks.extend(\n                StringComponent(component.placeholder, s) for s in\n                regex.split(str(component)))\n        for i, (chunk1, chunk2) in enumerate(\n                zip(chunks, islice(chunks, 1, None))):\n            if chunk1.placeholder is not chunk2.placeholder:\n                # We're crossing a boundary between placeholders\n                if chunk1.strip() and chunk2.strip():\n                    # There's no whitespace at the boundary, so stick the\n                    # chunks together\n                    # FIXME: This sort of defeats the point of the regex, as we\n                    # only look at whitespace:\n                    chunks[i:i + 2] = [self.__class__((chunk1, chunk2))]\n        return chunks"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef strip(self):\n        '''FIXME:\n        '''\n        if len(self._content) == 0:\n            return self\n        elif len(self._content) == 1:\n            return self.__class__(self._content[0].strip())\n        else:\n            first_component = self._content[0]\n            last_component = self._content[-1]\n            total = (\n                (first_component.lstrip(),) +\n                self._content[1:-1] +\n                (last_component.rstrip(),))\n            return self.__class__(total)", "response": "Return a new object with the stripped version of the content."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the concrete string representation of this string.", "response": "def populate(self, terminal=None, styles=None, default_esc_seq=''):\n        '''Get the concrete (including terminal escape sequences)\n        representation of this string.\n\n        :parameter Terminal terminal: The terminal object to use for turning\n            formatting attributes such as :attr:`Root.format.blue` into\n            concrete escape sequences.\n        :parameter styles: An object from which to look up style definitions,\n            which ultimately resolve to escape sequences, but may resolve to\n            other intermediaries, including other styles.\n        :type styles: StylePlaceholderFactory or dict\n        :parameter str default_esc_seq: FIXME\n        :returns str: Returns a concrete string, containing all the escape\n            sequences required to render the string to the terminal with the\n            desired formatting.\n\n        .. note::\n            All parameters are optional, and will be populated with sensible\n            defaults if ommitted. This is to assist testing and experimentation\n            with lower-level parts of Junction. If you want to use a\n            :class:`StringWithFormatting` object as part of a wider\n            application, it is suggested that you always pass all the arguments\n            explicitly.\n        '''\n        terminal = terminal or get_terminal()\n        styles = styles or {}\n        return ''.join(\n            s.populate(terminal, styles, default_esc_seq) for s in\n            self._content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef init_app(self, app):\n        app.cli.add_command(upgrader_cmd)\n        app.extensions['invenio-upgrader'] = self", "response": "Initialize the Flask application."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd bolditalic CSS. :param app: Sphinx application context. :param env: Sphinx environment context.", "response": "def css(app, env):\n    \"\"\"\n    Add bolditalic CSS.\n\n    :param app: Sphinx application context.\n    :param env: Sphinx environment context.\n    \"\"\"\n    srcdir = os.path.abspath(os.path.dirname(__file__))\n    cssfile = 'bolditalic.css'\n    csspath = os.path.join(srcdir, cssfile)\n    buildpath = os.path.join(app.outdir, '_static')\n    try:\n        os.makedirs(buildpath)\n    except OSError:\n        if not os.path.isdir(buildpath):\n            raise\n    copy(csspath, buildpath)\n    app.add_stylesheet(cssfile)\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds bolditalic role. Returns 2 part tuple containing list of nodes to insert into the document and a list of system messages. Both are allowed to be empty. :param name: The role name used in the document. :param rawtext: The entire markup snippet, with role. :param text: The text marked with the role. :param lineno: The line number where rawtext appears in the input. :param inliner: The inliner instance that called this function. :param options: Directive options for customization. :param content: The directive content for customization.", "response": "def bolditalic(name, rawtext, text, lineno, inliner, options={}, content=[]):\n    \"\"\"\n    Add bolditalic role.\n\n    Returns 2 part tuple containing list of nodes to insert into the\n    document and a list of system messages.  Both are allowed to be\n    empty.\n\n    :param name: The role name used in the document.\n    :param rawtext: The entire markup snippet, with role.\n    :param text: The text marked with the role.\n    :param lineno: The line number where rawtext appears in the input.\n    :param inliner: The inliner instance that called this function.\n    :param options: Directive options for customization.\n    :param content: The directive content for customization.\n    \"\"\"\n    node = nodes.inline(rawtext, text)\n    node.set_class('bolditalic')\n    return [node], []"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef iswhat(o):\n    import inspect\n    isfs = {n: f for n, f in inspect.getmembers(inspect) if n[0:2] == \"is\"}\n    return {n: f(o) for n, f in isfs.items()}", "response": "Returns a dictionary of all possible identity checks available to\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nattempt to return the module in which o is defined.", "response": "def _safe_getmodule(o):\n    \"\"\"Attempts to return the module in which `o` is defined.\n    \"\"\"\n    from inspect import getmodule\n    try:\n        return getmodule(o)\n    except: # pragma: no cover\n        #There is nothing we can do about this for now.\n        msg.err(\"_safe_getmodule: {}\".format(o), 2)\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _safe_getattr(o):\n    def getattribute(attr): # pragma: no cover\n        if hasattr(o, \"__acornext__\") and o.__acornext__ is not None:\n            return o.__acornext__.__getattribute__(attr)\n        elif hasattr(o, \"__acorn__\") and o.__acorn__ is not None:\n            #Some of the functions have the original function (when it was not\n            #extended) in the __acorn__ attribute.\n            return o.__acorn__.__getattribute__(attr)\n        else:\n            return getattr(o, attr)\n    return getattribute", "response": "Returns the attribute from the specified object taking the acorn decoration\n            into account."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _safe_hasattr(o, attr):\n    try:\n        has = hasattr(o, attr)\n    except: # pragma: no cover\n        has = False\n        msg.err(\"_safe_hasattr: {}.{}\".format(o, attr), 2)\n        pass\n    return has", "response": "Returns True if o has the specified attribute."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _update_attrs(nobj, oobj, exceptions=None, acornext=False):\n    success = True\n    if (acornext and hasattr(oobj, \"__acornext__\")\n        and oobj.__acornext__ is not None): # pragma: no cover\n        target = oobj.__acornext__\n    else:\n        target = oobj\n        \n    for a, v in _get_members(target):\n        if hasattr(nobj, a):\n            #We don't want to overwrite something that acorn has already done.\n            continue\n        if a in [\"__class__\", \"__code__\", \"__closure__\"]:# pragma: no cover\n            #These attributes are not writeable by design.\n            continue\n        \n        if exceptions is None or a not in exceptions:\n            try:\n                setattr(nobj, a, v)\n            except TypeError:# pragma: no cover\n                #Some of the built-in types have __class__ attributes (for\n                #example) that we can't set on a function type. This catches\n                #that case and any others.\n                emsg = \"_update_attrs (type): {}.{} => {}\"\n                msg.err(emsg.format(nobj, a, target), 2)\n                pass\n            except AttributeError:# pragma: no cover\n                #Probably a read-only attribute that we are trying to set. Just\n                #ignore it.\n                emsg = \"_update_attrs (attr): {}.{} => {}\"\n                msg.err(emsg.format(nobj, a, target), 2)\n                pass\n            except ValueError:# pragma: no cover\n                emsg = \"_update_attrs (value): {}.{} => {}\"\n                msg.err(emsg.format(nobj, a, target), 2)\n                success = False\n\n    return success", "response": "Updates the attributes of nobj to match those of old and excluding any ArcGIS attributes in the exceptions list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_name_filter(package, context=\"decorate\", reparse=False):\n    global name_filters\n    pkey = (package, context)\n    if pkey in name_filters and not reparse:\n        return name_filters[pkey]\n    \n    from acorn.config import settings\n    spack = settings(package)\n\n    # The acorn.* sections allow for global settings that affect every package\n    # that ever gets wrapped.\n    sections = {\n        \"decorate\": [\"tracking\", \"acorn.tracking\"],\n        \"time\": [\"timing\", \"acorn.timing\"],\n        \"analyze\": [\"analysis\", \"acorn.analysis\"]\n        }\n\n    filters, rfilters = None, None\n    import re\n    if context in sections:\n        # We are interested in the 'filter' and 'rfilter' options if they exist.\n        filters, rfilters = [], []\n        ignores, rignores = [], []\n        for section in sections[context]:\n            if spack.has_section(section):\n                options = spack.options(section)\n                if \"filter\" in options:\n                    filters.extend(re.split(r\"\\s*\\$\\s*\", spack.get(section, \"filter\")))\n                if \"rfilter\" in options: # pragma: no cover\n                    #Until now, the fnmatch filters have been the most\n                    #useful. So I don't have any unit tests for regex filters.\n                    pfilters = re.split(r\"\\s*\\$\\s*\", spack.get(section, \"rfilter\"))\n                    rfilters.extend([re.compile(p, re.I) for p in pfilters])\n                if \"ignore\" in options:\n                    ignores.extend(re.split(r\"\\s*\\$\\s*\", spack.get(section, \"ignore\")))\n                if \"rignore\" in options: # pragma: no cover\n                    pignores = re.split(r\"\\s*\\$\\s*\", spack.get(section, \"rignore\"))\n                    rignores.extend([re.compile(p, re.I) for p in pfilters])\n\n        name_filters[pkey] = {\n            \"filters\": filters,\n            \"rfilters\": rfilters,\n            \"ignores\": ignores,\n            \"rignores\": rignores\n            }\n    else:\n        name_filters[pkey] = None\n    return name_filters[pkey]", "response": "Returns the name filter for the specified package and context."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns True if the specified function should be filtered in the specified package.", "response": "def filter_name(funcname, package, context=\"decorate\", explicit=False):\n    \"\"\"Returns True if the specified function should be filtered (i.e., included\n    or excluded for use in the specified context.)\n\n    Args: \n        funcname (str): name of the method/function being called.\n        package (str): name of the package that the method belongs to.\n        context (str): one of ['decorate', 'time', 'analyze']; specifies which\n          section of the configuration settings to check.\n        explicit (bool): when True, if a name is not explicitly specified for\n          inclusion, then the function returns False.\n\n    Returns:\n        bool: specifying whether the function should be decorated, timed or\n          analyzed.\n    \"\"\"\n    packfilter = _get_name_filter(package, context)\n    if packfilter is None:\n        # By default, if there are no rules specified, then we include\n        # everything.\n        return True\n\n    # First we handle the `fnmatch` filters. If something is explicitly included\n    # that takes precedence over the ignore filters.\n    matched = None\n    if packfilter[\"filters\"] is not None:\n        from fnmatch import fnmatch\n        for pattern in packfilter[\"filters\"]:\n            if fnmatch(funcname, pattern):\n                matched = True\n                return matched\n\n    #We don't have any use cases yet for regex filters.\n    if packfilter[\"rfilters\"] is not None: # pragma: no cover\n        for pattern in packfilter[\"rfilters\"]:\n            if pattern.match(funcname):\n                matched = True\n                return matched\n\n    if packfilter[\"ignores\"] is not None:\n        from fnmatch import fnmatch\n        for pattern in packfilter[\"ignores\"]:\n            if fnmatch(funcname, pattern):\n                matched = False\n                return matched\n\n    if packfilter[\"rignores\"] is not None: # pragma: no cover\n        for pattern in packfilter[\"rignores\"]:\n            if pattern.match(funcname):\n                matched = False\n                return matched\n\n    if matched is None:\n        matched = not explicit\n            \n    return matched"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a string representation of the tracker object for the given item.", "response": "def _tracker_str(item):\n    \"\"\"Returns a string representation of the tracker object for the given item.\n    \n    Args:\n        item: object to get tracker for.\n        fqdn (str): fully-qualified domain name of the object.\n    \"\"\"\n    instance = tracker(item)\n    if instance is not None:\n        if isinstance(instance, str):\n            return instance\n        elif isinstance(instance, tuple):\n            return instance\n        else:\n            return instance.uuid\n    else:\n        #Must be a simple built-in type like `int` or `float`, in which case we\n        #don't want to convert it to a string.\n        return item"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking the specified argument lists for objects that are trackable.", "response": "def _check_args(*argl, **argd):\n    \"\"\"Checks the specified argument lists for objects that are trackable.\n    \"\"\"\n    args = {\"_\": []}\n    for item in argl:\n        args[\"_\"].append(_tracker_str(item))\n           \n    for key, item in argd.items():\n        args[key] = _tracker_str(item)\n        \n    return args"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a reduced version of inspect. stack that includes only relevant function calls.", "response": "def _reduced_stack(istart=3, iend=5, ipython=True):\n    \"\"\"Returns the reduced function call stack that includes only relevant\n    function calls (i.e., ignores any that are not part of the specified package\n    or acorn.\n\n    Args:\n        package (str): name of the package that the logged method belongs to.\n    \"\"\"\n    import inspect\n    return [i[istart:iend] for i in inspect.stack() if _decorated_path(i[1])]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _pre_create(cls, atdepth, stackdepth, *argl, **argd):\n    from time import time\n    if not atdepth:\n        rstack = _reduced_stack()\n        reduced = len(rstack)\n        if msg.will_print(3): # pragma: no cover\n            sstack = [' | '.join(map(str, r)) for r in rstack]\n            msg.info(\"{} => stack ({}): {}\".format(cls.__fqdn__, len(rstack),\n                                                   ', '.join(sstack)), 3)\n    else:\n        reduced = stackdepth + 10\n\n    if reduced <= stackdepth:\n        args = _check_args(*argl, **argd)\n        entry = {\n            \"m\": \"{}.__new__\".format(cls.__fqdn__),\n            \"a\": args,\n            \"s\": time(),\n            \"r\": None,\n            \"stack\": reduced\n            }\n    else:\n        atdepth = True\n        entry = None\n\n    return (entry, atdepth)", "response": "Checks whether the logging should happen based on the specified\nElems parameters. If it should an initialized entry is returned. Otherwise None is returned."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _post_create(atdepth, entry, result):\n    if not atdepth and entry is not None:\n        if result is not None:\n            #We need to get these results a UUID that will be saved so that any\n            #instance methods applied to this object has a parent to refer to.\n            retid = _tracker_str(result)\n            entry[\"r\"] = retid\n            ekey = retid\n        else: # pragma: no cover\n            ekey = _tracker_str(cls)\n\n        msg.info(\"{}: {}\".format(ekey, entry), 1)\n        record(ekey, entry)", "response": "Finishes the entry logging if applicable."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef creationlog(base, package, stackdepth=_def_stackdepth):\n    @staticmethod\n    def wrapnew(cls, *argl, **argd):\n        global _atdepth_new, _cstack_new, streamlining\n        origstream = None\n        if not (decorating or streamlining):\n            entry, _atdepth_new = _pre_create(cls, _atdepth_new,\n                                              stackdepth, *argl, **argd)\n            _cstack_new.append(cls)\n\n            #See if we need to enable streamlining for this constructor.\n            fqdn = cls.__fqdn__\n            if fqdn in _streamlines and _streamlines[fqdn]:\n                #We only use streamlining for the plotting routines at the\n                #moment, so it doesn't get hit by the unit tests.\n                msg.std(\"Streamlining {}.\".format(fqdn), 2)\n                origstream = streamlining\n                streamlining = True\n            \n        try:\n            if six.PY2:\n                result = base.__old__(cls, *argl, **argd)\n            else: # pragma: no cover\n                #Python 3 changed the way that the constructors behave. In cases\n                #where a class inherits only from object, and doesn't override\n                #the __new__ method, the __old__ we replaced was just the one\n                #belonging to object.\n                if base.__old__ is object.__new__:\n                    result = base.__old__(cls)\n                else:\n                    result = base.__old__(cls, *argl, **argd)\n                    \n        except TypeError: # pragma: no cover\n            #This is a crazy hack! We want this to be dynamic so that it can\n            #work with any of the packages. If the error message suggests using\n            #a different constructor, we go ahead and use it.\n            import sys\n            xcls, xerr = sys.exc_info()[0:2]\n            referral = xerr.args[0].split()[-1]\n            if \".__new__()\" in referral:\n                t = eval(referral.split('.')[0])\n                result = t.__new__(cls, *argl, **argd)\n            else:\n                raise\n                result = None\n\n        if result is not None and hasattr(cls, \"__init__\"):\n            try:\n                cls.__init__(result, *argl, **argd)\n            except: # pragma: no cover\n                print(cls, argl, argd)\n                raise\n        else: # pragma: no cover\n            msg.err(\"Object initialize failed for {}.\".format(base.__name__))\n\n        #If we don't disable streamlining for the original method that set\n        #it, then the post call would never be reached.\n        if origstream is not None:\n            #We avoid another dict lookup by checking whether we set the\n            #*local* origstream to something above.\n            streamlining = origstream\n            \n        if not (decorating or streamlining):\n            _cstack_new.pop()\n            if len(_cstack_new) == 0:\n                _atdepth_new = False\n            _post_create(_atdepth_new, entry, result)\n                        \n        return result\n    return wrapnew", "response": "Decorator for creating the new class instances that are being logged by acorn."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck whether the logging should create an entry based on the stackdepth.", "response": "def _pre_call(atdepth, parent, fqdn, stackdepth, *argl, **argd):\n    \"\"\"Checks whether the logging should create an entry based on stackdepth. If\n    so, the entry is created.\n    \"\"\"\n    from time import time\n    if not atdepth:\n        rstack = _reduced_stack()\n        if \"<module>\" in rstack[-1]: # pragma: no cover\n            code = rstack[-1][1]\n        else:\n            code = \"\"\n\n        reduced = len(rstack)\n        if msg.will_print(3): # pragma: no cover\n            sstack = [' | '.join(map(str, r)) for r in rstack]\n            msg.info(\"{} => stack ({}): {}\".format(fqdn, len(rstack),\n                                             ', '.join(sstack)), 3)\n    else:\n        reduced = stackdepth + 10\n\n    bound = False\n    if reduced <= stackdepth:\n        args = _check_args(*argl, **argd)\n        # At this point, we should start the entry. If the method raises an\n        # exception, we should keep track of that. If this is an instance\n        # method, we should get its UUID, if not, then we can just store the\n        # entry under the full method name.\n\n        #There is yet another subtletly here: many packages have a base, static\n        #method that gets set as an instance method for sub-classes of a certain\n        #ABC. In that case, parent will be a super-class of the first argument,\n        #though the types will *not* be identical. Check for overlap in the base\n        #classes of the first argument. It would be nice if we could easily\n        #check for bound methods using inspect, but it doesn't work for some of\n        #the C-extension modules...\n        if (len(argl) > 0 and parent is not None and inspect.isclass(parent)):\n            ftype = type(argl[0])\n            if isinstance(argl[0], parent):\n                bound = True\n            elif (inspect.isclass(ftype) and hasattr(ftype, \"__bases__\") and\n                inspect.isclass(parent) and hasattr(parent, \"__bases__\")): # pragma: no cover\n                common = set(ftype.__bases__) & set(parent.__bases__)\n                bound = len(common) > 0\n                \n        if not bound:\n            #For now, we use the fqdn; later, if the result is not None, we\n            #will rather index this entry by the returned result, since we\n            #can also access the fqdn in the entry details.\n            ekey = fqdn\n        else:\n            # It must have the first argument be the instance.\n            ekey = _tracker_str(argl[0])\n\n        #Check whether the logging has been overidden by a configuration option.\n        if (fqdn not in _logging or _logging[fqdn]):\n            entry = {\n                \"m\": fqdn,\n                \"a\": args,\n                \"s\": time(),\n                \"r\": None,\n                \"c\": code,\n            }\n        else:\n            entry = None\n    else:\n        entry = None\n        atdepth = True\n        ekey = None\n\n    return (entry, atdepth, reduced, bound, ekey)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinishes constructing the log and records it to the database.", "response": "def _post_call(atdepth, package, fqdn, result, entry, bound, ekey, argl, argd):\n    \"\"\"Finishes constructing the log and records it to the database.\n    \"\"\"\n    from time import time\n    if not atdepth and entry is not None:\n        ek = ekey\n        if result is not None:\n            retid = _tracker_str(result)\n            if result is not None and not bound:\n                ek = retid\n                entry[\"r\"] = None\n            else:\n                entry[\"r\"] = retid\n            \n        name = fqdn.split('.')[-1]\n        if filter_name(fqdn, package, \"time\"):\n            entry[\"e\"] = time() - entry[\"s\"]\n        if filter_name(fqdn, package, \"analyze\"):\n            entry[\"z\"] = analyze(fqdn, result, argl, argd)\n\n        msg.info(\"{}: {}\".format(ek, entry), 1)\n        # Before we return the result, let's first save this call to the\n        # database so we have a record of it.\n        record(ek, entry)\n        return (ek, entry)\n    else:\n        return (None, None)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding logging for the post - call result of calling the method externally.", "response": "def post(fqdn, package, result, entry, bound, ekey, *argl, **argd):\n    \"\"\"Adds logging for the post-call result of calling the method externally.\n\n    Args:\n        fqdn (str): fully-qualified domain name of the function being logged.\n        package (str): name of the package we are logging for. Usually the first\n          element of `fqdn.split('.')`.\n        result: returned from calling the method we are logging.\n        entry (dict): one of the values returned by :func:`pre`.\n        bound (bool): true if the method is bound.\n        ekey (str): key under which to store the entry in the database.\n    \"\"\"\n    global _atdepth_call, _cstack_call\n    _cstack_call.pop()\n    if len(_cstack_call) == 0:\n        _atdepth_call = False\n    r = _post_call(_atdepth_call, package, fqdn, result,\n                   entry, bound, ekey, argl, argd)\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pre(fqdn, parent, stackdepth, *argl, **argd):\n    global _atdepth_call, _cstack_call\n    #We add +1 to stackdepth because this method had to be called in\n    #addition to the wrapper method, so we would be off by 1.\n    pcres = _pre_call(_atdepth_call, parent, fqdn, stackdepth+1,\n                      *argl, **argd)\n    entry, _atdepth_call, reduced, bound, ekey = pcres\n    _cstack_call.append(fqdn)\n    return (entry, bound, ekey)", "response": "Adds a logging entry for a call to the specified function that is being handled by an external module."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _create_extension(o, otype, fqdn, pmodule):\n    import types\n    xdict = {\"__acornext__\": o,\n             \"__doc__\": o.__doc__}\n\n    if otype == \"classes\":\n        classname = o.__name__\n        try:\n            if fqdn in _explicit_subclasses:\n                xclass = eval(_explicit_subclasses[fqdn])\n                xclass.__acornext__ = o\n            else:\n                xclass = type(classname, (o, ), xdict)\n            xclass.__module__ = o.__module__\n            return xclass\n        except TypeError:\n            #This happens when a class is final, meaning that it is not allowed\n            #to be subclassed.\n            _final_objs.append(id(o))\n            return o\n    elif (otype in [\"functions\", \"descriptors\", \"unknowns\"] or\n          (otype == \"builtins\" and (isinstance(o, types.BuiltinFunctionType) or\n                                    isinstance(o, types.BuiltinMethodType)))):\n        #The unknowns type is for objects that don't match any of the\n        #inspect.is* function calls, but still have a __call__ method (such as\n        #the numpy.ufunc class instances). These can still be wrapped by another\n        #function.\n        def xwrapper(*args, **kwargs):\n            try:\n                return o(*args, **kwargs)\n            except:\n                #see issue #4.\n                targs = list(map(type, args))\n                kargs = list(kwargs.keys())\n                msg.err(\"xwrapper: {}({}, {})\".format(o, targs, kargs), 2)\n                pass\n            \n        #Set the docstring and original object attributes.\n        for attr, val in xdict.items():\n            setattr(xwrapper, attr, val)\n            \n        #We want to get the members dictionary. For classes, using\n        #:meth:`inspect.getmembers` produces stack overflow errors. Instead, we\n        #reference the __dict__ directly. However, for built-in methods and\n        #functions, there is no __dict__, so we use `inspect.getmembers`.\n        failed = False\n        setattr(xwrapper, \"__getattribute__\", _safe_getattr(xwrapper))\n\n        #We want the new function to be identical to the old except that\n        #it's __call__ method, which we overrode above.\n        failed = not _update_attrs(xwrapper, o, [\"__call__\"])\n\n        if otype in [\"descriptors\", \"unknowns\"] and inspect.ismodule(pmodule):\n            if hasattr(o, \"__objclass__\"): # pragma: no cover\n                setattr(xwrapper, \"__module__\", pmodule.__name__)\n            elif hasattr(o, \"__class__\") and o.__class__ is not None:\n                setattr(xwrapper, \"__module__\", pmodule.__name__)\n\n        if not failed:\n            return xwrapper", "response": "Creates an extension object that can be used to represent o."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nextends the specified object with the specified name attribute.", "response": "def _extend_object(parent, n, o, otype, fqdn):\n    \"\"\"Extends the specified object if it needs to be extended. The method\n    attempts to add an attribute to the object; if it fails, a new object is\n    created that inherits all of `o` attributes, but is now a regular object\n    that can have attributes set.\n\n    Args:\n        parent: has `n` in its `__dict__` attribute.\n        n (str): object name attribute.\n        o (list): object instances to be extended.\n        otype (str): object types; one of [\"classes\", \"functions\", \"methods\",\n          \"modules\"].\n        fqdn (str): fully qualified name of the package that the object belongs\n          to.\n    \"\"\"\n    from inspect import ismodule, isclass\n    pmodule = parent if ismodule(parent) or isclass(parent) else None\n    try:\n        #The __acornext__ attribute references the original, unextended\n        #object; if the object didn't need extended, then __acornext__ is\n        #none.\n        if otype == \"methods\":\n            setattr(o.__func__, \"__acornext__\", None)\n        else:\n            setattr(o, \"__acornext__\", None)\n\n        fqdn = _fqdn(o, recheck=True, pmodule=pmodule)\n        return o\n    except (TypeError, AttributeError):\n        #We have a built-in or extension type. \n        okey = id(o)\n        if okey not in _extended_objs:\n            #We need to generate an extension for this object and store it\n            #in the extensions dict.\n            xobj = _create_extension(o, otype, fqdn, pmodule)\n            fqdn = _fqdn(xobj, recheck=True, pmodule=pmodule)\n            if xobj is not None:\n                _extended_objs[okey] = xobj\n            #else: we can't handle this kind of object; it just won't be\n            #logged...\n        try:\n            setattr(parent, n, _extended_objs[okey])\n            return _extended_objs[okey]\n        except KeyError: # pragma: no cover\n            msg.warn(\"Object extension failed: {} ({}).\".format(o, otype))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the likely members of the object by appealing to the attr_globals attribute of the object.", "response": "def _get_members(o):\n    \"\"\"Returns the likely members of the object by appealing to :func:`dir`\n    instead of using `__dict__` attribute, since that misses certain members.\n    \"\"\"\n    result = []\n    for n in dir(o):\n        if hasattr(o, n) and n not in [\"__globals__\", \"func_globals\"]:\n            result.append((n, getattr(o, n)))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsplitting the specified object into modules classes methods and functions so that it can be decorated more easily.", "response": "def _split_object(pobj, package, resplit=False, packincl=None, skipext=False):\n    \"\"\"Splits the specified object into its modules, classes, methods and\n    functions so that it can be decorated more easily. For extension\n    modules/classes that can't have attributes set, the object's dictionary is\n    modified to point to a derived-type version.\n\n    Args:\n        pobj: object instance returned from the import.\n        package (str): name of the package (used for filtering all the loaded\n          packages and methods inside the package object).\n        resplit (bool): if True, re-processes the object, even if has been done\n          before.\n        packincl (list): of package names that should be considered relevant when\n          deciding how to filter the members of this object. If a member belongs\n          to one of these packages, they will be included in the split for the\n          object.\n        skipext (bool): when True, the list of split objects is only returned;\n          no attempts are made to extend any objects for decoration.\n    \"\"\"\n    import inspect\n    result = {\n        \"classes\": [],\n        \"functions\": [],\n        \"methods\": [],\n        \"modules\": [],\n        \"builtins\": [],\n        \"descriptors\": [],\n        \"unknowns\": []\n        }\n\n    global _split_objects\n    if pobj in _split_objects and not resplit:\n        return result\n    \n    tests = {\n        \"classes\": inspect.isclass,\n        \"functions\": inspect.isfunction,\n        \"methods\": inspect.ismethod,\n        \"modules\": inspect.ismodule,\n        \"builtins\": inspect.isbuiltin,\n        \"descriptors\": inspect.ismethoddescriptor\n        }\n\n    from functools import partial\n    prepack = \"{}.\".format(package)\n    pms = []\n    pmodule = pobj if inspect.ismodule(pobj) or inspect.isclass(pobj) else None\n    for n, o in _get_members(pobj):\n        if isinstance(o, (dict, list, set, float, int, str, complex, bool)):\n            #We are looking for functions, modules and packages; sometimes\n            #constants are declared that we just ignore.\n            continue\n        else:\n            omod = _safe_getmodule(o)\n            if omod is None:\n                #This may be an instance method of an object-class. In that\n                #case, we still want to decorate it.\n                if hasattr(o,\"__objclass__\") and o.__objclass__ is not type:\n                    omod = _safe_getmodule(o.__objclass__)\n                elif hasattr(o, \"__class__\") and o.__class__ is not type:\n                    omod = _safe_getmodule(o.__class__)\n                else:\n                    omod = pmodule\n\n                #Catch the last outlier case: C-extension built-in descriptors\n                #methods for \"built-in\" objects.\n                if omod is None and inspect.ismethoddescriptor(o):\n                    omod = pmodule\n                    \n        #Some packages define special types with __class__ = type. These are\n        #indistinguishable from the built-in types like `float` or `str`. So we\n        #force the developers to configure these manually.\n        packok = False\n        confok = False\n        pincl = False        \n        if omod is not None:\n            if packincl is not None and len(packincl) > 0:\n                #We want to sometimes return all the objects available at the\n                #top-level of a package, even if they were imported from a\n                #different package. This doesn't get called in normal decoration\n                #mode, except for certain special packages.\n                fqdn_ = _fqdn(o, False, pmodule=pmodule)\n                if fqdn_ is not None:\n                    pincl = any(p in fqdn_ for p in packincl)\n\n            omodname = (omod.__name__ if inspect.ismodule(omod)\n                        else _fqdn(omod, False))\n            packok = (prepack in omodname or omodname == package or pincl)\n            if not packok and hasattr(o, \"__class__\") and o.__class__ is type:\n                fqdn_ = _fqdn(o, False, pmodule=pmodule)\n                incl = filter_name(fqdn_, package, explicit=True)\n                if incl: # pragma: no cover\n                    filesrc = inspect.getabsfile(pobj)\n                    confok = \"/{}/\".format(package) in filesrc\n                \n        if packok or confok:\n            pms.append((n, o, confok))                    \n\n    global _decor_count\n    def oappend(n, o, t, result, confok):\n        \"\"\"Appends the specified object to `results` if it can be extended.\n\n        Args:\n            confok (bool): when True, the code has already determined previously\n              that this object should be decorated no matter what (the user said\n              so). In that case, we bypass the regular name checks.\n        \"\"\"\n        fqdn = _fqdn(o, False, pmodule=pmodule)\n        if fqdn is None:\n            #The object was probably of type unknown and doesn't have a __name__\n            #attribute, so we just skip it.\n            return\n\n        package = fqdn.split('.')[0]\n        if confok or (filter_name(n, package) and filter_name(fqdn, package)):\n            xobj = _extend_object(pobj, n, o, t, fqdn)\n            if xobj is not None:\n                result[t].append((n, xobj))\n            else: # pragma: no cover\n                msg.warn(\"Couldn't extend {} ({}).\".format(o, t), 2)\n        else:\n            skipmsg = \"Skipping {}: {} because of filter rules.\"\n            msg.info(skipmsg.format(n, fqdn), 4)\n            if package in _decor_count:\n                _decor_count[package][1] += 1\n        \n    for n, o, confok in pms:\n        for t, f in tests.items():\n            if f(o):\n                if skipext:\n                    result[t].append((n, o))\n                else:\n                    oappend(n, o, t, result, confok)\n                break\n        else:\n            #With some class instances (which end up being members of\n            #objects), an error is raised because they implement their own\n            #__getattr__ routine that wasn't designed to work with acorn. We\n            #just ignore these. We don't want to decorate object instances\n            #anyway, except that numpy.ufunc instances are actually\n            #functions that don't match any of the inspect.is* methods, and\n            #so we have this catch-all over here.\n            cancall = _safe_hasattr(o, \"__call__\")\n            if cancall:\n                if skipext: # pragma: no cover\n                    result[\"unknowns\"].append((n, o))\n                else:\n                    oappend(n, o, \"unknowns\", result, confok)\n\n    _split_objects.append(pobj)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _fqdn(o, oset=True, recheck=False, pmodule=None):\n    if id(o) in _set_failures or o is None:\n        return None\n    \n    if recheck or not _safe_hasattr(o, \"__fqdn__\"):\n        import inspect\n        if not hasattr(o, \"__name__\"):\n            msg.warn(\"Skipped object {}: no __name__ attribute.\".format(o), 3)\n            return\n        \n        result = None\n        if hasattr(o, \"__acornext__\") and o.__acornext__ is not None:\n            otarget = o.__acornext__\n        else:\n            otarget = o\n            \n        omod = _safe_getmodule(otarget) or pmodule\n        if (omod is None and hasattr(otarget, \"__objclass__\") and\n            otarget.__objclass__ is not None): # pragma: no cover\n            omod = _safe_getmodule(otarget.__objclass__)\n            parts = (\"<unknown>\" if omod is None else omod.__name__,\n                     otarget.__objclass__.__name__,\n                     otarget.__name__)\n            #msg.std(\"FQDN: objclass => {}\".format(parts), 4)\n            result = \"{}.{}.{}\".format(*parts)\n        elif (omod is None and hasattr(otarget, \"__class__\") and\n              otarget.__class__ is not None):\n            omod = _safe_getmodule(otarget.__class__)\n            parts = (\"<unknown>\" if omod is None else omod.__name__,\n                     otarget.__class__.__name__,\n                     otarget.__name__)\n            #msg.std(\"FQDN: class => {}\".format(parts), 4)\n            result = \"{}.{}.{}\".format(*parts)\n        elif omod is not otarget:\n            parts = (_fqdn(omod, False), otarget.__name__)\n            #msg.std(\"FQDN: o => {}\".format(parts), 4)\n            result = \"{}.{}\".format(*parts)\n        else:\n            result = otarget.__name__\n\n        if oset:\n            _safe_setattr(o, \"__fqdn__\", result)\n        return result\n\n    if _safe_hasattr(o, \"__fqdn__\"):\n        return o.__fqdn__", "response": "Returns the fully qualified name of the object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_stack_depth(package, fqdn, defdepth=_def_stackdepth):\n    global _stack_config\n    if package not in _stack_config:\n        from acorn.config import settings\n        spack = settings(package)\n        _stack_config[package] = {}\n\n        secname = \"logging.depth\"\n        if spack.has_section(secname):\n            for ofqdn in spack.options(secname):\n                _stack_config[package][ofqdn] = spack.getint(secname, ofqdn)\n\n    usedef = True\n    if fqdn in _stack_config[package]:\n        result = _stack_config[package][fqdn]\n        usedef = False\n    elif \"*\" in _stack_config[package]: # pragma: no cover\n        result = _stack_config[package][\"*\"]\n        usedef = False\n    else:\n        result = defdepth\n\n    if not usedef:\n        msg.gen(\"Using {} for {} stack depth.\".format(result, fqdn), 3)\n    return result", "response": "Loads the stack depth settings for the specified package and returns the value of the specified fqdn."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd the decoration for automated logging to the specified object.", "response": "def decorate_obj(parent, n, o, otype, recurse=True, redecorate=False):\n    \"\"\"Adds the decoration for automated logging to the specified object, if it\n    hasn't already been done.\n\n    Args:\n        parent: object that `o` belongs to.\n        n (str): name in the parent's dictionary.\n        o (type): instance of the object's type.\n        otype (str): one of ['classes', 'functions', 'methods', 'modules'];\n          specifies which group the object belongs to.\n        recurse (bool): when True, the objects methods and functions are also\n          decorated recursively.\n\n    Examples:\n        Decorate the function `mymod.myfunc` to log automatically to the\n        database.\n\n    >>> from acorn.logging.decoration import decorate_obj\n    >>> import mymod\n    >>> decorate_obj(mymod, \"myfunc\", mymod.myfunc, \"functions\")\n\n    \"\"\"\n    global _decor_count, _decorated_o\n    from inspect import isclass, isfunction, ismodule\n    pmodule = parent if ismodule(parent) or isclass(parent) else None\n    fqdn = _fqdn(o, recheck=True, pmodule=pmodule)\n    if fqdn is None:\n        #This object didn't have a name, which means we can't extend it or\n        #track it anyway.\n        return\n\n    package = fqdn.split('.')[0]\n    d = _get_stack_depth(package, fqdn)\n    if (package in _decorated_o and\n        (id(o) not in _decorated_o[package] or redecorate)):\n        decor = None\n        if hasattr(o, \"__call__\") and otype != \"classes\":\n            #calling on class types is handled by the construction decorator\n            #below.\n            cdecor = CallingDecorator(o)\n            if isclass(parent):\n                clog = cdecor(fqdn, package, parent, d)\n            else:\n                clog = cdecor(fqdn, package, None, d)\n\n            #We can't update the attributes of the static methods (it just\n            #produces errors), so we do what we can before that.\n            msg.std(\"Setting decorator on {}.\".format(fqdn), 4)\n            _update_attrs(clog, o)\n            if ((hasattr(o, \"im_self\") and o.im_self is parent)):\n                clog = staticmethod(clog)\n            setok = _safe_setattr(parent, n, clog)\n\n            if setok:\n                decor = cdecor\n                msg.okay(\"Set calling logger on {}: {}.\".format(n, fqdn), 3)\n            _decor_count[package][0] += 1\n        else:\n            setok = _safe_setattr(o, \"__acorn__\", None)\n            _decor_count[package][2] += 1\n\n        if otype == \"classes\" and setok:\n            if hasattr(o, \"__new__\"):\n                setattr(o, \"__old__\", staticmethod(o.__new__))\n                crelog = creationlog(o, package, d)\n                setok = _safe_setattr(o, \"__new__\", creationlog(o, package, d))\n                \n                if setok:\n                    decor = crelog\n                    msg.gen(\"Set creation logger on {}: {}.\".format(n, fqdn),3)\n                _decor_count[package][0] += 1\n            #else: must have only static methods and no instances.\n            \n        if setok:\n            _decorated_o[package][id(o)] = decor\n        else:\n            _decorated_o[package][id(o)] = None\n\n        #We don't need to bother recursing for those modules/classes that\n        #can't have their attributes set, since their members will have the\n        #same restrictions.\n        if setok and otype in [\"classes\", \"modules\"]:\n            #These types can be further decorated; let's traverse their members\n            #and try to decorate those as well.\n            splits = _split_object(o, package)\n            for ot, ol in splits.items():\n                for nobj, obj in ol:\n                    decorate_obj(o, nobj, obj, ot)\n            \n    elif otype != \"classes\" and package in _decorated_o:\n        #Even though the object with that id() has been decorated, it doesn't\n        #mean that the parent has had its attribute overwritten to point to the\n        #decorated object. This happens with instance methods on different\n        #classes that are implemented by another generic method.\n        target = _decorated_o[package][id(o)]\n        child = getattr(parent, n)\n        if target is not None:\n            clog = target(fqdn, package, parent)\n            _safe_setattr(clog, \"__acorn__\", o)\n            _update_attrs(clog, o)\n            \n            setok = _safe_setattr(parent, n, clog)\n            msg.okay(\"Set existing calling logger on {}: {}.\".format(n,fqdn), 4)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _load_subclasses(package):\n    global _explicit_subclasses\n    from acorn.config import settings\n    spack = settings(package)\n    if spack is not None:\n        if spack.has_section(\"subclass\"):\n            _explicit_subclasses.update(dict(spack.items(\"subclass\")))", "response": "Loads the subclass settings for the specified package so that we can decorate the classes correctly."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload the settings for generic options that take FQDN and a boolean value.", "response": "def _load_generic(packname, package, section, target):\n    \"\"\"Loads the settings for generic options that take FQDN and a boolean value\n    (1 or 0).\n\n    Args:\n        packname (str): name of the package to get config settings for.\n        package: actual package object.\n    \"\"\"\n    from acorn.config import settings\n    spack = settings(packname)\n    if spack.has_section(section):\n        secitems = dict(spack.items(section))\n        for fqdn, active in secitems.items():\n            target[fqdn] = active == \"1\""}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the special call wrapping settings for functions in the specified package.", "response": "def _load_callwraps(packname, package):\n    \"\"\"Loads the special call wrapping settings for functions in the specified\n    package. This allows the result of the original method call to be cast as a\n    different type, or passed to a different constructor before returning from\n    the wrapped function.\n\n    Args:\n        packname (str): name of the package to get config settings for.\n        package: actual package object.\n    \"\"\"\n    global _callwraps\n    from acorn.config import settings\n    from acorn.logging.descriptors import _obj_getattr\n    spack = settings(packname)\n    if spack is not None:\n        if spack.has_section(\"callwrap\"):\n            wrappings = dict(spack.items(\"callwrap\"))\n            for fqdn, target in wrappings.items():\n                caller = _obj_getattr(package, target)\n                _callwraps[fqdn] = caller"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndecorates all the methods in the specified package to have logging enabled according to the configuration for the specified package.", "response": "def decorate(package):\n    \"\"\"Decorates all the methods in the specified package to have logging\n    enabled according to the configuration for the package.\n    \"\"\"\n    from os import sep\n    global _decor_count, _decorated_packs, _decorated_o, _pack_paths\n    global decorating\n    if \"acorn\" not in _decorated_packs:\n        _decorated_packs.append(\"acorn\")\n        packpath = \"acorn{}\".format(sep)\n        if packpath not in _pack_paths:\n            #We initialize _pack_paths to include common packages that people\n            #use without decorating. Otherwise those slow *way* down and the\n            #notebook becomes unusable.\n            _pack_paths.append(packpath)\n        \n    npack = package.__name__\n    #Since scipy includes numpy (for example), we don't want to run the numpy\n    #decoration twice if the person also chooses to import numpy. In that case,\n    #we just skip it; the memory references in scipy point to the same numpy\n    #modules and libraries.\n    if npack not in _decorated_packs:\n        _decor_count[npack] = [0, 0, 0]\n        _decorated_o[npack] = {}\n        _load_subclasses(npack)\n        \n        packsplit = _split_object(package, package.__name__)\n        origdecor = decorating\n        decorating = True\n        \n        for ot, ol in packsplit.items():\n            for name, obj in ol:\n                decorate_obj(package, name, obj, ot)\n\n        #Now that we have actually decorated all the objects, we can load the\n        #call wraps to point to the new decorated objects.\n        _load_callwraps(npack, package)\n        _load_streamlines(npack, package)\n        _load_logging(npack, package)\n        decorating = origdecor\n        _decorated_packs.append(npack)\n        _pack_paths.append(\"{}{}\".format(npack, sep))\n        msg.info(\"{}: {} (Decor/Skip/NA)\".format(npack, _decor_count[npack]))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmaking sure that any additional imported names in the specified package still exist in the decorated objects.", "response": "def postfix(package):\n    \"\"\"Makes sure that any additional imported names in the specified package\n    that were decorated in the context of a *different* package still get\n    redirected to the decorated objects.\n\n    Args:\n        package: package object to examine for compliance.\n\n    Examples:\n    When `scipy` is imported, it imports most of `numpy` automatically and then\n    has references to the original, *undecorated* `numpy` functions. We use\n    :func:`postfix` to set the `scipy` references to the decorated `numpy`\n    functions.\n\n    >>> import scipy\n    >>> import acorn.numpy\n    >>> from acorn.logging.decoration import postfix, decorate\n    >>> decorate(scipy)\n    >>> postfix(scipy)\n\n    When we call :func:`decorate` on `scipy`, the references to `numpy`\n    functions are ignored, because they don't belong to the `scipy`\n    package. This filtering is a feature to prevent `acorn` repeatedly visiting\n    commonly used modules that are imported.\n    \"\"\"\n    #This time we don't have to go recursively; we can just look at top-level\n    #objects in the package.\n    global decorating\n    origdecor = decorating\n    decorating = True\n    \n    packsplit = _split_object(package, package.__name__,\n                              resplit=True, packincl=[\"numpy\"], skipext=True)\n    for ot, ol in packsplit.items():\n        for name, obj in ol:\n            if hasattr(obj, \"__acorn__\") or hasattr(obj, \"__acornext__\"):\n                continue\n\n            #The object could have been decorated directly, *or* it could have\n            #been extended first, and then decorated.\n            key = id(obj)\n            fqdn_ = _fqdn(obj, False)\n            if fqdn_ is None: # pragma: no cover\n                continue\n\n            packname = fqdn_.split('.')[0]\n            if key not in _decorated_o[packname] and key in _extended_objs:\n                xobj = _extended_objs[key]\n                key = id(xobj)\n\n            if key in _decorated_o[packname]:\n                target = _decorated_o[packname][key]\n                if target is not None and isinstance(target, CallingDecorator):\n                    clog = target(fqdn_, packname, None)\n                    _safe_setattr(clog, \"__acornext__\", obj)\n                    _update_attrs(clog, obj)\n\n                    setattr(package, name, clog)\n                    dmsg = \"Postfix decorated {} to {}.\"\n                    msg.info(dmsg.format(name, target), 3)\n    decorating = origdecor"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading a new object from the given input protocol and returns the object.", "response": "def read(cls, iprot):\n        '''\n        Read a new object from the given input protocol and return the object.\n\n        :type iprot: thryft.protocol._input_protocol._InputProtocol\n        :rtype: pastpy.gen.database.impl.dummy.dummy_database_configuration.DummyDatabaseConfiguration\n        '''\n\n        init_kwds = {}\n\n        iprot.read_struct_begin()\n        while True:\n            ifield_name, ifield_type, _ifield_id = iprot.read_field_begin()\n            if ifield_type == 0:  # STOP\n                break\n            elif ifield_name == 'images_per_object':\n                init_kwds['images_per_object'] = iprot.read_i32()\n            elif ifield_name == 'objects':\n                init_kwds['objects'] = iprot.read_i32()\n            iprot.read_field_end()\n        iprot.read_struct_end()\n\n        return cls(**init_kwds)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write(self, oprot):\n        '''\n        Write this object to the given output protocol and return self.\n\n        :type oprot: thryft.protocol._output_protocol._OutputProtocol\n        :rtype: pastpy.gen.database.impl.dummy.dummy_database_configuration.DummyDatabaseConfiguration\n        '''\n\n        oprot.write_struct_begin('DummyDatabaseConfiguration')\n\n        oprot.write_field_begin(name='images_per_object', type=8, id=None)\n        oprot.write_i32(self.images_per_object)\n        oprot.write_field_end()\n\n        oprot.write_field_begin(name='objects', type=8, id=None)\n        oprot.write_i32(self.objects)\n        oprot.write_field_end()\n\n        oprot.write_field_stop()\n\n        oprot.write_struct_end()\n\n        return self", "response": "Writes this object to the given output protocol and returns self."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nqueries the treasury. io API and return a pandas DataFrame.", "response": "def query(sql, format='df'):\n    '''\n    Submit an `sql` query (string) to treasury.io and return a pandas DataFrame.\n\n    For example::\n\n        print('Operating cash balances for May 22, 2013')\n        print(treasuryio.query('SELECT * FROM \"t1\" WHERE \"date\" = \\'2013-05-22\\';'))\n\n    Return a dict::\n\n        treasuryio.query('SELECT * FROM \"t1\" WHERE \"date\" = \\'2013-05-22\\';', format='dict')\n\n    '''\n    url = 'http://api.treasury.io/cc7znvq/47d80ae900e04f2/sql/'\n    query_string = urlencode({'q':sql})\n    handle = urlopen(url + '?' + query_string)\n    if handle.code == 200:\n        d = load(handle)\n        if format == 'df':\n            return DataFrame(d)\n        elif format == 'dict':\n            return d\n        else:\n            raise ValueError('format must equal \"df\" or \"dict\"')\n    else:\n        raise ValueError(handle.read())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the named argument and return a new instance of the named argument.", "response": "def visit_named_arg(self, _, children):\n        \"\"\"Named argument of a filter.\n\n        Arguments\n        ---------\n        _ (node) : parsimonious.nodes.Node.\n        children : list\n            - 0: name of the arg\n            - 1: for ``WS`` (whitespace): ``None``.\n            - 2: operator\n            - 3: for ``WS`` (whitespace): ``None``.\n            - 4: value of the named arg\n\n        Returns\n        -------\n        .resources.NamedArg\n            Instance of ``.resources.NamedArg``.\n\n        Example\n        -------\n\n        >>> NamedArgsParserMixin(r'foo= 1', default_rule='NAMED_ARG').data\n        foo=1\n        >>> NamedArgsParserMixin(r'bar=\"BAZ\"', default_rule='NAMED_ARG').data\n        bar=\"BAZ\"\n        >>> NamedArgsParserMixin(r'quz=null', default_rule='NAMED_ARG').data\n        quz=None\n        >>> NamedArgsParserMixin(r'foo:TRUE', default_rule='NAMED_ARG').data\n        foo=True\n        >>> NamedArgsParserMixin(r'bar=False', default_rule='NAMED_ARG').data\n        bar=False\n\n        \"\"\"\n\n        return self.NamedArg(\n            arg=children[0],\n            arg_type=children[2],\n            value=children[4],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset up a PUSH and a PULL socket. The PUSH socket will push out requests to the workers. The PULL socket will receive responses from the workers and reply through the server socket.", "response": "def setup_zmq(self):\n        \"\"\"Set up a PUSH and a PULL socket.  The PUSH socket will push out\n        requests to the workers.  The PULL socket will receive responses from\n        the workers and reply through the server socket.\"\"\"\n        self.context = zmq.Context()\n        self.push = self.context.socket(zmq.PUSH)\n        self.push_port = self.push.bind_to_random_port(\"tcp://%s\" % self.host)\n        # start a listener for the pull socket\n        eventlet.spawn(self.zmq_pull)\n        eventlet.sleep(0)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstart the producer. This will eventually fire the ``server_start`` and ``running`` events in sequence, which signify that the incoming TCP request socket is running and the workers have been forked, respectively. If ``blocking`` is False, control .", "response": "def start(self, blocking=True):\n        \"\"\"Start the producer.  This will eventually fire the ``server_start``\n        and ``running`` events in sequence, which signify that the incoming\n        TCP request socket is running and the workers have been forked,\n        respectively.  If ``blocking`` is False, control .\"\"\"\n        self.setup_zmq()\n        if blocking:\n            self.serve()\n        else:\n            eventlet.spawn(self.serve)\n            # ensure that self.serve runs now as calling code will\n            # expect start() to have started the server even non-blk\n            eventlet.sleep(0)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_references(self, references):\n        descriptor = Descriptor(None, \"counters\", None, None, None)\n        counters = references.get_optional(descriptor)\n        for counter in counters:\n            if isinstance(counter, ICounters):\n                self._counters.append(counter)", "response": "Sets the internal references to the dependent components."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nends measurement of execution elapsed time and updates specified counter.", "response": "def end_timing(self, name, elapsed):\n        \"\"\"\n        Ends measurement of execution elapsed time and updates specified counter.\n\n        :param name: a counter name\n\n        :param elapsed: execution elapsed time in milliseconds to update the counter.\n        \"\"\"\n        for counter in self._counters:\n            if isinstance(counter, ITimingCallback):\n                counter.end_timing(name, elapsed)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates min average max statistics based on the current and previous values.", "response": "def stats(self, name, value):\n        \"\"\"\n        Calculates min/average/max statistics based on the current and previous values.\n\n        :param name: a counter name of Statistics type\n\n        :param value: a value to update statistics\n        \"\"\"\n        for counter in self._counters:\n            counter.stats(name, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef last(self, name, value):\n        for counter in self._counters:\n            counter.last(name, value)", "response": "Records the last calculated measurement value."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef timestamp(self, name, value):\n        for counter in self._counters:\n            counter.timestamp(name, value)", "response": "Records the given timestamp."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nincrements the counter by given value.", "response": "def increment(self, name, value):\n        \"\"\"\n        Increments counter by given value.\n\n        :param name: a counter name of Increment type.\n\n        :param value: a value to add to the counter.\n        \"\"\"\n        for counter in self._counters:\n            counter.increment(name, value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving trailing component from content.", "response": "def remove_trailing_string(content, trailing):\n    \"\"\"\n    Strip trailing component `trailing` from `content` if it exists.\n    Used when generating names from view classes.\n    \"\"\"\n    if content.endswith(trailing) and content != trailing:\n        return content[:-len(trailing)]\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dedent(content):\n    content = force_text(content)\n    whitespace_counts = [len(line) - len(line.lstrip(' '))\n                         for line in content.splitlines()[1:] if line.lstrip()]\n\n    # unindent the content if needed\n    if whitespace_counts:\n        whitespace_pattern = '^' + (' ' * min(whitespace_counts))\n        content = re.sub(re.compile(whitespace_pattern, re.MULTILINE), '', content)\n\n    return content.strip()", "response": "Remove leading indent from a block of text."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef camelcase_to_spaces(content):\n    camelcase_boundry = '(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))'\n    content = re.sub(camelcase_boundry, ' \\\\1', content).strip()\n    return ' '.join(content.split('_')).title()", "response": "Translate Camel Case Names to spaces."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef markup_description(description):\n    if apply_markdown:\n        description = apply_markdown(description)\n    else:\n        description = escape(description).replace('\\n', '<br />')\n        description = '<p>' + description + '</p>'\n    return mark_safe(description)", "response": "Apply HTML markup to the given description."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a timedelta object based on the value which can be a timedelta or a number of seconds", "response": "def get_delta(value):\n    \"\"\"\n    Return a timedelta object based on the value which can be a timedelta\n    or a number of seconds (int or float).\n    Raise an exception in all other cases.\n    \"\"\"\n    if isinstance(value, (int, float)):\n        return timedelta(seconds=value)\n    elif isinstance(value, timedelta):\n        return value\n    raise Exception('Invalid delta')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef compute_delayed_until(delayed_for=None, delayed_until=None):\n    if delayed_until:\n        if delayed_for:\n            raise ValueError('delayed_until and delayed_for arguments are exclusive')\n        if not isinstance(delayed_until, datetime):\n            raise ValueError('Invalid delayed_until argument: must be a datetime object')\n\n    if delayed_for:\n        try:\n            delayed_until = datetime.utcnow() + get_delta(delayed_for)\n        except Exception:\n            raise ValueError('Invalid delayed_for argument: must be an int, a float or a timedelta object')\n\n    return delayed_until", "response": "Compute the delayed_until argument."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef import_class(class_uri):\n\n    parts = class_uri.split('.')\n    class_name = parts.pop()\n    module_uri = '.'.join(parts)\n\n    try:\n        module = import_module(module_uri)\n    except ImportError as e:\n        # maybe we are still in a module, test going up one level\n        try:\n            module = import_class(module_uri)\n        except Exception:\n            # if failure raise the original exception\n            raise e\n\n    return getattr(module, class_name)", "response": "Import a class by string from. path. module. class"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_init_files(path):\n    python_files = sorted([os.path.basename(file_)[:-3] for file_ in\n                           glob.glob(os.path.join(path, '*.py'))\n                           if not file_.endswith('__init__.py')])\n\n    folders = sorted([os.path.basename(folder) for folder in os.listdir(path)\n                      if os.path.isdir(os.path.join(path, folder))])\n    with open(path + '/__init__.py', 'w') as fn:\n        if python_files:\n            [fn.write('from %s import *\\n' % file_) for file_ in python_files]\n            [fn.write('import %s\\n' % folder) for folder in folders]\n    for folder in folders:\n        create_init_files(os.path.join(path, folder))", "response": "This will create the __init__. py for a module path and every subdirectory\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef OR(*fns):\n    if len(fns) < 2:\n        raise TypeError('At least two functions must be passed')\n\n    @chainable\n    def validator(v):\n        for fn in fns:\n            last = None\n            try:\n                return fn(v)\n            except ValueError as err:\n                last = err\n        if last:\n            raise last\n    return validator", "response": "Validate with any of the chainable valdator functions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef NOT(fn):\n    @chainable\n    def validator(v):\n        try:\n            fn(v)\n        except ValueError:\n            return v\n        raise ValueError('invalid')\n    return validator", "response": "Reverse the effect of a chainable validator function"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntaking a dict form and returns a function that validates objects", "response": "def spec_validator(spec, key=operator.itemgetter):\n    \"\"\" Take a spec in dict form, and return a function that validates objects\n\n    The spec maps each object's key to a chain of validator functions.\n\n    The ``key`` argument can be used to customize the way value matching a spec\n    key from the object. By default, it uses ``operator.itemgetter``. It should\n    be assigned a function that takes a key value and returns a function that\n    returns the vale from an object that is passed to it.\n    \"\"\"\n    spec = {k: (key(k), make_chain(v)) for k, v in spec.items()}\n\n    def validator(obj):\n        errors = {}\n        for k, v in spec.items():\n            getter, chain = v\n            val = getter(obj)\n            try:\n                chain(val)\n            except ValueError as err:\n                errors[k] = err\n        return errors\n\n    return validator"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef jacobian(f, v, v_mapping):\n    # make sure f is in the form np.array([fl1, ...])\n    if isinstance(f, Fluxion):\n        f = [f]\n    f = np.asarray(f)\n    v = np.asarray(v)\n    v_mapping = _check_input_vals(v_mapping)\n\n    m = len(v)\n    n = len(f)\n    T = len(list(v_mapping.values())[0]) # number of values per variable\n    \n    J = np.zeros((m,n,T))\n    for i, f_i in enumerate(f):\n        seed = dict.fromkeys(v, 1)\n            \n        dfi_dvj = f_i.diff(v_mapping, seed)\n        J[:,i,:] = dfi_dvj.T\n\n    return J.squeeze()", "response": "Calculates the Jacobian of the function f at a given vector of variables v."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process_docopts(test=None):  # type: (Optional[Dict[str,Any]])->None\n    if test:\n        arguments = test\n    else:\n        arguments = docopt(__doc__, version=\"Jiggle Version {0}\".format(__version__))\n\n    logger.debug(arguments)\n\n    file_opener = FileOpener()\n    central_module_finder = CentralModuleFinder(file_opener)\n\n    if arguments[\"--module\"]:\n        central_module = arguments[\"--module\"]\n    elif arguments[\"--project\"]:\n        # soon to be deprecated in favor of module/package\n        central_module = arguments[\"--project\"]\n    else:\n        # infer it the best we can.\n        central_module = central_module_finder.find_central_module()\n\n    if arguments[\"--init\"]:\n        force_init = arguments[\"--init\"]\n        if force_init == \"False\":\n            force_init = False\n        if force_init == \"True\":\n            force_init = True\n    else:\n        force_init = False\n\n    if arguments[\"here\"]:\n        # TODO: find better way to turn debugging on & off\n        # console_trace(logging.DEBUG)\n        module_finder = ModuleFinder(file_opener)\n        guess_src_dir = module_finder.extract_package_dir()\n        if not guess_src_dir:\n            guess_src_dir = \"\"\n\n        if not central_module:\n            # check if exists first?\n            central_module = \"setup.py\"\n\n        bump_version(\n            project=central_module, source=guess_src_dir, force_init=force_init\n        )\n    elif arguments[\"find\"]:\n        # Only show errors. Rest of extraneous console output messes up this:\n        # jiggle_version find>version.txt\n\n        if arguments[\"--project\"]:\n            central_module = arguments[\"--project\"]\n\n        find_version(project=central_module, source=\"\", force_init=force_init)\n\n    else:\n        if arguments[\"--project\"]:\n            central_module = arguments[\"--project\"]\n        bump_version(\n            project=arguments[\"--project\"],\n            source=arguments[\"--source\"],\n            force_init=force_init,\n        )", "response": "Process the command line options and commands."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_jobs(self, argument_filters=None):\r\n\r\n        '''\r\n            a method to list jobs in the scheduler\r\n\r\n        :param argument_filters: list of query criteria dictionaries for class argument keys\r\n        :return: list of jobs (which satisfy the filters)\r\n\r\n        NOTE:   query criteria architecture\r\n\r\n                each item in the argument filters list must be a dictionary\r\n                which is composed of one or more key names which represent the\r\n                dotpath to a key in the job record to be queried with a value\r\n                that is a dictionary of conditional operators used to test the\r\n                value in the corresponding key in each record in the list of jobs.\r\n\r\n                eg. argument_filters = [ { '.function': { 'must_contain': [ 'debug' ] } } ]\r\n\r\n                this example filter looks in the function key of each job for a\r\n                value which contains the characters 'debug'.\r\n\r\n        NOTE:   the filter method uses a query filters list structure to represent\r\n                the disjunctive normal form of a logical expression. a record is\r\n                added to the results list if any query criteria dictionary in the\r\n                list evaluates to true. within each query criteria dictionary, all\r\n                declared conditional operators must evaluate to true.\r\n\r\n                in this way, the argument_filters represents a boolean OR operator and\r\n                each criteria dictionary inside the list represents a boolean AND\r\n                operator between all keys in the dictionary.\r\n\r\n        NOTE:   each query_criteria uses the architecture of query declaration in\r\n                the jsonModel.query method\r\n\r\n        the list of keys in each query_criteria is the same as the arguments for\r\n        adding a job to the scheduler\r\n        query_criteria = {\r\n            '.id': {},\r\n            '.function': {},\r\n            '.name': {},\r\n            '.dt': {},\r\n            '.interval': {},\r\n            '.month': {},\r\n            '.day': {},\r\n            '.weekday': {},\r\n            '.hour': {},\r\n            '.minute': {},\r\n            '.second': {},\r\n            '.start_date': {},\r\n            '.end_date': {}\r\n        }\r\n\r\n        conditional operators for '.id', '.function', '.name':\r\n            \"byte_data\": false,\r\n            \"discrete_values\": [ \"\" ],\r\n            \"excluded_values\": [ \"\" ],\r\n            \"greater_than\": \"\",\r\n            \"less_than\": \"\",\r\n            \"max_length\": 0,\r\n            \"max_value\": \"\",\r\n            \"min_length\": 0,\r\n            \"min_value\": \"\",\r\n            \"must_contain\": [ \"\" ],\r\n            \"must_not_contain\": [ \"\" ],\r\n            \"contains_either\": [ \"\" ]\r\n\r\n        conditional operators for '.dt', 'start', 'end':\r\n            \"discrete_values\": [ 0.0 ],\r\n            \"excluded_values\": [ 0.0 ],\r\n            \"greater_than\": 0.0,\r\n            \"less_than\": 0.0,\r\n            \"max_value\": 0.0,\r\n            \"min_value\": 0.0\r\n\r\n        operators for '.interval', '.month', '.day', '.weekday', '.hour', '.minute', '.second':\r\n            \"discrete_values\": [ 0 ],\r\n            \"excluded_values\": [ 0 ],\r\n            \"greater_than\": 0,\r\n            \"less_than\": 0,\r\n            \"max_value\": 0,\r\n            \"min_value\": 0\r\n\r\n        '''\r\n\r\n        title = '%s.list_jobs' % self.__class__.__name__\r\n\r\n    # validate inputs\r\n        if argument_filters:\r\n            self.fields.validate(argument_filters, '.argument_filters')\r\n\r\n    # send request to get jobs\r\n        url = '%s/scheduler/jobs' % self.url\r\n        job_list = self._get_request(url)\r\n\r\n    # construct filter function\r\n        def query_function(**kwargs):\r\n            job_details = {}\r\n            for key, value in kwargs.items():\r\n                if key in self.job_model.schema.keys():\r\n                    job_details[key] = value\r\n            for query_criteria in argument_filters:\r\n                if self.job_model.query(query_criteria, job_details):\r\n                    return True\r\n            return False\r\n\r\n    # construct empty list\r\n        results_list = []\r\n\r\n    # add refactored jobs to results list\r\n        for job in job_list:\r\n            job_details = self._construct_details(job)\r\n            if argument_filters:\r\n                if query_function(**job_details):\r\n                    results_list.append(job_details)\r\n            else:\r\n                results_list.append(job_details)\r\n\r\n        return results_list", "response": "A method to list jobs in the scheduler"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef auth(self, auth_type, auth_key, project_id=None):\n        if auth_type == 'session':\n            return SessionAuthClient(\n                auth_header=get_session_http_auth_header(auth_key),\n                host=self.host,\n                port=self.port,\n                secure=self.secure,\n                requests_session=self.requests_session,\n                request_defaults=self.request_defaults,\n                api_base_path=self.api_base_path,\n            )\n        elif auth_type == 'token':\n            if not project_id:\n                msg = 'You should provide project_id for token authentication'\n                raise ValueError(msg)\n            return ProjectClient(\n                base_uri=get_base_uri(\n                    project=project_id,\n                    host=self.host,\n                    port=self.port,\n                    secure=self.secure,\n                    api_base_path=self.api_base_path\n                ),\n                auth_header=get_token_http_auth_header(auth_key),\n                requests_session=self.requests_session,\n                request_defaults=self.request_defaults,\n            )", "response": "Creates authenticated client.\n\n        Parameters:\n\n        * `auth_type` - Authentication type. Use `session` for auth\n          by session key. Use `token` for auth by token.\n        * `auth_key` - Authentication `session key` or `token`.\n        * `project_id` - Project identifier. Must be provided for\n          `token` authentication. Default is `None`.\n\n        Returns:\n\n        * Instance of [SessionAuthClient](#sessionauthclient) if\n          `auth_type` is `session`.\n        * Instance of [ProjectClient](#projectclient) if\n          `auth_type` is `token`\n\n        Raises:\n\n        * ValueError: if `project_id` parameter was not provided\n\n        Examples:\n\n        For auth with `session` you should obtain session key by\n        [Client.user.login](#clientuserlogin) providing\n        your account's email and password:\n\n        ```python\n        client = Client(host='deform.io')\n        session_client = client.auth(\n            'session',\n            client.user.login(\n                email='email@example.com',\n                password='password'\n            ),\n        )\n        print session_client\n        <pydeform.client.SessionAuthClient object at 0x10c585650>\n        ```\n\n        Authentication with `token` example:\n\n        ```python\n        client = Client(host='deform.io')\n        token_client = client.auth(\n          'token',\n          auth_key='token-value',\n          project_id='some-project',\n        )\n        print token_client\n        <pydeform.client.ProjectClient object at 0x11c585650>\n        ```"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate an instance of ProjectClient with session authentication.", "response": "def use_project(self, project_id):\n        \"\"\"Creates an instance of [ProjectClient](#projectclient),\n        providing session authentication.\n\n        Parameters:\n\n        * `project_id` - project identifier.\n\n        Returns:\n\n        Instance of [ProjectClient](#projectclient) with\n        session authentication.\n\n        Example:\n\n        ```python\n        client = Client('deform.io')\n        session_client = client.auth(\n            'session',\n            client.user.login('email@example.com', 'password')\n        )\n        session_client.use_project('some-project-id')\n        ```\n\n        \"\"\"\n        return ProjectClient(\n            base_uri=get_base_uri(\n                project=project_id,\n                host=self.host,\n                port=self.port,\n                secure=self.secure,\n                api_base_path=self.api_base_path\n            ),\n            auth_header=self.auth_header,\n            requests_session=self.requests_session,\n            request_defaults=self.request_defaults,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget object docstring :rtype: str", "response": "def getdoc(obj):\n    \"\"\" Get object docstring\n\n    :rtype: str\n    \"\"\"\n    inspect_got_doc = inspect.getdoc(obj)\n    if inspect_got_doc in (object.__init__.__doc__, object.__doc__):\n        return '' # We never want this builtin stuff\n    return (inspect_got_doc or '').strip()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget callable for an object and its full name.", "response": "def _get_callable(obj, of_class = None):\n    \"\"\" Get callable for an object and its full name.\n\n    Supports:\n\n    * functions\n    * classes (jumps to __init__())\n    * methods\n    * @classmethod\n    * @property\n\n    :param obj: function|class\n    :type obj: Callable\n    :param of_class: Class that this method is a member of\n    :type of_class: class|None\n    :return: (qualname, Callable|None, Class|None). Callable is None for classes without __init__()\n    :rtype: (str, Callable|None, Class|None)\n    \"\"\"\n    # Cases\n    o = obj\n\n    if inspect.isclass(obj):\n        try:\n            o = obj.__init__\n            of_class = obj\n        except AttributeError:\n            pass\n\n    # Finish\n    return qualname(obj), o, of_class"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _doc_parse(doc, module=None, qualname=None):\n\n    # Build the rex\n    known_tags = {\n        'param': 'arg',\n        'type': 'arg-type',\n        'return': 'ret',\n        'returns': 'ret',\n        'rtype': 'ret-type',\n        'exception': 'exc',\n        'except': 'exc',\n        'raise': 'exc',\n        'raises': 'exc',\n    }\n    tag_rex = re.compile(r'^\\s*:(' + '|'.join(map(re.escape, known_tags)) + r')\\s*(\\S+)?\\s*:', re.MULTILINE)\n\n    # Match tags\n    collect_args = {}\n    collect_ret = {}\n    doc_args = []\n    doc_exc = []\n    for m in reversed(list(tag_rex.finditer(doc))):\n        # Fetch data\n        tag, arg = m.groups()\n        tag = known_tags[tag]  # Normalized tag name\n\n        # Fetch docstring part\n        value = doc[m.end():].strip()  # Copy text after the tag\n        doc = doc[:m.start()].strip()  # truncate the string\n\n        # Handle tag: collect data\n        if tag == 'exc':\n            doc_exc.append(data.ExceptionDoc(arg, value))\n        elif tag in ('ret', 'ret-type'):\n            # Collect fields 1 by 1\n            collect_ret[{'ret': 'doc', 'ret-type': 'type'}[tag]] = value\n        elif tag in ('arg', 'arg-type'):\n            # Init new collection\n            if arg not in collect_args:\n                doc_args.append(arg)  # add name for now, then map() replace with classes\n                collect_args[arg] = {}\n            # Collect fields 1 by 1\n            collect_args[arg][{'arg': 'doc', 'arg-type': 'type'}[tag]] = value\n        else:\n            raise AssertionError('Unknown tag type: {}'.format(tag))\n\n    # Merge collected data\n    doc_ret = data.ValueDoc(**collect_ret) if collect_ret else None\n    doc_args = map(lambda name: data.ArgumentDoc(name=name, **collect_args[name]), collect_args)\n\n    # Finish\n    return data.FDocstring(module=module, qualname=qualname, doc=doc, args=doc_args, exc=doc_exc, ret=doc_ret)", "response": "Parse a docstring into a dict containing all the known tags and the data that is returned by _parse_doc_string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _argspec(func):\n    assert isinstance(func, collections.Callable), 'Argument must be a callable'\n\n    try: sp =  inspect.getargspec(func) if six.PY2 else inspect.getfullargspec(func)\n    except TypeError:\n        # inspect.getargspec() fails for built-in functions\n        return []\n\n    # Collect arguments with defaults\n    ret = []\n    defaults_start = len(sp.args) - len(sp.defaults) if sp.defaults else len(sp.args)\n    for i, name in enumerate(sp.args):\n        arg = data.ArgumentSpec(name)\n        if i >= defaults_start:\n            arg['default'] = sp.defaults[i - defaults_start]\n        ret.append(arg)\n\n    # *args, **kwargs\n    if sp.varargs:\n        ret.append(data.ArgumentSpec(sp.varargs, varargs=True))\n    if six.PY2:\n        if sp.keywords:\n            ret.append(data.ArgumentSpec(sp.keywords, keywords=True))\n    else:\n        if sp.varkw:\n            ret.append(data.ArgumentSpec(sp.varkw, keywords=True))\n\n    # TODO: support Python 3: kwonlyargs, kwonlydefaults, annotations\n\n    # Finish\n    return ret", "response": "Get the full argument spec for a callable"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the full docspec for a callable.", "response": "def _docspec(func, module=None, qualname=None, of_class=None):\n    \"\"\" For a callable, get the full spec by merging doc_parse() and argspec()\n\n    :type func: Callable\n    :rtype: data.FDocstring\n    \"\"\"\n    sp = _argspec(func)\n    doc = _doc_parse(getdoc(func), module=module, qualname=qualname)\n\n    # Merge args\n    doc_map = {a.name: a for a in doc.args}\n    doc.args = [data.Argument(a, doc_map.get(a.name.lstrip('*'), None)) for a in sp]\n\n    # Args shift: dump `self`\n    if (six.PY2 and inspect.ismethod(func)) or \\\n        (six.PY3 and (inspect.isroutine(func) and of_class is not None) and (of_class is not None and not is_method_static(of_class, func.__name__))):\n            doc.args = doc.args[1:]\n\n    # Signature\n    doc.update_signature()\n\n    # Finish\n    return doc"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget parsed documentation for an object.", "response": "def doc(obj, of_class=None):\n    \"\"\" Get parsed documentation for an object as a dict.\n\n    This includes arguments spec, as well as the parsed data from the docstring.\n\n    ```python\n    from exdoc import doc\n    ```\n\n    The `doc()` function simply fetches documentation for an object, which can be\n\n    * Module\n    * Class\n    * Function or method\n    * Property\n\n    The resulting dictionary includes argument specification, as well as parsed docstring:\n\n    ```python\n    def f(a, b=1, *args):\n        ''' Simple function\n\n        : param a: First\n        : type a: int\n        : param b: Second\n        : type b: int\n        : param args: More numbers\n        : returns: nothing interesting\n        : rtype: bool\n        : raises ValueError: hopeless condition\n        '''\n\n    from exdoc import doc\n\n    doc(f)  # ->\n    {\n      'module': '__main__',\n      'name': 'f',\n      'qualname': 'f',  # qualified name: e.g. <class>.<method>\n      'signature': 'f(a, b=1, *args)',\n      'qsignature': 'f(a, b=1, *args)',  # qualified signature\n      'doc': 'Simple function',\n      'clsdoc': '',  # doc from the class (used for constructors)\n      # Exceptions\n      'exc': [\n        {'doc': 'hopeless condition', 'name': 'ValueError'}\n      ],\n      # Return value\n      'ret': {'doc': 'nothing interesting', 'type': 'bool'},\n      # Arguments\n      'args': [\n        {'doc': 'First', 'name': 'a', 'type': 'int'},\n        {'default': 1, 'doc': 'Second', 'name': 'b', 'type': 'int'},\n        {'doc': 'More numbers', 'name': '*args', 'type': None}\n      ],\n    }\n    ```\n\n    Note: in Python 3, when documenting a method of a class, pass the class to the `doc()` function as the second argument:\n\n    ```python\n    doc(cls.method, cls)\n    ```\n\n    This is necessary because in Python3 methods are not bound like they used to. Now, they are just functions.\n\n    :type obj: ModuleType|type|Callable|property\n    :param of_class: A class whose method is being documented.\n    :type of_class: class|None\n    :rtype: Docstring|FDocstring\n    \"\"\"\n    # Special care about properties\n    if isinstance(obj, property):\n        docstr = doc(obj.fget)\n        # Some hacks for properties\n        docstr.signature = docstr.qsignature= obj.fget.__name__\n        docstr.args = docstr.args[1:]\n        return docstr\n\n    # Module\n    module = inspect.getmodule(obj)\n    if module:\n        module = module.__name__\n\n    # Not callable: e.g. modules\n    if not callable(obj):\n        if hasattr(obj, '__name__'):\n            return data.Docstring(qualname=obj.__name__, doc=getdoc(obj))\n        else:\n            return None\n\n    # Callables\n    qualname, fun, of_class = _get_callable(obj, of_class)\n    docstr = _docspec(fun, module=module, qualname=qualname, of_class=of_class)\n\n    # Class? Get doc\n    if inspect.isclass(obj):\n        # Get class doc\n        clsdoc = getdoc(obj)\n        # Parse docstring and merge into constructor doc\n        if clsdoc:\n            # Parse docstring\n            clsdoc = _doc_parse(clsdoc, module=module, qualname=qualname)\n\n            # Store clsdoc always\n            docstr.clsdoc = clsdoc.doc\n\n            # Merge exceptions list\n            docstr.exc.extend(clsdoc.exc)\n\n            # If constructor does not have it's own docstr -- copy it from the clsdoc\n            if not docstr.doc:\n                docstr.doc = docstr.clsdoc\n\n            # Merge arguments: type, doc\n            for a_class in clsdoc.args:\n                for a_constructor in docstr.args:\n                    if a_class.name.lstrip('*') == a_constructor.name.lstrip('*'):\n                        a_constructor.type = a_class.type\n                        a_constructor.doc = a_class.doc\n\n    # Finish\n    return docstr"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getmembers(obj, *predicates):\n    # Add default\n    if not predicates or predicates[0] is not None:\n        predicates = (lambda key, value: not key.startswith('_'),) + predicates\n    # Build composite predicate\n    def predicate(key_value_tuple):\n        key, value = key_value_tuple\n        for p in predicates:\n            if p is not None and not p(key, value):\n                return False\n        return True\n    # Filter\n    return filter(predicate, inspect.getmembers(obj))", "response": "Get all the members of an object sorted by name."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlists all subclasses of the given class including itself.", "response": "def subclasses(cls, leaves=False):\n    \"\"\" List all subclasses of the given class, including itself.\n\n    If `leaves=True`, only returns classes which have no subclasses themselves.\n\n    :type cls: type\n    :param leaves: Only return leaf classes\n    :type leaves: bool\n    :rtype: list[type]\n    \"\"\"\n    stack = [cls]\n    subcls = []\n    while stack:\n        c = stack.pop()\n        c_subs = c.__subclasses__()\n        stack.extend(c_subs)\n        if not leaves or not c_subs:\n            subcls.append(c)\n    return subcls"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef match_pattern(self, path):\n        for pattern in self.__pattern:\n            if len(fnmatch.filter([path], pattern)) > 0:\n                return True\n        return False", "response": "Return True if given path match the pattern."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a private seed for the primary tree of a Gem wallet.", "response": "def generate(passphrase, trees=['primary']):\n    \"\"\"Generate a seed for the primary tree of a Gem wallet.\n\n    You may choose to store the passphrase for a user so the user doesn't have\n    to type it in every time. This is okay (although the security risks should\n    be obvious) but Gem strongly discourages storing even the encrypted private\n    seed, and storing both the passphrase and the private seed is completely\n    insane. Don't do it.\n\n    Args:\n      passphrase (str): The passphrase that will be used to encrypt the seed\n        before it's send to Gem. Key-stretching is done with PBDKF2 and\n        encryption is done with nacl's SecretBox.\n      trees (list of str): A list of names to generate trees for. For User\n        Wallets this will be ['primary'], for Application Wallets it will be\n       ['primary', 'backup'].\n\n    Returns:\n      A dict of dicts containing the serialized public master node, and\n       a sub-dict with the encrypted private seed for each tree in `trees`.\n    \"\"\"\n    seeds, multi_wallet = MultiWallet.generate(trees, entropy=True)\n\n    result = {}\n    for tree in trees:\n        result[tree] = dict(private_seed=seeds[tree],\n                            public_seed=multi_wallet.public_wif(tree),\n                            encrypted_seed=PassphraseBox.encrypt(passphrase,\n                                                                 seeds[tree]))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(self, name, passphrase=None, wallet_data=None):\n        if not self.application:\n            raise RoundError(\"User accounts are limited to one wallet. Make an \"\n                             \"account or shoot us an email <dev@gem.co> if you \"\n                             \"have a compelling use case for more.\")\n        if not passphrase and not wallet_data:\n            raise ValueError(\"Usage: wallets.create(name, passphrase [, \"\n                             \"wallet_data])\")\n        elif passphrase:\n            wallet_data = generate(passphrase,\n                                   trees=(['primary', 'backup'] if (\n                                       self.application) else ['primary']))\n\n        wallet = dict(\n            primary_private_seed=wallet_data['primary']['encrypted_seed'],\n            primary_public_seed=wallet_data['primary']['public_seed'],\n            name=name)\n        if self.application:\n            wallet['backup_public_seed'] = wallet_data['backup']['public_seed']\n\n        resource = self.resource.create(wallet)\n        wallet = self.wrap(resource)\n        return (wallet_data['backup']['private_seed'], self.add(wallet)) if (\n            self.application) else self.add(wallet)", "response": "Create a new Wallet object and add it to this Wallets collection."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nunlocking the Wallet by decrypting the primary_private_seed with the passphrase.", "response": "def unlock(self, passphrase, encrypted_seed=None):\n        \"\"\"Unlock the Wallet by decrypting the primary_private_seed with the\n        supplied passphrase. Once unlocked, the private seed is accessible in\n        memory and calls to `account.pay` will succeed. This is a necessary step\n        for creating transactions.\n\n        Args:\n          passphrase (str): The passphrase the User used to encrypt this wallet.\n          encrypted_seed (dict): A dictionary of the form\n            {'ciphertext': longhexvalue,\n             'iterations': integer of pbkdf2 derivations,\n             'nonce': 24-byte hex value\n             'salt': 16-byte hex value}\n            this dict represents an private seed (not a master key) encrypted\n            with the `passphrase` using pbkdf2. You can obtain this value with\n            wallet.generate. If this value is supplied, it overwrites (locally\n            only) the encrypted primary_private_seed value, allowing you to load\n            in a primary key that you didn't store with Gem. Note that the key\n            MUST match the pubkey that this wallet was created with.\n        Returns:\n          self\n        \"\"\"\n        wallet = self.resource\n        if not encrypted_seed:\n            encrypted_seed = wallet.primary_private_seed\n        try:\n            if encrypted_seed['nonce']:\n                primary_seed = NaclPassphraseBox.decrypt(\n                    passphrase, encrypted_seed)\n            else:\n                primary_seed = PassphraseBox.decrypt(\n                    passphrase, encrypted_seed)\n        except:\n            raise InvalidPassphraseError()\n\n        self.multi_wallet = MultiWallet(\n            private_seeds={'primary': primary_seed},\n            public={'cosigner': wallet.cosigner_public_seed,\n                    'backup': wallet.backup_public_seed})\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef balances_at(self, utxo_confirmations=6, network=None):\n        if not network in SUPPORTED_NETWORKS:\n            raise ValueError('Network not valid!')\n        return self.resource.available({'utxo_confirmations': utxo_confirmations,\n                                        'network': network}).__dict__['data']", "response": "Return the confirmed claimed and available balances at the given utxo_confirmations."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn this Wallet s accounts object populating it if fetch is True.", "response": "def get_accounts(self, fetch=False):\n        \"\"\"Return this Wallet's accounts object, populating it if fetch is True.\"\"\"\n        return Accounts(self.resource.accounts, self.client, wallet=self, populate=fetch)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef account(self, key=None, address=None, name=None):\n        if key:\n            return self.client.account(key, wallet=self)\n        if address:\n            q = dict(address=address)\n        elif name:\n            q = dict(name=name)\n        else:\n            raise TypeError(\"Missing param: key, address, or name is required.\")\n\n        return Account(\n            self.resource.account_query(q).get(), self.client, wallet=self)", "response": "Query for an account by key address or name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndumping all the addresses in all of the accounts in this wallet of the specified network.", "response": "def dump_addresses(self, network, filename=None):\n        \"\"\"Return a list of address dictionaries for each address in all of the\n        accounts in this wallet of the network specified by `network`\n        \"\"\"\n        addrs =  [addr.data for a in self.accounts.values() if a.network == network\n                            for addr in a.addresses]\n        if filename:\n            from json import dump\n            with open(filename, 'w') as f:\n                dump(addrs, f)\n\n        return addrs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_subscriptions(self, fetch=False):\n        return Subscriptions(\n            self.resource.subscriptions, self.client, populate=fetch)", "response": "Return this Wallet s subscriptions object populating it if fetch is True."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsign a transaction. Args: transaction (coinop.Transaction) Returns: A list of signature dicts of the form [ {'primary': 'base58signaturestring'}, ... ]", "response": "def signatures(self, transaction):\n        \"\"\"Sign a transaction.\n\n        Args:\n          transaction (coinop.Transaction)\n\n        Returns:\n          A list of signature dicts of the form\n            [ {'primary': 'base58signaturestring'},\n              ... ]\n        \"\"\"\n        # TODO: output.metadata['type']['change']\n        if not self.multi_wallet:\n            raise DecryptionError(\"This wallet must be unlocked with \"\n                                  \"wallet.unlock(passphrase)\")\n\n        return self.multi_wallet.signatures(transaction)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds an API url given a few components.", "response": "def build_api_url(self, path, query_params=None,\n                      api_base_url=None, api_version=None):\n        \"\"\"Construct an API url given a few components, some optional.\n\n        Typically, you shouldn't need to use this method.\n\n        :type path: string\n        :param path: The path to the resource.\n\n        :type query_params: dict\n        :param query_params: A dictionary of keys and values to insert into\n                             the query string of the URL.\n\n        :type api_base_url: string\n        :param api_base_url: The base URL for the API endpoint.\n                             Typically you won't have to provide this.\n\n        :type api_version: string\n        :param api_version: The version of the API to call.\n                            Typically you shouldn't provide this and instead\n                            use the default for the library.\n\n        :rtype: string\n        :returns: The URL assembled from the pieces provided.\n        \"\"\"\n        if api_base_url is None:\n            api_base_url = self.api_base_url\n        return super(Connection, self.__class__).build_api_url(path, query_params=query_params,\n                                                               api_base_url=api_base_url, api_version=api_version)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing the annotation return tuples. Ruturn a dictinary { code : info.", "response": "def parse_return_annotation(callback):\n    '''Parses the annotation return tuples. Ruturn a dictinary {code: info}.'''\n    # This has been implemented as a function as the parsing need to be\n    # accessible from a decorator used on the function's class method\n    responses = {}\n    for data in callback.__annotations__['return']:\n        tmp = dict(zip(('code', 'message', 'responseModel'), data))\n        rm = tmp.get('responseModel', None)  # \"None\" can be omitted!\n        tmp['responseModel'] = rm.name if rm else 'void'\n        responses[tmp['code']] = tmp\n    return responses"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextracts the path variables from an Resource operation. Return a dictionary of the path variables mandatory and optional.", "response": "def extract_pathvars(callback):\n    '''Extract the path variables from an Resource operation.\n\n    Return {'mandatory': [<list-of-pnames>], 'optional': [<list-of-pnames>]}\n    '''\n    mandatory = []\n    optional = []\n    # We loop on the signature because the order of the parameters is\n    # important, and signature is an OrderedDict, while annotations is a\n    # regular dictionary\n    for pname in callback.signature.parameters.keys():\n        try:\n            anno = callback.__annotations__[pname]\n        except KeyError:  # unannotated params, like \"cls\" or \"request\"\n            continue\n        if anno[0] != Ptypes.path:\n            continue\n        # At this point we are only considering path variables, but\n        # we have to generate different (present/absent) if these\n        # parameters have a default.\n        if callback.signature.parameters[pname].default == inspect._empty:\n            mandatory.append(pname)\n        else:\n            optional.append(pname)\n    return {'mandatory': mandatory, 'optional': optional}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a docstring into a semmary summary and notes.", "response": "def parse_docstring(whatever_has_docstring):\n    '''Parse a docstring into a semmary (first line) and notes (rest of it).'''\n    try:\n        summary, notes = whatever_has_docstring.__doc__.split('\\n', 1)\n        notes = dedent(notes).replace('\\n', ' ')\n    except ValueError:\n        summary = whatever_has_docstring.__doc__.strip()\n        notes = ''\n    return summary, notes"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninjecting extra arguments from header body form.", "response": "def inject_extra_args(callback, request, kwargs):\n    '''Inject extra arguments from header, body, form.'''\n    # TODO: this is a temporary pach, should be managed via honouring the\n    # mimetype in the request header....\n    annots = dict(callback.__annotations__)\n    del annots['return']\n    for param_name, (param_type, _) in annots.items():\n        if param_type == Ptypes.path:\n            continue  # Already parsed by werkzeug\n        elif param_type == Ptypes.body:\n            value = getattr(request, PTYPE_TO_REQUEST_PROPERTY[param_type])\n            # TODO: The JSON conversion should be dependant from request\n            # header type, really...\n            value = json.loads(value.decode('utf-8'))\n        else:\n            get = lambda attr: getattr(request, attr).get(param_name, None)\n            value = get(PTYPE_TO_REQUEST_PROPERTY[param_type])\n        if value is not None:\n            kwargs[param_name] = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfilter an annotation by only leaving the parameters of type ptype.", "response": "def filter_annotations_by_ptype(function, ptype):\n    '''Filter an annotation by only leaving the parameters of type \"ptype\".'''\n    ret = {}\n    for k, v in function.__annotations__.items():\n        if k == 'return':\n            continue\n        pt, _ = v\n        if pt == ptype:\n            ret[k] = v\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef option2tuple(opt):\n\n    if isinstance(opt[0], int):\n        tup = opt[1], opt[2:]\n    else:\n        tup = opt[0], opt[1:]\n\n    return tup", "response": "Return a tuple of option taking possible presence of level into account"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrestore argument checks for functions that takes options dicts as arguments Functions that take the option dictionary produced by :meth:`Options.parse` as `kwargs` loose the argument checking usually performed by the python interpretor. They also loose the ability to take default values for their keyword arguments. Such function is basically unusable without the full dictionary produced by the option parser. This is a decorator that restores argument checking and default values assignment on the basis of an :class:`Options` instance. options = Options([ (0, \"-f\", \"input\", str, 1, None, MULTI, \"Input file\"), (0, \"-o\", \"output\", str, 1, None, MA, \"Output file\"), (0, \"-p\", \"topology\", str, 1, None, 0, \"Optional topology\"), ]) @opt_func(options) def process_things(**arguments): # Do something return # The function can be called with the arguments # from the argument parser arguments = options.parse() process_things(**arguments) # It can be called with only part of the arguments, # the other arguments will be set to their default as defined by # the Options instance process_things(output='output.gro') # If the function is called with an unknown argument, the decorator # raises a TypeError process_things(unknown=None) # Likewise, if the function is called without the mandatory arguments, # the decorator raises a TypeError process_things(topology='topology.top') # The check for mandatory arguments can be deactivated @opt_func(options, check_mandatory=False) def process_things(**arguments): # Do things return Note that the decorator cannot be used on functions that accept Other arguments than the one defined in the :class:`Options` instance. Also, the arguments have to be given as keyword arguments. Positional arguments will cause the decorator to raise a `TypeError`.", "response": "def opt_func(options, check_mandatory=True):\n    \"\"\"\n    Restore argument checks for functions that takes options dicts as arguments\n\n    Functions that take the option dictionary produced by :meth:`Options.parse`\n    as `kwargs` loose the argument checking usually performed by the python\n    interpretor. They also loose the ability to take default values for\n    their keyword arguments. Such function is basically unusable without the\n    full dictionary produced by the option parser.\n\n    This is a decorator that restores argument checking and default values\n    assignment on the basis of an :class:`Options` instance.\n\n        options = Options([\n            (0, \"-f\", \"input\",    str, 1, None, MULTI, \"Input file\"),\n            (0, \"-o\", \"output\",   str, 1, None,    MA, \"Output file\"),\n            (0, \"-p\", \"topology\", str, 1, None,     0, \"Optional topology\"),\n        ])\n\n        @opt_func(options)\n        def process_things(**arguments):\n            # Do something\n            return\n\n        # The function can be called with the arguments\n        # from the argument parser\n        arguments = options.parse()\n        process_things(**arguments)\n\n        # It can be called with only part of the arguments,\n        # the other arguments will be set to their default as defined by\n        # the Options instance\n        process_things(output='output.gro')\n\n        # If the function is called with an unknown argument, the decorator\n        # raises a TypeError\n        process_things(unknown=None)\n\n        # Likewise, if the function is called without the mandatory arguments,\n        # the decorator raises a TypeError\n        process_things(topology='topology.top')\n\n        # The check for mandatory arguments can be deactivated\n        @opt_func(options, check_mandatory=False)\n        def process_things(**arguments):\n            # Do things\n            return\n\n    Note that the decorator cannot be used on functions that accept Other\n    arguments than the one defined in the :class:`Options` instance. Also, the\n    arguments have to be given as keyword arguments. Positional arguments\n    will cause the decorator to raise a `TypeError`.\n    \"\"\"\n    # A function `my_function` decorated with `opt_func` is replaced by\n    # `opt_func(options)(my_function)`. This is equivalent to\n    # `validate_arguments(my_function)` using the `options` argument provided\n    # to the decorator. A call to `my_function` results in a call to\n    # `opt_func(options)(my_function)(*args, **kwargs)`\n    # ^^^^^^^^^^^^^^^^^^ validate_arguments\n    # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ wrap\n    def validate_arguments(func):\n        @functools.wraps(func)\n        def wrap(*args, **kwargs):\n            if args:\n                raise TypeError('{0.__name__}() takes 0 positional arguments '\n                                'but {1} was given'.format(func, len(args)))\n            keys = set(kwargs.keys())\n            missing = options.mandatory_keys - keys\n            if missing and check_mandatory:\n                raise TypeError('{0.__name__}() is missing the following '\n                                'mandatory keyword arguments: {1}'\n                                .format(func, ', '.join(missing)))\n            arguments = options._default_dict()\n            unknown = keys - set(arguments.keys())\n            if unknown:\n                raise TypeError('{0.__name__}() received the following '\n                                'unexpected arguments: {1}'\n                                .format(func, ', '.join(unknown)))\n            arguments.update(**kwargs)\n            return func(**arguments)\n        return wrap\n    return validate_arguments"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _default_dict(self):\n        options = {}\n        for attr, _, _, default, multi, _ in self._optiondict.values():\n            if multi and default is None:\n                options[attr] = []\n            else:\n                options[attr] = default\n        return options", "response": "Return a dictionary with the default for each option."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef help(self, args=None, userlevel=9):\n        out = [main.__file__+\"\\n\"]\n\n        if args is not None:\n            parsed = self.parse(args, ignore_help=True)\n        else:\n            parsed = self._default_dict()\n\n        for thing in self.options:\n            if type(thing) == str:\n                out.append(\"     \"+thing)\n            elif thing[0] <= userlevel:\n                out.append(\"     %10s   %s ( %s )\" % (thing[1], thing[-1], str(parsed[thing[2]])))\n\n        return \"\\n\".join(out)+\"\\n\"", "response": "Make a string from the option list"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the command - line arguments.", "response": "def parse(self, args, ignore_help=False):\n        \"\"\"Parse the (command-line) arguments.\"\"\"\n        options = self._default_dict()\n\n        seen = set()\n\n        # Do not alter the arguments. We may need them later.\n        args = copy.copy(args)\n        while args:\n            opt = args.pop(0)\n\n            seen.add(opt)\n\n            if opt in (\"--help\",\"-h\"):\n                if ignore_help:\n                    continue\n                raise SimoptHelp\n\n            if not opt in self._optiondict:\n                raise Usage(\"Unrecognized option '%s'\"%opt)\n\n            attr, typ, num, default, flags, description = self._optiondict[opt]\n\n            if num > len(args):\n                raise Usage(\"Option '%s' requires %d arguments\"%(opt,num))\n\n            if num:\n                a = args.pop(0)\n                try:\n                    val = [typ(a) for i in range(num)]\n                except ValueError:\n                    raise Usage(\"Invalid argument to option '%s': %s\"%(opt,repr(a)))\n            else:\n                # Boolean flag\n                val = [True]\n\n            if typ == bool:\n                # A boolean option is simply set to True if given\n                options[attr] = True\n            elif flags & MULTI:\n                # A multi-option adds an item or a tuple to the list\n                options[attr] = options.get(attr, list())\n                options[attr].append(val[0] if num == 1 else tuple(val))\n            else:\n                # Other options just set item or tuple\n                options[attr] = val[0] if num == 1 else tuple(val)\n\n        # All mandatory options should be seen\n        missing = self.mandatory_arguments - seen\n        if not ignore_help and missing:\n            raise MissingMandatoryError(missing)\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gist(cls, gistid):\n        url = \"https://gist.github.com/{}.js\".format(gistid)\n        script = \"<script src=\\\"{}\\\"></script>\".format(url)\n        return script", "response": "Returns the script tag for a gist"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntransforming a list of page titles in a list of html links", "response": "def page_list(cls, pages, base_url='/'):\n        \"\"\"transform a list of page titles in a list of html links\"\"\"\n        plist = []\n        for page in pages:\n            url = \"<a href=\\\"{}{}\\\">{}</a>\".format(base_url, cls.slugify(page), page)\n            plist.append(url)\n        return plist"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the slug version of the string s", "response": "def slugify(cls, s):\n        \"\"\"Return the slug version of the string ``s``\"\"\"\n        slug = re.sub(\"[^0-9a-zA-Z-]\", \"-\", s)\n        return re.sub(\"-{2,}\", \"-\", slug).strip('-')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn True if a result of socket. getaddrinfo is in the socket address_whitelist.", "response": "def is_whitelisted(self, addrinfo):\n        \"\"\"\n        Returns if a result of ``socket.getaddrinfo`` is in the socket address\n        whitelist.\n        \"\"\"\n        # For details about the ``getaddrinfo`` struct, see the Python docs:\n        # http://docs.python.org/library/socket.html#socket.getaddrinfo\n        family, socktype, proto, canonname, sockaddr = addrinfo\n        address, port = sockaddr[:2]\n        return address in self.socket_address_whitelist"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef report(self):\n        aggregations = dict(\n            (test, Counter().rollup(values))\n            for test, values in self.socket_warnings.items()\n        )\n        total = sum(\n            len(warnings)\n            for warnings in self.socket_warnings.values()\n        )\n\n        def format_test_statistics(test, counter):\n            return \"%s:\\n%s\" % (\n                test,\n                '\\n'.join(\n                    '  - %s: %s' % (socket, count)\n                    for socket, count in counter.items()\n                )\n            )\n\n        def format_statistics(aggregations):\n            return '\\n'.join(\n                format_test_statistics(test, counter)\n                for test, counter in aggregations.items()\n            )\n\n        # Only print the report if there are actually things to report.\n        if aggregations:\n            print('=' * 70, file=self.stream)\n            print(\n                'NON-WHITELISTED SOCKETS OPENED: %s' % total,\n                file=self.stream,\n            )\n            print('-' * 70, file=self.stream)\n            print(format_statistics(aggregations), file=self.stream)", "response": "Prints the report of the socket opened."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clear(self, name):\n        self._lock.acquire()\n        try:\n            del self._cache[name]\n        finally:\n            self._lock.release()", "response": "Clears the counter specified by its name."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nclears (resets) all counters.", "response": "def clear_all(self):\n        \"\"\"\n        Clears (resets) all counters.\n        \"\"\"\n        self._lock.acquire()\n        try:\n            self._cache = {}\n            self._updated = False\n        finally:\n            self._lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndumping the current values of the counters and updates the last dump time.", "response": "def dump(self):\n        \"\"\"\n        Dumps (saves) the current values of counters.\n        \"\"\"\n        if self._updated:\n            messages = self.get_all()\n            self._save(messages)\n\n            self._lock.acquire()\n            try:\n                self._updated = False\n                current_time = time.perf_counter() * 1000\n                self._last_dump_time = current_time\n            finally:\n                self._lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting all captured counters.", "response": "def get_all(self):\n        \"\"\"\n        Gets all captured counters.\n\n        :return: a list with counters.\n        \"\"\"\n        self._lock.acquire()\n        try:\n            return list(self._cache.values())\n        finally:\n            self._lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a counter specified by its name and type.", "response": "def get(self, name, typ):\n        \"\"\"\n        Gets a counter specified by its name.\n        It counter does not exist or its type doesn't match the specified type\n        it creates a new one.\n\n        :param name: a counter name to retrieve.\n\n        :param typ: a counter type.\n\n        :return: an existing or newly created counter of the specified type.\n        \"\"\"\n        if name == None or len(name) == 0:\n            raise Exception(\"Counter name was not set\")\n\n        self._lock.acquire()\n        try:\n            counter = self._cache[name] if name in self._cache else None\n\n            if counter == None or counter.type != typ:\n                counter = Counter(name, typ)\n                self._cache[name] = counter\n\n            return counter\n        finally:\n            self._lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef end_timing(self, name, elapsed):\n        counter = self.get(name, CounterType.Interval)\n        self._calculate_stats(counter, elapsed)\n        self._update()", "response": "Ends measurement of execution elapsed time and updates specified counter."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates min average max statistics based on the current and previous values.", "response": "def stats(self, name, value):\n        \"\"\"\n        Calculates min/average/max statistics based on the current and previous values.\n\n        :param name: a counter name of Statistics type\n\n        :param value: a value to update statistics\n        \"\"\"\n        counter = self.get(name, CounterType.Statistics)\n        self._calculate_stats(counter, value)\n        self._update()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef last(self, name, value):\n        counter = self.get(name, CounterType.LastValue)\n        counter.last = value\n        self._update()", "response": "Records the last calculated measurement value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrecording the given timestamp.", "response": "def timestamp(self, name, value):\n        \"\"\"\n        Records the given timestamp.\n\n        :param name: a counter name of Timestamp type.\n\n        :param value: a timestamp to record.\n        \"\"\"\n        counter = self.get(name, CounterType.Timestamp)\n        counter.time = value if value != None else datetime.datetime.utcnow()\n        self._update()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nincrement the counter by given value.", "response": "def increment(self, name, value):\n        \"\"\"\n        Increments counter by given value.\n\n        :param name: a counter name of Increment type.\n\n        :param value: a value to add to the counter.\n        \"\"\"\n        counter = self.get(name, CounterType.Increment)\n        counter.count = counter.count + value if counter.count != None else value\n        self._update()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load(self, filename, **kwargs):\n        with open(filename, 'r') as f:\n            return self.parse(f, **kwargs)", "response": "Parse a file specified with the filename and return an array of the n - grams that are in the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a thumbnail version of the file name.", "response": "def _get_thumbnail_filename(filename, append_text=\"-thumbnail\"):\n    \"\"\"\n    Returns a thumbnail version of the file name.\n    \"\"\"\n    name, ext = os.path.splitext(filename)\n    return ''.join([name, append_text, ext])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a tuple of width height force_size.", "response": "def _get_resize_options(self, dimensions):\n        \"\"\"\n        :param dimensions:\n            A tuple of (width, height, force_size).\n            'force_size' can be left off and will default to False.\n        \"\"\"\n        if dimensions and isinstance(dimensions, (tuple, list)):\n            if len(dimensions) < 3:\n                dimensions = tuple(dimensions) + (False, )\n            return dimensions"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmake sure thumbnail gets set when image field initialized.", "response": "def contribute_to_class(self, cls, name):\n        \"\"\"\n        Makes sure thumbnail gets set when image field initialized.\n        \"\"\"\n        super(SizedImageField, self).contribute_to_class(cls, name)\n        signals.post_init.connect(self._set_thumbnail, sender=cls)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _clean_file_name(self, model_instance, filename):\n        available_name = self.storage.get_available_name(\n            self.generate_filename(model_instance, filename))\n        return os.path.basename(available_name)", "response": "This method gets the full file name from the available filename and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _create_thumbnail(self, model_instance, thumbnail, image_name):\n        thumbnail = self._do_resize(thumbnail, self.thumbnail_size)\n        full_image_name = self.generate_filename(model_instance, image_name)\n        thumbnail_filename = _get_thumbnail_filename(full_image_name)\n        thumb = self._get_simple_uploaded_file(thumbnail, thumbnail_filename)\n        self.storage.save(thumbnail_filename, thumb)", "response": "Creates the thumbnail image based on the model instance and image name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _set_thumbnail(self, instance=None, **kwargs):\n        image_field = getattr(instance, self.name)\n        if image_field:\n            thumbnail_filename = _get_thumbnail_filename(image_field.name)\n\n            thumbnail_field = ThumbnailField(thumbnail_filename, self.storage)\n            setattr(image_field, 'thumbnail', thumbnail_field)", "response": "Sets a thumbnail attribute on the image field class."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a SimpleUploadedFile instance ready to be saved.", "response": "def _get_simple_uploaded_file(self, image, file_name):\n        \"\"\"\n        :param image:\n            a python PIL ``Image`` instance.\n\n        :param file_name:\n            The file name of the image.\n\n        :returns:\n            A django ``SimpleUploadedFile`` instance ready to be saved.\n        \"\"\"\n        extension = os.path.splitext(file_name)[1]\n\n        mimetype, encoding = mimetypes.guess_type(file_name)\n        content_type = mimetype or 'image/png'\n\n        temp_handle = BytesIO()\n        image.save(temp_handle, self._get_pil_format(extension))\n        temp_handle.seek(0)  # rewind the file\n\n        suf = SimpleUploadedFile(\n            file_name,\n            temp_handle.read(),\n            content_type=content_type,\n        )\n        return suf"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create(self, **kwargs):\n        resource = self.resource.create(kwargs)\n        if 'admin_token' in kwargs:\n            resource.context.authorize('Gem-Application',\n                                       api_token=resource.api_token,\n                                       admin_token=kwargs['admin_token'])\n        app = self.wrap(resource)\n        return self.add(app)", "response": "Create a new Application object and return it."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the currently - valid MFA token for this application.", "response": "def get_mfa(self):\n        \"\"\"Return the currently-valid MFA token for this application.\"\"\"\n        token = str(self.totp.now())\n        # PyOTP doesn't pre-pad tokens shorter than 6 characters\n        # ROTP does, so we have to.\n        while len(token) < 6:\n            token = '0{}'.format(token)\n        return token"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nresetting any of the tokens for this Application.", "response": "def reset(self, *args):\n        \"\"\"Resets any of the tokens for this Application.\n        Note that you may have to reauthenticate afterwards.\n\n        Usage:\n          application.reset('api_token')\n          application.reset('api_token', 'totp_secret')\n\n        Args:\n          *args (list of str): one or more of\n            ['api_token', 'subscription_token', 'totp_secret']\n\n        Returns:\n          The Application.\n        \"\"\"\n        self.resource = self.resource.reset(list(args))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning this Applications s users object populating it if fetch is True.", "response": "def get_users(self, fetch=True):\n        \"\"\"Return this Applications's users object, populating it if fetch\n        is True.\"\"\"\n        return Users(self.resource.users, self.client, populate=fetch)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning this Applications s wallets object populating it if fetch is True.", "response": "def get_wallets(self, fetch=False):\n        \"\"\"Return this Applications's wallets object, populating it if fetch\n        is True.\"\"\"\n        return Wallets(\n            self.resource.wallets, self.client, populate=fetch, application=self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_netki_domains(self, fetch=False):\n        return NetkiDomains(\n            self.resource.netki_domains, self.client, populate=fetch)", "response": "Return the Applications NetkiDomains object populating it if fetch is True."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning hostname ipv4 and ipv6.", "response": "def network_info():\n    \"\"\"Returns hostname, ipv4 and ipv6.\n    \"\"\"\n\n    def extract(host, family):\n        return socket.getaddrinfo(host, None, family)[0][4][0]\n    host = socket.gethostname()\n    response = {\n        'hostname': host,\n        'ipv4': None,\n        'ipv6': None\n    }\n    with suppress(IndexError, socket.gaierror):\n        response['ipv4'] = extract(host, socket.AF_INET)\n    with suppress(IndexError, socket.gaierror):\n        response['ipv6'] = extract(host, socket.AF_INET6)\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the interfaces data.", "response": "def interfaces_info():\n    \"\"\"Returns interfaces data.\n    \"\"\"\n    def replace(value):\n        if value == netifaces.AF_LINK:\n            return 'link'\n        if value == netifaces.AF_INET:\n            return 'ipv4'\n        if value == netifaces.AF_INET6:\n            return 'ipv6'\n        return value\n\n    results = {}\n    for iface in netifaces.interfaces():\n        addrs = netifaces.ifaddresses(iface)\n        results[iface] = {replace(k): v for k, v in addrs.items()}\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the gateways data.", "response": "def gateways_info():\n    \"\"\"Returns gateways data.\n    \"\"\"\n    data = netifaces.gateways()\n    results = {'default': {}}\n\n    with suppress(KeyError):\n        results['ipv4'] = data[netifaces.AF_INET]\n        results['default']['ipv4'] = data['default'][netifaces.AF_INET]\n    with suppress(KeyError):\n        results['ipv6'] = data[netifaces.AF_INET6]\n        results['default']['ipv6'] = data['default'][netifaces.AF_INET6]\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef devices_data():\n    response = {}\n    for part in psutil.disk_partitions():\n        device = part.device\n        response[device] = {\n            'device': device,\n            'mountpoint': part.mountpoint,\n            'fstype': part.fstype,\n            'opts': part.opts,\n        }\n        if part.mountpoint:\n            usage = psutil.disk_usage(part.mountpoint)\n            response[device]['usage'] = {\n                'size': mark(usage.total, 'bytes'),\n                'used': mark(usage.used, 'bytes'),\n                'free': mark(usage.free, 'bytes'),\n                'percent': mark(usage.percent, 'percentage')\n            }\n    return response", "response": "Returns a dictionary of all the devices data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef integrator(integrand,xmin,xmax,n_points,factor=2):\n    '''\n    Creating theoretical curve for 2D model functions\n    integrator function\n    '''\n    integral_vector = np.empty([n_points+1])\n    dx  = (xmax-xmin)/n_points\n    # integrate\n    for i in xrange(n_points+1):\n        xnow = xmin + i * dx\n        integral, error = integrate.quad(rotate(integrand,\n                xnow), xmin*factor, xmax*factor)\n        integral_vector[i] = integral\n    # normalize\n    normalization = np.average(integral_vector)*(xmax-xmin)\n    normalized_vector = integral_vector/normalization\n    return normalized_vector", "response": "Integrator function for 2D model functions"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rotate(f,x,theta=0):\n    '''\n    Returns a function that takes as input the 1D vector along the angle\n    given a function that takes in 2D input\n    '''\n    f_R = lambda b: f(np.array([[x*np.cos(theta)-b*np.sin(theta)],\n                                [x*np.sin(theta)+b*np.cos(theta)]]))\n    return f_R", "response": "Returns a function that takes as input the 1D vector along the angletheta given a function that takes in 2D input\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninspect the current state of the current user s failed access attempts.", "response": "def inspect(self):\n        \"\"\"\n        Inspect access attempt, used for catpcha flow\n        :return:\n        \"\"\"\n        last_attempt = self.get_last_failed_access_attempt(\n            ip_address=self.ip,\n            captcha_enabled=True,\n            captcha_passed=False,\n            is_expired=False\n        )\n\n        if last_attempt is None and not self.request.user.is_authenticated():\n            # create a new entry\n            user_access = self._FailedAccessAttemptModel(\n                ip_address=self.ip,\n                username=self.username,\n                captcha_enabled=True,\n                captcha_passed=False,\n                is_expired=False\n            )\n        elif last_attempt:\n            user_access = last_attempt\n\n        if self.request.method == 'POST':\n\n            if not self.request.user.is_authenticated():\n\n                user_access.user_agent = self.request.META.get('HTTP_USER_AGENT', '<unknown user agent>')[:255]\n                user_access.username = self.username\n                user_access.failed_attempts += 1\n                user_access.params_get = self.request.GET\n                user_access.params_post = self.request.POST\n\n                if user_access.failed_attempts >= self.max_failed_attempts:\n                    user_access.is_locked = True\n                user_access.save()\n\n            elif self.request.user.is_authenticated() and last_attempt:\n                last_attempt.is_expired = True\n                last_attempt.save()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a response that can be used to send a lockout message to the client.", "response": "def get_lockout_response(self):\n        \"\"\"\n        :return:\n        \"\"\"\n\n        return render_to_response(\n            self.template_name,\n            {'user_attempts': self.last_attempt_instance,\n             'lockout_time': self.block_login_seconds,\n             'ip_address': self.ip\n             }, context_instance=RequestContext(self.request)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nyielding all optional data directories entries in the PE file.", "response": "def optional_data_directories(self):\n        \"\"\"\n            Data directories entries are somewhat wierd.\n\n            First of all they have no direct type information in it, the type\n            is assumed from the position inside the table. For this reason\n            there are often \"null\" entries, with all fields set to zero.\n\n            Here we parse all the entries, assign the correct type via position\n            and then filter out the \"null\" ones.\n\n            Even if the algorithm itself if quite simple, figuring it required\n            a huge amount of time staring at PE/COFF specification with a 8O\n            like expression thinking \"WTF? WTF! WTF? WHY?!\"\n        \"\"\"\n        base_offset = self.pe_header_offset +\\\n            COFF_Header.get_size() +\\\n            OptionalHeader_StandardFields.get_size() +\\\n            OptionalHeader_WindowsFields.get_size()\n\n        for i in range(0, self.optional_windows_fields.NumberOfRvaAndSizes):\n            offset = base_offset + i*OptionalHeader_DataDirectory.get_size()\n            header = OptionalHeader_DataDirectory(self.stream, offset, i)\n\n            if not header.is_empty():\n                yield header"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef resolve_rva(self, rva):\n        containing_section = self.get_section_of_rva(rva)\n\n        in_section_offset = containing_section.PointerToRawData -\\\n            containing_section.VirtualAddress\n\n        return in_section_offset + rva", "response": "Resolves the RVA of a specific resource in memory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dir_import_table(self):\n        import_header = list(self.optional_data_directories)[1]\n        import_offset = self.resolve_rva(import_header.VirtualAddress)\n\n        i = 0\n        while True:\n            offset = import_offset + i*Import_DirectoryTable.get_size()\n            idt = Import_DirectoryTable(self.stream, offset, self)\n\n            if idt.is_empty():\n                break\n            else:\n                yield idt\n\n            i += 1", "response": "Generator that yields all the directories in the import table."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the number of the message from the specified Chinese", "response": "def get_number(message, limit=4):\n    \"\"\"\n    convert Chinese to pinyin and extract useful numbers\n\n    attention:\n        1. only for integer\n        2. before apply this method, the message should be preprocessed\n\n    input:\n        message: the message you want to extract numbers from.\n        limit: limit the length of number sequence\n    \"\"\"\n    words = pinyin.get_pinyin(message).split('-')\n    numbers = []\n    tmp = ''\n    count = 0\n    for w in words:\n        if re.search(r'\\W', w, re.A):\n            for s in list(w):\n                if s in special_char.keys():\n                    count += 1\n                    tmp += special_char[s]\n                else:\n                    if count >= limit:\n                        numbers.append(tmp)\n                    count = 0\n                    tmp = ''\n        elif w in pinyin2number.keys():\n            count += 1\n            tmp += pinyin2number[w]\n        else:\n            if count >= limit:\n                numbers.append(tmp)\n            count = 0\n            tmp = ''\n    if count >= limit:\n        numbers.append(tmp)\n    return numbers"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nevaluating the density matching metric at a given design point.", "response": "def evalMetric(self, x, method=None):\n        '''Evaluates the density matching metric at a given design point.\n\n        :param iterable x: values of the design variables, this is passed as\n            the first argument to the function fqoi\n\n        :return: metric_value - value of the metric evaluated at the design\n            point given by x\n\n        :rtype: float\n\n        *Example Usage*::\n\n            >>> def myFunc(x, u): return x[0]*x[1] + u\n            >>> u1 = UniformParameter()\n            >>> theDM = DensityMatching(myFunc, u)\n            >>> x0 = [1, 2]\n            >>> theDM.evalMetric(x0)\n\n        '''\n        return super(DensityMatching, self).evalMetric(x, method)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfunctioning that gets vectors of the pdf and target at the last design evaluated.", "response": "def getPDF(self):\n        '''Function that gets vectors of the pdf and target at the last design\n        evaluated.\n\n        :return: tuple of q values, pdf values, target values\n        '''\n\n        if hasattr(self, '_qplot'):\n\n            return self._qplot, self._hplot, self._tplot\n\n        else:\n            raise ValueError('''The metric has not been evaluated at any\n                    design point so the PDF cannot get obtained''')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef errorBand(x, yAvg, yStd, yDensity, plt, n_colors=None):\n\n    dmn = yDensity.min()\n    dmx = yDensity.max()\n\n    if n_colors is None:\n        n_colors = dmx - dmn + 1\n    print(n_colors)\n    cm = plt.cm.get_cmap('Blues', lut=n_colors)\n\n    # normalize (0...1):\n    relDensity = (yDensity - dmn) / (dmx - dmn)\n    # limit the number of densities to n_colors:\n    bins = np.linspace(0, 1, n_colors - 1)\n    inds = np.digitize(relDensity, bins)\n\n    i0 = 0\n    try:\n        while True:\n            # define area length as those of the same alpha value\n            v0 = inds[i0]\n            am = np.argmax(inds[i0:] != v0)\n            if am == 0:\n                i1 = len(inds)\n            else:\n                i1 = i0 + am\n            r = slice(i0, i1 + 1)\n            col = cm(v0)\n            # create polygon of color=density around average:\n            plt.fill_between(x[r], yAvg[r] - yStd[r], yAvg[r] + yStd[r],\n                             alpha=1,\n                             edgecolor=col,  # '#3F7F4C',\n                             facecolor=col,  # '#7EFF99',\n                             linewidth=1)\n            i0 = i1\n    except IndexError:\n        pass\n\n    plt.plot(x, yAvg, 'k', color='#3F7F4C')\n\n    # show colorbar in plot:\n    sm = plt.cm.ScalarMappable(cmap=cm, norm=plt.Normalize(vmin=dmn, vmax=dmx))\n    # fake up the array of the scalar mappable. Urgh...\n    sm._A = []\n\n    plt.colorbar(sm)\n    plt.legend()", "response": "plot error - band around average and yStd"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndownloading a web page as a string. Return a Deferred which will callback with the response.", "response": "def getPage(url, contextFactory=None, *args, **kwargs):\n    \"\"\"Download a web page as a string.\n\n    Download a page. Return a deferred, which will callback with a\n    page (as a string) or errback with a description of the error.\n\n    See HTTPClientFactory to see what extra args can be passed.\n    \"\"\"\n    scheme, host, port, path = client._parse(url)\n    factory = client.HTTPClientFactory(url, *args, **kwargs)\n    if scheme == 'https':\n        if contextFactory is None:\n            raise RuntimeError, 'must provide a contextFactory'\n        conn = reactor.connectSSL(host, port, factory, contextFactory)\n    else:\n        conn = reactor.connectTCP(host, port, factory)\n\n    return factory"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef processResponse(cls, soapdata, **kw):\n        if len(soapdata) == 0:\n            raise TypeError('Received empty response')\n\n#        log.msg(\"_\" * 33, time.ctime(time.time()), \n#                  \"RESPONSE: \\n%s\" %soapdata, debug=True)\n\n        ps = ParsedSoap(soapdata, readerclass=cls.readerClass)\n        if ps.IsAFault() is True:\n            log.msg('Received SOAP:Fault', debug=True)\n            raise FaultFromFaultMessage(ps)\n\n        return ps", "response": "called by deferred returns pyobj representing reply."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef processResponse(self, arg, replytype, **kw):\n        if self.debug:\n            log.msg('--->PROCESS REQUEST\\n%s' %arg, debug=1)\n\n        for h in self.handlers:\n            arg.addCallback(h.processResponse, **kw)\n            \n        arg.addCallback(self.parseResponse, replytype)", "response": "Process a response from the broker."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef processRequest(self, arg, **kw):\n        if self.debug:\n            log.msg('===>PROCESS RESPONSE: %s' %str(arg), debug=1)\n\n        if arg is None:\n            return\n\n        for h in self.handlers:\n            arg = h.processRequest(arg, **kw)\n            \n        s = str(arg)\n        if self.debug:\n            log.msg(s, debug=1)\n\n        return s", "response": "Process a response from the server."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef Send(self, url, opname, pyobj, nsdict={}, soapaction=None, chain=None, \n             **kw):\n        \"\"\"Returns a ProcessingChain which needs to be passed to Receive if \n        Send is being called consecutively.\n        \"\"\"\n        url = url or self.url\n        cookies = None\n        if chain is not None:\n            cookies = chain.flow.cookies\n        \n        d = {}\n        d.update(self.nsdict)\n        d.update(nsdict)\n         \n        if soapaction is not None:\n            self.addHTTPHeader('SOAPAction', soapaction)\n        \n        chain = self.factory.newInstance()\n        soapdata = chain.processRequest(pyobj, nsdict=nsdict, \n                                        soapaction=soapaction, **kw)\n            \n        if self.trace:\n            print >>self.trace, \"_\" * 33, time.ctime(time.time()), \"REQUEST:\"\n            print >>self.trace, soapdata\n\n        f = getPage(str(url), contextFactory=self.contextFactory, \n                    postdata=soapdata, agent=self.agent, \n                    method='POST', headers=self.getHTTPHeaders(), \n                    cookies=cookies)\n        \n        if isinstance(f, Failure):\n            return f\n        \n        chain.flow = f\n        self.chain = chain\n        return chain", "response": "Sends a single object to the specified URL."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef Receive(self, replytype, chain=None, **kw):\n        chain = chain or self.chain\n        d = chain.flow.deferred\n        if self.trace:\n            def trace(soapdata):\n                print >>self.trace, \"_\" * 33, time.ctime(time.time()), \"RESPONSE:\"\n                print >>self.trace, soapdata\n                return soapdata\n            \n            d.addCallback(trace)\n            \n        chain.processResponse(d, replytype, **kw)\n        if self.defer:\n            return d\n\n        failure = []\n        append = failure.append\n        def errback(result):\n            \"\"\"Used with Response method to suppress 'Unhandled error in \n            Deferred' messages by adding an errback.\n            \"\"\"\n            append(result)\n            return None\n        \n        d.addErrback(errback)\n\n        # spin reactor\n        while not d.called:\n            reactor.runUntilCurrent()\n            t2 = reactor.timeout()\n            t = reactor.running and t2\n            reactor.doIteration(t)\n\n        pyobj = d.result\n        if len(failure):\n            failure[0].raiseException()\n        \n        return pyobj", "response": "This method is used to send a message to a specific queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create(self, name, network):\n        if not network in SUPPORTED_NETWORKS:\n            raise ValueError('Network not valid!')\n        account = self.wrap(self.resource.create(dict(name=name,\n                                                      network=network)))\n        self.add(account)\n        return account", "response": "Create a new Account object and add it to this Accounts collection."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, **kwargs):\n        return self.__class__(self.resource.update(kwargs),\n                              self.client,\n                              wallet=self.wallet)", "response": "Update the Account resource with specified content."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pay(self, payees, change_account=None, utxo_confirmations=6,\n            mfa_token=None, redirect_uri=None):\n        \"\"\"Create, verify, and sign a new Transaction.\n\n        If this Account is owned by a User object, the user must be redirected to\n        a URL (`mfa_uri`) returned by this call to input their MFA token. After\n        they complete that step, the Transaction will be approved and published\n        to the bitcoin network. If a `redirect_uri` is provided in this call, the\n        user will be redirected to that uri after they complete the MFA challenge\n        so it's a good idea to have an endpoint in your app (or custom scheme on\n        mobile) that can provide the user a seamless flow for returning to your\n        application. If they have not configured a TOTP MFA application (e.g.\n        Google Authenticator), then an SMS will be sent to their phone number\n        with their token.\n\n        If this Account is owned by an Application, the `mfa_token` can be\n        included in this call and the Transaction will be automatically approved\n        and published to the blockchain.\n\n        Args:\n          payees (list of dict): list of outputs in the form:\n            [{'amount': 10000(satoshis),\n              'address':'validbtcaddress'}, ...]\n          change_account (str or Account): if supplied, this account will\n            be used to generate a change address in the event that a change\n            output is required. This account must be owned by the same Wallet.\n          utxo_confirmations (int, optional): Required confirmations for UTXO\n            selection ( > 0)\n          mfa_token (str/function, optional): TOTP token for the Application\n            owning this Account's wallet OR a callable/function which will\n            generate such a token. The latter is suggested\n            (e.g. application.get_mfa) as otherwise, the token might be\n            invalidated by the time tx.create and tx.update complete (before\n            the tx.approve call which actually requires the mfa_token).\n          redirect_uri (str, optional): URI to redirect a user to after they\n            input an mfa token on the page referenced by the `mfa_uri` returned\n            by this function.\n\n        Returns: An \"unapproved\" Transaction with an `mfa_uri` attribute to route\n          the user to the MFA confirmation page --  if called with Gem-Device\n          authentication.\n          An \"unconfirmed\" Transaction -- if called with Gem-Application auth\n          (and an `mfa_token` was supplied).\n        \"\"\"\n        # Check that wallet is unlocked\n        if self.wallet.is_locked():\n            raise DecryptionError(\"This wallet must be unlocked with \"\n                                  \"wallet.unlock(passphrase)\")\n\n        # First create the unsigned tx.\n        content = dict(payees=payees,\n                       utxo_confirmations=utxo_confirmations,\n                       remainder_account=self.resource.attributes['key'],\n                       network=self.network)\n\n        if change_account: content['change_account'] = \\\n           self.wallet._get_account_attr(change_account)\n\n        try:\n            unsigned = self.resource.transactions().create(content)\n        except ResponseError as e:\n            if \"cannot cover\" in e.message:\n                raise BalanceError(e.message)\n            raise e\n\n        # Sign the tx with the primary private key.\n        coinoptx = CoinopTx(data=unsigned.attributes)\n        signatures = self.wallet.signatures(coinoptx)\n\n        # Update the tx with the signatures.\n        transaction = dict(signatures=dict(inputs=signatures,\n                                           transaction_hash=coinoptx.hash))\n        if redirect_uri:\n            transaction['redirect_uri'] = redirect_uri\n\n        signed = Transaction(unsigned.update(transaction), self.client)\n\n        # If this is an Application wallet, approve the transaction.\n        if mfa_token and self.wallet.application:\n            try:\n                return Transaction(signed.with_mfa(mfa_token).approve(),\n                                   self.client)\n            except Exception as e:\n                signed = signed.cancel()\n                logger.debug(e.message)\n                logger.debug(\"If you are having trouble with MFA tokens, make \"\n                             \"sure your system time is accurate with `date -u`!\")\n\n        # Otherwise return the unapproved tx (now redirect the user to the\n        # `mfa_uri` attribute to approve!)\n        return signed", "response": "Create verify and sign a new Transaction."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches and return Transactions involving any Address inside this Account.", "response": "def transactions(self, **query):\n        \"\"\"Fetch and return Transactions involving any Address inside this\n        Account.\n        Note that this call is not cached. If you want to store a copy, you\n        must assign it to a local variable, and call .refresh() when you need\n        updated data\n\n        Args:\n          status (str or list, optional): One or a list of\n            [\"unsigned\", \"unapproved\",\n             \"confirmed\", \"unconfirmed\",\n             \"canceled\", \"denied\"]\n          type (str, optional): One of [\"incoming\", \"outgoing\"]\n\n        Returns:\n          A collection of matching Transactions\n        \"\"\"\n        if 'status' in query and isinstance(query['status'], list):\n            query['status'] = ','.join(map(str, query['status']))\n\n        transaction_resource = self.resource.transactions(query)\n        return Transactions(transaction_resource, self.client, populate=True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_addresses(self, fetch=False):\n        return Addresses(self.resource.addresses, self.client, populate=fetch)", "response": "Return the Account s addresses object populating it if fetch is True."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_netki_names(self, fetch=False):\n        return NetkiNames(self.resource.netki_names, self.client, populate=fetch)", "response": "Return the Account s NetkiNames object populating it if fetch is True."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef truncate_html(html, *args, **kwargs):\n    if hasattr(html, 'getchildren'):\n        etree = html\n    else:\n        etree = html5lib.parse(html)\n\n    walker = html5lib.getTreeWalker('etree')\n\n    stream = walker(etree)\n    stream = TruncationFilter(stream, *args, **kwargs)\n\n    serializer = html5lib.serializer.HTMLSerializer()\n    serialized = serializer.serialize(stream)\n\n    return u''.join(serialized).strip()", "response": "Truncates HTML string.\n\n    :param html: The HTML string or parsed element tree (with\n                 :func:`html5lib.parse`).\n    :param kwargs: Similar with :class:`.filters.TruncationFilter`.\n\n    :return: The truncated HTML string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntaking an iterable of tuples of item and weight and cycles around them returning heavier ( integer ) weighted items more frequently.", "response": "def weighted_round_robin(iterable):\n    '''Takes an iterable of tuples of <item>, <weight> and cycles around them,\n    returning heavier (integer) weighted items more frequently.\n    '''\n    cyclable_list = []\n    assigned_weight = 0\n    still_to_process = [\n        (item, weight) for item, weight in\n        sorted(iterable, key=lambda tup: tup[1], reverse=True)]\n    while still_to_process:\n        for i, (item, weight) in enumerate(still_to_process):\n            if weight > assigned_weight:\n                cyclable_list.append(item)\n            else:\n                del still_to_process[i]\n        assigned_weight += 1\n    return cycle(cyclable_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_allowed(func):\n    @wraps(func)\n    def _is_allowed(user, *args, **kwargs):\n        password = kwargs.pop('password', None)\n        if user.check_password(password):\n            return func(user, *args, **kwargs)\n        else:\n            raise NotAllowedError()\n\n    # add password parameter to function signature\n    sig = inspect.signature(func)\n    parms = list(sig.parameters.values())\n    parms.append(inspect.Parameter('password',\n                                   inspect.Parameter.KEYWORD_ONLY,\n                                   default=None))\n    _is_allowed.__signature__ = sig.replace(parameters=parms)\n\n    return _is_allowed", "response": "Decorator to check user password when is correct then run decorated function."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting labels directly connected to a content item.", "response": "def do_get(self, args):\n        '''Get labels directly connected to a content item.'''\n        for label in self.label_store.directly_connected(args.content_id):\n            if args.value is None or label.value.value == args.value:\n                self.stdout.write('{0}\\n'.format(label))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_connected(self, args):\n        '''Find a connected component from positive labels on an item.'''\n        connected = self.label_store.connected_component(args.content_id)\n        for label in connected:\n            self.stdout.write('{0}\\n'.format(label))", "response": "Find a connected component from positive labels on an item."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwait for all submitted jobs to complete.", "response": "def wait(self):\n        \"\"\"Waits for all submitted jobs to complete.\"\"\"\n        logging.info(\"waiting for {} jobs to complete\".format(len(self.submissions)))\n        while not self.shutdown:\n            time.sleep(1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef download_dropped_files(self, sha256, environment_id, target_dir):\n\n        download_url = '{}/api/sample-dropped-files/{}?environmentId={}&apikey={}&secret={}'.format(\n            self.url,\n            sha256,\n            environment_id,\n            self.api_key,\n            self.secret)\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            logging.info(\"downloading dropped files from {}\".format(download_url))\n            result = requests.get(download_url, verify=False, headers=VXSTREAM_HEADERS, proxies=self.proxies) # XXX\n\n        if result.status_code != 200:\n            logging.error(\"got result {} from vxstream for {}: {}\".format(result.status_code, download_url, result.reason))\n            return None\n\n        # put what we download into a temporary directory\n        temp_dir = tempfile.mkdtemp()\n        try:\n            # all dropped files come in a zip file\n            compressed_path = os.path.join(temp_dir, 'download.zip')\n\n            # write zip file to disk\n            with open(compressed_path, 'wb') as fp:\n                for block in result.iter_content(io.DEFAULT_BUFFER_SIZE):\n                    fp.write(block)\n\n            # unzip without paths\n            p = Popen(['7z', 'e', '-y', '-o{}'.format(target_dir), compressed_path], stdout=PIPE, stderr=PIPE)\n            stdout, stderr = p.communicate()\n\n            try:\n                os.remove(compressed_path)\n            except Exception as e:\n                logging.error(\"unable to delete {}: {}\".format(compressed_path, e))\n\n            # list gz files in drop_path\n            file_list = [os.path.join(target_dir, f) for f in os.listdir(target_dir) if f.endswith('.gz')]\n\n            result = []\n            for compressed_path in file_list:\n                # there are some other files in here sometimes that we'll ignore\n                # we just want the dropped file\n                if '.DROPPED.' not in compressed_path:\n                    continue\n\n                DROPPED_FILE_REGEX = re.compile(r'^(.+?)\\.[0-9]+\\.DROPPED\\.gz')\n\n                # the file paths look like this\n                # dropped/78QC7UOHAWCI47906LWH.temp.4212842214.DROPPED.gZ\n                m = DROPPED_FILE_REGEX.match(os.path.basename(compressed_path))\n                if not m:\n                    logging.error(\"could not extract file name from {}\".format(compressed_path))\n                    continue\n\n                target_path = os.path.join(target_dir, m.group(1))\n                result.append(target_path)\n\n                with gzip.open(compressed_path) as fp:\n                    logging.debug(\"decompressing {}\".format(compressed_path))\n                    with open(target_path, 'wb') as dest_fp:\n                        while True:\n                            data = fp.read(io.DEFAULT_BUFFER_SIZE)\n                            if data == b'':\n                                break\n\n                            dest_fp.write(data)\n\n                os.remove(compressed_path)\n\n            return result\n\n        finally:\n\n            try:\n                if temp_dir:\n                    shutil.rmtree(temp_dir)\n            except Exception as e:\n                logging.error(\"unable to delete temporary directory {}: {}\".format(temp_dir, e))", "response": "Downloads the dropped files for this sample into target_dir. Returns the list of files extracted."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndownload the given memory dump into the given directory. Returns a tuple of a list of files extracted from what was downloaded and the path to the combined memory dump.", "response": "def download_memory_dump(self, sha256, environment_id, dest_dir):\n        \"\"\"Downloads the given memory dump into the given directory.  Returns a tuple of a list of files extracted from what was downloaded, and the path to the combined memory dump.\"\"\"\n\n        dest_path = os.path.join(dest_dir, 'memory.zip')\n        if self.download(sha256, environment_id, VXSTREAM_DOWNLOAD_MEMORY, dest_path) is None:\n            return None\n\n        with open(dest_path, 'rb') as fp:\n            blob = fp.read(1024)\n            if b'No dump files available' in blob:\n                logging.debug(\"memory dump not available for {} env {}\".format(sha256, environment_id))\n                return None\n\n        logging.debug(\"extracting memory dump {} into {}\".format(dest_path, dest_dir))\n        p = Popen(['7z', 'x', '-y', '-o{}'.format(dest_dir), dest_path], stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n\n        file_list = []\n        for file_path in [os.path.join(dest_dir, f) for f in os.listdir(dest_dir) if f != \"memory.zip\"]:\n            file_list.append(file_path)\n\n        # concatenate all these files into one file\n        dest_path = os.path.join(dest_dir, 'memory.combined.mdmp')\n        for file_path in file_list:\n            logging.debug(\"concatenating {}\".format(file_path))\n            with open(file_path, 'rb') as input_fp:\n                with open(dest_path, 'ab') as output_fp:\n                    while True:\n                        data = input_fp.read(io.DEFAULT_BUFFER_SIZE)\n                        if data == b'':\n                            break\n\n                        output_fp.write(data)\n\n        return file_list, dest_path"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef messages(self):\n        '''A generator yielding the :class:`MacIndexMessage`\n        structures in this index file.'''\n\n        # The file contains the fixed-size file header followed by\n        # fixed-size message structures, followed by minimal message\n        # information (subject, from, to).  Start after the file\n        # header and then simply return the message structures in\n        # sequence until we have returned the number of messages in\n        # this folder, ignoring the minimal message information at the\n        # end of the file.\n\n        offset = self.header_length # initial offset\n        # how much of the data in this file we expect to use, based on\n        # the number of messages in this folder and the index message block size\n        maxlen = self.header_length + self.total_messages * MacIndexMessage.LENGTH\n        while offset < maxlen:\n             yield MacIndexMessage(mm=self.mmap, offset=offset)\n             offset += MacIndexMessage.LENGTH", "response": "A generator yielding the message structures in this index file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_message(self, offset, size):\n        '''Get an individual :class:`MacMailMessage` within a Mail\n        data file, based on size and offset information from the\n        corresponding :class:`MacIndexMessage`.\n\n        :param offset: offset within the Mail file where the desired\n            message begins, i.e. :attr:`MacMailMessage.offset`\n        :param size: size of the message,\n            i.e. :attr:`MacMailMessage.size`\n        '''\n        return MacMailMessage(size=size, mm=self.mmap, offset=offset)", "response": "Get an individual : class : MacMailMessage within a Mail\n            data file based on size and offset information from the\n            corresponding : class : MacIndexMessage."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef data(self):\n        '''email content for this message'''\n        # return data after any initial offset, plus content offset to\n        # skip header, up to the size of this message\n        return self.mmap[self.content_offset + self._offset: self._offset + self.size]", "response": "return the data for this message"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncopy the Overlay possibly overriding props.", "response": "def copy(self, props=None, value=None):\n        \"\"\"\n        Copy the Overlay possibly overriding props.\n        \"\"\"\n\n        return Overlay(self.text,\n                       (self.start, self.end),\n                       props=props or self.props,\n                       value=value or self.value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn True if all the provided predicates match or dont.", "response": "def match(self, props=None, rng=None, offset=None):\n        \"\"\"\n        Provide any of the args and match or dont.\n\n        :param props: Should be a subset of my props.\n        :param rng: Exactly match my range.\n        :param offset: I start after this offset.\n        :returns: True if all the provided predicates match or are None\n        \"\"\"\n\n        if rng:\n            s, e = rng\n        else:\n            e = s = None\n\n        return ((e is None or self.end == e) and\n                (s is None or self.start == s)) and \\\n            (props is None or props.issubset(self.props)) and \\\n            (offset is None or self.start >= offset)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef overlays_at(self, key):\n\n        if isinstance(key, slice):\n            s, e, _ = key.indices(len(self.text))\n        else:\n            s = e = key\n\n        return [o for o in self.overlays if o.start in Rng(s, e)]", "response": "Return a list of overlays at the given key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a list of matchers create overlays based on them.", "response": "def overlay(self, matchers, force=False):\n        \"\"\"\n        Given a list of matchers create overlays based on them. Normally I\n        will remember what overlays were run this way and will avoid\n        re-running them but you can `force` me to. This is the\n        recommended way of running overlays.c\n        \"\"\"\n\n        for m in matchers:\n            if m in self._ran_matchers:\n                continue\n\n            self._ran_matchers.append(m)\n            self.overlays += list(m.offset_overlays(self))\n\n        self.overlays.sort(key=lambda o: o.start, reverse=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_overlays(self, **kw):\n\n        return [o for o in self.overlays if o.match(**kw)]", "response": "Returns a list of all overlays that match the given keyword arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef published(self, **kwargs):\n\t\t''' Returns pages that are both status: Active and have a \n\t\t\tnon-conflicting activate_date / deactivate_date \n\t\t'''\n\t\treturn self.filter(\n\t\t\tQ(activate_date__lte=timezone.now()) | Q(\n\t\t\t\tactivate_date__isnull=True),\n\t\t\tQ(deactivate_date__gte=timezone.now()) | Q(\n\t\t\t\tdeactivate_date__isnull=True),\n\t\t\tQ(status=1), **kwargs)", "response": "Returns a QuerySet of Pages that are both active and have a \n\t\t\tactivate_date / deactivate_date assignments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nevaluating an expression according to the eval description given.", "response": "def evil(expr, lookup, operators, cast, reducer, tokenizer):\n    \"\"\"evil evaluates an expression according to the eval description given.\n\n    :param expr: An expression to evaluate.\n    :param lookup: A callable which takes a single pattern argument and returns\n                   a set of results. The pattern can be anything that is not an\n                   operator token or round brackets.\n    :param operators: A precedence-ordered dictionary of (function, side)\n                      tuples keyed on the operator token.\n    :param reducer: A callable which takes a sequential list of values (from\n                    operations or lookups) and combines them into a result.\n                    Typical behaviour is that of the + operator. The return\n                    type should be the same as cast.\n    :param cast: A callable which transforms the results of the lookup into\n                 the type expected by the operators and the type of the result.\n    :param tokenizer: A callable which will break the query into tokens for\n                      evaluation per the lookup and operators. Defaults to\n                      setquery.query_tokenizer.\n    :raises: SyntaxError\n    :returns:\n\n    \"\"\"\n    operators = OrderedDict((op[0], op[1:]) for op in operators)\n    if \"(\" in operators or \")\" in operators:\n        raise ValueError(\"( and ) are reserved operators\")\n\n    operator_tokens = [\"(\", \")\"] + operators.keys()\n    tokens = iter(tokenizer(expr, operator_tokens))\n    levels = [[]]\n\n    while True:\n        # Token evaluation and pattern lookups\n\n        expr = levels.pop()           # The currently-constructed expression\n        new_level = False             # We should step into a subexpression\n        first_token = len(expr) == 0  # The first (sub)exp. token\n\n        prev_op_side = None           # The side of the last-seen operator\n        try:\n            # Try to get the side of the last operator from an expression\n            # which we are going to continue constructing.\n            prev_op_side = operators[expr[-1]][1]\n        except:\n            pass\n\n        for token in tokens:\n\n            if token == \"(\":\n                new_level = True\n                break\n            elif token == \")\":\n                break\n            elif token in operators:\n                op_side = operators[token][1]\n                if first_token and op_side & OP_LEFT:\n                    raise SyntaxError(\"Operators which act on expressions to \"\n                                      \"their left or both sides cannot be at \"\n                                      \"the beginning of an expression.\")\n                if prev_op_side is not None:\n                    if prev_op_side & OP_RIGHT and op_side & OP_LEFT:\n                        raise SyntaxError(\"Operators cannot be beside one \"\n                                          \"another if they act on expressions \"\n                                          \"facing one-another.\")\n                expr.append(token)\n                prev_op_side = op_side\n                continue\n            else:\n                expr.append(cast(lookup(token)))\n                prev_op_side = None\n\n            first_token = False\n\n        if new_level:\n            levels.append(expr)\n            levels.append([])\n            continue\n        elif prev_op_side is not None and prev_op_side & OP_RIGHT:\n            raise SyntaxError(\"Operators which act on expressions to their \"\n                              \"right or both sides cannot be at the end of \"\n                              \"an expression.\")\n\n        # Operator evaluation\n\n        explen = len(expr)\n        for op, (op_eval, op_side) in operators.iteritems():\n            if op_side is OP_RIGHT:\n\n                # Apply right-sided operators. We loop from the end backward so\n                # that multiple such operators next to noe another are resolved\n                # in the correct order\n                t = explen - 1\n                while t >= 0:\n                    if expr[t] == op:\n                        expr[t] = op_eval(expr[t + 1])\n                        del expr[t + 1]\n                        explen -= 1\n                    t -= 1\n\n            else:\n\n                # Apply left- and both-sided operators. We loop forward so that\n                # that multiple such operators next to one another are resolved\n                # in the correct order.\n                t = 0\n                while t < explen:\n                    if expr[t] == op:\n                        # Apply left- or both-sided operators\n                        if op_side is OP_LEFT:\n                            expr[t] = op_eval(expr[t - 1])\n                            del expr[t - 1]\n                            t -= 1\n                            explen -= 1\n                        elif op_side is OP_BOTH:\n                            expr[t] = op_eval(expr[t - 1], expr[t + 1])\n                            del expr[t + 1], expr[t - 1]\n                            t -= 1\n                            explen -= 2\n                    t += 1\n\n        if len(levels) > 0:\n            levels[-1].append(reducer(expr))\n        else:\n            break\n\n    return reducer(expr)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef op(token, func, left=False, right=False):\n    both = (left == right)\n    return (token, func, OP_BOTH if both else OP_LEFT if left else OP_RIGHT)", "response": "provides a more verbose syntax for declaring operators."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a generator that yields all the filesystem objects whose relative path matches the given pattern.", "response": "def globlookup(pattern, root):\n    \"\"\"globlookup finds filesystem objects whose relative path matches the\n    given pattern.\n\n    :param pattern: The pattern to wish to match relative filepaths to.\n    :param root: The root director to search within.\n\n    \"\"\"\n    for subdir, dirnames, filenames in os.walk(root):\n        d = subdir[len(root) + 1:]\n        files = (os.path.join(d, f) for f in filenames)\n        for f in fnmatch.filter(files, pattern):\n            yield f"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef on_get(self, req, resp, rid, related):\n\n        signals.pre_req.send(self.model)\n        signals.pre_req_find.send(self.model)\n\n        if not hasattr(self.model, related):\n            abort(InvalidURL(**{\n                'detail': 'The \"%s\" resource does not have a related '\n                          'resource named \"%s\". This is an error, check '\n                          'your spelling & retry.' % (self.rtype, related)\n            }))\n\n        model = find(self.model, rid)\n        try:\n            model_related = getattr(model, related).load()\n        except AttributeError:\n            model_related = None\n\n        if isinstance(model_related, list):\n            props = to_rest_models(model_related, includes=req.includes)\n        elif model:\n            props = to_rest_model(model_related, includes=req.includes)\n        else:\n            props = model_related\n\n        resp.serialize(props)\n\n        signals.post_req.send(self.model)\n        signals.post_req_find.send(self.model)", "response": "Find the related model & serialize it back"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads the next frame and put it on the matrix.", "response": "def recv_data(self):\n        \"\"\"\n        Grab the next frame and put it on the matrix.\n        \"\"\"\n        data, addr = self.sock.recvfrom(self.packetsize)\n        matrix = map(ord, data.strip())\n        if len(matrix) == self.packetsize:\n            self.matrix = matrix[:-4]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self):\n        pixels = len(self.matrix)\n        for x in range(self.width):\n            for y in range(self.height):\n                pixel = y * self.width * 3 + x * 3\n                #TODO: sometimes the matrix is not as big as it should\n                if pixel < pixels:\n                    pygame.draw.circle(self.screen,\n                                       (self.matrix[pixel], self.matrix[pixel + 1], self.matrix[pixel + 2]),\n                                       (x * self.dotsize + self.dotsize / 2, y * self.dotsize + self.dotsize / 2), self.dotsize / 2, 0)", "response": "Generate the output from the matrix."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gameloop(self):\n        try:\n            while True:\n                for event in pygame.event.get():\n                    if event.type == pygame.QUIT:\n                        sys.exit()\n                    if event.type == pygame.KEYDOWN:\n                        if event.key == pygame.K_ESCAPE:\n                            pygame.event.post(pygame.event.Event(pygame.QUIT))\n\n                self.recv_data()\n                self.update()\n                self.render()\n        except KeyboardInterrupt:\n            pass", "response": "Loop through all the necessary stuff and end execution when Ctrl + C was hit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getname(obj):\n    for name_attribute in ('__qualname__', '__name__'):\n        try:\n            # an object always has a class, as per Python data model\n            return getattr(obj, name_attribute, getattr(obj.__class__, name_attribute))\n        except AttributeError:\n            pass\n    raise TypeError('object of type %r does not define a canonical name' % type(obj))", "response": "Returns the most qualified name of an object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wraplet(cls, *cls_args, **cls_kwargs):\n        if cls.__init_slave__ in (None, WrapperMixin.__init_slave__):\n            raise TypeError('type %r does not implement the wraplet protocol' % getname(cls))\n\n        def wrapper_factory(slave_factory):\n            \"\"\"Factory to create a new class by wrapping ``slave_factory``\"\"\"\n            class Wraplet(cls):  # pylint:disable=abstract-method\n                _slave_factory = staticmethod(slave_factory)\n                # Assign the wrapped attributes directly instead of\n                # using functools.wraps, as we may deal with arbitrarry\n                # class/callable combinations.\n                __doc__ = slave_factory.__doc__\n                # While the wrapped instance wraps the slave, the\n                # wrapper class wraps the slave factory. Any instance\n                # then just hides the class level attribute.\n                # Exposing __wrapped__ here allows introspection,such\n                # as inspect.signature, to pick up metadata.\n                __wrapped__ = slave_factory\n                # In Py3.X, objects without any annotations just provide an\n                # empty dict.\n                __annotations__ = getattr(slave_factory, '__annotations__', {})\n\n                def __init__(self, *slave_args, **slave_kwargs):\n                    slave = self.__init_slave__(self._slave_factory, *slave_args, **slave_kwargs)\n                    super(Wraplet, self).__init__(slave, *cls_args, **cls_kwargs)\n\n                __repr__ = cls.__wraplet_repr__\n\n            # swap places with our target so that both can be pickled/unpickled\n            Wraplet.__name__ = getname(slave_factory).split('.')[-1]\n            Wraplet.__qualname__ = getname(slave_factory)\n            Wraplet.__module__ = slave_factory.__module__\n            # this is enough for Py3.4+ to find the slave\n            slave_factory.__qualname__ = Wraplet.__qualname__ + '._slave_factory'\n            # ## This is an EVIL hack! Do not use use this at home unless you understand it! ##\n            # enable python2 lookup of the slave via its wrapper\n            # This allows to implicitly pickle slave objects which already support pickle,\n            # e.g. function and partial.\n            # python2 pickle performs the equivalent of getattr(sys.modules[obj.__module__, obj.__name__]\n            # which does not allow dotted name lookups. To work around this, we place the slave into the\n            # module, globally, using the qualified name *explicitly*. As qualified names are not valid identifiers,\n            # this will not create a collision unless someone tries to do the same trick.\n            if sys.version_info[:2] <= (3, 4):\n                # While 3.4 adds support for using __qualname__, that is *only* for protocol 4. Older\n                # protocols still require __name__. However, 3.4 *explicitly* disallows using dotted names,\n                # which defeats the obvious way of injecting the proper dotted name. Instead, an illegal name\n                # using : in place of . is used, which should also not conflict.\n                name_separator = '.' if sys.version_info[:2] != (3, 4) else ':'\n                # Make sure we actually register the correct entity\n                # Since we are only working with __name__, the slave could be defined\n                # in an inner scope. In this case, registering it in the global namespace\n                # may increase its lifetime, or replace an actual global slave of the\n                # same name.\n                # There are two cases we have to check here:\n                # slave = wraplet(slave)\n                #   The slave already exists in the module namespace, with its __name__.\n                #   The object with that name must be *identical* to the slave.\n                # @wraplet\\ndef slave\n                #   Neither slave nor Wrapper exist in the namespace yet (they are only bound *after*\n                #   the wraplet returns). No object may exist with the same name.\n                if getattr(sys.modules[slave_factory.__module__], slave_factory.__name__, slave_factory) is slave_factory:\n                    slave_factory.__name__ += name_separator + '_slave_factory'\n                    setattr(sys.modules[slave_factory.__module__], slave_factory.__name__, slave_factory)\n            return Wraplet\n        return wrapper_factory", "response": "Create a factory to produce a Wrapper from a slave factory."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef authenticate(self, request):\n        auth = get_authorization_header(request).split()\n\n        if not auth or auth[0].lower() != b'basic':\n            return None\n\n        if len(auth) == 1:\n            msg = _('Invalid basic header. No credentials provided.')\n            raise exceptions.AuthenticationFailed(msg)\n        elif len(auth) > 2:\n            msg = _('Invalid basic header. Credentials string should not contain spaces.')\n            raise exceptions.AuthenticationFailed(msg)\n\n        try:\n            auth_parts = base64.b64decode(auth[1]).decode(HTTP_HEADER_ENCODING).partition(':')\n        except (TypeError, UnicodeDecodeError):\n            msg = _('Invalid basic header. Credentials not correctly base64 encoded.')\n            raise exceptions.AuthenticationFailed(msg)\n\n        userid, password = auth_parts[0], auth_parts[2]\n        return self.authenticate_credentials(userid, password)", "response": "Returns a User object if a correct username and password have been supplied\n           . Otherwise returns None."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef authenticate_credentials(self, userid, password):\n        credentials = {\n            get_user_model().USERNAME_FIELD: userid,\n            'password': password\n        }\n        user = authenticate(**credentials)\n\n        if user is None:\n            raise exceptions.AuthenticationFailed(_('Invalid username/password.'))\n\n        if not user.is_active:\n            raise exceptions.AuthenticationFailed(_('User inactive or deleted.'))\n\n        return (user, None)", "response": "Authenticate the userid and password against username and password."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef enforce_csrf(self, request):\n        reason = CSRFCheck().process_view(request, None, (), {})\n        if reason:\n            # CSRF failed, bail with explicit error message\n            raise exceptions.PermissionDenied('CSRF Failed: %s' % reason)", "response": "Enforces CSRF validation for session based authentication."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns an enumeration containing only items filtered from another enumeration.", "response": "def filter_enum(pred, enum):\n    \"\"\"\n    Create a new enumeration containing only items filtered from another\n    enumeration.\n\n    Hidden enum items in the original enumeration are excluded.\n\n    :type pred: ``Callable[[`EnumItem`], bool]``\n    :param pred: Predicate that will keep items for which the result is true.\n    :type enum: Enum\n    :param enum: Enumeration to filter.\n    :rtype: Enum\n    :return: New filtered enumeration.\n    \"\"\"\n    def _items():\n        for item in enum:\n            yield EnumItem(\n                item.value,\n                item.desc,\n                not pred(item),\n                **item._extra)\n    return Enum('Filtered from {!r}'.format(enum), list(_items()))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconstruct an enumeration from an iterable of tuples.", "response": "def from_pairs(cls, doc, pairs):\n        \"\"\"\n        Construct an enumeration from an iterable of pairs.\n\n        :param doc: See `Enum.__init__`.\n        :type pairs: ``Iterable[Tuple[unicode, unicode]]``\n        :param pairs: Iterable to construct the enumeration from.\n        :rtype: Enum\n        \"\"\"\n        values = (EnumItem(value, desc) for value, desc in pairs)\n        return cls(doc=doc, values=values)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, value):\n        _nothing = object()\n        item = self._values.get(value, _nothing)\n        if item is _nothing:\n            raise InvalidEnumItem(value)\n        return item", "response": "Get an enumeration item for an enumeration value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the additional enumeration value for extra_name.", "response": "def extra(self, value, extra_name, default=None):\n        \"\"\"\n        Get the additional enumeration value for ``extra_name``.\n\n        :param unicode value: Enumeration value.\n        :param str extra_name: Extra name.\n        :param default: Default value in the case ``extra_name`` doesn't exist.\n        \"\"\"\n        try:\n            return self.get(value).get(extra_name, default)\n        except InvalidEnumItem:\n            return default"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_all(self, **names):\n        values = names.items()\n        if len(values) != 1:\n            raise ValueError('Only one query is allowed at a time')\n        name, value = values[0]\n        for item in self:\n            if item.get(name) == value:\n                yield item", "response": "Find all items with matching extra values."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_upgrade(self):\n        sql = text('delete from upgrade where upgrade = :upgrade')\n        for upgrade in self.legacy_upgrades:\n            db.engine.execute(sql, upgrade=upgrade)", "response": "Implement your upgrades here."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsplit command args to args list returns a list of args", "response": "def expand_args(cmd_args):\n    \"\"\"split command args to args list\n    returns a list of args\n\n    :param cmd_args: command args, can be tuple, list or str\n    \"\"\"\n    if isinstance(cmd_args, (tuple, list)):\n        args_list = list(cmd_args)\n    else:\n        args_list = shlex.split(cmd_args)\n    return args_list"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add(self, phrase, id=None):\n        phrase_id = id if id is not None else self.get_next_id()\n        PhraseDictionary._add_phrase(phrase, phrase_id, self, self.word_list)\n        self.id2phrase[phrase_id] = phrase", "response": "Adds a new phrase to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a phrase to a dictionary.", "response": "def _add_phrase(cls, phrase, phrase_id, dictionary=None, word_list=None):\n        \"\"\"\n        Adds a phrase to a phrase dictionary.\n        :param phrase: list of tokens\n        :param phrase_id: phrase id\n        :param dictionary: phrase dictionary\n        :return: new phrase dictionary\n        \"\"\"\n        # @Note: this function is called recursively\n        if dictionary is None:\n            dictionary = {}\n        if len(phrase):\n            current_word = phrase[0]\n            # if word_list is not None and current_word not in word_list: #@TODO remove, words should already be ids\n            #     word_list.add(current_word)\n            if current_word not in dictionary:\n                dictionary[current_word] = {}\n            cls._add_phrase(phrase[1:], phrase_id, dictionary[current_word], word_list)\n        else:\n            dictionary[None] = phrase_id\n        return dictionary"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if a phrase in the dictionary matches the list of text tokens", "response": "def contains_text_tokens(self, text_tokens):\n        \"\"\"\n        Returns true if a phrase in the dictionary matches the list of text tokens\n        :param text_tokens: a list of tokens.  Each token a string of text.\n        :return: True/False\n        \"\"\"\n        id_run = []\n        for token in text_tokens:\n            id = self.word_list.get(token, None)\n            if id is None:\n                return False  # since a token is not in the word list, the phrase is not in the dictionary\n            id_run.append(id)\n        return self.contains_tokens(id_run)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind the maximal phrase in the run starting from the given index. It uses the dictionary to find sequences of ids that can be merged into a phrase. :param run: a run of ids :param idx: the position in the run to start looking for a merge sequence :param dictionary: the dictionary to use to determine if a merge id is present. This should be a dictionary of dictionaries. Each inner dictionary is a continuation of a mergable run. The end of a run is donated by a None key in a dictionary. The value associated with the None key is the integer of the merge id. :return: phrase_id or None, index after the phrase_id or the current index if no phrase was found.", "response": "def return_max_phrase(run, idx, dictionary):\n        \"\"\"\n        Finds the maximal phrase in the run starting from the given index.  It uses the dictionary to find sequences of ids\n         that can be merged into a phrase.\n        :param run: a run of ids\n        :param idx: the position in the run to start looking for a merge sequence\n        :param dictionary: the dictionary to use to determine if a merge id is present.  This should be a dictionary of\n        dictionaries.  Each inner dictionary is a continuation of a mergable run.  The end of a run is donated by a None key\n        in a dictionary.  The value associated with the None key is the integer of the merge id.\n        :return: phrase_id or None, index after the phrase_id or the current index if no phrase was found.\n        \"\"\"\n        if idx < len(run) and run[idx] in dictionary:\n            id = run[idx]\n            rv, rv_idx = PhraseDictionary.return_max_phrase(run, idx + 1, dictionary[id])\n            if rv is not None:\n                return rv, rv_idx\n\n        if None in dictionary:\n            return dictionary[None], idx\n        else:\n            return None, None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts any identified phrases in the run into phrase_ids.", "response": "def convert_to_merged_ids(self, id_run):\n        \"\"\"\n        Converts any identified phrases in the run into phrase_ids.  The dictionary provides all acceptable phrases\n        :param id_run: a run of token ids\n        :param dictionary: a dictionary of acceptable phrases described as there component token ids\n        :return: a run of token and phrase ids.\n        \"\"\"\n        i = 0\n        rv = []\n        while i < len(id_run):\n            phrase_id, offset = self.max_phrase(id_run, i)\n            if phrase_id:\n                rv.append(phrase_id)\n                i = offset\n            else:\n                rv.append(id_run[i])\n                i += 1\n        return rv"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the preferred service for a given station", "response": "def get_service(station: str) -> Service:\n    \"\"\"\n    Returns the preferred service for a given station\n    \"\"\"\n    for prefix in PREFERRED:\n        if station.startswith(prefix):\n            return PREFERRED[prefix]  # type: ignore\n    return NOAA"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_err(self, body: str, key: str = 'report path') -> InvalidRequest:\n        msg = f'Could not find {key} in {self.__class__.__name__} response\\n'\n        return InvalidRequest(msg + body)", "response": "Creates an InvalidRequest exception with formatted error message"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfetching a report string from the service server", "response": "def fetch(self, station: str) -> str:\n        \"\"\"\n        Fetches a report string from the service\n        \"\"\"\n        valid_station(station)\n        try:\n            resp = getattr(requests, self.method.lower())(self.url.format(self.rtype, station))\n            if resp.status_code != 200:\n                raise SourceError(f'{self.__class__.__name__} server returned {resp.status_code}')\n        except requests.exceptions.ConnectionError:\n            raise ConnectionError(f'Unable to connect to {self.__class__.__name__} server')\n        report = self._extract(resp.text, station)\n        # This split join replaces all *whitespace elements with a single space\n        return ' '.join(report.split())"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nextracts the raw_report element from XML response.", "response": "def _extract(self, raw: str, station: str = None) -> str:\n        \"\"\"\n        Extracts the raw_report element from XML response\n        \"\"\"\n        resp = parsexml(raw)\n        try:\n            report = resp['response']['data'][self.rtype.upper()]\n        except KeyError:\n            raise self.make_err(raw)\n        # Find report string\n        if isinstance(report, dict):\n            report = report['raw_text']\n        elif isinstance(report, list) and report:\n            report = report[0]['raw_text']\n        else:\n            raise self.make_err(raw, '\"raw_text\"')\n        # Remove excess leading and trailing data\n        for item in (self.rtype.upper(), 'SPECI'):\n            if report.startswith(item + ' '):\n                report = report[len(item) + 1:]\n        return report"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _extract(self, raw: str, station: str = None) -> str:\n        resp = parsexml(raw)\n        try:\n            report = resp['response']['body']['items']['item'][self.rtype.lower() + 'Msg']\n        except KeyError:\n            raise self.make_err(raw)\n        # Replace line breaks\n        report = report.replace('\\n', '')\n        # Remove excess leading and trailing data\n        for item in (self.rtype.upper(), 'SPECI'):\n            if report.startswith(item + ' '):\n                report = report[len(item) + 1:]\n        report = report.rstrip('=')\n        # Make every element single-spaced and stripped\n        return ' '.join(report.split())", "response": "Extracts the report message from the XML response."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract the reports message using string finding", "response": "def _extract(self, raw: str, station: str) -> str:  # type: ignore\n        \"\"\"\n        Extracts the reports message using string finding\n        \"\"\"\n        report = raw[raw.find(station.upper() + ' '):]\n        report = report[:report.find(' =')]\n        return report"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying the weather from a METAR object to a MIZ file.", "response": "def set_weather_from_metar(\n        metar: typing.Union[Metar.Metar, str],\n        in_file: typing.Union[str, Path],\n        out_file: typing.Union[str, Path] = None\n) -> typing.Tuple[typing.Union[str, None], typing.Union[str, None]]:\n    \"\"\"\n    Applies the weather from a METAR object to a MIZ file\n\n    Args:\n        metar: metar object\n        in_file: path to MIZ file\n        out_file: path to output MIZ file (will default to in_file)\n\n    Returns: tuple of error, success\n\n    \"\"\"\n    error, metar = custom_metar.CustomMetar.get_metar(metar)\n\n    if error:\n        return error, None\n\n    if metar:\n        LOGGER.debug('METAR: %s', metar.code)\n\n    in_file = elib.path.ensure_file(in_file)\n\n    if out_file is None:\n        out_file = in_file\n    else:\n        out_file = elib.path.ensure_file(out_file, must_exist=False)\n    LOGGER.debug('applying metar: %s -> %s', in_file, out_file)\n\n    try:\n        LOGGER.debug('building MissionWeather')\n        _mission_weather = mission_weather.MissionWeather(metar)\n\n        with Miz(str(in_file)) as miz:\n            _mission_weather.apply_to_miz(miz)\n            miz.zip(str(out_file))\n            return None, f'successfully applied METAR to {in_file}'\n\n    except ValueError:\n        error = f'Unable to apply METAR string to the mission.\\n' \\\n                f'This is most likely due to a freak value, this feature is still experimental.\\n' \\\n                f'I will fix it ASAP !'\n        return error, None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _pull_schedule_loop(self):\n        try:\n            self.pull_schedule()\n            delay = 16*60\n        except ScheduleError, e:\n            self.l.exception(\"ScheduleError while pulling schedule.  \"+\n                             \"Retrying in 5m\")\n            delay = 5*60\n        if not self.running:\n            return\n        self.scheduler.plan(time.time() + delay, self._pull_schedule_loop)", "response": "Called every 16 minutes to pull a new version of the schedule"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef jiggle_source_code(self):  # type: () ->int\n        changed = 0\n        for file_name in self.file_inventory.source_files:\n            to_write = []\n            # self.create_missing(file_name, file_name)\n            if not os.path.isfile(file_name):\n                continue\n\n            all_source = self.file_opener.read_this(file_name)\n            if \"__version_info__\" in all_source:\n                logger.warning(\"We have __version_info__ to sync up.\")\n                # raise TypeError()\n\n            with self.file_opener.open_this(file_name, \"r\") as infile:\n                for line in infile:\n                    leading_white = self.leading_whitespace(line)\n                    version, version_token = dunder_version.find_in_line(line)\n                    if version:\n                        simplified_line = dunder_version.simplify_line(\n                            line, keep_comma=True\n                        )\n                        if simplified_line.strip(\" \\t\\n\").endswith(\",\"):\n                            comma = \",\"\n                        else:\n                            comma = \"\"\n\n                        if simplified_line.strip(\" \\t\\n\").startswith(\",\"):\n                            start_comma = \",\"\n                        else:\n                            start_comma = \"\"\n\n                        to_write.append(\n                            '{0}{1}{2} = \"{3}\"{4}{5}\\n'.format(\n                                start_comma,\n                                leading_white,\n                                version_token,\n                                unicode(self.version_to_write()),\n                                comma,\n                                self.signature,\n                            )\n                        )\n                    else:\n                        to_write.append(line)\n\n            check(self.file_opener.open_this(file_name, \"r\").read(), \"\".join(to_write))\n            with open(file_name, \"w\") as outfile:\n                outfile.writelines(to_write)\n                changed += 1\n        return changed", "response": "Updates version of central package with new source code."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef jiggle_setup_py(self):  # type: () -> int\n        changed = 0\n        setup_py = os.path.join(self.SRC, \"setup.py\")\n        if not os.path.isfile(setup_py):\n            return changed\n        lines_to_write = []\n        need_rewrite = False\n\n        encoding = chardet.detect(io.open(setup_py, \"rb\").read())\n        # logger.warning(\"guessing encoding \" + str(encoding))\n        with self.file_opener.open_this(setup_py, \"r\") as infile:\n            for line in infile:\n                leading_white = self.leading_whitespace(line)\n\n                simplified_line = dunder_version.simplify_line(line, keep_comma=True)\n\n                # determine if we have a version=\n                version = kwarg_version.find_in_line(line)\n                # setup() function args\n                if version:\n                    if simplified_line.strip(\" \\t\\n\").startswith(\",\"):\n                        start_comma = \",\"\n                    else:\n                        start_comma = \"\"\n\n                    comma = \"\"\n                    if simplified_line.strip(\" \\t\\n\").endswith(\",\"):\n                        comma = \",\"\n                    # could happen, say on last.\n                    # if not comma and not start_comma:\n                    #     print(simplified_line)\n                    #     raise TypeError(\"$$$$$\")\n                    source = '{0}{1}version = \"{2}\"{3}{4}\\n'.format(\n                        leading_white,\n                        start_comma,\n                        unicode(self.version_to_write()),\n                        comma,\n                        self.signature,\n                    )\n                    need_rewrite = True\n                    lines_to_write.append(source)\n                    continue\n\n                # code that isn't the setup() function args\n                version, version_token = dunder_version.find_in_line(line)\n                if version:\n                    if simplified_line.strip(\" \\t\\n\").startswith(\",\"):\n                        start_comma = \",\"\n                    else:\n                        start_comma = \"\"\n\n                    # the other simplify removes \",\"\n                    if simplified_line.strip(\" \\t\\n\").endswith(\",\"):\n                        comma = \",\"\n                    else:\n                        comma = \"\"\n\n                    lines_to_write.append(\n                        '{0}{1}{2} = \"{3}\"{4}{5}\\n'.format(\n                            leading_white,\n                            start_comma,\n                            version_token,\n                            unicode(self.version_to_write()),\n                            comma,\n                            self.signature,\n                        )\n                    )\n                    need_rewrite = True\n                    continue\n\n                lines_to_write.append(line)\n\n        if need_rewrite:\n            check(\n                self.file_opener.open_this(setup_py, \"r\").read(),\n                \"\".join(lines_to_write),\n            )\n            with io.open(setup_py, \"w\", encoding=encoding[\"encoding\"]) as outfile:\n\n                outfile.writelines(lines_to_write)\n                outfile.close()\n                changed += 1\n        return changed", "response": "This function is used to edit a version = 1. 2. 3 in the setup. py file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the number of changed files.", "response": "def jiggle_all(self):  # type: () -> int\n        \"\"\"\n        All possible files\n        :return:\n        \"\"\"\n        changed = 0\n        changed += self.jiggle_text_file()\n        changed += self.jiggle_source_code()\n        changed += self.jiggle_config_file()\n        changed += self.jiggle_setup_py()\n        # assert changed > 0, \"Failed to change anything.\"\n        return changed"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate ini cfg conf Update ini cfg conf Update ini cfg conf Update ini cfg conf Update ini cfg conf Update ini cfg conf Update ini cfg conf Update cfg conf", "response": "def jiggle_config_file(self):  # type: () ->int\n        \"\"\"\n        Update ini, cfg, conf\n        \"\"\"\n        changed = 0\n        # setup.py related. setup.py itself should read __init__.py or __version__.py\n\n        other_files = [\"setup.cfg\"]\n\n        for file_name in other_files:\n            filepath = os.path.join(self.SRC, file_name)\n\n            # only create setup.cfg if we have setup.py\n            if (\n                self.create_configs\n                and not os.path.isfile(filepath)\n                and os.path.isfile(\"setup.py\")\n            ):\n                logger.info(\"Creating \" + unicode(filepath))\n                self.file_maker.create_setup_cfg(filepath)\n\n            if os.path.isfile(filepath):\n                config = configparser.ConfigParser()\n                config.read(filepath)\n                try:\n                    version = config[\"metadata\"][\"version\"]\n                except KeyError:\n                    version = \"\"\n                if version:\n                    with io.open(filepath, \"w\") as configfile:  # save\n                        config[\"metadata\"][\"version\"] = unicode(self.version_to_write())\n                        config.write(configfile)\n                        changed += 1\n        return changed"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef jiggle_text_file(self):  # type: () -> int\n        changed = 0\n\n        files_to_update = []\n        for version_txt in self.file_inventory.text_files:\n            if os.path.isfile(version_txt):\n                files_to_update.append(version_txt)\n\n        if not files_to_update and self.create_configs:\n            files_to_update = self.file_inventory.default_text_file\n\n        for version_txt in files_to_update:\n            if os.path.isfile(version_txt):\n                with io.open(version_txt, \"w\", encoding=\"utf-8\") as outfile:\n                    if self.version is None or self.version == \"\":\n                        raise JiggleVersionException(\"Can't write version\")\n                    outfile.writelines([unicode(self.version_to_write())])\n                    outfile.close()\n                    changed += 1\n        return changed", "response": "Update ver strings in a non - python ordinary text file in root of package."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef name_from_setup_py(self):  # type: () -> str\n        source = self.setup_py_source()\n        if not source:\n            return \"\"\n        for row in source.split(\"\\n\"):\n            #\n            if \"packages=\" in row:\n                simplified_row = row.replace(\" \", \"\").replace(\"'\", '\"').strip(\" \\t\\n\")\n                if '\"' in simplified_row:\n                    return simplified_row.split('\"')[1]\n\n            if \"name=\" in row:\n                simplified_row = row.replace(\" \", \"\").replace(\"'\", '\"').strip(\" \\t\\n\")\n                if '\"' in simplified_row:\n                    return simplified_row.split('\"')[1]\n        return \"\"", "response": "Extract likley module name from setup. py"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef via_find_packages(self):  # type: () -> List[str]\n        packages = []  # type: List[str]\n        source = self.setup_py_source()\n        if not source:\n            return packages\n        for row in source.split(\"\\n\"):\n            if \"find_packages\" in row:\n                logger.debug(row)\n                if \"find_packages()\" in row:\n                    packages = find_packages()\n                else:\n                    try:\n                        value = row.split(\"(\")[1].split(\")\")[0]\n                        packages = find_packages(ast.literal_eval(value))\n                        logger.debug(unicode(packages))\n                    except:\n                        logger.debug(source)\n                        # raise\n\n        return packages", "response": "Use find_packages code to find modules. Can find LOTS of modules."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind all candidate projects.", "response": "def find_project(self):  # type: () -> List[str]\n        \"\"\"\n        Get all candidate projects\n        :return:\n        \"\"\"\n        folders = [f for f in os.listdir(\".\") if os.path.isdir(f)]\n\n        candidates = []\n        setup = self.setup_py_source()\n        for folder in folders:\n            if os.path.isfile(folder + \"/__init__.py\"):\n                dunder_source = self._read_file(folder + \"/__init__.py\")\n                project = folder\n                if setup:\n                    # prevents test folders & other junk\n                    in_setup = (\n                        \"'{0}\".format(project) not in setup\n                        and '\"{0}\"'.format(project) not in setup\n                    )\n                    in_dunder = (\n                        \"'{0}\".format(dunder_source) not in setup\n                        and '\"{0}\"'.format(dunder_source) not in setup\n                    )\n\n                    if not in_setup and not in_dunder:\n                        continue\n\n                candidates.append(folder)\n\n        # TODO: parse setup.cfg\n        if not candidates:\n            candidates = candidates + self.find_single_file_project()\n        if not candidates:\n            candidates = candidates + self.find_malformed_single_file_project()\n\n        candidates = list(set([x for x in candidates if x]))\n\n        # too many\n        if not candidates:\n            candidates.extend(self.via_find_packages())\n            candidates = list(set([x for x in candidates if x]))\n\n        if len(candidates) > 1:\n            for unlikely in [\n                \"test\",\n                \"tests\",\n                \"example\",\n                \"examples\",\n                \"demo\",\n                \"demos\",\n                \"test_files\",\n            ]:\n                if unlikely in candidates:\n                    logger.warning(\"Assuming {0} is not the project\".format(unlikely))\n                    candidates.remove(unlikely)\n                if len(candidates) == 1:\n                    break\n\n        # too few or too many\n        if len(candidates) != 1:\n            likely_name = self.name_from_setup_py()\n            if likely_name in candidates:\n                return [likely_name]\n        return list(set([x for x in candidates if x]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds a single file in the project.", "response": "def find_malformed_single_file_project(self):  # type: () -> List[str]\n        \"\"\"\n        Take first non-setup.py python file. What a mess.\n        :return:\n        \"\"\"\n        files = [f for f in os.listdir(\".\") if os.path.isfile(f)]\n\n        candidates = []\n        # project misnamed & not in setup.py\n\n        for file in files:\n            if file.endswith(\"setup.py\") or not file.endswith(\".py\"):\n                continue  # duh\n\n            candidate = file.replace(\".py\", \"\")\n            if candidate != \"setup\":\n                candidates.append(candidate)\n                # return first\n                return candidates\n\n        # files with shebang\n        for file in files:\n            if file.endswith(\"setup.py\"):\n                continue  # duh\n\n            if \".\" not in file:\n                candidate = files\n                try:\n                    firstline = self.file_opener.open_this(file, \"r\").readline()\n                    if (\n                        firstline.startswith(\"#\")\n                        and \"python\" in firstline\n                        and candidate in self.setup_py_source()\n                    ):\n                        candidates.append(candidate)\n                        return candidates\n                except:\n                    pass\n        # default.\n        return candidates"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding well formed singler file project", "response": "def find_single_file_project(self):  # type: () -> List[str]\n        \"\"\"\n        Find well formed singler file project\n        :return:\n        \"\"\"\n        files = [f for f in os.listdir(\".\") if os.path.isfile(f)]\n\n        candidates = []\n        setup_source = self.setup_py_source()\n\n        for file in files:\n            if file.endswith(\"setup.py\") or not file.endswith(\".py\"):\n                continue  # duh\n\n            if setup_source:\n                if file.replace(\".py\", \"\") in setup_source:\n                    candidate = file.replace(\".py\", \"\")\n                    if candidate != \"setup\":\n                        candidates.append(candidate)\n\n        return candidates"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates that there is only one project in the current directory.", "response": "def validate_found_project(self, candidates):  # type: (List[str]) -> None\n        \"\"\"\n        Should be only 1 project\n        :param candidates:\n        :return:\n        \"\"\"\n        if len(candidates) > 1:\n            message = \"Found multiple possible projects : \" + unicode(candidates)\n            logger.error(message)\n            die(-1, message)\n            return\n        if not candidates:\n            # we can still update setup.py\n            logger.warning(\n                \"Found no project. Expected a folder in current directory to contain a __init__.py \"\n                \"file. Use --source, --project for other scenarios\"\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading application configuration files.", "response": "def _getConfiguration(self):\n        \"\"\"\n        Load application configuration files.\n\n        :return: <dict>\n        \"\"\"\n        configDirectoryPath = os.path.join(\"application\", \"config\")\n        config = Config(configDirectoryPath)\n        configData = config.getData()\n\n        # setting application parameters\n        reactor.suggestThreadPoolSize(\n            int(configData[\"performance\"][\"threadPoolSize\"])\n        )\n\n        return configData"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _getInterfaces(self):\n        interfaces = {}\n\n        interfacesPath = os.path.join(\"application\", \"interface\")\n        interfaceList = os.listdir(interfacesPath)\n\n        for file in interfaceList:\n            interfaceDirectoryPath = os.path.join(interfacesPath, file)\n            if not os.path.isdir(interfaceDirectoryPath) or file.startswith(\"__\") or file.startswith(\".\"):\n                continue\n\n            interfaceName = ntpath.basename(interfaceDirectoryPath)\n            interfacePath = os.path.join(interfaceDirectoryPath, interfaceName) + \".py\"\n\n            if not os.path.isfile(interfacePath):\n                continue\n\n            # importing interface\n            interfaceSpec = importlib.util.spec_from_file_location(\n                interfaceName,\n                interfacePath\n            )\n            interface = importlib.util.module_from_spec(interfaceSpec)\n            interfaceSpec.loader.exec_module(interface)\n\n            # checking if there is an interface in the file\n            if hasattr(interface, \"Service\"):\n                # initializing interface\n                interfaceInstance = interface.Service(self)\n                interfaces[interfaceName] = interfaceInstance\n\n        return interfaces", "response": "Load application communication interfaces."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _getModules(self):\n        modules = {}\n        modulesPath = os.path.join(\"application\", \"module\")\n        moduleList = os.listdir(modulesPath)\n\n        for moduleName in moduleList:\n            modulePath = os.path.join(modulesPath, moduleName, \"module.py\")\n            if not os.path.isfile(modulePath):\n                continue\n\n            # importing module\n            moduleSpec = importlib.util.spec_from_file_location(\n                moduleName,\n                modulePath\n            )\n            module = importlib.util.module_from_spec(moduleSpec)\n            moduleSpec.loader.exec_module(module)\n\n            # initializing module\n            moduleInstance = module.Module(self)\n            modules[moduleName] = moduleInstance\n\n        return modules", "response": "Imports and loads application modules."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a model instance to the application model pool.", "response": "def addModel(self, moduleName, modelName, model):\n        \"\"\"\n        Add a model instance to the application model pool.\n\n        :param moduleName: <str> module name in which the model is located\n        :param modelName: <str> model name\n        :param model: <object> model instance\n        :return: <void>\n        \"\"\"\n        modelIdentifier = \"{}.{}\".format(moduleName, modelName)\n        if modelIdentifier not in self._models:\n            self._models[modelIdentifier] = model\n        else:\n            message = \"Application - addModel() - \" \\\n                      \"A model with the identifier {} already exists.\" \\\n                      .format(modelIdentifier)\n            raise Exception(message)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the requested model.", "response": "def getModel(self, modelIdentifier):\n        \"\"\"\n        Return the requested model.\n\n        :param modelIdentifier: <str> model identifier\n        :return: <object> model instance\n        \"\"\"\n        if modelIdentifier in self._models:\n            return self._models[modelIdentifier]\n        else:\n            message = \"Application - getModel() - \" \\\n                      \"Model with identifier {} does not exist.\" \\\n                      .format(modelIdentifier)\n            raise Exception(message)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload application bundled services.", "response": "def _loadViperServices(self):\n        \"\"\"\n        Load application bundled services.\n\n        :return: <void>\n        \"\"\"\n        servicesPath = os.path.join(\n            os.path.dirname(os.path.realpath(__file__)),\n            \"service\"\n        )\n        for serviceFile in os.listdir(servicesPath):\n            if serviceFile.startswith(\"__\") or serviceFile.startswith(\".\"):\n                continue\n\n            serviceName = serviceFile.replace(\".py\", \"\")\n            servicePath = os.path.join(\n                servicesPath, serviceFile\n            )\n\n            if not os.path.isfile(servicePath):\n                continue\n\n            # importing service\n            serviceSpec = importlib.util.spec_from_file_location(\n                serviceName,\n                servicePath\n            )\n            service = importlib.util.module_from_spec(serviceSpec)\n            serviceSpec.loader.exec_module(service)\n\n            # initializing service\n            serviceInstance = service.Service(self)\n            self.addService(\"viper\", serviceName, serviceInstance)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addService(self, moduleName, serviceName, service):\n        serviceIdentifier = \"{}.{}\".format(moduleName, serviceName)\n        if serviceIdentifier not in self._services:\n            self._services[serviceIdentifier] = service\n        else:\n            message = \"Application - addService() - \" \\\n                      \"A service with the identifier {} already exists.\" \\\n                      .format(serviceIdentifier)\n            raise Exception(message)", "response": "Adds a service instance to the application service pool."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the requested service instance.", "response": "def getService(self, serviceIdentifier):\n        \"\"\"\n        Return the requested service instance.\n\n        :param serviceIdentifier: <str> service identifier\n        :return: <object> service instance\n        \"\"\"\n        if serviceIdentifier in self._services:\n            return self._services[serviceIdentifier]\n        else:\n            message = \"Application - getService() - \" \\\n                      \"Service with identifier {} does not exist.\" \\\n                      .format(serviceIdentifier)\n            raise Exception(message)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load(settings=None, namespace=None, prefix=None):\n\n    parent = pyaas.util.getParent()\n    script_name = os.path.basename(parent)\n    script_name = script_name.rsplit('.', 1)[0]\n\n    if prefix is None:\n        # get the filename of the caller\n        # get the directory name of the file\n        prefix = os.path.dirname(parent)\n\n        if prefix.endswith(os.path.sep + 'bin'):\n            prefix = os.path.join(prefix, '..')\n            prefix = os.path.abspath(prefix)\n\n    prefix = os.path.abspath(prefix)\n    if pyaas.prefix != prefix:\n        pyaas.prefix = prefix\n        logging.debug('Setting prefix to \"%s\"', pyaas.prefix)\n\n    if namespace is None:\n        namespace = script_name\n\n    if namespace != pyaas.namespace:\n        pyaas.namespace = namespace\n        logging.debug('Setting namespace to \"%s\"', pyaas.namespace)\n\n    # if settings is not passed in use the supplied or derived namespace\n    settings = settings or namespace\n\n    pyaas.args = pyaas.argparser.parse_args()\n\n    pyaas.config = configparser.SafeConfigParser(dict_type=collections.OrderedDict)\n    pyaas.config.optionxform = str\n\n    ini_files = [\n        pyaas.paths('etc', settings + '.ini'),\n        pyaas.paths('etc', settings + '.ini.local')\n    ]\n\n    if pyaas.args.ini:\n        ini_files.append(pyaas.args.ini)\n\n    try:\n        ok = pyaas.config.read(ini_files)\n    except configparser.ParsingError as e:\n        raise pyaas.error('Unable to parse file: %s', e)\n\n    if not ok:\n        raise pyaas.error('Unable to read config file(s): %s', ini_files)\n\n    # setup file log\n    file_name = '%s_%s.log' % (script_name, time.strftime('%Y%m%d_%H%M%S'))\n\n    # hack back in single log file option without breaking existing code\n    if pyaas.config.has_section('logging'):\n        if pyaas.config.has_option('logging', 'append'):\n            append = pyaas.config.getboolean('logging', 'append')\n            if append:\n                file_name = script_name + '.log'\n\n    full_path = pyaas.paths('var', file_name)\n    logfile = logging.FileHandler(full_path)\n    logfile.setLevel(logging.INFO)\n\n    logfile.setFormatter(\n        logging.Formatter(\n            fmt = '%(asctime)s %(levelname)-8s %(message)s',\n            datefmt = '%Y-%m-%d %H:%M:%S',\n            )\n        )\n\n    # add the handlers to the logger\n    root = logging.getLogger()\n    root.addHandler(logfile)\n\n    if pyaas.args.debug:\n        root.setLevel(logging.DEBUG)\n        logfile.setLevel(logging.DEBUG)\n\n    # call this here if there is no daemon option\n    if not hasattr(pyaas.args, 'daemon'):\n        pyaas.module.load()\n\n    return", "response": "Load the next available version of the application."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd all parameters interpreted as integers", "response": "def add(self, *number):\n        \"\"\"Adds all parameters interpreted as integers\"\"\"\n        return self._format_result(sum(\n            # positional arguments are always strings\n            [int(n) for n in number]))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsubtract number2 from number1", "response": "def subtract(self, number1, number2):\n        \"\"\"Subtracts number2 from number1\"\"\"\n        return self._format_result(int(number1) - int(number2))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomputes the logarithm of x with the given base.", "response": "def log(self, x, base=2):\n        \"\"\"Computes the logarithm of x with the given base\n         (the default base is 2).\"\"\"\n        return self._format_result(log(float(x), base))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef area(x,y):\n    # http://stackoverflow.com/questions/24467972/calculate-area-of-polygon-given-x-y-coordinates\n    return 0.5 * np.abs(np.dot(x, np.roll(y, 1)) - np.dot(y, np.roll(x, 1)))", "response": "Calculate the area of a polygon given as x y"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pointInsidePolygon(x, y, poly):\n    n = len(poly)\n    inside = False\n    p1x, p1y = poly[0]\n    for i in range(n + 1):\n        p2x, p2y = poly[i % n]\n        if y > min(p1y, p2y):\n            if y <= max(p1y, p2y):\n                if x <= max(p1x, p2x):\n                    if p1y != p2y:\n                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                    if p1x == p2x or x <= xinters:\n                        inside = not inside\n        p1x, p1y = p2x, p2y\n    return inside", "response": "Determine if a point is inside a given polygon or not\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef conf_merger(user_dict, variable):\n    if variable not in globals().keys():\n        raise NameError(\"Unknown variable '%s'.\" % variable)\n\n    if variable not in user_dict:\n        return globals()[variable]\n\n    return globals()[variable] and user_dict[variable]", "response": "Merge global configuration with user s personal configuration."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget list of all uppercase non - private globals", "response": "def get_all_constants():\n    \"\"\"\n    Get list of all uppercase, non-private globals (doesn't start with ``_``).\n\n    Returns:\n        list: Uppercase names defined in `globals()` (variables from this \\\n              module).\n    \"\"\"\n    return filter(\n        lambda key: key.upper() == key and type(globals()[key]) in _ALLOWED,\n\n        filter(                               # filter _PRIVATE variables\n            lambda x: not x.startswith(\"_\"),\n            globals()\n        )\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_connection(self, host, port):\n        return beanstalkc.Connection(\n            host=host,\n            port=port\n        )", "response": "Returns a StrictRedis connection instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the length of the queue.", "response": "def len(self, queue_name):\n        \"\"\"\n        Returns the length of the queue.\n\n        :param queue_name: The name of the queue. Usually handled by the\n            ``Gator`` instance.\n        :type queue_name: string\n\n        :returns: The length of the queue\n        :rtype: integer\n        \"\"\"\n        try:\n            stats = self.conn.stats_tube(queue_name)\n        except beanstalkc.CommandFailed as err:\n            if err[1] == 'NOT_FOUND':\n                return 0\n\n            raise\n\n        return stats.get('current-jobs-ready', 0)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndrop all the task in the queue.", "response": "def drop_all(self, queue_name):\n        \"\"\"\n        Drops all the task in the queue.\n\n        :param queue_name: The name of the queue. Usually handled by the\n            ``Gator`` instance.\n        :type queue_name: string\n        \"\"\"\n        # This is very inefficient, but Beanstalk (as of v1.10) doesn't support\n        # deleting an entire tube.\n        queue_length = self.len(queue_name)\n        self._only_watch_from(queue_name)\n\n        for i in xrange(queue_length):\n            job = self.conn.reserve(timeout=0)\n\n            if job:\n                job.delete()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef push(self, queue_name, task_id, data):\n        # Beanstalk doesn't let you specify a task id.\n        self.conn.use(queue_name)\n        return self.conn.put(data)", "response": "Pushes a task onto the queue."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pop(self, queue_name):\n        self._only_watch_from(queue_name)\n        job = self.conn.reserve(timeout=0)\n        job.delete()\n        return job.body", "response": "Pops a task off the queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the data for a specific task from the specified queue.", "response": "def get(self, queue_name, task_id):\n        \"\"\"\n        Pops a specific task off the queue by identifier.\n\n        :param queue_name: The name of the queue. Usually handled by the\n            ``Gator`` instance.\n        :type queue_name: string\n\n        :param task_id: The identifier of the task.\n        :type task_id: string\n\n        :returns: The data for the task.\n        :rtype: string\n        \"\"\"\n        self._only_watch_from(queue_name)\n        job = self.conn.peek(task_id)\n\n        if not job:\n            return\n\n        job.delete()\n        return job.body"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd facets to search results.", "response": "def add_facets(engine_result, facet_features=None):\n    '''Adds facets to search results.\n\n    Construct a new result payload with `facets` added as a new\n    top-level property that carries a mapping from unicode strings to\n    lists of content_ids.  The `facet_features` lists the names of\n    :class:`~dossier.fc.StringCounter` features in each result\n    :class:`~dossier.fc.FeatureCollection` to harvest phrases for the\n    facets list.  If not specified, `facet_features` defaults to\n    `bowNP_sip`.\n\n    The remainder of the facet logic is handled in the UI.\n    '''\n    if facet_features is None:\n        facet_features = ['bowNP_sip']\n    phrases = collections.defaultdict(list)\n    for r in engine_result['results']:\n        cid = r[0]\n        fc = r[1]\n        for fname in facet_features:\n            for phrase in fc.get(u'bowNP_sip', []):\n                phrases[phrase].append(cid)\n    return dict(engine_result, **{'facets': dict(phrases)})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a list of labels into a list of coref values.", "response": "def labels_to_indexed_coref_values(content_objs, labels):\n    '''[(content_id, FeatureCollection)] -> [Label] -> [({-1,1}, i, j)]\n\n    where 0 <= i, j < len(content_objs).\n    '''\n    cids_to_idx = {}\n    for i, (content_id, _) in enumerate(content_objs):\n        cids_to_idx[content_id] = i\n    idx = lambda cid: cids_to_idx[cid]\n    labs = []\n    for lab in labels:\n        if lab.content_id1 in cids_to_idx and lab.content_id2 in cids_to_idx:\n            labs.append((lab.value.value, idx(lab.content_id1), idx(lab.content_id2)))\n    return labs"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndiscovers the ordered set of vectorizable features in fcs Returns a list of feature names sorted lexicographically.", "response": "def vectorizable_features(fcs):\n    '''Discovers the ordered set of vectorizable features in ``fcs``.\n\n    Returns a list of feature names, sorted lexicographically.\n    Feature names are only included if the corresponding\n    features are vectorizable (i.e., they are an instance of\n    :class:`collections.Mapping`).\n    '''\n    is_mapping = lambda obj: isinstance(obj, collections.Mapping)\n    return sorted(set([name for fc in fcs for name in fc if is_mapping(fc[name])]))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute the pairwise dissimilarity matrices. This returns a dictionary mapping each name in feature_names to a pairwise dissimilarity matrix. The pairwise dissimilarity matrix corresponds to 1 - kernel between each feature of each pair of feature collections in fcs.", "response": "def dissimilarities(feature_names, fcs):\n    '''Computes the pairwise dissimilarity matrices.\n\n    This returns a dictionary mapping each name in ``feature_names``\n    to a pairwise dissimilarities matrix. The dissimilaritiy scores\n    correspond to ``1 - kernel`` between each feature of each\n    pair of feature collections in ``fcs``.\n\n    (The kernel used is currently fixed to ``cosine`` distance.)\n    '''\n    dis = {}\n    for count, name in enumerate(feature_names, 1):\n        logger.info('computing pairwise dissimilarity matrix '\n                    'for %d of %d features (current feature: %s)',\n                    count, len(feature_names), name)\n        # opportunity to use joblib is buried down inside call to\n        # pairwise_distances...\n        # And it's fixed to `n_jobs=1` because running multiprocessing\n        # inside py.test causes weird problems. It also doesn't seem like a\n        # good idea to do it inside a web server either. ---AG\n        dis[name] = 1 - pairwise_distances(\n            dict_vector().fit_transform([get_feat(fc, name) for fc in fcs]),\n            metric='cosine', n_jobs=1)\n    return dis"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntrain a model and predicts recommendations.", "response": "def probabilities(self):\n        '''Trains a model and predicts recommendations.\n\n        If the query feature collection could not be found or if there\n        is insufficient training data, an empty list is returned.\n\n        Otherwise, a list of content objects (tuples of content\n        id and feature collection) and probabilities is returned.\n        The probability is generated from the model, and reflects\n        confidence of the model that the corresponding content object\n        is related to the query based on the ground truth data.\n\n        On a large database, random samples are used for training, so\n        this function is not deterministic.\n\n        :rtype: ``list`` of\n          ((``content_id``, :class:`dossier.fc.FeatureCollection`),\n          probability)\n        '''\n        self.query_fc = self.store.get(self.query_content_id)\n        if self.query_fc is None:\n            logger.warning('Could not find FC for %s', self.query_content_id)\n            return []\n\n        # Try the canopy query before training, because if the canopy query\n        # gives us nothing, then there's no point in the additional work.\n        #\n        # Possible optimization: If the canopy query yields fewer than N\n        # results, then can we just return all of them? ---AG\n        #\n        # N.B Doing the canopy query first will cause things to be slower\n        # when there is insufficient training data.\n        candidates = self.canopy(limit=self.canopy_limit)\n        if len(candidates) == 0:\n            logger.info(\n                'Could not find any candidates in a canopy query by '\n                'scanning the following indexes: %s',\n                ', '.join(self.store.index_names()))\n            return []\n\n        # Get labels from the database and translate them to the form\n        # `[{-1, 1}, i, j]` where `i, j` are indices into the list\n        # `content_objs`, which has type `[(content_id, FeatureCollection)]`.\n        logger.info('Fetching labels...')\n        labels = list(self.labels_from_query(limit=self.label_limit))\n        logger.info('Fetching FCs from labels...')\n        content_objs = self.content_objs_from_labels(labels)\n        indexed_labels = labels_to_indexed_coref_values(content_objs, labels)\n\n        logger.info('Training...')\n        model = self.train(content_objs, indexed_labels)\n        if model is None:\n            logger.info(\n                'Could not train model: insufficient training data. '\n                '(query content id: %s)', self.query_content_id)\n            raise InsufficientTrainingData\n\n        feature_names, classifier, transformer = model\n        return zip(candidates, self.classify(\n            feature_names, classifier, transformer, candidates))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef train(self, content_objs, idx_labels):\n        '''Trains and returns a model using sklearn.\n\n        If there are new labels to add, they can be added, returns an\n        sklearn model which can be used for prediction and getting\n        features.\n\n        This method may return ``None`` if there is insufficient\n        training data to produce a model.\n\n        :param labels: Ground truth data.\n        :type labels: list of ``({-1, 1}, index1, index2)``.\n        '''\n        # We have insufficient training data when there is only one or\n        # fewer classes of labels.\n        if len(set([lab[0] for lab in idx_labels])) <= 1:\n            return None\n\n        fcs = [fc for _, fc in content_objs]\n        feature_names = vectorizable_features(fcs)\n        dis = dissimilarities(feature_names, fcs)\n\n        phi_dicts, labels = [], []  # lists are in correspondence\n        for coref_value, i, j in idx_labels:\n            # i, j are indices into the list `fcs`\n            labels.append(coref_value)  # either -1 or 1\n            phi_dict = dict([(name, dis[name][i,j]) for name in feature_names])\n            phi_dicts.append(phi_dict)\n\n        vec = dict_vector()\n        training_data = vec.fit_transform(phi_dicts)\n\n        model = LogisticRegression(class_weight='auto', penalty='l1')\n        model.fit(training_data, labels)\n        self.feature_weights = dict([(name, model.coef_[0][i])\n                                     for i, name in enumerate(feature_names)])\n        return feature_names, model, vec", "response": "Trains and returns a sklearn model using sklearn."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef classify(self, feature_names, classifier, transformer, candidates,\n                 query_fc=None):\n        '''Returns ``[probability]`` in correspondence with\n        ``candidates``.\n\n        Where each ``probability`` corresponds to the probability that\n        the corresponding candidate is classified with a positive label\n        given the training data.\n\n        The list returned is in correspondence with the list of\n        candidates given.\n\n        N.B. The contract of this method should be simplified by\n        bundling ``feature_names``, ``classifier`` and ``transformer``\n        into one thing known as \"the model.\" ---AG\n        '''\n        if query_fc is None:\n            query_fc = self.query_fc\n        dis = {}\n        for name in feature_names:\n            vec = dict_vector()\n            query = vec.fit_transform([get_feat(query_fc, name)])\n            cans = vec.transform(get_feat(fc, name) for _, fc in candidates)\n            dis[name] = 1 - pairwise_distances(\n                cans, query, metric='cosine', n_jobs=1)[:,0]\n\n        # in correspondence with `candidates`\n        phi_dicts = transformer.transform(\n            [dict([(name, dis[name][i]) for name in feature_names])\n             for i in xrange(len(candidates))])\n        return classifier.predict_proba(phi_dicts)[:,1]", "response": "Classifies the given features with the given classifier and the given list of candidates."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of content objects from a list of labels.", "response": "def content_objs_from_labels(self, labels):\n        '''[Label] -> [(content_id, FeatureCollection)]'''\n        is_mapping = lambda obj: isinstance(obj, collections.Mapping)\n        def is_valid_fc((cid, fc)):\n            if fc is None:\n                return False\n            if sum(1 for name in fc if is_mapping(fc[name])) == 0:\n                return False\n            return True\n\n        ids = set()\n        for lab in labels:\n            ids.add(lab.content_id1)\n            ids.add(lab.content_id2)\n        return list(ifilter(is_valid_fc, self.store.get_many(ids)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates a bag of lists of unnormalized tokens representing noun phrases from text.", "response": "def noun_phrases_as_tokens(text):\n    '''Generate a bag of lists of unnormalized tokens representing noun\n    phrases from ``text``.\n\n    This is built around python's nltk library for getting Noun\n    Phrases (NPs). This is all documented in the NLTK Book\n    http://www.nltk.org/book/ch03.html and blog posts that cite the\n    book.\n\n    :rtype: list of lists of strings\n\n    '''\n    ## from NLTK Book:\n    sentence_re = r'''(?x)      # set flag to allow verbose regexps\n          ([A-Z])(\\.[A-Z])+\\.?  # abbreviations, e.g. U.S.A.\n        | \\w+(-\\w+)*            # words with optional internal hyphens\n        | \\$?\\d+(\\.\\d+)?%?      # currency and percentages, e.g. $12.40, 82%\n        | \\.\\.\\.                # ellipsis\n        | [][.,;\"'?():-_`]      # these are separate tokens\n    '''\n\n    ## From Su Nam Kim paper:\n    ## http://www.comp.nus.edu.sg/~kanmy/papers/10.1007_s10579-012-9210-3.pdf\n    grammar = r'''\n        NBAR:\n            {<NN.*|JJ>*<NN.*>}  # Nouns and Adjectives, terminated with Nouns\n\n        NP:\n            {<NBAR>}\n            {<NBAR><IN><NBAR>}  # Above, connected with in/of/etc...\n    '''\n    if len(text.strip()) == 0:\n        return []\n\n    chunker = nltk.RegexpParser(grammar)\n\n    toks = nltk.regexp_tokenize(text, sentence_re)\n    postoks = nltk.tag.pos_tag(toks)\n\n    #print postoks\n    tree = chunker.parse(postoks)\n    stops = stopwords.words('english')\n    stops += dossier_stopwords()\n\n    ## These next four functions are standard uses of NLTK illustrated by\n    ## http://alexbowe.com/au-naturale/\n    ## https://gist.github.com/alexbowe/879414\n    def leaves(tree):\n        '''Finds NP (nounphrase) leaf nodes of a chunk tree.'''\n        for subtree in tree.subtrees(filter = lambda t: t.label()=='NP'):\n            yield subtree.leaves()\n\n    def acceptable_word(word):\n        '''Checks conditions for acceptable word: length, stopword.'''\n        return 2 <= len(word) <= 40 and word.lower() not in stops\n\n    def get_terms(tree):\n        for leaf in leaves(tree):\n            yield [w for w,t in leaf if acceptable_word(w)]\n\n    return list(get_terms(tree))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef noun_phrases(text, included_unnormalized=False):\n    '''applies normalization to the terms found by noun_phrases_as_tokens\n    and joins on '_'.\n\n    :rtype: list of phrase strings with spaces replaced by ``_``.\n\n    '''\n    lemmatizer = nltk.WordNetLemmatizer()\n    stemmer = nltk.stem.porter.PorterStemmer()\n\n    def normalize(word):\n        '''Normalises words to lowercase and stems and lemmatizes it.'''\n        word = word.lower()\n        try:\n            word = stemmer.stem_word(word)\n            word = lemmatizer.lemmatize(word)\n        except:\n            pass\n        return word\n\n    normalizations = defaultdict(list)\n    for terms in noun_phrases_as_tokens(text):\n        key = u'_'.join(map(normalize, terms))\n        normalizations[key].append(u' '.join(terms))\n\n    if included_unnormalized:\n        return normalizations.keys(), normalizations\n    else:\n        return normalizations.keys()", "response": "applies normalization to the terms found by noun_phrases_as_tokens\n    and joins on _."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _makeCertificate(key, email, _utcnow=datetime.utcnow):\n    # Create a certificate for this key.\n    cert = X509()\n    cert.set_pubkey(key)\n\n    # Set the subject.\n    subject = cert.get_subject()\n    subject.CN = u\"Crypto 101 Client\"\n    subject.emailAddress = email\n\n    # Expiration dates. Mandatory.\n    now = _utcnow()\n    start = now.replace(hour=0, minute=0, second=0)\n    cert.set_notBefore(start.strftime(_ASN1_GENERALIZEDTIME_FORMAT))\n    end = start.replace(year=start.year + 5)\n    cert.set_notAfter(end.strftime(_ASN1_GENERALIZEDTIME_FORMAT))\n\n    # Self-sign.\n    cert.set_issuer(cert.get_subject())\n    cert.sign(key, \"sha512\")\n\n    return cert", "response": "Create a certificate for the client using the given key and email."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef makeCredentials(path, email):\n    key = _generateKey()\n    cert = _makeCertificate(key, email)\n\n    certPath = path.child(\"client.pem\")\n    certPath.alwaysCreate = True\n\n    with certPath.open(\"wb\") as pemFile:\n        pemFile.write(dump_privatekey(FILETYPE_PEM, key))\n        pemFile.write(dump_certificate(FILETYPE_PEM, cert))", "response": "Make credentials for the client from given e - mail address and store them in the directory at path."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getContextFactory(path):\n    with path.child(\"client.pem\").open() as pemFile:\n        cert = PrivateCertificate.loadPEM(pemFile.read())\n\n    certOptions = cert.options() # TODO: verify server cert (see #1)\n    certOptions.method = SSL.SSLv23_METHOD\n    ctxFactory = SecureCiphersContextFactory(certOptions)\n    return ctxFactory", "response": "Get a context factory for the client from keys already stored at\n    path. Raises IOError if the credentials didn t exist at\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef schedule(demand: dict, alterations: set, looped: set=None, altered: set=None):\n\tif looped is not None and len(demand) != len(looped):\n\t\tfor func in looped: del demand[func]\n\tif keep_temp in demand:\n\t\tdemand.pop(increase_temp, None)\n\t\tdemand.pop(lower_temp, None)\n\telif lower_temp in demand:\n\t\tdemand.pop(increase_temp, None)\n\treturn demand, alterations", "response": "Prioritizes Triggers called from outside."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef d(msg, *args, **kwargs):\n\n    '''\n    log a message at debug level;\n    '''\n\n    return logging.log(DEBUG, msg, *args, **kwargs)", "response": "log a message at debug level"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef v(msg, *args, **kwargs):\n\n    '''\n    log a message at verbose level;\n    '''\n\n    return logging.log(VERBOSE, msg, *args, **kwargs)", "response": "log a message at verbose level"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef i(msg, *args, **kwargs):\n\n    '''\n    log a message at info level;\n    '''\n\n    return logging.log(INFO, msg, *args, **kwargs)", "response": "log a message at info level"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlogging a message at error level", "response": "def e(msg, *args, **kwargs):\n\n    '''\n    log a message at error level;\n    '''\n\n    return logging.log(ERROR, msg, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndoes a rollover; in this case, a date/time stamp is appended to the filename when the rollover happens. However, you want the file to be named for the start of the interval, not the current time. If there is a backup count, then we have to get a list of matching filenames, sort them and remove the one with the oldest suffix.", "response": "def doRollover(self):\n        \"\"\"\n        do a rollover; in this case, a date/time stamp is appended to the filename\n        when the rollover happens.  However, you want the file to be named for the\n        start of the interval, not the current time.  If there is a backup count,\n        then we have to get a list of matching filenames, sort them and remove\n        the one with the oldest suffix.\n        \"\"\"\n        self.stream.close()\n        # get the time that this sequence started at and make it a TimeTuple\n        t = self.rolloverAt - self.interval\n        timeTuple = time.localtime(t)\n        dfn = self.baseFilename + \".\" + time.strftime(self.suffix, timeTuple)\n        if os.path.exists(dfn):\n            os.remove(dfn)\n        os.rename(self.baseFilename, dfn)\n        if self.backupCount > 0:\n            # find the oldest log file and delete it\n            s = glob.glob(self.baseFilename + \".20*\")\n            if len(s) > self.backupCount:\n                s.sort()\n                os.remove(s[0])\n        #print \"%s -> %s\" % (self.baseFilename, dfn)\n        if self.encoding:\n            self.stream = codecs.open(self.baseFilename, 'w', self.encoding)\n        else:\n            self.stream = open(self.baseFilename, 'w')\n        self.rolloverAt = self.rolloverAt + self.interval\n        if os.path.exists(dfn + \".zip\"):\n            os.remove(dfn + \".zip\")\n        file = zipfile.ZipFile(dfn + \".zip\", \"w\")\n        file.write(dfn, os.path.basename(dfn), zipfile.ZIP_DEFLATED)\n        file.close()\n        os.remove(dfn)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_instances(configuration):\n    instances = {}\n    for methods in configuration.itervalues():\n        for element in methods.itervalues():\n            if not isinstance(element, tuple):\n                continue\n            cls, _ = element\n            if cls not in instances:\n                instances[cls] = cls()\n    return instances", "response": "Create necessary class instances from a configuration dict."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef route(self, data):\n        if isinstance(data, (dict, list)):\n            requests = data\n        else:\n            requests = json.loads(data)\n        if not isinstance(requests, list):\n            requests = [requests]\n        responses = []\n        for request in requests:\n            responses.append(self.call(request))\n        if len(responses) == 1:\n            return json.dumps(responses[0])\n        return json.dumps(responses)", "response": "Route an Ext Direct request to the appropriate function and provide the response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef call(self, request):\n        result = None\n        try:\n            if 'extAction' in request:  # DirectSubmit method\n                tid = request['extTID']\n                action = request['extAction']\n                method = request['extMethod']\n            else:\n                tid = request['tid']\n                action = request['action']\n                method = request['method']\n            element = self.configuration[action][method]\n            if isinstance(element, tuple):  # class level function\n                func = getattr(self.instances[element[0]], element[1])\n            else:  # module level function\n                func = element\n            if func.exposed_kind == BASIC:  # basic method\n                args = request['data'] or []\n                result = func(*args)\n            elif func.exposed_kind == LOAD:  # DirectLoad method\n                args = request['data'] or []\n                result = {'success': True, 'data': func(*args)}\n            elif func.exposed_kind == SUBMIT:  # DirectSubmit method\n                kwargs = request\n                for k in ['extAction', 'extMethod', 'extType', 'extTID', 'extUpload']:\n                    if k in kwargs:\n                        del kwargs[k]\n                try:\n                    func(**kwargs)\n                    result = {'success': True}\n                except FormError as e:\n                    result = e.extra\n                    result['success'] = False\n                    if e.errors:\n                        result['errors'] = e.errors\n            elif func.exposed_kind == STORE_READ:  # DirectStore read method\n                kwargs = request['data'] or {}\n                data = func(**kwargs)\n                result = {'total': len(data), 'data': data}\n            elif func.exposed_kind == STORE_CUD:  # DirectStore create-update-destroy methods\n                kwargs = request['data'][0] or {}\n                try:\n                    result = {'success': True, 'data': func(**kwargs)}\n                except Error:\n                    result = {'success': False}\n        except Exception as e:\n            if self.debug:\n                return {'type': 'exception', 'message': str(e), 'where': '%s.%s' % (action, method)}\n        return {'type': 'rpc', 'tid': tid, 'action': action, 'method': method, 'result': result}", "response": "Calls the appropriate function in the appropriate order."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef app_data(self, org_name, prod_name):\r\n\r\n        ''' a method to retrieve the os appropriate path to user app data\r\n\r\n        # https://www.chromium.org/user-experience/user-data-directory\r\n\r\n        :param org_name: string with name of product/service creator\r\n        :param prod_name: string with name of product/service\r\n        :return: string with path to app data\r\n        '''\r\n\r\n        __name__ = '%s.app_data' % self.__class__.__name__\r\n\r\n    # validate inputs\r\n        org_name = self.fields.validate(org_name, '.org_name')\r\n        prod_name = self.fields.validate(prod_name, '.prod_name')\r\n\r\n    # construct empty fields\r\n        data_path = ''\r\n\r\n    # construct path from os\r\n        if self.os.sysname == 'Windows':\r\n            from re import compile\r\n            xp_pattern = compile('^C:\\\\Documents and Settings')\r\n            app_data = ''\r\n            if os.environ.get('APPDATA'):\r\n                app_data = os.environ.get('APPDATA')\r\n            if xp_pattern.findall(app_data):\r\n                data_path = '%s\\\\Local Settings\\\\Application Data\\\\%s\\\\%s' % (self.home, org_name, prod_name)\r\n            else:\r\n                data_path = '%s\\\\AppData\\\\Local\\\\%s\\\\%s' % (self.home, org_name, prod_name)\r\n\r\n        elif self.os.sysname == 'Darwin':\r\n            data_path = '%s/Library/Application Support/%s/%s/' % (self.home, org_name, prod_name)\r\n\r\n        elif self.os.sysname in ('Linux', 'FreeBSD', 'Solaris'):\r\n            org_format = org_name.replace(' ','-').lower()\r\n            prod_format = prod_name.replace(' ', '-').lower()\r\n            data_path = '%s/.config/%s-%s/' % (self.home, org_format, prod_format)\r\n\r\n        return data_path", "response": "a method to retrieve the os appropriate path to user app data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef metadata(self, file_path):\r\n\r\n        ''' a method to retrieve the metadata of a file on the localhost\r\n\r\n        :param file_path: string with path to file\r\n        :return: dictionary with file properties\r\n        '''\r\n\r\n        __name__ = '%s.metadata(...)' % self.__class__.__name__\r\n\r\n    # validate input\r\n        self.fields.validate(file_path, '.file_path')\r\n        file_exists = False\r\n        if os.path.exists(file_path):\r\n            if os.path.isfile(file_path):\r\n                file_exists = True\r\n        if not file_exists:\r\n            err_msg = __name__.replace('...', 'file_path=%s' % file_path)\r\n            raise ValueError('%s must be a valid file.' % err_msg)\r\n\r\n    # construct metadata dictionary\r\n        abs_path = os.path.abspath(file_path)\r\n        file_stats = os.stat(file_path)\r\n        file_metadata = {\r\n            'path_segments': abs_path.split(os.sep),\r\n            'file_name': os.path.split(abs_path)[1],\r\n            'file_path': abs_path,\r\n            'file_size': file_stats.st_size,\r\n            'create_date': file_stats.st_ctime,\r\n            'update_date': file_stats.st_mtime,\r\n            'access_date': file_stats.st_atime\r\n        }\r\n\r\n        return file_metadata", "response": "a method to retrieve the metadata of a file on the localhost\r\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef conditional_filter(self, metadata_filters):\r\n\r\n        ''' a method to construct a conditional filter function for the list method\r\n\r\n        :param metadata_filters: list with query criteria dictionaries\r\n        :return: filter_function object\r\n\r\n            NOTE:   query criteria architecture\r\n\r\n                    each item in the metadata filters list must be a dictionary\r\n                    which is composed of one or more key names which represent the\r\n                    dotpath to a metadata element of the record to be queried with a\r\n                    key value that is a dictionary of conditional operators used to\r\n                    test the value in the corresponding metadata field of the record.\r\n\r\n                    eg. path_filters = [ { '.file_name': { 'must_contain': [ '^lab' ] } } ]\r\n\r\n                    this example filter looks in the file tree that is walked for a\r\n                    file which starts with the characters 'lab'. as a result, it will\r\n                    match both the following:\r\n                        log/unittests/test/20160912/lab.json\r\n                        laboratory20160912.json\r\n\r\n            NOTE:   the filter method uses a query filters list structure to represent\r\n                    the disjunctive normal form of a logical expression. a record is\r\n                    added to the results list if any query criteria dictionary in the\r\n                    list evaluates to true. within each query criteria dictionary, all\r\n                    declared conditional operators must evaluate to true.\r\n\r\n                    in this way, the metadata_filters represents a boolean OR operator and\r\n                    each criteria dictionary inside the list represents a boolean AND\r\n                    operator between all keys in the dictionary.\r\n\r\n            NOTE:   each query_criteria uses the architecture of query declaration in\r\n                    the jsonModel.query method\r\n\r\n            query_criteria = {\r\n                '.file_name': {},\r\n                '.file_path': {},\r\n                '.file_size': {},\r\n                '.create_date': {},\r\n                '.update_date': {},\r\n                '.access_date': {}\r\n            }\r\n\r\n            conditional operators for '.file_name' and '.file_path' fields:\r\n                \"byte_data\": false,\r\n                \"discrete_values\": [ \"\" ],\r\n                \"excluded_values\": [ \"\" ],\r\n                \"greater_than\": \"\",\r\n                \"less_than\": \"\",\r\n                \"max_length\": 0,\r\n                \"max_value\": \"\",\r\n                \"min_length\": 0,\r\n                \"min_value\": \"\",\r\n                \"must_contain\": [ \"\" ],\r\n                \"must_not_contain\": [ \"\" ],\r\n                \"contains_either\": [ \"\" ]\r\n\r\n            conditional operators for '.file_size', '.create_date', '.update_date', '.access_date':\r\n                \"discrete_values\": [ 0.0 ],\r\n                \"excluded_values\": [ 0.0 ],\r\n                \"greater_than\": 0.0,\r\n                \"integer_data\": false,\r\n                \"less_than\": 0.0,\r\n                \"max_value\": 0.0,\r\n                \"min_value\": 0.0\r\n        '''\r\n\r\n    # validate input\r\n        self.fields.validate(metadata_filters, '.metadata_filters')\r\n\r\n    # construct function called by list function\r\n        def query_function(**kwargs):\r\n            file_metadata = {}\r\n            for key, value in kwargs.items():\r\n                if key in self.file_model.schema.keys():\r\n                    file_metadata[key] = value\r\n            for query_criteria in metadata_filters:\r\n                if self.file_model.query(query_criteria, file_metadata):\r\n                    return True\r\n            return False\r\n\r\n        return query_function", "response": "a method to construct a conditional filter function for the list of metadata elements that are specified in the metadata_filters parameter."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list(self, filter_function=None, list_root='', max_results=1, reverse_order=False, previous_file=''):\r\n\r\n        ''' a method to list files on localhost from walk of directories\r\n\r\n        :param filter_function: (keyword arguments) function used to filter results\r\n        :param list_root: string with localhost path from which to root list of files\r\n        :param max_results: integer with maximum number of results to return\r\n        :param reverse_order: boolean to determine alphabetical direction of walk\r\n        :param previous_file: string with absolute path of file to begin search after\r\n        :return: list of file absolute path strings\r\n\r\n            NOTE:   the filter_function must be able to accept keyword arguments and\r\n                    return a value that can evaluate to true or false. while walking\r\n                    the local file structure, the metadata for each file will be\r\n                    fed to the filter function. if the function evaluates this input\r\n                    and returns a true value the file will be included in the list\r\n                    results.\r\n\r\n                    fields produced by the metadata function are listed in the\r\n                    self.file_model.schema\r\n        '''\r\n\r\n        __name__ = '%s.list(...)' % self.__class__.__name__\r\n\r\n    # validate input\r\n        input_kwargs = [list_root, max_results, previous_file]\r\n        input_names = ['.list_root', '.max_results', '.previous_file']\r\n        for i in range(len(input_kwargs)):\r\n            if input_kwargs[i]:\r\n                self.fields.validate(input_kwargs[i], input_names[i])\r\n\r\n    # validate filter function\r\n        if filter_function:\r\n            try:\r\n                filter_function(**self.file_model.schema)\r\n            except:\r\n                err_msg = __name__.replace('...', 'filter_function=%s' % filter_function.__class__.__name__)\r\n                raise TypeError('%s must accept key word arguments.' % err_msg)\r\n\r\n    # validate that previous file exists\r\n        file_exists = False\r\n        if previous_file:\r\n            if os.path.exists(previous_file):\r\n                if os.path.isfile(previous_file):\r\n                    file_exists = True\r\n            if not file_exists:\r\n                err_msg = __name__.replace('...', 'previous_file=\"%s\"' % previous_file)\r\n                raise ValueError('%s must be a valid file.' % err_msg)\r\n\r\n    # construct empty results object\r\n        results_list = []\r\n\r\n    # determine root for walk\r\n        if list_root:\r\n            if not os.path.isdir(list_root):\r\n                return results_list\r\n        else:\r\n            list_root = './'\r\n\r\n    # walk directory structure to find files\r\n        for file_path in self.walk(list_root, reverse_order, previous_file):\r\n            if filter_function:\r\n                file_metadata = self.metadata(file_path)\r\n                if filter_function(**file_metadata):\r\n                    results_list.append(file_path)\r\n            else:\r\n                results_list.append(file_path)\r\n\r\n    # return results list\r\n            if len(results_list) == max_results:\r\n                return results_list\r\n\r\n        return results_list", "response": "a method to list files on localhost from walk of directories\r\n\r\n Gas"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef encode_instruction(self, pc, instr):\n        data = instr.split()\n        operation = data[0]\n\n        try:\n            mips_op_info = MIPS.operations[operation]\n        except KeyError, e:\n            raise RuntimeError('Unknown operation: {}'.format(operation))\n\n        # Grab the parsing info from the assembler operations table\n        # Generate the initial operand map using the specified tokenizer\n        parse_info = self.operations[operation]\n        encoding_map = parse_info.tokenizer(parse_info.tokens, ''.join(data[1:]))\n\n        # Get the binary equivalents of the operands and MIPS operation information\n        self.resolve_operands(encoding_map, operation, pc)\n\n        # Pull MIPS operation info into encoding map\n        self.resolve_operation_info(encoding_map, mips_op_info)\n\n        instruction = self.mips.generate_instruction(mips_op_info.format)\n        return instruction.encode(encoding_map)", "response": "Given an instruction string generate the encoded bit string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef resolve_operation_info(self, encoding_map, mips_op_info):\n        encoding_map['opcode'] = mips_op_info.opcode\n        encoding_map['funct'] = mips_op_info.funct", "response": "Resolves the operation info into the encoding map."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef resolve_operands(self, encoding_map, operation, pc):\n        convert = Encoder.to_binary\n        branch_replace = False\n        jump_replace = False\n\n        for operand, value in encoding_map.iteritems():\n            if (operand == 'rs' or operand == 'rt' or operand == 'rd'):\n                encoding_map[operand] = MIPS.registers[value]\n\n            elif (operand == 'imm'):\n                encoding_map[operand] = convert(int(value), MIPS.IMMEDIATE_SIZE)\n\n            elif (operand == 'addr'):\n                encoding_map[operand] = convert(int(value), MIPS.ADDRESS_SIZE)\n\n            elif (operand == 'shamt'):\n                encoding_map[operand] = convert(int(value), MIPS.SHAMT_SIZE)\n\n            elif (operand == 'label'):\n                label = encoding_map[operand]\n                hit, index = self.label_cache.query(label)\n\n                if not hit:\n                    raise RuntimeError('No address found for label: {}'.format(label))\n\n                if ((operation == 'beq') or (operation == 'bne')):\n                    # Calculate the relative instruction offset. The MIPS ISA uses\n                    # PC + 4 + (branch offset) to resolve branch targets.\n                    if index > pc:\n                        encoding_map[operand] = convert(index - pc - 1, MIPS.IMMEDIATE_SIZE)\n                    elif index < pc:\n                        encoding_map[operand] = convert((pc + 1) - index, MIPS.IMMEDIATE_SIZE)\n                    else:\n                        # Not sure why a branch would resolve to itself, but ok\n                        # (PC + 4) - 4 = \n                        encoding_map[operand] = convert(-1, MIPS.IMMEDIATE_SIZE)\n\n                    branch_replace = True\n\n                elif ((operation == 'j') or (operation == 'jal')):\n                    # Jump addresses are absolute\n                    encoding_map[operand] = convert(index, MIPS.ADDRESS_SIZE)\n                    jump_replace = True\n\n        # Need to convert references to 'label' back to references the instruction\n        # encoding string recognizes, otherwise we end up with the default value (zero)\n        # This doesn't feel very clean, but working on a fix.\n        if branch_replace:\n            encoding_map['imm'] = encoding_map['label']\n        elif jump_replace:\n            encoding_map['addr'] = encoding_map['label']", "response": "Resolves the operands of the given operation to their binary equivalents."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_binary(decimal, length):\n        b = bitstring.Bits(int=decimal, length=length)\n        return b.bin", "response": "Given a decimal number generate the binary equivalent string of\n        given length."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves relative path symobls such as '..' and..", "response": "def remove_pardir_symbols(path, sep=os.sep, pardir=os.pardir):\n    \"\"\"\n    Remove relative path symobls such as '..'\n\n    Args:\n        path (str): A target path string\n        sep (str): A strint to refer path delimiter (Default: `os.sep`)\n        pardir (str): A string to refer parent directory (Default: `os.pardir`)\n\n    Returns:\n        str\n    \"\"\"\n    bits = path.split(sep)\n    bits = (x for x in bits if x != pardir)\n    return sep.join(bits)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreplace dots with underscores at the end of a path.", "response": "def replace_dots_to_underscores_at_last(path):\n    \"\"\"\n    Remove dot ('.') while a dot is treated as a special character in backends\n\n    Args:\n        path (str): A target path string\n\n    Returns:\n        str\n    \"\"\"\n    if path == '':\n        return path\n    bits = path.split('/')\n    bits[-1] = bits[-1].replace('.', '_')\n    return '/'.join(bits)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _load(root):\n    types = _load_types(root)\n    enums = _load_enums(root)\n    commands = _load_commands(root)\n    features = _load_features(root)\n    extensions = _load_extensions(root)\n    return Registry(None, types, enums, commands, features, extensions)", "response": "Load from an xml. etree. ElementTree"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _load_types(root):\n    def text(t):\n        if t.tag == 'name':\n            return '{name}'\n        elif t.tag == 'apientry':\n            return '{apientry}'\n        out = []\n        if t.text:\n            out.append(_escape_tpl_str(t.text))\n        for x in t:\n            out.append(text(x))\n            if x.tail:\n                out.append(_escape_tpl_str(x.tail))\n        return ''.join(out)\n    out_dict = collections.OrderedDict()\n    for elem in root.findall('types/type'):\n        name = elem.get('name') or elem.find('name').text\n        template = text(elem)\n        api = elem.get('api')\n        if 'requires' in elem.attrib:\n            required_types = set((elem.attrib['requires'],))\n        else:\n            required_types = set()\n        comment = elem.get('comment')\n        if api:\n            k = (name, api)\n        else:\n            k = (name, None)\n        out_dict[k] = Type(name, template, required_types, api, comment)\n    return out_dict", "response": "Loads the types from the xml tree root."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _load_enums(root):\n    out = collections.OrderedDict()\n    for elem in root.findall('enums/enum'):\n        name = elem.attrib['name']\n        value = elem.attrib['value']\n        comment = elem.get('comment')\n        out[name] = Enum(name, value, comment)\n    return out", "response": "Load all the enums from the XML tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads all commands from the XML tree root.", "response": "def _load_commands(root):\n    \"\"\"Returns {name: Command}\"\"\"\n    def proto_text(t):\n        if t.tag == 'name':\n            return '{name}'\n        elif t.tag == 'ptype':\n            return '{type}'\n        out = []\n        if t.text:\n            out.append(_escape_tpl_str(t.text))\n        for x in t:\n            out.append(proto_text(x))\n            if x.tail:\n                out.append(_escape_tpl_str(x.tail))\n        return ''.join(out)\n    out = collections.OrderedDict()\n    for elem in root.findall('commands/command'):\n        type_elem = elem.find('proto/ptype')\n        name = elem.get('name') or elem.find('proto/name').text\n        type = type_elem.text if type_elem is not None else None\n        proto_template = proto_text(elem.find('proto'))\n        params = [_load_param(x) for x in elem.findall('param')]\n        comment = elem.get('comment')\n        out[name] = Command(name, type, proto_template, params, comment)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload all features from the XML tree root.", "response": "def _load_features(root):\n    \"\"\"Returns {name: Feature}\"\"\"\n    out = collections.OrderedDict()\n    for elem in root.findall('feature'):\n        name = elem.attrib['name']\n        api = elem.attrib['api']\n        number = tuple([int(x) for x in elem.attrib['number'].split('.')])\n        requires = [_load_require(x) for x in elem.findall('require')]\n        removes = [_load_remove(x) for x in elem.findall('remove')]\n        comment = elem.get('comment')\n        out[name] = Feature(name, api, number, requires, removes, comment)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads all extensions from the root.", "response": "def _load_extensions(root):\n    \"\"\"Returns {name: Extension}\"\"\"\n    out = collections.OrderedDict()\n    for elem in root.findall('extensions/extension'):\n        name = elem.attrib['name']\n        supported = set(elem.attrib['supported'].split('|'))\n        requires = [_load_require(x) for x in elem.findall('require')]\n        comment = elem.get('comment')\n        out[name] = Extension(name, supported, requires, comment)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef import_type(dest, src, name, api=None, filter_symbol=None):\n    if not filter_symbol:\n        filter_symbol = _default_filter_symbol\n    type = src.get_type(name, api)\n    for x in type.required_types:\n        if not filter_symbol('type', x):\n            continue\n        import_type(dest, src, x, api, filter_symbol)\n    dest.types[(type.name, type.api)] = type", "response": "Imports a type from src to dest."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nimporting a command from src to dest", "response": "def import_command(dest, src, name, api=None, filter_symbol=None):\n    \"\"\"Import Command `name` and its dependencies from Registry `src`\n    to Registry `dest`\n\n    :param Registry dest: Destination Registry\n    :param Registry src: Source Registry\n    :param str name: Name of Command to import\n    :param str api: Prefer to import Types with api name `api`, or None to\n                    import Types with no api name\n    :param filter_symbol: Optional filter callable\n    :type filter_symbol: Callable with signature\n                         ``(symbol_type:str, symbol_name:str) -> bool``\n    \"\"\"\n    if not filter_symbol:\n        filter_symbol = _default_filter_symbol\n    cmd = src.commands[name]\n    for x in cmd.required_types:\n        if not filter_symbol('type', x):\n            continue\n        import_type(dest, src, x, api, filter_symbol)\n    dest.commands[name] = cmd"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nimports the given Enum from Registry src to Registry dest.", "response": "def import_enum(dest, src, name):\n    \"\"\"Import Enum `name` from Registry `src` to Registry `dest`.\n\n    :param Registry dest: Destination Registry\n    :param Registry src: Source Registry\n    :param str name: Name of Enum to import\n    \"\"\"\n    dest.enums[name] = src.enums[name]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nimport a feature from src to dest.", "response": "def import_feature(dest, src, name, api=None, profile=None,\n                   filter_symbol=None):\n    \"\"\"Imports Feature `name`, and all its dependencies, from\n    Registry `src` to Registry `dest`.\n\n    :param Registry dest: Destination Registry\n    :param Registry src: Source Registry\n    :param str name: Name of Feature to import\n    :param str api: Prefer to import dependencies with api name `api`,\n                    or None to import dependencies with no API name.\n    :param str profile: Import dependencies with profile name\n                        `profile`, or None to import all dependencies.\n    :param filter_symbol: Optional symbol filter callable\n    :type filter_symbol: Callable with signature\n                         ``(symbol_type:str, symbol_name:str) -> bool``\n    \"\"\"\n    if filter_symbol is None:\n        filter_symbol = _default_filter_symbol\n    ft = src.features[name] if isinstance(name, str) else name\n    # Gather symbols to remove from Feature\n    remove_symbols = set()\n    for x in src.get_removes(api, profile):\n        remove_symbols.update(x.as_symbols())\n\n    def my_filter_symbol(t, name):\n        return False if (t, name) in remove_symbols else filter_symbol(t, name)\n\n    for req in ft.get_requires(profile):\n        for x in req.types:\n            if not my_filter_symbol('type', x):\n                continue\n            import_type(dest, src, x, api, filter_symbol)\n        for x in req.enums:\n            if not my_filter_symbol('enum', x):\n                continue\n            import_enum(dest, src, x)\n        for x in req.commands:\n            if not my_filter_symbol('command', x):\n                continue\n            import_command(dest, src, x, api, filter_symbol)\n    dest.features[name] = ft"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef import_extension(dest, src, name, api=None, profile=None,\n                     filter_symbol=None):\n    \"\"\"Imports Extension `name`, and all its dependencies.\n\n    :param Registry dest: Destination Registry\n    :param Registry src: Source Registry\n    :param str name: Name of Extension to import\n    :param str api: Prefer to import types with API name `api`,\n                or None to prefer Types with no API name.\n    :type api: str\n    :param filter_symbol: Optional symbol filter callable\n    :type filter_symbol: Callable with signature\n                         ``(symbol_type:str, symbol_name:str) -> bool``\n    \"\"\"\n    if filter_symbol is None:\n        filter_symbol = _default_filter_symbol\n    ext = src.extensions[name] if isinstance(name, str) else name\n    for req in ext.get_requires(api, profile):\n        for x in req.types:\n            if not filter_symbol('type', x):\n                continue\n            import_type(dest, src, x, api, filter_symbol)\n        for x in req.enums:\n            if not filter_symbol('enum', x):\n                continue\n            import_enum(dest, src, x)\n        for x in req.commands:\n            if not filter_symbol('command', x):\n                continue\n            import_command(dest, src, x, api, filter_symbol)\n    dest.extensions[name] = ext", "response": "Imports the extension with the given name and all its dependencies."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nimporting all features and extensions and all their dependencies.", "response": "def import_registry(dest, src, api=None, profile=None, support=None,\n                    filter_symbol=None):\n    \"\"\"Imports all features and extensions and all their dependencies.\n\n    :param Registry dest: Destination API\n    :param Registry src: Source Registry\n    :param str api: Only import Features with API name `api`, or None\n                    to import all features.\n    :param str profile: Only import Features with profile name `profile`,\n                        or None to import all features.\n    :param str support: Only import Extensions with this extension support\n                        string, or None to import all extensions.\n    :param filter_symbol: Optional symbol filter callable\n    :type filter_symbol: Callable with signature\n                         ``(symbol_type:str, symbol_name:str) -> bool``\n    \"\"\"\n    if filter_symbol is None:\n        filter_symbol = _default_filter_symbol\n    for x in src.get_features(api):\n        import_feature(dest, src, x.name, api, profile, filter_symbol)\n    for x in src.get_extensions(support):\n        import_extension(dest, src, x.name, api, profile, filter_symbol)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the sorting key for an extension.", "response": "def extension_sort_key(extension):\n    \"\"\"Returns the sorting key for an extension.\n\n    The sorting key can be used to sort a list of extensions\n    into the order that is used in the Khronos C OpenGL headers.\n    :param Extension extension: Extension to produce sort key for\n    :returns: A sorting key\n    \"\"\"\n    name = extension.name\n    category = name.split('_', 2)[1]\n    return (0, name) if category in ('ARB', 'KHR', 'OES') else (1, name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngrouping types enumers commands with their respective Features and Extensions.", "response": "def group_apis(reg, features=None, extensions=None, api=None, profile=None,\n               support=None):\n    \"\"\"Groups Types, Enums, Commands with their respective Features, Extensions\n\n    Similar to :py:func:`import_registry`, but generates a new Registry object\n    for every feature or extension.\n\n    :param Registry reg: Input registry\n    :param features: Feature names to import, or None to import all.\n    :type features: Iterable of strs\n    :param extensions: Extension names to import, or None to import all.\n    :type extensions: Iterable of strs\n    :param str profile: Import features which belong in `profile`, or None\n                        to import all.\n    :param str api: Import features which belong in `api`, or None to\n                    import all.\n    :param str support: Import extensions which belong in this extension\n                        support string, or None to import all.\n    :returns: list of :py:class:`Registry` objects\n    \"\"\"\n    features = (reg.get_features(api) if features is None\n                else [reg.features[x] for x in features])\n    if extensions is None:\n        extensions = sorted(reg.get_extensions(support),\n                            key=extension_sort_key)\n    else:\n        extensions = [reg.extensions[x] for x in extensions]\n    output_symbols = set()\n\n    def filter_symbol(type, name):\n        k = (type, name)\n        if k in output_symbols:\n            return False\n        else:\n            output_symbols.add(k)\n            return True\n\n    out_apis = []\n    for x in features:\n        out = Registry(x.name)\n        import_feature(out, reg, x.name, api, profile, filter_symbol)\n        out_apis.append(out)\n    for x in extensions:\n        out = Registry(x.name)\n        import_extension(out, reg, x.name, api, profile, filter_symbol)\n        out_apis.append(out)\n    return out_apis"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef main(args=None, prog=None):\n    args = args if args is not None else sys.argv[1:]\n    prog = prog if prog is not None else sys.argv[0]\n    # Prevent broken pipe exception from being raised.\n    signal.signal(signal.SIGPIPE, signal.SIG_DFL)\n    stdin = sys.stdin.buffer if hasattr(sys.stdin, 'buffer') else sys.stdin\n    p = argparse.ArgumentParser(prog=prog)\n    p.add_argument('-o', '--output', metavar='PATH',\n                   type=argparse.FileType('w'), default=sys.stdout,\n                   help='Write output to PATH')\n    p.add_argument('--api', help='Match API', default=None)\n    p.add_argument('--profile', help='Match profile', default=None)\n    p.add_argument('--support', default=None,\n                   help='Match extension support string')\n    g = p.add_mutually_exclusive_group()\n    g.add_argument('--list-apis', action='store_true', dest='list_apis',\n                   help='List apis in registry', default=False)\n    g.add_argument('--list-profiles', action='store_true', default=False,\n                   dest='list_profiles', help='List profiles in registry')\n    g.add_argument('--list-supports', action='store_true',\n                   dest='list_supports', default=False,\n                   help='List extension support strings')\n    p.add_argument('registry', type=argparse.FileType('rb'), nargs='?',\n                   default=stdin, help='Registry path')\n    args = p.parse_args(args)\n    o = args.output\n    try:\n        registry = load(args.registry)\n        if args.list_apis:\n            for x in sorted(registry.get_apis()):\n                print(x, file=o)\n            return 0\n        elif args.list_profiles:\n            for x in sorted(registry.get_profiles()):\n                print(x, file=o)\n            return 0\n        elif args.list_supports:\n            for x in sorted(registry.get_supports()):\n                print(x, file=o)\n            return 0\n        apis = group_apis(registry, None, None, args.api, args.profile,\n                          args.support)\n        for api in apis:\n            print('#ifndef', api.name, file=o)\n            print('#define', api.name, file=o)\n            print(api.text, file=o)\n            print('#endif', file=o)\n            print('', file=o)\n    except:\n        e = sys.exc_info()[1]\n        print(prog, ': error: ', e, sep='', file=sys.stderr)\n        return 1\n    return 0", "response": "Generates a C header file from the specified arguments."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef required_types(self):\n        required_types = set(x.type for x in self.params)\n        required_types.add(self.type)\n        required_types.discard(None)\n        return required_types", "response": "Set of names of types which the Command depends on."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nformatting Command identifier. Equivalent to ``self.proto_template.format(type=self.type, name=self.name)``.", "response": "def proto_text(self):\n        \"\"\"Formatted Command identifier.\n\n        Equivalent to ``self.proto_template.format(type=self.type,\n        name=self.name)``.\n        \"\"\"\n        return self.proto_template.format(type=self.type, name=self.name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nformats Command declaration. This is the C declaration for the command.", "response": "def text(self):\n        \"\"\"Formatted Command declaration.\n\n        This is the C declaration for the command.\n        \"\"\"\n        params = ', '.join(x.text for x in self.params)\n        return '{0} ({1})'.format(self.proto_text, params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nformats param definition Equivalent to self. template. format ( name = self. name type = self. type ).", "response": "def text(self):\n        \"\"\"Formatted param definition\n\n        Equivalent to ``self.template.format(name=self.name, type=self.type)``.\n        \"\"\"\n        return self.template.format(name=self.name, type=self.type)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a set of tuples containing the names of all the symbols required by this Require .", "response": "def as_symbols(self):\n        \"\"\"Set of symbols required by this Require\n\n        :return: set of ``(symbol type, symbol name)`` tuples\n        \"\"\"\n        out = set()\n        for name in self.types:\n            out.add(('type', name))\n        for name in self.enums:\n            out.add(('enum', name))\n        for name in self.commands:\n            out.add(('command', name))\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_profiles(self):\n        out = set(x.profile for x in self.requires if x.profile)\n        out.update(x.profile for x in self.removes if x.profile)\n        return out", "response": "Returns set of profile names referenced in this Feature\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_requires(self, profile=None):\n        out = []\n        for req in self.requires:\n            # Filter Require by profile\n            if ((req.profile and not profile) or\n               (req.profile and profile and req.profile != profile)):\n                continue\n            out.append(req)\n        return out", "response": "Get filtered list of Require objects in this Feature\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a list of Remove objects in this Feature", "response": "def get_removes(self, profile=None):\n        \"\"\"Get filtered list of Remove objects in this Feature\n\n        :param str profile: Return Remove objects with this profile or None\n                            to return all Remove objects.\n        :return: list of Remove objects\n        \"\"\"\n        out = []\n        for rem in self.removes:\n            # Filter Remove by profile\n            if ((rem.profile and not profile) or\n               (rem.profile and profile and rem.profile != profile)):\n                continue\n            out.append(rem)\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_apis(self):\n        out = set()\n        out.update(x.api for x in self.requires if x.api)\n        return out", "response": "Returns set of api names referenced in this Extension\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_profiles(self):\n        return set(x.profile for x in self.requires if x.profile)", "response": "Returns set of profile names referenced in this Extension\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_requires(self, api=None, profile=None):\n        out = []\n        for req in self.requires:\n            # Filter Remove by API\n            if (req.api and not api) or (req.api and api and req.api != api):\n                continue\n            # Filter Remove by profile\n            if ((req.profile and not profile) or\n               (req.profile and profile and req.profile != profile)):\n                continue\n            out.append(req)\n        return out", "response": "Return a list of Require objects in this Extension."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef text(self):\n        out = []\n        out.extend(x.text for x in self.types.values())\n        out.extend(x.text for x in self.enums.values())\n        out.extend('extern {0};'.format(x.text)\n                   for x in self.commands.values())\n        return '\\n'.join(out)", "response": "Formatted API declarations.\n\n        Equivalent to the concatenation of `text` attributes of\n        types, enums and commands in this Registry."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_type(self, name, api=None):\n        k = (name, api)\n        if k in self.types:\n            return self.types[k]\n        else:\n            return self.types[(name, None)]", "response": "Returns the object of the type with preference for the Type of api."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn filtered list of features in this registry", "response": "def get_features(self, api=None):\n        \"\"\"Returns filtered list of features in this registry\n\n        :param str api: Return only features with this api name, or None to\n                        return all features.\n        :return: list of Feature objects\n        \"\"\"\n        return [x for x in self.features.values()\n                if api and x.api == api or not api]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_extensions(self, support=None):\n        return [x for x in self.extensions.values() if support\n                and support in x.supported or not support]", "response": "Returns a list of extensions in this registry with the given support string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of Require objects in this registry.", "response": "def get_requires(self, api=None, profile=None, support=None):\n        \"\"\"Returns filtered list of Require objects in this registry\n\n        :param str api: Return Require objects with this api name or None to\n                        return all Require objects.\n        :param str profile: Return Require objects with this profile or None\n                            to return all Require objects.\n        :param str support: Return Require objects with this extension support\n                            string or None to return all Require objects.\n        :return: list of Require objects\n        \"\"\"\n        out = []\n        for ft in self.get_features(api):\n            out.extend(ft.get_requires(profile))\n        for ext in self.extensions.values():\n            # Filter extension support\n            if support and support not in ext.supported:\n                continue\n            out.extend(ext.get_requires(api, profile))\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_removes(self, api=None, profile=None):\n        out = []\n        for ft in self.get_features(api):\n            out.extend(ft.get_removes(profile))\n        return out", "response": "Returns a list of Remove objects in this registry"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_apis(self):\n        out = set(x.api for x in self.types.values() if x.api)\n        for ft in self.features.values():\n            out.update(ft.get_apis())\n        for ext in self.extensions.values():\n            out.update(ext.get_apis())\n        return out", "response": "Returns set of api names referenced in this Registry\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_profiles(self):\n        out = set()\n        for ft in self.features.values():\n            out.update(ft.get_profiles())\n        for ext in self.extensions.values():\n            out.update(ext.get_profiles())\n        return out", "response": "Returns set of profile names referenced in this Registry\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_supports(self):\n        out = set()\n        for ext in self.extensions.values():\n            out.update(ext.get_supports())\n        return out", "response": "Returns set of extension support strings referenced in this Registry\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads and return a module by name.", "response": "def load_module(self, name):\n        \"\"\"\n        Load and return a module\n\n        Always returns the corresponding module. If the module is already\n        loaded, the existing module is returned.\n        \"\"\"\n        if name in sys.modules:\n            return sys.modules[name]\n        path = self.module2uri(name)\n        if os.path.isfile(path):\n            return self._load_module(name, path)\n        elif os.path.isdir(path):\n            return self._load_package(name, path)\n        else:\n            raise ImportError(\"Missing module source file %r\" % path)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_open_window_names():\n    '''\n    Return a dict with open program names and their corresponding decimal ids\n    '''\n    raw_names = subprocess.check_output(['wmctrl', '-l']).decode('utf8').split('\\n')\n    split_names = [name.split() for name in raw_names if name]\n    name_dict = {}\n    for name in split_names:\n        if not int(name[1]):\n            name_dict[' '.join(name[3:]).lower()] = name[0]\n    return name_dict", "response": "Return a dict with open program names and their corresponding decimal ids\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating an iterator over all the rows in this resource s source data.", "response": "def resource_row_set(package, resource):\n    \"\"\" Generate an iterator over all the rows in this resource's\n    source data. \"\"\"\n    # This is a work-around because messytables hangs on boto file\n    # handles, so we're doing it via plain old HTTP.\n    table_set = any_tableset(resource.fh(),\n                             extension=resource.meta.get('extension'),\n                             mimetype=resource.meta.get('mime_type'))\n    tables = list(table_set.tables)\n    if not len(tables):\n        log.error(\"No tables were found in the source file.\")\n        return\n\n    row_set = tables[0]\n    offset, headers = headers_guess(row_set.sample)\n    row_set.register_processor(headers_processor(headers))\n    row_set.register_processor(offset_processor(offset + 1))\n    types = type_guess(row_set.sample, strict=True)\n    row_set.register_processor(types_processor(types))\n    return row_set"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates a normalized version of the column name.", "response": "def column_alias(cell, names):\n    \"\"\" Generate a normalized version of the column name. \"\"\"\n    column = slugify(cell.column or '', sep='_')\n    column = column.strip('_')\n    column = 'column' if not len(column) else column\n    name, i = column, 2\n    # de-dupe: column, column_2, column_3, ...\n    while name in names:\n        name = '%s_%s' % (name, i)\n        i += 1\n    return name"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a set of metadata for each field and column in the data.", "response": "def generate_field_spec(row):\n    \"\"\" Generate a set of metadata for each field/column in\n    the data. This is loosely based on jsontableschema. \"\"\"\n    names = set()\n    fields = []\n    for cell in row:\n        name = column_alias(cell, names)\n        field = {\n            'name': name,\n            'title': cell.column,\n            'type': unicode(cell.type).lower(),\n            'has_nulls': False,\n            'has_empty': False,\n            'samples': []\n        }\n        if hasattr(cell.type, 'format'):\n            field['type'] = 'date'\n            field['format'] = cell.type.format\n        fields.append(field)\n    return fields"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncollecting a random sample of the values in a particular field based on the reservoir sampling technique.", "response": "def random_sample(value, field, row, num=10):\n    \"\"\" Collect a random sample of the values in a particular\n    field based on the reservoir sampling technique. \"\"\"\n    # TODO: Could become a more general DQ piece.\n    if value is None:\n        field['has_nulls'] = True\n        return\n    if value in field['samples']:\n        return\n    if isinstance(value, basestring) and not len(value.strip()):\n        field['has_empty'] = True\n        return\n    if len(field['samples']) < num:\n        field['samples'].append(value)\n        return\n    j = random.randint(0, row)\n    if j < (num - 1):\n        field['samples'][j] = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef name(username):\n    if not username:\n        click.secho(dtool_config.utils.get_username(CONFIG_PATH))\n    else:\n        username_str = \" \".join(username)\n        click.secho(dtool_config.utils.set_username(CONFIG_PATH, username_str))", "response": "Display or update the user name."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndisplays or update the user email.", "response": "def email(email_address):\n    \"\"\"Display / set / update the user email.\"\"\"\n    if not email_address:\n        click.secho(dtool_config.utils.get_user_email(CONFIG_PATH))\n    else:\n        click.secho(dtool_config.utils.set_user_email(\n            CONFIG_PATH,\n            email_address\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef readme_template(readme_template_file):\n    if not readme_template_file:\n        click.secho(dtool_config.utils.get_readme_template_fpath(\n            CONFIG_PATH,\n        ))\n    else:\n        click.secho(dtool_config.utils.set_readme_template_fpath(\n            CONFIG_PATH,\n            readme_template_file\n        ))", "response": "Display or update the readme template file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndisplays / set the ECS endpoint URL.", "response": "def endpoint(url):\n    \"\"\"Display / set / update the ECS endpoint URL.\"\"\"\n    if not url:\n        click.secho(dtool_config.utils.get_ecs_endpoint(CONFIG_PATH))\n    else:\n        click.secho(dtool_config.utils.set_ecs_endpoint(CONFIG_PATH, url))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisplay or update the ECS access key id.", "response": "def access_key_id(ecs_access_key_id):\n    \"\"\"Display / set / update the ECS access key id.\"\"\"\n    if not ecs_access_key_id:\n        click.secho(dtool_config.utils.get_ecs_access_key_id(CONFIG_PATH))\n    else:\n        click.secho(dtool_config.utils.set_ecs_access_key_id(\n            CONFIG_PATH,\n            ecs_access_key_id\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef secret_access_key(ecs_secret_access_key):\n    if not ecs_secret_access_key:\n        click.secho(dtool_config.utils.get_ecs_secret_access_key(CONFIG_PATH))\n    else:\n        click.secho(dtool_config.utils.set_ecs_secret_access_key(\n            CONFIG_PATH,\n            ecs_secret_access_key\n        ))", "response": "Display or update the ECS secret access key."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cache(cache_directory_path):\n    if not cache_directory_path:\n        click.secho(dtool_config.utils.get_cache(\n            CONFIG_PATH,\n        ))\n    else:\n        click.secho(dtool_config.utils.set_cache(\n            CONFIG_PATH,\n            cache_directory_path\n        ))", "response": "Display or update the dtool cache directory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the Azure storage container s secret access key.", "response": "def set(container, azure_secret_access_key):\n    \"\"\"Set/update the access key for the specified Azure storage container.\"\"\"\n    click.secho(dtool_config.utils.set_azure_secret_access_key(\n        CONFIG_PATH,\n        container,\n        azure_secret_access_key\n    ))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmaking a set of unique n - grams from a string.", "response": "def make_unique_ngrams(s, n):\n    \"\"\"Make a set of unique n-grams from a string.\"\"\"\n    return set(s[i:i + n] for i in range(len(s) - n + 1))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if a string is in the DB.", "response": "def check(self, s, instant_exact=True):\n        \"\"\"Check if a string is in the DB.\n\n        :param s: str, string to check against the DB.\n        :param instant_exact: bool, look up exact matches with a hash lookup.\n        :return: True or False\n        :rtype: bool\n\n        \"\"\"\n        all_sets = self._get_comparison_strings(s)\n        if instant_exact and s in all_sets:  # exact match\n            return True\n\n        for comparison_string in all_sets:\n            if self.comparison_func(s, comparison_string) >= self.cutoff:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving all similar strings from the DB.", "response": "def retrieve(self, s):\n        \"\"\"Retrieve all similar strings from the DB.\n\n        :param s: str, string to check against the DB.\n        :return: list of all similar strings.\n        :rtype: list\n\n        \"\"\"\n        all_sim = []\n        use_max_n = self.max_n is not None\n        for comparison_string in self._get_comparison_strings(s):\n            if self.comparison_func(s, comparison_string) >= self.cutoff:\n                all_sim.append(comparison_string)\n                if use_max_n and len(all_sim) >= self.max_n:\n                    return all_sim\n        return all_sim"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve all similar strings from the DB.", "response": "def retrieve_with_score(self, s):\n        \"\"\"Retrieve all similar strings from the DB.\n\n        :param s: str, string to check against the DB.\n        :return: list of tuples - [(simlar_string, score)].\n                 Empty list if not found.\n        :rtype: list\n\n        \"\"\"\n        all_sim = []\n        use_max_n = self.max_n is not None\n        for comparison_string in self._get_comparison_strings(s):\n            score = self.comparison_func(s, comparison_string)\n            if score >= self.cutoff:\n                all_sim.append((comparison_string, score))\n                if use_max_n and len(all_sim) >= self.max_n:\n                    return all_sim\n        return all_sim"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninsert the given sequence of strings into the internal database.", "response": "def insert(self, seq):\n        \"\"\"\n        Populates the DB from a sequence of strings, ERASING PREVIOUS STATE.\n\n        :param seq: an iterable\n\n        \"\"\"\n        # erase previous elements and make defaultdict for easier insertion.\n        self._els_idxed = defaultdict(lambda: defaultdict(set))\n        if type(seq) is str:\n            raise ValueError('Provided argument should be a sequence of strings'\n                             ', but not a string itself.')\n        for el in seq:\n            if type(el) is not str:\n                raise ValueError('Element %s is not a string' % (el,))\n            for gram in make_unique_ngrams(el, self.idx_size):\n                self._els_idxed[gram][len(el)].add(el)\n\n        # convert defaultdict to dict so as to not increase size when checking\n        # for presence of an element\n        self._finalize_db()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _finalize_db(self):\n        for k, v in self._els_idxed.items():\n            self._els_idxed[k] = dict(v)\n        self._els_idxed = dict(self._els_idxed)", "response": "Convert defaultdicts to regular dicts."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_comparison_strings(self, s):\n        str_len = len(s)\n        comparison_idxs = make_unique_ngrams(s, self.idx_size)\n        min_len = len(s) - self.plus_minus\n\n        if min_len < 0:\n            min_len = 0\n\n        if self._els_idxed is None:\n            raise UnintitializedError('Database not created')\n\n        all_sets = set()\n        for idx in comparison_idxs:\n            found_idx = self._els_idxed.get(idx, None)\n            if found_idx is None:\n                continue\n            for i in range(min_len, str_len + self.plus_minus):\n                found_len = found_idx.get(i, None)\n                if found_len is not None:\n                    all_sets = all_sets.union(found_len)\n        return all_sets", "response": "Find all similar strings in the database"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a generator that generates the Galois linear feedback shift register for the specified size.", "response": "def lfsr(size, seed=None):\n    '''Creates a generator using the Galois linear feedback shift register\nalgorithm. The *size* corresponds to the entries in\n:py:class:`hotmic.polynomials.all_polys`, which represents the bitspace of the\nshift register. The *seed* is the initial value to pass to the algorithm.'''\n    \n    if not size in polynomials.all_polys:\n        raise ValueError('bitsize not found in polynomial map')\n    \n    poly = polynomials.all_polys[size]\n\n    if seed is None:\n        seed = 0xACE1 & (2 ** size - 1)\n        \n    register = seed\n\n    while 1:\n        lsb = register & 1\n        register >>= 1\n\n        if lsb:\n            register ^= poly\n\n        yield register"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef xrandrange(start=None, stop=None):\n    '''\nProduces an iterator similiar to xrange with the interface of range. \nThe iterator yields random numbers from 0 <= x < *start* if *stop* is not\nspecified, or *start* <= x < *stop* if it is. Here's an example of xrandrange::\n\n   >>> list(xrandrange(10))\n   [2, 1, 0, 7, 4, 3, 8, 5, 9, 6]\n   >>> list(xrandrange(10, 20))\n   [11, 10, 16, 13, 12, 17, 14, 18, 15, 19]\n\n'''\n\n    if start is None and stop is None:\n        raise ValueError('no stop point specified')\n\n    if not start is None and stop is None:\n        stop = start\n        start = 0\n\n    if start is None:\n        start = 0\n\n    rand_range = stop - start\n    \n    if rand_range <= 0:\n        raise ValueError('empty range given')\n\n    # +/-1 compensates for the fact that 0 is not generated by the lfsr\n    bitsize = int(math.floor(math.log(rand_range+1, 2)))+1\n    seed = random.randrange(0, 2 ** bitsize - 1)\n    lfsr_gen = lfsr(bitsize, seed)\n\n    for value in lfsr_gen:\n        if not value > rand_range:\n            yield value - 1 + start\n\n        if value == seed:\n            break", "response": "Returns an iterator similiar to xrange with the interface of range."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning an iterator that yields random elements from the iterable.", "response": "def randiter(iterable):\n    '''\nCreate an iterator that yields random elements from the iterable object \n*iterable*. It expects the iterable object to implement __getitem__ and __len__.'''\n\n    iter_len = len(iterable)\n\n    for index in xrandrange(iter_len):\n        yield iterable[index]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _load_methods(package):\n    global _methods\n    _methods[package] = None\n    \n    from acorn.config import settings\n    from acorn.logging.descriptors import _obj_getattr\n    spack = settings(package)\n    if spack is not None:\n        if spack.has_section(\"analysis.methods\"):\n            _methods[package] = {}\n            \n            from importlib import import_module\n            mappings = dict(spack.items(\"analysis.methods\"))\n            for fqdn, target in mappings.items():\n                rootname = target.split('.')[0]\n                root = import_module(rootname)\n                caller = _obj_getattr(root, target)\n                _methods[package][fqdn] = caller", "response": "Loads the mappings from method call result to analysis.\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nanalyzes the result of calling the method with the specified FQDN.", "response": "def analyze(fqdn, result, argl, argd):\n    \"\"\"Analyzes the result from calling the method with the specified FQDN.\n\n    Args:\n        fqdn (str): full-qualified name of the method that was called.\n        result: result of calling the method with `fqdn`.\n        argl (tuple): positional arguments passed to the method call.\n        argd (dict): keyword arguments passed to the method call.\n    \"\"\"\n    package = fqdn.split('.')[0]\n    if package not in _methods:\n        _load_methods(package)\n        \n    if _methods[package] is not None and fqdn in _methods[package]:\n        return _methods[package][fqdn](fqdn, result, *argl, **argd)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse TAF data and returns TafData and Units dataclasses with parsed data and their associated units", "response": "def parse(station: str, txt: str) -> TafData:\n    \"\"\"\n    Returns TafData and Units dataclasses with parsed data and their associated units\n    \"\"\"\n    core.valid_station(station)\n    while len(txt) > 3 and txt[:4] in ('TAF ', 'AMD ', 'COR '):\n        txt = txt[4:]\n    _, station, time = core.get_station_and_time(txt[:20].split(' '))\n    retwx = {\n        'end_time': None,\n        'raw': txt,\n        'remarks': None,\n        'start_time': None,\n        'station': station,\n        'time': core.make_timestamp(time)\n    }\n    txt = txt.replace(station, '')\n    txt = txt.replace(time, '').strip()\n    if core.uses_na_format(station):\n        use_na = True\n        units = Units(**NA_UNITS)  # type: ignore\n    else:\n        use_na = False\n        units = Units(**IN_UNITS)  # type: ignore\n    # Find and remove remarks\n    txt, retwx['remarks'] = core.get_taf_remarks(txt)\n    # Split and parse each line\n    lines = core.split_taf(txt)\n    parsed_lines = parse_lines(lines, units, use_na)\n    # Perform additional info extract and corrections\n    if parsed_lines:\n        parsed_lines[-1]['other'], retwx['max_temp'], retwx['min_temp'] \\\n            = core.get_temp_min_and_max(parsed_lines[-1]['other'])\n        if not (retwx['max_temp'] or retwx['min_temp']):\n            parsed_lines[0]['other'], retwx['max_temp'], retwx['min_temp'] \\\n                = core.get_temp_min_and_max(parsed_lines[0]['other'])\n        # Set start and end times based on the first line\n        start, end = parsed_lines[0]['start_time'], parsed_lines[0]['end_time']\n        parsed_lines[0]['end_time'] = None\n        retwx['start_time'], retwx['end_time'] = start, end\n        parsed_lines = core.find_missing_taf_times(parsed_lines, start, end)\n        parsed_lines = core.get_taf_flight_rules(parsed_lines)\n    # Extract Oceania-specific data\n    if retwx['station'][0] == 'A':  # type: ignore\n        parsed_lines[-1]['other'], retwx['alts'], retwx['temps'] \\\n            = core.get_oceania_temp_and_alt(parsed_lines[-1]['other'])\n    # Convert to dataclass\n    retwx['forecast'] = [TafLineData(**line) for line in parsed_lines]  # type: ignore\n    return TafData(**retwx), units"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a list of lines into a list of dictionaries.", "response": "def parse_lines(lines: [str], units: Units, use_na: bool = True) -> [dict]:  # type: ignore\n    \"\"\"\n    Returns a list of parsed line dictionaries\n    \"\"\"\n    parsed_lines = []\n    prob = ''\n    while lines:\n        raw_line = lines[0].strip()\n        line = core.sanitize_line(raw_line)\n        # Remove prob from the beginning of a line\n        if line.startswith('PROB'):\n            # Add standalone prob to next line\n            if len(line) == 6:\n                prob = line\n                line = ''\n            # Add to current line\n            elif len(line) > 6:\n                prob = line[:6]\n                line = line[6:].strip()\n        if line:\n            parsed_line = (parse_na_line if use_na else parse_in_line)(line, units)\n            for key in ('start_time', 'end_time'):\n                parsed_line[key] = core.make_timestamp(parsed_line[key])  # type: ignore\n            parsed_line['probability'] = core.make_number(prob[4:])  # type: ignore\n            parsed_line['raw'] = raw_line\n            parsed_line['sanitized'] = prob + ' ' + line if prob else line\n            prob = ''\n            parsed_lines.append(parsed_line)\n        lines.pop(0)\n    return parsed_lines"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_na_line(txt: str, units: Units) -> typing.Dict[str, str]:\n    retwx = {}\n    wxdata = txt.split(' ')\n    wxdata, _, retwx['wind_shear'] = core.sanitize_report_list(wxdata)\n    wxdata, retwx['type'], retwx['start_time'], retwx['end_time'] = core.get_type_and_times(wxdata)\n    wxdata, retwx['wind_direction'], retwx['wind_speed'], \\\n        retwx['wind_gust'], _ = core.get_wind(wxdata, units)\n    wxdata, retwx['visibility'] = core.get_visibility(wxdata, units)\n    wxdata, retwx['clouds'] = core.get_clouds(wxdata)\n    retwx['other'], retwx['altimeter'], retwx['icing'], retwx['turbulance'] \\\n        = core.get_taf_alt_ice_turb(wxdata)\n    return retwx", "response": "Parses a North American TAF forcast varient from a string"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_in_line(txt: str, units: Units) -> typing.Dict[str, str]:\n    retwx = {}\n    wxdata = txt.split(' ')\n    wxdata, _, retwx['wind_shear'] = core.sanitize_report_list(wxdata)\n    wxdata, retwx['type'], retwx['start_time'], retwx['end_time'] = core.get_type_and_times(wxdata)\n    wxdata, retwx['wind_direction'], retwx['wind_speed'], \\\n        retwx['wind_gust'], _ = core.get_wind(wxdata, units)\n    if 'CAVOK' in wxdata:\n        retwx['visibility'] = core.make_number('CAVOK')\n        retwx['clouds'] = []\n        wxdata.pop(wxdata.index('CAVOK'))\n    else:\n        wxdata, retwx['visibility'] = core.get_visibility(wxdata, units)\n        wxdata, retwx['clouds'] = core.get_clouds(wxdata)\n    retwx['other'], retwx['altimeter'], retwx['icing'], retwx['turbulance'] \\\n        = core.get_taf_alt_ice_turb(wxdata)\n    return retwx", "response": "Parses the TAF forcast varient from the input text"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef modify(self, entry_id, **kw):\n    '''\n    Incremental version of :meth:`update`: instead of updating all\n    attributes of the entry to the specified values, this method only\n    updates the specified keywords. Returns True on success, or raises\n    an exception on failure.\n\n    Note: the default implementation assumes fast and sequential access\n    and reads the current version, updates the specified values, and\n    calls :meth:`update`.\n    '''\n    entry = self.read(entry_id)\n    for k, v in kw.items():\n      setattr(entry, k, v)\n    self.update(entry)\n    return True", "response": "Updates the attributes of the entry with the specified keywords."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nresets the color matrix to black pixels.", "response": "def reset(self):\n        \"\"\"\n        Fill the screen with black pixels\n        \"\"\"\n        surface = Surface(self.width, self.height)\n        surface.fill(BLACK)\n        self.matrix = surface.matrix"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self):\n        display_data = []\n        for y in range(self.height):\n            for x in range(self.width):\n                for color in self.matrix[x][y]:\n                    display_data.append(int(color))\n\n        checksum = bytearray([0, 0, 0, 0])\n        data_as_bytes = bytearray(display_data)\n        data = data_as_bytes + checksum\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        sock.sendto(data, (self.host, self.port))", "response": "Sends the current screen contents to Mate Light"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef blit(self, surface, pos=(0, 0)):\n        for x in range(surface.width):\n            for y in range(surface.height):\n                point = (x + pos[0], y + pos[1])\n                if self.point_on_screen(point):\n                    self.matrix[point[0]][point[1]] = surface.matrix[x][y]", "response": "Blits a surface on the screen at pos"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef point_on_screen(self, pos):\n        if 0 <= pos[0] < self.width and 0 <= pos[1] < self.height:\n            return True\n        else:\n            return False", "response": "Returns True if the point is on the screen False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, word):\n\n        url = \"https://mashape-community-urban-dictionary.p.mashape.com/define?term=%s\" % word\n\n        try:\n            res = requests.get(url,\n                               headers = {\"X-Mashape-Key\": self.api_key,\n                               \"Accept\": \"text/plain\"})\n        except requests.ConnectionError:\n            raise errors.ConnectionError\n\n        if res.status_code == 200:\n            if res.json()[\"result_type\"] == 'no_results':\n                raise errors.NoResultsError\n            else:\n                return Result(res.json())\n        else:\n            if res.status_code == 403:\n                raise errors.APIUnauthorizedError", "response": "Gets the definition of a word from Urban Dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nestimating the time needed to apply upgrades.", "response": "def estimate(self, upgrades):\n        \"\"\"Estimate the time needed to apply upgrades.\n\n        If an upgrades does not specify and estimate it is assumed to be\n        in the order of 1 second.\n\n        :param upgrades: List of upgrades sorted in topological order.\n        \"\"\"\n        val = 0\n        for u in upgrades:\n            val += u.estimate()\n        return val"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmake a human readable estimated time to completion string.", "response": "def human_estimate(self, upgrades):\n        \"\"\"Make a human readable estimated time to completion string.\n\n        :param upgrades: List of upgrades sorted in topological order.\n        \"\"\"\n        val = self.estimate(upgrades)\n        if val < 60:\n            return \"less than 1 minute\"\n        elif val < 300:\n            return \"less than 5 minutes\"\n        elif val < 600:\n            return \"less than 10 minutes\"\n        elif val < 1800:\n            return \"less than 30 minutes\"\n        elif val < 3600:\n            return \"less than 1 hour\"\n        elif val < 3 * 3600:\n            return \"less than 3 hours\"\n        elif val < 6 * 3600:\n            return \"less than 6 hours\"\n        elif val < 12 * 3600:\n            return \"less than 12 hours\"\n        elif val < 86400:\n            return \"less than 1 day\"\n        else:\n            return \"more than 1 day\""}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _setup_log_prefix(self, plugin_id=''):\n        self._logger_console_fmtter.prefix = '%s: ' % plugin_id\n        self._logger_console_fmtter.plugin_id = plugin_id\n        self._logger_file_fmtter.prefix = '*'\n        self._logger_file_fmtter.plugin_id = '%s: ' % plugin_id", "response": "Setup custom warning notification."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _teardown_log_prefix(self):\n        self._logger_console_fmtter.prefix = ''\n        self._logger_console_fmtter.plugin_id = ''\n        self._logger_file_fmtter.prefix = ' '\n        self._logger_file_fmtter.plugin_id = ''", "response": "Tear down custom warning notification."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pre_upgrade_checks(self, upgrades):\n        errors = []\n\n        for check in self.global_pre_upgrade:\n            self._setup_log_prefix(plugin_id=check.__name__)\n            try:\n                check()\n            except RuntimeError as e:\n                errors.append((check.__name__, e.args))\n\n        for u in upgrades:\n            self._setup_log_prefix(plugin_id=u.name)\n            try:\n                u.pre_upgrade()\n            except RuntimeError as e:\n                errors.append((u.name, e.args))\n\n        self._teardown_log_prefix()\n\n        self._check_errors(errors, \"Pre-upgrade check for %s failed with the\"\n                           \" following errors:\")", "response": "Run pre - upgrade pre - checks prior to applying upgrades."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _check_errors(self, errors, prefix):\n        args = []\n\n        for uid, messages in errors:\n            error_msg = []\n            error_msg.append(prefix % uid)\n            for msg in messages:\n                error_msg.append(\" (-) %s\" % msg)\n            args.append(\"\\n\".join(error_msg))\n\n        if args:\n            raise RuntimeError(*args)", "response": "Check for errors and possible raise and format an error message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning post - upgrade checks after applying all pending upgrades.", "response": "def post_upgrade_checks(self, upgrades):\n        \"\"\"Run post-upgrade checks after applying all pending upgrades.\n\n        Post checks may be used to emit warnings encountered when applying an\n        upgrade, but post-checks can also be used to advice the user to run\n        re-indexing or similar long running processes.\n\n        Post-checks may query for user-input, but should respect the\n        --yes-i-know option to run in an unattended mode.\n\n        All applied upgrades post-checks are executed.\n\n        :param upgrades: List of upgrades sorted in topological order.\n        \"\"\"\n        errors = []\n\n        for u in upgrades:\n            self._setup_log_prefix(plugin_id=u.name)\n            try:\n                u.post_upgrade()\n            except RuntimeError as e:\n                errors.append((u.name, e.args))\n\n        for check in self.global_post_upgrade:\n            self._setup_log_prefix(plugin_id=check.__name__)\n            try:\n                check()\n            except RuntimeError as e:\n                errors.append((check.__name__, e.args))\n\n        self._teardown_log_prefix()\n\n        self._check_errors(errors, \"Post-upgrade check for %s failed with the \"\n                           \"following errors:\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\napplying an upgrade and register that it was successful.", "response": "def apply_upgrade(self, upgrade):\n        \"\"\"Apply a upgrade and register that it was successful.\n\n        A upgrade may throw a RuntimeError, if an unrecoverable error happens.\n\n        :param upgrade: A single upgrade\n        \"\"\"\n        self._setup_log_prefix(plugin_id=upgrade.name)\n\n        try:  # Nested due to Python 2.4\n            try:\n                upgrade.do_upgrade()\n                self.register_success(upgrade)\n            except RuntimeError as e:\n                msg = [\"Upgrade error(s):\"]\n\n                for m in e.args:\n                    msg.append(\" (-) %s\" % m)\n\n                logger = self.get_logger()\n                logger.error(\"\\n\".join(msg))\n\n                raise RuntimeError(\n                    \"Upgrade '%s' failed. Your installation is in an\"\n                    \" inconsistent state. Please manually review the upgrade \"\n                    \"and resolve inconsistencies.\" % upgrade['id']\n                )\n        finally:\n            self._teardown_log_prefix()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_history(self):\n        if not self.history:\n            query = Upgrade.query.order_by(desc(Upgrade.applied))\n\n            for u in query.all():\n                self.history[u.upgrade] = u.applied\n                self.ordered_history.append(u.upgrade)", "response": "Load upgrade history from database table."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register_success(self, upgrade):\n        u = Upgrade(upgrade=upgrade.name, applied=datetime.now())\n        db.session.add(u)\n        db.session.commit()", "response": "Register a successful upgrade."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_history(self):\n        self.load_history()\n        return map(lambda x: (x, self.history[x]), self.ordered_history)", "response": "Get history of applied upgrades."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload upgrade modules. :param remove_applied: if True, already applied upgrades will not be included, if False the entire upgrade graph will be returned.", "response": "def _load_upgrades(self, remove_applied=True):\n        \"\"\"Load upgrade modules.\n\n        :param remove_applied: if True, already applied upgrades will not\n            be included, if False the entire upgrade graph will be\n            returned.\n        \"\"\"\n        if remove_applied:\n            self.load_history()\n\n        for entry_point in iter_entry_points('invenio_upgrader.upgrades'):\n            upgrade = entry_point.load()()\n            self.__class__._upgrades[upgrade.name] = upgrade\n\n        return self.__class__._upgrades"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_upgrades(self, remove_applied=True):\n        if self.upgrades is None:\n            plugins = self._load_upgrades(remove_applied=remove_applied)\n\n            # List of un-applied upgrades in topological order\n            self.upgrades = self.order_upgrades(plugins, self.history)\n        return self.upgrades", "response": "Get upgrades ordered according to their dependencies."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating dependency graph from upgrades.", "response": "def _create_graph(self, upgrades, history=None):\n        \"\"\"Create dependency graph from upgrades.\n\n        :param upgrades: Dict of upgrades\n        :param history: Dict of applied upgrades\n        \"\"\"\n        history = history or {}\n        graph_incoming = {}  # nodes their incoming edges\n        graph_outgoing = {}  # nodes their outgoing edges\n\n        # Create graph data structure\n        for mod in six.itervalues(upgrades):\n            # Remove all incoming edges from already applied upgrades\n            graph_incoming[mod.name] = [x for x in mod.depends_on\n                                        if x not in history]\n            # Build graph_outgoing\n            if mod.name not in graph_outgoing:\n                graph_outgoing[mod.name] = []\n            for edge in graph_incoming[mod.name]:\n                if edge not in graph_outgoing:\n                    graph_outgoing[edge] = []\n                graph_outgoing[edge].append(mod.name)\n\n        return (graph_incoming, graph_outgoing)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_endpoints(self):\n        plugins = self._load_upgrades(remove_applied=False)\n\n        dummy_graph_incoming, graph_outgoing = self._create_graph(plugins, {})\n\n        endpoints = {}\n        for node, outgoing in six.iteritems(graph_outgoing):\n            if not outgoing:\n                repository = plugins[node].repository\n                if repository not in endpoints:\n                    endpoints[repository] = []\n                endpoints[repository].append(node)\n\n        return endpoints", "response": "Find upgrade end - points ( i. e nodes without dependents"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\norders upgrades according to their dependencies.", "response": "def order_upgrades(self, upgrades, history=None):\n        \"\"\"Order upgrades according to their dependencies.\n\n        (topological sort using\n        Kahn's algorithm - http://en.wikipedia.org/wiki/Topological_sorting).\n\n        :param upgrades: Dict of upgrades\n        :param history: Dict of applied upgrades\n        \"\"\"\n        history = history or {}\n        graph_incoming, graph_outgoing = self._create_graph(upgrades, history)\n\n        # Removed already applied upgrades (assumes all dependencies prior to\n        # this upgrade has been applied).\n        for node_id in six.iterkeys(history):\n            start_nodes = [node_id, ]\n            while start_nodes:\n                node = start_nodes.pop()\n                # Remove from direct dependents\n                try:\n                    for d in graph_outgoing[node]:\n                        graph_incoming[d] = [x for x in graph_incoming[d]\n                                             if x != node]\n                except KeyError:\n                    warnings.warn(\"Ghost upgrade %s detected\" % node)\n\n                # Remove all prior dependencies\n                if node in graph_incoming:\n                    # Get dependencies, remove node, and recursively\n                    # remove all dependencies.\n                    depends_on = graph_incoming[node]\n\n                    # Add dependencies to check\n                    for d in depends_on:\n                        graph_outgoing[d] = [x for x in graph_outgoing[d]\n                                             if x != node]\n                        start_nodes.append(d)\n\n                    del graph_incoming[node]\n\n        # Check for missing dependencies\n        for node_id, depends_on in six.iteritems(graph_incoming):\n            for d in depends_on:\n                if d not in graph_incoming:\n                    raise RuntimeError(\"Upgrade %s depends on an unknown\"\n                                       \" upgrade %s\" % (node_id, d))\n\n        # Nodes with no incoming edges\n        start_nodes = [x for x in six.iterkeys(graph_incoming)\n                       if len(graph_incoming[x]) == 0]\n        topo_order = []\n\n        while start_nodes:\n            # Append node_n to list (it has no incoming edges)\n            node_n = start_nodes.pop()\n            topo_order.append(node_n)\n\n            # For each node m with and edge from n to m\n            for node_m in graph_outgoing[node_n]:\n                # Remove the edge n to m\n                graph_incoming[node_m] = [x for x in graph_incoming[node_m]\n                                          if x != node_n]\n                # If m has no incoming edges, add it to start_nodes.\n                if not graph_incoming[node_m]:\n                    start_nodes.append(node_m)\n\n        for node, edges in six.iteritems(graph_incoming):\n            if edges:\n                raise RuntimeError(\"The upgrades have at least one cyclic \"\n                                   \"dependency involving %s.\" % node)\n\n        return map(lambda x: upgrades[x], topo_order)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_plugin_id(self, plugin_id):\n        m = re.match(\"(.+)(_\\d{4}_\\d{2}_\\d{2}_)(.+)\", plugin_id)\n        if m:\n            return m.group(1)\n        m = re.match(\"(.+)(_release_)(.+)\", plugin_id)\n        if m:\n            return m.group(1)\n\n        raise RuntimeError(\"Repository could not be determined from \"\n                           \"the upgrade identifier: %s.\" % plugin_id)", "response": "Determine repository from plugin id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the ISO - 8601 version of the object.", "response": "def repository(self):\n        \"\"\"Repository.\"\"\"\n        m = re.match(\"(.+)(_\\d{4}_\\d{2}_\\d{2}_)(.+)\", self.__module__)\n        if m:\n            return m.group(1)\n        m = re.match(\"(.+)(_release_)(.+)\", self.__module__)\n        if m:\n            return m.group(1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild a METAR string from a mission file", "response": "def get_metar_from_mission(\n        mission_file: str,\n        icao: str = 'XXXX',\n        time: str = None,\n) -> str:\n    \"\"\"\n    Builds a dummy METAR string from a mission file\n\n    Args:\n        mission_file: input mission file\n        icao: dummy ICAO (defaults to XXXX)\n        time: dummy time (defaults to now())\n\n    Returns: METAR str\n\n    \"\"\"\n    return _MetarFromMission(\n        mission_file=mission_file,\n        icao=icao,\n        time=time,\n    ).metar"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild a METAR string from a MIZ file containing information.", "response": "def metar(self) -> str:\n        \"\"\"\n        Builds a METAR string from a MIZ file\n\n        A lots of information is inferred from what information we have available in DCS. There constraints in the way\n        MIZ files are built, with precipitations for example.\n\n        Returns: METAR string\n        \"\"\"\n        metar = f'{self._icao} ' \\\n                f'{self._time} ' \\\n                f'{self._wind} ' \\\n                f'{self._visibility} ' \\\n                f'{self._precipitations} ' \\\n                f'{self._clouds} ' \\\n                f'{self._temperature} ' \\\n                f'{self._pressure} ' \\\n                f'{self._qualifier}'\n        return re.sub(' +', ' ', metar)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef subtopics(store, folders, folder_id, subfolder_id, ann_id=None):\n    '''Yields an unordered generator of subtopics in a subfolder.\n\n    Each item of the generator is a 4-tuple of ``content_id``,\n    ``subtopic_id``, ``subtopic_type`` and ``data``. Subtopic type\n    is one of the following Unicode strings: ``text``, ``image``\n    or ``manual``. The type of ``data`` is dependent on the\n    subtopic type. For ``image``, ``data`` is a ``(unicode, str)``,\n    where the first element is the URL and the second element is\n    the binary image data. For all other types, ``data`` is a\n    ``unicode`` string.\n\n    :param str folder_id: Folder id\n    :param str subfolder_id: Subfolder id\n    :param str ann_id: Username\n    :rtype: generator of\n            ``(content_id, subtopic_id, url, subtopic_type, data)``\n    '''\n    # This code will be changed soon. In essence, it implements the\n    # convention established in SortingDesk for storing subtopic data.\n    # Currently, subtopic data is stored in the FC that the data (i.e.,\n    # image or snippet) came from. This is bad because it causes pretty\n    # severe race conditions.\n    #\n    # Our current plan is to put each subtopic datum in its own FC. It will\n    # require this code to make more FC fetches, but we should be able to\n    # do it with one `store.get_many` call.\n    items = folders.grouped_items(folder_id, subfolder_id, ann_id=ann_id)\n    fcs = dict([(cid, fc) for cid, fc in store.get_many(items.keys())])\n    for cid, subids in items.iteritems():\n        fc = fcs[cid]\n        for subid in subids:\n            try:\n                data = typed_subtopic_data(fc, subid)\n            except KeyError:\n                # We have a dangling label folks!\n                continue\n            yield cid, subid, fc['meta_url'], subtopic_type(subid), data", "response": "Yields an unordered generator of subtopics in a subfolder."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning typed subtopic data from an FC.", "response": "def typed_subtopic_data(fc, subid):\n    '''Returns typed subtopic data from an FC.'''\n    # I don't think this code will change after we fix the data race bug. ---AG\n    ty = subtopic_type(subid)\n    data = get_unicode_feature(fc, subid)\n    assert isinstance(data, unicode), \\\n        'data should be `unicode` but is %r' % type(data)\n    if ty == 'image':\n        img_data = get_unicode_feature(fc, subid + '|data')\n        img = re.sub('^data:image/[a-zA-Z]+;base64,', '', img_data)\n        img = base64.b64decode(img.encode('utf-8'))\n        return data, img\n    elif ty in ('text', 'manual'):\n        return data\n    raise ValueError('unrecognized subtopic type \"%s\"' % ty)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef draw(self):\n        '''Draw the tree of UI elements once directly to the terminal. The root\n        element of the UI is referenced by this instance's :attr:`element`\n        attribute. Layout is automatically calculated by the UI elements in the\n        tree in reponse ultimately to the :attr:`width` and :attr:`height`\n        attributes of this instances :class:`Terminal`: instance. There is no\n        async behaviour triggered from this method - see :meth:`run` if you\n        want to :mod:`jcn` to take care redrawing when required.\n        '''\n        super().draw(\n            self.terminal.width, self.terminal.height, terminal=self.terminal,\n            styles=self.style)", "response": "Draw the tree of UI elements once directly to the terminal."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndrawing directly to the terminal any UI elements in the tree that are marked as having been updated.", "response": "def update(self):\n        '''Draws directly to the terminal any UI elements in the tree that are\n        marked as having been updated. UI elements may have marked themselves\n        as updated if, for example, notable attributes have been altered, or\n        the :attr:`updated` element may be set to ``True`` explicitly by your\n        program. The drawing and layout logic are exactly the same as for\n        :meth:`draw`.\n        '''\n        super().update(\n            self.default_format, terminal=self.terminal, styles=self.style)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the raw_data and return a new instance of the class MetadataFile.", "response": "def _parse(self):\n        \"\"\"\n        Parse :attr:`raw_data`.\n\n        Returns:\n            MetadataFile: New MetadataFile with parsed data inside (namedtuples\n                          are immutable).\n        \"\"\"\n        return MetadataFile(\n            self.filename,\n            self.raw_data,\n            decoders.parse_meta(self.filename, self.raw_data)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef text(el, strip=True):\n    if not el:\n        return \"\"\n\n    text = el.text\n    if strip:\n        text = text.strip()\n    return text", "response": "Return the text of a BeautifulSoup element."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the text of a BeautifulSoup element assuming it s a course code.", "response": "def coursecode(el):\n    \"\"\"\n    Return the text of a ``BeautifulSoup`` element, assuming it's a course code\n    (it strips any square-brackets-surrounded number at its end).\n    \"\"\"\n    txt = text(el)\n    return re.sub(r\"\\s*\\[\\d+\\]$\", \"\", txt, re.UNICODE)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse(el, typ):\n    if not el:\n        return typ()\n    txt = text(el)\n    if not txt:\n        return typ()\n    return typ(txt)", "response": "Parse a BeautifulSoup element as the given type."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parsebool(el):\n    txt = text(el)\n    up = txt.upper()\n    if up == \"OUI\":\n        return True\n    if up == \"NON\":\n        return False\n\n    return bool(parseint(el))", "response": "Parse a BeautifulSoup element as a bool returning True if the element is a boolean False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef findMax(arr):\n    out = np.zeros(shape=arr.shape, dtype=bool)\n    _calcMax(arr, out)\n    return out", "response": "find max in comparison to argrelmax more simple and reliable peak finder\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind the minimum value in an array", "response": "def findMin(arr):\n    \"\"\"\n    in comparison to argrelmax() more simple and  reliable peak finder\n    \"\"\"\n    out = np.zeros(shape=arr.shape, dtype=bool)\n    _calcMin(arr, out)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef authenticate_application(self, api_token, admin_token,\n                                 override=False, fetch=True):\n        \"\"\"Set credentials for Application authentication.\n        Important Note: Do not use Application auth on any end-user device.\n        Application auth provides read-access to all Users who have\n        authorized an Application. Use on a secure application server only.\n\n        Args:\n          api_token (str): Token issued to your Application through the Gem\n            Developer Console.\n          admin_token (str): Token issued to run an instance of your App\n            THIS IS A SECRET. TREAT IT LIKE A SECRET.\n          override (boolean): Replace existing Application credentials.\n          fetch (boolean): Return the authenticated Application.\n\n        Returns:\n          An Application object if `fetch` is True.\n        \"\"\"\n        if (self.context.has_auth_params('Gem-Application') and not override):\n            raise OverrideError('Gem-Application')\n\n        if (not api_token or not admin_token or\n            not self.context.authorize('Gem-Application',\n                                       api_token=api_token,\n                                       admin_token=admin_token)):\n            raise AuthUsageError(self.context, 'Gem-Application')\n\n        return self.application if fetch else True", "response": "Set credentials for Application authentication.\n        Important Note: Do not use Application auth on any end-user device.\n        Application auth provides read-access to all Users who have\n        authorized an Application. Use on a secure application server only.\n\n        Args:\n          api_token (str): Token issued to your Application through the Gem\n            Developer Console.\n          admin_token (str): Token issued to run an instance of your App\n            THIS IS A SECRET. TREAT IT LIKE A SECRET.\n          override (boolean): Replace existing Application credentials.\n          fetch (boolean): Return the authenticated Application.\n\n        Returns:\n          An Application object if `fetch` is True."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets credentials for Device authentication. Args: api_token (str): Token issued to your Application through the Gem Developer Console. device_token (str): Physical device identifier. You will receive this from a user.devices.create call or from users.create. email (str, optional): User's email address, required if user_url is not provided. user_url (str, optional): User's Gem url. override (boolean, optional): Replace existing Application credentials. fetch (boolean, optional): Return the authenticated User. Returns: An User object if `fetch` is True.", "response": "def authenticate_device(self, api_token, device_token, email=None,\n                            user_url=None, override=False, fetch=True):\n        \"\"\"Set credentials for Device authentication.\n\n        Args:\n          api_token (str): Token issued to your Application through the Gem\n            Developer Console.\n          device_token (str): Physical device identifier. You will receive this\n            from a user.devices.create call or from users.create.\n          email (str, optional): User's email address, required if user_url is\n            not provided.\n          user_url (str, optional): User's Gem url.\n          override (boolean, optional): Replace existing Application credentials.\n          fetch (boolean, optional): Return the authenticated User.\n\n        Returns:\n          An User object if `fetch` is True.\n        \"\"\"\n        if (self.context.has_auth_params('Gem-Device') and not override):\n            raise OverrideError('Gem-Device')\n\n        if (not api_token or\n            not device_token or\n            (not email and not user_url) or\n            not self.context.authorize('Gem-Device',\n                                       api_token=api_token,\n                                       user_email=email,\n                                       user_url=user_url,\n                                       device_token=device_token)):\n            raise AuthUsageError(self.context, 'Gem-Device')\n\n        if fetch:\n            user = self.user(email) if email else self.user()\n            return user.refresh()\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nauthenticating the application using the Gem - Identify API Token.", "response": "def authenticate_identify(self, api_token, override=True):\n        \"\"\"Set credentials for Identify authentication.\n\n        Args:\n          api_token (str): Token issued to your Application through the Gem\n            Developer Console.\n          override (boolean): Replace existing Application credentials.\n        \"\"\"\n        if (self.context.has_auth_params('Gem-Identify') and not override):\n            raise OverrideError('Gem-Identify')\n\n        if (not api_token or\n            not self.context.authorize('Gem-Identify', api_token=api_token)):\n            raise AuthUsageError(self.context, 'Gem-Identify')\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate command line parser for the s - expression indenter command line.", "response": "def create_args_parser():\n    \"\"\" Return command line parser \"\"\"\n    parser = argparse.ArgumentParser(\n        description='Dialect-aware s-expression indenter', prog='yasi')\n    parser.add_argument('files', help='List of files to be indented. '\n                        'Will indent from standard input if no files are specified',\n                        nargs='*')\n    parser.add_argument(\n        '-nc', '--no-compact', '--nc', dest='compact',\n        help='Do not compact the code, just indent', action='store_false')\n    parser.add_argument(\n        '-nb', '--no-backup', '--nb', dest='backup', action='store_false',\n        help='Do not create a backup file even if --backup-dir is specified ')\n    parser.add_argument(\n        '-nm', '--no-modify', '--nm', dest='modify',\n        help='Do not modify the file', action='store_false')\n    parser.add_argument(\n        '--diff', '-diff', dest='output_diff',\n        help='Prints unified diff of the initial and final result',\n        action='store_true')\n    parser.add_argument(\n        '-nw', '--no-warning', '--nw', dest='warning',\n        help='Do not display warnings', action='store_false')\n    parser.add_argument(\n        '-nr', '--no-rc', '--nr', dest='read_rc',\n        help='Ignore any rc files in the current or home folder',\n        action='store_false')\n    parser.add_argument(\n        '--no-output', '-no-output', dest='output',\n        help='Suppress output of the indented code', action='store_false')\n    parser.add_argument(\n        '-c', '--color', '-color', dest='colour_diff',\n        help='Display diff text in color', action='store_true')\n    parser.add_argument(\n        '-ne', '--no-exit', '--ne', dest='exit', action='store_false',\n        help='Instructs the program not to exit when a warning is raised.')\n    parser.add_argument(\n        '-o', dest='output_file',\n        help='Path/name of output file', type=str, default='')\n    parser.add_argument(\n        '--tab', '-tab', dest='tab_size',\n        help='Indent with tabs using the specified tabwidth. A tab is assumed \\\n        equal to 4 spaces by default when expanding the tabs in the input file',\n        type=int, default=-1)\n    parser.add_argument(\n        '--dialect', '-dialect',\n        help='Use Scheme keywords', type=str, default='')\n    parser.add_argument(\n        '-v', '--version', action='version',\n        help='Prints script version', version='yasi v%s' % __version__)\n    parser.add_argument(\n        '-suffix', '--suffix', dest='backup_suffix', help='Backup file suffix',\n        type=str, default='.yasi.bak~')\n    parser.add_argument(\n        '-bd', '--backup-dir', '--bd', '-backup-dir',\n        help='The directory where the backup file is to be written',\n        type=str, default=os.getcwd())\n    parser.add_argument(\n        '-is', '--indent-size', '--is',\n        help='The number of spaces per indent',\n        type=int, default=2)\n    parser.add_argument(\n        '-di', '--default-indent', '--di',\n        help='The indent level to be used in case a ' +\n        \"function's argument is in the next line. Vim uses 2, the most common being 1.\",\n        type=int, default=1)\n    parser.add_argument(\n        '-ic', '--indent-comments', '--ic',\n        help='If true, comment lines will be indented possibly ' +\n        'messing with any deliberate comment layout', action='store_true')\n    parser.add_argument(\n        '-uni', '--uniform', '-uniform', '--uni',\n        help='Dictates whether the if-clause and else-clause of an if-like' +\n        'block should have the same indent level.',\n        action='store_true')\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads command - line arguments >>> parse_options ( - indent - comments", "response": "def parse_options(arguments=None):\n    \"\"\" Reads command-line arguments\n\n    >>> parse_options('--indent-comments')\n    \"\"\"\n    if arguments is None:\n        arguments = sys.argv[1:]\n    if isinstance(arguments, str):\n        arguments = arguments.split()\n    if isinstance(arguments, argparse.Namespace):\n        return arguments\n    parser = create_args_parser()\n    args = parser.parse_args(arguments)\n    # pprint(args.__dict__)\n\n    args.dialect = args.dialect.lower()\n    if args.dialect not in ['lisp', 'newlisp', 'clojure', 'scheme', 'all', '']:\n        parser.error(\"`{0}' is not a recognized dialect\".format(args.dialect))\n\n    args.backup_dir = os.path.expanduser(args.backup_dir)\n    if not os.path.exists(args.backup_dir):\n        parser.error(\"Directory `{0}' does not exist\".format(args.backup_dir))\n\n    if len(args.files) > 1 and args.output_file:\n        parser.error('Cannot use the -o flag when more than one file is specified')\n\n    if not args.files:\n        # Indentation from standard input\n        if args.modify and not args.output_file:\n            args.modify = False\n        args.backup = False\n        args.warning = False\n\n    if args.output_diff:\n        # If someone requests a diff we assume he/she doesn't want the file to be\n        # modified\n        args.modify = False\n\n    return args"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread a file into a sequence of strings.", "response": "def read_file(fname):\n    \"\"\" read_file(fname : str) -> str\n\n    >>> read_file(r'C:\\\\mine\\\\test.lisp')\n    r'(print \"No, no, there\\'s \\\\r\\\\nlife in him!. \")\\\\r\\\\n\\\\r\\\\n'\n\n    The file is read in binary mode in order to preserve original line endings.\n        Line ending    Binary mode Text mode\n            CRLF            CRLF    LF\n            CR              CR      LF\n    \"\"\"\n    assert os.path.exists(fname), \"\\n--%s-- Warning: File `%s' does not exist. . .\" \\\n        % (current_time(), fname)\n    with open(fname, 'rb') as fp:\n        return fp.read().decode('utf-8')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef backup_source_file(fname, options=None):\n    opts = parse_options(options)\n    backup_dir = opts.backup_dir\n    assert os.path.exists(fname), \\\n        (\"\\n--%s-- Warning: File `%s' does not exist. . .\" % (current_time(), fname))\n    assert os.path.exists(os.path.abspath(backup_dir)), \\\n        (\"\\n--%s-- Warning: Directory `%s' does not exist. . .\" % (current_time(), fname))\n    backup_name = backup_dir + os.sep + os.path.split(fname)[1] + opts.backup_suffix\n    try:\n        shutil.copyfile(fname, backup_name)\n    except IOError:\n        message = \"\\n--%s-- Warning: Couldn't backup the file `%s' in `%s', check if you have enough permissions. \"\n        tpl = (current_time(), fname, backup_dir)\n        sys.stderr.write(message % tpl)", "response": "Backup a source file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntrims a string into a non - empty sequence", "response": "def trim(string):\n    \"\"\" trim(string : str) -> str\n\n    Uses every usefull hack to try and reduce extra whitespace without\n    messing with character literals\n    \"\"\"\n    # Trailing whitespace\n    string = re.sub('[ \\t]*$', '', string)\n    # turn '(print(+ 1 1))' to '(print (+ 1 1))'\n    string = re.sub(r'''([^\\\\(\\[, {@~`'#^])(\\(|\\[|{)''', r'\\1 \\2', string, re.X)\n    # turn  ')(' to ') ('\n    string = re.sub(r'(\\)|\\]|})(\\[|\\(|{)', r'\\1 \\2', string)\n    # Remove any space before closing brackets '(print 12   )' ==> '(print 12)'\n    string = re.sub('[ \\t]*(\\)|\\]|})', r'\\1', string)\n    # remove extra whitespace \"(print     'this)\" ==> \"(print 'this)\"\n    string = re.sub('[ \\t]{2,}', ' ', string)\n    # turn ') ) ) ' into '))) '\n    string = re.sub(r'(\\))[ \\t]*(?=(\\)))', r'\\1', string)\n    string = re.sub(r'(\\])[ \\t]*(?=(\\]))', r'\\1', string)\n    string = re.sub(r'(})[ \\t]*(?=(}))', r'\\1', string)\n    # turn '( ( ( ' into '((( '\n    string = re.sub(r'(\\()[ \\t]*(?=(\\())', r'\\1', string)\n    string = re.sub(r'(\\[)[ \\t]*(?=(\\[))', r'\\1', string)\n    string = re.sub(r'({)[ \\t]*(?=({))', r'\\1', string)\n    # remove leading whitespace '   print' ==> 'print'\n    string = re.sub('^[ \\t]*', '', string)\n    # Remove space between quote and opening bracket, \"' (1 2 3)\" ==> \"'(1 2 3)\"\n    string = re.sub(\"('|`)[ \\t]+(\\(|\\[|{)\", r'\\1\\2', string)\n    return string"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_trim_limit(string, options=None):\n    opts = parse_options(options)\n    # Find position of the first unescaped semi colon\n    comment_start = re.search(r'([^\\\\];)|(^;)', string)\n    # Find position of the first unescaped double quote\n    string_start = re.search(r'([^\\\\]\")|(^\")', string)\n    # Assign -1 if there's no match\n    limit = string_start.end() if string_start else -1\n    comment_start = comment_start.end() if comment_start else -1\n    if comment_start != -1:\n        # If a semi colon is found, include all the whitespace before it to preserve\n        # any aligned comments\n        comment_start = re.search('[ \\t]*;', string).start()\n\n    if opts.dialect == 'newlisp':\n        # Find out which string type comes first(normal, tag or brace strings)\n        brace_string_start = string.find('{')\n        tag_string_start = string.find('[text]')\n        pos_lst = [limit, brace_string_start, tag_string_start]\n        pos_lst = [x for x in pos_lst if x != -1]\n        if pos_lst:\n            limit = min(pos_lst)\n\n    if comment_start != -1 and limit != -1:\n        if comment_start < limit:\n            # If the semicolon comes before the comma, it means the string has been\n            # commented out\n            limit = comment_start\n    elif comment_start != -1 and limit == -1:\n        # If there's a semicolon but no quote, use the semicolon position as the\n        # limit\n        limit = comment_start\n    elif limit == -1:\n        # If neither a semicolon nor a double quote has been found, use the length\n        # of the string as the limit\n        limit = len(string)\n    return limit", "response": "This function finds the next non - empty version of the base class of the base class."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntest if a word is a macro name.", "response": "def is_macro_name(func_name, dialect):\n    \"\"\" is_macro_name(func_name : str, dialect : str) -> bool\n\n    >>> is_macro_name('yacc:define-parser')\n    True\n\n    Tests if a word is a macro using the language's/dialect's convention,\n    e.g macros in Lisp usually start with 'def' and 'with' in Scheme. Saves\n    the effort of finding all the macros in Lisp/Scheme/Clojure/newLISP and storing\n    them in a list.\n    \"\"\"\n    if not func_name:\n        return False\n    if dialect == 'lisp':\n        return re.search('^(macro|def|do|with-)', func_name, re.I)\n    if dialect == 'scheme':\n        return re.search('^(call-|def|with-)', func_name)\n    if dialect == 'clojure':\n        return re.search('^(def|with)', func_name)\n    if dialect == 'newlisp':\n        return re.search('^(macro|def)', func_name)\n    else:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef split_preserve(string, sep):\n    # split the whole string into a list so that you can iterate line by line.\n    str_list = string.split(sep)\n    if str_list[-1] == '':\n        # If you split 'this\\nthat\\n' you get ['this', 'that', ''] if\n        # you add newlines to every string in the list you get\n        # ['this\\n', 'that\\n', '\\n']. You've just added\n        # another newline at the end of the file.\n        del str_list[-1]\n        str_list = [x + sep for x in str_list]\n    else:\n        # ['this', 'that'] will become ['this\\n', 'that\\n'] when\n        # mapped. A newline has been added to the file. We don't want\n        # this, so we strip it below.\n        str_list     = [x + sep for x in str_list]\n        str_list[-1] = str_list[-1].rstrip(sep)\n    return str_list", "response": "split_preserve - Splits a string into a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tabify(text, options):\n    opts = parse_options(options)\n    if opts.tab_size < 1:\n        return text\n    else:\n        tab_equiv = ' ' * opts.tab_size\n        return text.replace(tab_equiv, '\\t')", "response": "Tabify text with tab_size tabs"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a string with leading whitespace added to the current level and the zero level.", "response": "def pad_leading_whitespace(string, zero_level, blist, options=None):\n    \"\"\" pad_leading_whitespace(string : str, current_level : int,\n                               zero_level : int) -> str\n\n    >>> pad_leading_whitespace(\"(print 'Yello)\")\n    \"         (print 'Yello)\"\n\n    Takes a string and indents it using the current indentation level\n    and the zero level.\n    \"\"\"\n    opts = parse_options(options)\n    if opts.compact:\n        # if compact mode is on, split the string into two, trim the first\n        # position and merge the two portions.\n        trim_limit = find_trim_limit(string, opts)\n        comment_line = re.search('^[ \\t]*;', string, re.M)\n        if comment_line and opts.indent_comments:\n            trim_limit = comment_line.end()\n        substr1 = string[0:trim_limit]\n        substr2 = string[trim_limit:]\n        substr1 = trim(substr1)\n        string = substr1 + substr2\n    else:\n        # If in nocompact mode, remove leading spaces only\n        string = re.sub('^[ \\t]+', '', string, count=0)\n\n    indent_level = zero_level\n    if blist:\n        indent_level = blist[-1]['indent_level']\n\n    padding = ' ' * indent_level\n    padding = tabify(padding, opts)\n    return padding + string, indent_level"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef indent_line(zerolevel, bracket_list, line, in_comment, in_symbol_region,\n                options=None):\n    \"\"\" indent_line(zerolevel : int, bracket_list : list, line : str, in_comment : bool,\n                    in_symbol_region : bool, options : string|list)\n\n    Most important function in the indentation process. It uses the bracket\n    locations stored in the list to indent the line.\n    \"\"\"\n    opts = parse_options(options)\n    comment_line = re.search('^[ \\t]*;', line, re.M)\n    if opts.indent_comments:\n        # We are allowed to indent comment lines\n        comment_line = False\n    if not opts.compact and bracket_list == [] and not in_comment:\n        # If nocompact mode is on and there are no unclosed blocks, try to\n        # find the zero level by simply counting spaces before a line that\n        # is not empty or has a comment\n        _line = detabify(line, opts)\n        leading_spaces = re.search('^[ \\t]+[^; )\\n\\r]', _line)\n        if leading_spaces:\n            # NOTE: If you don't subtract one here, the zero level will increase\n            # every time you indent the file because the character at the end of\n            # the regex is part of the capture.\n            zerolevel = leading_spaces.end() - 1\n        else:\n            zerolevel = 0\n\n    if in_symbol_region:\n        # No processing done in strings and comments\n        return zerolevel, line, 0\n    elif not comment_line and not all_whitespace(line):\n        # If this is not a comment line indent the line.\n        # If the list is empty, then the current_level defaults\n        # to zero\n        curr_line, current_level = pad_leading_whitespace(line, zerolevel,\n                                                          bracket_list, opts)\n        return zerolevel, curr_line, current_level\n    else:\n        return zerolevel, line, 0", "response": "This function indents a line in the specified bracket list."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_rc_json():\n    fname = '.yasirc.json'\n    path = os.path.expanduser('~/' + fname)\n    if os.path.exists(fname):\n        path = os.path.abspath(fname)\n    elif not os.path.exists(path):\n        path = ''\n    content = ''\n    if path:\n        with open(path) as f:\n            content = f.read()\n    ret = {}\n    if content:\n        ret = json.loads(content)\n    return collections.defaultdict(dict, ret)", "response": "Reads the json configuration file and parses it and returns the dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef assign_indent_numbers(lst, inum, dic=collections.defaultdict(int)):\n    for i in lst:\n        dic[i] = inum\n    return dic", "response": "Associate keywords with their respective indentation numbers."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_keywords(opts):\n    dialect = opts.dialect\n    keywords = collections.defaultdict(int)\n    two_spacers = []\n    two_armed = IF_LIKE\n    local_binders = []\n    if dialect == 'lisp':  # Lisp\n        two_spacers = LISP_KEYWORDS\n        two_armed += ['multiple-value-bind', 'destructuring-bind', 'do', 'do*']\n        local_binders += ['flet', 'macrolet', 'labels']\n    elif dialect == 'scheme':  # Scheme\n        two_spacers = SCHEME_KEYWORDS\n        two_armed += ['with-slots', 'do', 'do*']\n        local_binders += []\n    elif dialect == 'clojure':  # Clojure\n        two_spacers = CLOJURE_KEYWORDS\n        two_armed += []\n        local_binders += ['letfn']\n    elif dialect == 'newlisp':  # newLISP\n        two_spacers = NEWLISP_KEYWORDS\n        two_armed += []\n        local_binders += []\n    elif dialect == 'all':\n        two_spacers = LISP_KEYWORDS + SCHEME_KEYWORDS + CLOJURE_KEYWORDS + \\\n            NEWLISP_KEYWORDS\n    keywords = assign_indent_numbers(two_spacers, KEYWORD1, keywords)\n    keywords = assign_indent_numbers(two_armed, KEYWORD2, keywords)\n    keywords = assign_indent_numbers(local_binders, KEYWORD4, keywords)\n    if opts.read_rc:\n        rc_keywords = parse_rc_json()\n        keywords.update(rc_keywords[dialect])\n    return keywords", "response": "Add keywords to a lisp language file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_first_arg_pos(bracket_offset, curr_line, options=None):\n    opts = parse_options(options)\n    spaces_before_func = 0\n    subline = curr_line[bracket_offset + 1:]\n    if re.search('^[ \\t]*($|\\r)', subline):\n        # whitespace extending to the end of the line means there's no\n        # function in this line. The indentation level defaults to one.\n        arg_pos = 1\n    else:\n        if bracket_offset != len(curr_line) - 1 and curr_line[bracket_offset + 1] == ' ':\n            # control reaches here if we are not at the end of the line\n            # and whitespace follows. We must first find the position of the\n            # function and then the arguments position\n            match = re.search(' +[^)\\]]| \\)', subline)  # Find the first non whitespace/bracket character\n            if match:\n                spaces_before_func = match.end() - match.start() - 1\n                end = match.end()\n            else:\n                end = 0\n            # Then use the end of the whitespace group as the first argument\n            arg_pos = re.search(' +([^)])|( *(\\(|\\[))', subline[end:])\n            if arg_pos:\n                arg_pos = arg_pos.end() + spaces_before_func + 1\n            else:\n                arg_pos = spaces_before_func + 1\n            if re.match('^[ \\t]*(#\\||;|$|\\r)',\n                        subline[(end - 1 + subline[end - 1:].find(' ')):]):\n                # But, if a comment if found after the function name, the\n                # indent level becomes one\n                arg_pos = spaces_before_func + opts.default_indent\n        else:\n            # If there's no space after the bracket, simply find the end of the\n            # whitespace group\n            match = re.search(' +([^)}\\n\\r])|( *(\\(|\\[|{))', subline)\n            if match:  # found the argument\n                arg_pos = match.end()\n            else:  # Either empty list or argument is in the next line\n                arg_pos = 1\n            if re.match('^[\\t ]*(;|$|\\r)', subline[subline.find(' '):]):\n                # Again if a comment is found after the function name, the\n                # indent level defaults to 1\n                arg_pos = spaces_before_func + opts.default_indent\n    return [arg_pos, spaces_before_func]", "response": "Find the first argument to the function in the current line."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _pop_from_list(bracket, lst, line, real_pos, offset, msg_stack):\n    # Try to spot a case when a square bracket is used to close a round bracket\n    # block\n    if bracket == ']':\n        correct_closer = '['\n    elif bracket == ')':\n        correct_closer = '('\n    else:\n        correct_closer = '{'\n    if lst != []:\n        popped = lst.pop()\n        popped_char = popped['character']\n        popped_pos = popped['line_number']\n        popped_offset = popped['bracket_pos']\n        if popped_char is not correct_closer:\n            message = \"Bracket `%s' does not match `%s' at (%d, %d)\"\n            message = message % (bracket, popped_char, popped_pos, popped_offset)\n            warning_info = {\n                'msg': message,\n                'line': line,\n                'column': real_pos\n            }\n            msg_stack.append(warning_info)\n    else:\n        # If the list is empty and a closing bracket is found, it means we have\n        # excess brackets. That warning is issued here. The coordinates used\n        # will be slightly or largely off target depending on how much your\n        # code was modified when used with compact mode\n        message = \"Unmatched closing bracket `%s'\" % bracket\n        warning_info = {\n            'msg': message,\n            'line': line,\n            'column': offset + 1\n        }\n        msg_stack.append(warning_info)\n    return lst", "response": "Internal function to pop an item from a list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _push_to_list(lst, func_name, char, line, offset,\n                  first_arg_pos, first_item, in_list_literal,\n                  lead_spaces, options=None):\n    \"\"\" _push_to_list(lst : [str], func_name : str, char : str, line : int, offset : int,\n                        first_arg_pos :int , first_item : int, in_list_literal : bool,\n                        lead_spaces : int, options : str)\n\n    Called when an opening bracket is encountered. A hash containing the\n    necessary data to pin point errors and the indentation level is stored in\n    the list and the list returned.\n    \"\"\"\n    opts = parse_options(options)\n    keywords = add_keywords(opts)\n    pos_hash = {'character': char,\n                'line_number': line,\n                'bracket_pos': offset,\n                'indent_level': offset + first_arg_pos,  # the default value, e.g in normal function\n                'func_name': func_name,\n                'spaces': 0}\n\n    is_macro = is_macro_name(func_name, opts.dialect)\n    two_spacer = is_macro or keywords[func_name] in [KEYWORD1, KEYWORD4]\n\n    if in_list_literal or char == '{' or (char == '[' and opts.dialect == 'clojure'):\n        # found quoted list or clojure hashmap/vector\n        pos_hash['indent_level'] = first_item\n\n    elif keywords[func_name] == KEYWORD2:\n        # We only make the if-clause stand out if not in uniform mode\n        pos_hash['indent_level'] = lead_spaces + ((offset + opts.indent_size * 2)\n                                                  if not opts.uniform\n                                                  else (offset + opts.indent_size))\n\n    elif func_name != '':\n        if two_spacer:\n            pos_hash['indent_level'] = lead_spaces + offset + opts.indent_size\n        elif keywords[func_name] == KEYWORD3:\n            pos_hash['indent_level'] = lead_spaces + offset + (2 * opts.indent_size)\n\n    lst.append(pos_hash)\n    try:\n        # A hack to make flets and labels in Lisp not indent like\n        # functions. The 'labels' indentation may not be exactly\n        # perfect.\n        parent_func = lst[-3]['func_name']\n        # Make 'special' indentation occur only in a Clojure binding block([]) for\n        # letfns\n        non_bind_block = opts.dialect == 'clojure' and lst[-2]['character'] != '['\n        if keywords[parent_func] == KEYWORD4 and not non_bind_block:\n            lst[-1]['indent_level'] = offset + opts.indent_size\n    except IndexError:\n        pass\n    return lst", "response": "Internal function to push a list to the internal list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a new language tree with indented code.", "response": "def indent_code(original_code, options=None):\n    \"\"\" indented_code(string : str, fname : str) -> [...]\n\n    Arguments:\n    fpath: Simply used in formatting the warning messages\n\n    >>> indent_code(\"(print\\n'Hello)\")\n    {'bracket_locations': [],\n     'comment_locations': [],\n     'in_comment': 0,\n     'in_newlisp_tag_string': False,\n     'in_string': False,\n     'in_symbol_with_space': False,\n     'indented_code': ['(print\\n', \" 'Hello)\"],\n     'last_quote_location': (),\n     'last_symbol_location': (),\n     'message_stack': [],\n     'newlisp_brace_locations': [],\n     'original_code': ['(print\\n', \"'Hello)\"],\n     'first_tag_string': ()}\n\n\n    The last entry in the list is the indented string.\n    \"\"\"\n\n    opts = parse_options(options)\n    keywords = add_keywords(opts)\n\n    # Safeguards against processing brackets inside strings\n    in_string = False\n\n    # newLISP use curly brackets as a syntax for multiline strings\n    # this variable here tries to keep track of that\n    in_newlisp_string = 0\n    in_newlisp_tag_string = False\n    newlisp_brace_locations = []\n    first_tag_string = ()\n\n    # zero_level helps us get the same results as Sitaram's indenter when in\n    # --no-compact mode.\n    zero_level = 0\n\n    # The two variables prevent formatting comment regions or symbols with whitespace\n    in_comment = 0\n    in_symbol_with_space = False\n    comment_locations = []\n    last_symbol_location = ()\n\n    # A in_symbol_region is the region between pipes(|   |) or in strings. This\n    # includes the comment region. This region is not to be messed with.\n    in_symbol_region = in_string or in_comment or in_symbol_with_space or \\\n        in_newlisp_string or in_newlisp_tag_string\n\n    # we need to know the line number in order to issue almost accurate messages about\n    # unclosed brackets and string\n    line_number = 1\n\n    # Stores the last position a quote was encountered so that in case there are\n    # any unclosed strings, we can pinpoint them\n    last_quote_location = ()\n\n    line_ending = find_line_ending(original_code)\n    code_lines = split_preserve(original_code, line_ending)\n\n    indented_code = []\n\n    bracket_locations = []\n\n    # List of warnings from errors in the code\n    message_stack = []\n\n    for line in code_lines:\n        escaped   = False\n        curr_line = line\n\n        # Get the indent level and the indented line\n        zero_level, curr_line, indent_level = indent_line(zero_level,\n                                                          bracket_locations,\n                                                          line, in_comment,\n                                                          in_symbol_region, opts)\n        # Build up the indented string.\n        indented_code.append(curr_line)\n        regex = '^[ \\t]*'\n        lead_spaces = re.findall(regex, curr_line)\n        if lead_spaces:\n            curr_line = re.sub(regex, detabify(lead_spaces[0], opts), curr_line)\n        offset = 0\n        for curr_char in curr_line:\n            next_char = curr_line[offset + 1:offset + 2]\n            prev_char = curr_line[offset - 1:offset]\n\n            substr = curr_line[offset + 1:]  # slice to the end\n\n            if escaped:\n                # Move to the next character if the current one has been escaped\n                escaped = False\n                offset += 1\n                continue\n\n            if curr_char == '\\\\' and not in_newlisp_string and not in_newlisp_tag_string:\n                # the next character has been escaped\n                escaped = True\n\n            if (curr_char == ';' or (curr_char == '#' and opts.dialect == 'newlisp'))\\\n                    and not in_symbol_region and not \\\n                    (prev_char == '#' and opts.dialect == 'scheme'):\n                # a comment has been found, go to the next line\n                # A sharp sign(#) before a semi-colon in Scheme is used to\n                # comment out sections of code. We don't treat it as a comment\n                break\n\n            # ----------------------------------------------------------\n            # Comments are dealt with here. Clojure and newLISP don't have Lisp\n            # style multiline comments so don't include them.\n            if opts.dialect not in ['clojure', 'newlisp'] and curr_char == '|' \\\n                    and not in_string:\n                if prev_char == '#' and not in_symbol_with_space:\n                    comment_locations.append((line_number, offset))\n                    in_comment += 1\n                elif in_comment and next_char == '#':\n                    in_comment -= 1\n                    comment_locations.pop()\n                elif not in_comment:\n                    if in_symbol_with_space:\n                        last_symbol_location = ()\n                        in_symbol_with_space = False\n                    else:\n                        last_symbol_location = (line_number, offset)\n                        in_symbol_with_space = True\n\n            # ----------------------------------------------------------\n\n            # Strings are dealt with here only if we are not comment\n            if not (in_symbol_with_space or in_comment or in_newlisp_tag_string):\n                if curr_char == '\"':\n                    last_quote_location = (line_number, offset)\n                    in_string = True if not in_string else False\n                if opts.dialect == 'newlisp' and not in_string:\n                    # We handle newLISP's multiline(brace) string here. Brace\n                    # strings can nest\n                    if curr_char == '{':\n                        newlisp_brace_locations.append((line_number, offset))\n                        in_newlisp_string += 1\n                    elif curr_char == '}':\n                        if newlisp_brace_locations:\n                            newlisp_brace_locations.pop()\n                        else:\n                            message = \"Attempt to close a non-existent newLISP string\"\n                            warning_info = {\n                                'msg': message,\n                                'line': line_number,\n                                'column': offset\n                            }\n                            message_stack.append(warning_info)\n                        in_newlisp_string -= 1\n\n            if curr_char == '[' and opts.dialect == 'newlisp' and not \\\n                    (in_newlisp_string or in_string):\n                # We have to handle tag strings in newLISP here.\n                if re.match('\\[text\\]', curr_line[offset:offset + 7]):\n                    in_newlisp_tag_string = True\n                    if first_tag_string == ():\n                        first_tag_string = (line_number, offset)\n                elif re.match('\\[/text\\]', curr_line[offset:offset + 7]):\n                    in_newlisp_tag_string = False\n                    first_tag_string = ()\n\n            in_symbol_region = in_string or in_comment or in_symbol_with_space \\\n                or in_newlisp_string or in_newlisp_tag_string\n\n            if in_symbol_region:\n                # move on if we are in a string, a symbol with a space or a comment\n                # altogether known as the symbol region\n                offset += 1\n                continue\n\n            # Finds the real position of a bracket to be used in pinpointing where\n            # the unclosed bracket is. The real position is different from the offset\n            # because current offset is the position of the bracket in the\n            # trimmed string not the original.\n            real_position = (offset - zero_level) + \\\n                len(re.findall('^[ \\t]*', line)[0]) - indent_level\n            if curr_char in ['(', '[', '{']:\n                if curr_char in ['[', '{'] and opts.dialect in ['lisp', 'newlisp']:\n                    # Square/Curly brackets are used should not contribute to\n                    # the indentation in CL and newLISP\n                    offset += 1\n                    continue\n\n                first_arg_pos, spaces_before_func = \\\n                    find_first_arg_pos(offset, curr_line, opts)\n                func_name = substr[0:first_arg_pos - 1].strip(')]\\t\\n\\r ').lower()\n                in_list_literal = False\n                if re.search(\"[^#]('|`|#)([ \\t]*\\(|\\[)($|\\r)\", curr_line[0:offset + 1]):\n                    in_list_literal = True\n\n                if re.search('^[^ \\t]+[ \\t]*($|\\r)', substr):\n                    # The function is the last symbol/form in the line\n                    func_name = substr.strip(')]\\t\\n\\r ').lower()\n\n                if in_list_literal:\n                    # an empty string is always in a non-empty string, we don't want\n                    # this. We set False as the func_name because it's not a string\n                    # in_list_literal prevents an keyword in a list literal from\n                    # affecting the indentation\n                    func_name = ''\n\n                if func_name in ['define-macro', 'defmacro']:\n                    # Macro names are part of two space indenters.\n                    # This part tries to find the name so that it is not indented\n                    # like a function the next time it's used.\n                    end_of_space = re.search('^[ \\t]*', substr).end()\n                    substr = substr[end_of_space:]\n                    substr = substr[re.search('[ \\t]*', substr).start():].strip()\n                    macro_name = substr[:substr.find(' ')]  # macro name is delimeted by whitespace\n                    if macro_name != '':\n                        keywords[macro_name] = KEYWORD1\n\n                # first_item stores the position of the first item in the literal list\n                # it's necessary so that we don't assume that the first item is always\n                # after the opening bracket.\n                first_item = re.search('[ \\t]*', curr_line[offset + 1:]).end() + offset + 1\n                bracket_locations = _push_to_list(bracket_locations[:], func_name,\n                                                  curr_char, line_number, offset,\n                                                  first_arg_pos, first_item,\n                                                  in_list_literal,\n                                                  spaces_before_func, opts)\n\n            elif curr_char in [']', ')', '}']:\n                if curr_char in [']', '}'] and opts.dialect in ['lisp', 'newlisp']:\n                    # Square/Curly brackets are used should not contribute to\n                    # the indentation in CL and newLISP\n                    offset += 1\n                    continue\n\n                bracket_locations = _pop_from_list(curr_char, bracket_locations[:],\n                                                   line_number, real_position,\n                                                   offset, message_stack)\n\n            if bracket_locations and curr_char in [' ', '\\t'] and \\\n                    keywords[bracket_locations[-1]['func_name']] == KEYWORD2:\n                # This part changes the indentation level of a then clause so that\n                # we can achieve something like:\n                #         (if (= this that)\n                #             'then-form\n                #           'else-form)\n                # This is done by keeping track of the number of spaces found. If\n                # you find two spaces it means that, for example that we have just\n                # passed the then-form and hence should decrease the indentation\n                # level by 2.(I shamelessly copied this algorithm from Dorai's\n                # indenter)\n                if prev_char not in [' ', '\\t', ''] or not \\\n                        re.search('^[ \\t]*(;|#\\||$|\\r)', curr_line):\n                    # The level shouldn't be decreased if the line is a comment\n                    # line. The regex above takes care of that.\n                    bracket_locations[-1]['spaces'] += 1\n                if bracket_locations[-1]['spaces'] == 2:\n                    bracket_locations[-1]['indent_level'] -= \\\n                        0 if opts.uniform else opts.indent_size\n                    # some dummy value to prevent control from reaching here again\n                    bracket_locations[-1]['spaces'] = 999\n\n            offset += 1\n        line_number += 1\n    res = {\n        'message_stack': message_stack,\n        'first_tag_string': first_tag_string,\n        'in_newlisp_tag_string': in_newlisp_tag_string,\n        'last_symbol_location': last_symbol_location,\n        'comment_locations': comment_locations,\n        'newlisp_brace_locations': newlisp_brace_locations,\n        'in_string': in_string,\n        'in_comment': in_comment,\n        'in_symbol_with_space': in_symbol_with_space,\n        'bracket_locations': bracket_locations,\n        'last_quote_location': last_quote_location,\n        'original_code': code_lines,\n        'indented_code': indented_code\n    }\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprints diff text to terminal in colorama", "response": "def colour_diff(diff_lines):\n    \"\"\" colour_diff(diff_lines : lst)\n\n    Print diff text to terminal in color\n    \"\"\"\n\n    try:\n        import colorama\n    except ImportError:\n        # colorama is not available, print plain diff\n        print(''.join(list(diff_lines)))\n        return\n\n    colorama.init()\n\n    def p_green(text):\n        \"\"\" Print added line in green \"\"\"\n        print(colorama.Fore.GREEN + text + colorama.Fore.WHITE, end='')\n\n    def p_yellow(text):\n        \"\"\" Print diff section header in yellow \"\"\"\n        print(colorama.Fore.YELLOW + text + colorama.Fore.WHITE, end='')\n\n    def p_red(text):\n        \"\"\" Print removed line in red \"\"\"\n        print(colorama.Fore.RED + text + colorama.Fore.WHITE, end='')\n    section = re.compile('@@\\s+-\\d\\d,\\d\\d\\s\\+\\d\\d,\\d\\d\\s+@@')\n    for line in diff_lines:\n        if line.startswith('-'):\n            p_red(line)\n        elif line.startswith('+'):\n            p_green(line)\n        elif section.search(line):\n            p_yellow(line)\n        else:\n            print(line, end='')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nindenting the files in the current directory and return the indented code.", "response": "def indent_files(arguments):\n    \"\"\" indent_files(fname : str)\n\n    1. Creates a backup of the source file(backup_source_file())\n    2. Reads the files contents(read_file())\n    3. Indents the code(indent_code())\n    4. Writes the file or print the indented code(_after_indentation())\n    \"\"\"\n    opts = parse_options(arguments)\n    if not opts.files:\n        # Indent from stdin\n        code = sys.stdin.read()\n        indent_result = indent_code(code, opts)\n        _after_indentation(indent_result)\n\n    for fname in opts.files:\n        code = read_file(fname)\n        if not opts.dialect:\n            # Guess dialect from the file extensions if none is specified in the\n            # command line\n            if fname.endswith('.lisp'):\n                opts.dialect = 'lisp'\n            elif fname.endswith('.lsp'):\n                opts.dialect = 'newlisp'\n            elif re.search(\".clj[sc]{0,1}$\", fname):\n                opts.dialect = 'clojure'\n            elif fname.endswith('.ss') or fname.endswith('.scm'):\n                opts.dialect = 'scheme'\n            else:\n                opts.dialect = 'all'\n        indent_result = indent_code(code, opts)\n\n        if opts.backup:\n            # Create a backup file in the directory specified\n            backup_source_file(fname, opts)\n\n        _after_indentation(indent_result, fpath=fname)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the URL for a single image.", "response": "def get_url(\n    width, height=None, background_color=\"cccccc\",\n    text_color=\"969696\", text=None, random_background_color=False\n):\n    \"\"\"\n    Craft the URL for a placeholder image.\n\n    You can customize the background color, text color and text using\n    the optional keyword arguments\n\n    If you want to use a random color pass in random_background_color as True.\n    \"\"\"\n    if random_background_color:\n        background_color = _get_random_color()\n\n    # If height is not provided, presume it is will be a square\n    if not height:\n        height = width\n    d = dict(\n        width=width,\n        height=height,\n        bcolor=background_color,\n        tcolor=text_color\n    )\n    url = URL % d\n    if text:\n        text = text.replace(\" \", \"+\")\n        url = url + \"?text=\" + text\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef preserve_builtin_query_params(url, request=None):\n    if request is None:\n        return url\n\n    overrides = [\n        api_settings.URL_FORMAT_OVERRIDE,\n    ]\n\n    for param in overrides:\n        if param and (param in request.GET):\n            value = request.GET[param]\n            url = replace_query_param(url, param, value)\n\n    return url", "response": "Given an incoming request and an outgoing URL representation append any built - in query parameters."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreverse the given viewname args and kwargs and request.", "response": "def reverse(viewname, args=None, kwargs=None, request=None, format=None, **extra):\n    \"\"\"\n    If versioning is being used then we pass any `reverse` calls through\n    to the versioning scheme instance, so that the resulting URL\n    can be modified if needed.\n    \"\"\"\n    scheme = getattr(request, 'versioning_scheme', None)\n    if scheme is not None:\n        try:\n            url = scheme.reverse(viewname, args, kwargs, request, format, **extra)\n        except NoReverseMatch:\n            # In case the versioning scheme reversal fails, fallback to the\n            # default implementation\n            url = _reverse(viewname, args, kwargs, request, format, **extra)\n    else:\n        url = _reverse(viewname, args, kwargs, request, format, **extra)\n\n    return preserve_builtin_query_params(url, request)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _reverse(viewname, args=None, kwargs=None, request=None, format=None, **extra):\n    if format is not None:\n        kwargs = kwargs or {}\n        kwargs['format'] = format\n    url = django_reverse(viewname, args=args, kwargs=kwargs, **extra)\n    if request:\n        return request.build_absolute_uri(url)\n    return url", "response": "Same as django. core. urlresolvers. reverse but optionally takes a request\n    and returns a fully qualified URL using the request to get the base URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndecomposes this MIZ into json structure.", "response": "def decompose(miz_file: Path, output_folder: Path):\n        \"\"\"\n        Decompose this Miz into json\n\n        Args:\n            output_folder: folder to output the json structure as a Path\n            miz_file: MIZ file path as a Path\n        \"\"\"\n        mission_folder, assets_folder = NewMiz._get_subfolders(output_folder)\n        NewMiz._wipe_folders(mission_folder, assets_folder)\n        LOGGER.info('unzipping mission file')\n        with Miz(miz_file) as miz:\n            version = miz.mission.d['version']\n            LOGGER.debug(f'mission version: \"%s\"', version)\n\n            LOGGER.info('copying assets to: \"%s\"', assets_folder)\n            ignore = shutil.ignore_patterns('mission')\n            shutil.copytree(str(miz.temp_dir), str(assets_folder), ignore=ignore)\n\n            NewMiz._reorder_warehouses(assets_folder)\n\n            LOGGER.info('decomposing mission table into: \"%s\" (this will take a while)', mission_folder)\n            NewMiz._decompose_dict(miz.mission.d, 'base_info', mission_folder, version, miz)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef recompose(src: Path, target_file: Path):\n        mission_folder, assets_folder = NewMiz._get_subfolders(src)\n        # pylint: disable=c-extension-no-member\n        base_info = ujson.loads(Path(mission_folder, 'base_info.json').read_text(encoding=ENCODING))\n        version = base_info['__version__']\n        with Miz(target_file) as miz:\n            LOGGER.info('re-composing mission table from folder: \"%s\"', mission_folder)\n            miz.mission.d = NewMiz._recreate_dict_from_folder(mission_folder, version)\n            for item in assets_folder.iterdir():\n                target = Path(miz.temp_dir, item.name).absolute()\n                if item.is_dir():\n                    if target.exists():\n                        shutil.rmtree(target)\n                    shutil.copytree(item.absolute(), target)\n                elif item.is_file():\n                    shutil.copy(item.absolute(), target)\n            miz.zip(target_file, encode=False)", "response": "Recompose a Miz from a json object containing the json structure"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle the entry point for the class.", "response": "def handle(self, *args, **options):\n        \"\"\"\n        Sets options common to all commands.\n        Any command subclassing this object should implement its own\n        handle method, as is standard in Django, and run this method\n        via a super call to inherit its functionality.\n        \"\"\"\n\n        # Create a data directory\n        self.data_dir = os.path.join(\n            settings.BASE_DIR,\n            'data')\n        if not os.path.exists(self.data_dir):\n            os.makedirs(self.data_dir)\n\n        # Start the clock\n        self.start_datetime = datetime.now()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _save_file(self, filename, contents):\n        with open(filename, 'w') as f:\n            f.write(contents)", "response": "write the html file contents to disk"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nextracts lexical features from given token", "response": "def lexical(token):\n    \"\"\"\n    Extract lexical features from given token\n    There are 3 kinds of lexical features, take 'Hello' as an example:\n\n    1. lowercase: 'hello'\n    2. first4: 'hell'\n    3. last4: 'ello'\n    \"\"\"\n    lowercase = token.lower()\n    first4 = lowercase[:4]\n    last4 = lowercase[-4:]\n    return OrderedDict([\n            ('lowercase', lowercase), \n            ('first4', first4),\n            ('last4', last4)\n            ])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract orthographic features from a given token", "response": "def orthographic(token):\n    \"\"\"\n    Extract orthographic features from a given token\n    \n    There are 11 kinds of orthographic features, take 'Windows10' as an example:\n\n    1. shape: 'Aaaaaaa00'\n    2. length: 9\n    3. contains_a_letter: True\n    4. contains_a_capital: True\n    5. begins_with_capital: True\n    6. all_capital: False\n    7. contains_a_digit: True\n    8. all_digit: False\n    9. contains_a_punctuation: False\n    10. consists_letters_n_digits: True\n    11. consists_digits_n_punctuations: False\n    \"\"\"\n\n    return OrderedDict([\n                    ('shape', _shape(token)), \n                    ('length', len(token)), \n                    ('contains_a_letter', _contains_a_letter(token)), \n                    ('contains_a_capital', _contains_a_capital(token)),\n                    ('begins_with_capital', _begins_with_capital(token)), \n                    ('all_capital', _all_capital(token)), \n                    ('contains_a_digit', _contains_a_digit(token)),\n                    ('all_digit', _all_digit(token)),\n                    ('contains_a_punctuation', _contains_a_punctuation(token)),\n                    ('consists_letters_n_digits', _consists_letters_n_digits(token)),\n                    ('consists_digits_n_punctuations', _consists_digits_n_punctuations(token)),\n                   ])"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets sqlalchemy db session.", "response": "def get_session(url):\n    \"\"\"Get db session.\n\n    :param url: URL for connect with DB\n    :type url: :class:`str`\n\n    :returns: A sqlalchemy db session\n    :rtype: :class:`sqlalchemy.orm.Session`\n\n    \"\"\"\n    engine = create_engine(url)\n    db_session = scoped_session(sessionmaker(engine))\n    Base.metadata.create_all(engine)\n    return db_session"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a list of identifiers as strings construct a dictionary of the keys and values of the ientifiers as the values.", "response": "def getBindings(varList, startLevel=0):\n    \"\"\"Given a list of identifiers as strings, construct the dictonary of the identifiers as keys and the evaluated values of\n    the ientifiers as the values. Ie something like {id:full_lookup(id) for id in identifiers}. full_lookup here is looking\n    up the value of an identifier by looking at all the bindings at every level in the call stack.\n    Return (bindings,unbound) where the bindings is the dictionary of found bindings and the set of unbound identifiers.\"\"\"\n    varsToFind = set(varList)\n    bindings = {}\n    \n    # We start at the level of the caller of getBindings\n    frame = inspect.currentframe()\n    try:\n        for i in xrange(startLevel+1):\n            frame = frame.f_back\n    except:\n        raise Exception(\"bindings: startLevel {} is too high\\n\".format(startLevel))\n    \n    # while we have a current frame look through it for our identifiers\n    while frame:\n        frameLocals = frame.f_locals\n        localKeys = set(varsToFind).intersection(frameLocals)\n        for v in localKeys:\n            bindings[v]=frameLocals[v]\n        varsToFind -= localKeys\n        if not varsToFind:\n            return (bindings,varsToFind)\n\n        frameGlobals = frame.f_globals\n        globalKeys = set(varsToFind).intersection(frameGlobals)\n        for v in globalKeys:\n            bindings[v]=frameGlobals[v]\n        varsToFind -= localKeys\n        if not varsToFind:\n            return (bindings,varsToFind)\n\n        frame = frame.f_back\n\n    return (bindings,varsToFind)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _AsynchronouslyGetProcessOutput(formattedCmd, printStdOut, printStdErr, **kwargs):\n    ''' Asynchronously read the process '''\n    opts = filterKWArgsForFunc(kwargs, subprocess.Popen)\n    opts['stdout'] = subprocess.PIPE\n    opts['stderr'] = subprocess.PIPE\n    process = subprocess.Popen(formattedCmd, **opts)\n\n    # Launch the asynchronous readers of the process' stdout and stderr.\n    stdout_queue = Queue.Queue()\n    stdout_reader = _AsynchronousFileReader(process.stdout, stdout_queue)\n    stdout_reader.start()\n    stderr_queue = Queue.Queue()\n    stderr_reader = _AsynchronousFileReader(process.stderr, stderr_queue)\n    stderr_reader.start()\n\n    stdOutLines = []\n    stdErrLines = []\n    # Check the queues if we received some output (until there is nothing more to get).\n    while not stdout_reader.eof() or not stderr_reader.eof():\n        # Show what we received from standard output.\n        while not stdout_queue.empty():\n            line = stdout_queue.get()\n            stdOutLines.append(line)\n            if printStdOut:\n                print line.rstrip()\n \n        # Show what we received from standard error.\n        while not stderr_queue.empty():\n            line = stderr_queue.get()\n            stdErrLines.append(line)\n            if printStdErr:\n                print colored(line.rstrip(),'red')\n \n        # Sleep a bit before asking the readers again.\n        time.sleep(.05)\n \n    # Let's be tidy and join the threads we've started.\n    stdout_reader.join()\n    stderr_reader.join()\n \n    # Close subprocess' file descriptors.\n    process.stdout.close()\n    process.stderr.close()\n    process.wait()\n\n    stdOut = ''.join(stdOutLines)\n    stdErr = ''.join(stdErrLines)\n    return (process.returncode, stdOut, stdErr)", "response": "Asynchronously read the process stdout and stderr and return the output."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef execute(cmd, verbosityThreshold = 1, **kwargs):\n    '''execute the passed in command in the shell'''\n    global exectue_defaults\n    opts = merge(exectue_defaults, kwargs)              # the options computed from the default options together with the passed in options.\n    subopts = filterKWArgsForFunc(opts, subprocess.Popen)\n    formattedCmd = cmd.format(**getFormatBindings(cmd,1))\n\n    shouldPrint = opts['verbosity'] >= verbosityThreshold\n    isDryrun = opts['dryrun']\n\n    if shouldPrint:\n        msg = \"would execute:\" if isDryrun else \"executing:\"\n        pre = \"(\"+subopts['cwd']+\")\" if (subopts['cwd'] != exectue_defaults['cwd']) else \"\"\n        print \"{pre}{msg} {formattedCmd}\".format(pre=pre, formattedCmd=formattedCmd, msg=msg)\n    if isDryrun:\n        return (0, None, None)\n\n    printStdOut = shouldPrint and opts['permitShowingStdOut']\n    printStdErr = shouldPrint and opts['permitShowingStdErr']\n    returnCode = 0\n    if opts['captureStdOutStdErr']:\n        (returnCode, stdOut, stdErr) = _AsynchronouslyGetProcessOutput(formattedCmd, printStdOut, printStdErr, **subopts)    \n    else:\n        subopts['stdout'] = None if printStdOut else subprocess.PIPE\n        subopts['stderr'] = None if printStdErr else subprocess.PIPE\n        process = subprocess.Popen(formattedCmd, **subopts)\n        res = process.communicate()\n        returnCode = process.returncode\n        stdOut = res[0]\n        stdErr = res[1]\n\n    if returnCode and not opts['ignoreErrors']:\n        print colored('Command {} failed with return code {}!'.format(cmd, returnCode),'red')\n        sys.exit(returnCode)\n    \n    # always print any errors\n    return (returnCode, stdOut, stdErr)", "response": "execute the passed in command in the shell"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _compare_columns(self, new_columns, old_columns):\n        \n        ''' a helper method for generating differences between column properties '''\n        \n        # print(new_columns)\n        # print(old_columns)\n        \n        add_columns = {}\n        remove_columns = {}\n        rename_columns = {}\n        retype_columns = {}\n        resize_columns = {}\n        for key, value in new_columns.items():\n            if key not in old_columns.keys():\n                add_columns[key] = True\n                if value[2]:\n                    if value[2] in old_columns.keys():\n                        rename_columns[key] = value[2]\n                        del add_columns[key]\n            else:\n                if value[1] != old_columns[key][1]:\n                    retype_columns[key] = value[1]\n                if value[3] != old_columns[key][3]:\n                    resize_columns[key] = value[3]\n        remove_keys = set(old_columns.keys()) - set(new_columns.keys())\n        if remove_keys:\n            for key in list(remove_keys):\n                remove_columns[key] = True\n        \n        return add_columns, remove_columns, rename_columns, retype_columns, resize_columns", "response": "a helper method for generating differences between column properties"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _construct_inserts(self, record, new_columns, rename_columns, retype_columns, resize_columns):\n\n        ''' a helper method for constructing the insert kwargs for a record '''\n\n        insert_kwargs = {}\n\n        for key, value in new_columns.items():\n\n        # retrieve value for key (or from old key name)\n            if key in rename_columns.keys():\n                record_value = getattr(record, rename_columns[key], None)\n            else:\n                record_value = getattr(record, key, None)\n\n        # attempt to convert datatype\n            if record_value:\n                if key in retype_columns.keys():\n                    try:\n                        old_list = False\n                        if isinstance(record_value, bytes):\n                            record_value = pickle.loads(record_value)\n                            old_list = True\n                        if retype_columns[key] == 'boolean':\n                            record_value = bool(record_value)\n                        elif retype_columns[key] == 'string':\n                            if old_list:\n                                record_value = ','.join(record_value)\n                            else:\n                                record_value = str(record_value)\n                        elif retype_columns[key] == 'integer':\n                            if old_list:\n                                record_value = int(record_value[0])\n                            else:\n                                record_value = int(record_value)\n                        elif retype_columns[key] == 'float':\n                            if old_list:\n                                record_value = int(record_value[0])\n                            else:\n                                record_value = float(record_value)\n                        elif retype_columns[key] == 'list':\n                            if isinstance(record_value, str):\n                                record_value = pickle.dumps(record_value.split(','))\n                            else:\n                                record_value = pickle.dumps([record_value])\n                    except:\n                        record_value = None\n        \n        # attempt to resize string data \n                if key in resize_columns.keys():\n                    max_length = resize_columns[key]\n                    try:\n                        if len(record_value) > max_length:\n                            record_value = record_value[0:max_length]\n                    except:\n                        record_value = None\n\n                insert_kwargs[key] = record_value\n\n        return insert_kwargs", "response": "constructs the insert kwargs for a record"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrebuilding the table with the given name and columns", "response": "def _rebuild_table(self, new_name, old_name, new_columns, old_columns): \n        \n        ''' a helper method for rebuilding table (by renaming & migrating) '''\n    \n    # verbosity\n        print('Rebuilding %s table in %s database' % (self.table_name, self.database_name), end='', flush=True)\n        \n        from sqlalchemy import Table, MetaData\n        metadata_object = MetaData()\n    \n    # construct old table\n        old_table_args = [ old_name, metadata_object ]\n        old_column_args = self._construct_columns(old_columns)\n        old_table_args.extend(old_column_args)\n        old_table = Table(*old_table_args)\n    \n    # construct new table\n        new_table_args = [ new_name, metadata_object ]\n        new_column_args = self._construct_columns(new_columns)\n        new_table_args.extend(new_column_args)\n        new_table = Table(*new_table_args)\n    \n    # determine differences between tables\n        add_columns, remove_columns, rename_columns, retype_columns, resize_columns = self._compare_columns(new_columns, old_columns)\n        \n    # rename table and recreate table if it doesn't already exist\n        table_list = self.engine.table_names()\n        if not old_name in table_list:\n            self.engine.execute('ALTER TABLE %s RENAME TO %s' % (new_name, old_name))\n            new_table.create(self.engine)\n     \n    # wait for renamed table to be responsive\n                \n    # migrate records from old to new\n        list_statement = old_table.select()\n        count = 0\n        for record in self.session.execute(list_statement).fetchall():\n            create_kwargs = self._construct_inserts(record, new_columns, rename_columns, retype_columns, resize_columns)\n            insert_statement = new_table.insert().values(**create_kwargs)\n            self.session.execute(insert_statement)\n            delete_statement = old_table.delete(old_table.c.id==record.id)\n            self.session.execute(delete_statement)\n            if not count % 10:\n                print('.', end='', flush=True)\n            count += 1\n        \n    # drop old table\n        record_list = self.session.execute(list_statement).first()\n        if not record_list:\n            self.session.close()\n            old_table.drop(self.engine)\n            self.session = self.engine.connect()\n    \n    # handle verbosity   \n        print(' done.')\n        \n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef exists(self, primary_key):\n        \n        '''\n            a method to determine if record exists\n            \n        :param primary_key: string with primary key of record \n        :return: boolean to indicate existence of record\n        '''\n        \n        select_statement = self.table.select(self.table).where(self.table.c.id==primary_key)\n        record_object = self.session.execute(select_statement).first()\n        if record_object:\n            return True\n        return False", "response": "a method to determine if record exists in database"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list(self, query_criteria=None, order_criteria=None):\n        \n        '''\n            a generator method to list records in table which match query criteria\n            \n        :param query_criteria: dictionary with schema dot-path field names and query qualifiers\n        :param order_criteria: list of single keypair dictionaries with field names to order by \n        :return: generator object with string of primary key\n        \n        an example of how to construct the query_criteria argument:\n\n        query_criteria = {\n            '.path.to.number': {\n                'min_value': 4.5\n            },\n            '.path.to.string': {\n                'discrete_values': [ 'pond', 'lake', 'stream', 'brook' ]\n            }\n        }\n\n        NOTE:   sql only supports a limited number of query conditions and all list\n                fields in a record are stored as a blob. this method constructs a\n                sql query which contains clauses wherever the query conditions can\n                be translated one-to-one into sql keywords and returns the entire\n                record of each qualifying record. once sql returns its results, the\n                remaining query conditions are applied to the record and only those\n                results which match all conditions are yield by the generator. as\n                such, depending upon the conditions selected, this method acts more\n                or less like a SCAN of the entire database. if no sql supported\n                conditions are provided, the method will look through all records.\n        \n                native SQL supported conditions\n                \n                float, integer & strings:\n                    value_exists\n                    equal_to\n                    discrete_values\n                    excluded_values\n                    greater_than\n                    less_than\n                    max_value\n                    min_value\n                \n                booleans:\n                    value_exists\n                    equal_to\n                    \n                lists:\n                    value_exists\n        \n        NOTE:   the full list of all criteria are found in the reference page for the\n                jsonmodel module as well as the query-rules.json file included in the\n                module. \n                http://collectiveacuity.github.io/jsonModel/reference/#query-criteria\n        \n        an example of how to construct the order_criteria argument:\n        \n        order_criteria = [\n            { '.path.to.number': 'descend' }, \n            { '.path.to.string': '' }\n        ]\n        \n        NOTE:   results can be ordered either by ascending or descending values. to\n                order in ascending order, leave the value for the field empty. any value\n                for the field key automatically is interpreted as descending order\n        \n        '''\n        \n        title = '%s.list' % self.__class__.__name__\n        \n        from sqlalchemy import desc as order_desc\n        \n    # validate inputs\n        if query_criteria:\n            self.model.query(query_criteria)\n        else:\n            query_criteria = {}\n        if order_criteria:\n            object_title = '%s(%s=%s)' % (title, 'order_criteria', str(order_criteria))\n            self.fields.validate(order_criteria, '.order_criteria', object_title)\n            for i in range(len(order_criteria)):\n                criterion = order_criteria[i]\n                for key, value in criterion.items():\n                    criteria_key = key\n                    if key.find('.') != 0:\n                        criteria_key = '.%s' % key\n                    if criteria_key not in self.model.keyMap.keys():\n                        raise ValueError('%s(order_criteria=[...]) item %s key %s does not exist in record_schema.' % (title, i, key))\n        else:\n            order_criteria = []\n\n    # construct select statement with sql supported conditions\n    # http://docs.sqlalchemy.org/en/latest/orm/tutorial.html#common-filter-operators\n        select_object = self.table.select()\n        for key, value in query_criteria.items():\n            record_key = key\n            map_key = key\n            if key.find('.') == 0:\n                record_key = key[1:]\n            else:\n                map_key = '.%s' % key\n            if record_key:\n                if self.item_key.findall(record_key):\n                    pass\n                else:\n                    test_value = value\n                    if not isinstance(value, dict):\n                        test_value = { 'equal_to': value }\n                    column_object = getattr(self.table.c, record_key)\n                    for k, v in test_value.items():\n                        if k == 'value_exists':\n                            if self.model.keyMap[map_key]['value_datatype'] in ('string', 'number', 'boolean', 'list'):\n                                if v:\n                                    select_object = select_object.where(column_object!=None)\n                                else:\n                                    select_object = select_object.where(column_object==None)\n                        else:\n                            if self.model.keyMap[map_key]['value_datatype'] in ('string', 'number', 'boolean'):\n                                if k == 'equal_to':\n                                    select_object = select_object.where(column_object==v)\n                                elif k == 'discrete_values':\n                                    select_object = select_object.where(column_object.in_(v))\n                                elif k == 'excluded_values':\n                                    select_object = select_object.where(~column_object.in_(v))\n                                elif k == 'greater_than':\n                                    select_object = select_object.where(column_object.__gt__(v))\n                                elif k == 'less_than':\n                                    select_object = select_object.where(column_object.__lt__(v))\n                                elif k == 'max_value':\n                                    select_object = select_object.where(column_object.__le__(v))\n                                elif k == 'min_value':\n                                    select_object = select_object.where(column_object.__ge__(v))\n\n    # add order criteria\n        for criterion in order_criteria:\n            key, value = next(iter(criterion.items()))\n            record_key = key\n            if key.find('.') == 0:\n                record_key = key[1:]\n            if record_key:\n                if self.item_key.findall(record_key):\n                    pass\n                else:\n                    column_object = getattr(self.table.c, record_key)\n                    if value:\n                        select_object = select_object.order_by(order_desc(column_object))\n                    else:\n                        select_object = select_object.order_by(column_object)\n\n    # execute query on database\n        # print(select_object)\n        for record in self.session.execute(select_object).fetchall():\n            record_details = self._reconstruct_record(record)\n\n        # filter results with non-sql supported conditions\n            if query_criteria:\n                if self.model.query(query_criteria, record_details):\n                    yield record_details\n            else:\n                yield record_details", "response": "A method to list records in table which match query criteria\n            \n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read(self, primary_key):\n    \n        ''' \n            a method to retrieve the details for a record in the table \n            \n        :param primary_key: string with primary key of record \n        :return: dictionary with record fields \n        '''\n        \n        title = '%s.read' % self.__class__.__name__\n        \n    # retrieve record object\n        # record_object = self.session.query(self.record).filter_by(id=primary_key).first()\n        select_statement = self.table.select(self.table.c.id==primary_key)\n        record_object = self.session.execute(select_statement).first()\n        if not record_object:\n            raise ValueError('%s(primary_key=%s) does not exist.' % (title, primary_key))\n        \n    # reconstruct record details\n        record_details = self._reconstruct_record(record_object)\n                    \n        return record_details", "response": "a method to retrieve the details for a record in the table \n ArcGIS"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete(self, primary_key):\n        \n        ''' \n            a method to delete a record in the table\n         \n        :param primary_key: string with primary key of record \n        :return: string with status message\n        '''\n        \n        title = '%s.delete' % self.__class__.__name__\n    \n    # delete object\n        delete_statement = self.table.delete(self.table.c.id==primary_key)\n        self.session.execute(delete_statement)\n    \n    # return message\n        exit_msg = '%s has been deleted.' % primary_key\n        return exit_msg", "response": "a method to delete a record in the table by primary key"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove(self):\n        \n        ''' \n            a method to remove the entire table \n        \n        :return string with status message    \n        '''\n        \n        self.table.drop(self.engine)\n        \n        exit_msg = '%s table has been removed from %s database.' % (self.table_name, self.database_name)\n        self.printer(exit_msg)\n        \n        return exit_msg", "response": "a method to remove the entire table \n "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a name in the correct format.", "response": "def generate(self, gender=None, part=None, snake_case=False, weighted=False):\n        \"\"\"Generate a Queb name.\n\n        :param str gender: Gender of name to generate, one of 'male'\n            or 'female'. If not specified, either gender can be\n            generated. (optional)\n        :param str part: Part of the name to generate, one of 'first'\n            or 'last'. If not specified, full names are\n            generated. (optional)\n        :param bool snake_case: If True, generate a name in\n            \"snake_case\" format, also stripping diacritics if\n            any. (default: False)\n        :param bool weighted: If True, generate names according to\n            their relative popularity. (default: False)\n        :return str: The generated name.\n        \"\"\"\n        if weighted:\n            get_random_name = self._get_weighted_random_name\n        else:\n            get_random_name = self._get_random_name\n\n        if gender == 'male':\n            first_names = self._male_names\n        elif gender == 'female':\n            first_names = self._female_names\n        else:\n            first_names = self._names\n\n        name = ''\n        surname = ''\n\n        if part == 'first':\n            name = get_random_name(first_names)\n        elif part == 'last':\n            surname = get_random_name(self._surnames)\n        else:\n            name = get_random_name(first_names)\n            surname = get_random_name(self._surnames)\n\n        return self._format_name(name, surname, snake_case=snake_case)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _read_name_file(self, filename):\n        file_path = os.path.join(self._DATA_DIR, filename)\n        with open(file_path) as f:\n            names = json.load(f)\n\n        return names", "response": "Read a name file from the data directory."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_names(self):\n        names = self._read_name_file('names.json')\n        names = self._compute_weights(names)\n\n        return names", "response": "Get the list of first name entries."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the list of surname entries.", "response": "def _get_surnames(self):\n        \"\"\"Get the list of surnames.\n\n        :return: A list of surname entries.\n        \"\"\"\n        names = self._read_name_file('surnames.json')\n        names = self._compute_weights(names)\n\n        return names"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a random name from a given list.", "response": "def _get_random_name(name_list):\n        \"\"\"Get a random name from a given list.\n\n        The choice of the name is fully random.\n\n        :param name_list: The list of names from which to pick.\n        :return str: A randomly chosen name.\n        \"\"\"\n        length = len(name_list)\n        index = random.randrange(length)\n\n        return name_list[index]['name']"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_weighted_random_name(name_list):\n        total_weight = name_list[-1]['weight_high']\n        random_weight = random.randrange(total_weight + 1)\n\n        left = 0\n        right = len(name_list) - 1\n\n        while left <= right:\n            index = (left + right) // 2\n            entry = name_list[index]\n\n            if random_weight > entry['weight_high']:\n                left = index + 1\n            elif random_weight < entry['weight_low']:\n                right = index - 1\n            else:\n                return entry['name']", "response": "Get a random name from a given list according to its frequency."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _format_name(self, name, surname, snake_case=False):\n        if not name or not surname:\n            sep = ''\n        elif snake_case:\n            sep = '_'\n        else:\n            sep = ' '\n\n        if snake_case:\n            name = self._snakify_name(name)\n            surname = self._snakify_name(surname)\n\n        disp_name = '{}{}{}'.format(name, sep, surname)\n\n        return disp_name", "response": "Format a first name and a surname into a cohesive string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _sorter(n1,n2):\n    '''_sorter(n1,n2) -> int\n    Sorting predicate for non-NS attributes.'''\n\n    i = cmp(n1.namespaceURI, n2.namespaceURI)\n    if i: return i\n    return cmp(n1.localName, n2.localName)", "response": "_sorter - Sorting predicate for non - NS attributes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _utilized(n, node, other_attrs, unsuppressedPrefixes):\n    '''_utilized(n, node, other_attrs, unsuppressedPrefixes) -> boolean\n    Return true if that nodespace is utilized within the node'''\n    if n.startswith('xmlns:'):\n        n = n[6:]\n    elif n.startswith('xmlns'):\n        n = n[5:]\n    if (n==\"\" and node.prefix in [\"#default\", None]) or \\\n        n == node.prefix or n in unsuppressedPrefixes: \n            return 1\n    for attr in other_attrs:\n        if n == attr.prefix: return 1\n    # For exclusive need to look at attributes\n    if unsuppressedPrefixes is not None:\n        for attr in _attrs(node):\n            if n == attr.prefix: return 1\n            \n    return 0", "response": "Return true if that nodespace is utilized within the node"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _inclusiveNamespacePrefixes(node, context, unsuppressedPrefixes):\n    '''http://www.w3.org/TR/xml-exc-c14n/ \n    InclusiveNamespaces PrefixList parameter, which lists namespace prefixes that \n    are handled in the manner described by the Canonical XML Recommendation'''\n    inclusive = []\n    if node.prefix:\n        usedPrefixes = ['xmlns:%s' %node.prefix]\n    else:\n        usedPrefixes = ['xmlns']\n\n    for a in _attrs(node):\n        if a.nodeName.startswith('xmlns') or not a.prefix: continue\n        usedPrefixes.append('xmlns:%s' %a.prefix)\n\n    unused_namespace_dict = {}\n    for attr in context:\n        n = attr.nodeName\n        if n in unsuppressedPrefixes:\n            inclusive.append(attr)\n        elif n.startswith('xmlns:') and n[6:] in unsuppressedPrefixes:\n            inclusive.append(attr)\n        elif n.startswith('xmlns') and n[5:] in unsuppressedPrefixes:\n            inclusive.append(attr)\n        elif attr.nodeName in usedPrefixes:\n            inclusive.append(attr)\n        elif n.startswith('xmlns:'):\n            unused_namespace_dict[n] = attr.value\n\n    return inclusive, unused_namespace_dict", "response": "InclusiveNamespacePrefixes parameter which lists namespace prefixes that are not allowed by the Canonical XML Recommendation."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef Canonicalize(node, output=None, **kw):\n    '''Canonicalize(node, output=None, **kw) -> UTF-8\n\n    Canonicalize a DOM document/element node and all descendents.\n    Return the text; if output is specified then output.write will\n    be called to output the text and None will be returned\n    Keyword parameters:\n        nsdict: a dictionary of prefix:uri namespace entries\n                assumed to exist in the surrounding context\n        comments: keep comments if non-zero (default is 0)\n        subset: Canonical XML subsetting resulting from XPath\n                (default is [])\n        unsuppressedPrefixes: do exclusive C14N, and this specifies the\n                prefixes that should be inherited.\n    '''\n    if output:\n        apply(_implementation, (node, output.write), kw)\n    else:\n        s = StringIO.StringIO()\n        apply(_implementation, (node, s.write), kw)\n        return s.getvalue()", "response": "Canonicalize a DOM document or element node and all descendents."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _inherit_context(self, node):\n        '''_inherit_context(self, node) -> list\n        Scan ancestors of attribute and namespace context.  Used only\n        for single element node canonicalization, not for subset\n        canonicalization.'''\n\n        # Collect the initial list of xml:foo attributes.\n        xmlattrs = filter(_IN_XML_NS, _attrs(node))\n\n        # Walk up and get all xml:XXX attributes we inherit.\n        inherited, parent = [], node.parentNode\n        while parent and parent.nodeType == Node.ELEMENT_NODE:\n            for a in filter(_IN_XML_NS, _attrs(parent)):\n                n = a.localName\n                if n not in xmlattrs:\n                    xmlattrs.append(n)\n                    inherited.append(a)\n            parent = parent.parentNode\n        return inherited", "response": "_inherit_context - Scan ancestors of attribute and namespace context. Used only\n        for single element node canonicalization not for subset\n        canonicalization."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprocess a document node.", "response": "def _do_document(self, node):\n        '''_do_document(self, node) -> None\n        Process a document node. documentOrder holds whether the document\n        element has been encountered such that PIs/comments can be written\n        as specified.'''\n\n        self.documentOrder = _LesserElement\n        for child in node.childNodes:\n            if child.nodeType == Node.ELEMENT_NODE:\n                self.documentOrder = _Element        # At document element\n                self._do_element(child)\n                self.documentOrder = _GreaterElement # After document element\n            elif child.nodeType == Node.PROCESSING_INSTRUCTION_NODE:\n                self._do_pi(child)\n            elif child.nodeType == Node.COMMENT_NODE:\n                self._do_comment(child)\n            elif child.nodeType == Node.DOCUMENT_TYPE_NODE:\n                pass\n            else:\n                raise TypeError, str(child)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprocesses a text or CDATA node.", "response": "def _do_text(self, node):\n        '''_do_text(self, node) -> None\n        Process a text or CDATA node.  Render various special characters\n        as their C14N entity representations.'''\n        if not _in_subset(self.subset, node): return\n        s = string.replace(node.data, \"&\", \"&amp;\")\n        s = string.replace(s, \"<\", \"&lt;\")\n        s = string.replace(s, \">\", \"&gt;\")\n        s = string.replace(s, \"\\015\", \"&#xD;\")\n        if s: self.write(s)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprocessing a PI node.", "response": "def _do_pi(self, node):\n        '''_do_pi(self, node) -> None\n        Process a PI node. Render a leading or trailing #xA if the\n        document order of the PI is greater or lesser (respectively)\n        than the document element.\n        '''\n        if not _in_subset(self.subset, node): return\n        W = self.write\n        if self.documentOrder == _GreaterElement: W('\\n')\n        W('<?')\n        W(node.nodeName)\n        s = node.data\n        if s:\n            W(' ')\n            W(s)\n        W('?>')\n        if self.documentOrder == _LesserElement: W('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprocessing a comment node.", "response": "def _do_comment(self, node):\n        '''_do_comment(self, node) -> None\n        Process a comment node. Render a leading or trailing #xA if the\n        document order of the comment is greater or lesser (respectively)\n        than the document element.\n        '''\n        if not _in_subset(self.subset, node): return\n        if self.comments:\n            W = self.write\n            if self.documentOrder == _GreaterElement: W('\\n')\n            W('<!--')\n            W(node.data)\n            W('-->')\n            if self.documentOrder == _LesserElement: W('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _do_element(self, node, initial_other_attrs = [], unused = None):\n        '''_do_element(self, node, initial_other_attrs = [], unused = {}) -> None\n        Process an element (and its children).'''\n\n        # Get state (from the stack) make local copies.\n        #   ns_parent -- NS declarations in parent\n        #   ns_rendered -- NS nodes rendered by ancestors\n        #        ns_local -- NS declarations relevant to this element\n        #   xml_attrs -- Attributes in XML namespace from parent\n        #       xml_attrs_local -- Local attributes in XML namespace.\n        #   ns_unused_inherited -- not rendered namespaces, used for exclusive \n        ns_parent, ns_rendered, xml_attrs = \\\n                self.state[0], self.state[1].copy(), self.state[2].copy() #0422\n                \n        ns_unused_inherited = unused\n        if unused is None:\n            ns_unused_inherited = self.state[3].copy()\n            \n        ns_local = ns_parent.copy()\n        inclusive = _inclusive(self)\n        xml_attrs_local = {}\n\n        # Divide attributes into NS, XML, and others.\n        other_attrs = []\n        in_subset = _in_subset(self.subset, node)\n        for a in initial_other_attrs + _attrs(node):\n            if a.namespaceURI == XMLNS.BASE:\n                n = a.nodeName\n                if n == \"xmlns:\": n = \"xmlns\"        # DOM bug workaround\n                ns_local[n] = a.nodeValue\n            elif a.namespaceURI == XMLNS.XML:\n                if inclusive or (in_subset and  _in_subset(self.subset, a)): #020925 Test to see if attribute node in subset\n                    xml_attrs_local[a.nodeName] = a #0426\n            else:\n                if  _in_subset(self.subset, a):     #020925 Test to see if attribute node in subset\n                    other_attrs.append(a)\n                    \n#                # TODO: exclusive, might need to define xmlns:prefix here\n#                if not inclusive and a.prefix is not None and not ns_rendered.has_key('xmlns:%s' %a.prefix):\n#                    ns_local['xmlns:%s' %a.prefix] = ??\n\n            #add local xml:foo attributes to ancestor's xml:foo attributes\n            xml_attrs.update(xml_attrs_local)\n\n        # Render the node\n        W, name = self.write, None\n        if in_subset: \n            name = node.nodeName\n            if not inclusive:\n                if node.prefix is not None:\n                    prefix = 'xmlns:%s' %node.prefix\n                else:\n                    prefix = 'xmlns'\n                    \n                if not ns_rendered.has_key(prefix) and not ns_local.has_key(prefix):\n                    if not ns_unused_inherited.has_key(prefix):\n                        raise RuntimeError,\\\n                            'For exclusive c14n, unable to map prefix \"%s\" in %s' %(\n                            prefix, node)\n                    \n                    ns_local[prefix] = ns_unused_inherited[prefix]\n                    del ns_unused_inherited[prefix]\n                \n            W('<')\n            W(name)\n\n            # Create list of NS attributes to render.\n            ns_to_render = []\n            for n,v in ns_local.items():\n\n                # If default namespace is XMLNS.BASE or empty,\n                # and if an ancestor was the same\n                if n == \"xmlns\" and v in [ XMLNS.BASE, '' ] \\\n                and ns_rendered.get('xmlns') in [ XMLNS.BASE, '', None ]:\n                    continue\n\n                # \"omit namespace node with local name xml, which defines\n                # the xml prefix, if its string value is\n                # http://www.w3.org/XML/1998/namespace.\"\n                if n in [\"xmlns:xml\", \"xml\"] \\\n                and v in [ 'http://www.w3.org/XML/1998/namespace' ]:\n                    continue\n\n\n                # If not previously rendered\n                # and it's inclusive  or utilized\n                if (n,v) not in ns_rendered.items():\n                    if inclusive or _utilized(n, node, other_attrs, self.unsuppressedPrefixes):\n                        ns_to_render.append((n, v))\n                    elif not inclusive:\n                        ns_unused_inherited[n] = v\n\n            # Sort and render the ns, marking what was rendered.\n            ns_to_render.sort(_sorter_ns)\n            for n,v in ns_to_render:\n                self._do_attr(n, v)\n                ns_rendered[n]=v    #0417\n\n            # If exclusive or the parent is in the subset, add the local xml attributes\n            # Else, add all local and ancestor xml attributes\n            # Sort and render the attributes.\n            if not inclusive or _in_subset(self.subset,node.parentNode):  #0426\n                other_attrs.extend(xml_attrs_local.values())\n            else:\n                other_attrs.extend(xml_attrs.values())\n            other_attrs.sort(_sorter)\n            for a in other_attrs:\n                self._do_attr(a.nodeName, a.value)\n            W('>')\n\n        # Push state, recurse, pop state.\n        state, self.state = self.state, (ns_local, ns_rendered, xml_attrs, ns_unused_inherited)\n        for c in _children(node):\n            _implementation.handlers[c.nodeType](self, c)\n        self.state = state\n\n        if name: W('</%s>' % name)", "response": "Process an element and its children."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cmp_val_salt_hash(val, salt, str_hash):\n\n    computed_hash = hashlib.sha256(val + salt).hexdigest()\n    return computed_hash == str_hash", "response": "Validate the string salt & hash and compare it with the existing hash"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a salt and hash of the object.", "response": "def gen_salt_and_hash(val=None):\n    \"\"\" Generate a salt & hash\n\n    If no string is provided then a random string will be\n    used to hash & referred to as `val`.\n\n    The salt will always be randomly generated & the hash\n    will be a sha256 hex value of the `val` & the salt as\n    a concatenated string. It follows the guidance here:\n\n        crackstation.net/hashing-security.htm#properhashing\n\n    :param val: str\n    :return: tuple of strings (salt, hash)\n    \"\"\"\n\n    if not val:\n        val = random_str()\n\n    str_salt = random_str()\n    str_hash = hashlib.sha256(val + str_salt).hexdigest()\n    return str_salt, str_hash"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a boolean if the string value represents one", "response": "def str_to_bool(val):\n    \"\"\" Return a boolean if the string value represents one\n\n    :param val: str\n    :return: bool\n    :raise: ValueError\n    \"\"\"\n\n    if isinstance(val, bool):\n        return val\n    elif val.lower() == 'true':\n        return True\n    elif val.lower() == 'false':\n        return False\n    else:\n        raise ValueError"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a datetime object if the string value represents one Taxonomy Epoch integer or an ISO 8601 compatible string is supported.", "response": "def str_to_dt(val):\n    \"\"\" Return a datetime object if the string value represents one\n\n    Epoch integer or an ISO 8601 compatible string is\n    supported.\n\n    :param val: str\n    :return: datetime\n    :raise: ValueError\n    \"\"\"\n\n    if isinstance(val, dt):\n        return val\n\n    try:\n        if val.isdigit():\n            return dt.utcfromtimestamp(float(val))\n        else:\n            return dt.strptime(val, '%Y-%m-%dT%H:%M:%S.%f')\n    except (AttributeError, TypeError):\n        raise ValueError"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the specified profile. If profile is None returns the default profile.", "response": "def getProfile(self, profile=None):\n    '''\n    Returns the specified profile (by ID or by name). If `profile` is\n    ``None`` or omitted, returns the default profile.\n    '''\n    if profile is None:\n      # todo: what if the configuration `profile.default` does not exist?\n      profile = self.config.get('DEFAULT', 'profile.default')\n    if profile in self.profiles:\n      return self.profiles[profile].init()\n    for prof in self.profiles.values():\n      if prof.name == profile:\n        return prof.init()\n    for prof in self.profiles.values():\n      if prof.name.lower() == profile.lower():\n        return prof.init()\n    raise KeyError(profile)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef configure(self, config):\n        self._level = LogLevelConverter.to_log_level(config.get_as_object(\"level\"))\n        self._source = config.get_as_string_with_default(\"source\", self._source)", "response": "Configures the component by passing configuration parameters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the references to dependent components.", "response": "def set_references(self, references):\n        \"\"\"\n        Sets references to dependent components.\n\n        :param references: references to locate the component dependencies.\n        \"\"\"\n        context_info = references.get_one_optional(Descriptor(\"pip-services\", \"context-info\", \"*\", \"*\", \"1.0\"))\n        if context_info != None and self._source == None:\n            self._source = context_info.get_name()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _format_and_write(self, level, correlation_id, error, message, *args, **kwargs):\n        if message != None and len(message) > 0 and len(kwargs) > 0:\n            message = message.format(*args, **kwargs)\n        self._write(level, correlation_id, error, message)", "response": "Formats the log message and writes it to the logger destination."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef log(self, level, correlation_id, error, message, *args, **kwargs):\n        self._format_and_write(level, correlation_id, error, message, args, kwargs)", "response": "Logs a message at the specified log level."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fatal(self, correlation_id, error, message, *args, **kwargs):\n        self._format_and_write(LogLevel.Fatal, correlation_id, error, message, args, kwargs)", "response": "Logs a fatal message that caused the process to crash."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlogs an error message.", "response": "def error(self, correlation_id, error, message, *args, **kwargs):\n        \"\"\"\n        Logs recoverable application error.\n\n        :param correlation_id: (optional) transaction id to trace execution through call chain.\n\n        :param error: an error object associated with this message.\n\n        :param message: a human-readable message to log.\n\n        :param args: arguments to parameterize the message.\n\n        :param kwargs: arguments to parameterize the message.\n        \"\"\"\n        self._format_and_write(LogLevel.Error, correlation_id, error, message, args, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlog a warning that may or may not have a negative impact.", "response": "def warn(self, correlation_id, message, *args, **kwargs):\n        \"\"\"\n        Logs a warning that may or may not have a negative impact.\n\n        :param correlation_id: (optional) transaction id to trace execution through call chain.\n\n        :param message: a human-readable message to log.\n\n        :param args: arguments to parameterize the message.\n\n        :param kwargs: arguments to parameterize the message.\n        \"\"\"\n        self._format_and_write(LogLevel.Warn, correlation_id, None, message, args, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlog an important information message.", "response": "def info(self, correlation_id, message, *args, **kwargs):\n        \"\"\"\n        Logs an important information message\n\n        :param correlation_id: (optional) transaction id to trace execution through call chain.\n\n        :param message: a human-readable message to log.\n\n        :param args: arguments to parameterize the message.\n\n        :param kwargs: arguments to parameterize the message.\n        \"\"\"\n        self._format_and_write(LogLevel.Info, correlation_id, None, message, args, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlogs a debug message for troubleshooting.", "response": "def debug(self, correlation_id, message, *args, **kwargs):\n        \"\"\"\n        Logs a high-level debug information for troubleshooting.\n\n        :param correlation_id: (optional) transaction id to trace execution through call chain.\n\n        :param message: a human-readable message to log.\n\n        :param args: arguments to parameterize the message.\n\n        :param kwargs: arguments to parameterize the message.\n        \"\"\"\n        self._format_and_write(LogLevel.Debug, correlation_id, None, message, args, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef trace(self, correlation_id, message, *args, **kwargs):\n        self._format_and_write(LogLevel.Trace, correlation_id, None, message, args, kwargs)", "response": "Logs a debug message through the call chain."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef players_from_fantasypros_cheatsheet(file):\n\n    with open(file, newline='') as csvfile:\n        # Note - considered using a generator for this, but I don't want to hold the file open\n        # for a long time and it's pretty small anyway.\n        players = []\n        playerindex = 0\n        playerreader = reader(csvfile, delimiter=',')\n        linecount = 0\n        for row in playerreader:\n            if linecount > 1:\n                raw_name = row[0]\n                name = raw_name[:raw_name.find('(') - 1]\n                position_text = raw_name[raw_name.find('(') + 1:raw_name.find('-') - 1]\n                position = Position[position_text]\n                value = int(row[2].replace('$', ''))\n                players.append(Player(name, position, value, linecount-2))\n                playerindex += 1\n            linecount += 1\n    return players", "response": "Returns a list of Players from a standard ChEMATS cheatsheet file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_ipv6(ip_str):\n\n    try:\n        socket.inet_pton(socket.AF_INET6, ip_str)\n    except socket.error:\n        return False\n    return True", "response": "Check if the given string is a valid IP v6."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_ipv4(ip_str):\n    try:\n        socket.inet_pton(socket.AF_INET, ip_str)\n    except AttributeError:\n        try:\n            socket.inet_aton(ip_str)\n        except socket.error:\n            return False\n        return ip_str.count('.') == 3\n    except socket.error:\n        return False\n    return True", "response": "Check if the given string is a valid IP v4."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating string to sign using giving prepared request", "response": "def gen_str_to_sign(self, req):\n        \"\"\"Generate string to sign using giving prepared request\"\"\"\n        url = urlsplit(req.url)\n        bucket_name = url.netloc.split(\".\", 1)[0]\n\n        logger.debug(req.headers.items())\n        ucloud_headers = [\n            (k, v.strip())\n            for k, v in sorted(req.headers.lower_items())\n            if k.startswith(\"x-ucloud-\")\n        ]\n        canonicalized_headers = \"\\n\".join([\n            \"{0}:{1}\".format(k, v) for k, v in ucloud_headers\n        ])\n\n        canonicalized_resource = \"/{0}{1}\".format(\n            bucket_name,\n            unquote(url.path)\n        )\n\n        str_to_sign = \"\\n\".join([\n            req.method,\n            req.headers.get(\"content-md5\", \"\"),\n            req.headers.get(\"content-type\", \"\"),\n            req.headers.get(\"date\", self._expires),\n            canonicalized_headers + canonicalized_resource\n        ])\n        return str_to_sign"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fill_all_headers(self, req):\n        url = urlsplit(req.url)\n\n        content_type, __ = mimetypes.guess_type(url.path)\n        if content_type is None:\n            content_type = self.DEFAULT_TYPE\n            logger.warn(\"can not determine mime-type for {0}\".format(url.path))\n        if self._expires is None:\n            # sign with url, no content-type for url\n            req.headers.setdefault(\"content-type\", content_type)\n\n        if (\n            req.body is not None\n            and req.headers.get(\"content-md5\") is None\n            and self._allow_empty_md5 is False\n        ):\n            logger.debug(\"calculating content-md5\")\n            content, content_md5 = utils.cal_content_md5(req.body)\n            req.body = content\n            req.headers[\"content-md5\"] = content_md5\n            logger.debug(\"new content-md5 is: {0}\".format(content_md5))\n        else:\n            logger.debug(\"skip content-md5 calculation\")\n\n        if self._expires is None:\n            req.headers.setdefault(\n                \"date\",\n                time.strftime(self.DATE_FMT, time.gmtime())\n            )\n        return req", "response": "Set content - type content - md5 date to the request."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_old_options(cli, image):\n    return {\n        'cmd': dockerapi.inspect_config(cli, image, 'Cmd'),\n        'entrypoint': dockerapi.inspect_config(cli, image, 'Entrypoint'),\n    }", "response": "Returns Dockerfile values for CMD and Entrypoint"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef restore_image_options(cli, image, options):\n    dockerfile = io.StringIO()\n\n    dockerfile.write(u'FROM {image}\\nCMD {cmd}'.format(\n        image=image, cmd=json.dumps(options['cmd'])))\n\n    if options['entrypoint']:\n        dockerfile.write(\n            '\\nENTRYPOINT {}'.format(json.dumps(options['entrypoint'])))\n\n    cli.build(tag=image, fileobj=dockerfile)", "response": "Restores CMD and ENTRYPOINT values of the image"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_code_in_container(cli, image, code, mount, entrypoint):\n    kwargs = {\n        'image': image,\n    }\n\n    if entrypoint:\n        kwargs['entrypoint'] = '/bin/bash'\n        kwargs['command'] = '-c {}'.format(quote(code))\n    else:\n        kwargs['command'] = '/bin/bash -c {}'.format(quote(code))\n\n    if mount:\n        binds = []\n        volumes = []\n\n        for m in mount:\n            part = m.split(':')\n\n            if len(part) == 3:\n                pass\n            elif len(part) == 2:\n                part.append('rw')\n            else:\n                raise\n\n            src, target, mode = part\n            src = os.path.abspath(os.path.expanduser(src))\n\n            binds.append('{}:{}:{}'.format(src, target, mode))\n            volumes.append(target)\n\n        kwargs['host_config'] = cli.create_host_config(binds=binds)\n        kwargs['volumes'] = volumes\n\n    container = cli.create_container(**kwargs)\n    container_id = container['Id']\n\n    cli.start(container=container_id)\n\n    return container_id", "response": "Runs code in a container returning its ID\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_and_check_settings(base_settings, file_name=None, section=None, base_path=None,\n                            strategy_type=INIJSONStrategy, disable=None, prompt=None,\n                            quiet=None):\n    \"\"\"Merge local settings from file with base settings, then check.\n\n    Returns a new dict containing the base settings and the loaded\n    settings. Includes:\n\n        - base settings\n        - settings from extended file(s), if any\n        - settings from file\n\n    Settings loaded from the specified file will override base settings,\n    then the settings will be checked to ensure that all required local\n    settings have been set.\n\n    If a file name is passed: if the file exists, local settings will be\n    loaded from it and any missing settings will be appended to it; if\n    the file does not exist, it will be created and all settings will be\n    added to it.\n\n    If a file name isn't passed: if the ``LOCAL_SETTINGS_FILE_NAME``\n    environment variable is set, the specified file will be used;\n    otherwise ``{base_path}/local.cfg`` will be used.\n\n    ``base_path`` is used when ``file_name`` is relative; if it's not\n    passed, it will be set to the current working directory.\n\n    When ``prompt`` is ``True``, the user will be prompted for missing\n    local settings. By default, the user is prompted only when running\n    on TTY. The ``LOCAL_SETTINGS_CONFIG_PROMPT`` environment variable\n    can be used to set ``prompt``.\n\n    When ``quiet`` is ``True``, informational messages will not be\n    printed. The ``LOCAL_SETTINGS_CONFIG_QUIET`` environment variable\n    can be used to set ``quiet``.\n\n    .. note:: When setting flags via environment variables, use a JSON\n        value like 'true', '1', 'false', or '0'.\n\n    See :meth:`.Loader.load` and :meth:`.Checker.check` for more info.\n\n    \"\"\"\n    environ_config = get_config_from_environ()\n    disable = environ_config['disable'] if disable is None else disable\n    prompt = environ_config['prompt'] if prompt is None else prompt\n    quiet = environ_config['quiet'] if quiet is None else quiet\n    if disable:\n        return {}\n    if file_name is None:\n        file_name = get_file_name()\n    if ':' in file_name:\n        package, path = file_name.split(':', 1)\n        file_name = pkg_resources.resource_filename(package, path)\n    if not os.path.isabs(file_name):\n        base_path = base_path or os.getcwd()\n        file_name = os.path.normpath(os.path.join(base_path, file_name))\n    try:\n        loader = Loader(file_name, section, strategy_type=strategy_type)\n        settings, success = loader.load_and_check(base_settings, prompt)\n    except KeyboardInterrupt:\n        # Loading/checking of local settings was aborted with Ctrl-C.\n        # This isn't an error, but we don't want to continue.\n        if not quiet:\n            printer.print_warning('\\nAborted loading/checking of local settings')\n        sys.exit(0)\n    if loader.section:\n        file_name = '{loader.file_name}#{loader.section}'.format(loader=loader)\n    else:\n        file_name = loader.file_name\n    if not success:\n        raise SettingsFileDidNotPassCheck(file_name)\n    if not quiet:\n        printer.print_success('Settings loaded successfully from {0}'.format(file_name))\n    return settings", "response": "Load and check local settings from file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef defer_reduce(func, items, test, accum=None):\n    '''Recursively reduce items by func, but only the items that do not cause test(items, accum) to return False.  Returns the reduced list (accum) and the list of remaining deferred items.\n    '''\n    removals = []\n\n    for k, item in enumerate(items):\n        if test(item, accum):\n            removals.append(k)\n            if accum is None:\n                accum = item\n            else:\n                accum = func(accum, item)\n        \n    deferred = indices_removed(items, removals)\n    \n    if deferred == items or not deferred:\n        return accum, deferred\n\n    return defer_reduce(func, deferred, test, accum)", "response": "Recursively reduce items by func but only the items that cause test ( items accum to return False."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating an authorization response dictionary.", "response": "def generate_response(chaldict,uri,username,passwd,method='GET',cnonce=None):\n  \"\"\"\n  Generate an authorization response dictionary. chaldict should contain the digest\n  challenge in dict form. Use fetch_challenge to create a chaldict from a HTTPResponse\n  object like this: fetch_challenge(res.getheaders()).\n\n  returns dict (the authdict)\n\n  Note. Use build_authorization_arg() to turn an authdict into the final Authorization\n  header value.\n  \"\"\"\n  authdict = {} \n  qop = dict_fetch(chaldict,'qop')\n  domain = dict_fetch(chaldict,'domain')\n  nonce = dict_fetch(chaldict,'nonce')\n  stale = dict_fetch(chaldict,'stale')\n  algorithm = dict_fetch(chaldict,'algorithm','MD5')\n  realm = dict_fetch(chaldict,'realm','MD5')\n  opaque = dict_fetch(chaldict,'opaque')\n  nc = \"00000001\"\n  if not cnonce:\n    cnonce = H(str(random.randint(0,10000000)))[:16]\n\n  if algorithm.lower()=='md5-sess':\n    a1 = A1(username,realm,passwd,nonce,cnonce)\n  else:\n    a1 = A1(username,realm,passwd)\n\n  a2 = A2(method,uri)\n\n  secret = H(a1)\n  data = '%s:%s:%s:%s:%s' % (nonce,nc,cnonce,qop,H(a2))\n  authdict['username'] = '\"%s\"' % username\n  authdict['realm'] = '\"%s\"' % realm\n  authdict['nonce'] = '\"%s\"' % nonce\n  authdict['uri'] = '\"%s\"' % uri\n  authdict['response'] = '\"%s\"' % KD(secret,data)\n  authdict['qop'] = '\"%s\"' % qop\n  authdict['nc'] = nc\n  authdict['cnonce'] = '\"%s\"' % cnonce\n  \n  return authdict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch_challenge(http_header):\n  m = fetch_challenge.wwwauth_header_re.match(http_header)\n  if m is None:\n      raise RuntimeError, 'expecting \"WWW-Authenticate header [Basic,Digest]\"'\n\n  d = dict(challenge=m.groups()[0])\n  m = fetch_challenge.auth_param_re.search(http_header)\n  while m is not None:\n      k,v = http_header[m.start():m.end()].split('=')\n      d[k.lower()] = v[1:-1]\n      m = fetch_challenge.auth_param_re.search(http_header, m.end())\n       \n  return d", "response": "Parse the WWW - Authenticate header and return a dictionary of challenge and auth parameters."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds an Authorization header value from an authdict.", "response": "def build_authorization_arg(authdict):\n  \"\"\"\n  Create an \"Authorization\" header value from an authdict (created by generate_response()).\n  \"\"\"\n  vallist = []\n  for k in authdict.keys():\n    vallist += ['%s=%s' % (k,authdict[k])]\n  return 'Digest '+', '.join(vallist)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nopening s URL with apiToken in the headers", "response": "def open_url(self, url):\n        \"\"\" Open's URL with apiToken in the headers \"\"\"\n        try:\n            c = pycurl.Curl()\n            c.setopt(pycurl.FAILONERROR, True)\n            c.setopt(pycurl.URL, \"%s/api/v0/%s\" % (self.url, url))\n            c.setopt(pycurl.HTTPHEADER, [\"User-Agent: %s\" % self.userAgent,\n                                         \"apiToken: %s\" % self.apiToken])\n            b = StringIO.StringIO()\n            c.setopt(pycurl.WRITEFUNCTION, b.write)\n            c.setopt(pycurl.FOLLOWLOCATION, 1)\n            c.setopt(pycurl.MAXREDIRS, 5)\n            # Persoonlijkrooster only supports SSLv3, not the default SSLv23.\n            c.setopt(pycurl.SSLVERSION, pycurl.SSLVERSION_SSLv3) \n            # Verify authenticity of peer's certificate. (0 will not check it)\n            c.setopt(pycurl.SSL_VERIFYPEER, 1)\n            # Verify that domain in URL matches to the Common Name Field or\n            # a Subject Alternate Name field in the certificate.\n            # (0 will not check it; 1 is an invalid value)\n            c.setopt(pycurl.SSL_VERIFYHOST, 2) \n            c.perform()\n            return b.getvalue()\n        except pycurl.error, e:\n            raise MyTimetableError(e)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fetch_room_ids(self, names):\n        ret = dict()\n        names_set = frozenset(names)\n        for d in json.loads(self.open_url(\n                            'timetables?type=location'))['timetable']:\n            name = d['hostKey']\n            if name in names_set:\n                ret[name] = d['value'].encode('utf-8')\n        return ret", "response": "Fetches the ids of the rooms with the given names"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fetch_todays_schedule(self, rooms):\n        def _format_date(d):\n            return d.strftime('%Y/%m/%d')\n        room_ids = self.fetch_room_ids(rooms)\n        ret = {}\n        now = datetime.datetime.now()\n        nowStr = _format_date(now)\n        tomorrowStr = _format_date(now + datetime.timedelta(days=1))\n        for room_name in room_ids:\n            ret[room_name] = []\n            events = json.loads(self.open_url(\n                            \"timetables/%s?startDate=%s&endDate=%s\" % (\n                                room_ids[room_name], nowStr, tomorrowStr)))\n            for event in events:\n                starttime = datetime.datetime.fromtimestamp(\n                            event['startDate']/1000.0)\n                endtime = datetime.datetime.fromtimestamp(\n                            event['endDate']/1000.0)\n                description = event['activityDescription']\n                if description is None:\n                    description = event['notes']\n                if description is None:\n                    description = '( geen omschrijving )'\n                ret[room_name].append((starttime,\n                                       endtime,\n                                       normalize_event_name(description)))\n        return ret", "response": "Fetch the schedules for the given rooms."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads module configuration files.", "response": "def _loadConfiguration(self):\n        \"\"\"\n        Load module configuration files.\n\n        :return: <void>\n        \"\"\"\n        configPath = os.path.join(self.path, \"config\")\n        if not os.path.isdir(configPath):\n            return\n\n        config = Config(configPath)\n\n        Config.mergeDictionaries(config.getData(), self.application.config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload module models. :return: <void>", "response": "def _loadModels(self):\n        \"\"\"\n        Load module models.\n\n        :return: <void>\n        \"\"\"\n        modelsPath = os.path.join(self.path, \"model\")\n        if not os.path.isdir(modelsPath):\n            return\n\n        for modelFile in os.listdir(modelsPath):\n            modelName = modelFile.replace(\".py\", \"\")\n            modelPath = os.path.join(\n                self.path, \"model\", modelFile\n            )\n\n            if not os.path.isfile(modelPath):\n                continue\n\n            # importing model\n            modelSpec = importlib.util.spec_from_file_location(\n                modelName,\n                modelPath\n            )\n            model = importlib.util.module_from_spec(modelSpec)\n            modelSpec.loader.exec_module(model)\n\n            # initializing model\n            modelInstance = model.Model(self.application)\n            self.application.addModel(self.name, modelName, modelInstance)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads module services. :return: <void>", "response": "def _loadServices(self):\n        \"\"\"\n        Load module services.\n\n        :return: <void>\n        \"\"\"\n        servicesPath = os.path.join(self.path, \"service\")\n        if not os.path.isdir(servicesPath):\n            return\n\n        self._scanDirectoryForServices(servicesPath)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _scanDirectoryForServices(self, directoryPath):\n        # checking if path is actually a directory\n        if not os.path.isdir(directoryPath):\n            return\n\n        for item in os.listdir(directoryPath):\n            itemPath = os.path.join(\n                directoryPath, item\n            )\n\n            if os.path.isdir(itemPath) and not item.startswith(\"__\") and not item.startswith(\".\"):\n                self._scanDirectoryForServices(itemPath)\n                continue\n\n            if os.path.isfile(itemPath) and itemPath.lower().endswith((\".py\",)):\n                self._loadService(itemPath)\n                continue", "response": "Scan a directory looking for services and load them if they are found."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload an application service at the specified path.", "response": "def _loadService(self, servicePath):\n        \"\"\"\n        Check if an application service can be found at the specified path.\n        If found, instantiate it and add it to the application service pool.\n\n        :param: <str> service file path\n        :return: <void>\n        \"\"\"\n        serviceName = ntpath.basename(servicePath).replace(\".py\", \"\")\n\n        # importing service\n        serviceSpec = importlib.util.spec_from_file_location(\n            serviceName,\n            servicePath\n        )\n        service = importlib.util.module_from_spec(serviceSpec)\n        serviceSpec.loader.exec_module(service)\n\n        # checking if there is a service in the file\n        if hasattr(service, \"Service\"):\n            # instantiate the service\n            serviceInstance = service.Service(self.application)\n            self.application.addService(\n                self.name,\n                serviceName,\n                serviceInstance\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef post(self, request, key):\n\n        email = request.POST.get('email')\n        user_id = request.POST.get('user')\n        if not email:\n            return http.HttpResponseBadRequest()\n\n        try:\n            EmailAddressValidation.objects.create(address=email,\n                                                  user_id=user_id)\n        except IntegrityError:\n            # 409 Conflict\n            #   duplicated entries\n            #   email exist and it's waiting for validation\n            return http.HttpResponse(status=409)\n\n        return http.HttpResponse(status=201)", "response": "Create new email address that will wait for validation"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nscaling an array to the given min - max values.", "response": "def scale(arr, mn=0, mx=1):\n    \"\"\"\n    Apply min-max scaling (normalize)\n    then scale to (mn,mx)\n    \"\"\"\n    amn = arr.min()\n    amx = arr.max()\n    # normalize:\n    arr = (arr - amn) / (amx - amn)\n    # scale:\n    if amn != mn or amx != mx:\n        arr *= mx - mn\n        arr += mn\n    return arr"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning count independent thread - safe iterators for iterable", "response": "def multi_iter(iterable, count=2):\n    \"\"\"Return `count` independent, thread-safe iterators for `iterable`\"\"\"\n    # no need to special-case re-usable, container-like iterables\n    if not isinstance(\n            iterable,\n            (\n                    list, tuple, set,\n                    FutureChainResults,\n                    collections.Sequence, collections.Set, collections.Mapping, collections.MappingView\n            )):\n        iterable = SafeTee(iterable, n=count)\n    return (iter(iterable) for _ in range(count))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrealise the future in this thread if possible.", "response": "def realise(self):\n        \"\"\"\n        Realise the future if possible\n\n        If the future has not been realised yet, do so in the current thread.\n        This will block execution until the future is realised.\n        Otherwise, do not block but return whether the result is already available.\n\n        This will not return the result nor propagate any exceptions of the future itself.\n\n        :return: whether the future has been realised\n        :rtype: bool\n        \"\"\"\n        if self._mutex.acquire(False):\n            # realise the future in this thread\n            try:\n                if self._result is not None:\n                    return True\n                call, args, kwargs = self._instruction\n                try:\n                    result = call(*args, **kwargs)\n                except BaseException as err:\n                    self._result = None, err\n                else:\n                    self._result = result, None\n                return True\n            finally:\n                self._mutex.release()\n        else:\n            # indicate whether the executing thread is done\n            return self._result is not None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the result of the future.", "response": "def result(self):\n        \"\"\"\n        The result from realising the future\n\n        If the result is not available, block until done.\n\n        :return: result of the future\n        :raises: any exception encountered during realising the future\n        \"\"\"\n        if self._result is None:\n            self.await_result()\n        chunks, exception = self._result\n        if exception is None:\n            return chunks\n        raise exception"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the WARCINFO record from the archieve as a single string including the WARCINFO header.", "response": "def get_warcinfo(self):\r\n\t\t''' \r\n\t\tReturns WARCINFO record from the archieve as a single string including\r\n\t\tWARC header. Expects the record to be in the beginning of the archieve,\r\n\t\totherwise it will be not found.\r\n\t\t'''\r\n\t\tif self.searched_for_warcinfo:\r\n\t\t\treturn self.warcinfo\r\n\t\tprev_line = None\r\n\t\tin_warcinfo_record = False\r\n\t\tself.searched_for_warcinfo = True\r\n\t\tfor line in self.file_object:\r\n\t\t\tif not in_warcinfo_record:\r\n\t\t\t\tif line[:11] == b'WARC-Type: ':\r\n\t\t\t\t\tif line[:19] == b'WARC-Type: warcinfo':\r\n\t\t\t\t\t\tin_warcinfo_record = True\r\n\t\t\t\t\t\twarcinfo_lines = [prev_line, line]\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\tself.warcinfo = None\r\n\t\t\t\t\t\tbreak\r\n\t\t\telse:\r\n\t\t\t\tif line[0:1] == self.w_letter and self.warc_header_re.match(line):\r\n\t\t\t\t\tself.warcinfo = b''.join(warcinfo_lines)\r\n\t\t\t\t\tbreak\r\n\t\t\t\twarcinfo_lines.append(line)\r\n\t\t\tprev_line = line\r\n\t\tself.file_object.seek(0)\r\n\t\treturn self.warcinfo"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing the state machine.", "response": "def init_state(self):\r\n\t\t''' Sets the initial state of the state machine. '''\r\n\t\tself.in_warc_response = False\r\n\t\tself.in_http_response = False\r\n\t\tself.in_payload = False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a label into a kvl key.", "response": "def _keys_from_label(self, label):\n        '''Convert a label into a kvl key.\n        '''\n        k1 = (label.content_id1, label.content_id2,\n              label.annotator_id, time_complement(label.epoch_ticks))\n        k2 = (label.content_id2, label.content_id1,\n              label.annotator_id, time_complement(label.epoch_ticks))\n        return k1, k2"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a label into a kvl value.", "response": "def _value_from_label(self, label):\n        '''Convert a label into a kvl value.\n        '''\n        unser_val = (label.rel_strength.value, label.meta)\n        return cbor.dumps(unser_val)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _label_from_kvlayer(self, key, val):\n        '''Make a label from a kvlayer row.\n        '''\n        (content_id1, content_id2, annotator_id,\n         inverted_epoch_ticks) = key\n        epoch_ticks = time_complement(inverted_epoch_ticks)\n\n        rel_strength, meta = cbor.loads(val)\n        return RelationLabel(content_id1, content_id2, annotator_id,\n                             RelationStrength(rel_strength),\n                             epoch_ticks=epoch_ticks, meta=meta)", "response": "Make a label from a kvlayer row."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, cid1, cid2, annotator_id):\n        '''Retrieve a relation label from the store.\n        '''\n        t = (cid1, cid2, annotator_id)\n        for k, v in self.kvl.scan(self.TABLE, (t, t)):\n            return self._label_from_kvlayer(k, v)", "response": "Retrieve a relation label from the store."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_related(self, content_id, min_strength=None):\n        '''Get positive relation labels for ``cid``.\n\n        If ``min_strength`` is set, will restrict results to labels\n        with a ``rel_strength`` greater or equal to the provided\n        ``RelationStrength`` value. Note: ``min_strength`` should be of\n        type ``RelationStrength``.\n        '''\n        def is_related(label):\n            if min_strength is not None:\n                return label.rel_strength >= min_strength\n            else:\n                return label.rel_strength.is_positive\n\n        labels = self.everything(content_id=content_id)\n        return ifilter(is_related, labels)", "response": "Get positive relation labels for cid."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_related_ids(self, content_id, min_strength=None):\n        '''Get identifiers for related identifiers.\n        '''\n        related_labels = self.get_related(content_id,\n                                          min_strength=min_strength)\n        related_idents = set()\n        for label in related_labels:\n            related_idents.add(label.other(content_id))\n\n        return list(related_idents)", "response": "Get identifiers for related identifiers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget relationships between idents and a cid", "response": "def get_relationships_for_idents(self, cid, idents):\n        '''Get relationships between ``idents`` and a ``cid``.\n\n        Returns a dictionary mapping the identifiers in ``idents``\n        to either None, if no relationship label is found between\n        the identifier and ``cid``, or a RelationshipType classifying\n        the strength of the relationship between the identifier and\n        ``cid``.\n        '''\n        keys = [(cid, ident,) for ident in idents]\n        key_ranges = zip(keys, keys)\n        mapping = {}\n        for k, v in self.kvl.scan(self.TABLE, *key_ranges):\n            label = self._label_from_kvlayer(k, v)\n            ident = label.other(cid)\n            rel_strength = label.rel_strength\n            mapping[ident] = label.rel_strength\n\n        return mapping"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a generator of all labels in the store.", "response": "def everything(self, content_id=None):\n        '''Returns a generator of all labels in the store.\n\n        If ``content_id`` is set, will restrict results to labels\n        containing the provided ``content_id``.\n        '''\n        if content_id is not None:\n            ranges = [((content_id,), (content_id,))]\n        else:\n            ranges = []\n\n        labels = self.kvl.scan(self.TABLE, *ranges)\n        labels = imap(lambda p: self._label_from_kvlayer(*p), labels)\n        return labels"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef backup_db(\n        aws_access_key_id,\n        aws_secret_access_key,\n        bucket_name,\n        s3_folder,\n        database,\n        mysql_host,\n        mysql_port, \n        db_user, \n        db_pass, \n        db_backups_dir, \n        backup_aging_time):\n    \"\"\"\n    dumps databases into /backups, uploads to s3, deletes backups older than a month\n    fab -f ./fabfile.py backup_dbs\n    :param aws_access_key_id:\n    :param aws_secret_access_key:\n    :param bucket_name:\n    :param database:\n    :param mysql_host:\n    :param mysql_port:\n    :param db_pass:\n    :param db_backups_dir:\n    :param backup_aging_time:\n    :return:\n    \"\"\"\n\n    #  Connect to the bucket\n\n    bucket = s3_bucket(aws_access_key_id, aws_secret_access_key, bucket_name)\n    key = boto.s3.key.Key(bucket)\n\n    bucketlist = bucket.list()\n\n    pat = \"[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-%s.sql.bz2\" % database\n\n    sql_file = '%s-%s.sql' % (dt.now().strftime(TIMESTAMP_FORMAT), database)\n    print('Dumping database %s to %s.bz2' % (database, sql_file))\n\n    sql_full_target = os.path.join(db_backups_dir, sql_file)\n    f = open(sql_full_target, \"wb\")\n    cmd = '/usr/bin/mysqldump -h%s -P%s -u%s -p%s %s ' % (mysql_host, mysql_port, db_user, db_pass, database)\n    print(cmd)\n    subprocess.call(cmd.split(), stdout=f)\n    cmd = 'bzip2 %s' % sql_full_target\n    print(cmd)\n    subprocess.call(cmd.split())\n    sql_local_full_target = sql_full_target\n    # append '.bz2'\n    key.key = os.path.join(s3_folder, '%s.bz2' % sql_file)\n    print('STARTING upload of %s to %s: %s' % (sql_file, key.key, dt.now()))\n    try:\n        key.set_contents_from_filename('%s.bz2' % os.path.join(db_backups_dir, sql_full_target))\n        print('Upload of %s FINISHED: %s' % (sql_local_full_target, dt.now()))\n    finally:\n        delete_expired_backups_in_bucket(bucket, bucketlist, pat, backup_aging_time=backup_aging_time)\n        delete_local_db_backups(pat, db_backups_dir, backup_aging_time)", "response": "This function will backup the databases in the specified bucket."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef renew_token(self, refresh_token):\r\n\r\n        ''' a method to renew an access token from an oauth2 authorizing party\r\n\r\n        :param auth_code: string with refresh token provided by service with access token\r\n        :return: dictionary with access token details inside [json] key\r\n\r\n        token_details = self.objects.token.schema\r\n        '''\r\n\r\n        title = '%s.renew_token' % self.__class__.__name__\r\n\r\n    # validate inputs\r\n        input_args = {\r\n            'refresh_token': refresh_token\r\n        }\r\n\r\n        for key, value in input_args.items():\r\n            if value:\r\n                object_title = '%s(%s=%s)' % (title, key, value)\r\n                self.fields.validate(value, '.%s' % key, object_title)\r\n\r\n    # construct base url\r\n        request_kwargs = {\r\n            'url': self.token_endpoint\r\n        }\r\n\r\n    # construct token fields\r\n        token_fields = {\r\n            'grant_type': 'refresh_token',\r\n            'refresh_token': refresh_token,\r\n            'client_id': self.client_id,\r\n            'client_secret': self.client_secret\r\n        }\r\n\r\n    # construct request params\r\n        if self.request_mimetype == 'application/x-www-form-urlencoded':\r\n            request_kwargs['data'] = token_fields\r\n        elif self.request_mimetype == 'application/json':\r\n            request_kwargs['json'] = token_fields\r\n        else:\r\n            request_kwargs['params'] = token_fields\r\n\r\n    # send request\r\n        from time import time\r\n        current_time = time()\r\n        token_details = self._post_request(**request_kwargs)\r\n\r\n    # convert expiration info to epoch timestamp\r\n        details = token_details['json']\r\n        details['expires_at'] = 0\r\n        if details:\r\n            if 'expires_in' in details.keys():\r\n                details['expires_at'] = int(current_time) + int(details['expires_in'])\r\n                del details['expires_in']\r\n\r\n        return token_details", "response": "a method to renew an access token from an oauth2 authorizing party with a refresh token"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndisplaying the HTML for the reCAPTCHA public API key and the optional options.", "response": "def displayhtml(public_key,\n                attrs,\n                use_ssl=False,\n                error=None):\n    \"\"\"Gets the HTML to display for reCAPTCHA\n\n    public_key -- The public api key\n    use_ssl -- Should the request be sent over ssl?\n    error -- An error message to display (from RecaptchaResponse.error_code)\"\"\"\n\n    error_param = ''\n    if error:\n        error_param = '&error=%s' % error\n\n    if use_ssl:\n        server = API_SSL_SERVER\n    else:\n        server = API_SERVER\n\n    if 'lang' not in attrs:\n        attrs['lang'] = get_language()[:2]\n\n    return render_to_string(\n        WIDGET_TEMPLATE,\n        {'api_server': server,\n         'public_key': public_key,\n         'error_param': error_param,\n         'lang': attrs['lang'],\n         'options': mark_safe(json.dumps(attrs, indent=2))\n         })"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef submit(recaptcha_challenge_field,\n           recaptcha_response_field,\n           private_key,\n           remoteip,\n           use_ssl=False):\n    \"\"\"\n    Submits a reCAPTCHA request for verification. Returns RecaptchaResponse\n    for the request\n\n    recaptcha_challenge_field -- The value of recaptcha_challenge_field\n    from the form\n    recaptcha_response_field -- The value of recaptcha_response_field\n    from the form\n    private_key -- your reCAPTCHA private key\n    remoteip -- the user's ip address\n    \"\"\"\n\n    if not (recaptcha_response_field and recaptcha_challenge_field and\n            len(recaptcha_response_field) and len(recaptcha_challenge_field)):\n        return RecaptchaResponse(\n            is_valid=False,\n            error_code='incorrect-captcha-sol'\n        )\n\n    if getattr(settings, \"NOCAPTCHA\", False):\n        params = urlencode({\n            'secret': want_bytes(private_key), \n            'response': want_bytes(recaptcha_response_field), \n            'remoteip': want_bytes(remoteip),\n        })\n    else:\n        params = urlencode({\n        'privatekey': want_bytes(private_key),\n        'remoteip':  want_bytes(remoteip),\n        'challenge':  want_bytes(recaptcha_challenge_field),\n        'response':  want_bytes(recaptcha_response_field),\n        })\n\n    if not PY2:\n        params = params.encode('utf-8')\n\n    if use_ssl:\n        verify_url = 'https://%s/recaptcha/api/verify' % VERIFY_SERVER\n    else:\n        verify_url = 'http://%s/recaptcha/api/verify' % VERIFY_SERVER\n\n    if getattr(settings, \"NOCAPTCHA\", False):\n        verify_url = 'https://%s/recaptcha/api/siteverify' % VERIFY_SERVER\n\n    req = Request(\n        url=verify_url,\n        data=params,\n        headers={\n            'Content-type': 'application/x-www-form-urlencoded',\n            'User-agent': 'reCAPTCHA Python'\n        }\n    )\n\n    httpresp = urlopen(req)\n    if getattr(settings, \"NOCAPTCHA\", False):\n        data = json.loads(httpresp.read().decode('utf-8'))\n        return_code = data['success']\n        return_values = [return_code, None]\n        if return_code:\n            return_code = 'true'\n        else:\n            return_code = 'false'\n    else:\n        return_values = httpresp.read().splitlines()\n        return_code = return_values[0]\n\n    httpresp.close()\n\n    if (return_code == \"true\"):\n        return RecaptchaResponse(is_valid=True)\n    else:\n        return RecaptchaResponse(is_valid=False, error_code=return_values[1])", "response": "Submits a reCAPTCHA request for verification. Returns a RecaptchaResponse object for the request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nensuring the sortable field exists on the model.", "response": "def _validate_field(param, fields):\n    \"\"\" Ensure the sortable field exists on the model \"\"\"\n\n    if param.field not in fields:\n        raise InvalidQueryParams(**{\n            'detail': 'The sort query param value of \"%s\" is '\n                      'invalid. That field does not exist on the '\n                      'resource being requested.' % param.raw_field,\n            'links': LINK,\n            'parameter': PARAM,\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nensures the sortable field is not on a relationship", "response": "def _validate_no_rels(param, rels):\n    \"\"\" Ensure the sortable field is not on a relationship \"\"\"\n\n    if param.field in rels:\n        raise InvalidQueryParams(**{\n            'detail': 'The sort query param value of \"%s\" is not '\n                      'supported. Sorting on relationships is not '\n                      'currently supported' % param.raw_field,\n            'links': LINK,\n            'parameter': PARAM,\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef init(req, model):\n\n    rels = model.relationships\n    fields = model.all_fields\n\n    params = req.get_param_as_list('sort') or [goldman.config.SORT]\n    params = [Sortable(param.lower()) for param in params]\n\n    for param in params:\n        _validate_no_rels(param, rels)\n        _validate_field(param, fields)\n\n    return params", "response": "Determine the sorting preference by query parameter\n    Return an array of Sortable objects."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_proxy(self, proxy):\n        # TODO: Validate proxy url format\n\n        if proxy is None:\n            self.driver.proxies = {'http': None,\n                                   'https': None\n                                   }\n        else:\n            self.driver.proxies = {'http': proxy,\n                                   'https': proxy\n                                   }\n\n        self.current_proxy = proxy", "response": "Set proxy for requests session\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _create_session(self):\n        self.driver = requests.Session(**self.driver_args)\n        # Set default headers\n        self.update_headers(self.current_headers)\n        self.update_cookies(self.current_cookies)\n        self.set_proxy(self.current_proxy)", "response": "Creates a fresh session with the default header and cookies"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_site(self, url, headers, cookies, timeout, driver_args, driver_kwargs):\n        try:\n            # Headers and cookies are combined to the ones stored in the requests session\n            #  Ones passed in here will override the ones in the session if they are the same key\n            response = self.driver.get(url,\n                                       *driver_args,\n                                       headers=headers,\n                                       cookies=cookies,\n                                       timeout=timeout,\n                                       **driver_kwargs)\n\n            # Set data to access from script\n            self.status_code = response.status_code\n            self.url = response.url\n            self.response = response\n\n            if response.status_code == requests.codes.ok:\n                # Return the correct format\n                return response.text\n\n            response.raise_for_status()\n\n        except Exception as e:\n            raise e.with_traceback(sys.exc_info()[2])", "response": "Try and return page content in the requested format using requests\n           "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting an uid for your controller.", "response": "def _new_controller(self, addr, port):\n        \"\"\"\n        Get an uid for your controller.\n\n        :param addr: Address of the controller\n        :param port: Port of the controller\n        :type addr: str\n        :type port: int\n        :return: Unique id of the controller\n        :rtype: str\n        \"\"\"\n        for uid, controller in self.controllers.items():\n            if controller[0] == addr:\n                # duplicate address. sending the uid again\n                #print('/uid/{} => {}:{}'.format(uid, addr, port))\n                self.sock.sendto('/uid/{}'.format(uid).encode('utf-8'), (addr, port))\n                return False\n\n        # get an uid and add the controller to the game\n        uid = str(uuid4())\n        self.controllers[uid] = [addr, port, '00000000000000', time.time()]\n\n        # tell the controller about it\n        #print('/uid/{} => {}:{}'.format(uid, addr, port))\n        self.sock.sendto('/uid/{}'.format(uid).encode('utf-8'), (addr, port))\n\n        # create event for pymlgame\n        e = Event(uid, E_NEWCTLR)\n        self.queue.put_nowait(e)\n\n        return uid"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _del_controller(self, uid):\n        try:\n            self.controllers.pop(uid)\n            e = Event(uid, E_DISCONNECT)\n            self.queue.put_nowait(e)\n        except KeyError:\n            # There is no such controller, ignore the command\n            pass", "response": "Remove a controller from internal list and tell the game."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _ping(self, uid, addr, port):\n        try:\n            self.controllers[uid][0] = addr\n            self.controllers[uid][1] = port\n            self.controllers[uid][3] = time.time()\n\n            e = Event(uid, E_PING)\n            self.queue.put_nowait(e)\n        except KeyError:\n            # There is no such controller, ignore the command\n            pass", "response": "Ping the controller with the given uid."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _update_states(self, uid, states):\n        #TODO: use try and catch all exceptions\n        # test if uid exists\n        if self.controllers[uid]:\n            # test if states have correct lenght\n            if len(states) == 14:\n                old_states = self.controllers[uid][2]\n                if old_states != states:\n                    for key in range(14):\n                        if int(old_states[key]) > int(states[key]):\n                            e = Event(uid, E_KEYUP, key)\n                            self.queue.put_nowait(e)\n                        elif int(old_states[key]) < int(states[key]):\n                            e = Event(uid, E_KEYDOWN, key)\n                            self.queue.put_nowait(e)\n                self.controllers[uid][2] = states\n            self.controllers[uid][3] = time.time()", "response": "Update the states of all buttons from a controller."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _got_message(self, uid, text):\n        #TODO: use try\n        e = Event(uid, E_MESSAGE, text)\n        self.queue.put_nowait(e)\n\n        self.controllers[uid][2] = time.time()", "response": "Called by the controller when a message is received."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send(self, uid, event, payload=None):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        if uid in self.controllers.keys():\n            addr = self.controllers[uid][0]\n            port = self.controllers[uid][1]\n            if event == E_MESSAGE:\n                #print('/message/{} => {}:{}'.format(payload, addr, port))\n                return sock.sendto('/message/{}'.format(payload).encode('utf-8'), (addr, port))\n            elif event == E_RUMBLE:\n                #print('/rumble/{} => {}:{}'.format(payload, addr, port))\n                return sock.sendto('/rumble/{}'.format(payload).encode('utf-8'), (addr, port))\n            else:\n                pass\n        else:\n            pass\n        return False", "response": "Send an event to a connected controller. Use pymlgame. E_MESSAGE event and a string as payload."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a python object from a python object string", "response": "def get_obj_frm_str(obj_str, **kwargs):\n    \"\"\"\n    Returns a python object from a python object string\n\n    args:\n        obj_str: python object path expamle\n                    \"rdfframework.connections.ConnManager[{param1}]\"\n\n    kwargs:\n        * kwargs used to format the 'obj_str'\n    \"\"\"\n    obj_str = obj_str.format(**kwargs)\n    args = []\n    kwargs = {}\n    params = []\n    # parse the call portion of the string\n    if \"(\" in obj_str:\n        call_args = obj_str[obj_str.find(\"(\"):]\n        obj_str = obj_str[:obj_str.find(\"(\")]\n        call_args = call_args[1:-1]\n        if call_args:\n            call_args = call_args.split(\",\")\n        else:\n            call_args = []\n        call_args = [arg.strip() for arg in call_args]\n\n        for arg in call_args:\n            if \"=\" in arg:\n                parts = arg.split(\"=\")\n                kwargs[parts[0]] = parts[1]\n            else:\n                args.append(arg)\n    # parse a the __getitem__ portion of the string\n    if \"[\" in obj_str:\n        params = obj_str[obj_str.find(\"[\"):]\n        obj_str = obj_str[:obj_str.find(\"[\")]\n        params = [part.replace(\"[\", \"\").replace(\"]\", \"\")\n                  for part in params.split(\"][\")]\n    obj = pydoc.locate(obj_str)\n    if params:\n        for part in params:\n            obj = get_attr(obj, part)\n    if args or kwargs:\n        if kwargs:\n            obj = obj.__call__(*args, **kwargs)\n        else:\n            obj = obj.__call__(*args)\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrendering a template without a request.", "response": "def render_without_request(template_name, template_path=None, **template_vars):\n    \"\"\"\n    Usage is the same as flask.render_template:\n\n    render_without_request('my_template.html', var1='foo', var2='bar')\n    \"\"\"\n    if template_path:\n        env = Environment(loader=FileSystemLoader([os.path.join(template_path)]))\n    else:\n        env = ENV\n    template = env.get_template(template_name)\n    return template.render(**template_vars)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a value to true or false. Python s default bool function does not handle true of false of false strings", "response": "def cbool(value, strict=True):\n    ''' converts a value to true or false. Python's default bool() function\n    does not handle 'true' of 'false' strings '''\n    return_val = value\n    if is_not_null(value):\n        if isinstance(value, bool):\n            return_val = value\n        else:\n            value = str(value)\n            if value.lower() in ['true', '1', 't', 'y', 'yes']:\n                return_val = True\n            elif value.lower() in ['false', '0', 'n', 'no', 'f']:\n                return_val = False\n            else:\n                if strict:\n                    return_val = None\n    else:\n        if strict:\n            return_val = None\n    return return_val"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_set(value):\n    ''' Takes a value and turns it into a set\n\n    !!!! This is important because set(string) will parse a string to\n    individual characters vs. adding the string as an element of\n    the set i.e.\n        x = 'setvalue'\n        set(x) = {'t', 'a', 'e', 'v', 'u', 's', 'l'}\n        make_set(x) = {'setvalue'}\n        or use set([x,]) by adding string as first item in list.\n    '''\n    if isinstance(value, list):\n        value = set(value)\n    elif not isinstance(value, set):\n        value = set([value,])\n    return value", "response": "Takes a value and turns it into a set"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_triple(sub, pred, obj):\n    return \"{s} {p} {o} .\".format(s=sub, p=pred, o=obj)", "response": "Takes a subject predicate and object and joins them with a space\n\tin between\n    Returns a string"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_null(obj):\n    ''' reads through a list or set and strips any null values'''\n    if isinstance(obj, set):\n        try:\n            obj.remove(None)\n        except:\n            pass\n    elif isinstance(obj, list):\n        for item in obj:\n            if not is_not_null(item):\n                obj.remove(item)\n    return obj", "response": "reads through a list or set and strips any null values"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef copy_obj(obj):\n    ''' does a deepcopy of an object, but does not copy a class\n        i.e.\n        x = {\"key\":[<classInstance1>,<classInstance2>,<classInstance3>]}\n        y = copy_obj(x)\n        y --> {\"key\":[<classInstance1>,<classInstance2>,<classInstance3>]}\n        del y['key'][0]\n        y --> {\"key\":[<classInstance2>,<classInstance3>]}\n        x --> {\"    key\":[<classInstance1>,<classInstance2>,<classInstance3>]}\n        *** this is to overcome a dictionary object that lists with classes\n            as the list items. '''\n    if isinstance(obj, dict):\n        return_obj = {}\n        for key, value in obj.items():\n            if isinstance(value, dict):\n                return_obj[key] = copy_obj(value)\n            elif isinstance(value, list):\n                return_obj[key] = copy_obj(value)\n            else:\n                return_obj[key] = value\n    elif isinstance(obj, list):\n        return_obj = []\n        for value in obj:\n            if isinstance(value, dict):\n                return_obj.append(copy_obj(value))\n            elif isinstance(value, list):\n                return_obj.append(copy_obj(value))\n            else:\n                return_obj.append(value)\n    else:\n        return_obj = copy.copy(obj)\n    return return_obj", "response": "does a deep copy of an object but does not copy a class\n           "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_key_pattern(obj, regx_pattern):\n    ''' takes a dictionary object and a regular expression pattern and removes\n    all keys that match the pattern.\n\n    args:\n        obj: dictionay object to search trhough\n        regx_pattern: string without beginning and ending / '''\n\n    if isinstance(obj, list):\n        _return_list = []\n        for item in obj:\n            if isinstance(item, list):\n                _return_list.append(delete_key_pattern(item, regx_pattern))\n            elif isinstance(item, set):\n                _return_list.append(list(item))\n            elif isinstance(item, dict):\n                _return_list.append(delete_key_pattern(item, regx_pattern))\n            else:\n                try:\n                    json.dumps(item)\n                    _return_list.append(item)\n                except:\n                    _return_list.append(str(type(item)))\n        return _return_list\n    elif isinstance(obj, set):\n        return list(obj)\n    elif isinstance(obj, dict):\n        _return_obj = {}\n        for key, item in obj.items():\n            if not re.match(regx_pattern, key):\n                if isinstance(item, list):\n                    _return_obj[key] = delete_key_pattern(item, regx_pattern)\n                elif isinstance(item, set):\n                    _return_obj[key] = list(item)\n                elif isinstance(item, dict):\n                    _return_obj[key] = delete_key_pattern(item, regx_pattern)\n                else:\n                    try:\n                        json.dumps(item)\n                        _return_obj[key] = item\n                    except:\n                        _return_obj[key] = str(type(item))\n        return _return_obj\n    else:\n        try:\n            json.dumps(obj)\n            return obj\n        except:\n            return str(type(obj))", "response": "takes a dictionary object and a regular expression pattern and removes all keys that match the pattern and returns a list of the objects that match the pattern."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_dict_key(data, key):\n    ''' will serach a mulitdemensional dictionary for a key name and return a\n        value list of matching results '''\n\n    if isinstance(data, Mapping):\n        if key in data:\n            yield data[key]\n        for key_data in data.values():\n            for found in get_dict_key(key_data, key):\n                yield found", "response": "returns a list of all the items in a dict that match a key"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget attr of a node", "response": "def get_attr(item, name, default=None):\n    ''' similar to getattr and get but will test for class or dict '''\n    try:\n        val = item[name]\n    except (KeyError, TypeError):\n        try:\n            val = getattr(item, name)\n        except AttributeError:\n            val = default\n    return val"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clean_iri(uri_string):\n    '''removes the <> signs from a string start and end'''\n    uri_string = str(uri_string).strip()\n    if uri_string[:1] == \"<\" and uri_string[len(uri_string)-1:] == \">\":\n        uri_string = uri_string[1:len(uri_string)-1]\n    return uri_string", "response": "removes the <> signs from a string start and end"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find(self, value):\n        value = str(value).lower()\n        rtn_dict = RegistryDictionary()\n        for key, item in self.items():\n            if value in key.lower():\n                rtn_dict[key] = item\n        return rtn_dict", "response": "returns a dictionary of items based on the a lowercase search\n\n        value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, prop):\n        prop_parts = prop.split(\".\")\n        val = None\n        for part in prop_parts:\n            if val is None:\n                val = self.obj.get(part)\n            else:\n                val = val.get(part)\n        return val", "response": "get the value off the passed in dot notation\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set(self, prop, value):\n\n        prop_parts = prop.split(\".\")\n        if self.copy_dict:\n            new_dict = copy.deepcopy(self.obj)\n        else:\n            new_dict = self.obj\n        pointer = None\n        parts_length = len(prop_parts) - 1\n        for i, part in enumerate(prop_parts):\n            if pointer is None and i == parts_length:\n                new_dict[part] = value\n            elif pointer is None:\n                pointer = new_dict.get(part)\n            elif i == parts_length:\n                pointer[part] = value\n            else:\n                pointer = pointer.get(part)\n        return new_dict", "response": "sets the dot notated property to the passed in value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts the class to a dictionary object", "response": "def dict(self):\n        \"\"\" converts the class to a dictionary object \"\"\"\n        return_obj = {}\n        for attr in dir(self):\n            if not attr.startswith('__') and attr not in self.__reserved:\n                if isinstance(getattr(self, attr), list):\n                    return_val = []\n                    for item in getattr(self, attr):\n                        if isinstance(item, DictClass):\n                            return_val.append(dict(item))\n                        else:\n                            return_val.append(item)\n                elif isinstance(getattr(self, attr), dict):\n                    return_val = {}\n                    for key, item in getattr(self, attr).items():\n                        if isinstance(item, DictClass):\n                            return_val[key] = item.dict()\n                        else:\n                            return_val[key] = item\n                elif isinstance(getattr(self, attr), DictClass):\n                    return_val = getattr(self, attr).dict()\n                else:\n                    return_val = getattr(self, attr)\n                return_obj[attr] = return_val\n        return return_obj"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_anchor_href(markup):\n    soup = BeautifulSoup(markup, 'lxml')\n    return ['%s' % link.get('href') for link in soup.find_all('a')]", "response": "Given HTML markup return a list of hrefs for each anchor tag."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_anchor_contents(markup):\n    soup = BeautifulSoup(markup, 'lxml')\n    return ['%s' % link.contents[0] for link in soup.find_all('a')]", "response": "Given HTML markup return a list of href inner html for each anchor tag."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef names_from_exp(exp):\n  \"Return a list of AttrX and NameX from the expression.\"\n  def match(exp):\n    return isinstance(exp, (sqparse2.NameX, sqparse2.AttrX))\n  paths = treepath.sub_slots(exp, match, match=True, recurse_into_matches=False)\n  return [exp[path] for path in paths]", "response": "Return a list of AttrX and NameX from the expression."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a RowList with the rows included from scope by the fromx and wherex.", "response": "def wherex_to_rowlist(scope_, fromx, wherex):\n  \"\"\"return a RowList with the rows included from scope by the fromx and wherex.\n  When the scope has more than one name in it, the output will be a list of composite row\n    (i.e. a row whose field types are themselves RowType).\n  \"\"\"\n  single, multi = classify_wherex(scope_, fromx, wherex)\n  single_rowlists = {\n    tablename: table_to_rowlist(scope_[tablename], conds)\n    for tablename, conds in misc.multimap(single).items() # i.e. {cond.table:[cond.exp, ...]}\n  }\n  raise NotImplementedError"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(self):\n        for package in os.listdir(self.root_directory):\n            directory = os.path.join(self.root_directory, package)\n            if not os.path.isdir(directory):\n                continue\n            dir_contents = os.listdir(directory)\n            sdists = [tarball for tarball in dir_contents\n                      if (tarball.endswith('.tar.gz')\n                          and tarball.startswith(package + '-'))]\n            for sdist in sdists:\n                version = sdist.replace('.tar.gz', '').replace(\n                    package + '-', '')\n                self.packages[package].append(version)", "response": "Iterate through the directory and extract package and version info."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a tarball to the directory if needed.", "response": "def add_tarball(self, tarball, package):\n        \"\"\"Add a tarball, possibly creating the directory if needed.\"\"\"\n        if tarball is None:\n            logger.error(\n                \"No tarball found for %s: probably a renamed project?\",\n                package)\n            return\n        target_dir = os.path.join(self.root_directory, package)\n        if not os.path.exists(target_dir):\n            os.mkdir(target_dir)\n            logger.info(\"Created %s\", target_dir)\n        logger.info(\"Copying tarball to %s\", target_dir)\n        shutil.copy(tarball, target_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ls(self):\n        width = max([len(x) for x in self.namespace.keys()])\n        for key, value in sorted(self.namespace.items()):\n            if key == \"_\":\n                continue\n            info = \"\"\n            if (isinstance(value, dict) or\n                isinstance(value, list) or key == \"services\"):\n                info = \"data\"\n            elif type(value).__name__ == \"module\":\n                info = value.__name__\n            elif type(value).__name__ == \"function\":\n                info = \"%s.%s\" % (value.__module__, value.__name__)\n            elif type(value).__name__ == \"instance\":\n                info = \"%s.%s\" % (value.__module__, value.__class__.__name__)\n            else:\n                info = \"%s.%s.%s\" % (\n                    value.im_class.__module__, value.im_class.__name__, key)\n            print \"\\t%s - %s\" % (key.ljust(width), info)", "response": "List the objects in the current namespace in alphabetical order."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a string to a unicode object.", "response": "def to_unicode(text, charset=None):\n    \"\"\"Convert input to an `unicode` object.\n\n    For a `str` object, we'll first try to decode the bytes using the given\n    `charset` encoding (or UTF-8 if none is specified), then we fall back to\n    the latin1 encoding which might be correct or not, but at least preserves\n    the original byte sequence by mapping each byte to the corresponding\n    unicode code point in the range U+0000 to U+00FF.\n\n    For anything else, a simple `unicode()` conversion is attempted,\n    with special care taken with `Exception` objects.\n    \"\"\"\n    if isinstance(text, str):\n        try:\n            return unicode(text, charset or 'utf-8')\n        except UnicodeDecodeError:\n            return unicode(text, 'latin1')\n    elif isinstance(text, Exception):\n        if os.name == 'nt' and \\\n                isinstance(text, (OSError, IOError)):  # pragma: no cover\n            # the exception might have a localized error string encoded with\n            # ANSI codepage if OSError and IOError on Windows\n            try:\n                return unicode(str(text), 'mbcs')\n            except UnicodeError:\n                pass\n        # two possibilities for storing unicode strings in exception data:\n        try:\n            # custom __str__ method on the exception (e.g. PermissionError)\n            return unicode(text)\n        except UnicodeError:\n            # unicode arguments given to the exception (e.g. parse_date)\n            return ' '.join([to_unicode(arg) for arg in text.args])\n    return unicode(text)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef exception_to_unicode(e, traceback=False):\n    message = '%s: %s' % (e.__class__.__name__, to_unicode(e))\n    if traceback:\n        from docido_sdk.toolbox import get_last_traceback\n        traceback_only = get_last_traceback().split('\\n')[:-2]\n        message = '\\n%s\\n%s' % (to_unicode('\\n'.join(traceback_only)), message)\n    return message", "response": "Convert an Exception to an unicode object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef levenshtein(s, t):\n    ''' From Wikipedia article; Iterative with two matrix rows. '''\n    if s == t:\n        return 0\n    elif len(s) == 0:\n        return len(t)\n    elif len(t) == 0:\n        return len(s)\n    v0 = [None] * (len(t) + 1)\n    v1 = [None] * (len(t) + 1)\n    for i in range(len(v0)):\n        v0[i] = i\n    for i in range(len(s)):\n        v1[0] = i + 1\n        for j in range(len(t)):\n            cost = 0 if s[i] == t[j] else 1\n            v1[j + 1] = min(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost)\n        for j in range(len(v0)):\n            v0[j] = v1[j]\n\n    return v1[len(t)]", "response": "Compute the Levenshtein distance between two strings."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef precmd(self, line):\n        line = line.lower()\n        \n        if line == 'exit' or line == 'help':\n            return line\n        \n        try:\n            parts = stmt.parseString(line)\n\n            if len(parts) == 2:\n                self.simple_report(parts)\n            else:\n                self.grouped_report(parts)\n        except ParseException, err:\n            pass\n        \n        return \"none\"", "response": "Parse the command on the given line."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns all posts in blog sorted by date", "response": "def get_allposts(self):\n\t\t''' Return all posts in blog sorted by date\n\t\t'''\n\t\tresult = self.client.posts(self.blog, offset = 0, limit = 1)\n\t\ttry: \n\t\t\ttotal_posts = result['total_posts']\n\t\texcept:\n\t\t\traise phasetumblr_errors.TumblrBlogException(result['meta']['msg'])\n\n\t\tdelta = (total_posts / 10) + 1\n\n\t\tall_posts = []\n\t\tposts_ids = []\n\t\tfor j in range(delta):\n\t\t\tstart = j * 10\n\t\t\tend = (j + 1) * 10\n\t\t\tposts = self.client.posts(self.blog, offset = start, limit = end)['posts']\n\t\t\tif not len(posts):\n\t\t\t\tbreak\n\t\t\tfor i in posts:\n\t\t\t\tif i['id'] in posts_ids:\n\t\t\t\t\tcontinue\n\t\t\t\tdescription = split_body(i['body'])\n\t\t\t\tbody = split_body(i['body'], 1)\n\t\t\t\tpost = {}\n\t\t\t\tpost['title'] = i['title']\n\t\t\t\tpost['link'] = i['post_url']\n\t\t\t\tpost['date'] = datetime.strptime(i['date'], '%Y-%m-%d %H:%M:%S %Z')\n\t\t\t\tpost['tags'] = i['tags']\n\t\t\t\tpost['id'] = i['id']\n\t\t\t\tpost['body'] = body\n\t\t\t\tpost['description'] = description\n\t\t\t\tall_posts.append(post)\n\t\t\t\tposts_ids.append(i['id'])\n\n\t\tnewlist = sorted(all_posts, key=lambda k: k['date']) \n\t\treturn newlist"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef n_to_pf(L, n, R):\n    dim = L.shape[0]\n    return (n * sphere_volume(R=R, n=dim)) / np.product(L)", "response": "Returns the packing fraction for a number of non - intersecting spheres."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pf_to_n(L, pf, R):\n    dim = L.shape[0]\n    n = int(round(pf * np.product(L) / sphere_volume(R, dim)))\n    pf_actual = n_to_pf(L, n, R)\n    return n, pf_actual", "response": "Returns the number of non - intersecting spheres required to achieve a packing fraction as close to a given packing fraction as possible along with the actual\n    achieved packing fraction as possible."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pack_simple(R, L, pf=None, n=None, rng=None, periodic=False):\n    if rng is None:\n        rng = np.random\n    if pf is not None:\n        if pf == 0.0:\n            return np.array([]), R\n        # If packing fraction is specified, find required number of spheres\n        # and the actual packing fraction this will produce\n        n, pf_actual = pf_to_n(L, pf, R)\n    elif n is not None:\n        if n == 0:\n            return np.array([]), R\n    if periodic:\n        return _pack_simple_periodic(R, L, n, rng)\n    else:\n        return _pack_simple(R, L, n, rng)", "response": "Pack a number of non - intersecting spheres into a single system."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pack(R, L, pf=None, n=None, rng=None, periodic=False,\n         beta_max=1e4, dL_max=0.02, dr_max=0.02):\n    \"\"\"Pack a number of non-intersecting spheres into a periodic system.\n\n    Can specify packing by number of spheres or packing fraction.\n\n    This implementation uses the Metropolis-Hastings algorithm for an\n    NPT system.\n\n    Parameters\n    ----------\n    R: float\n        Sphere radius.\n    L: float array, shape (d,)\n        System lengths.\n    pf: float or None\n        Packing fraction\n    n: integer or None\n        Number of spheres.\n    rng: RandomState or None\n        Random number generator. If None, use inbuilt numpy state.\n    periodic: bool\n        Whether or not the system is periodic.\n\n\n    Metropolis-Hastings parameters\n    ------------------------------\n    Playing with these parameters may improve packing speed.\n\n    beta_max: float, greater than zero.\n        Inverse temperature which controls how little noiseis in the system.\n    dL_max: float, 0 < dL_max < 1\n        Maximum fraction by which to perturb the system size.\n    dr_max: float, 0 < dr_max < 1\n        Maximum system fraction by which to perturb sphere positions.\n\n    Returns\n    -------\n    r: float array, shape (n, d)\n        Coordinates of the centres of the spheres for a valid configuration.\n    R_actual: float\n        Actual sphere radius used in the packing.\n    \"\"\"\n    if pf is not None:\n        if pf == 0.0:\n            return np.array([]), R\n        # If packing fraction is specified, find required number of spheres\n        # and the actual packing fraction this will produce\n        n, pf_actual = pf_to_n(L, pf, R)\n    elif n is not None:\n        if n == 0:\n            return np.array([]), R\n        # If n is specified, find packing fraction\n        pf_actual = n_to_pf(L, n, R)\n\n    # Calculate an initial packing fraction and system size\n    # Start at at most 0.5%; lower if the desired packing fraction is very low\n    pf_initial = min(0.005, pf_actual / 2.0)\n    # Find system size that will create this packing fraction\n    dim = L.shape[0]\n    increase_initial_ratio = (pf_actual / pf_initial) ** (1.0 / dim)\n    L_0 = L * increase_initial_ratio\n\n    # Pack naively into this system\n    r_0, R = pack_simple(R, L_0, n=n, rng=rng, periodic=periodic)\n\n    mg = metro_rcp_factory(periodic, r_0, L_0, R, dr_max, dL_max, rng=rng)\n\n    print('Initial packing done, Initial packing: {:g}'.format(mg.pf))\n\n    t = 0\n    while mg.pf < pf_actual:\n        t += 1\n        beta = beta_max * mg.pf\n        mg.iterate(beta)\n\n        if not t % every:\n            print('Packing: {:g}%'.format(100.0 * mg.pf))\n\n    print('Final packing: {:g}%'.format(100.0 * mg.pf))\n\n    return mg.r, mg.R", "response": "Pack a number of non - intersecting spheres into a single NPT system."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef relpath_for(self, path):\n        if self.parent_dir in (\".\", \"\"):\n            return path\n\n        if path == self.parent_dir:\n            return \"\"\n\n        dirname = os.path.dirname(path) or \".\"\n        basename = os.path.basename(path)\n\n        cached = self.relpath_cache.get(dirname, empty)\n        if cached is empty:\n            cached = self.relpath_cache[dirname] = os.path.relpath(dirname, self.parent_dir)\n\n        return os.path.join(cached, basename)", "response": "Find the relative path from here from the parent_dir"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind all the files we want to find and return a dictionary of the commit times for those files and the dates of those files.", "response": "def find(self):\n        \"\"\"\n        Find all the files we want to find commit times for, and any extra files\n        under symlinks.\n\n        Then find the commit times for those files and return a dictionary of\n        {relative_path: commit_time_as_epoch}\n        \"\"\"\n        mtimes = {}\n\n        git = Repo(self.root_folder)\n        all_files = git.all_files()\n        use_files = set(self.find_files_for_use(all_files))\n\n        # the git index won't find the files under a symlink :(\n        # And we include files under a symlink as seperate copies of the files\n        # So we still want to generate modified times for those files\n        extras = set(self.extra_symlinked_files(use_files))\n\n        # Combine use_files and extras\n        use_files.update(extras)\n\n        # Tell the user something\n        if not self.silent:\n            log.info(\"Finding modified times for %s/%s git controlled files in %s\", len(use_files), len(all_files), self.root_folder)\n\n        # Finally get the dates from git!\n        return self.commit_times_for(git, use_files)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef commit_times_for(self, git, use_files):\n        # Use real_relpath if it exists (SymlinkdPath) and default to just the path\n        # This is because we _want_ to compare the commits to the _real paths_\n        # As git only cares about the symlink itself, rather than files under it\n        # We also want to make sure that the symlink targets are included in use_files\n        # If they've been excluded by the filters\n        use_files_paths = set([getattr(p, \"real_relpath\", p.path) for p in use_files if p.relpath])\n\n        # Find us the first commit to consider\n        first_commit = str(git.first_commit)\n\n        # Try and get our cached commit times\n        # If we get a commit then it means we have a match for this parent/sorted_relpaths\n        commit_times = {}\n        cached_commit, cached_commit_times = None, {}\n        if self.with_cache:\n            sorted_relpaths = sorted([p.relpath for p in use_files])\n            cached_commit, cached_commit_times = get_cached_commit_times(self.root_folder, self.parent_dir, sorted_relpaths)\n\n            if cached_commit == first_commit:\n                commit_times = cached_commit_times\n\n        # If we couldn't find cached commit times, we have to do some work\n        if not commit_times:\n            for commit_id, commit_time, different_paths in git.file_commit_times(use_files_paths, debug=self.debug):\n                for path in different_paths:\n                    commit_times[path] = commit_time\n\n            if self.with_cache:\n                set_cached_commit_times(self.root_folder, self.parent_dir, first_commit, commit_times, sorted_relpaths)\n\n        # Finally, yield the (relpath, commit_time) for all the files we care about.\n        for key in use_files:\n            if key.relpath:\n                path = getattr(key, \"real_relpath\", key.path)\n                relpath = getattr(key, \"real_relpath\", key.relpath)\n                if path in commit_times:\n                    yield key.relpath, commit_times[path]\n                else:\n                    log.warning(\"Couldn't find commit time for {0}\".format(relpath))", "response": "Return a list of commit times for the use_files specified."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef extra_symlinked_files(self, potential_symlinks):\n        for key in list(potential_symlinks):\n            location = os.path.join(self.root_folder, key.path)\n            real_location = os.path.realpath(location)\n\n            if os.path.islink(location) and os.path.isdir(real_location):\n                for root, dirs, files in os.walk(real_location, followlinks=True):\n                    for name in files:\n                        # So this is joining the name of the symlink\n                        # With the name of the file, relative to the real location of the symlink\n                        full_path = os.path.join(root, name)\n                        rel_location = os.path.relpath(full_path, real_location)\n                        symlinkd_path = os.path.join(key.path, rel_location)\n\n                        # We then get that relative to the parent dir\n                        dir_part = os.path.relpath(root, real_location)\n                        symlinkd_relpath = os.path.normpath(os.path.join(key.relpath, dir_part, name))\n\n                        # And we need the original file location so we can get a commit time for the symlinkd path\n                        real_path = os.path.realpath(full_path)\n                        real_root_folder = os.path.realpath(self.root_folder)\n                        real_relpath = os.path.relpath(real_path, real_root_folder)\n\n                        # So that's path relative to root_folder, path relative to parent_folder\n                        # and path relative to root for the target\n                        yield SymlinkdPath(symlinkd_path, symlinkd_relpath, real_relpath)", "response": "Yields SymlinkdPath objects for each file that is found under the symlink."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_files_for_use(self, all_files):\n        for path in all_files:\n            # Find the path relative to the parent dir\n            relpath = self.relpath_for(path)\n\n            # Don't care about the ./\n            if relpath.startswith(\"./\"):\n                relpath = relpath[2:]\n\n            # Only care about paths that aren't filtered\n            if not self.is_filtered(relpath):\n                yield Path(path, relpath)", "response": "Given a list of all the files to consider yield a list of Path objects that are needed to be used for the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsays whether this relpath is filtered out", "response": "def is_filtered(self, relpath):\n        \"\"\"Say whether this relpath is filtered out\"\"\"\n        # Only include files under the parent_dir\n        if relpath.startswith(\"../\"):\n            return True\n\n        # Ignore files that we don't want timestamps from\n        if self.timestamps_for is not None and type(self.timestamps_for) is list:\n            match = False\n            for line in self.timestamps_for:\n                if fnmatch.fnmatch(relpath, line):\n                    match = True\n                    break\n            if not match:\n                return True\n\n        # Matched is true by default if\n        # * Have exclude\n        # * No exclude and no include\n        matched = self.exclude or not any([self.exclude, self.include])\n\n        # Anything not matching exclude gets included\n        if self.exclude:\n            for line in self.exclude:\n                if fnmatch.fnmatch(relpath, line):\n                    matched = False\n\n        # Anything matching include gets included\n        if self.include:\n            for line in self.include:\n                if fnmatch.fnmatch(relpath, line):\n                    matched = True\n                    break\n\n        return not matched"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_args_and_defaults(args, defaults):\n    defaults = defaults or []\n    args_and_defaults = [(argument, default) for (argument, default)\n                         in zip_longest(args[::-1], defaults[::-1],\n                                        fillvalue=NoDefault)]\n    return args_and_defaults[::-1]", "response": "Return a list of 2 - tuples - the argument name and its default value or\n        a special value that indicates there is no default value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngive a function docstring get the arg parse description and arguments and help message.", "response": "def _prepare_doc(func, args, delimiter_chars):\n    \"\"\"From the function docstring get the arg parse description and arguments\n        help message. If there is no docstring simple description and help\n        message are created.\n\n    Args:\n        func: the function that needs argument parsing\n        args: name of the function arguments\n        delimiter_chars: characters used to separate the parameters from their\n        help message in the docstring\n\n    Returns:\n        A tuple containing the description to be used in the argument parser and\n        a dict indexed on the callable argument name and their associated help\n        message\n    \"\"\"\n    _LOG.debug(\"Preparing doc for '%s'\", func.__name__)\n    if not func.__doc__:\n        return _get_default_help_message(func, args)\n    description = []\n    args_help = {}\n    fill_description = True\n    arg_name = None\n    arg_doc_regex = re.compile(\"\\b*(?P<arg_name>\\w+)\\s*%s\\s*(?P<help_msg>.+)\" %\n                               delimiter_chars)\n    for line in func.__doc__.splitlines():\n        line = line.strip()\n        if line and fill_description:\n            description.append(line)\n        elif line:\n            arg_match = arg_doc_regex.match(line)\n            try:\n                arg_name = arg_match.groupdict()[\"arg_name\"].strip()\n                args_help[arg_name] = arg_match.groupdict()[\"help_msg\"].strip()\n            except AttributeError:\n                # The line didn't match the pattern we've hit a\n                # multiline argument docstring so we add it to the\n                # previous argument help message\n                if arg_name is not None:\n                    args_help[arg_name] = \" \".join([args_help[arg_name], line])\n        else:\n            # The first empty line we encountered means we are done with\n            # the description. The first empty line we encounter after\n            # filling the argument help means we are done with argument\n            # parsing.\n            if not fill_description and args_help:\n                break\n            fill_description = False\n    return _get_default_help_message(func, args, \" \".join(description),\n                                     args_help)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn all methods of cls that are parseable i. e. have been decorated by '@create_parser'.", "response": "def _get_parseable_methods(cls):\n    \"\"\"Return all methods of cls that are parseable i.e. have been decorated\n    by '@create_parser'.\n\n    Args:\n        cls: the class currently being decorated\n\n    Note:\n        classmethods will not be included as they can only be referenced once\n        the class has been defined\n    Returns:\n        a 2-tuple with the parser of the __init__ method if any and a dict\n        of the form {'method_name': associated_parser}\n    \"\"\"\n    _LOG.debug(\"Retrieving parseable methods for '%s'\", cls.__name__)\n    init_parser = None\n    methods_to_parse = {}\n    for name, obj in vars(cls).items():\n        # Every callable object that has a 'parser' attribute will be\n        # added as a subparser.\n        # This won't work for classmethods because reference to\n        # classmethods are only possible once the class has been defined\n        if callable(obj) and hasattr(obj, \"parser\"):\n            _LOG.debug(\"Found method '%s'\", name)\n            if name == \"__init__\":\n                # If we find the decorated __init__ method it will be\n                # used as the top level parser\n                init_parser = obj.parser\n            else:\n                methods_to_parse[obj.__name__] = obj.parser\n    return (init_parser, methods_to_parse)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a default description for the parser and help message for the method.", "response": "def _get_default_help_message(func, args, description=None, args_help=None):\n    \"\"\"Create a default description for the parser and help message for the\n    agurments if they are missing.\n\n    Args:\n        func: the method we are creating a parser for\n        args: the argument names of the method\n        description: a potentially existing description created from the\n        function docstring\n        args_help: a dict {arg_name: help} with potentially missing arguments\n\n    Returns:\n        a tuple (arg_parse_description, complete_args_help)\n    \"\"\"\n    if description is None:\n        description = \"Argument parsing for %s\" % func.__name__\n    args_help = args_help or {}\n    # If an argument is missing a help message we create a simple one\n    for argument in [arg_name for arg_name in args\n                     if arg_name not in args_help]:\n        args_help[argument] = \"Help message for %s\" % argument\n    return (description, args_help)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an ArgumentParser for the given function.", "response": "def _get_arg_parser(func, types, args_and_defaults, delimiter_chars):\n    \"\"\"Return an ArgumentParser for the given function. Arguments are defined\n        from the function arguments and their associated defaults.\n\n    Args:\n        func: function for which we want an ArgumentParser\n        types: types to which the command line arguments should be converted to\n        args_and_defaults: list of 2-tuples (arg_name, arg_default)\n        delimiter_chars: characters used to separate the parameters from their\n        help message in the docstring\n    \"\"\"\n    _LOG.debug(\"Creating ArgumentParser for '%s'\", func.__name__)\n    (description, arg_help) = _prepare_doc(\n        func, [x for (x, _) in args_and_defaults], delimiter_chars)\n    parser = argparse.ArgumentParser(description=description)\n    for ((arg, default), arg_type) in zip_longest(args_and_defaults, types):\n        help_msg = arg_help[arg]\n        if default is NoDefault:\n            arg_type = arg_type or identity_type\n            if arg_type == bool:\n                _LOG.debug(\"Adding optional flag %s.%s\", func.__name__, arg)\n                parser.add_argument(\"--%s\" % arg, default=True, required=False,\n                                    action=\"store_false\",\n                                    help=\"%s. Defaults to True if not specified\"\n                                    % help_msg)\n            else:\n                _LOG.debug(\"Adding positional argument %s.%s\", func.__name__,\n                           arg)\n                parser.add_argument(arg, help=help_msg, type=arg_type)\n        else:\n            if default is None and arg_type is None:\n                raise ParseThisError(\"To use default value of 'None' you need \"\n                                     \"to specify the type of the argument '{}' \"\n                                     \"for the method '{}'\"\n                                     .format(arg, func.__name__))\n            arg_type = arg_type or type(default)\n            if arg_type == bool:\n                action = \"store_false\" if default else \"store_true\"\n                _LOG.debug(\"Adding optional flag %s.%s\", func.__name__, arg)\n                parser.add_argument(\"--%s\" % arg, help=help_msg,\n                                    default=default, action=action)\n            else:\n                _LOG.debug(\n                    \"Adding optional argument %s.%s\", func.__name__, arg)\n                parser.add_argument(\"--%s\" % arg, help=help_msg,\n                                    default=default, type=arg_type)\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the given arguments if it contains something else an empty list otherwise.", "response": "def _get_args_to_parse(args, sys_argv):\n    \"\"\"Return the given arguments if it is not None else sys.argv if it contains\n        something, an empty list otherwise.\n\n    Args:\n        args: argument to be parsed\n        sys_argv: arguments of the command line i.e. sys.argv\n    \"\"\"\n    arguments = args if args is not None else sys_argv[1:]\n    _LOG.debug(\"Parsing arguments: %s\", arguments)\n    return arguments"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _check_types(func_name, types, func_args, defaults):\n    defaults = defaults or []\n    if len(types) > len(func_args):\n        raise ParseThisError(\"To many types provided for conversion for '{}'.\"\n                             .format(func_name))\n    if len(types) < len(func_args) - len(defaults):\n        raise ParseThisError(\"Not enough types provided for conversion for '{}'\"\n                             .format(func_name))\n    if types and types[0] in [Self, Class]:\n        types = types[1:]\n        func_args = func_args[1:]\n    return (types, func_args)", "response": "Check that enough types were given to ensure conversion."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the method that is linked to the call method of the parser.", "response": "def _get_parser_call_method(func):\n    \"\"\"Returns the method that is linked to the 'call' method of the parser\n\n    Args:\n        func: the decorated function\n\n    Raises:\n        ParseThisError if the decorated method is __init__, __init__ can\n        only be decorated in a class decorated by parse_class\n    \"\"\"\n    func_name = func.__name__\n    parser = func.parser\n\n    def inner_call(instance=None, args=None):\n        \"\"\"This is method attached to <parser>.call.\n\n        Args:\n            instance: the instance of the parser\n            args: arguments to be parsed\n        \"\"\"\n        _LOG.debug(\"Calling %s.parser.call\", func_name)\n        # Defer this check in the method call so that __init__ can be\n        # decorated in class decorated with parse_class\n        if func_name == \"__init__\":\n            raise ParseThisError((\"To use 'create_parser' on the\"\n                                  \"'__init__' you need to decorate the \"\n                                  \"class with '@parse_class'\"))\n        namespace = parser.parse_args(_get_args_to_parse(args, sys.argv))\n        if instance is None:\n            # If instance is None we are probably decorating a function not a\n            # method and don't need the instance\n            args_name = _get_args_name_from_parser(parser)\n            return _call(func, args_name, namespace)\n        return _call_method_from_namespace(instance, func_name, namespace)\n\n    return inner_call"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_args_name_from_parser(parser):\n    # Retrieve the 'action' destination of the method parser i.e. its\n    # argument name. The HelpAction is ignored.\n    return [action.dest for action in parser._actions if not\n            isinstance(action, argparse._HelpAction)]", "response": "Retrieve the name of the function argument linked to the given parser."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall the method from the object with the correct arguments via the namespace.", "response": "def _call_method_from_namespace(obj, method_name, namespace):\n    \"\"\"Call the method, retrieved from obj, with the correct arguments via\n    the namespace\n\n    Args:\n        obj: any kind of object\n        method_name: method to be called\n        namespace: an argparse.Namespace object containing parsed command\n        line arguments\n    \"\"\"\n    method = getattr(obj, method_name)\n    method_parser = method.parser\n    arg_names = _get_args_name_from_parser(method_parser)\n    if method_name == \"__init__\":\n        return _call(obj, arg_names, namespace)\n    return _call(method, arg_names, namespace)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_url(profile, resource):\n    repo = profile[\"repo\"]\n    url = GITHUB_API_BASE_URL + \"repos/\" + repo + \"/git\" + resource\n    return url", "response": "Get the URL for a resource."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndoing a POST request to Github s API to merge a single item into a single item.", "response": "def post_merge_request(profile, payload):\n    \"\"\"Do a POST request to Github's API to merge.\n\n    Args:\n\n        profile\n            A profile generated from ``simplygithub.authentication.profile``.\n            Such profiles tell this module (i) the ``repo`` to connect to,\n            and (ii) the ``token`` to connect with.\n\n        payload\n            A dict of information to pass to Github's API as the payload for\n            a merge request, something like this::\n\n                { \"base\": <base>, \"head\": <head>, \"commit_message\": <mesg>}\n\n    Returns:\n        The response returned by the ``requests`` library when it does the\n        POST request.\n\n    \"\"\"\n    repo = profile[\"repo\"]\n    url = GITHUB_API_BASE_URL + \"repos/\" + repo + \"/merges\"\n    headers = get_headers(profile)\n    response = requests.post(url, json=payload, headers=headers)\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_request(profile, resource):\n    url = get_url(profile, resource)\n    headers = get_headers(profile)\n    response = requests.get(url, headers=headers)\n    return response.json()", "response": "Do a GET request to Github s API."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndoing a POST request to Github s API.", "response": "def post_request(profile, resource, payload):\n    \"\"\"Do a POST request to Github's API.\n\n    Args:\n\n        profile\n            A profile generated from ``simplygithub.authentication.profile``.\n            Such profiles tell this module (i) the ``repo`` to connect to,\n            and (ii) the ``token`` to connect with.\n\n        resource\n            The part of a Github API URL that comes after ``.../:repo/git``.\n            For instance, for ``.../:repo/git/commits``, it's ``/commits``.\n\n        payload\n            A dict of values to send as the payload of the POST request.\n            The data will be JSON-encoded.\n\n    Returns:\n        The body of the response, converted from JSON into a Python dict.\n\n    \"\"\"\n    url = get_url(profile, resource)\n    headers = get_headers(profile)\n    response = requests.post(url, json=payload, headers=headers)\n    return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_request(profile, resource):\n    url = get_url(profile, resource)\n    headers = get_headers(profile)\n    return requests.delete(url, headers=headers)", "response": "Do a DELETE request to Github s API."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the URI that you can use to authorize the user.", "response": "def authorize(self, client_id, redirect_uri, scope, \n                  state=None, user_name=None, user_email=None):\n        \"\"\"Documentation: `/oauth2/authorize\n        <https://www.wepay.com/developer/reference/oauth2#authorize>`_.\n\n        .. note::\n    \n           This is not an API call but an actual uri that you send the user to.\n\n        \"\"\"\n        query = [\n            ('client_id', client_id),\n            ('redirect_uri', redirect_uri),\n            ('scope', scope)\n        ]\n        if user_name is not None:\n            query.append(('user_name', user_name))\n        if user_email is not None:\n            query.append(('user_email', user_email))\n        if state is not None:\n            query.append(('state', state))\n        return '%s/oauth2/authorize?%s' % (\n            self._api.browser_endpoint, urllib.parse.urlencode(query))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __token(self, client_id, redirect_uri, client_secret, code, **kwargs):\n        params = {\n            'client_id': client_id,\n            'redirect_uri': redirect_uri,\n            'client_secret': client_secret,\n            'code': code\n        }\n        return self.make_call(self.__token, params, kwargs)", "response": "This method is used to make a call to the token API."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nextract the update and reset the buffer.", "response": "def _extract_updater(self):\n        \"\"\" Get the update and reset the buffer.\n        Return `None` if there is no update. \"\"\"\n        if self._node is self._buffer:\n            return None\n        else:\n            updater = (self._node, self._buffer)\n            self._buffer = self._node\n            return updater"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild the dependency graph based on the list of tasks produced by the parser.", "response": "def _build_graph(self):\n        \"\"\" Produce a dependency graph based on a list\n            of tasks produced by the parser.\n        \"\"\"\n        self._graph.add_nodes_from(self.tasks)\n        for node1 in self._graph.nodes:\n            for node2 in self._graph.nodes:\n                for input_file in node1.inputs:\n                    for output_file in node2.outputs:\n                        if output_file == input_file:\n                            self._graph.add_edge(node2, node1)\n        for order, task in enumerate(topological_sort(self._graph)):\n            task.predecessors = self._graph.predecessors(task)\n            task.order = order"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninserting the project into the database.", "response": "def insert(self, context):\n\t\n\t\t\"\"\"\n\t\tBuild the project.\n\t\t\n\t\t:param resort.engine.execution.Context context:\n\t\t   Current execution context.\n\t\t\"\"\"\n\t\t\n\t\tif self.__dependency:\n\t\t\tself.__execute(context, \"install\")\n\t\telse:\n\t\t\tself.__execute(context, \"package\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_value(self, key, args, kwargs):\n        if (self.tolerant and\n                not isinstance(key, basestring) and\n                key not in kwargs):\n            key = str(key)\n\n        return kwargs[key]", "response": "Get value only from mapping and possibly convert key to string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_field(self, field_name, args, kwargs):\n        try:\n            obj, arg_used = super(FormatterWrapper, self).get_field(\n                    field_name, args, kwargs)\n        except (KeyError, IndexError, AttributeError):\n            if not self.tolerant:\n                raise\n\n            obj = MissingField(field_name)\n            arg_used = field_name\n\n        return obj, arg_used", "response": "Create a special value when field missing and tolerant."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef convert_field(self, value, conversion):\n        if isinstance(value, MissingField):\n            if conversion is not None:\n                value.conversion = conversion\n            return value\n\n        return super(FormatterWrapper, self).convert_field(value, conversion)", "response": "When field missing store conversion specifier."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef configure_settings():\n    if not settings.configured:\n        db_config = {\n            'ENGINE': 'django.db.backends.sqlite3',\n            'NAME': 'django_kittens_db.sqlite3',\n        }\n\n        settings.configure(\n            TEST_RUNNER='django_nose.NoseTestSuiteRunner',\n            NOSE_ARGS=['--nocapture', '--nologcapture', '--verbosity=1'],\n            DATABASES={\n                'default': db_config,\n            },\n            INSTALLED_APPS=(\n                'django.contrib.auth',\n                'django.contrib.contenttypes',\n                'django.contrib.sessions',\n                'django.contrib.admin',\n                'django_kittens',\n                'django_kittens.tests',\n            ),\n            ROOT_URLCONF='django_kittens.urls',\n            DEBUG=True,\n            MIDDLEWARE_CLASSES=(),\n        )", "response": "Configure settings for manage. py and run_tests. py."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a dialog that updates the status of a given plugin package.", "response": "def update_plugin_dialog(package_name=None, update_args=None,\n                         update_kwargs=None, ignore_not_installed=True):\n    '''\n    Launch dialog to track status of update of specified plugin package.\n\n    .. versionadded:: 0.19\n\n    .. versionchanged:: 0.20\n        Add support for updating multiple packages (update all **installed**\n        plugins by default).\n\n        Add :data:`update_args` and :data:`update_kwargs` arguments.\n\n    .. versionchanged:: 0.20.1\n        Disable \"OK\" button until update has completed.\n\n        Add \"Cancel\" button.\n\n    .. versionchanged:: 0.20.3\n        Fix typo in handling of attempt to update plugin packages that are not\n        installed.\n\n    .. versionchanged:: 0.23\n        Add :data:`ignore_not_installed` parameter.\n\n    .. versionchanged:: 0.23.1\n        Fix bug in status message markup syntax when no packages are unlinked\n        **or** linked.\n\n    Parameters\n    ----------\n    package_name : str or list, optional\n        Conda MicroDrop plugin package name, e.g., `microdrop.mr-box-plugin`.\n\n        Multiple plugin package names may be provided as a list.\n\n        If no package name(s) specified, update **all installed** plugin\n        packages.\n    update_args : list or tuple, optional\n        Extra arguments to pass to :func:`mpm.api.update` call.\n    update_kwargs : dict, optional\n        Extra keyword arguments to pass to :func:`mpm.api.update` call.\n    ignore_not_installed : bool, optional\n        If ``True`` (*default*), ignore plugin packages that are not installed\n        as Conda packages.\n\n        Otherwise, a :class:`conda_heplers.PackageNotFound` exception will be\n        raised for plugins that are not installed as Conda packages.\n\n    Returns\n    -------\n    dict or None\n        Conda install log.\n\n        If dialog is closed or cancelled, ``None`` is returned.\n\n    Notes\n    -----\n    This function launches two threads; one to pulse the progress bar\n    periodically, and one to run the actual update attempt.\n    '''\n    thread_context = {}\n\n    if package_name is None:\n        # No plugin package specified.  Update all plugins which are installed\n        # as Conda packages.\n        installed_plugins_ = installed_plugins(only_conda=True)\n        installed_package_names = [plugin_i['package_name']\n                                   for plugin_i in installed_plugins_]\n        package_name = installed_package_names\n        logger.info('Update all plugins installed as Conda packages.')\n    else:\n        # At least one plugin package name was explicitly specified.\n        if isinstance(package_name, types.StringTypes):\n            package_name = [package_name]\n\n        # Only update plugins that are installed as Conda packages.\n        try:\n            conda_package_infos = ch.package_version(package_name, verbose=False)\n        except ch.PackageNotFound, exception:\n            # At least one specified plugin package name did not correspond to an\n            # installed Conda package.\n            if not ignore_not_installed:\n                # Raise error indicating at least one plugin is not installed\n                # as a Conda package.\n                raise\n            logger.warning(str(exception))\n            conda_package_infos = exception.available\n        # Extract name from each Conda plugin package.\n        package_name = [package_i['name'] for package_i in conda_package_infos]\n        logger.info('Update the following plugins: %s',\n                    ', '.join('`{}`'.format(name_i)\n                              for name_i in package_name))\n\n    # Format string list of packages.\n    package_name_list = ', '.join('`{}`'.format(name_i)\n                                  for name_i in package_name)\n    # Format multiple-lines string list of packages.\n    package_name_lines = '\\n'.join(' - {}'.format(name_i)\n                                   for name_i in package_name)\n\n    def _update(update_complete, package_name):\n        '''\n        Attempt to update plugin.  Display status message when complete.\n\n        Parameters\n        ----------\n        update_complete : threading.Event\n            Set when update operation has been completed.\n        package_name : str, list, or None\n            Conda MicroDrop plugin package name(s) (default to all installed\n            plugins).\n        '''\n        try:\n            with lh.logging_restore(clear_handlers=True):\n                args = update_args or []\n                kwargs = update_kwargs or {}\n                kwargs['package_name'] = package_name\n                # Pass extra args and kwargs to `.api.update` (if specified).\n                update_response = update(*args, **kwargs)\n                thread_context['update_response'] = update_response\n\n            # Display prompt indicating update status.\n\n            # Get list of unlinked and linked packages.\n            install_info_ = ch.install_info(update_response)\n\n            if any(install_info_):\n                # At least one package was uninstalled or installed (or\n                # \"unlinked\"/\"linked\" in Conda lingo).\n                def _status():\n                    updated_packages = []\n                    for package_name_i in package_name:\n                        if any(linked_i[0].startswith(package_name_i)\n                               for linked_i in install_info_[1]):\n                            # Plugin package was updated.\n                            updated_packages.append(package_name_i)\n\n                    def _version_lines(package_info_tuples):\n                        return (['<tt>'] + list(' - {} (from {})'\n                                                .format(name_i, channel_i)\n                                                for name_i, channel_i in\n                                                package_info_tuples) +\n                                ['</tt>'])\n                    detailed_message_lines = []\n                    if install_info_[0]:\n                        detailed_message_lines.append('<b>Uninstalled:</b>')\n                        (detailed_message_lines\n                         .extend(_version_lines(install_info_[0])))\n                    if install_info_[1]:\n                        detailed_message_lines.append('<b>Installed:</b>')\n                        (detailed_message_lines\n                         .extend(_version_lines(install_info_[1])))\n\n                    dialog.props.secondary_text = \\\n                        '\\n'.join(detailed_message_lines)\n                    dialog.props.secondary_use_markup = True\n                    dialog.props.use_markup = True\n\n                    if updated_packages:\n                        message = ('The following plugin(s) were updated '\n                                   'successfully:\\n<b><tt>{}</tt></b>'\n                                   .format(package_name_lines))\n                    else:\n                        message = ('Plugin dependencies were updated '\n                                   'successfully.')\n                    dialog.props.text = message\n            else:\n                # No packages were unlinked **or** linked.\n                def _status():\n                    #  1. Success (with previous version and new version).\n                    dialog.props.text = ('The latest version of the following '\n                                         'plugin(s) are already installed: '\n                                         '<tt><b>`{}`</b></tt>'\n                                         .format(package_name_list))\n                    dialog.props.use_markup = True\n            gobject.idle_add(_status)\n        except Exception, exception:\n            # Failure updating plugin.\n            def _error():\n                dialog.props.text = ('Error updating plugin(s):\\n<tt>{}</tt>'\n                                     .format(package_name_lines))\n                dialog.props.use_markup = True\n                exception_markup = gobject.markup_escape_text(str(exception))\n                exception_markup = exception_markup.replace(r'\\n', '\\n')\n\n                content_area = dialog.get_content_area()\n                label = gtk.Label()\n                label.set_markup(exception_markup)\n                error_scroll = gtk.ScrolledWindow()\n                error_scroll.set_policy(gtk.POLICY_AUTOMATIC,\n                                        gtk.POLICY_AUTOMATIC)\n                error_scroll.add_with_viewport(label)\n                error_scroll.show_all()\n\n                content_area.pack_start(error_scroll, expand=True, fill=True)\n            gobject.idle_add(_error)\n            thread_context['update_response'] = None\n        update_complete.set()\n\n    def _pulse(update_complete, progress_bar):\n        '''\n        Show pulsing progress bar to indicate activity.\n        '''\n        while not update_complete.wait(1. / 16):\n            gobject.idle_add(progress_bar.pulse)\n        def _on_complete():\n            progress_bar.set_fraction(1.)\n            progress_bar.hide()\n            # Enable \"OK\" button and focus it.\n            dialog.action_area.get_children()[1].props.sensitive = True\n            dialog.action_area.get_children()[1].grab_focus()\n        gobject.idle_add(_on_complete)\n\n    dialog = gtk.MessageDialog(buttons=gtk.BUTTONS_OK_CANCEL)\n    dialog.set_position(gtk.WIN_POS_MOUSE)\n    dialog.props.resizable = True\n    progress_bar = gtk.ProgressBar()\n    content_area = dialog.get_content_area()\n    content_area.pack_start(progress_bar, True, True, 5)\n    content_area.show_all()\n    # Disable \"OK\" button until update has completed.\n    dialog.action_area.get_children()[1].props.sensitive = False\n\n    dialog.props.title = 'Update plugin'\n    if len(package_name) > 1:\n        # Multiple packages were specified.\n        dialog.props.text = ('Searching for updates for:\\n<tt>{}</tt>'\n                             .format(package_name_lines))\n    else:\n        # A single package was specified.\n        dialog.props.text = ('Searching for updates for <tt>{}</tt>...'\n                             .format(package_name[0]))\n    dialog.props.use_markup = True\n\n    # Event to keep progress bar pulsing while waiting for update to\n    # complete.\n    update_complete = threading.Event()\n\n    # Launch thread to periodically pulse progress bar.\n    progress_thread = threading.Thread(target=_pulse, args=(update_complete,\n                                                            progress_bar, ))\n    progress_thread.daemon = True\n    progress_thread.start()\n\n    # Launch thread to attempt plugin update.\n    update_thread = threading.Thread(target=_update, args=(update_complete,\n                                                           package_name, ))\n    update_thread.daemon = True\n    update_thread.start()\n\n    # Show dialog.\n    dialog.run()\n    dialog.destroy()\n\n    # Return response from `conda_helpers.api.update` call.\n    return thread_context.get('update_response')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_last_thread(self):\n        cache_key = '_get_last_thread_cache'\n        if not hasattr(self, cache_key):\n            item = None\n            res = self.thread_set.filter(visible=True).order_by('-modified')[0:1]\n            if len(res)>0:\n                item = res[0]\n            setattr(self, cache_key, item)\n        return getattr(self, cache_key)", "response": "Return the last modified thread in the thread set"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_first_post(self):\n        cache_key = '_get_starter_cache'\n        if not hasattr(self, cache_key):\n            item = None\n            res = self.post_set.all().order_by('created')[0:1]\n            if len(res)>0:\n                item = res[0]\n            setattr(self, cache_key, item)\n        return getattr(self, cache_key)", "response": "Retourne le premier post en date celui crui cr\u00e9\u00e9lors du crui cr\u00e9ation du fil\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save(self, *args, **kwargs):\n        if self.created is None:\n            self.created = tz_now()\n        \n        if self.modified is None:\n            self.modified = self.created\n            \n        super(Thread, self).save(*args, **kwargs)", "response": "Save the object to the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_paginated_urlargs(self):\n        position = self.get_paginated_position()\n        \n        if not position:\n            return '#forum-post-{0}'.format(self.id)\n        \n        return '?page={0}#forum-post-{1}'.format(position, self.id)", "response": "Returns url arguments to retrieve the Post in a paginated list"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_paginated_position(self):\n        # If Post list is not paginated\n        if not settings.FORUM_THREAD_DETAIL_PAGINATE:\n            return 0\n        \n        count = Post.objects.filter(thread=self.thread_id, created__lt=self.created).count() + 1\n        \n        return int(math.ceil(count / float(settings.FORUM_THREAD_DETAIL_PAGINATE)))", "response": "Returns the position in the paginated list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the created and modified attributes on first create and allways update the thread s modified attribute", "response": "def save(self, *args, **kwargs):\n        \"\"\"\n        Fill 'created' and 'modified' attributes on first create and allways update \n        the thread's 'modified' attribute\n        \"\"\"\n        edited = not(self.created is None)\n        \n        if self.created is None:\n            self.created = tz_now()\n        \n        # Update de la date de modif. du message\n        if self.modified is None:\n            self.modified = self.created\n        else:\n            self.modified = tz_now()\n        \n        super(Post, self).save(*args, **kwargs)\n        \n        # Update de la date de modif. du thread lors de la cr\u00e9ation du message\n        if not edited:\n            self.thread.modified = self.created\n            self.thread.save()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist all available plugins", "response": "def get(search=\"unsigned\"):\n    \"\"\" List all available plugins\"\"\"\n    plugins = []\n    for i in os.walk('/usr/lib/nagios/plugins'):\n        for f in i[2]:\n            plugins.append(f)\n    return plugins"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(plugin_name, *args, **kwargs):\n    plugindir = nago.settings.get_option('plugin_dir')\n    plugin = plugindir + \"/\" + plugin_name\n    if not os.path.isfile(plugin):\n        raise ValueError(\"Plugin %s not found\" % plugin)\n\n    command = [plugin] + list(args)\n    p = subprocess.Popen(command, stdout=subprocess.PIPE,stderr=subprocess.PIPE,)\n    stdout, stderr = p.communicate('through stdin to stdout')\n    result = {}\n    result['stdout'] = stdout\n    result['stderr'] = stderr\n    result['return_code'] = p.returncode\n    return result", "response": "Run a specific plugin"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning the safe task.", "response": "def process(self, *args, **kwargs):\n        \"\"\"\n        args: list of arguments for the `runnable`\n        kwargs: dictionary of arguments for the `runnable`\n        \"\"\"\n        try:\n            timeout_seconds = self.timeout_timedelta.total_seconds()\n            with timeout(self.run, timeout_seconds) as run:\n                run(*args, **kwargs)\n        except Exception as e:\n            if self.verbose:\n                if isinstance(e, TimeoutError):\n                    logger.error('SafeTask timed out: %s', e, exc_info=True)\n                else:\n                    logger.error('Error running SafeTask: %s',\n                                 e, exc_info=True)\n            self.on_error(e, *args, **kwargs)\n        else:\n            self.on_success(*args, **kwargs)\n        finally:\n            self.on_completion(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_ctx(elt):\n\n    result = elt  # by default, result is ctx\n\n    # if elt is ctx and elt is a method, it is possible to find the best ctx\n    if ismethod(elt):\n        # get instance and class of the elt\n        instance = get_method_self(elt)\n        # if instance is not None, the right context is the instance\n        if instance is not None:\n            result = instance\n\n        elif PY2:\n            result = elt.im_class\n\n    return result", "response": "Find the right context element that is related to elt."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfrees the cached properties bound to input cached elts.", "response": "def free_cache(ctx, *elts):\n    \"\"\"Free properties bound to input cached elts. If empty, free the whole\n    cache.\n    \"\"\"\n\n    for elt in elts:\n        if isinstance(elt, Hashable):\n            cache = __STATIC_ELEMENTS_CACHE__\n        else:\n            cache = __UNHASHABLE_ELTS_CACHE__\n            elt = id(elt)\n        if elt in cache:\n            del cache[elt]\n\n    if not elts:\n        __STATIC_ELEMENTS_CACHE__.clear()\n        __UNHASHABLE_ELTS_CACHE__.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting elt properties related to a given elt.", "response": "def _ctx_elt_properties(elt, ctx=None, create=False):\n    \"\"\"Get elt properties related to a ctx.\n\n    :param elt: property component elt. Not None methods or unhashable types.\n    :param ctx: elt ctx from where get properties. Equals elt if None. It\n        allows to get function properties related to a class or instance if\n        related function is defined in base class.\n    :param bool create: create ctx elt properties if not exist.\n\n    :return: dictionary of property by name embedded into ctx __dict__ or in\n        shared __STATIC_ELEMENTS_CACHE__ or else in shared\n        __UNHASHABLE_ELTS_CACHE__. None if no properties exists.\n    :rtype: dict\n    \"\"\"\n\n    result = None\n\n    if ctx is None:\n        ctx = find_ctx(elt=elt)\n\n    ctx_properties = None\n\n    # in case of dynamic object, parse the ctx __dict__\n    ctx__dict__ = getattr(ctx, __DICT__, None)\n    if ctx__dict__ is not None and isinstance(ctx__dict__, dict):\n        # if properties exist in ctx__dict__\n        if __B3J0F__PROPERTIES__ in ctx__dict__:\n            ctx_properties = ctx__dict__[__B3J0F__PROPERTIES__]\n        elif create:  # if create in worst case\n            ctx_properties = ctx__dict__[__B3J0F__PROPERTIES__] = {}\n\n    else:  # in case of static object\n        if isinstance(ctx, Hashable):  # search among static elements\n            cache = __STATIC_ELEMENTS_CACHE__\n        else:  # or unhashable elements\n            cache = __UNHASHABLE_ELTS_CACHE__\n            ctx = id(ctx)\n            if not isinstance(elt, Hashable):\n                elt = id(elt)\n        # if ctx is in cache\n        if ctx in cache:\n            # get its properties\n            ctx_properties = cache[ctx]\n        elif create:  # elif create, get an empty dict\n            ctx_properties = cache[ctx] = {}\n\n    # if ctx_properties is not None\n    if ctx_properties is not None:\n        # check if elt exist in ctx_properties\n        if elt in ctx_properties:\n            result = ctx_properties[elt]\n        elif create:  # create the right data if create\n            if create:\n                result = ctx_properties[elt] = {}\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_properties(elt, keys=None, ctx=None):\n\n    # initialize keys if str\n    if isinstance(keys, string_types):\n        keys = (keys,)\n\n    result = _get_properties(elt, keys=keys, local=False, ctx=ctx)\n\n    return result", "response": "Get properties from an elt."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting elt key property.", "response": "def get_property(elt, key, ctx=None):\n    \"\"\"Get elt key property.\n\n    :param elt: property elt. Not None methods.\n    :param key: property key to get from elt.\n    :param ctx: elt ctx from where get properties. Equals elt if None. It\n        allows to get function properties related to a class or instance if\n        related function is defined in base class.\n\n    :return: list of property values by elt.\n    :rtype: list\n    \"\"\"\n\n    result = []\n\n    properties = get_properties(elt=elt, ctx=ctx, keys=key)\n\n    if key in properties:\n        result = properties[key]\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_first_properties(elt, keys=None, ctx=None):\n\n    # ensure keys is an iterable if not None\n    if isinstance(keys, string_types):\n        keys = (keys,)\n\n    result = _get_properties(elt, keys=keys, first=True, ctx=ctx)\n\n    return result", "response": "Get first properties related to one input key."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets first property related to one input key.", "response": "def get_first_property(elt, key, default=None, ctx=None):\n    \"\"\"Get first property related to one input key.\n\n    :param elt: first property elt. Not None methods.\n    :param str key: property key to get.\n    :param default: default value to return if key does not exist in elt.\n        properties\n    :param ctx: elt ctx from where get properties. Equals elt if None. It\n        allows to get function properties related to a class or instance if\n        related function is defined in base class.\n    \"\"\"\n\n    result = default\n\n    properties = _get_properties(elt, keys=(key,), ctx=ctx, first=True)\n\n    # set value if key exists in properties\n    if key in properties:\n        result = properties[key]\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_local_properties(elt, keys=None, ctx=None):\n\n    if isinstance(keys, string_types):\n        keys = (keys,)\n\n    result = _get_properties(elt, keys=keys, local=True, ctx=ctx)\n\n    return result", "response": "Get local properties of an elt."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget one local property related to one input key or default value if key does not exist in elt .", "response": "def get_local_property(elt, key, default=None, ctx=None):\n    \"\"\"Get one local property related to one input key or default value if key\n    is not found.\n\n    :param elt: local property elt. Not None methods.\n    :param str key: property key to get.\n    :param default: default value to return if key does not exist in elt\n        properties.\n    :param ctx: elt ctx from where get properties. Equals elt if None. It\n        allows to get function properties related to a class or instance if\n        related function is defined in base class.\n    :return: dict of properties by name.\n    :rtype: dict\n    \"\"\"\n\n    result = default\n\n    local_properties = get_local_properties(elt=elt, keys=(key,), ctx=ctx)\n\n    if key in local_properties:\n        result = local_properties[key]\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_properties(\n    elt, keys=None, local=False, exclude=None, first=False, ctx=None,\n    _found_keys=None\n):\n    \"\"\"Get a dictionary of elt properties.\n\n    Such dictionary is filled related to the elt properties, and from all base\n        elts properties if not local.\n\n    :param elt: properties elt. Not None methods.\n    :param ctx: elt ctx from where get properties. Equals elt if None. It\n        allows to get function properties related to a class or instance if\n        related function is defined in base class.\n    :param keys: keys of properties to get from elt. If None, get all\n        properties.\n    :param bool local: if False, get properties from bases classes and type\n        as well.\n    :param set exclude: elts from where not get properties.\n    :param bool first: get only first property values.\n    :param _found_keys: used such as a cache value for result.\n\n    :return: dict of properties by name and ...:\n\n        - if local or first: value.\n        - other cases: [(elt, value)] in order of property definition even if\n            multi inheritance do not ensure to respect inheritance order in a\n            list.\n    :rtype: dict\n    \"\"\"\n\n    result = {}\n\n    # get the best context\n    if ctx is None:\n        ctx = find_ctx(elt=elt)\n\n    # initialize found keys\n    if first and _found_keys is None:\n        _found_keys = set()\n\n    # get elt properties if exist\n    elt_properties = _ctx_elt_properties(elt=elt, ctx=ctx, create=False)\n\n    # if elt_properties exists\n    if elt_properties is not None:\n        # if elt properties is not empty\n        # try to add property values in result related to input keys\n        properties_to_keep = elt_properties.copy() if keys is None else {}\n        # get key values\n        if keys is not None:\n            for key in keys:\n                if key in elt_properties:\n                    if not first or key not in _found_keys:\n                        properties_to_keep[key] = elt_properties[key]\n                    if first and key not in _found_keys:\n                        _found_keys.add(key)\n\n        if local:  # in case of local, use properties_to_keep\n            result = properties_to_keep\n\n        # if not local and not first and properties to keep\n        elif not first and properties_to_keep:\n            for name in properties_to_keep:\n                property_to_keep = properties_to_keep[name]\n                # add (elt, properties_to_keep) in result\n                if name not in result:\n                    result[name] = [(elt, property_to_keep)]\n                else:\n                    result[name].append((elt, property_to_keep))\n\n        # in case of first, result is properties_to_keep\n        elif properties_to_keep:\n            result = properties_to_keep\n    # check if all keys have been found if first\n    keys_left = not first or keys is None or len(keys) != len(_found_keys)\n\n    # if not local or keys left\n    if not local and keys_left:\n        # initialize exclude\n        if exclude is None:\n            exclude = set()\n\n        # add elt in exclude in order to avoid to get elt properties twice\n        if isinstance(elt, Hashable):\n            exclude.add(elt)\n\n        # and search among bases ctx elements\n        if ctx is not elt:\n            # go to base elts\n            try:\n                elt_name = elt.__name__\n            except AttributeError:\n                pass\n            else:\n                # if elt is a sub attr of ctx\n                if hasattr(ctx, elt_name):\n                    if hasattr(ctx, __BASES__):\n                        ctx_bases = ctx.__bases__\n                    elif hasattr(ctx, __CLASS__):\n                        ctx_bases = (ctx.__class__,)\n                    else:\n                        ctx_bases = ()\n                    for base_ctx in ctx_bases:\n                        # get base_elt properties\n                        base_elt = getattr(base_ctx, elt_name, None)\n                        if base_elt is not None:\n                            base_properties = _get_properties(\n                                elt=base_elt,\n                                keys=keys,\n                                local=local,\n                                exclude=exclude,\n                                ctx=base_ctx,\n                                _found_keys=_found_keys\n                            )\n                            # update result with base_properties\n                            for name in base_properties:\n                                properties = base_properties[name]\n                                if name not in result:\n                                    result[name] = properties\n                                else:\n                                    result[name] += properties\n\n        else:\n            # bases classes\n            if hasattr(elt, __BASES__):\n                for base in elt.__bases__:\n                    if base not in exclude:\n                        base_result = _get_properties(\n                            elt=base,\n                            keys=keys,\n                            local=local,\n                            exclude=exclude,\n                            ctx=base,\n                            _found_keys=_found_keys\n                        )\n                        # update result with base_result\n                        for name in base_result:\n                            properties = base_result[name]\n                            if name not in result:\n                                result[name] = properties\n                            else:\n                                result[name] += properties\n\n            # search among type definition\n\n            # class\n            if hasattr(elt, __CLASS__):\n                elt_class = elt.__class__\n                # get class properties only if elt is not its own class\n                if elt_class is not elt and elt_class not in exclude:\n                    elt_class_properties = _get_properties(\n                        elt=elt_class,\n                        keys=keys,\n                        local=local,\n                        exclude=exclude,\n                        ctx=elt_class,\n                        _found_keys=_found_keys\n                    )\n                    # update result with class result\n                    for name in elt_class_properties:\n                        properties = elt_class_properties[name]\n                        if name not in result:\n                            result[name] = properties\n                        else:\n                            result[name] += properties\n\n            # type\n            elt_type = type(elt)\n            # get elt type properties only if elt is not its type\n            if elt_type is not elt and elt_type not in exclude:\n                elt_type_properties = _get_properties(\n                    elt=elt_type,\n                    keys=keys,\n                    local=local,\n                    exclude=exclude,\n                    ctx=elt_type,\n                    _found_keys=_found_keys\n                )\n                # update result with type properties\n                for name in elt_type_properties:\n                    properties = elt_type_properties[name]\n                    if name not in result:\n                        result[name] = properties\n                    else:\n                        result[name] += properties\n\n    return result", "response": "Get a dictionary of properties related to an elt."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nputting properties in an element.", "response": "def put_property(elt, key, value, ttl=None, ctx=None):\n    \"\"\"Put properties in elt.\n\n    :param elt: properties elt to put. Not None methods.\n    :param number ttl: If not None, property time to leave.\n    :param ctx: elt ctx from where put properties. Equals elt if None. It\n        allows to get function properties related to a class or instance if\n        related function is defined in base class.\n    :param dict properties: properties to put in elt. elt and ttl are exclude.\n\n    :return: Timer if ttl is not None.\n    :rtype: Timer\n    \"\"\"\n    return put_properties(elt=elt, properties={key: value}, ttl=ttl, ctx=ctx)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef put_properties(elt, properties, ttl=None, ctx=None):\n\n    result = None\n\n    if properties:\n\n        # get the best context\n        if ctx is None:\n            ctx = find_ctx(elt=elt)\n\n        # get elt properties\n        elt_properties = _ctx_elt_properties(elt=elt, ctx=ctx, create=True)\n\n        # set properties\n        elt_properties.update(properties)\n\n        if ttl is not None:\n            kwargs = {\n                'elt': elt,\n                'ctx': ctx,\n                'keys': tuple(properties.keys())\n            }\n            result = Timer(ttl, del_properties, kwargs=kwargs)\n            result.start()\n\n    return result", "response": "Put properties in an element."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef put(properties, ttl=None, ctx=None):\n\n    def put_on(elt):\n        return put_properties(elt=elt, properties=properties, ttl=ttl, ctx=ctx)\n\n    return put_on", "response": "Decorator for creating properties on an element."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef del_properties(elt, keys=None, ctx=None):\n\n    # get the best context\n    if ctx is None:\n        ctx = find_ctx(elt=elt)\n\n    elt_properties = _ctx_elt_properties(elt=elt, ctx=ctx, create=False)\n\n    # if elt properties exist\n    if elt_properties is not None:\n\n        if keys is None:\n            keys = list(elt_properties.keys())\n\n        else:\n            keys = ensureiterable(keys, iterable=tuple, exclude=str)\n\n        for key in keys:\n            if key in elt_properties:\n                del elt_properties[key]\n\n        # delete property component if empty\n        if not elt_properties:\n            # case of dynamic object\n            if isinstance(getattr(ctx, '__dict__', None), dict):\n                try:\n                    if elt in ctx.__dict__[__B3J0F__PROPERTIES__]:\n                        del ctx.__dict__[__B3J0F__PROPERTIES__][elt]\n                except TypeError:  # if elt is unhashable\n                    elt = id(elt)\n                    if elt in ctx.__dict__[__B3J0F__PROPERTIES__]:\n                        del ctx.__dict__[__B3J0F__PROPERTIES__][elt]\n                # if ctx_properties is empty, delete it\n                if not ctx.__dict__[__B3J0F__PROPERTIES__]:\n                    del ctx.__dict__[__B3J0F__PROPERTIES__]\n\n            # case of static object and hashable\n            else:\n                if isinstance(ctx, Hashable):\n                    cache = __STATIC_ELEMENTS_CACHE__\n                else:  # case of static and unhashable object\n                    cache = __UNHASHABLE_ELTS_CACHE__\n                    ctx = id(ctx)\n                    if not isinstance(elt, Hashable):\n                        elt = id(elt)\n\n                # in case of static object\n                if ctx in cache:\n                    del cache[ctx][elt]\n                    if not cache[ctx]:\n                        del cache[ctx]", "response": "Delete properties from an elt."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef firsts(properties):\n\n    result = {}\n\n    # parse elts\n    for name in properties:\n        elt_properties = properties[name]\n        # add property values in result[name]\n        result[name] = elt_properties[0][1]\n\n    return result", "response": "Transform a dictionary of properties where names are first\n        encountered in input properties."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntransforms a dictionary of properties of a node to a dictionary of navigable elements.", "response": "def remove_ctx(properties):\n    \"\"\"\n    Transform a dictionary of {name: [(elt, value)+]} into a dictionary of\n        {name: [value+]}.\n\n    :param dict properties: properties from where get only values.\n    :return: dictionary of parameter values by names.\n    :rtype: dict\n    \"\"\"\n    result = {}\n\n    for name in properties:\n        elt_properties = properties[name]\n        result[name] = []\n        for _, value in elt_properties:\n            result[name].append(value)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setdefault(elt, key, default, ctx=None):\n\n    result = default\n\n    # get the best context\n    if ctx is None:\n        ctx = find_ctx(elt=elt)\n\n    # get elt properties\n    elt_properties = _ctx_elt_properties(elt=elt, ctx=ctx, create=True)\n\n    # if key exists in elt properties\n    if key in elt_properties:\n        # result is elt_properties[key]\n        result = elt_properties[key]\n    else:  # set default property value\n        elt_properties[key] = default\n\n    return result", "response": "Get a local property and create default value if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef addproperties(\n        names,\n        bfget=None, afget=None, enableget=True,\n        bfset=None, afset=None, enableset=True,\n        bfdel=None, afdel=None, enabledel=True\n):\n    \"\"\"Decorator in charge of adding python properties to cls.\n\n    {a/b}fget, {a/b}fset and {a/b}fdel are applied to all properties matching\n    names in taking care to not forget default/existing properties. The\n    prefixes *a* and *b* are respectively for after and before default/existing\n    property getter/setter/deleter execution.\n\n    These getter, setter and deleter functions are called before existing or\n    default getter, setter and deleters. Default getter, setter and deleters\n    are functions which uses an attribute with a name starting with '_' and\n    finishing with the property name (like the python language convention).\n\n    .. seealso::\n        _protectedattrname(name)\n\n    :param str(s) names: property name(s) to add.\n    :param bfget: getter function to apply to all properties before\n        default/existing getter execution. Parameters are a decorated cls\n        instance and a property name.\n    :param afget: fget function to apply to all properties after\n        default/existing getter execution. Parameters are a decorated cls\n        instance and a property name.\n    :param bool enableget: if True (default), enable existing or default getter\n        . Otherwise, use only fget if given.\n    :param bfset: fset function to apply to all properties before\n        default/existing setter execution. Parameters are a decorated cls\n        instance and a property name.\n    :param afset: fset function to apply to all properties after\n        default/existing setter execution. Parameters are a decorated cls\n        instance and a property name.\n    :param bool enableset: if True (default), enable existing or default setter\n        . Otherwise, use only fset if given.\n    :param bfdel: fdel function to apply to all properties before\n        default/existing deleter execution. Parameters are a decorated cls\n        instance and a property name.\n    :param bfdel: fdel function to apply to all properties after\n        default/existing deleter execution. Parameters are a decorated cls\n        instance and a property name.\n    :param bool enabledel: if True (default), enable existing or default\n        deleter. Otherwise, use only fdel if given.\n    :return: cls decorator.\n    \"\"\"\n\n    # ensure names is a list\n    names = ensureiterable(names, exclude=string_types)\n\n    if isinstance(bfget, MethodType):\n        finalbfget = lambda self, name: bfget(name)\n    else:\n        finalbfget = bfget\n\n    if isinstance(afget, MethodType):\n        finalafget = lambda self, name: afget(name)\n    else:\n        finalafget = afget\n\n    if isinstance(bfset, MethodType):\n        finalbfset = lambda self, value, name: bfset(value, name)\n    else:\n        finalbfset = bfset\n\n    if isinstance(afset, MethodType):\n        finalafset = lambda self, value, name: afset(value, name)\n    else:\n        finalafset = afset\n\n    if isinstance(bfdel, MethodType):\n        finalbfdel = lambda self, name: bfdel(name)\n    else:\n        finalbfdel = bfdel\n\n    if isinstance(afdel, MethodType):\n        finalafdel = lambda self, name: afdel(name)\n    else:\n        finalafdel = afdel\n\n    def _addproperties(cls):\n        \"\"\"Add properties to cls.\n\n        :param type cls: cls on adding properties.\n        :return: cls\n        \"\"\"\n\n        for name in names:\n            protectedattrname = _protectedattrname(name)\n            # try to find an existing property\n            existingproperty = getattr(cls, name, None)\n\n            if isinstance(existingproperty, property):\n                _fget = existingproperty.fget\n                _fset = existingproperty.fset\n                _fdel = existingproperty.fdel\n\n            else:\n                _fget, _fset, _fdel = None, None, None\n\n            # construct existing/default getter\n            if _fget is None:\n                def _fget(protectedattrname):\n                    \"\"\"Simple getter wrapper.\"\"\"\n                    def _fget(self):\n                        \"\"\"Simple getter.\"\"\"\n                        return getattr(self, protectedattrname, None)\n                    return _fget\n                _fget = _fget(protectedattrname)\n                _fget.__doc__ = 'Get this {0}.\\n:return: this {0}.'.format(\n                    name\n                )\n            # transform method to function in order to add self in parameters\n            if isinstance(_fget, MethodType):\n                final_fget = lambda self: _fget()\n\n            else:\n                final_fget = _fget\n\n            # construct existing/default setter\n            if _fset is None:\n                def _fset(protectedattrname):\n                    \"\"\"Simple setter wrapper.\"\"\"\n                    def _fset(self, value):\n                        \"\"\"Simple setter.\"\"\"\n                        setattr(self, protectedattrname, value)\n                    return _fset\n                _fset = _fset(protectedattrname)\n                _fset.__doc__ = (\n                    'Change of {0}.\\n:param {0}: {0} to use.'.format(name)\n                )\n            # transform method to function in order to add self in parameters\n            if isinstance(_fset, MethodType):\n                final_fset = lambda self, value: _fset(value)\n\n            else:\n                final_fset = _fset\n\n            # construct existing/default deleter\n            if _fdel is None:\n                def _fdel(protectedattrname):\n                    \"\"\"Simple deleter wrapper.\"\"\"\n                    def _fdel(self):\n                        \"\"\"Simple deleter.\"\"\"\n                        if hasattr(self, protectedattrname):\n                            delattr(self, protectedattrname)\n                    return _fdel\n                _fdel = _fdel(protectedattrname)\n                _fdel.__doc__ = 'Delete this {0}.'.format(name)\n            # transform method to function in order to add self in parameters\n            if isinstance(_fdel, MethodType):\n                final_fdel = lambda self: _fdel()\n            else:\n                final_fdel = _fdel\n\n            def _getter(final_fget, name):\n                \"\"\"Property getter wrapper.\"\"\"\n                def _getter(self):\n                    \"\"\"Property getter.\"\"\"\n                    result = None\n                    # start to process input bfget\n                    if finalbfget is not None:\n                        result = finalbfget(self, name)\n                    # process cls getter\n                    if enableget:\n                        result = final_fget(self)\n                    # finish to process afget\n                    if finalafget is not None:\n                        result = finalafget(self, name)\n                    return result\n                return _getter\n            _getter = _getter(final_fget, name)\n            _getter.__doc__ = final_fget.__doc__  # update doc\n\n            def _setter(final_fset, name):\n                \"\"\"Property setter wrapper.\"\"\"\n                def _setter(self, value):\n                    \"\"\"Property setter.\"\"\"\n                    # start to process input bfset\n                    if finalbfset is not None:\n                        finalbfset(self, value, name)\n                    # finish to process cls setter\n                    if enableset:\n                        final_fset(self, value)\n                    # finish to process afset\n                    if finalafset is not None:\n                        finalafset(self, value, name)\n                return _setter\n            _setter = _setter(final_fset, name)\n            _setter.__doc__ = final_fset.__doc__  # update doc\n\n            def _deleter(final_fdel, name):\n                \"\"\"Property deleter wrapper.\"\"\"\n                def _deleter(self):\n                    \"\"\"Property deleter.\"\"\"\n                    # start to process input fdel\n                    if finalbfdel is not None:\n                        finalbfdel(self, name)\n                    # finish to process cls deleter\n                    if enabledel:\n                        final_fdel(self)\n                    # finish to process afget\n                    if finalafdel is not None:\n                        finalafdel(self, name)\n                return _deleter\n            _deleter = _deleter(final_fdel, name)\n            _deleter.__doc__ = final_fdel.__doc__  # update doc\n\n            # get property name\n            doc = '{0} property.'.format(name)\n            propertyfield = property(\n                fget=_getter, fset=_setter, fdel=_deleter, doc=doc\n            )\n\n            # put property name in cls\n            setattr(cls, name, propertyfield)\n\n        return cls  # finish to return the cls\n\n    return _addproperties", "response": "Decorator to add python properties to the base class containing the given property names."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_jsonparsed_data(url):\n    response = urlopen(url)\n    data = response.read().decode('utf-8')\n    return json.loads(data)", "response": "Receive the content of url and return the\n       object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_stats(package):\n\n    grand_total = 0\n\n    if '==' in package:\n        package, version = package.split('==')\n    try:\n        package = normalize(package)\n        version = None\n    except ValueError:\n        raise RuntimeError('No such module or package %r' % package)\n\n    # Count downloads\n    total, releases = count_downloads(\n        package,\n        json=True,\n        version=version,\n    )\n\n    result = {\n        'version': version,\n        'releases': releases,\n    }\n\n    grand_total += total\n\n    return result, grand_total, version", "response": "Fetch raw statistics of a package"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting statistics for a package and then corrects them using a special honeypot.", "response": "def get_corrected_stats(package, use_honeypot=True):\n    \"\"\"\n    Fetches statistics for `package` and then corrects them using a special\n    honeypot.\n    \"\"\"\n\n    honeypot, __, __ = get_stats('python-bogus-project-honeypot')\n\n    if not honeypot:\n        raise RuntimeError(\"Could not get honeypot data\")\n\n    honeypot = honeypot['releases']\n    # Add a field used to store diff when choosing the best honey pot release\n    # for some statistic\n    for x in honeypot:\n        x['diff'] = 0\n\n    stats, __, version = get_stats(package)\n\n    if not stats:\n        return\n\n    # Denote release date diff and choose the honey pot release that's closest\n    # to the one of each release\n\n    releases = stats['releases']\n\n    for release in releases:\n\n        # Sort by absolute difference\n        honeypot.sort(key=lambda x: abs(\n            (x['upload_time'] - release['upload_time']).total_seconds()\n        ))\n        # Multiple candidates\n        honeypot_filtered = list(filter(lambda x: x['diff'] == honeypot[0]['diff'], honeypot))\n        average_downloads = sum([x['downloads'] for x in honeypot_filtered]) / len(honeypot_filtered)\n\n        release['downloads'] = release['downloads'] - average_downloads\n\n    # Re-calculate totals\n    total_count = sum([x['downloads'] for x in releases])\n\n    return stats, total_count, version"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextracts a group from Facebook.", "response": "def extract(group_id, access_token, fields=None):\n    '''\n    FIXME: DOCS...\n    Links:\n       * https://developers.facebook.com/tools/explorer/\n\n    '''\n    fields = fields or ['id', 'owner', 'email', 'name', 'members']\n    # TEST that fields are a subset of valid fields\n    assert set(fields).issubset(VALID_FIELDS)\n\n    get_args = {'fields': ','.join(fields),\n                'access_token': access_token}\n    get_args_str = '&'.join(\n        ['{}={}'.format(x, y) for x, y in get_args.items()])\n\n    base_url = 'https://graph.facebook.com/{}/?{}'.format(\n        group_id, get_args_str)\n    logr.debug(' LOADING URL: {}'.format(base_url))\n\n    response = rq.get(base_url)\n\n    # FIXME: check for errors\n    # probably want to validate here somehow...?\n    r_json = response.json()\n    subscribers = r_json.get('members')\n\n    return subscribers"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unique_iter(seq):\n    seen = set()\n    return [x for x in seq if x not in seen and not seen.add(x)]", "response": "Returns a list of unique elements in a sequence."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nensures that value is a subclass of types", "response": "def ensure_subclass(value, types):\n    \"\"\"\n    Ensure value is a subclass of types\n\n    >>> class Hello(object): pass\n    >>> ensure_subclass(Hello, Hello)\n    >>> ensure_subclass(object, Hello)\n    Traceback (most recent call last):\n    TypeError:\n    \"\"\"\n    ensure_class(value)\n    if not issubclass(value, types):\n        raise TypeError(\n            \"expected subclass of {}, not {}\".format(\n                types, value))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ensure_instance(value, types):\n    if not isinstance(value, types):\n        raise TypeError(\n            \"expected instance of {}, got {}\".format(\n                types, value))", "response": "Ensures that value is an instance of a certain type."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef iter_ensure_instance(iterable, types):\n    ensure_instance(iterable, Iterable)\n    [ ensure_instance(item, types) for item in iterable ]", "response": "Iterate over object and check each item type"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef extend_instance(instance, *bases, **kwargs):\n    last = kwargs.get('last', False)\n    bases = tuple(bases)\n    for base in bases:\n        assert inspect.isclass(base), \"bases must be classes\"\n    assert not inspect.isclass(instance)\n    base_cls = instance.__class__\n    base_cls_name = instance.__class__.__name__\n    new_bases = (base_cls,)+bases if last else bases+(base_cls,)\n    new_cls = type(base_cls_name, tuple(new_bases), {})\n    setattr(instance, '__class__', new_cls)", "response": "Extend a class object with a list of bases."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd bases to class cls.", "response": "def add_bases(cls, *bases):\n    \"\"\"\n    Add bases to class\n\n    >>> class Base(object): pass\n    >>> class A(Base): pass\n    >>> class B(Base): pass\n    >>> issubclass(A, B)\n    False\n    >>> add_bases(A, B)\n    >>> issubclass(A, B)\n    True\n    \"\"\"\n    assert inspect.isclass(cls), \"Expected class object\"\n    for mixin in bases:\n        assert inspect.isclass(mixin), \"Expected class object for bases\"\n    new_bases = (bases + cls.__bases__)\n    cls.__bases__ = new_bases"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new class that is a subclass of cls with the given bases.", "response": "def subclass(cls, *bases, **kwargs):\n    \"\"\"\n    Add bases to class (late subclassing)\n\n    Annoyingly we cannot yet modify __bases__ of an existing\n    class, instead we must create another subclass, see here;\n    http://bugs.python.org/issue672115\n\n    >>> class A(object): pass\n    >>> class B(object): pass\n    >>> class C(object): pass\n    >>> issubclass(B, A)\n    False\n    >>> D = subclass(B, A)\n    >>> issubclass(D, A)\n    True\n    >>> issubclass(D, B)\n    True\n    \"\"\"\n    last = kwargs.get('last', False)\n    bases = tuple(bases)\n    for base in bases:\n        assert inspect.isclass(base), \"bases must be classes\"\n    new_bases = (cls,)+bases if last else bases+(cls,)\n    new_cls = type(cls.__name__, tuple(new_bases), {})\n    return new_cls"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nimports a package module or attribute from path", "response": "def import_from_path(path):\n    \"\"\"\n    Imports a package, module or attribute from path\n    Thanks http://stackoverflow.com/a/14050282/1267398\n\n    >>> import_from_path('os.path')\n    <module 'posixpath' ...\n    >>> import_from_path('os.path.basename')\n    <function basename at ...\n    >>> import_from_path('os')\n    <module 'os' from ...\n    >>> import_from_path('getrektcunt')\n    Traceback (most recent call last):\n    ImportError:\n    >>> import_from_path('os.dummyfunc')\n    Traceback (most recent call last):\n    ImportError:\n    >>> import_from_path('os.dummyfunc.dummylol')\n    Traceback (most recent call last):\n    ImportError:\n    \"\"\"\n    try:\n        return importlib.import_module(path)\n    except ImportError:\n        if '.' not in path:\n            raise\n        module_name, attr_name = path.rsplit('.', 1)\n        if not does_module_exist(module_name):\n            raise ImportError(\"No object found at '{}'\".format(path))\n        mod = importlib.import_module(module_name)\n\n        if not hasattr(mod, attr_name):\n            raise ImportError(\"No object found at '{}'\".format(path))\n        return getattr(mod, attr_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsorting dict by its keys", "response": "def sort_dict_by_key(obj):\n    \"\"\"\n    Sort dict by its keys\n\n    >>> sort_dict_by_key(dict(c=1, b=2, a=3, d=4))\n    OrderedDict([('a', 3), ('b', 2), ('c', 1), ('d', 4)])\n    \"\"\"\n    sort_func = lambda x: x[0]\n    return OrderedDict(sorted(obj.items(), key=sort_func))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating random secure token", "response": "def generate_random_token(length=32):\n    \"\"\"\n    Generate random secure token\n\n    >>> len(generate_random_token())\n    32\n    >>> len(generate_random_token(6))\n    6\n    \"\"\"\n    chars = (string.ascii_lowercase + string.ascii_uppercase + string.digits)\n    return ''.join(random.choice(chars) for _ in range(length))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns first argument which is truthy", "response": "def default(*args, **kwargs):\n    \"\"\"\n    Return first argument which is \"truthy\"\n\n    >>> default(None, None, 1)\n    1\n    >>> default(None, None, 123)\n    123\n    >>> print(default(None, None))\n    None\n    \"\"\"\n    default = kwargs.get('default', None)\n    for arg in args:\n        if arg:\n            return arg\n    return default"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\njoin given arguments into a url removing duplicate slashes", "response": "def urljoin(*args):\n    \"\"\"\n    Joins given arguments into a url, removing duplicate slashes\n    Thanks http://stackoverflow.com/a/11326230/1267398\n\n    >>> urljoin('/lol', '///lol', '/lol//')\n    '/lol/lol/lol'\n    \"\"\"\n    value = \"/\".join(map(lambda x: str(x).strip('/'), args))\n    return \"/{}\".format(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_int(value):\n    ensure_instance(value, (int, str, bytes, float, Decimal))\n    if isinstance(value, int):\n        return True\n    elif isinstance(value, float):\n        return False\n    elif isinstance(value, Decimal):\n        return str(value).isdigit()\n    elif isinstance(value, (str, bytes)):\n        return value.isdigit()\n    raise ValueError()", "response": "Check if value is an int\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef padded_split(value, sep, maxsplit=None, pad=None):\n    result = value.split(sep, maxsplit)\n    if maxsplit is not None:\n        result.extend(\n            [pad] * (1+maxsplit-len(result)))\n    return result", "response": "Returns a list of strings with padded separator."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef coerce_to_bytes(x, charset=sys.getdefaultencoding(), errors='strict'):\n    PY2 = sys.version_info[0] == 2\n    if PY2: # pragma: nocover\n        if x is None:\n            return None\n        if isinstance(x, (bytes, bytearray, buffer)):\n            return bytes(x)\n        if isinstance(x, unicode):\n            return x.encode(charset, errors)\n        raise TypeError('Cannot coerce to bytes')\n\n    else: # pragma: nocover\n        if x is None:\n            return None\n        if isinstance(x, (bytes, bytearray, memoryview)):\n            return bytes(x)\n        if isinstance(x, str):\n            return x.encode(charset, errors)\n        raise TypeError('Cannot coerce to bytes')", "response": "Coerce value to bytes"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef random_date_between(start_date, end_date):\n    assert isinstance(start_date, datetime.date)\n    delta_secs = int((end_date - start_date).total_seconds())\n    delta = datetime.timedelta(seconds=random.randint(0, delta_secs))\n    return (start_date + delta)", "response": "Return random date between start_date and end_date"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves any created temp paths", "response": "def cleanup(self):\n        \"\"\"Remove any created temp paths\"\"\"\n        for path in self.paths:\n            if isinstance(path, tuple):\n                os.close(path[0])\n                os.unlink(path[1])\n            else:\n                shutil.rmtree(path)\n        self.paths = []"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a multicolor that is a subset of the edge colors that are surrounded by the given vertex.", "response": "def get_vertex_surrounding_multicolor(graph, vertex):\n    \"\"\"\n    Loops over all edges that are incident to supplied vertex and accumulates all colors,\n     that are present in those edges\n    \"\"\"\n    result = Multicolor()\n    for edge in graph.get_edges_by_vertex(vertex):\n        result += edge.multicolor\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_irregular_edge_by_vertex(graph, vertex):\n    for edge in graph.get_edges_by_vertex(vertex):\n        if edge.is_irregular_edge:\n            return edge\n    return None", "response": "Returns the first irregular edge that is irregular for the given vertex."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive a connected component graph and a target multicolor return a list of irregular edge pairs that are included in the original graph.", "response": "def get_irregular_subnets(cc, target_multicolor, exclude, verbose=False, verbose_destination=None):\n    \"\"\"\n    For a supplied connected component (which is assumed to be a deepcopy from an original breakpoint graph)\n    we filter out all edges, that are of no interest for the scaffolding purposes with current target multicolor:\n        1. target multicolor must be fully present in the irregular edge\n        2. all colors from the target multicolor must be present exactly once in irregular edge multicolor\n        3. no colors from the \"exclude\" set must be present in the irregular edge multicolor\n        4. regular edge must \"support\" two irregular edges, that have survived the filtration specified above\n    \"\"\"\n    to_remove = []\n\n    if verbose:\n        print(\">Getting irregular subnets\", file=verbose_destination)\n        print(\"Graph contains\", len(list(cc.edges())), \"edges\", file=verbose_destination)\n        print(\"Removing uninteresting irregular edges\", file=verbose_destination)\n\n    ####################################################################################################\n    # we work with a supplied connected components,\n    #   assuming that its a deepcopy of the connected components in the original graph\n    # so we can do with it whatever we want, without affecting data in the original graph\n    ####################################################################################################\n    for bgedge, key in cc.edges(keys=True):\n        ####################################################################################################\n        # infinity edges must fully contain target multicolor\n        ####################################################################################################\n        if bgedge.is_irregular_edge and not target_multicolor <= bgedge.multicolor:\n            if verbose:\n                print(\"  removing\", bgedge.vertex1.name, \"--\", bgedge.vertex2.name,\n                      [color.name for color in bgedge.multicolor.multicolors.elements()], \": no target multicolor\",\n                      file=verbose_destination)\n            to_remove.append((bgedge, key))\n            continue\n        ####################################################################################################\n        # infinity edges must not contain colors from the excluded group\n        ####################################################################################################\n        if bgedge.is_irregular_edge and any(map(lambda color: color in bgedge.multicolor.colors, exclude)):\n            if verbose:\n                print(\"  removing\", bgedge.vertex1.name, \"--\", bgedge.vertex2.name,\n                      [color.name for color in bgedge.multicolor.multicolors.elements()],\n                      \": contains exclude multicolor\", file=verbose_destination)\n            to_remove.append((bgedge, key))\n            continue\n        ####################################################################################################\n        # in infinity edge multicolor all colors from targetted multicolor must have multiplicity one\n        ####################################################################################################\n        if bgedge.is_irregular_edge and any(map(lambda color: bgedge.multicolor.multicolors[color] > 1, target_multicolor.colors)):\n            if verbose:\n                print(\"  removing\", bgedge.vertex1.name, \"--\", bgedge.vertex2.name,\n                      [color.name for color in bgedge.multicolor.multicolors.elements()],\n                      \": multicplicity of some target multicolor os greater than 1\", file=verbose_destination)\n            to_remove.append((bgedge, key))\n            continue\n            ####################################################################################################\n\n    ##########################################################################################################\n    # once we've gathered all uninteresting / ambiguous (from target multicolor scaffolding stand point) irregular edges\n    #   we remove them\n    ##########################################################################################################\n    for bgedge, key in to_remove:\n        cc.delete_bgedge(bgedge, key)\n    if verbose:\n        print(\"Graph contains\", len(list(cc.edges())), \"edges\", file=verbose_destination)\n\n    to_remove = []\n    ################################################################################\n    # after we have left only those infinity edges are of interesting for the scaffolding purposses\n    # we filter regular edges to leave only those, that are supporting these infinity edges\n    ################################################################################\n    if verbose:\n        print(\"Removing uninteresting regular edges\", file=verbose_destination)\n    for bgedge, key in cc.edges(keys=True):\n        ################################################################################\n        # we only need edges that are either infinity edges, that were left during the presious step\n        # or support edges (have infinity edges at both vertices, that they are incident to)\n        ################################################################################\n        if not bgedge.is_irregular_edge and not supports_a_pair_of_irregular_edges(cc, bgedge):\n            if verbose:\n                print(\"  removing\", bgedge.vertex1.name, \"--\", bgedge.vertex2.name,\n                      [color.name for color in bgedge.multicolor.multicolors.elements()],\n                      \": does not support any irregular edge\", file=verbose_destination)\n            to_remove.append((bgedge, key))\n\n    ##########################################################################################################\n    # once we've gathered all regular edges, that do not support pairs of interesting (from scaffolding stand point)\n    #   irregular edges\n    ##########################################################################################################\n    for bgedge, key in to_remove:\n        cc.delete_bgedge(bgedge, key)\n    if verbose:\n        print(\"Graph contains\", len(list(cc.edges())), \"edges\", file=verbose_destination)\n\n    ##########################################################################################################\n    # once we've deleted all the uninteresting for scaffolding purposes infinity and regular edges,\n    #   our connected component\n    # is being torn apart into multiple connected components, each of which we can process independently\n    # and which contain only edges of interest for us\n    ##########################################################################################################\n    result = []\n    for cc in cc.connected_components_subgraphs(copy=False):\n        if len(list(cc.edges())) > 0:\n            result.append(cc)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nassemble a list of assemblies into a single tree structure.", "response": "def assemble_points(graph, assemblies, multicolor, verbose=False, verbose_destination=None):\n    \"\"\"\n    This function actually does assembling being provided\n        a graph, to play with\n        a list of assembly points\n        and a multicolor, which to assemble\n    \"\"\"\n    if verbose:\n        print(\">>Assembling for multicolor\", [e.name for e in multicolor.multicolors.elements()],\n              file=verbose_destination)\n    for assembly in assemblies:\n        v1, v2, (before, after, ex_data) = assembly\n        iv1 = get_irregular_vertex(get_irregular_edge_by_vertex(graph, vertex=v1))\n        iv2 = get_irregular_vertex(get_irregular_edge_by_vertex(graph, vertex=v2))\n        kbreak = KBreak(start_edges=[(v1, iv1), (v2, iv2)],\n                        result_edges=[(v1, v2), (iv1, iv2)],\n                        multicolor=multicolor)\n        if verbose:\n            print(\"(\", v1.name, \",\", iv1.name, \")x(\", v2.name, \",\", iv2.name, \")\", \" score=\", before - after, sep=\"\",\n                  file=verbose_destination)\n        graph.apply_kbreak(kbreak=kbreak, merge=True)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrap exceptions raised by requests. inelock.", "response": "def error_map(func):\n    \"\"\"Wrap exceptions raised by requests.\n\n    .. py:decorator:: error_map\n    \"\"\"\n    @six.wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except exceptions.RequestException as err:\n            raise TVDBRequestException(\n                err,\n                response=getattr(err, 'response', None),\n                request=getattr(err, 'request', None))\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_scans(urls_file):\n    cli_logger.debug('Starting to process batch input file')\n    created_scans = []\n\n    for line in urls_file:\n        line = line.strip()\n\n        if line.startswith('#'):\n            continue\n\n        if not line:\n            continue\n\n        try:\n            protocol, domain, port, path = parse_url(line)\n        except ValueError, ve:\n            cli_logger.debug(str(ve))\n            continue\n\n        for scan in created_scans:\n            if scan.matches(protocol, domain, port):\n                scan.add_path(path)\n                args = (path, scan.get_root_url())\n                cli_logger.debug('Added %s to %s' % args)\n                break\n        else:\n            scan = BatchScan(protocol, domain, port, path)\n            created_scans.append(scan)\n            cli_logger.debug('Added a new scan to %s' % scan.get_root_url())\n\n    cli_logger.debug('Created a total of %s scans' % len(created_scans))\n    return created_scans", "response": "This method creates a list of BatchScan objects based on the given urls_file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a URL into the parts I need for processing.", "response": "def parse_url(url):\n    \"\"\"\n    Parse a URL into the parts I need for processing:\n        * protocol\n        * domain\n        * port\n        * path\n\n    :param url: A string\n    :return: A tuple containing the above\n    \"\"\"\n    split_url = url.split('/', 3)\n    if len(split_url) == 3:\n        # http://foo.com\n        path = '/'\n    elif len(split_url) == 4:\n        path = '/' + split_url[3]\n    else:\n        raise ValueError('Invalid URL: %s' % url)\n\n    try:\n        parse_result = urlparse(url)\n    except Exception:\n        raise ValueError('Invalid URL: %s' % url)\n\n    protocol = parse_result.scheme\n    protocol = protocol.lower()\n    if protocol not in ('http', 'https'):\n        raise ValueError('Invalid URL protocol \"%s\"' % protocol)\n\n    split_netloc = parse_result.netloc.split(':')\n    domain = split_netloc[0]\n    domain = domain.lower()\n\n    if len(split_netloc) == 2:\n        try:\n            port = int(split_netloc[1])\n        except:\n            raise ValueError('Invalid port: \"%s\"' % split_netloc[1])\n    elif protocol == 'https':\n        port = 443\n    elif protocol == 'http':\n        port = 80\n    else:\n        raise ValueError('Invalid scheme: \"%s\"' % protocol)\n\n    return protocol, domain, port, path"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a standard message from a given user with the messageFormatted", "response": "def create_message(username, message):\r\n    \"\"\" Creates a standard message from a given user with the message \r\n        Replaces newline with html break \"\"\"\r\n    message = message.replace('\\n', '<br/>')\r\n    return '{{\"service\":1, \"data\":{{\"message\":\"{mes}\", \"username\":\"{user}\"}} }}'.format(mes=message, user=username)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addReader(self, reader):\n        self._add(reader, self._reads, QtCore.QSocketNotifier.Read)", "response": "Add a FileDescriptor for notification of data available to read."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef addWriter(self, writer):\n        self._add(writer, self._writes, QtCore.QSocketNotifier.Write)", "response": "Add a new writer to the list of available write files."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _remove(self, xer, primary):\n        if xer in primary:\n            notifier = primary.pop(xer)\n            notifier.shutdown()", "response": "Private method to remove a descriptor from the event loop."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove all selectables and return a list of them.", "response": "def removeAll(self):\n        \"\"\"\n        Remove all selectables, and return a list of them.\n        \"\"\"\n        rv = self._removeAll(self._reads, self._writes)\n        return rv"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _iterate(self, delay=None, fromqt=False):\n        self.runUntilCurrent()\n        self.doIteration(delay, fromqt)", "response": "This method is called by the thread that runs the iteration loop."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef doIteration(self, delay=None, fromqt=False):\n        'This method is called by a Qt timer or by network activity on a file descriptor'\n        \n        if not self.running and self._blockApp:\n            self._blockApp.quit()\n        self._timer.stop()\n        delay = max(delay, 1)\n        if not fromqt:\n            self.qApp.processEvents(QtCore.QEventLoop.AllEvents, delay * 1000)\n        if self.timeout() is None:\n            timeout = 0.1\n        elif self.timeout() == 0:\n            timeout = 0\n        else:\n            timeout = self.timeout()\n        self._timer.setInterval(timeout * 1000)\n        self._timer.start()", "response": "This method is called by a Qt timer or by network activity on a file descriptor"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef addEvent(self, event, fd, action):\n        self._events[event] = (fd, action)", "response": "Add a new event to the event loop."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_levenshtein(first, second):\n    if not first:\n        return len(second)\n\n    if not second:\n        return len(first)\n\n    prev_distances = range(0, len(second) + 1)\n    curr_distances = None\n\n    # Find the minimum edit distance between each substring of 'first' and\n    # the entirety of 'second'. The first column of each distance list is\n    # the distance from the current string to the empty string.\n    for first_idx, first_char in enumerate(first, start=1):\n        # Keep only the previous and current rows of the\n        # lookup table in memory\n        curr_distances = [first_idx]\n\n        for second_idx, second_char in enumerate(second, start=1):\n            # Take the max of the neighbors\n            compare = [\n                prev_distances[second_idx - 1],\n                prev_distances[second_idx],\n                curr_distances[second_idx - 1],\n            ]\n\n            distance = min(*compare)\n\n            if first_char != second_char:\n                distance += 1\n\n            curr_distances.append(distance)\n\n        prev_distances = curr_distances\n\n    return curr_distances[-1]", "response": "Returns the Levenshtein distance between two strings."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _validate_signal(self, sig):\n        if not isinstance(sig, int):\n            raise TypeError('sig must be an int, not {!r}'.format(sig))\n        if signal is None:\n            raise RuntimeError('Signals are not supported')\n        if not (1 <= sig < signal.NSIG):\n            raise ValueError('sig {} out of range(1, {})'.format(sig, signal.NSIG))\n        if sys.platform == 'win32':\n            raise RuntimeError('Signals are not really supported on Windows')", "response": "Internal helper to validate a signal."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef describe_version(self):\n        def _vers(client):\n            return client.describe_version()\n\n        d = self._connection()\n        d.addCallback(_vers)\n        return d", "response": "Query the Cassandra server for the version of the tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes a CQL query against the server and return a Deferred that fires with None an int or an iterable of rows or None", "response": "def execute(self, query, args, consistency):\n        \"\"\"\n        Execute a CQL query against the server.\n\n        :param query: The CQL query to execute\n        :type query: str.\n\n        :param args: The arguments to substitute\n        :type args: dict.\n\n        :param consistency: The consistency level\n        :type consistency: ConsistencyLevel\n\n        In order to avoid unpleasant issues of CQL injection\n        (Hey, just because there's no SQL doesn't mean that Little\n        Bobby Tables won't mess things up for you like in XKCD #327)\n        you probably want to use argument substitution instead of\n        concatting strings together to build a query.\n\n        Thus, like the official CQL driver for non-Twisted python\n        that comes with the Cassandra distro, we do variable substitution.\n\n        Example::\n\n            d = client.execute(\"UPDATE :table SET 'fff' = :val WHERE \"\n            \"KEY = :key\",{\"val\":1234, \"key\": \"fff\", \"table\": \"blah\"})\n\n        :returns: A Deferred that fires with either None, an int, or an\n                  iterable of `{'column': value, ...}` dictionaries, depending\n                  on the CQL query.  e.g. a UPDATE would return None,\n                  whereas a SELECT would return an int or some rows\n\n        Example output::\n\n            [{\"fff\": 1222}]\n        \"\"\"\n        prep_query = prepare(query, args)\n\n        def _execute(client):\n            exec_d = client.execute_cql3_query(prep_query,\n                                               ttypes.Compression.NONE, consistency)\n            if self._disconnect_on_cancel:\n                cancellable_d = Deferred(lambda d: self.disconnect())\n                exec_d.chainDeferred(cancellable_d)\n                return cancellable_d\n            else:\n                return exec_d\n\n        def _proc_results(result):\n            if result.type == ttypes.CqlResultType.ROWS:\n                return self._unmarshal_result(result.schema, result.rows,\n                                              unmarshallers)\n            elif result.type == ttypes.CqlResultType.INT:\n                return result.num\n            else:\n                return None\n\n        d = self._connection()\n        d.addCallback(_execute)\n        d.addCallback(_proc_results)\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting rule files in a directory", "response": "def getfiles(qfiles, dirname, names):\n    \"\"\"Get rule files in a directory\"\"\"\n    for name in names:\n        fullname = os.path.join(dirname, name)\n        if os.path.isfile(fullname) and \\\n            fullname.endswith('.cf') or \\\n                fullname.endswith('.post'):\n            qfiles.put(fullname)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef deploy_file(source, dest):\n    date = datetime.utcnow().strftime('%Y-%m-%d')\n    shandle = open(source)\n    with open(dest, 'w') as handle:\n        for line in shandle:\n            if line == '# Updated: %date%\\n':\n                newline = '# Updated: %s\\n' % date\n            else:\n                newline = line\n            handle.write(newline)\n            handle.flush()\n    shandle.close()", "response": "Deploy a file from source to dest"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npackage files in the target directory", "response": "def package(dest, tardir, p_version):\n    \"\"\"Package files\"\"\"\n    os.chdir(dest)\n    p_filename = '%s.tar.gz' % p_version\n    p_path = os.path.join(tardir, p_filename)\n    tar = tarfile.open(p_path, mode='w:gz')\n    for cf_file in os.listdir('.'):\n        if os.path.isfile(cf_file):\n            tar.add(cf_file)\n    tar.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprocesses rules and return True if the archive is newer than the archive", "response": "def process(dest, rulefiles):\n    \"\"\"process rules\"\"\"\n    deploy = False\n    while not rulefiles.empty():\n        rulefile = rulefiles.get()\n        base = os.path.basename(rulefile)\n        dest = os.path.join(dest, base)\n        if os.path.exists(dest):\n            # check if older\n            oldtime = os.stat(rulefile).st_mtime\n            newtime = os.stat(dest).st_mtime\n            if oldtime > newtime:\n                deploy = True\n                deploy_file(rulefile, dest)\n        else:\n            deploy = True\n            deploy_file(rulefile, dest)\n    return deploy"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the counter value", "response": "def get_counter(counterfile):\n    \"\"\"Get the counter value\"\"\"\n    try:\n        version_num = open(counterfile).read()\n        version_num = int(version_num) + 1\n    except (ValueError, IOError):\n        version_num = 1\n        create_file(counterfile, \"%d\" % version_num)\n    except BaseException as msg:\n        raise SaChannelUpdateError(msg)\n    return version_num"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_dns(config, record, sa_version):\n    \"Update the DNS record\"\n    try:\n        domain = config.get('domain_name', 'sa.baruwa.com.')\n        dns_key = config.get('domain_key')\n        dns_ip = config.get('domain_ip', '127.0.0.1')\n        keyring = tsigkeyring.from_text({domain: dns_key})\n        transaction = update.Update(\n            domain,\n            keyring=keyring,\n            keyalgorithm=tsig.HMAC_SHA512)\n        txtrecord = '%s.%s' % (sa_version, domain)\n        transaction.replace(txtrecord, 120, 'txt', record)\n        query.tcp(transaction, dns_ip)\n        return True\n    except DNSException, msg:\n        raise SaChannelUpdateDNSError(msg)", "response": "Update the DNS record"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nuploads the files to the remote server", "response": "def upload(config, remote_loc, u_filename):\n    \"\"\"Upload the files\"\"\"\n    rcode = False\n    try:\n        sftp, transport = get_sftp_conn(config)\n        remote_dir = get_remote_path(remote_loc)\n        for part in ['sha1', 'asc']:\n            local_file = '%s.%s' % (u_filename, part)\n            remote_file = os.path.join(remote_dir, local_file)\n            sftp.put(local_file, remote_file)\n        sftp.put(remote_dir, os.path.join(remote_dir, u_filename))\n        rcode = True\n    except BaseException:\n        pass\n    finally:\n        if 'transport' in locals():\n            transport.close()\n    return rcode"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd files in a directory to a queue", "response": "def queue_files(dirpath, queue):\n    \"\"\"Add files in a directory to a queue\"\"\"\n    for root, _, files in os.walk(os.path.abspath(dirpath)):\n        if not files:\n            continue\n        for filename in files:\n            queue.put(os.path.join(root, filename))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_cf_files(path, queue):\n    for root, _, files in os.walk(os.path.abspath(path)):\n        if not files:\n            continue\n        for filename in files:\n            fullname = os.path.join(root, filename)\n            if os.path.isfile(fullname) and fullname.endswith('.cf') or \\\n                    fullname.endswith('.post'):\n                queue.put(fullname)", "response": "Get rule files in a directory and put them in a queue"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving existing rules from the archive", "response": "def cleanup(dest, tardir, counterfile):\n    \"\"\"Remove existing rules\"\"\"\n    thefiles = Queue()\n    # dest directory files\n    queue_files(dest, thefiles)\n    # tar directory files\n    queue_files(tardir, thefiles)\n    while not thefiles.empty():\n        d_file = thefiles.get()\n        info(\"Deleting file: %s\" % d_file)\n        os.unlink(d_file)\n    if os.path.exists(counterfile):\n        info(\"Deleting the counter file %s\" % counterfile)\n        os.unlink(counterfile)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef entry(config, delete_files=None):\n    home_dir = config.get('home_dir', '/var/lib/sachannelupdate')\n    dns_ver = config.get('spamassassin_version', '1.4.3')\n    remote_loc = config.get('remote_location')\n    rule_dir = os.path.join(home_dir, 'rules')\n    dest = os.path.join(home_dir, 'deploy')\n    tardir = os.path.join(home_dir, 'archives')\n    counterfile = os.path.join(home_dir, 'db', 'counters')\n\n    check_required(config)\n\n    if delete_files:\n        cleanup(dest, tardir, counterfile)\n        return\n\n    cffiles = Queue()\n    get_cf_files(rule_dir, cffiles)\n\n    if process(dest, cffiles):\n        version = get_counter(counterfile)\n        filename = '%s.tar.gz' % version\n        path = os.path.join(tardir, filename)\n        package(dest, tardir, version)\n        sign(config, path)\n        hash_file(path)\n        if upload(config, remote_loc, path):\n            if update_dns(config, str(version), dns_ver):\n                create_file(counterfile, \"%d\" % version)", "response": "Main function for the sachannel update process"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing clamscan output into same dictionary structured used by .", "response": "def _parse_result(result):\n    \"\"\"\n    Parse ``clamscan`` output into same dictionary structured used by\n    ``pyclamd``.\n\n    Input example::\n        /home/bystrousak/Plocha/prace/test/eicar.com: Eicar-Test-Signature FOUND\n\n    Output dict::\n        {\n            \"/home/bystrousak/Plocha/prace/test/eicar.com\": (\n                \"FOUND\",\n                \"Eicar-Test-Signature\"\n            )\n        }\n    \"\"\"\n    lines = filter(lambda x: x.strip(), result.splitlines())  # rm blank lines\n\n    if not lines:\n        return {}\n\n    out = {}\n    for line in lines:\n        line = line.split(\":\")\n        fn = line[0].strip()\n\n        line = \" \".join(line[1:])\n\n        line = line.rsplit(None, 1)\n        status = line.pop().strip()\n\n        out[fn] = (status, \" \".join(line).strip())\n\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef scan_file(path):\n    path = os.path.abspath(path)\n    assert os.path.exists(path), \"Unreachable file '%s'.\" % path\n\n    result = sh.clamscan(path, no_summary=True, infected=True, _ok_code=[0, 1])\n\n    return _parse_result(result)", "response": "Scan path for viruses using clamscan program."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect(self):\n        connection_method = 'SMTP_SSL' if self.ssl else 'SMTP'\n        self._logger.debug('Trying to connect via {}'.format(connection_method))\n        smtp = getattr(smtplib, connection_method)\n        if self.port:\n            self._smtp = smtp(self.address, self.port)\n        else:\n            self._smtp = smtp(self.address)\n        self._smtp.ehlo()\n        if self.tls:\n            self._smtp.starttls()\n            self._smtp.ehlo()\n        self._logger.info('Got smtp connection')\n        if self.username and self.password:\n            self._logger.info('Logging in')\n            self._smtp.login(self.username, self.password)\n        self._connected = True", "response": "Initializes a connection to the SMTP server and returns True if successful False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send(self,\n             sender,\n             recipients,\n             cc=None,\n             bcc=None,\n             subject='',\n             body='',\n             attachments=None,\n             content='text'):\n        \"\"\"Sends the email\n\n        :param sender: The server of the message\n        :param recipients: The recipients (To:) of the message\n        :param cc: The CC recipients of the message\n        :param bcc: The BCC recipients of the message\n        :param subject: The subject of the message\n        :param body: The body of the message\n        :param attachments: The attachments of the message\n        :param content: The type of content the message [text/html]\n\n        :return: True on success, False otherwise\n        \"\"\"\n        if not self.connected:\n            self._logger.error(('Server not connected, cannot send message, '\n                                'please connect() first and disconnect() when '\n                                'the connection is not needed any more'))\n            return False\n        try:\n            message = Message(sender,\n                              recipients,\n                              cc,\n                              bcc,\n                              subject,\n                              body,\n                              attachments,\n                              content)\n            self._smtp.sendmail(message.sender,\n                                message.recipients,\n                                message.as_string)\n            result = True\n            self._connected = False\n            self._logger.debug('Done')\n        except Exception:  # noqa\n            self._logger.exception('Something went wrong!')\n            result = False\n        return result", "response": "Sends the email to the server"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef disconnect(self):\n        if self.connected:\n            try:\n                self._smtp.close()\n                self._connected = False\n                result = True\n            except Exception:  # noqa\n                self._logger.exception('Something went wrong!')\n                result = False\n            return result", "response": "Disconnects from the remote smtp server"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend the email by connecting and disconnecting after the send method.", "response": "def send(self,\n             sender,\n             recipients,\n             cc=None,\n             bcc=None,\n             subject='',\n             body='',\n             attachments=None,\n             content='text'):\n        \"\"\"Sends the email by connecting and disconnecting after the send\n\n        :param sender: The sender of the message\n        :param recipients: The recipients (To:) of the message\n        :param cc: The CC recipients of the message\n        :param bcc: The BCC recipients of the message\n        :param subject: The subject of the message\n        :param body: The body of the message\n        :param attachments: The attachments of the message\n        :param content: The type of content the message [text/html]\n\n        :return: True on success, False otherwise\n        \"\"\"\n        self._server.connect()\n        self._server.send(sender,\n                          recipients,\n                          cc,\n                          bcc,\n                          subject,\n                          body,\n                          attachments,\n                          content)\n        self._server.disconnect()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _setup_message(self):\n        if self.content == 'html':\n            self._message = MIMEMultipart('alternative')\n            part = MIMEText(self.body, 'html', 'UTF-8')\n        else:\n            self._message = MIMEMultipart()\n            part = MIMEText(self.body, 'plain', 'UTF-8')\n        self._message.preamble = 'Multipart massage.\\n'\n        self._message.attach(part)\n        self._message['From'] = self.sender\n        self._message['To'] = COMMASPACE.join(self.to)\n        if self.cc:\n            self._message['Cc'] = COMMASPACE.join(self.cc)\n        self._message['Date'] = formatdate(localtime=True)\n        self._message['Subject'] = self.subject\n        for part in self._parts:\n            self._message.attach(part)", "response": "Constructs the underlying message with the provided values"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndoing a simple validation of an email by matching it to a regexps", "response": "def _validate_simple(email):\n        \"\"\"Does a simple validation of an email by matching it to a regexps\n\n        :param email: The email to check\n        :return: The valid Email address\n\n        :raises: ValueError if value is not a valid email\n        \"\"\"\n        name, address = parseaddr(email)\n        if not re.match('[^@]+@[^@]+\\.[^@]+', address):\n            raise ValueError('Invalid email :{email}'.format(email=email))\n        return address"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfills the about label txt with the module attributes of the module", "response": "def setModule(self, mod):\r\n        \"\"\"\r\n        fill the about about label txt with the module attributes of the module\r\n        \"\"\"\r\n        txt = \"\"\"<b>%s</b> - %s<br><br>\r\nAuthor:        %s<br>\r\nEmail:        %s<br>\r\nVersion:        %s<br>\r\nLicense:        %s<br>\r\nUrl:            <a href=\"%s\">%s</a>\"\"\" % (\r\n            mod.__name__,\r\n            mod.__doc__,\r\n            mod.__author__,\r\n            mod.__email__,\r\n            mod.__version__,\r\n            mod.__license__,\r\n            mod.__url__, mod.__url__)\r\n        self.label_txt.setText(txt)\r\n        self.label_txt.setOpenExternalLinks(True)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding the logo to the Institution logo widget.", "response": "def setInstitutionLogo(self, pathList: tuple):\r\n        \"\"\"\r\n        takes one or more [logo].svg paths\r\n            if logo should be clickable, set\r\n                pathList = (\r\n                (my_path1.svg,www.something1.html),\r\n                (my_path2.svg,www.something2.html),\r\n                ...)\r\n        \"\"\"\r\n        for p in pathList:\r\n            url = None\r\n            if type(p) in (list, tuple):\r\n                p, url = p\r\n            logo = QtSvg.QSvgWidget(p)\r\n            s = logo.sizeHint()\r\n            aR = s.height() / s.width()\r\n            h = 150\r\n            w = h / aR\r\n            logo.setFixedSize(int(w), int(h))\r\n            self.layout().addWidget(logo)\r\n            if url:\r\n                logo.mousePressEvent = lambda evt, u=url: self._openUrl(evt, u)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving cahce to disk.", "response": "def save_cache(cache):\n    \"\"\"\n    Save cahce to the disk.\n\n    Args:\n        cache (set): Set with cached data.\n    \"\"\"\n    with open(settings.DUP_FILTER_FILE, \"w\") as f:\n        f.write(\n            json.dumps(list(cache))\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading cache from disk.", "response": "def load_cache():\n    \"\"\"\n    Load cache from the disk.\n\n    Return:\n        set: Deserialized data from disk.\n    \"\"\"\n    if not os.path.exists(settings.DUP_FILTER_FILE):\n        return set()\n\n    with open(settings.DUP_FILTER_FILE) as f:\n        return set(\n            json.loads(f.read())\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef filter_publication(publication, cache=_CACHE):\n    if cache is None:\n        cache = load_cache()\n\n    if publication._get_hash() in cache:\n        return None\n\n    cache.update(\n        [publication._get_hash()]\n    )\n    save_cache(cache)\n    return publication", "response": "Returns the publication if it is found in cache else None."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle_stop_command(srv, pid):\n    service = 'pinky_{}'.format(srv)\n    twisted_pid = filepath.FilePath(pid)\n    if not twisted_pid.exists():\n        print('error: {}.pid file can\\'t be found.'.format(service))\n        sys.exit(-1)\n\n    pid = twisted_pid.open().read()\n    print('killing {} process id {} with SIGINT signal'.format(\n        service, pid).ljust(73), end='')\n    try:\n        filepath.os.kill(int(pid), signal.SIGINT)\n        print('[{}]'.format(darkgreen('Ok')))\n    except:\n        print('[{}]'.format(darkred('Fail')))\n        raise", "response": "Kill the running service\n           "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying the widget defined by the richtext_widget_path to the kwargs.", "response": "def formfield(self, **kwargs):\n        \"\"\"\n        Apply the widget class defined by the\n        ``RICHTEXT_WIDGET_CLASS`` setting.\n        \"\"\"\n        default = kwargs.get(\"widget\", None) or AdminTextareaWidget\n        if default is AdminTextareaWidget:\n            from yacms.conf import settings\n            richtext_widget_path = settings.RICHTEXT_WIDGET_CLASS\n            try:\n                widget_class = import_dotted_path(richtext_widget_path)\n            except ImportError:\n                raise ImproperlyConfigured(_(\"Could not import the value of \"\n                                             \"settings.RICHTEXT_WIDGET_CLASS: \"\n                                             \"%s\" % richtext_widget_path))\n            kwargs[\"widget\"] = widget_class()\n        kwargs.setdefault(\"required\", False)\n        formfield = super(RichTextField, self).formfield(**kwargs)\n        return formfield"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nqueries a web URL and return a Response object with the following attributes", "response": "def get(url):\n    \"\"\"Query a web URL.\n\n    Return a Response object with the following attributes:\n    - text: the full text of the web page\n    - soup: a BeautifulSoup object representing the web page\n\n    \"\"\"\n    text = urlopen(url).read()\n    soup = BeautifulSoup(text)\n    return Response(text=text, soup=soup)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def anext(self):\n        try:\n            f = next(self._iter)\n        except StopIteration as exc:\n            raise StopAsyncIteration() from exc\n        return await f", "response": "Fetch the next value from the iterable."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nappends a new token to the token stream.", "response": "def _new_token(self, chars=None, line_no=None):\n        \"\"\" Appends new token to token stream.\n\n            `chars`\n                List of token characters. Defaults to current token list.\n            `line_no`\n                Line number for token. Defaults to current line number.\n            \"\"\"\n\n        if not line_no:\n            line_no = self._line_no\n\n        if not chars:\n            chars = self._token_chars\n\n        if chars:\n            # add new token\n            self._tokens.append((line_no, ''.join(chars)))\n            self._token_chars = []"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprocessing a newline character.", "response": "def _process_newline(self, char):\n        \"\"\" Process a newline character.\n            \"\"\"\n\n        state = self._state\n\n        # inside string, just append char to token\n        if state == self.ST_STRING:\n            self._token_chars.append(char)\n        else:\n            # otherwise, add new token\n            self._new_token()\n\n        self._line_no += 1  # update line counter\n\n        # finished with comment\n        if state == self.ST_COMMENT:\n            self._state = self.ST_TOKEN"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _process_string(self, char):\n\n        if char in self.QUOTES:\n            # end of quoted string:\n            #   1) quote must match original quote\n            #   2) not escaped quote (e.g. \"hey there\" vs \"hey there\\\")\n            #   3) actual escape char prior (e.g. \"hey there\\\\\")\n\n            if (char == self._last_quote and\n                    not self._escaped or self._double_escaped):\n\n                # store token\n                self._new_token()\n                self._state = self.ST_TOKEN\n                return  # skip adding token char\n\n        elif char == self.ESCAPE:\n            # escape character:\n            #   double escaped if prior char was escape (e.g. \"hey \\\\ there\")\n\n            if not self._double_escaped:\n                self._double_escaped = self._escaped\n\n        else:\n            self._double_escaped = False\n\n        self._token_chars.append(char)", "response": "Process a character as part of a string token."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprocess a token character.", "response": "def _process_tokens(self, char):\n        \"\"\" Process a token character.\n            \"\"\"\n\n        if (char in self.WHITESPACE or char == self.COMMENT_START or\n                char in self.QUOTES or char in self.TOKENS):\n\n            add_token = True\n\n            # escaped chars, keep going\n            if char == self.SPACE or char in self.TOKENS:\n                if self._escaped:\n                    add_token = False\n\n            # start of comment\n            elif char == self.COMMENT_START:\n                self._state = self.ST_COMMENT\n\n            # start of quoted string\n            elif char in self.QUOTES:\n                if self._escaped:\n                    # escaped, keep going\n                    add_token = False\n\n                else:\n                    self._state = self.ST_STRING\n                    self._last_quote = char  # store for later quote matching\n\n            if add_token:\n                # store token\n                self._new_token()\n\n                if char in self.TOKENS:\n                    # store char as a new token\n                    self._new_token([char])\n\n                return  # skip adding token char\n\n        self._token_chars.append(char)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read(self, filename):\n\n        try:\n            with open(filename, 'r') as _file:\n                self._filename = filename\n                self.readstream(_file)\n            return True\n\n        except IOError:\n            self._filename = None\n            return False", "response": "Reads the file specified and tokenizes the data for parsing."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _escaped(self):\n\n        chars = self._token_info['chars']\n        count = len(chars)\n\n        # prev char is escape, keep going\n        if count and chars[count - 1] == self.ESCAPE:\n            chars.pop()  # swallow escape char\n            return True\n        else:\n            return False", "response": "Return True if the current character is at the end of accumulated token\n            character list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn if a request has an okay error code otherwise raises InvalidRequest.", "response": "def checkResponse(request):\n        '''\n        Returns if a request has an okay error code, otherwise raises InvalidRequest.\n        '''\n\n        # Check the status code of the returned request\n        if str(request.status_code)[0] not in ['2', '3']:\n            w = str(request.text).split('\\\\r')[0][2:]\n            raise InvalidRequest(w)\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef checkKey(self, key=None):\n        '''\n        Checks that an API key is valid.\n\n        :param str key: (optional) A key that you want to check the validity of. Defaults to the one provided on initialization.\n        :returns: If the key is valid, this method will return ``True``.\n        :rtype: `bool`\n        :raises: :class:`brickfront.errors.InvalidApiKey`\n        '''\n\n        # Get site\n        url = Client.ENDPOINT.format('checkKey')\n        if not key: key = self.apiKey\n        params = {\n            'apiKey': key or self.apiKey\n        }\n        returned = get(url, params=params)\n        self.checkResponse(returned)\n\n        # Parse and return\n        root = ET.fromstring(returned.text)\n        if root.text == 'OK':\n            return True\n        raise InvalidApiKey('The provided API key `{}` was invalid.'.format(key))", "response": "Checks that an API key is valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlogs into Brickset as a user returning a userhash which can be used in other methods.", "response": "def login(self, username, password):\n        '''\n        Logs into Brickset as a user, returning a userhash, which can be used in other methods.\n        The user hash is stored inside the client (:attr:`userHash`).\n\n        :param str username: Your Brickset username.\n        :param str password: Your Brickset password.\n        :returns: If the login is valid, this will return ``True``.\n        :rtype: `bool`\n        :raises: :class:`brickfront.errors.InvalidLoginCredentials`\n        '''\n\n        # Get the site\n        url = Client.ENDPOINT.format('login')\n        params = {\n            'apiKey': self.apiKey,\n            'username': username,\n            'password': password,\n        }\n        returned = get(url, params=params)\n        self.checkResponse(returned)\n        root = ET.fromstring(returned.text)\n\n        # Determine whether they logged in correctly\n        if root.text.startswith('ERROR'):\n            self.userHash = ''\n            raise InvalidLoginCredentials('The provided username and password were unable to authenticate.')\n        self.userHash = root.text\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getSets(self, **kwargs):\n        '''\n        A way to get different sets from a query.\n        All parameters are optional, but you should probably use some (so that you get results)\n\n        :param str query: The thing you're searching for.\n        :param str theme: The theme of the set.\n        :param str subtheme: The subtheme of the set.\n        :param str setNumber: The LEGO set number.\n        :param str year: The year in which the set came out.\n        :param int owned: Whether or not you own the set. Only works when logged in with :meth:`login`. Set to `1` to make true.\n        :param int wanted: Whether or not you want the set. Only works when logged in with :meth:`login`. Set to `1` to make true.\n        :param str orderBy: How you want the set ordered. Accepts 'Number', 'YearFrom', 'Pieces', 'Minifigs', 'Rating', 'UKRetailPrice', 'USRetailPrice', 'CARetailPrice', 'EURetailPrice', 'Theme', 'Subtheme', 'Name', 'Random'. Add 'DESC' to the end to sort descending, e.g. NameDESC. Case insensitive. Defaults to 'Number'.\n        :param int pageSize: How many results are on a page. Defaults to 20.\n        :param int pageNumber: The number of the page you're looking at. Defaults to 1.\n        :param str userName: The name of a user whose sets you want to search.\n        :returns: A list of :class:`brickfront.build.Build` objects.\n        :rtype: list\n        '''\n\n        # Generate a dictionary to send as parameters\n        params = {\n            'apiKey':     self.apiKey,\n            'userHash':   self.userHash,\n            'query':      kwargs.get('query', ''),\n            'theme':      kwargs.get('theme', ''),\n            'subtheme':   kwargs.get('subtheme', ''),\n            'setNumber':  kwargs.get('setNumber', ''),\n            'year':       kwargs.get('year', ''),\n            'owned':      kwargs.get('owned', ''),\n            'wanted':     kwargs.get('wanted', ''),\n            'orderBy':    kwargs.get('orderBy', 'Number'),\n            'pageSize':   kwargs.get('pageSize', '20'),\n            'pageNumber': kwargs.get('pageNumber', '1'),\n            'userName':   kwargs.get('userName', '')\n        }\n        url = Client.ENDPOINT.format('getSets')\n        returned = get(url, params=params)\n        self.checkResponse(returned)\n\n        # Construct the build objects and return them graciously\n        root = ET.fromstring(returned.text)\n        return [Build(i, self) for i in root]", "response": "This method returns a list of build objects that are available for the LEGO set."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the information of one specific build using its Brickset set ID.", "response": "def getSet(self, setID):\n        '''\n        Gets the information of one specific build using its Brickset set ID.\n\n        :param str setID: The ID of the build from Brickset.\n        :returns: A single Build object.\n        :rtype: :class:`brickfront.build.Build`\n        :raises brickfront.errors.InvalidSetID: If no sets exist by that ID.\n        '''\n\n        params = {\n            'apiKey': self.apiKey,\n            'userHash': self.userHash,\n            'setID': setID\n        }\n        url = Client.ENDPOINT.format('getSet')\n        returned = get(url, params=params)\n        self.checkResponse(returned)\n\n        # Put it into a Build class\n        root = ET.fromstring(returned.text)\n        v = [Build(i, self) for i in root]\n\n        # Return to user\n        try:\n            return v[0]\n        except IndexError:\n            raise InvalidSetID('There is no set with the ID of `{}`.'.format(setID))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getRecentlyUpdatedSets(self, minutesAgo):\n        '''\n        Gets the information of recently updated sets.\n\n        :param int minutesAgo: The amount of time ago that the set was updated.\n        :returns: A list of Build instances that were updated within the given time.\n        :rtype: list\n        .. warning:: An empty list will be returned if there are no sets in the given time limit.\n        '''\n\n        params = {\n            'apiKey': self.apiKey,\n            'minutesAgo': minutesAgo\n        }\n        url = Client.ENDPOINT.format('getRecentlyUpdatedSets')\n        returned = get(url, params=params)\n        self.checkResponse(returned)\n\n        # Parse them in to build objects\n        root = ET.fromstring(returned.text)\n        return [Build(i, self) for i in root]", "response": "Gets the information of recently updated sets."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a list of URLs containing images of the set.", "response": "def getAdditionalImages(self, setID):\n        '''\n        Gets a list of URLs containing images of the set.\n\n        :param str setID: The ID of the set you want to grab the images for.\n        :returns: A list of URL strings.\n        :rtype: list\n        .. warning:: An empty list will be returned if there are no additional images, or if the set ID is invalid.\n        '''\n\n        params = {\n            'apiKey': self.apiKey,\n            'setID': setID\n        }\n        url = Client.ENDPOINT.format('getAdditionalImages')\n        returned = get(url, params=params)\n        self.checkResponse(returned)\n\n        # I really fuckin hate XML\n        root = ET.fromstring(returned.text)\n        urlList = []\n\n        for imageHolder in root:\n            urlList.append(imageHolder[-1].text)\n        return urlList"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getReviews(self, setID):\n        '''\n        Get the reviews for a set.\n\n        :param str setID: The ID of the set you want to get the reviews of.\n        :returns: A list of reviews.\n        :rtype: List[:class:`brickfront.review.Review`]\n        .. warning:: An empty list will be returned if there are no reviews, or if the set ID is invalid.\n        '''\n\n        params = {\n            'apiKey': self.apiKey,\n            'setID': setID\n        }\n        url = Client.ENDPOINT.format('getReviews')\n        returned = get(url, params=params)\n        self.checkResponse(returned)\n\n        # Parse into review objects\n        root = ET.fromstring(returned.text)\n        return [Review(i) for i in root]", "response": "Get the reviews for a set."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef results(cls, function, group=None):\n        return numpy.array(cls._results[group][function])", "response": "Returns a numpy nparray representing the benchmark results of a function in a group."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes statistics from _results and return a dictionary of numpy array.", "response": "def statistics(cls, function, group=None):\n        \"\"\"\n        Compute statistics (average, max, median, minimun and sum) from _results\n        into a dictionary of numpy array.\n        \"\"\"\n        benchmark = cls.results(function, group)\n        results = {}\n        for name, stat in {'avg': numpy.average, 'max': numpy.amax, 'med': numpy.median, 'min': numpy.amin, 'sum': numpy.sum}.items():\n            results[name] = stat(benchmark, axis=0)\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmix cls content in target.", "response": "def mixin_class(target, cls):\n        \"\"\"Mix cls content in target.\"\"\"\n\n        for name, field in getmembers(cls):\n            Mixin.mixin(target, field, name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mixin(target, resource, name=None):\n\n        result = None\n\n        if ismethod(resource) or isfunction(resource):\n            result = Mixin.mixin_function_or_method(target, resource, name)\n\n        elif isclass(resource):\n            result = list()\n\n            for name, content in getmembers(resource):\n                if isclass(content):\n                    mixin = Mixin.set_mixin(target, content, name)\n\n                else:\n                    mixin = Mixin.mixin(target, content, name)\n\n                result.append(mixin)\n\n        else:\n            result = Mixin.set_mixin(target, resource, name)\n\n        return result", "response": "Do the correct mixin depending on the type of input resource and return the result of the choosen method."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a set of couple names and fields of target mixedin.", "response": "def get_mixedins_by_name(target):\n        \"\"\"Get a set of couple (name, field) of target mixedin.\"\"\"\n\n        result = getattr(target, Mixin.__MIXEDIN_KEY__, None)\n\n        if result is None:\n            result = dict()\n            setattr(target, Mixin.__MIXEDIN_KEY__, result)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_mixin(target, resource, name=None, override=True):\n\n        if name is None and not hasattr(resource, '__name__'):\n            raise Mixin.MixInError(\n                \"name must be given or resource {0} can't be anonymous\"\n                .format(resource))\n\n        result = None\n\n        name = resource.__name__ if name is None else name\n\n        mixedins_by_name = Mixin.get_mixedins_by_name(target)\n\n        result = getattr(target, name, Mixin.__NEW_CONTENT_KEY__)\n\n        if override or result == Mixin.__NEW_CONTENT_KEY__:\n\n            if name not in mixedins_by_name:\n                mixedins_by_name[name] = (result,)\n            else:\n                mixedins_by_name[name] += (result,)\n\n            try:\n                setattr(target, name, resource)\n\n            except (AttributeError, TypeError):\n\n                if len(mixedins_by_name[name]) == 1:\n                    del mixedins_by_name[name]\n                    if len(mixedins_by_name) == 0:\n                        delattr(target, Mixin.__MIXEDIN_KEY__)\n\n                else:\n                    mixedins_by_name[name] = mixedins_by_name[name][:-2]\n\n                result = None\n        else:\n            result = None\n\n        return result", "response": "Set a resource and returns the mixed one in target content item or None if the target content item doesn t exist in the resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_mixin(target, name, mixedin=None, replace=True):\n\n        try:\n            result = getattr(target, name)\n\n        except AttributeError:\n            raise Mixin.MixInError(\n                \"No mixin {0} exists in {1}\".format(name, target)\n            )\n\n        mixedins_by_name = Mixin.get_mixedins_by_name(target)\n\n        mixedins = mixedins_by_name.get(name)\n\n        if mixedins:\n\n            if mixedin is None:\n                mixedin = mixedins[-1]\n                mixedins = mixedins[:-2]\n\n            else:\n\n                try:\n                    index = mixedins.index(mixedin)\n\n                except ValueError:\n                    raise Mixin.MixInError(\n                        \"Mixedin {0} with name {1} does not exist \\\n                        in target {2}\"\n                        .format(mixedin, name, target)\n                    )\n\n                mixedins = mixedins[0:index] + mixedins[index + 1:]\n\n            if len(mixedins) == 0:\n                # force to replace/delete the mixin even if replace is False\n                # in order to stay in a consistent state\n                if mixedin != Mixin.__NEW_CONTENT_KEY__:\n                    setattr(target, name, mixedin)\n\n                else:\n                    delattr(target, name)\n\n                del mixedins_by_name[name]\n\n            else:\n                if replace:\n                    setattr(target, name, mixedin)\n\n                mixedins_by_name[name] = mixedins\n\n        else:\n            # shouldn't be raised except if removing has been done\n            # manually\n            raise Mixin.MixInError(\n                \"No mixin {0} exists in {1}\".format(name, target))\n\n        # clean mixedins if no one exists\n        if len(mixedins_by_name) == 0:\n            delattr(target, Mixin.__MIXEDIN_KEY__)\n\n        return result", "response": "Removes a mixin with name and reference from target and returns the replaced one or None."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntries to get back target in a no mixin consistent state.", "response": "def remove_mixins(target):\n        \"\"\"Tries to get back target in a no mixin consistent state.\n        \"\"\"\n\n        mixedins_by_name = Mixin.get_mixedins_by_name(target).copy()\n\n        for _name in mixedins_by_name:  # for all named mixins\n            while True:  # remove all mixins named _name\n                try:\n                    Mixin.remove_mixin(target, _name)\n                except Mixin.MixInError:\n                    break"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetch_by_uuid(uuid):\n    # fetch all - private and public - publications\n    all_pubs = [\n        pub\n        for pub in search_publications(DBPublication(uuid=uuid))\n    ]\n\n    if not all_pubs:\n        abort(404, \"Dokument s UUID '%s' nen\u00ed dostupn\u00fd.\" % (uuid))\n\n    public_pubs = [\n        pub\n        for pub in all_pubs\n        if pub.is_public\n    ]\n\n    if not public_pubs:\n        name = all_pubs[0].title\n        raise HTTPError(\n            403,\n            body=\"Forbidden!\",\n            traceback={\"name\": name.decode(\"utf-8\"), \"uuid\": uuid}\n        )\n\n    if len(public_pubs) > 1:\n        abort(500, \"Inkonzistence datab\u00e1ze - vr\u00e1ceno v\u00edcero UUID.\")\n\n    pub = public_pubs[0]\n\n    if settings.PUBLIC_DIR not in pub.file_pointer:\n        abort(500, \"Pokus o neopr\u00e1vn\u011bn\u00fd p\u0159\u00edstup!\")\n\n    down_fn = os.path.basename(pub.filename)\n    local_fn = pub.file_pointer.replace(settings.PUBLIC_DIR, \"\")\n\n    mime_type = mime.Types.of(down_fn)[0].content_type\n    if mime_type == \"inode/symlink\":\n        mime_type = \"auto\"\n\n    response = static_file(\n        local_fn,\n        root=settings.PUBLIC_DIR,\n        download=down_fn,\n        mimetype=mime_type,\n    )\n\n    # Bottle doesn't allow you to specify custom filename AND to say, that you\n    # want to have this file for view in browser instead of download. This\n    # happens because it uses `download` parameter as both bool flag and\n    # alternative filename. - this hack allows it.\n    if mime_type == \"application/pdf\":\n        disposition = 'inline; filename=\"%s\"' % down_fn\n        response.headers[str(\"Content-Disposition\")] = str(disposition)\n\n    return response", "response": "Serve publications by UUID."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render_trees(trees, path_composer):\n    trees = list(trees)  # by default, this is set\n\n    def create_pub_cache(trees):\n        \"\"\"\n        Create uuid -> DBPublication cache from all uuid's linked from `trees`.\n\n        Args:\n            trees (list): List of :class:`.Tree`.\n\n        Returns:\n            dict: {uuid: DBPublication}\n        \"\"\"\n        sub_pubs_uuids = sum((x.collect_publications() for x in trees), [])\n\n        uuid_mapping = {\n            uuid: search_pubs_by_uuid(uuid)\n            for uuid in set(sub_pubs_uuids)\n        }\n\n        # cleaned dict without blank matches\n        return {\n            uuid: pub[0]\n            for uuid, pub in uuid_mapping.iteritems()\n            if pub\n        }\n\n    # create uuid -> DBPublication cache\n    pub_cache = create_pub_cache(trees)\n\n    def render_tree(tree, ind=1):\n        \"\"\"\n        Render the tree into HTML using :attr:`TREE_TEMPLATE`. Private trees\n        are ignored.\n\n        Args:\n            tree (obj): :class:`.Tree` instance.\n            ind (int, default 1): Indentation. This function is called\n                recursively.\n\n        Returns:\n            str: Rendered string.\n        \"\"\"\n        if not tree.is_public:\n            return \"\"\n\n        rendered_tree = SimpleTemplate(TREE_TEMPLATE).render(\n            tree=tree,\n            render_tree=render_tree,\n            ind=ind,\n            path_composer=path_composer,\n            pub_cache=pub_cache,\n        )\n\n        # keep nice indentation\n        ind_txt = ind * \"  \"\n        return ind_txt + (\"\\n\" + ind_txt).join(rendered_tree.splitlines())\n\n    # this is used to get reference for back button\n    parent = tree_handler().get_parent(trees[0])\n    link_up = path_composer(parent) if parent else None\n\n    return SimpleTemplate(TREES_TEMPLATE).render(\n        trees=trees,\n        render_tree=render_tree,\n        link_up=link_up,\n    )", "response": "Render a list of trees into HTML."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrender tree using ISSN.", "response": "def show_periodical_tree_by_issn(issn):\n    \"\"\"\n    Render tree using ISSN.\n    \"\"\"\n    trees = tree_handler().trees_by_issn(issn)\n\n    if not trees:\n        abort(404, \"Dokument s ISSN '%s' nen\u00ed dostupn\u00fd.\" % issn)\n\n    return render_trees(\n        trees,\n        partial(web_tools.compose_tree_path, issn=True)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrender tree using it s path.", "response": "def show_periodical_tree_by_path(path):\n    \"\"\"\n    Render tree using it's path.\n    \"\"\"\n    path = unquote_plus(path)\n    trees = tree_handler().trees_by_path(path)\n\n    if not trees:\n        path = path.decode(\"utf-8\")\n        abort(404, \"Dokument s n\u00e1zvem '%s' nen\u00ed dostupn\u00fd.\" % path)\n\n    return render_trees(\n        trees,\n        partial(web_tools.compose_tree_path, issn=False)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_publications():\n    publications = search_publications(\n        DBPublication(is_public=True)\n    )\n\n    return SimpleTemplate(INDEX_TEMPLATE).render(\n        publications=publications,\n        compose_path=web_tools.compose_path,\n        delimiter=\":\",\n    )", "response": "Return list of all publications in basic graphic HTML render."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if username and password are valid for private index.", "response": "def check_auth(username, password):\n    \"\"\"\n    This function is used to check `username` and `password` in case that\n    :attr:`.settings.PRIVATE_INDEX` is set to ``True`` (default is ``False``).\n    \"\"\"\n    return (username == settings.PRIVATE_INDEX_USERNAME and\n            settings.PRIVATE_INDEX_PASSWORD and\n            password == settings.PRIVATE_INDEX_PASSWORD)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_sample():\n    if md_sample:\n        # user has set another:\n        return md_sample\n    _md = []\n    for hl in range(1, 7): _md.append('#' * hl + ' ' + 'Header %s' % hl)\n    this = open(__file__).read().split('\"\"\"', 3)[2].splitlines()[:10]\n    _md.append('```python\\n\"\"\" Test \"\"\"\\n%s\\n```' % '\\n'.join(this).strip())\n    _md.append(\"\"\"\n| Tables        | Fmt |\n| -- | -- |\n| !!! hint: wrapped | 0.1 **strong** |\n    \"\"\")\n    for ad in admons.keys()[:1]:\n        _md.append('!!! %s: title\\n    this is a %s\\n' % (ad, ad.capitalize()))\n    # 'this theme' replaced in the roller (but not at mdv w/o args):\n    globals()['md_sample'] = \\\n            '\\n'.join(_md) + '\\n----\\n!!! question: %s' % you_like", "response": "Generate the theme roller sample markdown"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_theme(theme=None, for_code=None):\n    try:\n        if theme == 'default':\n            return\n        theme = theme or os.environ.get('AXC_THEME', 'random')\n        # all the themes from here:\n        themes = read_themes()\n        if theme == 'random':\n            rand = randint(0, len(themes)-1)\n            theme = themes.keys()[rand]\n        t = themes.get(theme)\n        if not t or len(t.get('ct')) != 5:\n            # leave defaults:\n            return\n        _for = ''\n        if for_code:\n            _for = ' (code)'\n        if is_app:\n            print >> sys.stderr, low('theme%s: %s (%s)' % (_for, theme,\n                                                       t.get('name')))\n        t = t['ct']\n        cols = (t[0], t[1], t[2], t[3], t[4])\n        if for_code:\n            global CH1, CH2, CH3, CH4, CH5\n            CH1, CH2, CH3, CH4, CH5 = cols\n        else:\n            global H1, H2, H3, H4, H5\n            # set the colors now from the ansi codes in the theme:\n            H1, H2, H3, H4, H5 = cols\n    finally:\n        if for_code:\n            build_hl_by_token()", "response": "set md and code theme"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstyle ansi code hilite", "response": "def style_ansi(raw_code, lang=None):\n    \"\"\" actual code hilite \"\"\"\n    lexer = 0\n    if lang:\n        try:\n            lexer = get_lexer_by_name(lang)\n        except ValueError:\n            print col(R, 'Lexer for %s not found' % lang)\n    lexer = None\n    if not lexer:\n        try:\n            if guess_lexer:\n                lexer = pyg_guess_lexer(raw_code)\n        except:\n            pass\n    if not lexer:\n        lexer = get_lexer_by_name(def_lexer)\n    tokens = lex(raw_code, lexer)\n    cod = []\n    for t, v in tokens:\n        if not v:\n            continue\n        _col = code_hl_tokens.get(t)\n        if _col:\n            cod.append(col(v, _col))\n        else:\n            cod.append(v)\n    return ''.join(cod)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef col(s, c, bg=0, no_reset=0):\n    reset = reset_col\n    if no_reset:\n        reset = ''\n    for _strt, _end, _col in ((code_start, code_end, H2),\n                              (stng_start, stng_end, H2),\n                              (emph_start, emph_end, H3)):\n        if _strt in s:\n            # inline code:\n            s = s.replace(_strt, col('', _col, bg=background, no_reset=1))\n            s = s.replace(_end , col('', c, no_reset=1))\n\n    s =  '\\033[38;5;%sm%s%s' % (c, s, reset)\n    if bg:\n        pass\n        #s = col_bg(bg) + s\n    return s", "response": "print col('foo', 124) -> red 'foo' on the terminal\n    c = color, s the value to colorize"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsplit while multiline blocks vertically", "response": "def split_blocks(text_block, w, cols, part_fmter=None):\n    \"\"\" splits while multiline blocks vertically (for large tables) \"\"\"\n    ts = []\n    for line in text_block.splitlines():\n        parts = []\n        # make equal len:\n        line = line.ljust(w, ' ')\n        # first part full width, others a bit indented:\n        parts.append(line[:cols])\n        scols = cols-2\n        # the txt_block_cut in low makes the whole secondary tables\n        # low. which i find a feature:\n        # if you don't want it remove the col(.., L)\n        parts.extend([' ' + col(txt_block_cut, L, no_reset=1) + \\\n                line[i:i+scols] \\\n                    for i in range(cols, len(line), scols)])\n        ts.append(parts)\n\n    blocks = []\n    for block_part_nr in xrange(len(ts[0])):\n        tpart = []\n        for lines_block in ts:\n            tpart.append(lines_block[block_part_nr])\n        if part_fmter:\n            part_fmter(tpart)\n        tpart[1]  = col(tpart[1], H3)\n        blocks.append('\\n'.join(tpart))\n    t = '\\n'.join(blocks)\n    return('\\n%s\\n' % t)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the width of all the hrs in the result string.", "response": "def set_hr_widths(result):\n    \"\"\"\n    We want the hrs indented by hirarchy...\n    A bit 2 much effort to calc, maybe just fixed with 10\n    style seps would have been enough visually:\n    \u25c8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25c8\n    \"\"\"\n    # set all hrs to max width of text:\n    mw = 0\n    hrs = []\n    if not hr_marker in result:\n        return result\n    for line in result.splitlines():\n        if hr_marker in line:\n            hrs.append(line)\n            continue\n        if len(line) < mw:\n            continue\n        l = len(clean_ansi(line))\n        if l > mw:\n            mw = l\n    for hr in hrs:\n        # pos of hr marker is indent, derives full width:\n        # (more indent = less '-'):\n        hcl = clean_ansi(hr)\n        ind = len(hcl) - len(hcl.split(hr_marker, 1)[1]) - 1\n        w = min(term_columns, mw) - 2 * ind\n        hrf = hr.replace(hr_marker, hr_sep * w)\n        result = result.replace(hr, hrf)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main(md=None, filename=None, cols=None, theme=None, c_theme=None, bg=None,\n         c_no_guess=None, display_links=None, from_txt=None, do_html=None,\n         no_colors=None, **kw):\n    \"\"\" md is markdown string. alternatively we use filename and read \"\"\"\n\n    args = locals()\n    if not md:\n        if not filename:\n            print 'Using sample markdown:'\n            make_sample()\n            md = args['md'] = md_sample\n            print md\n            print\n            print 'Styling Result'\n        else:\n            with open(filename) as f:\n                md = f.read()\n\n    global term_columns\n    # style rolers requested?\n    if c_theme == 'all' or theme == 'all':\n        args.pop('kw')\n        themes = read_themes()\n        for k, v in themes.items():\n            if not filename:\n                yl = 'You like *%s*, *%s*?' % (k, v['name'])\n                args['md'] = md_sample.replace(you_like, yl)\n            print col('%s%s%s' % ('\\n\\n', '=' * term_columns,'\\n'), L)\n            # should really create an iterator here:\n            if theme == 'all':\n                args['theme'] = k\n            else:\n                args['c_theme'] = k\n            print main(**args)\n        return ''\n\n    if cols:\n        term_columns = int(cols)\n\n    global show_links\n    show_links = display_links\n\n    if bg and bg == 'light':\n        # not in use rite now:\n        global background, color\n        background = BGL\n        color = T\n\n    set_theme(theme)\n\n    global guess_lexer\n    guess_lexer = not c_no_guess\n\n    if not c_theme:\n        c_theme = theme or 'default'\n\n    if c_theme == 'None':\n        c_theme = None\n\n    if c_theme:\n        set_theme(c_theme, for_code=1)\n\n    if c_theme or c_guess:\n        # info:\n        if not have_pygments:\n            print col('No pygments, can not analyze code for hilite', R)\n\n\n    # Create an instance of the Markdown class with the new extension\n    MD = markdown.Markdown(extensions=[AnsiPrintExtension(),\n                                       TableExtension(),\n                                       fenced_code.FencedCodeExtension()])\n    # html?\n    the_html = MD.convert(md)\n    if do_html:\n        return the_html\n\n    # who wants html, here is our result:\n    try:\n        ansi = MD.ansi\n    except:\n        if html:\n            # can this happen? At least show:\n            print \"we have markdown result but no ansi.\"\n            print html\n        else:\n            ansi = 'n.a. (no parsing result)'\n\n    # The RAW html within source, incl. fenced code blocks:\n    # phs are numbered like this in the md, we replace back:\n    PH = markdown.util.HTML_PLACEHOLDER\n    stash = MD.htmlStash\n    nr = -1\n    tags = Tags()\n    for ph in stash.rawHtmlBlocks:\n        nr += 1\n        raw = html_parser.unescape(ph[0])\n        pre = '<pre><code'\n        if raw.startswith(pre):\n            pre, raw = raw.split(pre, 1)\n            raw = raw.split('>', 1)[1].rsplit('</code>', 1)[0]\n            if 'class=\"' in pre:\n                # language:\n                lang = pre.split('class=\"', 1)[1].split('\"')[0]\n            else:\n                lang = ''\n            raw = tags.code(raw.strip(), from_fenced_block=1, lang=lang)\n        ansi = ansi.replace(PH % nr, raw)\n\n    # don't want these: gone through the extension now:\n    # ansi = ansi.replace('```', '')\n\n    # sub part display (the -f feature)\n    if from_txt:\n        if not from_txt.split(':', 1)[0] in ansi:\n            # display from top then:\n            from_txt = ansi.strip()[1]\n        from_txt, mon_lines = (from_txt + ':%s' % (term_rows-6)).split(':')[:2]\n        mon_lines = int(mon_lines)\n        pre, post = ansi.split(from_txt, 1)\n        post = '\\n'.join(post.split('\\n')[:mon_lines])\n        ansi = '\\n(...)%s%s%s' % (\n               '\\n'.join(pre.rsplit('\\n', 2)[-2:]), from_txt, post)\n\n    ansi = set_hr_widths(ansi) + '\\n'\n    if no_colors:\n        return clean_ansi(ansi)\n    return ansi + '\\n'", "response": "This function is used to run the main function of the Knockout module."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef monitor(args):\n    filename = args.get('MDFILE')\n    if not filename:\n        print col('Need file argument', 2)\n        raise SystemExit\n    last_err = ''\n    last_stat = 0\n    while True:\n        if not os.path.exists(filename):\n            last_err = 'File %s not found. Will continue trying.' % filename\n        else:\n            try:\n                stat = os.stat(filename)[8]\n                if stat != last_stat:\n                    parsed = run_args(args)\n                    print parsed\n                    last_stat = stat\n                last_err = ''\n            except Exception, ex:\n                last_err = str(ex)\n        if last_err:\n            print 'Error: %s' % last_err\n        sleep()", "response": "monitor mode for the file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning commands on changes on file fp", "response": "def run_changed_file_cmd(cmd, fp, pretty):\n    \"\"\" running commands on changes.\n        pretty the parsed file\n    \"\"\"\n    with open(fp) as f:\n        raw = f.read()\n    # go sure regarding quotes:\n    for ph in (dir_mon_filepath_ph, dir_mon_content_raw,\n                dir_mon_content_pretty):\n        if ph in cmd and not ('\"%s\"' % ph) in cmd \\\n                        and not (\"'%s'\" % ph) in cmd:\n            cmd = cmd.replace(ph, '\"%s\"' % ph)\n\n    cmd = cmd.replace(dir_mon_filepath_ph, fp)\n    print col('Running %s' % cmd, H1)\n    for r, what in ((dir_mon_content_raw, raw),\n                    (dir_mon_content_pretty, pretty)):\n        cmd = cmd.replace(r, what.encode('base64'))\n\n    # yeah, i know, sub bla bla...\n    if os.system(cmd):\n        print col('(the command failed)', R)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmonitors the directory tree", "response": "def monitor_dir(args):\n    \"\"\" displaying the changed files \"\"\"\n\n    def show_fp(fp):\n        args['MDFILE'] = fp\n        pretty = run_args(args)\n        print pretty\n        print \"(%s)\" % col(fp, L)\n        cmd = args.get('change_cmd')\n        if cmd:\n            run_changed_file_cmd(cmd, fp=fp, pretty=pretty)\n\n    ftree = {}\n    d = args.get('-M')\n    # was a change command given?\n    d += '::'\n    d, args['change_cmd'] = d.split('::')[:2]\n    args.pop('-M')\n    # collides:\n    args.pop('-m')\n    d, exts = (d + ':md,mdown,markdown').split(':')[:2]\n    exts = exts.split(',')\n    if not os.path.exists(d):\n        print col('Does not exist: %s' % d, R)\n        sys.exit(2)\n\n    dir_black_list = ['.', '..']\n    def check_dir(d, ftree):\n        check_latest = ftree.get('latest_ts')\n        d = os.path.abspath(d)\n        if d in dir_black_list:\n            return\n\n        if len(ftree) > mon_max_files:\n            # too deep:\n            print col('Max files (%s) reached' % c(mon_max_files, R))\n            dir_black_list.append(d)\n            return\n        try:\n            files = os.listdir(d)\n        except Exception, ex:\n            print '%s when scanning dir %s' % (col(ex, R), d)\n            dir_black_list.append(d)\n            return\n\n        for f in files:\n            fp = j(d, f)\n            if os.path.isfile(fp):\n                f_ext = f.rsplit('.', 1)[-1]\n                if f_ext == f:\n                    f_ext == ''\n                if not f_ext in exts:\n                    continue\n                old = ftree.get(fp)\n                # size:\n                now = os.stat(fp)[6]\n                if check_latest:\n                    if os.stat(fp)[7] > ftree['latest_ts']:\n                        ftree['latest'] = fp\n                        ftree['latest_ts'] = os.stat(fp)[8]\n                if now == old:\n                    continue\n                # change:\n                ftree[fp] = now\n                if not old:\n                    # At first time we don't display ALL the files...:\n                    continue\n                # no binary. make sure:\n                if 'text' in os.popen('file \"%s\"' % fp).read():\n                    show_fp(fp)\n            elif os.path.isdir(fp):\n                check_dir(j(d, fp), ftree)\n\n\n    ftree['latest_ts'] = 1\n    while True:\n        check_dir(d, ftree)\n        if 'latest_ts' in ftree:\n            ftree.pop('latest_ts')\n            fp = ftree.get('latest')\n            if fp:\n                show_fp(fp)\n            else:\n                print 'sth went wrong, no file found'\n        sleep()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall the lib entry function with CLI args", "response": "def run_args(args):\n    \"\"\" call the lib entry function with CLI args \"\"\"\n    return main(filename      = args.get('MDFILE')\n               ,theme         = args.get('-t', 'random')\n               ,cols          = args.get('-c')\n               ,from_txt      = args.get('-f')\n               ,c_theme       = args.get('-T')\n               ,c_no_guess    = args.get('-x')\n               ,do_html       = args.get('-H')\n               ,no_colors     = args.get('-A')\n               ,display_links = args.get('-L'))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef code(_, s, from_fenced_block = None, **kw):\n        lang = kw.get('lang')\n\n        raw_code = s\n        if have_pygments:\n            s = style_ansi(raw_code, lang=lang)\n\n\n        # outest hir is 2, use it for fenced:\n        ind = ' ' * kw.get('hir', 2)\n        #if from_fenced_block: ... WE treat equal.\n\n        # shift to the far left, no matter the indent (screenspace matters):\n        firstl = s.split('\\n')[0]\n        del_spaces = ' ' * (len(firstl) - len(firstl.lstrip()))\n        s = ('\\n' + s).replace('\\n%s' % del_spaces, '\\n')[1:]\n\n        # we want an indent of one and low vis prefix. this does it:\n        code_lines = ('\\n' + s).splitlines()\n        prefix = ('\\n%s%s %s' % (ind, low(code_pref), col('', C, no_reset=1)))\n        code = prefix.join(code_lines)\n        return code + '\\n' + reset_col", "response": "md code and raw code ends here"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning y value of bestfit_func", "response": "def bestfit_func(self, bestfit_x):\n        \"\"\"\n        Returns y value\n        \"\"\"\n        if not self.bestfit_func:\n            raise KeyError(\"Do do_bestfit first\")\n        return self.args[\"func\"](self.fit_args, bestfit_x)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef do_bestfit(self):\n        self.check_important_variables()\n        x = np.array(self.args[\"x\"])\n        y = np.array(self.args[\"y\"])\n        if self.args.get(\"use_RealData\", True):\n            realdata_kwargs = self.args.get(\"RealData_kwargs\", {})\n            data = RealData(x, y, **realdata_kwargs)\n        else:\n            data_kwargs = self.args.get(\"Data_kwargs\", {})\n            data = Data(x, y, **data_kwargs)\n        model = self.args.get(\"Model\", None)\n        if model is None:\n            if \"func\" not in self.args.keys():\n                raise KeyError(\"Need fitting function\")\n            model_kwargs = self.args.get(\"Model_kwargs\", {})\n            model = Model(self.args[\"func\"], **model_kwargs)\n        odr_kwargs = self.args.get(\"ODR_kwargs\", {})\n        odr = ODR(data, model, **odr_kwargs)\n        self.output = odr.run()\n        if self.args.get(\"pprint\", False):\n            self.output.pprint()\n        self.fit_args = self.output.beta\n        return self.fit_args", "response": "do bestfit using scipy. odr\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gprmc_to_degdec(lat, latDirn, lng, lngDirn):\n    x = float(lat[0:2]) + float(lat[2:]) / 60\n    y = float(lng[0:3]) + float(lng[3:]) / 60\n\n    if latDirn == 'S':\n        x = -x\n    if lngDirn == 'W':\n        y = -y\n\n    return x, y", "response": "Converts GPRMC formats ( Decimal Minutes ) to Degrees Decimal."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tinygps_to_degdec(lat, lng):\n    x = float(lat[:-5] + '.' + lat[-5:])\n    y = float(lng[:-5] + '.' + lng[-5:])\n\n    return x, y", "response": "Converts TinyGPS formats to Degrees Decimal."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef change_in_longitude(lat, miles):\n\n    # Find the radius of a circle around the earth at given latitude.\n    r = earth_radius * math.cos(lat * degrees_to_radians)\n    return (miles / r) * radians_to_degrees", "response": "Given a latitude and a distance west return the change in longitude."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef calculate_boundingbox(lng, lat, miles):\n\n    latChange = change_in_latitude(miles)\n    latSouth = lat - latChange\n    latNorth = lat + latChange\n    lngChange = change_in_longitude(lat, miles)\n    lngWest = lng + lngChange\n    lngEast = lng - lngChange\n    return (lngWest, latSouth, lngEast, latNorth)", "response": "Calculate the bounding box of a node given a latitude longitude and a distance in miles."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef disconnect(self):\n\n        if self.connection_receive:\n            self.connection_receive.close()\n        if self.connection_respond:\n            self.connection_respond.close()\n        if self.connection_send:\n            self.connection_send.close()", "response": "Disconnect all connections that are set on this wire."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_and_wait(self, path, message, timeout=0, responder=None):\n\n        message.on(\"response\", lambda x,event_origin,source:None, once=True)\n\n        if timeout > 0:\n            ts = time.time()\n        else:\n            ts = 0\n        sent = False\n\n        while not message.response_received:\n            if not sent:\n                self.send(path, message)\n                sent = True\n            if ts:\n                if time.time() - ts > timeout:\n                    raise exceptions.TimeoutError(\"send_and_wait(%s)\"%path, timeout)\n\n        return message.response_message", "response": "Send a message and block until a response is received."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wire(self, name, receive=None, send=None, respond=None, **kwargs):\n\n        \"\"\"\n        Wires the link to a connection. Can be called multiple\n        times to set up wires to different connections\n\n        After creation wire will be accessible on the link via its name\n        as an attribute.\n\n        You can undo this action with the cut() method\n\n        Arguments:\n\n            - name (str): unique name for the wire\n\n        Keyword Arguments:\n\n            - receive (Connection): wire receiver to this connection\n            - respond (Connection): wire responder to this connection\n            - send (Connection): wire sender to this connection\n            - meta (dict): attach these meta variables to any message\n                sent from this wire\n\n        Returns:\n\n            - Wire: the created wire instance\n        \"\"\"\n\n        if hasattr(self, name) and name != \"main\":\n            raise AttributeError(\"cannot use '%s' as name for wire, attribute already exists\")\n\n        if send:\n            self.log_debug(\"Wiring '%s'.send: %s\" % (name, send))\n        if respond:\n            self.log_debug(\"Wiring '%s'.respond: %s\" % (name, respond))\n        if receive:\n            self.log_debug(\"Wiring '%s'.receive: %s\" % (name, receive))\n\n        wire = Wire(receive=receive, send=send, respond=respond)\n        wire.name = \"%s.%s\" % (self.name, name)\n        wire.meta = kwargs.get(\"meta\",{})\n        wire.on(\"receive\", self.on_receive)\n        setattr(self, name, wire)\n\n        if not self.main:\n            self.main = wire\n\n        return wire", "response": "Create a wire instance for a specific connection."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cut(self, name, disconnect=False):\n\n        \"\"\"\n        Cut a wire (undo a wire() call)\n\n        Arguments:\n\n            - name (str): name of the wire\n\n        Keyword Arguments:\n\n            - disconnect (bool): if True also disconnect all connections on the\n                specified wire\n        \"\"\"\n\n        wire = getattr(self, name, None)\n        if wire and isinstance(wire, Wire):\n            if name != \"main\":\n                delattr(self, name)\n            if disconnect:\n                wire.disconnect()\n            wire.off(\"receive\", self.on_receive)\n            if self.main == wire:\n                self.main = None\n                self.set_main_wire()", "response": "Cut a wire from the main wire"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_main_wire(self, wire=None):\n\n        \"\"\"\n        Sets the specified wire as the link's main wire\n        This is done automatically during the first wire() call\n\n        Keyword Arguments:\n\n            - wire (Wire): if None, use the first wire instance found\n\n        Returns:\n\n            - Wire: the new main wire instance\n        \"\"\"\n\n        if not wire:\n            for k in dir(self):\n                if isinstance(getattr(self, k), Wire):\n                    wire = getattr(self, k)\n                    break\n        elif not isinstance(wire, Wire):\n            raise ValueError(\"wire needs to be a Wire instance\")\n\n        if not isinstance(wire, Wire):\n            wire = None\n\n        self.main = wire\n        return wire", "response": "Sets the specified wire as the link s main wire\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nyield name wire for all wires on this link", "response": "def wires(self):\n        \"\"\"\n        Yields name (str), wire (Wire) for all wires on\n        this link\n        \"\"\"\n\n        for k in dir(self):\n            if isinstance(getattr(self, k), Wire):\n                yield k, getattr(self, k)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef disconnect(self):\n\n        for name, wire in self.wires():\n            self.cut(name, disconnect=True)", "response": "Disconnect all wires and disconnect all connections established on this link."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef call(self, task, decorators=None):\n        if decorators is None:\n            decorators = []\n\n        task = self.apply_task_decorators(task, decorators)\n\n        data = task.get_data()\n        name = task.get_name()\n\n        result = self._inner_call(name, data)\n        task_result = RawTaskResult(task, result)\n        return self.apply_task_result_decorators(task_result, decorators)", "response": "Call given task on service layer."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the absolute path to the resources directory for given file.", "response": "def _resource_context(fn):\n    \"\"\"\n    Compose path to the ``resources`` directory for given `fn`.\n\n    Args:\n        fn (str): Filename of file in ``resources`` directory.\n\n    Returns:\n        str: Absolute path to the file in resources directory.\n    \"\"\"\n    return os.path.join(\n        os.path.dirname(__file__),\n        DES_DIR,\n        fn\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_contract(firma, pravni_forma, sidlo, ic, dic, zastoupen):\n    contract_fn = _resource_context(\n        \"Licencni_smlouva_o_dodavani_elektronickych_publikaci\"\n        \"_a_jejich_uziti.rst\"\n    )\n\n    # load contract\n    with open(contract_fn) as f:\n        contract = f.read()#.decode(\"utf-8\").encode(\"utf-8\")\n\n    # make sure that `firma` has its heading mark\n    firma = firma.strip()\n    firma = firma + \"\\n\" + ((len(firma) + 1) * \"-\")\n\n    # patch template\n    contract = Template(contract).substitute(\n        firma=firma,\n        pravni_forma=pravni_forma.strip(),\n        sidlo=sidlo.strip(),\n        ic=ic.strip(),\n        dic=dic.strip(),\n        zastoupen=zastoupen.strip(),\n        resources_path=RES_PATH\n    )\n\n    return gen_pdf(\n        contract,\n        open(_resource_context(\"style.json\")).read(),\n    )", "response": "Returns a PDF file containing the contract and creates it."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates review from review_struct.", "response": "def get_review(review_struct):\n    \"\"\"\n    Generate review from `review_struct`.\n\n    Args:\n        review_struct (obj): :class:`.GenerateReview` instance.\n\n    Returns:\n        obj: StringIO file instance containing PDF file.\n    \"\"\"\n    review_fn = _resource_context(\"review.rst\")\n\n    # read review template\n    with open(review_fn) as f:\n        review = f.read()\n\n    # generate qr code\n    with NamedTemporaryFile(suffix=\".png\") as qr_file:\n        url = pyqrcode.create(review_struct.internal_url)\n        url.png(qr_file.name, scale=5)\n\n        # save the file\n        qr_file.flush()\n        qr_file.seek(0)\n\n        # generate template\n        review = Template(review).substitute(\n            content=review_struct.get_rst(),\n            datum=time.strftime(\"%d.%m.%Y\", time.localtime()),\n            cas=time.strftime(\"%H:%M\", time.localtime()),\n            resources_path=RES_PATH,\n            qr_path=qr_file.name,\n        )\n\n        return gen_pdf(\n            review,\n            open(_resource_context(\"review_style.json\")).read(),\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef enum_subpattern(p):\n    subpattern_id, d = p\n    patterns = list(enum_gen(d))\n\n    '''\n    if subpattern_id:\n        subpat_iter = EnumSubpatternIterator(subpattern_id, patterns)\n        SUBPATTERNS[subpattern_id] = subpat_iter\n        return subpat_iter\n    else:\n        return patterns\n        '''\n    return patterns", "response": "Enumerate all subpatterns of a given pattern."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef as_tag(self, tag_func):\n        @wraps(tag_func)\n        def tag_wrapper(parser, token):\n            class AsTagNode(template.Node):\n                def render(self, context):\n                    parts = token.split_contents()\n\n                    # Resolve variables if their names are given.\n                    def resolve(arg):\n                        try:\n                            return template.Variable(arg).resolve(context)\n                        except template.VariableDoesNotExist:\n                            return arg\n                    args, kwargs = [], {}\n                    for arg in parts[1:-2]:\n                        if \"=\" in arg:\n                            name, val = arg.split(\"=\", 1)\n                            if name in tag_func.__code__.co_varnames:\n                                kwargs[name] = resolve(val)\n                                continue\n                        args.append(resolve(arg))\n                    context[parts[-1]] = tag_func(*args, **kwargs)\n                    return \"\"\n            return AsTagNode()\n        return self.tag(tag_wrapper)", "response": "Create a tag expecting the format of tag_name as var_name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef render_tag(self, tag_func):\n        @wraps(tag_func)\n        def tag_wrapper(parser, token):\n            class RenderTagNode(template.Node):\n                def render(self, context):\n                    return tag_func(context, token)\n            return RenderTagNode()\n        return self.tag(tag_wrapper)", "response": "Decorator for creating a tag using the decorated function as the render function\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_end_tag(self, tag_func):\n        @wraps(tag_func)\n        def tag_wrapper(parser, token):\n\n            class ToEndTagNode(template.Node):\n\n                def __init__(self):\n                    end_name = \"end%s\" % tag_func.__name__\n                    self.nodelist = parser.parse((end_name,))\n                    parser.delete_first_token()\n\n                def render(self, context):\n                    args = (self.nodelist.render(context), context, token)\n                    return tag_func(*args[:tag_func.__code__.co_argcount])\n\n            return ToEndTagNode()\n\n        return self.tag(tag_wrapper)", "response": "Creates a tag that parses until it finds the corresponding endTag."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef inclusion_tag(self, name, context_class=Context, takes_context=False):\n        def tag_decorator(tag_func):\n\n            @wraps(tag_func)\n            def tag_wrapper(parser, token):\n\n                class InclusionTagNode(template.Node):\n\n                    def render(self, context):\n                        if not getattr(self, \"nodelist\", False):\n                            try:\n                                request = context[\"request\"]\n                            except KeyError:\n                                t = get_template(name)\n                            else:\n                                ts = templates_for_device(request, name)\n                                t = select_template(ts)\n\n                            self.template = t\n                        parts = [template.Variable(part).resolve(context)\n                                 for part in token.split_contents()[1:]]\n                        if takes_context:\n                            parts.insert(0, context)\n                        result = tag_func(*parts)\n                        autoescape = context.autoescape\n                        context = context_class(result, autoescape=autoescape)\n                        return self.template.render(context)\n\n                return InclusionTagNode()\n            return self.tag(tag_wrapper)\n        return tag_decorator", "response": "Decorator for Django s inclusion_tag which looks up a specific template at render time."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef user_list(self, params=None):\n\n        uri = 'openstack/users'\n        if params:\n            uri += '?%s' % urllib.urlencode(params)\n\n        resp, body = self.get(uri)\n        self.expected_success(200, resp.status)\n        body = json.loads(body)\n        return rest_client.ResponseBody(resp, body)", "response": "Lists all users within the tenant."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef user_invite(self, username, email, roles):\n\n        uri = 'openstack/users'\n        data = {\n            \"username\": username,\n            \"email\": email,\n            \"roles\": list(set(roles))\n        }\n        post_body = json.dumps(data)\n        resp, body = self.post(uri, body=post_body)\n        self.expected_success(200, resp.status)\n        body = json.loads(body)\n        return rest_client.ResponseBody(resp, body)", "response": "Invite a user to the tenant."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrevokes a user from the Keystone", "response": "def revoke_user(self, user_id):\n        \"\"\" Revoke a user from the tenant\n            This will remove pending or approved roles but\n            will not not delete the user from Keystone.\n        \"\"\"\n\n        uri = 'openstack/users/%s' % user_id\n        try:\n            resp = self.delete(uri)\n        except AttributeError:\n            # note: this breaks. stacktask returns a string, not json.\n            return\n        self.expected_success(200, resp.status)\n        return rest_client.ResponseBody(resp, None)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_tokens(self, filters={}):\n        uri = 'tokens'\n\n        if filters:\n            filters = {'filters': json.dumps(filters)}\n            uri += \"?%s\" % urllib.urlencode(filters, True)\n\n        resp, body = self.get(uri)\n        self.expected_success(200, resp.status)\n        body = json.loads(body)\n        return rest_client.ResponseBody(resp, body)", "response": "Returns a dict of tokens matching the provided filters"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef token_submit(self, token_id, json_data={}):\n        uri = 'tokens/%s' % token_id\n        post_body = json.dumps(json_data)\n\n        resp, body = self.post(uri, post_body)\n        self.expected_success(200, resp.status)\n        body = json.loads(body)\n        return rest_client.ResponseBody(resp, body)", "response": "Submits a given token along with optional data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\napproving a task from the specified task_id. Returns a dict of tasks matching the provided filters.", "response": "def approve_task(self, task_id):\n        \"\"\" Returns dict of tasks matching the provided filters \"\"\"\n        uri = 'tasks/%s' % task_id\n\n        data = {\"approved\": True}\n\n        resp, body = self.post(uri, json.dumps(data))\n        self.expected_success(200, resp.status)\n        body = json.loads(body)\n        return rest_client.ResponseBody(resp, body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef signup(self, project_name, email):\n\n        uri = 'openstack/sign-up'\n        data = {\n            \"project_name\": project_name,\n            \"email\": email,\n        }\n        post_body = json.dumps(data)\n        resp, body = self.post(uri, body=post_body)\n        self.expected_success(200, resp.status)\n        body = json.loads(body)\n        return rest_client.ResponseBody(resp, body)", "response": "Signup for a new project."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _add_internal_event(self, name, send_event=False, internal_event_factory=None):\n        if not internal_event_factory:\n            internal_event_factory = self.internal_event_factory\n        return self.add_event(names, send_event=send_event, event_factory=internal_event_factory)", "response": "Add an internal event to the event queue."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd events to the internal event list.", "response": "def add_events(self, names, send_event=True, event_factory=None):\n        \"\"\"\n        Add event by name.\n\n        This is called for you as needed if you allow auto creation of events (see __init__).\n\n        Upon an event being added, all handlers are searched for if they have this event,\n        and if they do, they are added to the Event's list of callables.\n\n        :param tuple names: Names\n        \"\"\"\n        if not event_factory:\n            event_factory = self.event_factory\n\n        # Create events\n        self.events.update({name: event_factory() for name in names},)\n        # Inspect handlers to see if they should be attached to this new event\n        [self._attach_handler_events(handler, events=names) for handler in self.handlers]\n\n        if send_event:\n            [self.on_add_event(name) for name in names]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_event(self, name, send_event=True, event_factory=None):\n        return self.add_events((name,),send_event=send_event,event_factory=event_factory)", "response": "Add an event by name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsearching handler for methods named after events and attaches them to self. events.", "response": "def _attach_handler_events(self, handler, events=None):\n        \"\"\"\n        Search handler for methods named after events, attaching to event handlers as applicable.\n\n        :param object handler: Handler instance\n        :param list events: List of event names to look for. If not specified, will do all known event names.\n        \"\"\"\n        if not events:\n            events = self\n        for name in events:\n            meth = getattr(handler, name, None)\n            if meth:\n                self.events[name] += meth"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a new handler instance and attach any events to it.", "response": "def _add(self, handler, allow_dupe=False, send_event=True):\n        \"\"\"\n        Add handler instance and attach any events to it.\n\n        :param object handler: handler instance\n        :param bool allow_dupe: If True, allow registering a handler more than once.\n        :return object: The handler you added is given back so this can be used as a decorator.\n        \"\"\"\n        if not allow_dupe and handler in self.handlers:\n            raise ValueError(\"Handler already present: %s\" % handler)\n        self.handlers.append(handler)\n        self._attach_handler_events(handler)\n        if send_event:\n            self.on_handler_add(handler)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a new handler instance and attach any events to it.", "response": "def add(self, handler, allow_dupe=False, send_event=True):\n        \"\"\"\n        Add handler instance and attach any events to it.\n\n        :param object handler: handler instance\n        :param bool allow_dupe: If True, allow registering a handler more than once.\n        :return object: The handler you added is given back so this can be used as a decorator.\n        \"\"\"\n        self._add(handler, allow_dupe=allow_dupe, send_event=send_event)\n        return handler"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _remove(self, handler, send_event=True):\n        for event in self:\n            event.remove_handlers_bound_to_instance(handler)\n        self.handlers.remove(handler)\n        if send_event:\n            self.on_handler_remove(handler)", "response": "Removes a handler instance and detach any methods bound to it from uninhibited."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fire(self, event, *args, **kwargs):\n        if not self._maybe_create_on_fire(event):\n            return\n        return self[event].fire(*args, **kwargs)", "response": "Fire event. call each handler with given arguments return a list of results."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ifire(self, event, *args, **kwargs):\n        if not self._maybe_create_on_fire(event):\n            return\n\n        # Wrap the generator per item to force that this method be a generator\n        # Python 3.x of course has yield from, which would be great here.\n        # for x in self[event].ifire(*args, **kwargs)\n        #     yield x\n        return self[event].ifire(*args, **kwargs)", "response": "Iteratively fire an event returning a generator yielding each result."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef active(context, pattern_or_urlname, class_name='active', *args, **kwargs):\n    request = context.dicts[1].get('request')\n\n    try:\n        pattern = '^%s$' % reverse(pattern_or_urlname, args=args,\n                                   kwargs=kwargs)\n    except NoReverseMatch:\n        pattern = pattern_or_urlname\n\n    if request and re.search(pattern, request.path):\n        return class_name\n\n    return ''", "response": "This function will determine if a URL pattern or name is the current page."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tick(self, unit_value):\n    total_secs = round(time.time() - self.__prev_tick)\n    if total_secs >= 1:\n      self.__unit_per_sec = unit_value / total_secs - self.__unit_per_sec_prev\n      self.__unit_per_sec_prev = unit_value\n      self.__prev_tick = time.time()", "response": "tick the order of the elements in the order of the elements in the order of the elements in the order they were added."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start(self, max_val):\n    self._timer.init_timer(max_value=max_val)\n\n    self._infinite_mode = max_val <= 0\n    self._infinite_position = 0\n\n    self._max = max_val\n    self._fill_empty()\n    self._value = 0\n    self.progress(0)\n    self._status = ProgressBarStatus.started", "response": "Starts the progress bar."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef progress(self, value, new_status=None):\n    space_fillers = 0\n\n    if new_status is not None:\n      # if new text is shorter, then we need fill previously used place\n      space_fillers = len(self._status_msg) - len(new_status) if self._status_msg and len(self._status_msg) - len(new_status) > 0 else 0\n      self._status_msg = new_status\n\n    if not self._infinite_mode and value > self._max:\n      self._infinite_mode = True\n      self._fill_empty()\n\n    self._timer.tick(value)\n\n    if not self._infinite_mode:\n      percent_done = self._calc_percent_done(value)\n      filled = self._options.fill_char * int(self._calc_filled_space(percent_done))\n      empty = self._options.blank_char * int(self._calc_empty_space(percent_done))\n    else:\n      percent_done = 100\n      self._infinite_position = 1 if self._infinite_position + self._infinite_width >= self._width else self._infinite_position + 1\n      filled = \"%s%s\" % (self._options.blank_char * (self._infinite_position - self._infinite_width), self._options.fill_char * self._infinite_width)\n      empty = self._options.blank_char * int(self._width - self._infinite_position)\n\n    kwargs = {\n      \"begin_line\": self._begin_line_character,\n      \"text\": self._text,\n      \"status\": self._status_msg,\n      \"end_line\": \" \" * space_fillers,\n      \"filled\": filled,\n      \"reverse_filled\": filled[::-1],\n      \"empty\": empty,\n      \"value\": int(value),\n      \"max\": int(self._max),\n      \"items_per_sec\": self._timer.unit_per_sec,\n      \"percents_done\": percent_done\n    }\n\n    self.stdout.write(safe_format(self._options.progress_format.value, **kwargs))\n    self.stdout.flush()", "response": "Update the progress bar."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef progress_inc(self, step=1, new_status=None):\n    self._value += step\n    self.progress(self._value, new_status=new_status)", "response": "inc the progress of the current node"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef stop(self, hide_progress=False, new_status=None):\n\n    self._status = ProgressBarStatus.stopped\n    if hide_progress:\n      sep = \" - \"\n      if new_status is None:\n        new_status = sep = \"\"\n\n      kwargs = {\n        \"begin_line\": self._begin_line_character,\n        \"text\": self._text,\n        \"new_status\": new_status,\n        \"sep\": sep,\n        \"fill_space\": \" \" * (self._console_width - len(self._text) - len(sep) - len(new_status) - len(os.linesep))\n      }\n      self.stdout.write(\"{begin_line}{text}{sep}{new_status}{fill_space}\".format(**kwargs))\n    else:\n      self.progress(int(self._max), new_status=new_status)\n\n    self.stdout.write(os.linesep)", "response": "Stop the current process."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __trim_extensions_dot(exts):\n  if exts is None:\n    return None\n  res = []\n  for i in range(0, len(exts)):\n    if exts[i] == \"\":\n      continue\n    res.append(__trim_extension_dot(exts[i]))\n  return res", "response": "trim leading dots from extensions and drop any empty strings."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsplit a filename into chrom start and end coordinates.", "response": "def __split_genomic_interval_filename(fn):\n  \"\"\"\n  Split a filename of the format chrom:start-end.ext or chrom.ext (full chrom).\n\n  :return: tuple of (chrom, start, end) -- 'start' and 'end' are None if not\n           present in the filename.\n  \"\"\"\n  if fn is None or fn == \"\":\n    raise ValueError(\"invalid filename: \" + str(fn))\n  fn = \".\".join(fn.split(\".\")[:-1])\n  parts = fn.split(\":\")\n  if len(parts) == 1:\n    return (parts[0].strip(), None, None)\n  else:\n    r_parts = parts[1].split(\"-\")\n    if len(r_parts) != 2:\n      raise ValueError(\"Invalid filename: \" + str(fn))\n    return (parts[0].strip(), int(r_parts[0]), int(r_parts[1]))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_just_in_time_genome_alignment(path, ref_spec, extensions=None,\n                                       index_exts=None, fail_no_index=True,\n                                       verbose=False):\n    \"\"\"Load a just-in-time genome alignment from a directory.\"\"\"\n    if index_exts is None and fail_no_index:\n      raise ValueError(\"Failure on no index specified for loading genome \" +\n                       \"alignment, but no index extensions specified\")\n\n    extensions = __trim_extensions_dot(extensions)\n    index_exts = __trim_extensions_dot(index_exts)\n\n    partial_chrom_files = {}\n    whole_chrom_files = {}\n    for fn in os.listdir(path):\n      pth = os.path.join(path, fn)\n      if os.path.isfile(pth):\n        base, ext = os.path.splitext(pth)\n        ext = __trim_extension_dot(ext)\n        if extensions is None or ext in extensions:\n          idx_path = __find_index(pth, index_exts)\n          if idx_path is None and fail_no_index:\n            raise PyokitIOError(\"No index file for \" + fn)\n          chrom, start, end = __split_genomic_interval_filename(fn)\n          assert((start is None and end is None) or\n                 (start is not None and end is not None))\n          if start is None:\n            if chrom in whole_chrom_files:\n              raise PyokitIOError(\"multiple files for chrom \" + chrom)\n            whole_chrom_files[chrom] = (pth, idx_path)\n          else:\n            k = (chrom, start, end)\n            if k in partial_chrom_files:\n              other_pth = partial_chrom_files[k][0]\n              raise PyokitIOError(\"multiple files for \" + str(k) + \" --> \" +\n                                  pth + \" and \" + other_pth)\n            partial_chrom_files[k] = (pth, idx_path)\n\n    def factory(k):\n      pth, idx = k\n      return build_genome_alignment_from_file(pth, ref_spec, idx, verbose)\n\n    return JustInTimeGenomeAlignment(whole_chrom_files, partial_chrom_files,\n                                     factory)", "response": "Load a just - in - time genome alignment from a directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds an index file for a genome alignment file in the same directory.", "response": "def __find_index(alig_file_pth, idx_extensions):\n  \"\"\"\n  Find an index file for a genome alignment file in the same directory.\n\n  :param alig_file_path: path to the alignment file.\n  :param idx_extensions: check for index files with these extensions\n  :return: path to first index file that matches the name of the alignment file\n           and has one of the specified extensions.\n  \"\"\"\n  if idx_extensions is None:\n    return None\n  base, _ = os.path.splitext(alig_file_pth)\n  for idx_ext in idx_extensions:\n    candidate = base + os.extsep + idx_ext\n    if os.path.isfile(candidate):\n      return candidate\n  return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_genome_alignment_from_directory(d_name, ref_spec, extensions=None,\n                                          index_exts=None,\n                                          fail_no_index=False):\n  \"\"\"\n  build a genome aligment by loading all files in a directory.\n\n  Fiel without indexes are loaded immediately; those with indexes are\n  loaded on-demand. Not recursive (i.e. subdirectories are not parsed).\n\n  :param d_name:        directory to load from.\n  :param ref_spec:      which species in the alignemnt files is the reference?\n  :param extensions:    list or set of acceptable extensions; treat any files\n                        with these extensions as part of the alignment. If\n                        None, treat any file which has an extension that is\n                        NOT in index_extensions as part of the alignment.\n  :param index_exts:    treat any files with these extensions as index files.\n  :param fail_no_index: fail if index extensions are provided and an alignment\n                        file has no index file.\n  \"\"\"\n  if index_exts is None and fail_no_index:\n    raise ValueError(\"Failure on no index specified for loading genome \" +\n                     \"alignment, but no index extensions specified\")\n\n  blocks = []\n  for fn in os.listdir(d_name):\n    pth = os.path.join(d_name, fn)\n    if os.path.isfile(pth):\n      _, ext = os.path.splitext(pth)\n      if extensions is None or ext in extensions:\n        idx_path = __find_index(pth, index_exts)\n        if idx_path is None and fail_no_index:\n          raise PyokitIOError(\"No index file for \" + fn)\n        for b in genome_alignment_iterator(pth, ref_spec, idx_path):\n          blocks.append(b)\n  return GenomeAlignment(blocks)", "response": "Build a genome alignment from a directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild a genome alignment from a single MAF file.", "response": "def build_genome_alignment_from_file(ga_path, ref_spec, idx_path=None,\n                                     verbose=False):\n  \"\"\"\n  build a genome alignment by loading from a single MAF file.\n\n  :param ga_path:  the path to the file to load.\n  :param ref_spec: which species in the MAF file is the reference?\n  :param idx_path: if provided, use this index to generate a just-in-time\n                   genome alignment, instead of loading the file immediately.\n  \"\"\"\n  blocks = []\n  if (idx_path is not None):\n    bound_iter = functools.partial(genome_alignment_iterator,\n                                   reference_species=ref_spec)\n    hash_func = JustInTimeGenomeAlignmentBlock.build_hash\n    factory = IndexedFile(None, bound_iter, hash_func)\n    factory.read_index(idx_path, ga_path, verbose=verbose)\n\n    pind = None\n    for k in factory:\n      if verbose:\n        if pind is None:\n          total = len(factory)\n          pind = ProgressIndicator(totalToDo=total, messagePrefix=\"completed\",\n                                   messageSuffix=\"building alignment blocks \")\n        pind.done += 1\n        pind.showProgress()\n      blocks.append(JustInTimeGenomeAlignmentBlock(factory, k))\n  else:\n    for b in genome_alignment_iterator(ga_path, ref_spec, verbose=verbose):\n      blocks.append(b)\n  return GenomeAlignment(blocks, verbose)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding an iterator for an MAF file of genome alignment blocks.", "response": "def genome_alignment_iterator(fn, reference_species, index_friendly=False,\n                              verbose=False):\n  \"\"\"\n  build an iterator for an MAF file of genome alignment blocks.\n\n  :param fn:                 filename or stream-like object to iterate over.\n  :param reference_species:  which species in the alignment should be treated\n                             as the reference?\n  :param index_friendly:     if True, buffering is disabled to support using\n                             the iterator to build an index.\n\n  :return an iterator that yields GenomeAlignment objects\n  \"\"\"\n  kw_args = {\"reference_species\": reference_species}\n  for e in maf.maf_iterator(fn, index_friendly=index_friendly,\n                            yield_class=GenomeAlignmentBlock,\n                            yield_kw_args=kw_args,\n                            verbose=verbose):\n    yield e"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding an index for a MAF genome alig file and return StringIO of it.", "response": "def _build_index(maf_strm, ref_spec):\n  \"\"\"Build an index for a MAF genome alig file and return StringIO of it.\"\"\"\n  idx_strm = StringIO.StringIO()\n  bound_iter = functools.partial(genome_alignment_iterator,\n                                 reference_species=ref_spec)\n  hash_func = JustInTimeGenomeAlignmentBlock.build_hash\n  idx = IndexedFile(maf_strm, bound_iter, hash_func)\n  idx.write_index(idx_strm)\n  idx_strm.seek(0)  # seek to the start\n  return idx_strm"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the name and rssi attributes of this object.", "response": "def update(self, name, rssi):\n        \"\"\"Update the device name and/or RSSI.\n\n        During an ongoing scan, multiple records from the same device can be \n        received during the scan. Each time that happens this method is \n        called to update the :attr:`name` and/or :attr:`rssi` attributes.\n        \"\"\"\n        self.name = name\n        self.rssi = rssi\n        self._age = time.time()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, addr, raw_addr, name=None, rssi=None):\n        if addr in self._devices:\n            # logger.debug('UPDATE scan result: {} / {}'.format(addr, name))\n            self._devices[addr].update(name, rssi)\n            return False\n        else:\n            self._devices[addr] = ScanResult(addr, raw_addr, name, rssi)\n            logger.debug('Scan result: {} / {}'.format(addr, name))\n            return True", "response": "Updates the collection of results with a newly received scan response."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_device(self, addr_or_name):\n        if addr_or_name in self._devices:\n            return self._devices[addr_or_name]\n\n        for v in self._devices.values():\n            if v == addr_or_name:\n                return v\n\n        return None", "response": "Retrieves a device with a given address or name from the results."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_calibration(self, enabled, imus):\n        if len(imus) == 0:\n            imus = list(range(MAX_IMUS))\n\n        for i in imus:\n            if i < 0 or i >= MAX_IMUS:\n                logger.warn('Invalid IMU index {} in set_calibration'.format(i))\n                continue\n            self.imus[i]._use_calibration = enabled", "response": "Set calibration state for attached IMUs."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads the calibration data for this SK8 IMU.", "response": "def load_calibration(self, calibration_file=None):\n        \"\"\"Load calibration data for IMU(s) connected to this SK8.\n\n        This method attempts to load a set of calibration data from a .ini file \n        produced by the sk8_calibration_gui application (TODO link!).\n\n        By default, it will look for a file name \"sk8calib.ini\" in the current working\n        directory. This can be overridden using the `calibration_file` parameter.\n\n        Args:\n            calibration_file (str): Path to a user-specified calibration file (ini format).\n\n        Returns:\n            True if any calibration data was loaded, False if none was. Note that True will be\n            returned even if for example only 1 IMU had any calibration data available.\n        \"\"\"\n        logger.debug('Loading calibration for {}'.format(self.addr))\n        calibration_data = ConfigParser()\n        path = calibration_file or os.path.join(os.getcwd(), 'sk8calib.ini')\n        logger.debug('Attempting to load calibration from {}'.format(path))\n        calibration_data.read(path)\n        success = False\n        for i in range(MAX_IMUS):\n            s = '{}_IMU{}'.format(self.name, i)\n            if s in calibration_data.sections():\n                logger.debug('Calibration data for device {} was detected, extracting...'.format(s))\n                success = success or self.imus[i]._load_calibration(calibration_data[s])\n\n        return success"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndisconnects the dongle from this SK8.", "response": "def disconnect(self):\n        \"\"\"Disconnect the dongle from this SK8.\n\n        Simply closes the active BLE connection to the device represented by the current instance.\n\n        Returns:\n            bool. True if connection was closed, False if not (e.g. if already closed).\n        \"\"\"\n        result = False\n        logger.debug('SK8.disconnect({})'.format(self.conn_handle))\n        if self.conn_handle >= 0:\n            logger.debug('Calling dongle disconnect')\n            result = self.dongle._disconnect(self.conn_handle)\n            self.conn_handle = -1\n            self.packets = 0\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_extana_callback(self, callback, data=None):\n        self.extana_callback = callback\n        self.extana_callback_data = data", "response": "Register a callback for incoming data packets from the SK8 - ExtAna board."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconfigure and enables sensor data streaming from the SK8 - ExtAna device.", "response": "def enable_extana_streaming(self, include_imu=False, enabled_sensors=SENSOR_ALL):\n        \"\"\"Configures and enables sensor data streaming from the SK8-ExtAna device.\n\n        By default this will cause the SK8 to only stream data from the analog \n        sensors on the SK8-ExtAna, but if `include_imu` is set to True, it will \n        also send data from the internal IMU in the SK8. \n\n        NOTE: only one streaming mode can be active at any time, so e.g. if you \n        want to stream IMU data normally, you must disable SK8-ExtAna streaming first. \n\n        Args:\n            include_imu (bool): If False, only SK8-ExtAna packets will be streamed.\n                If True, the device will also stream data from the SK8's internal IMU. \n            enabled_sensors (int): If `include_imu` is True, this can be used to \n                select which IMU sensors will be active. \n\n        Returns:\n            bool. True if successful, False if an error occurred.\n        \"\"\"\n        if not self.dongle._enable_extana_streaming(self, include_imu, enabled_sensors):\n            logger.warn('Failed to enable SK8-ExtAna streaming!')\n            return False\n\n        # have to add IMU #0 to enabled_imus if include_imu is True\n        if include_imu:\n            self.enabled_imus = [0]\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_extana_led(self, cached=True):\n        if cached and self.led_state is not None:\n            return self.led_state\n\n        extana_led = self.get_characteristic_handle_from_uuid(UUID_EXTANA_LED)\n        if extana_led is None:\n            logger.warn('Failed to find handle for ExtAna LED')\n            return None\n\n        rgb = self.dongle._read_attribute(self.conn_handle, extana_led, israw=True)\n        if rgb is None:\n            return rgb\n\n        return list(map(lambda x: int(x * (LED_MAX / INT_LED_MAX)), struct.unpack('<HHH', rgb)))", "response": "Returns the current colour of the ExtAna LED."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_extana_led(self, r, g, b, check_state=True):\n\n        r, g, b = map(int, [r, g, b])\n\n        if min([r, g, b]) < LED_MIN or max([r, g, b]) > LED_MAX:\n            logger.warn('RGB channel values must be {}-{}'.format(LED_MIN, LED_MAX))\n            return False\n\n        if check_state and (r, g, b) == self.led_state:\n            return True\n\n        # internally range is 0-3000\n        ir, ig, ib = map(lambda x: int(x * (INT_LED_MAX / LED_MAX)), [r, g, b])\n        val = struct.pack('<HHH', ir, ig, ib)\n\n        extana_led = self.get_characteristic_handle_from_uuid(UUID_EXTANA_LED)\n        if extana_led is None:\n            logger.warn('Failed to find handle for ExtAna LED')\n            return None\n            \n        if not self.dongle._write_attribute(self.conn_handle, extana_led, val):\n            return False\n\n        # update cached LED state if successful\n        self.led_state = (r, g, b)\n        return True", "response": "Update the colour of the ExtAna LED on the SK8 - ExtAna board."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering a callback for incoming IMU data packets.", "response": "def set_imu_callback(self, callback, data=None):\n        \"\"\"Register a callback for incoming IMU data packets.\n        \n        This method allows you to pass in a callbable which will be called on\n        receipt of each IMU data packet sent by this SK8 device. Set to `None`\n        to disable it again.\n\n        Args:\n            callback: a callable with the following signature:\n                        (acc, gyro, mag, imu_index, seq, timestamp, data)\n                      where:\n                        acc, gyro, mag = sensor data ([x,y,z] in each case)\n                        imu_index = originating IMU number (int, 0-4)\n                        seq = packet sequence number (int, 0-255)\n                        timestamp = value of time.time() when packet received\n                        data = value of `data` parameter passed to this method\n            data: an optional arbitrary object that will be passed as a \n                parameter to the callback\n        \"\"\"\n        self.imu_callback = callback\n        self.imu_callback_data = data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef enable_imu_streaming(self, enabled_imus, enabled_sensors=SENSOR_ALL):\n        imus_enabled = 0\n        for imu in enabled_imus:\n            imus_enabled |= (1 << imu)\n\n        if enabled_sensors == 0:\n            logger.warn('Not enabling IMUs, no sensors enabled!')\n            return False\n\n        if not self.dongle._enable_imu_streaming(self, imus_enabled, enabled_sensors):\n            logger.warn('Failed to enable IMU streaming (imus_enabled={}, enabled_sensors={}'.format(imus_enabled, enabled_sensors))\n            return False\n\n        self.enabled_imus = enabled_imus\n        self.enabled_sensors = enabled_sensors\n        return True", "response": "Configures and enables IMU streaming mode on the given list of IMUs."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndisabling IMU streaming for this device.", "response": "def disable_imu_streaming(self):\n        \"\"\"Disable IMU streaming for this device.\n\n        Returns:\n            True on success, False if an error occurred.\n        \"\"\"\n        self.enabled_imus = []\n        # reset IMU data state\n        for imu in self.imus:\n            imu.reset()\n        return self.dongle._disable_imu_streaming(self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading the battery level descriptor on the device.", "response": "def get_battery_level(self):\n        \"\"\"Reads the battery level descriptor on the device.\n\n        Returns:\n            int. If successful this will be a positive value representing the current \n            battery level as a percentage. On error, -1 is returned. \n        \"\"\"\n\n        battery_level = self.get_characteristic_handle_from_uuid(UUID_BATTERY_LEVEL)\n        if battery_level is None:\n            logger.warn('Failed to find handle for battery level')\n            return None\n\n        level = self.dongle._read_attribute(self.conn_handle, battery_level)\n        if level is None:\n            return -1\n        return ord(level)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_device_name(self, cached=True):\n        if cached and self.name is not None:\n            return self.name\n\n        device_name = self.get_characteristic_handle_from_uuid(UUID_DEVICE_NAME)\n        if device_name is None:\n            logger.warn('Failed to find handle for device name')\n            return None\n\n        self.name = self.dongle._read_attribute(self.conn_handle, device_name)\n        return self.name", "response": "Returns the SK8 device BLE name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_device_name(self, new_name):\n\n        device_name = self.get_characteristic_handle_from_uuid(UUID_DEVICE_NAME)\n        if device_name is None:\n            logger.warn('Failed to find handle for device name')\n            return False\n        \n        if len(new_name) > MAX_DEVICE_NAME_LEN:\n            logger.error('Device name exceeds maximum length ({} > {})'.format(len(new_name), MAX_DEVICE_NAME_LEN))\n            return False\n\n        if self.dongle._write_attribute(self.conn_handle, device_name, new_name.encode('ascii')):\n            self.name = new_name\n            return True\n\n        return False", "response": "Sets the name of the SK8."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_firmware_version(self, cached=True):\n        if cached and self.firmware_version != 'unknown':\n            return self.firmware_version\n\n        firmware_version = self.get_characteristic_handle_from_uuid(UUID_FIRMWARE_REVISION)\n        if firmware_version is None:\n            logger.warn('Failed to find handle for firmware version')\n            return None\n\n        self.firmware_version = self.dongle._read_attribute(self.conn_handle, firmware_version)\n        return self.firmware_version", "response": "Returns the SK8 device firmware version."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef has_extana(self, cached=True):\n        if cached and self.hardware != -1:\n            return True if (self.hardware & EXT_HW_EXTANA) else False\n\n        result = self._check_hardware()\n        return True if (result & EXT_HW_EXTANA) != 0 else False", "response": "Check if an SK8 - ExtAna device is currently connected."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef has_imus(self, cached=True):\n        if cached and self.hardware != -1:\n            return True if (self.hardware & EXT_HW_IMUS) else False\n\n        result = self._check_hardware()\n        return True if (result & EXT_HW_IMUS) != 0 else False", "response": "Returns True if the SK8 has an external IMU chain attached."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_characteristic_handle_from_uuid(self, uuid):\n        ch = self.get_characteristic_from_uuid(uuid)\n        return None if ch is None else ch.char_handle", "response": "Given a characteristic UUID return its handle."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_characteristic_from_uuid(self, uuid):\n\n        if uuid in self.uuid_chars:\n            logger.debug('Returning cached info for char: {}'.format(uuid))\n            return self.uuid_chars[uuid]\n\n        for service in self.services.values():\n            char = service.get_characteristic_by_uuid(uuid)\n            if char is not None:\n                self.uuid_chars[uuid] = char\n                logger.debug('Found char for UUID: {}'.format(uuid))\n                return char\n\n        logger.info('Failed to find char for UUID: {}'.format(uuid))\n        return None", "response": "Given a characteristic UUID return a : class:`Characteristic object containing information about that characteristic."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_ccc_handle_from_uuid(self, uuid):\n\n        if uuid in self.uuid_cccds:\n            return self.uuid_cccds[uuid].handle\n        \n        char = self.get_characteristic_from_uuid(uuid)\n        if char is None:\n            return None\n\n        ccc = char.get_descriptor_by_uuid(UUID_GATT_CCC)\n        if ccc is not None:\n            self.uuid_cccds[uuid] = ccc\n        return None if ccc is None else ccc.handle", "response": "Utility function to retrieve the client characteristic configuration and descriptor handle for a given UUID."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a Service object for the given UUID.", "response": "def get_service(self, uuid):\n        \"\"\"Lookup information about a given GATT service.\n\n        Args:\n            uuid (str): a string containing the hex-encoded service UUID\n\n        Returns:\n            None if an error occurs, otherwise a :class:`Service` object.\n        \"\"\"\n        if uuid in self.services:\n            return self.services[uuid]\n\n        if pp_hex(uuid) in self.services:\n            return self.services[pp_hex(uuid)]\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_service_for_handle(self, handle):\n        for s in self.services.values():\n            if s.start_handle <= handle and s.end_handle >= handle:\n                return s\n\n        return None", "response": "Given a characteristic handle return the Service object that matches the given handle."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the current polling override value in milliseconds.", "response": "def get_polling_override(self):\n        \"\"\"Get the current polling override value in milliseconds. \n\n        See :meth:`set_polling_override` for more information. \n\n        Returns:\n            None on error, otherwise the current override period in milliseconds \n            (0 = disabled). \n        \"\"\"\n        polling_override = self.get_characteristic_handle_from_uuid(UUID_POLLING_OVERRIDE)\n        if polling_override is None:\n            logger.warn('Failed to find handle for polling override')\n            return None\n        override_ms = self.dongle._read_attribute(self.conn_handle, polling_override, True)\n        return None if override_ms is None else ord(override_ms)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the polling timer override value in milliseconds.", "response": "def set_polling_override(self, override):\n        \"\"\"Set the sensor polling timer override value in milliseconds. \n\n        Due to the time it takes to poll all the sensors on up to 5 IMUs, it's not \n        possible for the SK8 firmware to define a single fixed rate for reading \n        new samples without it being artificially low for most configurations. \n        \n        Instead the firmware tries to define a sensible default value for each \n        combination of IMUs and sensors that can be enabled (any combination of \n        1-5 IMUs and 1-3 sensors on each IMU). In most cases this should work well,\n        but for example if you have multiple SK8s connected through the same dongle\n        and have multiple IMUs enabled on each, you may find packets start to be\n        dropped quite frequently. \n\n        To mitigate this, you can adjust the period of the timer used by the firmware\n        to poll for new sensor data (and send data packets to the host device). The\n        value should be in integer milliseconds, and have a minimum value of 20. Values\n        below 20 will be treated as a request to disable the override and return to the\n        default polling period. \n\n        The method can be called before or after streaming is activated, and will take\n        effect immediately. \n\n        NOTE1: the value is stored in RAM and will not persist across reboots, although\n            it should persist for multiple connections.\n        NOTE2: once set, the override applies to ALL sensor configurations, so for \n            example if you set it while using 5 IMUs on 2 SK8s, then switch to using \n            1 IMU on each SK8, you will probably want to disable it again as the \n            latter configuration should work fine with the default period.\n\n        Args:\n            override (int): polling timer override period in milliseconds. Values\n                below 20 are treated as 0, and have the effect of disabling the\n                override in favour of the default periods. \n\n        Returns:\n            True on success, False on error.\n        \"\"\"\n        polling_override = self.get_characteristic_handle_from_uuid(UUID_POLLING_OVERRIDE)\n        if polling_override is None:\n            logger.warn('Failed to find handle for device name')\n            return False\n        \n        if self.dongle._write_attribute(self.conn_handle, polling_override, struct.pack('B', override)):\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef init(self, address, hard_reset=False):\n        self.address = address\n\n        if hard_reset:\n            # TODO (needs more work to be usable)\n            # if not Dongle._hard_reset(address):\n            #     return False\n            # time.sleep(2.0)\n            pass\n\n        # TODO timeout not working if opened on valid, non Bluegiga port\n        for i in range(Dongle.PORT_RETRIES):\n            try:\n                logger.debug('Setting up BGAPI, attempt {}/{}'.format(i + 1, Dongle.PORT_RETRIES))\n                self.api = BlueGigaAPI(port=self.address, callbacks=self, baud=Dongle.BAUDRATE, timeout=DEF_TIMEOUT)\n                self.api.start_daemon()\n                break\n            except serial.serialutil.SerialException as e:\n                logger.debug('Failed to init BlueGigaAPI: {}, attempt {}/{}'.format(e, i + 1, Dongle.PORT_RETRIES))\n                time.sleep(0.1)\n\n        if self.api is None:\n            return False\n\n        time.sleep(0.5) # TODO\n        self.get_supported_connections()\n        logger.info('Dongle supports {} connections'.format(self.supported_connections))\n        if self.supported_connections == -1:\n            logger.error('Failed to retrieve number of supported connections from the dongle! (try reinserting it)')\n            return False\n        \n        self.conn_state = {x: self._STATE_IDLE for x in range(self.supported_connections)}\n        self.reset()\n\n        self._cbthread = threading.Thread(target=self._cbthreadfunc)\n        self._cbthread.setDaemon(True)\n        self._cbthread_q = Queue()\n        self._cbthread.start()\n        return True", "response": "Open a connection to a BLED112 dongle at the supplied address."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_dongle_port():\n        logger.debug('Attempting to find Bluegiga dongle...')\n        # TODO this will probably only work on Windows at the moment\n        ports = list(serial.tools.list_ports.grep('Bluegiga'))\n        if len(ports) == 0:\n            logger.debug('No Bluegiga-named serial ports discovered')\n            return None\n\n        # just return the first port even if multiple dongles\n        logger.debug('Found \"Bluegiga\" serial port at {}'.format(ports[0].device))\n        return ports[0].device", "response": "Convenience method which attempts to find the port where a BLED112 dongle is connected."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reset(self):\n        logger.debug('resetting dongle state')\n\n        self._clear()\n\n        if self.api is not None:\n            self._set_state(Dongle._STATE_RESET)\n            self.api.ble_cmd_gap_set_mode(gap_discoverable_mode['gap_non_discoverable'], gap_connectable_mode['gap_non_connectable'])\n            self._wait_for_state(self._STATE_RESET)\n\n            for i in range(self.supported_connections):\n                self._set_conn_state(i, self._STATE_DISCONNECTING)\n                self.api.ble_cmd_connection_disconnect(i)\t\n                self._wait_for_conn_state(i, self._STATE_DISCONNECTING)\n\n        logger.debug('reset completed')", "response": "Reset the internal state of the object and disconnect any active connections."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef close(self):\n        logger.debug('closing dongle, {} active connections'.format(len(self.conn_handles)))\n        if self.is_scanning():\n            logger.debug('in scanning mode, calling end_scan')\n            self.end_scan()\n        self.reset()\n        if self.api is not None:\n            self.api.stop_daemon()\n            self.api = None", "response": "Closes the connection to the dongle."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _discover_services(self, sk8):\n\n        ts = time.time()\n\n        # start by discovering primary service UUIDs\n        # params to ble_cmd_attclient_read_by_group_type are:\n        #   conn_handle, start handle, end handle, UUID identifier to match (little endian)\n        self._set_conn_state(sk8.conn_handle, self._STATE_DISCOVER_SERVICES)\n        self.api.ble_cmd_attclient_read_by_group_type(sk8.conn_handle, 0x0001, 0xFFFF, RAW_UUID_GATT_PRIMARY_SERVICE)\n        self._wait_for_conn_state(sk8.conn_handle, self._STATE_DISCOVER_SERVICES)\n        logger.debug('Service discovery took: {:.3f}s'.format(time.time() - ts))\n\n        logger.debug('Found {} primary services'.format(sk8.services))\n\n        # now discover characteristics and descriptors within each service\n        tc = time.time()\n        for service in sk8.services.values():\n            self._set_conn_state(sk8.conn_handle, self._STATE_DISCOVER_CHARS)\n            self.api.ble_cmd_attclient_read_by_type(sk8.conn_handle, service.start_handle, service.end_handle, RAW_UUID_GATT_CHAR_DECL)\n            self._wait_for_conn_state(sk8.conn_handle, self._STATE_DISCOVER_CHARS)\n\n            self._set_conn_state(sk8.conn_handle, self._STATE_DISCOVER_DESCS)\n            self.api.ble_cmd_attclient_find_information(sk8.conn_handle, service.start_handle, service.end_handle)\n            self._wait_for_conn_state(sk8.conn_handle, self._STATE_DISCOVER_DESCS)\n\n        logger.debug('Characteristic discovery took: {:.3f}s'.format(time.time() - tc))\n\n        return True", "response": "This function is called by BLE to discover the primary services and characteristics and descriptors."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the behaviour of the automatic reconnect feature.", "response": "def set_reconnect_parameters(self, interval, attempts, restore_state=True):\n        \"\"\"Sets the behaviour of the automatic reconnect feature. \n\n        When a connected SK8 is disconnected unexpectedly (in other words not by a \n        user-triggered action), an automatic attempt to reconnect to the device\n        can be made. If successful this will typically resume the connection with\n        an interruption of only a few seconds. \n\n        This method allows the application to configure some aspects of the automatic\n        reconnect functionality.\n\n        Args:\n            interval (float): time in seconds between successive attempts to reconnect. \n                Also applies to the delay between the initial disconnection and the first\n                attempt to reconnect.\n            attempts (int): the number of attempts to make to recreate the connection. This\n                can be set to zero in order to disable the reconnection feature.\n            restore_state (bool): if True, the streaming state of the device will also be\n                restored if possible. For example, the IMU configuration will be re-applied\n                after the reconnection attempt succeeds, to return the SK8 to the same\n                state it was in before the disconnection occurred.\n\n        Returns: \n            None\n        \"\"\"\n        self._reconnect_attempts = max(0, attempts)\n        self._reconnect_interval = max(0, interval)\n        self._reconnect_restore_state = restore_state"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef scan_and_connect(self, devnames, timeout=DEF_TIMEOUT, calibration=True):\n        responses = self.scan_devices(devnames, timeout)\n\n        for dev in devnames:\n            if dev not in responses:\n                logger.error('Failed to find device {} during scan'.format(dev))\n                return (False, [])\n\n        return self.connect([responses.get_device(dev) for dev in devnames], calibration)", "response": "Scan for and then connect to one or more SK8s."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef begin_scan(self, callback=None, interval=DEF_SCAN_INTERVAL, window=DEF_SCAN_WINDOW):\n\n        # TODO validate params and current state\n        logger.debug('configuring scan parameters') \n        self.api.ble_cmd_gap_set_scan_parameters(interval, window, 1)\n        self._set_state(self._STATE_CONFIGURE_SCAN)\n        self.api.ble_cmd_gap_discover(1) # any discoverable devices\n        self._wait_for_state(self._STATE_CONFIGURE_SCAN)\n        # TODO check state\n\n        logger.debug('starting async scan for devices')\n        self.scan_targets = None\n        self.scan_callback = callback\n        self._set_state(self._STATE_SCANNING)\n        return True", "response": "Starts a BLE scan and returns immediately."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nend an ongoing BLE scan.", "response": "def end_scan(self):\n        \"\"\"Ends an ongoing BLE scan started by :meth:`begin_scan`.\n\n        Returns:\n            a :class:`ScanResults` object containing the scan results.\n        \"\"\"\n        # TODO check states before/after\n        self._set_state(self._STATE_GAP_END)\n        self.api.ble_cmd_gap_end_procedure()\n        self._wait_for_state(self._STATE_GAP_END)\n\n        logger.debug('scanning completed')\n        return self.scan_responses"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scan_devices(self, devnames, timeout=DEF_TIMEOUT, interval=DEF_SCAN_INTERVAL, window=DEF_SCAN_WINDOW):\n\n        # TODO validate params and state\n        logger.debug('configuring scan parameters') \n        self.api.ble_cmd_gap_set_scan_parameters(interval, window, 1)\n        self._set_state(self._STATE_CONFIGURE_SCAN)\n        self.api.ble_cmd_gap_discover(1) # any discoverable devices\n        self._wait_for_state(self._STATE_CONFIGURE_SCAN)\n\n        logger.debug('starting scan for devices {}'.format(devnames))\n        self.scan_targets = devnames\n        self._set_state(self._STATE_SCANNING)\n        self._wait_for_state(self._STATE_SCANNING, timeout)\n\n        self._set_state(self._STATE_GAP_END)\n        self.api.ble_cmd_gap_end_procedure()\n        self._wait_for_state(self._STATE_GAP_END)\n\n        logger.debug('scanning completed')\n\n        return self.scan_responses", "response": "Run a BLE scan for a set of devices."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nestablishes a connection to one or more SK8 devices.", "response": "def connect(self, devicelist, calibration=True):\n        \"\"\"Establish a connection to one or more SK8 devices.\n\n        Given a list of 1 or more :class:`ScanResult` objects, this method will attempt\n        to create a connection to each SK8 in sequence. It will return when\n        all connections have been attempted, although they may not all have succeeded. In\n        addition, the dongle has a limit on simultaneous connections, which you can\n        retrieve by calling :meth:`get_supported_connections`. If the number of \n        supplied device names exceeds this value then the method will abort \n        immediately. \n\n        Args:\n            devicelist (list): a list of :class:`ScanResult` instances, one for each\n                SK8 you wish to create a connection to. \n            calibration (bool): True if calibration data should be loaded post-connection,\n                for each device (if available).\n\n        Returns:\n            tuple (`result`, `devices`), where `result` is a bool indicating if \n            connections were successfully made to all given devices. If True, \n            `devices` will contain a list of :class:`SK8` instances representing\n            the connected SK8 devices. If False, `devices` will contain a smaller\n            number of :class:`SK8` instances depending on the number of connections\n            that succeeded (possibly 0). \n        \"\"\"\n        if not isinstance(devicelist, list):\n            devicelist = [devicelist]\n\n        logger.debug('Connecting to {} devices'.format(len(devicelist)))\n        if len(devicelist) > self.supported_connections:\n            logging.error('Dongle firmware supports max {} connections, {} device connections requested!'.format(self.supported_connections, len(devicelist)))\n            return (False, [])\n\n        # TODO check number of active connections and fail if exceeds max\n\n        connected_devices = []\n        all_connected = True\n        for dev in devicelist:\n            logger.info('Connecting to {} (name={})...'.format(dev.addr, dev.name))\n            self._set_state(self._STATE_CONNECTING)\n            self.api.ble_cmd_gap_connect_direct(dev.raw_addr, 0, 6, 14, 100, 50)\n            self._wait_for_state(self._STATE_CONNECTING, 5)\n\n            if self.state != self._STATE_CONNECTED:\n                logger.warn('Connection failed!')\n                # send end procedure to cancel connection attempt\n                self._set_state(self._STATE_GAP_END)\n                self.api.ble_cmd_gap_end_procedure()\n                self._wait_for_state(self._STATE_GAP_END)\n                all_connected = False\n                continue\n\n            conn_handle = self.conn_handles[-1]\n            logger.info('Connection OK, handle is 0x{:02X}'.format(conn_handle))\n            sk8 = SK8(self, conn_handle, dev, calibration)\n            self._add_device(sk8)\n            connected_devices.append(sk8)\n            sk8._discover_services()\n\n            time.sleep(0.1) # TODO\n        return (all_connected, connected_devices)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nestablishing a connection to a single SK8.", "response": "def connect_direct(self, device, calibration=True):\n        \"\"\"Establish a connection to a single SK8.\n\n        Args:\n            device: either a :class:`ScanResult` or a plain hardware address string\n                in xx:xx:xx:xx:xx:xx format.\n            calibration (bool): True to attempt to load calibration data for this\n                device after connection, False otherwise. See :meth:`SK8.load_calibration`.\n\n        Returns:\n            tuple (`result`, `device`), where `result` is a bool indicating if a \n            connection was created successfully. If `result` is True, `device` will\n            be set to a new :class:`SK8` instance. Otherwise it will be None.\n        \"\"\"\n\n        # convert string address into a ScanResult if needed\n        if not isinstance(device, ScanResult):\n            if isinstance(device, str):\n                device = ScanResult(device, fmt_addr_raw(device))\n            elif isinstance(device, unicode):\n                device = device.encode('ascii')\n                device = ScanResult(device, fmt_addr_raw(device))\n            else:\n                logger.warn('Expected ScanResult, found type {} instead!'.format(type(device)))\n                return (False, None)\n\n        logger.debug('Connecting directly to device address'.format(device.addr))\n        # TODO check number of active connections and fail if exceeds max\n        self._set_state(self._STATE_CONNECTING)\n\n        # TODO parameters here = ???\n        self.api.ble_cmd_gap_connect_direct(device.raw_addr, 0, 6, 14, 100, 50)\n        self._wait_for_state(self._STATE_CONNECTING, 5)\n\n        if self.state != self._STATE_CONNECTED:\n            logger.warn('Connection failed!')\n            # send end procedure to cancel connection attempt\n            self._set_state(self._STATE_GAP_END)\n            self.api.ble_cmd_gap_end_procedure()\n            self._wait_for_state(self._STATE_GAP_END)\n            return (False, None)\n\n        conn_handle = self.conn_handles[-1]\n        logger.info('Connection OK, handle is 0x{:02X}'.format(conn_handle))\n        sk8 = SK8(self, conn_handle, device, calibration)\n        self._add_device(sk8)\n        sk8._discover_services()\n\n        return (True, sk8)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_supported_connections(self):\n        if self.supported_connections != -1:\n            return self.supported_connections\n        \n        if self.api is None:\n            return -1\n\n        self._set_state(self._STATE_DONGLE_COMMAND)\n        self.api.ble_cmd_system_get_connections()\n        self._wait_for_state(self._STATE_DONGLE_COMMAND)\n        \n        return self.supported_connections", "response": "Returns the number of simultaneous BLE connections."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef httpapi_request(client, **params) -> 'Response':\n    return requests.get(\n        _HTTPAPI,\n        params={\n            'client': client.name,\n            'clientver': client.version,\n            'protover': 1,\n            **params\n        })", "response": "Send a request to AniDB HTTP API."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unpack_xml(text) -> ET.ElementTree:\n    etree: ET.ElementTree = ET.parse(io.StringIO(text))\n    _check_for_errors(etree)\n    return etree", "response": "Unpack an XML string from AniDB API."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _check_for_errors(etree: ET.ElementTree):\n    if etree.getroot().tag == 'error':\n        raise APIError(etree.getroot().text)", "response": "Check AniDB response XML tree for errors."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns generator of fields matching searches.", "response": "def extract_fields(lines, delim, searches, match_lineno=1, **kwargs):\n    \"\"\"Return generator of fields matching `searches`.\n\n    Parameters\n    ----------\n    lines : iterable\n        Provides line number (1-based) and line (str)\n    delim : str\n        Delimiter to split line by to produce fields\n    searches : iterable\n        Returns search (str) to match against line fields.\n    match_lineno : int\n        Line number of line to split and search fields\n\n    Remaining keyword arguments are passed to `match_fields`.\n    \"\"\"\n    keep_idx = []\n    for lineno, line in lines:\n        if lineno < match_lineno or delim not in line:\n            if lineno == match_lineno:\n                raise WcutError('Delimter not found in line {}'.format(\n                    match_lineno))\n            yield [line]\n            continue\n\n        fields = line.split(delim)\n        if lineno == match_lineno:\n            keep_idx = list(match_fields(fields, searches, **kwargs))\n        keep_fields = [fields[i] for i in keep_idx]\n\n        if keep_fields:\n            yield keep_fields"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef match_fields(fields, searches,\n                 ignore_case=False, wholename=False, complement=False):\n    \"\"\"Return fields that match searches.\n\n    Parameters\n    ----------\n    fields : iterable\n    searches : iterable\n    ignore_case, wholename, complement : boolean\n    \"\"\"\n    if ignore_case:\n        fields = [f.lower() for f in fields]\n        searches = [s.lower() for s in searches]\n    if wholename:\n        match_found = _complete_match\n    else:\n        match_found = _partial_match\n\n    fields = [(i, field) for i, field in enumerate(fields)]\n    matched = []\n    for search, (idx, field) in itertools.product(searches, fields):\n        if not search:  ## don't return all fields for ''\n            continue\n        if match_found(search, field) and idx not in matched:\n            matched.append(idx)\n\n    if complement:\n        matched = [idx for idx in list(zip(*fields))[0] if idx not in matched]\n\n    return matched", "response": "Return fields that match searches."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new connection to the SQLite3 database.", "response": "def connect(cls, dbname):\n        \"\"\"Create a new connection to the SQLite3 database.\n\n        :param dbname: The database name\n        :type dbname: str\n        \n        \"\"\"\n        test_times_schema = \"\"\"\n        CREATE TABLE IF NOT EXISTS test_times (\n          file text,\n          module text,\n          class text,\n          func text,\n          elapsed float\n        )\n        \"\"\"\n        \n        setup_times_schema = \"\"\"\n        CREATE TABLE IF NOT EXISTS setup_times (\n          file text,\n          module text,\n          class text,\n          func text,\n          elapsed float\n        )\n        \"\"\"\n        \n        schemas = [test_times_schema,\n                   setup_times_schema]\n        \n        db_file = '{}.db'.format(dbname)\n                \n        cls.connection = sqlite3.connect(db_file)\n        for s in schemas:\n            cls.connection.execute(s)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the singleton connection to the SQLite3 database.", "response": "def get(cls, dbname=\"perfdump\"):\n        \"\"\"Returns the singleton connection to the SQLite3 database.\n\n        :param dbname: The database name\n        :type dbname: str\n        \n        \"\"\"\n        try:\n            return cls.connection\n        except:\n            cls.connect(dbname)\n            return cls.connection"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprepares a fresh environment for each scenario.", "response": "def before_scenario(context, scenario):\n    \"\"\"Prepare a fresh environment for each scenario.\"\"\"\n\n    # Prepare a new temporary directory.\n    context.directory = testfixtures.TempDirectory(create=True)\n    context.old_cwd = os.getcwd()\n    context.new_cwd = context.directory.path\n\n    # Move into our new working directory.\n    os.chdir(context.new_cwd)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef after_scenario(context, scenario):\n\n    # Move back into the original working directory.\n    os.chdir(context.old_cwd)\n\n    # Delete all content generated by the test.\n    context.directory.cleanup()", "response": "Leave the environment fresh after each scenario."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a parameter object by name.", "response": "def get(self, name):\n        \"\"\"Get a parameter object by name.\n\n        :param name: Name of the parameter object.\n        :type name: str\n\n        :return: The parameter.\n        :rtype: Parameter\n        \"\"\"\n        parameter = next((p for p in self.parameters if p.name == name), None)\n        if parameter is None:\n            raise LookupError(\"Cannot find parameter '\" + name + \"'.\")\n        return parameter"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a parameter to the parameter list.", "response": "def add_parameter(self, name, value, meta=None):\n        \"\"\"Add a parameter to the parameter list.\n\n        :param name: New parameter's name.\n        :type name: str\n\n        :param value: New parameter's value.\n        :type value: float\n\n        :param meta: New parameter's meta property.\n        :type meta: dict\n        \"\"\"\n        parameter = Parameter(name, value)\n        if meta: parameter.meta = meta\n        self.parameters.append(parameter)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_file(self, path):\n        data = yaml.load(open(path, 'r'))\n        for key in self.property_keys:\n            if key in data: setattr(self, key, data[key])\n        self.parameters = self.parameter_list(data['parameters'])", "response": "Load a YAML file with parameter data and other metadata."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a list of Parameter objects from a dictionary.", "response": "def parameter_list(data):\n        \"\"\"Create a list of parameter objects from a dict.\n\n        :param data: Dictionary to convert to parameter list.\n        :type data: dict\n\n        :return: Parameter list.\n        :rtype: dict\n        \"\"\"\n        items = []\n        for item in data:\n            param = Parameter(item['name'], item['value'])\n            if 'meta' in item: param.meta = item['meta']\n            items.append(param)\n        return items"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_blueprint(self, blueprint, **options):\n        instance = werkzeug.utils.import_string(blueprint)\n        self._blueprints.append((instance, options))", "response": "Adds a blueprint to the blueprints list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_extension(self, extension):\n        instance = werkzeug.utils.import_string(extension)\n\n        if hasattr(instance, 'register'):\n            instance.register(self)\n\n        self._extensions.append(instance)", "response": "Adds a broadway extension to initialise\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main():\n    parser = OptionParser()\n    parser.add_option(\n        '-c', '--config',\n        help='configuration file',\n        dest='filename',\n        type='str',\n        default='/etc/sachannelupdate/sachannelupdate.ini')\n    parser.add_option(\n        '-d', '--delete',\n        help='Deletes existing rules',\n        dest='cleanup',\n        action=\"store_true\",\n        default=False,)\n    options, _ = parser.parse_args()\n    if not os.path.isfile(options.filename):\n        raise SaChannelUpdateConfigError(\n            \"The configuration file: %s does not exist\" % options.filename)\n\n    config = ConfigParser()\n    config.read(options.filename)\n    try:\n        # pylint: disable=protected-access\n        entry(config._sections['settings'], options.cleanup)\n    except BaseException as msg:\n        error(msg)", "response": "Main function of the sachannelupdate command line interface."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef newkeys(nbits=1024):\n        pubkey, privkey = rsa.newkeys(nbits, poolsize=1)\n        return pubkey, privkey", "response": "Create a new pair of public and private key pairs to use."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nencrypts binary data. **\u4e2d\u6587\u6587\u6863** - \u53d1\u9001\u6d88\u606f\u65f6\u53ea\u9700\u8981\u5bf9\u65b9\u7684pubkey - \u5982\u9700\u4f7f\u7528\u7b7e\u540d, \u5219\u53cc\u65b9\u90fd\u9700\u8981\u6301\u6709\u5bf9\u65b9\u7684pubkey", "response": "def encrypt(self, binary, use_sign=True):\n        \"\"\"\n        Encrypt binary data.\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        - \u53d1\u9001\u6d88\u606f\u65f6\u53ea\u9700\u8981\u5bf9\u65b9\u7684pubkey\n        - \u5982\u9700\u4f7f\u7528\u7b7e\u540d, \u5219\u53cc\u65b9\u90fd\u9700\u8981\u6301\u6709\u5bf9\u65b9\u7684pubkey\n        \"\"\"\n        token = rsa.encrypt(binary, self.his_pubkey)  # encrypt it\n        if use_sign:\n            self.sign = rsa.sign(binary, self.my_privkey, \"SHA-1\")  # sign it\n        return token"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nencrypt a file using RSA for big file encryption.", "response": "def encrypt_file(self,\n                     path,\n                     output_path=None,\n                     overwrite=False,\n                     enable_verbose=True):\n        \"\"\"\n        Encrypt a file using rsa.\n\n        RSA for big file encryption is very slow. For big file, I recommend\n        to use symmetric encryption and use RSA to encrypt the password.\n        \"\"\"\n        path, output_path = files.process_dst_overwrite_args(\n            src=path, dst=output_path, overwrite=overwrite,\n            src_to_dst_func=files.get_encrpyted_path,\n        )\n\n        with open(path, \"rb\") as infile, open(output_path, \"wb\") as outfile:\n            encrypt_bigfile(infile, outfile, self.his_pubkey)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef print_subcommands(self):\n        lines = [\"Call\"]\n        lines.append('-'*len(lines[-1]))\n        lines.append('')\n        lines.append(\"> jhubctl <subcommand> <resource-type> <resource-name>\")\n        lines.append('')\n        lines.append(\"Subcommands\")\n        lines.append('-'*len(lines[-1]))\n        lines.append('')\n\n        for name, subcommand in self.subcommands.items():\n            lines.append(name)\n            lines.append(indent(subcommand[1]))\n\n        lines.append('')\n        print(os.linesep.join(lines))", "response": "Print the subcommand part of the help."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the jhubctl command line arguments.", "response": "def parse_command_line(self, argv=None):\n        \"\"\"Parse the jhubctl command line arguments.\n        \n        This overwrites traitlets' default `parse_command_line` method\n        and tailors it to jhubctl's needs.\n        \"\"\"\n        argv = sys.argv[1:] if argv is None else argv\n        self.argv = [py3compat.cast_unicode(arg) for arg in argv]\n\n        # Append Provider Class to the list of configurable items.\n        ProviderClass = getattr(providers, self.provider_type)\n        self.classes.append(ProviderClass)\n\n        if any(x in self.argv for x in ('-h', '--help-all', '--help')):\n            self.print_help('--help-all' in self.argv)\n            self.exit(0)\n\n        if '--version' in self.argv or '-V' in self.argv:\n            self.print_version()\n            self.exit(0)\n\n        # Generate a configuration file if flag is given.\n        if '--generate-config' in self.argv:\n            conf = self.generate_config_file()\n            with open(self.config_file, 'w') as f:\n                f.write(conf)\n            self.exit(0)\n\n        # If not config, parse commands.\n        ## Run sanity checks.\n        # Check that the minimum number of arguments have been called.\n        if len(self.argv) < 2:\n            raise JhubctlError(\n                \"Not enough arguments. \\n\\n\"\n                \"Expected: jhubctl <action> <resource> <name>\")\n\n        # Check action\n        self.resource_action = self.argv[0]\n        if self.resource_action not in self.subcommands:\n            raise JhubctlError(\n                f\"Subcommand is not recognized; must be one of these: {self.subcommands}\")\n\n        # Check resource\n        self.resource_type = self.argv[1]\n        if self.resource_type not in self.resources:\n            raise JhubctlError(\n                f\"First argument after a subcommand must one of these\"\n                f\"resources: {self.resources}\"\n            )\n\n        # Get name of resource.\n        try:\n            self.resource_name = self.argv[2]\n        except IndexError:\n            if self.resource_action != \"get\":\n                raise JhubctlError(\n                    \"Not enough arguments. \\n\\n\"\n                    \"Expected: jhubctl <action> <resource> <name>\")\n            else:\n                self.resource_name = None\n\n        # flatten flags&aliases, so cl-args get appropriate priority:\n        flags, aliases = self.flatten_flags()\n        loader = KVArgParseConfigLoader(argv=argv, aliases=aliases,\n                                        flags=flags, log=self.log)\n        config = loader.load_config()\n        self.update_config(config)\n        # store unparsed args in extra_args\n        self.extra_args = loader.extra_args"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the object variables.", "response": "def initialize(self, argv=None):\n        \"\"\"Handle specific configurations.\"\"\"\n        # Parse configuration items on command line.\n        self.parse_command_line(argv)\n        if self.config_file:\n            self.load_config_file(self.config_file)\n\n        # Initialize objects to interact with.\n        self.kubeconf = KubeConf()\n        self.cluster_list = ClusterList(kubeconf=self.kubeconf)\n        self.hub_list = HubList(kubeconf=self.kubeconf)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start(self):\n        # Get specified resource.\n        resource_list = getattr(self, f'{self.resource_type}_list')\n        resource_action = getattr(resource_list, self.resource_action)\n        resource_action(self.resource_name)", "response": "Starts execution happening on jhubctl."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_result(self):\n\n        timeout = 60\n        if self.method == \"GET\":\n            timeout = 360\n\n        headers = {\n            \"Authorization\": \"Bearer \" + self.key,\n            \"content-type\": \"application/json\"\n        }\n        response = None\n        try:\n            response = getattr(requests, self.method.lower())(\n                self.url,\n                headers=headers,\n                params=self.data,\n                data=self.data,\n                timeout=timeout,\n            )\n            # Return the response.\n            return response\n        except requests.exceptions.RequestException:\n            error = {\n                \"objeto\": \"error\",\n                \"tipo\": \"error_api\",\n                \"codigo_error\": \"404\",\n                \"mensaje\": \"conexion...\",\n                \"mensaje_usuario\": \"\u00a1Error de conexion!\",\n            }\n            return error", "response": "Returns an http response object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_children(self, children):\n\n        self._children += [c for c in children if c not in self._children]", "response": "Adds new children nodes after filtering for duplicates\n           "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding new parent nodes after filtering for duplicates", "response": "def add_parents(self, parents):\n        \"\"\"Adds new parent nodes after filtering for duplicates\n\n        Args:\n            parents (list): list of OmniTree nodes to add as parents\n        \"\"\"\n\n        self._parents += [p for p in parents if p not in self._parents]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_loops(self, _path=None):\n\n        if _path is None:\n            _path = []\n\n        if self in _path:\n            return _path + [self]\n        elif self._children == []:\n            return None\n        else:\n            for child in self._children:\n                return child.find_loops(_path + [self])", "response": "Crappy function that finds a single loop in the tree"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_branches(self, labels=False, unique=False):\n\n        branches = []\n\n        # Assign proper item, pointer or label, to return\n        if labels is True:\n            identifier = [self.label]\n        else:\n            identifier = [self]\n\n        if self._children == []:  # Base Case: current node is a leaf/end node\n            return identifier\n\n        else:  # Recursive Case: all other nodes\n            for child in self._children:\n                if unique is True:\n                    for branch in child.find_branches(labels=labels,\n                                                      unique=True):\n                        # I don't know why this 'if' is necessary, but it is\n                        if type(branch) is not list:\n                            branch = list(branch)\n                        branches.append(identifier + branch)\n                else:\n                    branches.append(child.find_branches(labels=labels))\n\n            # Proper construction of list depends on 'unique'\n            if unique is True:\n                return branches\n            else:\n                return identifier + branches", "response": "Recursively finds the branches of the tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef stop_other_daemons(self):\n        if self.smbd.running:\n            self.smbd.stop()\n\n        if self.nmbd.running:\n            self.nmbd.stop()", "response": "Stop services already provided by main samba daemons"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking that all necessary values for the package to be used have been provided.", "response": "def check(cls):\n        \"\"\"\n        Verifies that all necessary values for the package to be used have been provided\n\n        :raises: `elib_config._exc.IncompleteSetupError`\n        \"\"\"\n        attribs = [\n            'app_version',\n            'app_name',\n            'config_file_path',\n            'config_sep_str',\n        ]\n        for attrib in attribs:\n            if getattr(cls, attrib) == 'not_set':\n                raise IncompleteSetupError(f'elib_config setup is incomplete; missing: {attrib}')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting up the elib_config in one fell swoop.", "response": "def setup(\n            cls,\n            app_version: str,\n            app_name: str,\n            config_file_path: str,\n            config_sep_str: str,\n            root_path: typing.Optional[typing.List[str]] = None,\n    ):\n        \"\"\"\n        Configures elib_config in one fell swoop\n\n        :param app_version: version of the application\n        :param app_name:name of the application\n        :param config_file_path: path to the config file to use\n        :param config_sep_str: separator for config values paths\n        :param root_path: list of strings that will be pre-pended to *all* config values paths (useful to setup a\n        prefix for the whole app)\n        \"\"\"\n        cls.app_version = app_version\n        cls.app_name = app_name\n        cls.config_file_path = config_file_path\n        cls.config_sep_str = config_sep_str\n        cls.root_path = root_path"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsort results by given criteria", "response": "def sortBy(self, *args):\n        '''sort results by given criteria'''\n        criteria = ['seeds', 'size']\n        for k in args:\n            if k in criteria:\n                self.results = sorted(\n                    self.results, key=attrgetter(k), reverse=True)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filterBy(self, **kwargs):\n        ''' filter results by given criteria'''\n        criteria = ['seeds', 'size']\n        for k, v in kwargs.iteritems():\n            if k in criteria:\n                self.results = filter(\n                    lambda x: getattr(x, k) >= v, self.results)\n        return self", "response": "filter results by given criteria"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the user s perms for the specified prefix.", "response": "def perms_check(perms, prefix, ambiguous=False):\n  \n  \"\"\"\n  Return the user's perms for the specified prefix\n\n  perms <dict> permissions dict\n  prefix <string> namespace to check for perms\n\n  ambiguous <bool=False> if True reverse wildcard matching is active and a perm check for a.b.* will\n  be matched by the user having perms to a.b.c or a.b.d - only use this if you know what \n  you are doing.\n  \"\"\"\n\n  try:\n   \n    token = prefix.split(\".\")\n\n    i = 1\n    l = len(token)\n    r = 0\n    \n    # collect permission rules with a wildcard in them, so we dont do unecessary\n    # regex searches later on\n    perms_wc = {}\n    for ns, p in perms.items():\n      if ns.find(\"*\") > -1:\n        perms_wc[re.escape(ns).replace(\"\\*\", \"[^\\.]+\")] = p\n\n    while i <= l:\n      k = \".\".join(token[:i])\n      matched = False\n\n      # check for exact match\n      if perms.has_key(k):\n        r = perms.get(k)\n\n      # check for wildcard matches (if any wildcard rules exist)\n      elif perms_wc:\n        for ns, p in perms_wc.items():\n          a = \"^%s$\" % ns\n          b = \"^%s\\.\" % ns\n          j = len(a)\n          u = len(b)\n          if j > matched and re.match(a, k):\n            r = p\n            matched = j\n          elif u > matched and re.match(b, k):\n            r = p\n            matched = u\n      \n      # if not matched at all and ambiguous flag is true, do ambiguous matching\n      if not matched and ambiguous:\n        m = \"^%s\" % re.escape(k).replace(\"\\*\", \"[^\\.]+\")\n        for ns, p in perms.items():\n          if re.match(m, ns) and p > r:\n            r = p\n            break\n\n      i += 1\n\n    return r\n  except:\n    raise"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef discover_config_path(self, config_filename: str) -> str:\n\n        if config_filename and os.path.isfile(config_filename):\n            return config_filename\n\n        for place in _common_places:\n            config_path = os.path.join(place, config_filename)\n            if os.path.isfile(config_path):\n                return config_path\n\n        return", "response": "Find the path to the config file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn an iterator over the keys from a yml file.", "response": "def gen_from_yaml_config(self, config_path: str) -> Iterator:\n        \"\"\"\n        Convention is to uppercase first level keys.\n\n        :param config_path: Valid path to the yml config file.\n        :return: Config loaded from yml file\n        \"\"\"\n        if not config_path:\n            return {}\n\n        with open(config_path, 'r') as f:\n            yaml_config = yaml.load(f)\n\n        gen = map(lambda x: (x[0].upper(), x[1]), yaml_config.items())\n\n        return gen"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove handler_name from dict_config and requested_handlers if check_key is not set.", "response": "def remove_handler_if_not_configured(self, dict_config, requested_handlers, handler_name, check_key) -> None:\n        \"\"\"\n        Remove ``handler_name`` from ``dict_config`` and ``requested_handlers`` if ``check_key`` is empty.\n        \"\"\"\n        try:\n            if not dict_config[\"handlers\"][handler_name][check_key]:\n                dict_config[\"handlers\"].pop(handler_name)\n                if handler_name in requested_handlers:\n                    requested_handlers.remove(handler_name)\n        except KeyError:\n            # Ignore key errors\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _normalize_name(name):\n  if isinstance(name, tuple):\n    ns, nm = name\n    return \"{}:{}\".format(ns, nm)\n  else:\n    return name", "response": "Normalizes the name of an element tag or attribute name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _normalize_attrs(attrs, null=None):\n  if attrs:\n    items = sorted((_normalize_name(k), _normalize_value(v, null)) for (k, v) in attrs.items())\n\n    if null is None:\n      return OrderedDict((k, v) for (k, v) in items if v is not None)\n    else:\n      return OrderedDict(items)\n  else:\n    return {}", "response": "Normalizes the attributes of the node."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite an opening element.", "response": "def open(self, name, attrs=None, *, close=False):\n    \"\"\"Writes an opening element.\n\n    :name: the name of the element\n    :attrs: a dict of attributes\n    :close: if True, close will be called immediately after writing the element\n    \"\"\"\n    self._pad()\n    self._writer.startElement(_normalize_name(name), _normalize_attrs(attrs))\n    self._newline()\n    self._open_elements.append(name)\n\n    if close:\n      self.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclose the most recently opened element.", "response": "def close(self, name=None):\n    \"\"\"Closes the most recently opened element.\n\n    :name: if given, this value must match the name given for the most recently opened element. This\n           is primarily here for providing quick error checking for applications\n    \"\"\"\n    tag = self._open_elements.pop()\n    if name is not None and name != tag:\n      raise Exception(\"Tag closing mismatch\")\n    self._pad()\n    self._writer.endElement(_normalize_name(tag))\n    self._newline()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef characters(self, characters):\n    self._pad()\n    self._writer.characters(str(characters))\n    self._newline()", "response": "Writes content for a tag."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef element(self, name, attrs=None):\n    self.open(name, attrs)\n    yield\n    self.close()", "response": "This method is a context manager for writing and closing an element."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef no_inner_space(self, *, outer=True):\n    if outer:\n      self._pad()\n\n    indent_was = self._indent\n    self._indent = None\n\n    try:\n      yield\n    finally:\n      self._indent = indent_was\n\n    if outer:\n      self._newline()", "response": "Context manager that does not add any inner space."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef content(self, name, attrs=None, characters=None):\n    with self.no_inner_space(outer=True):\n      with self.element(name, attrs):\n        if characters:\n          self.characters(characters)", "response": "Writes an element some content for the element and then closes the element."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npad the output with an amount of indentation appropriate for the number of open elements.", "response": "def _pad(self):\n    \"\"\"Pads the output with an amount of indentation appropriate for the number of open element.\n\n    This method does nothing if the indent value passed to the constructor is falsy.\n    \"\"\"\n    if self._indent:\n      self.whitespace(self._indent * len(self._open_elements))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_dump_names(self, names, dumps=None):\n        # Default value for dumps argument is an empty set (setting directly\n        # as a python argument would result as a shared value between\n        # instances)\n        if dumps is None:\n            dumps = set([])\n\n        # Add name to the dumps and find its dependancies\n        for item in names:\n            if item not in self:\n                if not self.silent_key_error:\n                    raise KeyError(\"Dump name '{0}' is unknowed\".format(item))\n                else:\n                    continue\n\n            dumps.add(item)\n\n            # Add dependancies names to the dumps\n            deps = self.__getitem__(item).get('dependancies', [])\n            dumps.update(deps)\n\n        # Avoid maximum recursion when we allready find all dependancies\n        if names == dumps:\n            return dumps\n\n        # Seems we don't have finded other dependancies yet, recurse to do it\n        return self.get_dump_names(dumps.copy(), dumps)", "response": "Find and return all dump names required by dependancies for a given dump names list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_dump_order(self, names):\n        finded_names = self.get_dump_names(names)\n        return [item for item in self if item in finded_names]", "response": "Return ordered dump names required for a given dump names list"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntrying to print meaningful info about wrapped twisted. web exceptions.", "response": "def log_web_failure(err, err_lid=''):\n\t'Try to print meaningful info about wrapped twisted.web exceptions.'\n\tif err_lid and not err_lid.endswith(' '): err_lid += ' '\n\ttry: err.value.reasons # multiple levels of fail\n\texcept AttributeError: pass\n\telse: err = err.value\n\tif hasattr(err, 'reasons'):\n\t\tfor err in err.reasons:\n\t\t\tlid = '  '\n\t\t\tif isinstance(err, Failure):\n\t\t\t\tlog.error('{}{} {}: {}'.format(err_lid, lid, err.type, err.getErrorMessage()))\n\t\t\t\tfor line in err.getTraceback().splitlines():\n\t\t\t\t\tlog.error('{}{}   {}'.format(err_lid, lid, line))\n\t\t\telse: log.error('{}{} {}: {}'.format(err_lid, lid, type(err), err))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting passed string type to bytes if necessary.", "response": "def force_bytes(bytes_or_unicode, encoding='utf-8', errors='backslashreplace'):\n\t'Convert passed string type to bytes, if necessary.'\n\tif isinstance(bytes_or_unicode, bytes): return bytes_or_unicode\n\treturn bytes_or_unicode.encode(encoding, errors)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef request( self, url, method='get',\n\t\t\tdecode=None, encode=None, data=None,\n\t\t\theaders=None, raise_for=dict(), queue_lines=None ):\n\t\t'''Make HTTP(S) request.\n\t\t\theaders can be either dict or callable(url, method, body, mimetype or None).\n\t\t\tdecode (response body) = None | json.\n\t\t\tencode (data) = None | json | form | files.'''\n\t\tif self.debug_requests:\n\t\t\turl_debug = _dump_trunc(url)\n\t\t\tlog.debug('HTTP request: {} {} (h: {}, enc: {}, dec: {}, data: {!r})'.format(\n\t\t\t\tmethod, url_debug, headers, encode, decode, _dump_trunc(data) ))\n\n\t\ttimeout = HTTPTimeout(**self.request_io_timeouts)\n\t\treq_headers = {'User-Agent': 'txU1'}\n\n\t\tif data is not None:\n\t\t\tif encode == 'files':\n\t\t\t\tboundary = os.urandom(16).encode('hex')\n\t\t\t\treq_headers['Content-Type'] = 'multipart/form-data; boundary={}'.format(boundary)\n\t\t\t\tdata = MultipartDataSender(data, boundary)\n\t\t\t\tif not callable(headers): yield data.calculate_length()\n\t\t\t\telse:\n\t\t\t\t\tbody = io.BytesIO()\n\t\t\t\t\tyield data.calculate_length(body)\n\t\t\t\t\theaders = headers(url, method, body.getvalue(), 'multipart/form-data')\n\t\t\telse:\n\t\t\t\tif encode is None:\n\t\t\t\t\tif isinstance(data, types.StringTypes): data = io.BytesIO(data)\n\t\t\t\telif encode == 'form':\n\t\t\t\t\treq_headers['Content-Type'] = 'application/x-www-form-urlencoded'\n\t\t\t\t\tdata = io.BytesIO(urllib.urlencode(data))\n\t\t\t\telif encode == 'json':\n\t\t\t\t\treq_headers['Content-Type'] = 'application/json'\n\t\t\t\t\tdata = io.BytesIO(json.dumps(data))\n\t\t\t\telse: raise ValueError('Unknown request encoding: {}'.format(encode))\n\t\t\t\tif callable(headers):\n\t\t\t\t\tdata.seek(0)\n\t\t\t\t\theaders = headers(url, method, data.read(), req_headers.get('Content-Type'))\n\t\t\t\tdata = FileBodyProducer(data)\n\t\telif callable(headers): headers = headers(url, method, '', None)\n\n\t\t# Passed \"headers\" should be allowed to be modified by body_hash()\n\t\tfor k, v in (headers or dict()).viewitems():\n\t\t\treq_headers[force_bytes(k)] = force_bytes(v)\n\t\turl, method = it.imap(force_bytes, [url, method.lower()])\n\n\t\tif decode == 'json': req_headers.setdefault('Accept', 'application/json')\n\t\telif decode is not None:\n\t\t\traise ValueError('Unknown response decoding method: {}'.format(decode))\n\n\t\tres_deferred = first_result( timeout,\n\t\t\tself.request_agent.request( method.upper(), url,\n\t\t\t\tHeaders(dict((k,[v]) for k,v in req_headers.viewitems())), data ) )\n\t\tcode = res_body = None\n\t\ttry:\n\t\t\tres = yield res_deferred\n\t\t\tcode = res.code\n\t\t\tif code == http.NO_CONTENT: defer.returnValue(None)\n\t\t\tif code not in [http.OK, http.CREATED]:\n\t\t\t\tif self.debug_requests:\n\t\t\t\t\tres_body = defer.Deferred()\n\t\t\t\t\tres.deliverBody(DataReceiver(res_body, timer=timeout, allow_loss=True))\n\t\t\t\t\tres_body = yield first_result(timeout, res_body)\n\t\t\t\t\tlog.debug('HTTP error response body: {!r}'.format(res_body))\n\t\t\t\traise ProtocolError(code, res.phrase)\n\n\t\t\tres_body = defer.Deferred()\n\t\t\tres.deliverBody(DataReceiver(res_body, timer=timeout))\n\t\t\tres_body = yield first_result(timeout, res_body)\n\n\t\t\tif self.debug_requests:\n\t\t\t\tlog.debug( 'HTTP request done ({} {}): {} {} {}, body_len: {}'\\\n\t\t\t\t\t.format(method, url_debug, code, res.phrase, res.version, len(res_body)) )\n\t\t\tdefer.returnValue(json.loads(res_body) if decode is not None else res_body)\n\n\t\texcept ( timeout.ActivityTimeout, TimeoutError,\n\t\t\t\tResponseFailed, RequestNotSent, RequestTransmissionFailed ) as err:\n\t\t\tif isinstance(err, timeout.ActivityTimeout):\n\t\t\t\tif not res_deferred.called: res_deferred.cancel()\n\t\t\t\tif res_body and not res_body.called: res_body.cancel()\n\t\t\tif self.debug_requests:\n\t\t\t\tlog.debug(\n\t\t\t\t\t'HTTP transport (underlying protocol) error ({} {}): {}'\\\n\t\t\t\t\t.format(method, url_debug, err.message or repr(err.args)) )\n\t\t\traise UnderlyingProtocolError(err)\n\n\t\texcept ProtocolError as err:\n\t\t\tif self.debug_requests:\n\t\t\t\tlog.debug(\n\t\t\t\t\t'HTTP request handling error ({} {}, code: {}): {}'\\\n\t\t\t\t\t.format(method, url_debug, code, err.message) )\n\t\t\traise raise_for.get(code, ProtocolError)(code, err.message)\n\n\t\texcept RequestGenerationFailed as err:\n\t\t\terr[0][0].raiseException()\n\n\t\tfinally: timeout.state_finished()", "response": "Make HTTP(S) request.\n\t\t\theaders can be either dict or callable(url, method, body, mimetype or None).\n\t\t\tdecode (response body) = None | json.\n\t\t\tencode (data) = None | json | form | files."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn tuple of ( bytes_available bytes_quota ).", "response": "def get_quota(self):\n\t\t'Return tuple of (bytes_available, bytes_quota).'\n\t\tdu, ds = op.itemgetter('used_bytes', 'max_bytes')((yield self()))\n\t\tdefer.returnValue((ds - du, ds))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets list of all volumes or info for the one specified.", "response": "def volume_info(self, vol=None, type_filter=None):\n\t\t'Get list of all volumes or info for the one specified.'\n\t\tvols = yield self(join('volumes', vol))\n\t\tif not isinstance(vols, list): vols = [vols]\n\t\tif type_filter is not None:\n\t\t\tvols = list(vol for vol in vols if vol['type'] == type_filter)\n\t\tif vol is not None: defer.returnValue(vols[0] if vols else None)\n\t\tdefer.returnValue(vols)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndoing not raise any errors.", "response": "def node_mkdir(self, path=''):\n\t\t'Does not raise any errors if dir already exists.'\n\t\treturn self(path, data=dict(kind='directory'), encode='json', method='put')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse a MeetupEvent from the given response data.", "response": "def parse_event(data, attendees=None, photos=None):\n    \"\"\"\n    Parse a ``MeetupEvent`` from the given response data.\n\n    Returns\n    -------\n    A ``pythonkc_meetups.types.MeetupEvent``.\n\n    \"\"\"\n    return MeetupEvent(\n        id=data.get('id', None),\n        name=data.get('name', None),\n        description=data.get('description', None),\n        time=parse_datetime(data.get('time', None),\n                            data.get('utc_offset', None)),\n        status=data.get('status', None),\n        yes_rsvp_count=data.get('yes_rsvp_count', None),\n        maybe_rsvp_count=data.get('maybe_rsvp_count', None),\n        event_url=data.get('event_url', None),\n        photo_url=data.get('photo_url', None),\n        venue=parse_venue(data['venue']) if 'venue' in data else None,\n        attendees=attendees,\n        photos=photos\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a MeetupVenue from the given response data.", "response": "def parse_venue(data):\n    \"\"\"\n    Parse a ``MeetupVenue`` from the given response data.\n\n    Returns\n    -------\n    A `pythonkc_meetups.types.`MeetupVenue``.\n\n    \"\"\"\n    return MeetupVenue(\n        id=data.get('id', None),\n        name=data.get('name', None),\n        address_1=data.get('address_1', None),\n        address_2=data.get('address_2', None),\n        address_3=data.get('address_3', None),\n        city=data.get('city', None),\n        state=data.get('state', None),\n        zip=data.get('zip', None),\n        country=data.get('country', None),\n        lat=data.get('lat', None),\n        lon=data.get('lon', None)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a MeetupMember from the given RSVP response data.", "response": "def parse_member_from_rsvp(data):\n    \"\"\"\n    Parse a ``MeetupMember`` from the given RSVP response data.\n\n    Returns\n    -------\n    A ``pythonkc_meetups.types.MeetupMember``.\n\n    \"\"\"\n    return MeetupMember(\n        id=data['member'].get('member_id', None),\n        name=data['member'].get('name', None),\n        photo=(parse_photo(data['member_photo'])\n               if 'member_photo' in data else None)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_photo(data):\n    return MeetupPhoto(\n        id=data.get('photo_id', data.get('id', None)),\n        url=data.get('photo_link', None),\n        highres_url=data.get('highres_link', None),\n        thumb_url=data.get('thumb_link', None)\n    )", "response": "Parse a MeetupPhoto from the given response data."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses a datetime. datetime from a given UTC timestamp.", "response": "def parse_datetime(utc_timestamp_ms, utc_offset_ms):\n    \"\"\"\n    Create a timezone-aware ``datetime.datetime`` from the given UTC timestamp\n    (in milliseconds), if provided. If an offest it given, it is applied to the\n    datetime returned.\n\n    Parameters\n    ----------\n    utc_timestamp_ms\n        UTC timestamp in milliseconds.\n    utc_offset_ms\n        Offset from UTC, in milliseconds, to apply to the time.\n\n    Returns\n    -------\n    A ``datetime.datetime`` if a timestamp is given, otherwise ``None``.\n\n    \"\"\"\n    if utc_timestamp_ms:\n        utc_timestamp_s = utc_timestamp_ms / 1000\n        dt = datetime.datetime.fromtimestamp(utc_timestamp_s, tzutc())\n\n        if utc_offset_ms:\n            utc_offset_s = utc_offset_ms / 1000\n            tz_offset = tzoffset(None, utc_offset_s)\n            dt = dt.astimezone(tz_offset)\n\n        return dt"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if the value is a valid mysql value.", "response": "def _mysql_isval(val):\n    \"\"\" These types should either be ignored or have already been\n    inserted into the SQL directly and dont need sqlalchemy to do\n    it for us. \"\"\"\n    if _mysql_is_list(val):\n        return False\n    elif isinstance(val, mysql_col):\n        return False\n    elif val in [None, mysql_now, mysql_ignore]:\n        return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize a model registry with a list of model definitions in Json - like format.", "response": "def init_registry(mongo, model_defs, clear_collection=False):\n    \"\"\"Initialize a model registry with a list of model definitions in Json\n    format.\n\n    Parameters\n    ----------\n    mongo : scodata.MongoDBFactory\n        Connector for MongoDB\n    model_defs : list()\n        List of model definitions in Json-like format\n    clear_collection : boolean\n        If true, collection will be dropped before models are created\n    \"\"\"\n    # Create model registry\n    registry = DefaultModelRegistry(mongo)\n    # Drop collection if clear flag is set to True\n    if clear_collection:\n        registry.clear()\n    for i in range(len(model_defs)):\n        model = registry.from_json(model_defs[i])\n        registry.register_model(\n            model.identifier,\n            model.properties,\n            model.parameters,\n            model.outputs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes a model registry with a list of model definitions that are stored in a given file in Json format.", "response": "def init_registry_from_json(mongo, filename, clear_collection=False):\n    \"\"\"Initialize a model registry with a list of model definitions that are\n    stored in a given file in Json format.\n\n    Parameters\n    ----------\n    mongo : scodata.MongoDBFactory\n        Connector for MongoDB\n    filename : string\n        Path to file containing model definitions\n    clear_collection : boolean\n        If true, collection will be dropped before models are created\n    \"\"\"\n    # Read model definition file (JSON)\n    with open(filename, 'r') as f:\n        models = json.load(f)\n    init_registry(mongo, models, clear_collection)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete the model with given identifier in the database. Returns the handle for the deleted model or None if the identifier is unknown.", "response": "def delete_model(self, identifier, erase=False):\n        \"\"\"Delete the model with given identifier in the database. Returns the\n        handle for the deleted model or None if object identifier is unknown.\n\n        Parameters\n        ----------\n        identifier : string\n            Unique model identifier\n        erase : Boolean, optinal\n            If true, the record will be deleted from the database. Otherwise,\n            the active flag will be set to False to support provenance tracking.\n\n        Returns\n        -------\n        ModelHandle\n        \"\"\"\n        self.delete_object(identifier, erase=erase)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a model database object from a given Json document.", "response": "def from_json(self, document):\n        \"\"\"Create a model database object from a given Json document.\n\n        Parameters\n        ----------\n        document : JSON\n            Json representation of the object\n\n        Returns\n        ModelHandle\n        \"\"\"\n        # The timestamp is optional (e.g., in cases where model definitions are\n        # loaded from file).\n        if 'timestamp' in document:\n            timestamp = datetime.datetime.strptime(\n                document['timestamp'],\n                '%Y-%m-%dT%H:%M:%S.%f'\n            )\n        else:\n            timestamp = None\n        # Create handle for database object\n        return ModelHandle(\n            document['_id'],\n            document['properties'],\n            [AttributeDefinition.from_json(el) for el in document['parameters']],\n            ModelOutputs.from_json(document['outputs']),\n            timestamp=timestamp\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlist the models in the database.", "response": "def list_models(self, limit=-1, offset=-1):\n        \"\"\"List models in the database. Takes optional parameters limit and\n        offset for pagination.\n\n        Parameters\n        ----------\n        limit : int\n            Limit number of models in the result set\n        offset : int\n            Set offset in list (order as defined by object store)\n\n        Returns\n        -------\n        ObjectListing\n        \"\"\"\n        return self.list_objects(limit=limit, offset=offset)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_model(self, identifier, properties, parameters, outputs):\n        # Create object handle and store it in database before returning it\n        obj = ModelHandle(identifier, properties, parameters, outputs)\n        self.insert_object(obj)\n        return obj", "response": "Create an object for the subject and image group."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a Json - like object for a model.", "response": "def to_json(self, model):\n        \"\"\"Create a Json-like object for a model.\n\n        Parameters\n        ----------\n        model : ModelHandle\n\n        Returns\n        -------\n        dict\n            Json-like object representation\n        \"\"\"\n        # Get the basic Json object from the super class\n        obj = super(DefaultModelRegistry, self).to_json(model)\n        # Add model parameter\n        obj['parameters'] = [\n            para.to_json() for para in model.parameters\n        ]\n        obj['outputs'] = model.outputs.to_json()\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _bad_result(cls, error):\n        return cls.Result(ok=False, expr='', files={}, stdout='', type='', value=error)", "response": "Return a TryHaskell. Result object with error message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef eval(cls, exp, files=None):\n        return cls.show(cls.get(exp, files=files))", "response": "Evaluate a Haskell expression."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(cls, exp, files=None):\n        return cls.parse(cls.raw(exp, files=files))", "response": "Evaluate a Haskell expression and return a TryHaskell. Result object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nevaluating a Haskell expression.", "response": "def raw(cls, exp, files=None):\n        \"\"\"\n        :param str|unicode exp: Haskell expression to evaluate.\n        :param dict[str|unicode, str|unicode] files: Dictionary of file names->contents\n        :rtype: dict\n        \"\"\"\n        payload = {'exp': exp}\n        if files:\n            # TODO: Implement stdin.\n            stdin = []\n            payload['args'] = json.dumps([stdin, files])\n        try:\n            return requests.get('http://tryhaskell.org/eval', params=payload).json()\n        except ValueError as e:\n            raise cls.Error(e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a TryHaskell. response.", "response": "def parse(cls, j):\n        \"\"\"\n        :param dict j: JSON response from TryHaskell.\n        :rtype: TryHaskell.Result\n        \"\"\"\n        error = j.get('error')\n        if error:\n            return cls._bad_result(error)\n        success = j.get('success')\n        if success:\n            try:\n                return cls.Result(ok=True, **j.get('success'))\n            except (TypeError, ValueError) as e:\n                raise cls.Error(e)\n        # If there was neither a success nor an error, the service\n        # is probably expecting something from stdin, which is not\n        # currently implemented.\n        # TODO: Implement stdin.\n        return cls._bad_result('Unsupported operation.')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show(cls, result):\n        if result.ok:\n            if result.stdout:\n                out = '\\n'.join(result.stdout)\n                if result.value and result.value != '()':\n                    return '\\n'.join([out, result.value])\n                return out\n            if result.value and not cls._is_function_value(result.value):\n                return result.value\n            return cls.show_type(result)\n        return result.value", "response": "Show the value of a resource in the format that is expected by the API."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef show_type(cls, result):\n        if result.ok:\n            return ' :: '.join([result.expr, result.type])\n        return result.value", "response": "Show type of the object in the JSON data."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nviews for an admin to log her self out and login the anonymous user.", "response": "def anonymous_login_view(request):\n    ''' View for an admin to log her/himself out and login the anonymous user. '''\n    logout(request)\n    try:\n        spineless = User.objects.get(username=ANONYMOUS_USERNAME)\n    except User.DoesNotExist:\n        random_password = User.objects.make_random_password()\n        spineless = User.objects.create_user(username=ANONYMOUS_USERNAME, first_name=\"Anonymous\", last_name=\"Coward\", password=random_password)\n        spineless.is_active = False\n        spineless.save()\n        spineless_profile = UserProfile.objects.get(user=spineless)\n        spineless_profile.status = UserProfile.ALUMNUS\n        spineless_profile.save()\n    spineless.backend = 'django.contrib.auth.backends.ModelBackend'\n    login(request, spineless)\n    request.session['ANONYMOUS_SESSION'] = True\n    messages.add_message(request, messages.INFO, MESSAGES['ANONYMOUS_LOGIN'])\n    return HttpResponseRedirect(reverse('homepage'))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef end_anonymous_session_view(request):\n    ''' End the anonymous session if the user is a superuser. '''\n    request.session['ANONYMOUS_SESSION'] = False\n    messages.add_message(request, messages.INFO, MESSAGES['ANONYMOUS_SESSION_ENDED'])\n    return HttpResponseRedirect(reverse('utilities'))", "response": "End the anonymous session if the user is a superuser."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_managers_view(request):\n    ''' Show a list of manager positions with links to view in detail. '''\n    managerset = Manager.objects.filter(active=True)\n    return render_to_response('list_managers.html', {\n        'page_name': \"Managers\",\n        'managerset': managerset,\n        }, context_instance=RequestContext(request))", "response": "Show a list of manager positions with links to view in detail."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef manager_view(request, managerTitle):\n    ''' View the details of a manager position.\n    Parameters:\n        request is an HTTP request\n        managerTitle is the URL title of the manager.\n    '''\n    targetManager = get_object_or_404(Manager, url_title=managerTitle)\n\n    if not targetManager.active:\n        messages.add_message(request, messages.ERROR, MESSAGES['INACTIVE_MANAGER'].format(managerTitle=targetManager.title))\n        return HttpResponseRedirect(reverse('managers:list_managers'))\n    else:\n        return render_to_response('view_manager.html', {\n            'page_name': \"View Manager\",\n            'targetManager': targetManager,\n            }, context_instance=RequestContext(request))", "response": "View the details of a manager position."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_manager_view(request):\n    ''' View to add a new manager position. Restricted to superadmins and presidents. '''\n    form = ManagerForm(request.POST or None)\n    if form.is_valid():\n        manager = form.save()\n        messages.add_message(request, messages.SUCCESS,\n                             MESSAGES['MANAGER_ADDED'].format(managerTitle=manager.title))\n        return HttpResponseRedirect(reverse('managers:add_manager'))\n    return render_to_response('edit_manager.html', {\n        'page_name': \"Admin - Add Manager\",\n        'managerset': Manager.objects.all(),\n        'form': form,\n        }, context_instance=RequestContext(request))", "response": "View to add a new manager position. Restricted to superadmins and presidents."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nviews to edit an existing manager.", "response": "def edit_manager_view(request, managerTitle):\n    ''' View to modify an existing manager.\n    Parameters:\n        request is an HTTP request\n        managerTitle is URL title of the manager.\n    '''\n    targetManager = get_object_or_404(Manager, url_title=managerTitle)\n    form = ManagerForm(\n        request.POST or None,\n        instance=targetManager,\n        )\n    if form.is_valid():\n        manager = form.save()\n        messages.add_message(request, messages.SUCCESS,\n                             MESSAGES['MANAGER_SAVED'].format(managerTitle=manager.title))\n        return HttpResponseRedirect(reverse('managers:meta_manager'))\n    return render_to_response('edit_manager.html', {\n        'page_name': \"Admin - Edit Manager\",\n        'form': form,\n        \"managerset\": Manager.objects.all(),\n        'manager_title': targetManager.title,\n        }, context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmanages requests. Display a list of request types with links to edit them. Also display a link to add a new request type. Restricted to presidents and superadmins.", "response": "def manage_request_types_view(request):\n    ''' Manage requests.  Display a list of request types with links to edit them.\n    Also display a link to add a new request type.  Restricted to presidents and superadmins.\n    '''\n    request_types = RequestType.objects.all()\n    return render_to_response('manage_request_types.html', {\n        'page_name': \"Admin - Manage Request Types\",\n        'request_types': request_types\n        }, context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_request_type_view(request):\n    ''' View to add a new request type.  Restricted to presidents and superadmins. '''\n    form = RequestTypeForm(request.POST or None)\n    if form.is_valid():\n        rtype = form.save()\n        messages.add_message(request, messages.SUCCESS,\n                             MESSAGES['REQUEST_TYPE_ADDED'].format(typeName=rtype.name))\n        return HttpResponseRedirect(reverse('managers:manage_request_types'))\n    return render_to_response('edit_request_type.html', {\n        'page_name': \"Admin - Add Request Type\",\n        'request_types': RequestType.objects.all(),\n        'form': form,\n        }, context_instance=RequestContext(request))", "response": "View to add a new request type. Restricted to presidents and superadmins."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nview to edit a new request type. Restricted to presidents and superadmins.", "response": "def edit_request_type_view(request, typeName):\n    ''' View to edit a new request type.  Restricted to presidents and superadmins.\n    Parameters:\n        request is an HTTP request\n        typeName is the request type's URL name.\n    '''\n    requestType = get_object_or_404(RequestType, url_name=typeName)\n    form = RequestTypeForm(\n        request.POST or None,\n        instance=requestType,\n        )\n    if form.is_valid():\n        rtype = form.save()\n        messages.add_message(request, messages.SUCCESS,\n                             MESSAGES['REQUEST_TYPE_SAVED'].format(typeName=rtype.name))\n        return HttpResponseRedirect(reverse('managers:manage_request_types'))\n    return render_to_response('edit_request_type.html', {\n        'page_name': \"Admin - Edit Request Type\",\n        'request_types': RequestType.objects.all(),\n        'form': form,\n        'requestType': requestType,\n        }, context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef my_requests_view(request):\n    '''\n    Show user his/her requests, sorted by request_type.\n    '''\n    page_name = \"Your Requests\"\n    userProfile = UserProfile.objects.get(user=request.user)\n    my_requests = Request.objects.filter(owner=userProfile)\n    # A pseudo dictionary, actually a list with items of form\n    # (request_type.name.title(), request_form, type_manager, [(request,\n    # [list_of_request_responses], response_form, upvote, vote_form),...],\n    # relevant_managers)\n    request_dict = list()\n    for request_type in RequestType.objects.all():\n        relevant_managers = request_type.managers.filter(active=True)\n        type_manager = any(i.incumbent == userProfile for i in\n                           relevant_managers)\n        # Items are of form (request, [list_of_request_responses],\n        # response_form),...])\n        requests_list = list()\n        type_requests = my_requests.filter(request_type=request_type)\n        for req in type_requests:\n            responses_list = Response.objects.filter(request=req)\n            if type_manager:\n                response_form = ManagerResponseForm(\n                    request.POST if \"add_response-{0}\".format(req.pk) in request.POST else None,\n                    initial={'action': Response.NONE},\n                    profile=userProfile,\n                    request=req,\n                    prefix=\"response-{0}\".format(req.pk),\n                    )\n            else:\n                response_form = ResponseForm(\n                    request.POST if \"add_response-{0}\".format(req.pk) in request.POST else None,\n                    profile=userProfile,\n                    request=req,\n                    prefix=\"response-{0}\".format(req.pk),\n                    )\n\n            upvote = userProfile in req.upvotes.all()\n            vote_form = VoteForm(\n                request.POST if \"vote-{0}\".format(req.pk) in request.POST else None,\n                request.POST or None,\n                profile=userProfile,\n                request=req,\n                prefix=\"vote-{0}\",\n                )\n\n            if response_form.is_valid():\n                response_form.save()\n                return HttpResponseRedirect(reverse('managers:my_requests'))\n            if vote_form.is_valid():\n                vote_form.save()\n                return HttpResponseRedirect(reverse('managers:my_requests'))\n\n            requests_list.append((req, responses_list, response_form, upvote, vote_form))\n        request_form = RequestForm(\n            request.POST if \"submit_request\" in request.POST else None,\n            profile=userProfile,\n            request_type=request_type,\n            prefix=\"request-{0}\".format(request_type.pk),\n            )\n        if request_form.is_valid():\n            request_form.save()\n            return HttpResponseRedirect(reverse('managers:my_requests'))\n        request_dict.append((request_type, request_form, type_manager,\n                             requests_list, relevant_managers))\n    return render_to_response('my_requests.html', {\n        'page_name': page_name,\n        'request_dict': request_dict,\n        }, context_instance=RequestContext(request))", "response": "Show user his / her requests sorted by request_type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nshow user his requests in list form.", "response": "def list_my_requests_view(request):\n    '''\n    Show user his/her requests in list form.\n    '''\n    userProfile = UserProfile.objects.get(user=request.user)\n    requests = Request.objects.filter(owner=userProfile)\n    return render_to_response('list_requests.html', {\n        'page_name': \"Your Requests\",\n        'requests': requests,\n        }, context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_user_requests_view(request, targetUsername):\n    '''\n    Show user his/her requests in list form.\n    '''\n    if targetUsername == request.user.username:\n        return list_my_requests_view(request)\n\n    targetUser = get_object_or_404(User, username=targetUsername)\n    targetProfile = get_object_or_404(UserProfile, user=targetUser)\n    page_name = \"{0}'s Requests\".format(targetUsername)\n    requests = Request.objects.filter(owner=targetProfile).exclude(\n        ~Q(owner__user=request.user), private=True,\n        )\n    return render_to_response('list_requests.html', {\n        'page_name': page_name,\n        'requests': requests,\n        'targetUsername': targetUsername,\n        }, context_instance=RequestContext(request))", "response": "Show user his / her requests in list form."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndisplaying user a list of enabled request types the number of requests of each request type and a link to see them all.", "response": "def all_requests_view(request):\n    '''\n    Show user a list of enabled request types, the number of requests of each\n    type and a link to see them all.\n    '''\n    # Pseudo-dictionary, actually a list with items of form\n    # (request_type.name.title(), number_of_type_requests, name, enabled,\n    # glyphicon)\n    types_dict = list()\n    for request_type in RequestType.objects.all():\n        requests = Request.objects.filter(request_type=request_type)\n        # Hide the count for private requests\n        if not request_type.managers.filter(incumbent__user=request.user):\n            requests = requests.exclude(\n                ~Q(owner__user=request.user), private=True,\n                )\n\n        number_of_requests = requests.count()\n        types_dict.append((\n            request_type.name.title(), number_of_requests,\n            request_type.url_name, request_type.enabled,\n            request_type.glyphicon,\n            ))\n    return render_to_response('all_requests.html', {\n        'page_name': \"Archives - All Requests\",\n        'types_dict': types_dict,\n        }, context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshows all the requests for a given type in list form.", "response": "def list_all_requests_view(request, requestType):\n    '''\n    Show all the requests for a given type in list form.\n    '''\n    request_type = get_object_or_404(RequestType, url_name=requestType)\n    requests = Request.objects.filter(request_type=request_type)\n    # Hide the count for private requests\n    if not request_type.managers.filter(incumbent__user=request.user):\n        requests = requests.exclude(\n            ~Q(owner__user=request.user), private=True,\n            )\n\n    page_name = \"Archives - All {0} Requests\".format(request_type.name.title())\n    return render_to_response('list_requests.html', {\n        'page_name': page_name,\n        'requests': requests,\n        'request_type': request_type,\n        }, context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef announcement_view(request, announcement_pk):\n    ''' The view of a single manager announcement. '''\n    announce = get_object_or_404(Announcement, pk=announcement_pk)\n    page_name = \"View Announcement\"\n    profile = UserProfile.objects.get(user=request.user)\n    pin_form = PinForm(\n        request.POST if \"pin\" in request.POST else None,\n        instance=announce,\n        )\n    can_edit = announce.incumbent == profile or request.user.is_superuser\n    if pin_form.is_valid():\n        pin_form.save()\n        return HttpResponseRedirect(\n            reverse('managers:view_announcement', kwargs={\"announcement_pk\": announcement_pk}),\n            )\n    return render_to_response('view_announcement.html', {\n        'page_name': page_name,\n        'pin_form': pin_form,\n        'can_edit': can_edit,\n        'announcement': announce,\n        }, context_instance=RequestContext(request))", "response": "The view of a single manager announcement."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef all_announcements_view(request):\n    ''' The view of manager announcements. '''\n    page_name = \"Archives - All Announcements\"\n    userProfile = UserProfile.objects.get(user=request.user)\n    announcement_form = None\n    manager_positions = Manager.objects.filter(incumbent=userProfile)\n    if manager_positions:\n        announcement_form = AnnouncementForm(\n            request.POST if \"post_announcement\" in request.POST else None,\n            profile=userProfile,\n            )\n        if announcement_form.is_valid():\n            announcement_form.save()\n            return HttpResponseRedirect(reverse('managers:all_announcements'))\n\n    # A pseudo-dictionary, actually a list with items of form (announcement,\n    # announcement_pin_form)\n    announcements_dict = list()\n    for a in Announcement.objects.all():\n        pin_form = None\n        if a.manager.incumbent == userProfile or request.user.is_superuser:\n            pin_form = PinForm(\n                request.POST if \"pin-{0}\".format(a.pk) in request.POST else None,\n                instance=a,\n                )\n            if pin_form.is_valid():\n                pin_form.save()\n                return HttpResponseRedirect(reverse('managers:all_announcements'))\n        announcements_dict.append((a, pin_form))\n    return render_to_response('announcements.html', {\n        'page_name': page_name,\n        'manager_positions': manager_positions,\n        'announcements_dict': announcements_dict,\n        'announcement_form': announcement_form,\n        }, context_instance=RequestContext(request))", "response": "The view of manager announcements."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef installed():\n        try:\n            path = ChromeCookies._getPath()\n            with open(path) as f: pass\n                \n            return True\n        except Exception as e:\n            return False", "response": "Returns whether or not Google Chrome is installed."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef loadCookies(domain):\n        try:\n            cj = requests.cookies.RequestsCookieJar()\n            path = ChromeCookies._getPath()\n            results = []\n            with sqlite.connect(path, timeout=0.1) as conn:\n                cursor = conn.cursor()\n                cursor.execute(\"select name, value, path, expires_utc from cookies WHERE host_key='\" + domain + \"'\")\n                results = cursor.fetchall()\n            \n            if not results:\n                raise noCookiesForDomain\n            \n            for result in results:\n                if not result[3]:\n                    expire = datetime.datetime.now() + datetime.timedelta(365)\n                else:\n                    epoch = datetime.datetime(1601, 1, 1)\n                    expire = epoch + datetime.timedelta(microseconds=result[3])\n                \n                expire = calendar.timegm(expire.utctimetuple())\n                cargs = {'expires': expire, 'domain': domain, 'path': result[2]}\n                cj.set(result[0], result[1], **cargs)\n        \n            return cj\n        except Exception as e:\n            logging.getLogger(\"neolib.http\").exception(\"Failed to load Google Chrome cookies\")\n            return False", "response": "Loads all Neopets cookies for a given domain into a CookieJar."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _getPath():\n        \n        if os.name == \"posix\":\n            path = os.getenv(\"HOME\") + \"/.config/google-chrome/Default/Cookies\"\n            return path\n        \n        import _winreg\n        key = _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, 'Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders')\n        path = _winreg.QueryValueEx(key, 'Local AppData')[0]\n        path = os.path.join(path, 'Google\\\\Chrome\\\\User Data\\\\Default\\\\Cookies')\n        \n        return path", "response": "Returns the path of the Google Chrome s cookie database"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef identify_assembly_points(graph, bgtree, target_multicolor, exclude=None, verbose=False, verbose_destination=None):\n    if verbose:\n        print(\">>Identifying assemblies for target multicolor:\",\n              [e.name for e in target_multicolor.multicolors.elements()], file=verbose_destination)\n    guidance = bgtree.consistent_multicolors[:]\n    offset = len(Multicolor.split_colors(target_multicolor, guidance=guidance,\n                                         account_for_color_multiplicity_in_guidance=False)) - 1\n    assemblies = []  # the overall result\n    if exclude is None:\n        exclude = []  # a container with single colors of genomes, that are to be considered fully assembled\n    multicolor_scores = {}\n    surroundings = {}\n    full_irregular_multicolors = {}\n    for i, cc in enumerate(graph.connected_components_subgraphs(copy=True)):\n        subnets, possible_assemblies, h_support, t_support, repeats = get_irregular_subnets(cc, target_multicolor, exclude)\n        for subnet in subnets:\n            vertices = [vertex for vertex in subnet.nodes() if not vertex.is_irregular_vertex]\n            repeats_h = {repeat for vertex in vertices for repeat in h_support[vertex]}\n            repeats_t = {repeat for vertex in vertices for repeat in t_support[vertex]}\n            repeats = repeats_h.intersection(repeats_t)\n            for repeat in repeats:\n                g = nx.Graph()\n                for edge in filter(lambda edge: not edge.is_irregular_edge, subnet.edges()):\n                    v1, v2 = sorted((edge.vertex1, edge.vertex2), key=lambda vertex: vertex.name)\n                    if v1 in h_support and repeat in h_support[v1] and v2 in t_support and repeat in t_support[v2]:\n                        before, after = get_assembly_score(graph, v1, v2, target_multicolor, bgtree,\n                                                           multicolor_scores, surroundings, full_irregular_multicolors)\n                        if before - after - offset > 1:\n                            g.add_edge((v1, \"h\"), (v2, \"t\"), weight=before - after - offset)\n                    if v1 in t_support and repeat in t_support[v1] and v2 in h_support and repeat in h_support[v2]:\n                        before, after = get_assembly_score(graph, v1, v2, target_multicolor, bgtree,\n                                                           multicolor_scores, surroundings, full_irregular_multicolors)\n                        if before - after - offset > 1:\n                            g.add_edge((v1, \"t\"), (v2, \"h\"), weight=before - after - offset)\n                edges = g.edges(data=True)\n                if len(edges) == 0:\n                    continue\n                new_edges = []\n                for edge in edges:\n                    first, second = edge[0], edge[1]\n                    v1, v2 = sorted((first, second), key=lambda item: item[0].name)\n                    new_edges.append((v1, v2, edge[2]))\n                edges = sorted(new_edges, reverse=True, key=lambda e: (e[2][\"weight\"], e[0][0].name, e[0][1], e[1][0].name, e[0][1]))\n                visited = set()\n                for v1, v2, data in edges:\n                    weight = data[\"weight\"]\n                    if v1 not in visited and v2 not in visited:\n                        visited.add(v1)\n                        visited.add(v2)\n                        v1, dir1 = v1\n                        v2, dir2 = v2\n                        assert (dir1 == \"h\" and dir2 == \"t\") or (dir1 == \"t\" and dir2 == \"h\")\n                        if dir1 == \"h\":\n                            assemblies.append((v2, v1, weight, repeat))\n                        else:\n                            assemblies.append((v1, v2, weight, repeat))\n    return assemblies", "response": "This function is used to identify the assemblies of a given multicolor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a Flask application factory", "response": "def create_app(object_name):\n    \"\"\"\n    An flask application factory, as explained here:\n    http://flask.pocoo.org/docs/patterns/appfactories/\n\n    Arguments:\n        object_name: the python path of the config object,\n                     e.g. webapp.settings.ProdConfig\n\n        env: The name of the current environment, e.g. prod or dev\n    \"\"\"\n    app = Flask(__name__)\n\n    app.config.from_object(object_name)\n\n    # initialize the cache\n    cache.init_app(app)\n\n    # initialize the debug tool bar\n    debug_toolbar.init_app(app)\n\n    # initialize SQLAlchemy\n    db.init_app(app)\n\n    return app"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts the string argument to an integer.", "response": "def to_int(argument):\n\t\"\"\"\n\tConverts the ``str`` argument to an integer:\n\n\t>>> from py_register_machine2.engine_tools.conversions import *\n\t>>> to_int(\"0x04\")\n\t4\n\t>>> to_int(\"'a'\")\n\t97\n\n\t\"\"\"\n\tif(argument.startswith(\"0b\")):\n\t\treturn int(argument[2:], 2)\n\telif(argument.startswith(\"0x\")):\n\t\treturn int(argument[2:], 16)\n\telif(argument.startswith(\"0\") and argument != \"0\"):\n\t\treturn int(argument[1:], 8)\n\telif(argument[0] == \"'\" and argument[2] == \"'\"):\n\t\treturn ord(argument[1])\n\treturn int(argument)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef chunks(iterable, size = 8):\n\tfor i in range(0, len(iterable), size):\n\t\tyield l[i:i + n]", "response": "Yields a list of size chunks from iterable."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmakes a path from a list of path segments.", "response": "def make_path(*path_or_str_or_segments):\n    \"\"\"\n    :param path_or_str_or_segments:\n    :return:\n    :rtype: cifparser.path.Path\n    \"\"\"\n    if len(path_or_str_or_segments) == 0:\n        return ROOT_PATH\n    elif len(path_or_str_or_segments) == 1:\n        single_item = path_or_str_or_segments[0]\n        if isinstance(single_item, Path):\n            return single_item\n        if isinstance(single_item, str):\n            try:\n                return path_parser.parseString(single_item, True).asList()[0]\n            except:\n                raise ValueError()\n        raise TypeError()\n    else:\n        segments = path_or_str_or_segments\n        return sum(map(lambda x: make_path(x), segments), ROOT_PATH)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmodifies the internal state of a wePay entry.", "response": "def __modify(self, client_id, client_secret, **kwargs):\n        \"\"\"Call documentation: `/app/modify\n        <https://www.wepay.com/developer/reference/app#modify>`_, plus extra\n        keyword parameter:\n        \n        :keyword bool batch_mode: turn on/off the batch_mode, see \n           :class:`wepay.api.WePay`\n\n        :keyword str batch_reference_id: `reference_id` param for batch call,\n           see :class:`wepay.api.WePay`\n\n        :keyword str api_version: WePay API version, see\n           :class:`wepay.api.WePay`\n\n        \"\"\"\n        params = {\n            'client_id': client_id,\n            'client_secret': client_secret\n        }\n        return self.make_call(self.__modify, params, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write(cls, html_file):\n        f = open(html_file, 'w')\n        f.write('<html>')\n        f.write('<head>')\n        f.write('</head>')\n        f.write('<body>')\n        f.write('<h1>Test times</h1>')\n        \n        fmt_test = '<tr><td>{:.05f}</td><td>{}</td></tr><tr><td>&nbsp;</td><td>{}</td></tr>'\n\n        f.write('<table>')\n        f.write('<tr><th>Time</th><th>Test info</th></tr>')\n        for row in TestTime.get_slowest_tests(10):\n            f.write(fmt_test.format(row['elapsed'], row['file'], '{}.{}.{}'.format(row['module'], row['class'], row['func'])))\n        f.write('</table>')\n\n\n        fmt_file = '<tr><td>{:.05f}</td><td>{}</td></tr>'\n        f.write('<table>')\n        f.write('<tr><th>Time</th><th>Test info</th></tr>')\n        for row in TestTime.get_slowest_files(10):\n            f.write(fmt_file.format(row['sum_elapsed'], row['file']))\n        f.write('</table>')\n\n        \n        f.write('<h1>Setup times</h1>')\n\n        f.write('<table>')\n        f.write('<tr><th>Time</th><th>Test info</th></tr>')\n        for row in SetupTime.get_slowest_tests(10):\n            f.write(fmt_test.format(row['elapsed'], row['file'], '{}.{}.{}'.format(row['module'], row['class'], row['func'])))\n        f.write('</table>')\n\n\n        f.write('<table>')\n        f.write('<tr><th>Time</th><th>Test info</th></tr>')\n        for row in SetupTime.get_slowest_files(10):\n            f.write(fmt_file.format(row['sum_elapsed'], row['file']))\n        f.write('</table>')\n\n        \n        f.write('</body>')\n        f.write('</html>')\n\n        f.close()", "response": "Writes the HTML report to the given file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _import_packages(packages, optional=None):\n    if not optional:\n        optional = []\n\n    package_references = set()\n\n    # Check all reqiured packages\n    failures = set()\n    for package_name in packages:\n        try:\n            package_reference = __import__(package_name, globals(), locals(), [], 0)\n            package_references.add(package_reference)\n        except ImportError:\n            failures.add(package_name)\n\n    # Report aggregated list of import failures (save a developer time when building a new frozen environment)\n    if failures:\n        raise ImportError(u\"Unable to find required packages: {0}\".format(u\", \".join(failures)))\n\n    # Check all optional packages (and warn if some aren't found)\n    failures = set()\n    for package_name in optional:\n        try:\n            package_reference = __import__(package_name, globals(), locals(), [], 0)\n            package_references.add(package_reference)\n        except ImportError:\n            failures.add(package_name)\n\n    # Warn user which optional packages weren't found\n    for failure in failures:\n        warn(ImportWarning(u\"Unable to import {0}\".format(failure)))\n\n    return package_references", "response": "Get actual package references from an iterable of package names\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef build_includes(include_packages, freezer=None, optional=None):\n    freezer = resolve_freezer(freezer)\n\n    # Import (or get reference to) all listed packages to ensure that they exist.\n    package_references = _import_packages(include_packages, optional=optional)\n\n    # Find all includes for the given freezer type\n    includes = freezer.build_includes(package_references)\n\n    return includes", "response": "Iterate the list of packages to build a complete list of those packages as well as all subpackages."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef locale_title(locale_name):\n    l = dict(settings.EXTRA_COUNTRY_LOCALES)\n    if locale_name not in l:\n        return locale_name\n    return l.get(locale_name)", "response": "Returns the title of a locale name in the current language."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _make_opt_list(opts, group):\n    import copy\n    import itertools\n\n    _opts = [(group, list(itertools.chain(*opts)))]\n    return [(g, copy.deepcopy(o)) for g, o in _opts]", "response": "Generate a list of tuples containing group and options associated with a group\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_from_area(self, lat_min, lon_min, lat_max, lon_max, picture_size=None, set_=None, map_filter=None):\n        page_size = 100\n        page = 0\n\n        result = self._request(lat_min, lon_min, lat_max, lon_max, page * page_size, (page + 1) * page_size,\n                               picture_size, set_, map_filter)\n\n        total_photos = result['count']\n        if total_photos < page_size:\n            return result\n\n        page += 1\n\n        pages = (total_photos / page_size) + 1\n        while page < pages:\n            new_result = self._request(lat_min, lon_min, lat_max, lon_max, page * page_size, (page + 1) * page_size,\n                                       picture_size, set_, map_filter)\n\n            result['photos'].extend(new_result['photos'])\n\n            page += 1\n\n        return result", "response": "Get all photos from a bounding box."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_all_pictures_cursor(self, lat_min, lon_min, lat_max, lon_max, picture_size=None, set_=None,\n                                map_filter=None):\n        \"\"\"\n        Generator to get all available photos for a given bounding box\n\n        :param lat_min:\n            Minimum latitude of the bounding box\n        :type lat_min: float\n        :param lon_min:\n            Minimum longitude of the bounding box\n        :type lon_min: float\n        :param lat_max:\n            Maximum latitude of the bounding box\n        :type lat_max: float\n        :param lon_max:\n            Maximum longitude of the bounding box\n        :type lon_max: float\n        :param picture_size:\n            This can be: original, medium (*default*), small, thumbnail, square, mini_square\n        :type picture_size: basestring\n        :param set_:\n            This can be: public, popular or user-id; where user-id is the specific id of a user (as integer)\n        :type set_: basestring/int\n        :param map_filter:\n            Whether to return photos that look better together; when True, tries to avoid returning photos of the same\n            location\n        :type map_filter: bool\n        :return: Yields individual dicts of photos\n        \"\"\"\n        page_size = 100\n        page = 0\n\n        result = self._request(lat_min, lon_min, lat_max, lon_max, page * page_size, (page + 1) * page_size,\n                               picture_size, set_, map_filter)\n\n        total_photos = result['count']\n\n        for photo in result['photos']:\n            yield photo\n\n        if total_photos < page_size:\n            raise StopIteration()\n\n        page += 1\n\n        pages = (total_photos / page_size) + 1\n        while page < pages:\n            result = self._request(lat_min, lon_min, lat_max, lon_max, page * page_size, (page + 1) * page_size,\n                                   picture_size, set_, map_filter)\n\n            for photo in result['photos']:\n                yield photo\n\n            page += 1\n\n        raise StopIteration()", "response": "Get all available photos for a given bounding box."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a column from an alignment as a dictionary indexed by seq. name.", "response": "def get_column(self, position, missing_seqs=MissingSequenceHandler.SKIP):\n    \"\"\"\n    return a column from an alignment as a dictionary indexed by seq. name.\n\n    :param position:     the index to extract; these are in alignment\n                         co-ordinates, which are one-based, so the first column\n                         has index 1, and the final column has\n                         index == size(self).\n    :param missing_seqs: how to treat sequence with no actual sequence data for\n                         the column.\n    :return: dictionary where keys are sequence names and values are\n             nucleotides (raw strings).\n    \"\"\"\n    res = {}\n    for k in self.sequences:\n      if isinstance(self.sequences[k], UnknownSequence):\n        if missing_seqs is MissingSequenceHandler.TREAT_AS_ALL_GAPS:\n          res[k] = \"-\"\n        elif missing_seqs is MissingSequenceHandler.SKIP:\n          continue\n      else:\n        res[k] = self.sequences[k][position - 1]\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting an alignment into a tuple with start and end coordinates", "response": "def alignment_to_sequence_coords(self, seq_name, start, end, trim=False):\n    \"\"\"\n    convert an interval in the alignmnet into co-ordinates in one of the\n    sequences. Alignment intervals are inclusive of start, but not end. They\n    are one-based. Hence the full alignment has coords [1, N+1), where N is the\n    length of the alignment (number of columns). Sequence coords follow the\n    same conventions: one-based, inclusive of start but not end.\n\n    :param seq_name: which sequence are the start and end coords for?\n    :param start:    start of the interval in alignment co-ordinates\n    :param end:      end of the interval in alignment co-ordinates\n    :param trim:     if true, trim coordinates that fall partially outside\n                     the alignment\n    :return: a tuple with the start and end sequence coords, in that order;\n             None if the interval in the alignment defined by (start, end)\n             contains only gaps in the specified sequence. start < end always,\n             even if the sequence is reverse complement.\n    :raises AlignmentError: if the sequence number specifies a sequence not\n                            in this alignment, or the coordinates fall\n                            entirely outside the alignment (or partially\n                            outside and trim == false), or they are not a valid\n                            interval (start >= end)\n    \"\"\"\n    start = 1 if start < 1 and trim else start\n    end = self.size() + 1 if (end > self.size() + 1) and trim else end\n\n    if (start < 1 or end > (self.size() + 1)):\n      msg = \"Coordinates fall partially outside alignemnt: \" + str(start) +\\\n            \", \" + str(end)\n      raise InvalidAlignmentCoordinatesError(msg)\n    if (end < 1 or start > self.size() + 1):\n      msg = \"Coordinates fall entirely outside alignment: \" + str(start) +\\\n            \", \" + str(end)\n      raise InvalidAlignmentCoordinatesError(msg)\n    if (end <= start):\n      msg = \"Invalid alignment coordinates: \" + str(start) + \", \" + str(end)\n      raise InvalidAlignmentCoordinatesError(msg)\n\n    seq = self[seq_name]\n    pos_strand = seq.is_positive_strand()\n    non_gaps = 0\n    r_start = None\n    r_end = None\n    l_start = 0 if pos_strand else self.size() - 1\n    l_end = end - 1 if pos_strand else start - 2\n    l_step = 1 if pos_strand else -1\n    for i in range(l_start, l_end, l_step):\n      if seq[i] != GAP_CHAR:\n        non_gaps += 1\n        if ((pos_strand and r_start is None and (i + 1) >= start) or\n           (not pos_strand and r_start is None and (i + 1) < end)):\n          r_start = non_gaps + seq.start - 1\n    if r_start is None:\n      # we went through the whole region and didn't find a single non-gap char\n      return None\n    r_end = non_gaps + seq.start\n    return (r_start, r_end)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a sequence into an alignment coordinates", "response": "def sequence_to_alignment_coords(self, seq_name, start, end, trim=False):\n    \"\"\"\n    convert an interval in one of the sequences into an interval in the\n    alignment. Alignment intervals are inclusive of start, but not end. They\n    are one-based. Hence the full alignment has coords [1, N+1), where N is the\n    length of the alignment (number of columns). Sequence coords follow the\n    same conventions: one-based, inclusive of start but not end.\n\n    :param seq_name: which sequence are the start and end coords for?\n    :param start:    start of the interval in sequence co-ordinates\n    :param end:      end of the interval in sequence co-ordinates\n    :param trim:     if true, trim coordinates that fall partially outside\n                     the sequence\n    :raises AlignmentError: if coordinates fall entirely outside the\n                            sequence, or partially outside and trim == false\n    \"\"\"\n    # check for valid order of start/end\n    if end <= start:\n      raise InvalidSequenceCoordinatesError(\"invalid region: \" + str(start) +\n                                            \", \" + str(end))\n    seq = self[seq_name]\n    s_start = seq.start\n    s_end = seq.end\n    pos_strand = seq.is_positive_strand()\n\n    # check that the start and end coords are at least partially in the seq\n    if start > s_end or end < s_start:\n      msg = \"Cannot convert \" + str(start) + \", \" + str(end) + \" to \" +\\\n            \"alignment coordinates; falls fully outside of sequence \" +\\\n            str(s_start) + \", \" + str(s_end)\n      raise InvalidSequenceCoordinatesError(msg)\n\n    # trim overlap if that option is sepcified, otherwise complain if outside\n    if trim:\n      start = s_start if start < s_start else start\n      end = s_end if end > s_end else end\n    elif start < s_start or end > s_end:\n      msg = \"Cannot convert \" + str(start) + \", \" + str(end) + \" to \" +\\\n            \"alignment coordinates; falls artially outside of seq. \" +\\\n            str(s_start) + \", \" + str(s_end)\n      raise InvalidSequenceCoordinatesError(msg)\n\n    num_gaps = 0\n    num_non_gaps = 0\n    res = []\n    current_start = None\n    current_end = None\n    l_start = 0 if pos_strand else self.size() - 1\n    l_end = self.size() if pos_strand else 0\n    l_step = 1 if pos_strand else -1\n    for i in range(l_start, l_end, l_step):\n      if seq[i] == GAP_CHAR:\n        num_gaps += 1\n      else:\n        num_non_gaps += 1\n\n      if num_non_gaps > end - s_start:    # done, past the end of the ROI\n        break\n      if num_non_gaps > start - s_start:  # within ROI still\n        if seq[i] != GAP_CHAR:\n          if current_start is None and current_end is None:\n            current_start = i\n            current_end = i + 1\n          else:\n            if ((pos_strand and seq[i - 1] == GAP_CHAR) or\n                (not pos_strand and seq[i + 1] == GAP_CHAR)):\n              # is the start of a new non-gapped region...\n              res.append((current_start + 1, current_end + 1))\n              current_start = i\n              current_end = i + 1\n            if pos_strand and seq[i - 1] != GAP_CHAR:\n              # is continuation of non-gapped region\n              current_end += 1\n            if not pos_strand and seq[i + 1] != GAP_CHAR:\n              # is continuation of non-gapped region\n              current_start -= 1\n    res.append((current_start + 1, current_end + 1))\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _after_event(self, e):\n        '''\n            Checks to see if the callback is registered for, after this event is completed.\n        '''\n        ''' my patch, serialize to redis '''\n        self.r.set(self.rhname, self.current)\n        for fnname in ['onafter' + e.event, 'on' + e.event]:\n            if hasattr(self, fnname):\n                return getattr(self, fnname)(e)", "response": "Checks to see if the callback is registered for after this event is completed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncoerce value into a string", "response": "def coerce(value):\n        \"\"\"\n        Turns value into a string\n        \"\"\"\n        if isinstance(value, StringCell):\n            return value\n        elif isinstance(value, (str, unicode)):\n            return StringCell(value)\n        else:\n            raise CoercionFailure(\"Cannot coerce %s to StringCell\" % (value))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_contradictory(self, other):\n        other = StringCell.coerce(other)\n\n        if self.value is None or other.value is None:\n            # None = empty, and won't contradict anything\n            return False\n\n        def sequence_in(s1, s2):\n            \"\"\"Does `s1` appear in sequence in `s2`?\"\"\"\n            return bool(re.search(\".*\".join(s1), s2))\n\n        return not sequence_in(self.value, other.value) and \\\n            not sequence_in(other.value, self.value)", "response": "Returns True if self and other are not contradictory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_equal(self, other):\n        other = StringCell.coerce(other)\n        empties = [None,'']\n        if self.value in empties and other.value in empties:\n            return True\n        return self.value == other.value", "response": "Returns True if the two strings are equal."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmerges two strings into this one.", "response": "def merge(self, other):\n        \"\"\"\n        Merges two strings\n        \"\"\"\n        other = StringCell.coerce(other)\n        if self.is_equal(other):\n            # pick among dependencies\n            return self\n        elif other.is_entailed_by(self):\n            return self\n        elif self.is_entailed_by(other):\n            self.value = other.value\n        elif self.is_contradictory(other):\n            raise Contradiction(\"Cannot merge string '%s' with '%s'\" % \\\n                    (self, other))\n        else:\n            self._perform_merge(other)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmerge the longer string with the current string.", "response": "def _perform_merge(self, other):\n        \"\"\"\n        Merges the longer string\n        \"\"\"\n        if len(other.value) > len(self.value):\n            self.value = other.value[:]\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_geometry(self, geo_level, geo_code):\n        mapit_level = SETTINGS['level_codes'][geo_level]\n        url = SETTINGS['url'] + '/area/MDB:%s/feature.geojson?type=%s' % (geo_code, mapit_level)\n        url = url + '&generation=%s' % SETTINGS['generation']\n        simplify = SETTINGS['level_simplify'].get(mapit_level)\n        if simplify:\n            url = url + '&simplification_level=%s' % simplify\n\n        resp = requests.get(url)\n        if resp.status_code == 404:\n            return None\n        resp.raise_for_status()\n\n        feature = resp.json()\n        shape = asShape(feature['geometry'])\n\n        return {\n            'properties': feature['properties'],\n            'shape': shape,\n        }", "response": "Get the geometry description for a geography."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of geographies containing this point.", "response": "def get_locations_from_coords(self, longitude, latitude, levels=None):\n        \"\"\"\n        Returns a list of geographies containing this point.\n        \"\"\"\n        resp = requests.get(SETTINGS['url'] + '/point/4326/%s,%s?generation=%s' % (longitude, latitude, SETTINGS['generation']))\n        resp.raise_for_status()\n\n        geos = []\n        for feature in resp.json().itervalues():\n            try:\n                geo = self.get_geography(feature['codes']['MDB'],\n                                         feature['type_name'].lower())\n\n                if not levels or geo.geo_level in levels:\n                    geos.append(geo)\n            except LocationNotFound as e:\n                log.warn(\"Couldn't find geo that Mapit gave us: %s\" % feature, exc_info=e)\n\n        return geos"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_folder(self, folder):\n        if folder in self.folders:\n            return\n\n        self.folders.add(folder)\n        \n        for subfolder, junk, filenames in os.walk(folder):\n            for filename in filenames:\n                name, ext = os.path.splitext(filename)\n                if ext in self.exts:\n                    self.images.append(\n                        os.path.join(subfolder, filename))", "response": "Add a folder scan images there"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntrying and find the image file", "response": "def interpret(self, msg):\n        \"\"\" Try and find the image file \n\n        some magic here would be good.\n\n        FIXME move elsewhere and make so everyone can use.\n\n        interpreter that finds things?\n        \"\"\"\n        for gallery in msg.get('galleries', []):\n            self.add_folder(gallery)\n            \n        image_file = msg.get('image')\n        if not image_file: return\n\n        return self.find_image(image_file)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef publisherSocket(self,\n                        port,\n                        connect=False,\n                        host='*',\n                        hwm=1):\n        '''\n        Create a PUB-style socket for data publishers.\n        If <connect> is true, connects to a XPUB/XSUB forwarding device.\n        '''\n        socket = self._context.socket(zmq.PUB)\n        socket.setsockopt(zmq.SNDHWM, hwm)\n        socket.setsockopt(zmq.LINGER, 0)\n\n        try:\n            if connect:\n                socket.connect(self.tcpAddress(host, port))\n            else:\n                socket.bind(self.tcpAddress(host, port))\n        except Exception as e:\n            newMsg= str(\"%s %s:%d\" % (str(e), host, port))\n            raise (type(e))(newMsg)\n        return socket", "response": "Create a PUB - style socket for data publishers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a SUB - style socket for data receivers.", "response": "def subscriberSocket(self, host, port, filt=b'', conflate=False):\n        '''\n        Create a SUB-style socket for data receivers\n        '''\n        socket = self._context.socket(zmq.SUB)\n        if conflate:\n            socket.setsockopt(zmq.CONFLATE, 1)\n\n        socket.connect(self.tcpAddress(host, port))\n        socket.setsockopt(zmq.SUBSCRIBE, filt)\n        return socket"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate frontend and backend sockets for a XPUB or XSUB forwarding device", "response": "def xpubsubSockets(self, hostSub, portSub, hostPub, portPub):\n        '''\n        Creates frontend and backend for a XPUB/XSUB forwarding device\n        '''\n        frontend_addr = self.tcpAddress(hostSub, portSub)\n        backend_addr = self.tcpAddress(hostPub, portPub)\n\n        frontendSocket = self._context.socket(zmq.SUB)\n        frontendSocket.bind(frontend_addr)\n        frontendSocket.setsockopt(zmq.SUBSCRIBE, b'')\n\n        backendSocket = self._context.socket(zmq.PUB)\n        backendSocket.bind(backend_addr)\n\n        return frontendSocket, backendSocket"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef replySocket(self, port, host='*'):\n        '''\n        Create a REP-style socket for servers\n        '''\n        try:\n            socket = self._context.socket(zmq.REP)\n            socket.bind(self.tcpAddress(host, port))\n        except Exception as e:\n            newMsg= str(\"%s %s:%d\" % (str(e), host, port))\n            raise (type(e))(newMsg)\n        return socket", "response": "Create a REP - style socket for servers\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends a request to the broker and receive the reply.", "response": "def sendRequest(self, socket, cmd, args=(), timeout=10):\n        '''\n        Perform client request/reply\n        Request is a ZMQ multipart message:\n         - command string\n         - pickled argument list\n        Reply is a pickled object\n        '''\n        self._logger.debug(\"sending request %s %s\" % (cmd, args))\n        t0= time.time()\n        self._sendMultiPartWithBarrierTimeout(\n            socket,\n            [cmd.encode(),\n             pickle.dumps(args, Constants.PICKLE_PROTOCOL)],\n            timeout)\n        toBeReturned= self.receiveWithTimeout(socket, timeout)\n        retObj= pickle.loads(toBeReturned, **pickle_options)\n        self._logger.debug(\"%s received %s in %.3fs\" % (\n            cmd, str(retObj), time.time() - t0))\n        if isinstance(retObj, Exception):\n            raise retObj\n        else:\n            return retObj"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef handleRequest(self, obj, socket, multi=False):\n        '''\n        Handle one or more requests on a REP socket, with the format\n        sent by sendRequest()\n        '''\n        while 1:\n            try:\n                msg = socket.recv_multipart(zmq.NOBLOCK)\n                method = msg[0].decode()\n                try:\n                    args = pickle.loads(msg[1], **pickle_options)\n                except ValueError as err:\n                    self._logger.notice('Request %s failed. Caught %s %s' %\n                                        (method, type(err), str(err)))\n                    self._sendAnswer(socket, err)\n                self._logger.debug(\"received request %s %s\" %\n                                   (method, str(args)))\n                try:\n                    res= getattr(obj, method).__call__(*args)\n                except Exception as e:\n                    self._logger.notice('Request %s %s failed. Caught %s %s' %\n                                        (method, str(args), type(e), str(e)))\n                    res= e\n                self._sendAnswer(socket, res)\n            except zmq.ZMQError:\n                return\n            except Exception as e:\n                self._logger.error(\"Unknown error %s\" % str(e))\n            if not multi:\n                break", "response": "Handle one or more requests on a REP socket."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setup(self, app):\n        super(Plugin, self).setup(app)\n        if isinstance(self.cfg['locales_dirs'], str):\n            self.cfg['locales_dirs'] = [self.cfg['locales_dirs']]\n\n        @app.manage.command(init=False)\n        def extract_messages(   # noqa\n                *dirnames, project=app.name, version=app.cfg.get('VERSION', ''), locations=True,\n                charset='utf-8', domain=self.cfg.domain, locale=self.cfg.default_locale):\n            \"\"\"Extract messages from source code.\n\n            :param charset: charset to use in the output\n            :param domain:  set domain name for locales\n            :param project: set project name in output\n            :param version: set project version in output\n            :param locations: add message locations\n            \"\"\"\n            Locale.parse(locale)\n\n            dirnames = [d for d in dirnames if os.path.isdir(d)]\n\n            catalog = Catalog(locale=locale, project=project, version=version, charset=charset)\n            for dname in dirnames:\n                for filename, lineno, message, comments, context in extract_from_dir(\n                        dname, method_map=self.cfg.sources_map, options_map=self.cfg.options_map):\n\n                    lines = []\n                    if locations:\n                        filepath = os.path.normpath(os.path.join(dname, filename))\n                        lines = [(filepath, lineno)]\n\n                    catalog.add(message, None, lines, auto_comments=comments, context=context)\n\n            locales_dir = self.cfg.locales_dirs[0]\n            output = os.path.join(locales_dir, locale, 'LC_MESSAGES', '%s.po' % domain)\n\n            if os.path.exists(output):\n                with open(output, 'rb') as f:\n                    template = read_po(f, locale=locale, charset=charset)\n                    template.update(catalog)\n                    catalog = template\n\n            if not os.path.exists(os.path.dirname(output)):\n                os.makedirs(os.path.dirname(output))\n\n            logger.info('writing PO template file to %s', output)\n            outfile = open(output, 'wb')\n\n            try:\n                write_po(outfile, catalog, include_previous=True,\n                         sort_output=not locations, sort_by_file=locations)\n            finally:\n                outfile.close()\n\n        @app.manage.command(init=False)\n        def compile_messages(use_fuzzy=False, statistics=False, domain=self.cfg.domain): # noqa\n            \"\"\"Compile messages for locales.\n\n            :param domain:  set domain name for locales\n            \"\"\"\n            for locales_dir in self.cfg.locales_dirs:\n                for locale in os.listdir(locales_dir):\n                    po_file = os.path.join(locales_dir, locale, 'LC_MESSAGES', domain + '.po')\n\n                    if not os.path.exists(po_file):\n                        continue\n\n                    with open(po_file, 'r') as po:\n                        catalog = read_po(po, locale)\n\n                    mo_file = os.path.join(locales_dir, locale, 'LC_MESSAGES', domain + '.mo')\n\n                    with open(mo_file, 'wb') as mo:\n                        logger.info('writing MO template file to %s', mo_file)\n                        write_mo(mo, catalog, use_fuzzy=use_fuzzy)", "response": "Setup the plugin s commands."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def startup(self, app):\n        self.local = slocal(app.loop)\n        if self.cfg.configure_jinja2 and 'jinja2' in app.ps:\n            app.ps.jinja2.env.add_extension('jinja2.ext.i18n')\n            app.ps.jinja2.env.install_gettext_callables(\n                lambda x: self.get_translations().ugettext(x),\n                lambda s, p, n: self.get_translations().ungettext(s, p, n),\n                newstyle=True\n            )\n\n        if self.locale_selector_func:\n            app.middlewares.append(self._middleware)", "response": "Initialize a local namespace and setup Jinja2."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_translations(self, domain=None, locale=None):\n        if locale is None:\n\n            if self.locale is None:\n                return support.NullTranslations()\n\n            locale = self.locale\n\n        if domain is None:\n            domain = self.cfg.domain\n\n        if (domain, locale.language) not in self.translations:\n            translations = None\n            for locales_dir in reversed(self.cfg.locales_dirs):\n                trans = support.Translations.load(\n                    locales_dir, locales=locale, domain=domain)\n                if translations:\n                    translations._catalog.update(trans._catalog)\n                else:\n                    translations = trans\n\n            self.translations[(domain, locale.language)] = translations\n\n        return self.translations[(domain, locale.language)]", "response": "Load translations for given or configuration domain."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef select_locale_by_request(self, request, locales=()):\n        default_locale = locales and locales[0] or self.cfg.default_locale\n\n        if len(locales) == 1 or 'ACCEPT-LANGUAGE' not in request.headers:\n            return default_locale\n\n        ulocales = [\n            (q, locale_delim_re.split(v)[0])\n            for v, q in parse_accept_header(request.headers['ACCEPT-LANGUAGE'])\n        ]\n        ulocales.sort()\n        ulocales.reverse()\n\n        for locale in locales:\n            for _, ulocale in ulocales:\n                ulocale = locale_delim_re.split(ulocale)[0]\n                if ulocale.lower() == locale.lower():\n                    return ulocale\n\n        return ulocales[0][1]", "response": "Choose an user s locale by request."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef gettext(self, string, domain=None, **variables):\n        t = self.get_translations(domain)\n        return t.ugettext(string) % variables", "response": "Translate a string with the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntranslates a string wity the current locale.", "response": "def ngettext(self, singular, plural, num, domain=None, **variables):\n        \"\"\"Translate a string wity the current locale.\n\n        The `num` parameter is used to dispatch between singular and various plural forms of the\n        message.\n\n        \"\"\"\n        variables.setdefault('num', num)\n        t = self.get_translations(domain)\n        return t.ungettext(singular, plural, num) % variables"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pgettext(self, context, string, domain=None, **variables):\n        t = self.get_translations(domain)\n        return t.upgettext(context, string) % variables", "response": "Like gettext but with a context."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nliking np. ngettext but with a context.", "response": "def npgettext(self, context, singular, plural, num, domain=None, **variables):\n        \"\"\"Like :meth:`ngettext` but with a context.\"\"\"\n        variables.setdefault('num', num)\n        t = self.get_translations(domain)\n        return t.unpgettext(context, singular, plural, num) % variables"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading the file_locations into the triplestores", "response": "def load(self, file_locations=[], **kwargs):\n        \"\"\" Loads the file_locations into the triplestores\n\n        args:\n            file_locations: list of tuples to load\n                    [('vocabularies', [list of vocabs to load])\n                     ('directory', '/directory/path')\n                     ('filepath', '/path/to/a/file')\n                     ('package_all', 'name.of.a.package.with.defs')\n                     ('package_file','name.of.package', 'filename')]\n            custom: list of custom definitions to load\n        \"\"\"\n        self.__set_cache_dir__(**kwargs)\n        conn = self.__get_conn__(**kwargs)\n        self.set_load_state(**kwargs)\n        super(DefinitionManager, self).load(file_locations, **kwargs)\n        if not file_locations:\n            file_locations = self.__file_locations__\n        if file_locations:\n            log.info(\"loading vocabs into conn '%s'\", conn)\n        for item in file_locations:\n            if item[0] == 'vocabularies':\n                vocabs = item[1]\n                if item[1] == \"all\":\n                    vocabs = self.vocab_map\n                for vocab in vocabs:\n                    self.load_vocab(vocab)\n\n        self.loaded_files(reset=True)\n        self.loaded_times = self.load_times(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_vocab(self, vocab_name, **kwargs):\n        log.setLevel(kwargs.get(\"log_level\", self.log_level))\n\n        vocab = self.get_vocab(vocab_name   , **kwargs)\n        if vocab['filename'] in self.loaded:\n            if self.loaded_times.get(vocab['filename'],\n                    datetime.datetime(2001,1,1)).timestamp() \\\n                    < vocab['modified']:\n                self.drop_file(vocab['filename'], **kwargs)\n            else:\n                return\n        conn = kwargs.get(\"conn\", self.conn)\n        conn.load_data(graph=getattr(__NSM__.kdr, vocab['filename']).clean_uri,\n                       data=vocab['data'],\n                       datatype=vocab['filename'].split(\".\")[-1],\n                       log_level=logging.WARNING)\n        self.__update_time__(vocab['filename'], **kwargs)\n        log.warning(\"\\n\\tvocab: '%s' loaded \\n\\tconn: '%s'\",\n                    vocab['filename'],\n                    conn)\n        self.loaded.append(vocab['filename'])", "response": "loads a vocabulary into the defintion triplestore"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning data stream of an rdf vocabulary", "response": "def get_vocab(self, vocab_name, **kwargs):\n        \"\"\" Returns data stream of an rdf vocabulary\n\n        args:\n            vocab_name: the name or uri of the vocab to return\n        \"\"\"\n        vocab_dict = self.__get_vocab_dict__(vocab_name, **kwargs)\n\n        filepaths = list(set([os.path.join(self.cache_dir,\n                                           vocab_dict['filename']),\n                              os.path.join(self.vocab_dir,\n                                           vocab_dict['filename'])]))\n        for path in filepaths:\n            if os.path.exists(path):\n                with open(path, 'rb') as f_obj:\n                    vocab_dict.update({\"name\": vocab_name,\n                                       \"data\": f_obj.read(),\n                                       \"modified\": os.path.getmtime(path)})\n                return vocab_dict\n        download_locs = make_list(vocab_dict.get('download',[]))\n        for loc in download_locs:\n\n            loc_web = urllib.request.urlopen(loc)\n            # loc_file_date = date_parse(loc_web.info()['Last-Modified'])\n            urllib.request.urlretrieve(loc, filepaths[0])\n            with open(filepaths[0], 'rb') as f_obj:\n                vocab_dict.update({\"name\": vocab_name,\n                                   \"data\": f_obj.read(),\n                                   \"modified\": os.path.getmtime(filepaths[0])})\n                return vocab_dict"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef drop_vocab(self, vocab_name, **kwargs):\n        vocab_dict = self.__get_vocab_dict__(vocab_name, **kwargs)\n        return self.drop_file(vocab_dict['filename'], **kwargs)", "response": "Removes the vocab from the definiton triplestore"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef quick(config, mysterious=None, only_authenticated=None):\n\n    def decorator(func):\n\n        @wraps(func)\n        def _quick(request, *args, **kwargs):\n            # Check if the request is ajax.\n            is_ajax = request.is_ajax()\n\n            # Check if the config is available globally and return '' or raise\n            # 404 as per the nature of the request.\n            if not config:\n                return _return_blank_or_raise_404(is_ajax)\n            callable_name = None\n            _only_authenticated = None\n\n            if mysterious is not None:\n                if type(mysterious) == bool:\n                    _only_authenticated = mysterious\n                else:\n                    callable_name = mysterious\n            elif only_authenticated is not None:\n                _only_authenticated = only_authenticated\n\n            user = request.user\n            if callable_name is None:\n                if (_only_authenticated is not None and\n                        _only_authenticated and\n                        not user.is_authenticated()):\n                    return _return_blank_or_raise_404(is_ajax)\n                else:\n                    return func(request, *args, **kwargs)\n            else:\n                if not user.is_authenticated():\n                    return _return_blank_or_raise_404(is_ajax)\n                else:\n                    _callable = function_from_string(callable_name)\n                    if user.id in _callable():\n                        return func(request, *args, **kwargs)\n                    return _return_blank_or_raise_404(is_ajax)\n            return _return_blank_or_raise_404(is_ajax)\n        return _quick\n    return decorator", "response": "Decorator to make a quick view of the user s users."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ha_get_delay_policy(self, config_name):\n        config = self.ha_get_config(config_name)\n        delay_policy_conf = config.delay_config\n        delay_policy_conf = copy.deepcopy(delay_policy_conf)\n        delay_policy_conf.update(delay=config.delay)\n        return self._retry_delays_class.get(\n            config.delay_policy,\n            **delay_policy_conf\n        )", "response": "Build generator of delays to wait between each call\nTaxonomy"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_python(self, value):\n        if self.blank and not value:\n            return {}\n        value = value or '{}'\n        if isinstance(value, six.binary_type):\n            value = six.text_type(value, 'utf-8')\n        if isinstance(value, six.string_types):\n            try:\n                # with django 1.6 i have '\"{}\"' as default value here\n                if value[0] == value[-1] == '\"':\n                    value = value[1:-1]\n\n                return json.loads(value)\n            except Exception as err:\n                raise ValidationError(str(err))\n        else:\n            return value", "response": "Convert the input JSON value into python structures."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate(self, value, model_instance):\n        if isinstance(value, six.string_types):\n            super(JSONField, self).validate(value, model_instance)\n            try:\n                json.loads(value)\n            except Exception as err:\n                raise ValidationError(str(err))", "response": "Check value is a valid JSON string raise ValidationError on\n            error."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_prep_value(self, value):\n        try:\n            return json.dumps(value)\n        except Exception as err:\n            raise ValidationError(str(err))", "response": "Convert value to JSON string before save"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef value_to_string(self, obj):\n        value = getattr(obj, self.attname)\n        return self.get_prep_value(value)", "response": "Return value from object converted to string properly"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning down migration with name or numeric id matching arg", "response": "def do_down(self, arg):\n        \"\"\"Run down migration with name or numeric id matching arg\"\"\"\n        print \"running down migration\"\n        self.manager.run_one(arg, Direction.DOWN)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef do_up(self, arg):\n        print \"running up migration\"\n        self.manager.run(arg, Direction.UP)", "response": "Run up migration with name or numeric id matching arg"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates exception subclass. If 'attached_to' is supplied, the exception will be created in a way that allows it to be pickled, assuming the returned exception class will be added as an attribute to the 'attached_to' class.", "response": "def subclass_exception(name, parents, module, attached_to=None):\n    \"\"\"\n    Create exception subclass.\n\n    If 'attached_to' is supplied, the exception will be created in a way that\n    allows it to be pickled, assuming the returned exception class will be added\n    as an attribute to the 'attached_to' class.\n    \"\"\"\n    class_dict = {'__module__': module}\n    if attached_to is not None:\n        def __reduce__(self):\n            # Exceptions are special - they've got state that isn't\n            # in self.__dict__. We assume it is all in self.args.\n            return (unpickle_inner_exception, (attached_to, name), self.args)\n\n        def __setstate__(self, args):\n            self.args = args\n\n        class_dict['__reduce__'] = __reduce__\n        class_dict['__setstate__'] = __setstate__\n\n    return type(name, parents, class_dict)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a set of all the files under git control", "response": "def all_files(self):\n        \"\"\"Return a set of all the files under git control\"\"\"\n        return set([entry.decode() for entry, _ in self.git.open_index().items()])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nyield the commit times for all the files in the current branch.", "response": "def file_commit_times(self, use_files_paths, debug=False):\n        \"\"\"\n        Traverse the commits in the repository, starting from HEAD until we have\n        found the commit times for all the files we care about.\n\n        Yield each file once, only when it is found to be changed in some commit.\n\n        If self.debug is true, also output log.debug for the speed we are going\n        through commits (output commits/second every 1000 commits and every\n        100000 commits)\n        \"\"\"\n        prefixes = PrefixTree()\n        prefixes.fill(use_files_paths)\n\n        for entry in self.git.get_walker():\n            # Commit time taking into account the timezone\n            commit_time = entry.commit.commit_time - entry.commit.commit_timezone\n\n            # Get us the two different tree structures between parents and current\n            cf_and_pf, changes = self.tree_structures_for(()\n                , entry.commit.tree\n                , [self.git.get_object(oid).tree for oid in entry.commit.parents]\n                , prefixes\n                )\n\n            # Deep dive into any differences\n            difference = []\n            if changes:\n                cfs_and_pfs = [(cf_and_pf, changes)]\n                while cfs_and_pfs:\n                    nxt, changes = cfs_and_pfs.pop(0)\n                    for thing, changes, is_path in self.differences_between(nxt[0], nxt[1], changes, prefixes):\n                        if is_path:\n                            found = prefixes.remove(thing[:-1], thing[-1])\n                            if found:\n                                difference.append('/'.join(thing))\n                        else:\n                            cfs_and_pfs.append((thing, changes))\n\n            # Only yield if there was a difference\n            if difference:\n                yield entry.commit.sha().hexdigest(), commit_time, difference\n\n            # If nothing remains, then break!\n            if not prefixes:\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef entries_in_tree_oid(self, prefix, tree_oid):\n        try:\n            tree = self.git.get_object(tree_oid)\n        except KeyError:\n            log.warning(\"Couldn't find object {0}\".format(tree_oid))\n            return empty\n        else:\n            return frozenset(self.entries_in_tree(prefix, tree))", "response": "Find the tree at this oid and return entries prefixed with prefix"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef entries_in_tree(self, prefix, tree):\n        for entry in tree.items():\n            if prefix:\n                new_prefix = prefix + (entry.path.decode(), )\n            else:\n                new_prefix = (entry.path.decode(), )\n\n            yield (new_prefix, stat.S_ISDIR(entry.mode), entry.sha)", "response": "Iterate over the entries in the tree and yield a tuple of the prefix is_tree oid and the name of the entry."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tree_structures_for(self, prefix, current_oid, parent_oids, prefixes):\n        if prefix and prefixes and prefix not in prefixes:\n            return empty, empty\n\n        parent_files = set()\n        for oid in parent_oids:\n            parent_files.update(self.entries_in_tree_oid(prefix, oid))\n\n        current_files = self.entries_in_tree_oid(prefix, current_oid)\n        return (current_files, parent_files), (current_files - parent_files)", "response": "Return the entries for this commit and parent commits and the difference between the two."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nyielding the differences between two sets of tree entries.", "response": "def differences_between(self, current_files, parent_files, changes, prefixes):\n        \"\"\"\n        yield (thing, changes, is_path)\n\n        If is_path is true, changes is None and thing is the path as a tuple.\n\n        If is_path is false, thing is the current_files and parent_files for\n        that changed treeentry and changes is the difference between current_files\n        and parent_files.\n\n        The code here is written to squeeze as much performance as possible out\n        of this operation.\n        \"\"\"\n        parent_oid = None\n\n        if any(is_tree for _, is_tree, _ in changes):\n            if len(changes) == 1:\n                wanted_path = list(changes)[0][0]\n                parent_oid = frozenset([oid for path, is_tree, oid in parent_files if path == wanted_path and is_tree])\n            else:\n                parent_values = defaultdict(set)\n                parent_changes = parent_files - current_files\n                for path, is_tree, oid in parent_changes:\n                    if is_tree:\n                        parent_values[path].add(oid)\n\n        for path, is_tree, oid in changes:\n            if is_tree and path not in prefixes:\n                continue\n\n            if not is_tree:\n                yield path, None, True\n            else:\n                parent_oids = parent_oid if parent_oid is not None else parent_values.get(path, empty)\n                cf_and_pf, changes = self.tree_structures_for(path, oid, parent_oids, prefixes)\n                if changes:\n                    yield cf_and_pf, changes, False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an installer instance for the given version of the current version.", "response": "def dev_tools_installer(cv, ctx, site):\n    \"\"\"\n    Installer factory\n    @param  cv: Current version (The version of Developer Tools we are installing)\n    @type   cv: ips_vagrant.common.version.Version\n    @return:    Installer instance\n    @rtype:     ips_vagrant.installer.dev_tools.latest.DevToolsInstaller\n    \"\"\"\n    log = logging.getLogger('ipsv.installer.dev_tools')\n    log.info('Loading installer for Dev Tools %s', cv)\n    iv = None\n    for v in versions:\n        vstring = '.'.join(map(str, v)) if v else 'latest'\n        # cvstring = '.'.join(map(str, cv)) if cv else 'latest'\n        log.debug('Checking if version %s >= %s', vstring, cv.vstring)\n        if (v is None) or (v >= cv):\n            log.debug('Changing installer version to %s', vstring)\n            iv = v\n\n    log.info('Returning installer version %s', '.'.join(map(str, iv)) if iv else 'latest')\n    return versions[iv](ctx, site)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ignite(self, args=None):\n        if args is None:\n            args = sys.argv[1:]\n\n        if os.environ.get(\"MANAGED_VIRTUALENV\", None) != \"1\":\n            made = self.make_virtualenv()\n\n            if made or os.environ.get(\"VENV_STARTER_CHECK_DEPS\", None) != \"0\":\n                self.install_deps()\n\n        self.start_program(args)", "response": "Ignite the current process."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nannotate a function by adding the given arguments to the ARGPARSE_ARGS_LIST attribute.", "response": "def arg(*args, **kwargs):\n    \"\"\"Annotate a function by adding the args/kwargs to the meta-data.\n\n    This appends an Argparse \"argument\" to the function's\n    ``ARGPARSE_ARGS_LIST`` attribute, creating ``ARGPARSE_ARGS_LIST`` if it\n    does not already exist.  Aside from that, it returns the decorated function\n    unmodified, and unwrapped.\n\n    The \"arguments\" are simply ``(args, kwargs)`` tuples which will be passed\n    to the Argparse parser created from the function as\n    ``parser.add_argument(*args, **kwargs)``.\n\n    `argparse.ArgumentParser.add_argument\n    <https://docs.python.org/2/library/argparse.html#the-add-argument-method>`_\n    should be consulted for up-to-date documentation on the accepted arguments.\n    For convenience, a list has been included here.\n\n    Args\n    ----\n    name/flags : str or list\n        Either a name or a list of (positional) option strings, e.g. ('foo') or\n        ('-f', '--foo').\n    action : str\n        The basic type of action to be taken when this argument is encountered\n        at the command line.\n    nargs : str\n        The number of command-line arguments that should be consumed.\n    const\n        A constant value required by some action and nargs selections.\n    default\n        The value produced if the argument is absent from the command line.\n    type : type\n        The type to which the command-line argument should be converted.\n    choices\n        A container of the allowable values for the argument.\n    required : bool\n        Whether or not the command-line option may be omitted (optionals only).\n    help : str\n        A brief description of what the argument does.\n    metavar : str\n        A name for the argument in usage messages.\n    dest : str\n        The name of the attribute to be added to the object returned by\n        parse_args().\n\n    Example\n    -------\n    .. testsetup::\n\n       mycommand = Command(name='mycommand')\n\n    .. testcode::\n\n        @command(name='echo')\n        @arg('-n', '--num', type=int, default=42)\n        @arg('-s', '--some-switch', action='store_false')\n        @arg('foo')\n        def echo(foo, num, some_switch):\n            print foo, num\n\n    .. doctest::\n\n       >>> echo_subcommand = mycommand.add_subcommand(echo)\n       >>> mycommand.init()\n       >>> mycommand.parse_args(['echo', 'hi', '-n', '42'])\n       hi 42\n\n    See also\n    --------\n    `argparse.ArgumentParser.add_argument\n    <https://docs.python.org/2/library/argparse.html#the-add-argument-method>`_\n\n    \"\"\"\n    def annotate(func):\n        # Get the list of argparse args already added to func (if any).\n        argparse_args_list = getattr(func, 'ARGPARSE_ARGS_LIST', [])\n        # Since we're only annotating (not wrapping) the function, appending\n        # the argument to the list would result in the decorators being applied\n        # in reverse order.  To prevent that, we simply add to the beginning.\n        argparse_args_list.insert(0, (args, kwargs))\n        setattr(func, 'ARGPARSE_ARGS_LIST', argparse_args_list)\n        return func\n    return annotate"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a docstring into title and description.", "response": "def _parse_doc(doc=''):\n    \"\"\"Parse a docstring into title and description.\n\n    Args\n    ----\n    doc : str\n        A docstring, optionally with a title line, separated from a description\n        line by at least one blank line.\n\n    Returns\n    -------\n    title : str\n        The first line of the docstring.\n    description : str\n        The rest of a docstring.\n\n    \"\"\"\n    title, description = '', ''\n    if doc:\n        sp = doc.split('\\n', 1)\n        title = sp[0].strip()\n        if len(sp) > 1:\n            description = textwrap.dedent(sp[1]).strip()\n    return (title, description)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef command(name):\n    # TODO(nick): It would be nice if this didn't transform the handler.  That\n    #   way, handlers could be used and tested independently of this system.\n    #   Unfortunately that's one of the better properties of the previous\n    #   system that wasn't preserved in this rewrite.\n    def wrapper(func):\n        title, description = _parse_doc(func.__doc__)\n        command = Command(name=name, title=title, description=description)\n        command.add_handler(func)\n        argparse_args_list = getattr(func, 'ARGPARSE_ARGS_LIST', [])\n        for args, kwargs in argparse_args_list:\n            command.add_argument_tuple((args, kwargs))\n        return command\n    return wrapper", "response": "Decorator to create a new Command instance with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_command(parent_command, name):\n    def wrapper(func):\n        c = command(name)(func)\n        parent_command.add_subcommand(c)\n    return wrapper", "response": "Create and register a command with a parent command."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_handler(self, namespace, remove_handler=False):\n        if hasattr(namespace, '_func'):\n            _func = namespace._func\n            if remove_handler:\n                del namespace._func\n            return _func", "response": "Get a handler function from a namespace."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds the registered arguments to the parser.", "response": "def _attach_arguments(self):\n        \"\"\"Add the registered arguments to the parser.\"\"\"\n        for arg in self.arguments:\n            self.parser.add_argument(*arg[0], **arg[1])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _attach_subcommands(self):\n        if self.subcommands:\n            self.subparsers = self.parser.add_subparsers()\n\n            for subcommand in self.subcommands:\n                subparser = self.subparsers.add_parser(subcommand.name,\n                                                       help=subcommand.title)\n                if subcommand.handler:\n                    self._register_handler(subparser, subcommand.handler)\n                subcommand._init(subparser)", "response": "Create a subparser and add the registered commands to it."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the parser and all the related commands.", "response": "def _init(self, parser):\n        \"\"\"Initialize/Build the ``argparse.ArgumentParser`` and subparsers.\n\n        This internal version of ``init`` is used to ensure that all\n        subcommands have a properly initialized parser.\n\n        Args\n        ----\n        parser : argparse.ArgumentParser\n            The parser for this command.\n\n        \"\"\"\n        assert isinstance(parser, argparse.ArgumentParser)\n        self._init_parser(parser)\n\n        self._attach_arguments()\n        self._attach_subcommands()\n        self.initialized = True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing the command - line arguments and call the associated handler.", "response": "def parse_args(self, args=None, namespace=None):\n        \"\"\"Parse the command-line arguments and call the associated handler.\n\n        The signature is the same as `argparse.ArgumentParser.parse_args\n        <https://docs.python.org/2/library/argparse.html#argparse.ArgumentParser.parse_args>`_.\n\n        Args\n        ----\n        args : list\n            A list of argument strings.  If ``None`` the list is taken from\n            ``sys.argv``.\n        namespace : argparse.Namespace\n            A Namespace instance.  Defaults to a new empty Namespace.\n\n        Returns\n        -------\n        The return value of the handler called with the populated Namespace as\n        kwargs.\n\n        \"\"\"\n        assert self.initialized, '`init` must be called before `parse_args`.'\n        namespace = self.parser.parse_args(args, namespace)\n        handler = self._get_handler(namespace, remove_handler=True)\n        if handler:\n            return handler(**vars(namespace))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list(options):\n    configuration = config.get_default()\n    app_url = configuration['app_url']\n\n    if options.deployment != None:\n        deployment_name = options.deployment\n    else:\n        deployment_name = configuration['deployment_name']\n\n    client_id = configuration['client_id']\n    client_secret = configuration['client_secret']\n\n    token_manager = auth.TokenManager(client_id=client_id,\n                                      client_secret=client_secret,\n                                      app_url=app_url)\n\n    jobs = data_engine.get_jobs(deployment_name,\n                                token_manager=token_manager,\n                                app_url=app_url)\n\n\n    if len(jobs) == 0:\n        error('No running jobs')\n\n    else:\n        _print_jobs(jobs, token_manager, app_url, options)", "response": "List all currently running jobs"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef kill(options):\n    configuration = config.get_default()\n    app_url = configuration['app_url']\n\n    if options.deployment != None:\n        deployment_name = options.deployment\n    else:\n        deployment_name = configuration['deployment_name']\n\n    client_id = configuration['client_id']\n    client_secret = configuration['client_secret']\n\n    token_manager = auth.TokenManager(client_id=client_id,\n                                      client_secret=client_secret,\n                                      app_url=app_url)\n\n    job_details = data_engine.get_job_details(options.job_id,\n                                              deployment_name,\n                                              token_manager=token_manager,\n                                              app_url=app_url)\n\n    options.format = 'table'\n\n    if options.yes:\n        decision = 'Y'\n    else:\n        _print_jobs([job_details], token_manager, app_url, options)\n        decision = prompt('Are you sure you want to delete the above job? (Y/N)')\n\n    if decision == 'Y':\n        data_engine.delete_job(options.job_id.strip(),\n                               deployment_name,\n                               token_manager=token_manager,\n                               app_url=app_url)\n\n    else:\n        raise JutException('Unexpected option \"%s\"' % decision)", "response": "kill a specific job by id"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, key):\n\n        if not key in self._actions:\n            return None\n        if not key in self._cache:\n            self._cache[key] = self._actions[key]()\n\n        return self._cache[key]", "response": "Gets the callable registered at the specified key and returns the value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nregister a callable with the specified key.", "response": "def register(self, key, value):\n        \"\"\" Registers a callable with the specified key.\n\n            `key`\n                String key to identify a callable.\n            `value`\n                Callable object.\n            \"\"\"\n\n        self._actions[key] = value\n\n        # invalidate cache of results for existing key\n        if key in self._cache:\n            del self._cache[key]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef deregister(self, key):\n\n        if not key in self._actions:\n            return False\n\n        del self._actions[key]\n\n        if key in self._cache:\n            del self._cache[key]\n\n        return True", "response": "Deregisters an existing key. Returns boolean."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the callable registered at the specified key and returns the type info of the callable.", "response": "def get(self, key):\n        \"\"\" Executes the callable registered at the specified key and returns\n            its value along with type info. Subsequent queries are cached\n            internally.\n\n            `key`\n                String key for a previously stored callable.\n            \"\"\"\n\n        obj = super(ExtRegistry, self).get(key)\n        if obj is None:\n            return obj\n\n        return (obj, self._type_info.get(key))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nregister a callable with the specified key and type info.", "response": "def register(self, key, value, type_info):\n        \"\"\" Registers a callable with the specified key and type info.\n\n            `key`\n                String key to identify a callable.\n            `value`\n                Callable object.\n            `type_info`\n                Dictionary with type information about the value provided.\n            \"\"\"\n\n        # check for existing action\n        old_action = self._actions.get(key)\n\n        # update existing type info if value hasn't changed\n        if old_action == value and key in self._type_info:\n            self._type_info[key].update(type_info)\n        else:\n            self._type_info[key] = dict(type_info)\n\n        super(ExtRegistry, self).register(key, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dijkstra(G, start, weight='weight'):\r\n    if start not in G.vertices:\r\n        raise GraphInsertError(\"Vertex %s doesn't exist.\" % (start,))\r\n    visited = {start: 0}\r\n    path = {}\r\n    vertices = set(G.vertices.keys())\r\n    while vertices:\r\n        min_vertex = None\r\n        for vertex in vertices:\r\n            if vertex in visited:\r\n                if min_vertex is None or visited[vertex] < visited[min_vertex]:\r\n                    min_vertex = vertex\r\n        if min_vertex is None:\r\n            break\r\n        vertices.remove(min_vertex)\r\n        current_weight = visited[min_vertex]\r\n        for edge in G.vertices[min_vertex]:\r\n            edge_weight = current_weight + G.edges[(min_vertex, edge)][weight]\r\n            if edge not in visited or edge_weight < visited[edge]:\r\n                visited[edge] = edge_weight\r\n                path[edge] = min_vertex\r\n    return visited, path", "response": "Returns a function that returns a tuple of the shortest path length between satrt\r\nInsights and all other reachable nodes for a weight graph."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dijkstra_single_path_length(G, start, end):\r\n    if start not in G.vertices:\r\n        raise GraphInsertError(\"Vertex %s doesn't exist.\" % (start,))\r\n    if end not in G.vertices:\r\n        raise GraphInsertError(\"Vertex %s doesn't exist.\" % (end,))\r\n    dijkstra_data = dijkstra(G, start)\r\n    length = dijkstra_data[0][end]\r\n    path = [end]\r\n    current = end\r\n    while current is not start:\r\n        for vertex in dijkstra_data[1]:\r\n            if vertex is current:\r\n                path.append(dijkstra_data[1][vertex])\r\n                current = dijkstra_data[1][vertex]\r\n                break\r\n    return length, path", "response": "Compute shortest path length between start and end for a weight graph."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialize and runs an extractor", "response": "def run_extractor(*args, **kwargs):\n    \"\"\"\n    Initializes and runs an extractor\n    \"\"\"\n    # pdb.set_trace()\n    extractor = Extractor(*args, **kwargs)\n    result = extractor.run(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning the extractor for the base class.", "response": "def run(self, tag=None, output=None, **kwargs):\n        \"\"\"\n        runs the extractor\n\n        Args:\n        -----\n            output: ['filepath', None]\n\n        \"\"\"\n        start = datetime.datetime.now()\n        count = 0\n        if tag:\n            tag = Uri(tag)\n            xml_generator = etree.iterparse(self.source,\n                                            #events=(\"start\", \"end\"),\n                                            tag=tag.etree)\n        else:\n            xml_generator = etree.iterparse(self.source) #,\n                                            #events=(\"start\", \"end\"))\n        i = 0\n        for event, element in xml_generator:\n            type_tags = element.findall(_RDF_TYPE_TAG)\n            rdf_types = [el.get(_RES_TAG)\n                         for el in type_tags\n                         if el.get(_RES_TAG)]\n            # print(rdf_types)\n            if str(self.filter_val) in rdf_types:\n                pdb.set_trace()\n                # print(\"%s - %s - %s - %s\" % (event,\n                #                              element.tag,\n                #                              element.attrib,\n                #                              element.text))\n                count += 1\n            # if i == 100:\n            #     break\n            i += 1\n            element.clear()\n        print(\"Found '{}' items in {}\".format(count,\n                (datetime.datetime.now() - start)))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef exc_info(hide_calls = 0):\n    '''as sys.exc_info() but returns a remote exception object'''\n    ErrorType, thrownError, traceback = sys.exc_info()\n    for i in range(hide_calls):\n        if traceback.tb_next:\n            traceback = traceback.tb_next\n    err = withTracebackPrint(ErrorType, thrownError, traceback)\n    return type(err), err, traceback", "response": "as sys. exc_info but returns a remote exception object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn an Exception object for the given ErrorType of the thrownError and the _traceback can be used like withTracebackPrint", "response": "def withTracebackPrint(ErrorType, thrownError, _traceback):\n    '''returns an Exception object for the given ErrorType of the thrownError\nand the _traceback\n\ncan be used like withTracebackPrint(*sys.exc_info())'''\n    file = StringIO.StringIO()\n    traceback.print_exception(ErrorType, thrownError, _traceback, file = file)\n    return _loadError(ErrorType, thrownError, file.getvalue())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new RemoteExceptionType from a given errortype", "response": "def _newRemoteException(ErrorType):\n    '''create a new RemoteExceptionType from a given errortype'''\n    RemoteErrorBaseType = _RemoteExceptionMeta('', (ErrorType,), {})\n    class RemoteException(RemoteErrorBaseType):\n        BaseExceptionType = ErrorType\n\n        def __init__(self, thrownError, tracebackString):\n            self.thrownError = thrownError\n            self.tracebackString = tracebackString\n            RemoteErrorBaseType.__init__(self, *thrownError.args)\n\n        loadError = staticmethod(_loadError)\n\n        def __str__(self):\n            return '\\n%s\\n%s' % (self.tracebackString, self.thrownError)\n\n        def __reduce__(self):\n            args = (ErrorType, self.thrownError, self.tracebackString)\n            return self.loadError, args\n    RemoteException.__name__ = 'Remote' + ErrorType.__name__\n    return RemoteException"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the remote exception version of the error above you can catch errors as usally", "response": "def asRemoteException(ErrorType):\n    '''return the remote exception version of the error above\nyou can catch errors as usally:\n>>> try:\nraise asRemoteException(ValueError)\nexcept ValueError:\npass\nor you can catch the remote Exception\n>>> try:\nraise asRemoteException(ReferenceError)(ReferenceError(),'')\nexcept asRemoteException(ReferenceError):\npass\n'''\n    RemoteException = _remoteExceptionCache.get(ErrorType)\n    if RemoteException is None:\n        RemoteException = _newRemoteException(ErrorType)\n        _remoteExceptionCache.setdefault(ErrorType, RemoteException)\n        _remoteExceptionCache.setdefault(RemoteException, RemoteException)\n        return _remoteExceptionCache.get(ErrorType)\n    return RemoteException"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef template_response(self, name, context=None, content_type='text/html', code=200, minify=True):\n        context = OrderedDict(context or {})\n        context['json'] = json\n        context['full_url_for'] = full_url_for\n\n        utf8 = render_template(name, **context)\n        if minify:\n            mini = htmlmin.minify(utf8, remove_comments=True, remove_empty_space=True, remove_all_empty_space=True, reduce_boolean_attributes=True, remove_optional_attribute_quotes=True)\n        else:\n            mini = utf8\n\n        return Response(mini, headers={\n            'Content-Type': content_type,\n            'Content-Encoding': 'UTF-8',\n        }, status=code)", "response": "Returns a Response object that can be used to serve a template file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_json_request(self):\n        content_type = request.headers.get('Content-Type', 'text/plain')\n        if content_type not in ('application/json', 'text/json'):\n            self.log.error('get_json_request() called in a request that does not have a json content-type: %s. Refusing to parse the request data', content_type)\n            return {}\n\n        try:\n            data = json.loads(request.data)\n        except ValueError:\n            self.log.exception(\n                \"Trying to parse json body in the %s to %s\",\n                request.method, request.url,\n            )\n            data = {}\n\n        return data", "response": "This method is used to parse a proper json request."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef handle_exception(self, e):\n        sys.stderr.write(\"p4rr0t007 handled an error:\")\n        sys.stderr.write(traceback.format_exc(e))\n        sys.stderr.flush()\n\n        self.log.exception('failed to handle {} {}'.format(request.method, request.url))\n        try:\n            return self.template_response(self.error_template_name, code=500)\n        except TemplateError as e:\n            sys.stderr.write('failed render the {}/{}'.format(self.template_folder, self.error_template_name))\n            sys.stderr.write(traceback.format_exc(e))\n\n        sys.stderr.flush()\n        return self.text_response('5ERV3R 3RR0R')", "response": "called by flask when an exception occurs. p4rr0t007 always returns\n        a 500. html response that must exist under the given template_folder constructor param."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef button_input(self, title, message, buttons, default, timeout=None, dimensions=None):\n        '''\n        Function to accept input in the form of a button click.\n        '''\n\n        # Create the dialog box\n        self.response = default\n        self.top = tkinter.Tk()\n        self.top.title(title)\n\n        # Use dimensions if passes\n        if dimensions is not None:\n            self.top.minsize(width=dimensions[0], height=dimensions[1])\n            self.top.maxsize(width=dimensions[0], height=dimensions[1])\n\n        # Display a message\n        labelString = tkinter.StringVar()\n        labelString.set(message)\n        label = tkinter.Label(self.top, textvariable=labelString, relief=tkinter.RAISED)\n        label.pack(ipadx=100, ipady=10)\n\n        # Populate dialog box with buttons\n        for key in buttons.keys():\n            button = tkinter.Button(self.top, text=buttons[key], command=lambda key=key: self.selected(key))\n            button.pack(fill='both', pady=5, padx=10)\n\n        # Destroy the dialog box if there has been no button click within the timeout period\n        if timeout != None:\n            try:\n                self.top.after(timeout, lambda: self.top.destroy())\n            except:\n                pass\n\n        self.top.mainloop()\n        return self.response", "response": "Function to accept input in the form of a button click."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a WSGI filter app for use with paste. deploy.", "response": "def filter_factory(global_conf, **local_conf):\n    \"\"\"Returns a WSGI filter app for use with paste.deploy.\"\"\"\n    conf = global_conf.copy()\n    conf.update(local_conf)\n\n    def blacklist(app):\n        return BlacklistFilter(app, conf)\n    return blacklist"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsorts of based off of an answer about rate limiting on Stack Overflow. Definitely **not** thread safe, so don't even think about it, buddy.", "response": "def rate_limited(max_per_second):\n    \"\"\" Sort of based off of an answer about\n        rate limiting on Stack Overflow.\n\n        Definitely **not** thread safe, so\n        don't even think about it, buddy.\n    \"\"\"\n    import datetime\n    min_request_time = datetime.timedelta(seconds=max_per_second)\n    last_time_called = [None]\n    def decorate(func):\n        def rate_limited_function(*args, **kwargs):\n            if last_time_called[0]:\n                delta = datetime.datetime.now() - last_time_called[0]\n                if delta < datetime.timedelta.min:\n                    raise chrw.exceptions.TimeIsBackToFront, \"Call the Doc!\"\n                elif delta < min_request_time:\n                    msg = \"Last request was {0}, should be at least {1}\".format(\n                        delta, min_request_time\n                    )\n                    raise chrw.exceptions.RequestRateTooHigh, msg\n            ret = func(*args, **kwargs)\n            last_time_called[0] = datetime.datetime.now()\n            return ret\n        return functools.update_wrapper(rate_limited_function, func)\n    return decorate"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef shorten(self, url, custom=None, give_delete=True):\n        data = self.fetch(\"/submit\", {\n            \"long\": url,\n            \"short\": custom if custom else \"\",\n            \"delete\": \"true\" if give_delete else \"\"\n        })\n\n        return data", "response": "Shortens a URL to the API."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrequesting a URL be deleted. This will only work if you supply the valid deletion code. :param url: the shortened url to delete :type url: str :param code: the deletion code given to you on URL shorten :type code: str :return: the deletion request's reply dict :rtype: dict", "response": "def delete(self, url, code):\n        \"\"\"\n            Request a URL be deleted.\n\n            This will only work if you supply the valid deletion code.\n\n            :param url: the shortened url to delete\n            :type url: str\n            :param code: the deletion code given to you on URL shorten\n            :type code: str\n            :return: the deletion request's reply dict\n            :rtype: dict\n        \"\"\"\n        data = self.fetch(\"/delete\", {\n            \"short\": url,\n            \"delete\": code\n        })\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef watch(path, handler):\n    # let the user just deal with events\n    @functools.wraps(handler)\n    def wrapper(self, event):\n        if not event.is_directory:\n            return handler(event.event_type, event.src_path)\n    attrs = {'on_any_event': wrapper}\n    EventHandler = type(\"EventHandler\", (FileSystemEventHandler,), attrs)\n    observer = Observer()\n    observer.schedule(EventHandler(), path=path, recursive=True)\n    observer.start()\n    try:\n        while True:\n            time.sleep(1)\n    except KeyboardInterrupt:\n        observer.stop()\n    observer.join()", "response": "Watch a directory for events."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrotates 90 degrees clockwise shift times.", "response": "def rotate(self, shift):\n        '''\n        Rotate 90 degrees clockwise `shift` times.  If `shift` is negative,\n        rotate counter-clockwise.\n        '''\n        self.child_corners.values[:] = np.roll(self.child_corners\n                                                 .values, shift, axis=0)\n        self.update_transform()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the length of the message in a random unicode mixed text.", "response": "def message_length(message):\n    '''\n    message_length returns visual length of message.\n    Ascii chars are counted as 1, non-asciis are 2.\n\n    :param str message: random unicode mixed text\n    :rtype: int\n    '''\n    length = 0\n    for char in map(east_asian_width, message):\n        if char == 'W':\n            length += 2\n        elif char == 'Na':\n            length += 1\n\n    return length"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a suddendeath message string", "response": "def suddendeathmessage(message):\n    '''\n    suddendeathmessage returns \"\u7a81\u7136\u306e\u6b7b\" like ascii art decorated message string.\n\n    :param str message: random unicode mixed text\n    :rtype: str\n    '''\n    msg_len = message_length(message)\n    header_len = msg_len // 2 + 2\n    footer_len = (msg_len // 2) * 2 + 1\n    footer_pattern = cycle([\"Y\", \"^\"])\n\n    header = \"\uff3f\" + \"\u4eba\" * header_len + \"\uff3f\"\n    footer = \"\uffe3\"\n    for _ in range(footer_len):\n        footer += next(footer_pattern)\n    footer += \"\uffe3\"\n\n    middle = \"\uff1e\u3000\" + message + \"\u3000\uff1c\"\n    return \"\\n\".join([header, middle, footer])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters a migration function", "response": "def migration(resource, version, previous_version=''):\n    \"\"\"Register a migration function\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            migrated = func(*args, **kwargs)\n\n            return migrated\n\n        m = Migration(wrapper, resource, version, previous_version)\n        m.register()\n\n        return m\n\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create(resource_path, previous_version=None, package='perch.migrations'):\n    pkg, obj = resource_path.rsplit('.', 1)\n    module = importlib.import_module(pkg)\n    resource = getattr(module, obj)\n    version = uuid4().hex\n    target_module = importlib.import_module(package)\n    target_dir = os.path.dirname(target_module.__file__)\n    target_file = os.path.join(target_dir, resource.resource_type + '_' + version + '.py')\n\n    with open(target_file, 'w') as f:\n        f.write(MIGRATION_TEMPLATE.format(\n            resource_path=resource_path,\n            resource_type=resource.resource_type,\n            version=version,\n            previous_version=previous_version or '',\n        ))\n\n    return target_file", "response": "Create a new migration"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nimports all modules inside the perch. migrations package and returns the available migrations", "response": "def collect(package='perch.migrations'):\n    \"\"\"\n    Import all modules inside the perch.migrations package and return the\n    registered migrations\n    \"\"\"\n    package = importlib.import_module(package)\n\n    for loader, name, is_pkg in pkgutil.walk_packages(package.__path__):\n        importlib.import_module(package.__name__ + '.' + name)\n\n    return _migrations"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning migrations for a resource type", "response": "def run_migrations(migrations):\n    \"\"\"\n    Run migrations for a resource type\n\n    :param: a dicitionary of migrations\n    \"\"\"\n    for resource, resource_migrations in migrations.items():\n        for version in resource_migrations:\n            to_migrate = yield resource_version.get(\n                key=[resource.resource_type, version],\n                include_docs=True)\n\n            for x in to_migrate['rows']:\n                instance = resource(**x['doc'])\n                instance = _migrate_resource(\n                    instance,\n                    resource_migrations,\n                    version\n                )\n\n                yield instance._save()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmigrating a resource instance recursively", "response": "def _migrate_resource(instance, migrations, version=''):\n    \"\"\"\n    Migrate a resource instance\n\n    Subresources are migrated first, then the resource is recursively migrated\n\n    :param instance: a perch.Document instance\n    :param migrations: the migrations for a resource\n    :param version: the current resource version to migrate\n    \"\"\"\n    if version not in migrations:\n        return instance\n\n    instance = _migrate_subresources(\n        instance,\n        migrations[version]['subresources']\n    )\n\n    for migration in migrations[version]['migrations']:\n        instance = migration(instance)\n        instance._resource['doc_version'] = unicode(migration.version)\n\n        instance = _migrate_resource(\n            instance,\n            migrations,\n            version=migration.version\n        )\n\n    return instance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _migrate_subresources(parent, migrations):\n    for subresource, resource_migrations in migrations.items():\n        parent = _migrate_subresource(\n            subresource,\n            parent,\n            resource_migrations\n        )\n\n    return parent", "response": "Migrate a resource s subresources to a new parent perch. Document instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmigrate a resource s subresource to a parent document.", "response": "def _migrate_subresource(subresource, parent, migrations):\n    \"\"\"\n    Migrate a resource's subresource\n\n    :param subresource: the perch.SubResource instance\n    :param parent: the parent perch.Document instance\n    :param migrations: the migrations for a resource\n    \"\"\"\n    for key, doc in getattr(parent, subresource.parent_key, {}).items():\n        for migration in migrations['migrations']:\n            instance = migration(subresource(id=key, **doc))\n            parent._resource['doc_version'] = unicode(migration.version)\n\n            instance = _migrate_subresources(\n                instance,\n                migrations['subresources']\n            )\n\n        doc = instance._resource\n        doc.pop('id', None)\n        doc.pop(instance.resource_type + '_id', None)\n\n        getattr(parent, subresource.parent_key)[key] = doc\n\n    return parent"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprints the entire file as an ast", "response": "def print_ast(f):\n    \"\"\"\n    :param f:\n    :type f: file\n    :return:\n    \"\"\"\n    for linenum,indent,value in iter_lines(f):\n        print(\"{0}{1}|{2}\".format(str(linenum).rjust(3), ' ' * indent, value))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pop_frame(self):\n        self.frames.pop(0)\n        if len(self.frames) == 0:\n            raise Exception(\"stack is exhausted\")\n        return self.frames[0]", "response": "Removes and returns the frame at the top of the stack."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append_child_object(self, linenum, indent, path):\n        frame = self.current_frame()\n        assert isinstance(frame,RootFrame) or isinstance(frame,ContainerFrame) and frame.indent < indent\n        assert len(path.segments) > 0\n        container = frame.container\n        if container.contains_container(path):\n            raise KeyError(\"container exists at path {0}\".format(path))\n        container.put_container(path)\n        container = container.get_container(path)\n        path = frame.path + path\n        frame = ContainerFrame(linenum, indent, path, container)\n        self.push_frame(frame)", "response": "Append a child object to the current frame."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef append_sibling_object(self, linenum, indent, path):\n        frame = self.current_frame()\n        assert frame.indent is not None and frame.indent == indent\n        self.pop_frame()\n        self.append_child_object(linenum, indent, path)", "response": "Append a sibling object to the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef append_child_field(self, linenum, indent, field_name, field_value):\n        frame = self.current_frame()\n        assert isinstance(frame,RootFrame) or isinstance(frame,ContainerFrame) and frame.indent < indent\n        if frame.container.contains(ROOT_PATH, field_name):\n            raise KeyError(\"field {0} exists in container at path {1}\".format(field_name, frame.path))\n        frame.container.put_field(ROOT_PATH, field_name, field_value)\n        frame = FieldFrame(linenum, indent, frame.path, frame.container, field_name, field_value)\n        self.push_frame(frame)", "response": "Append a child field to the current frame."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef append_sibling_field(self, linenum, indent, field_name, field_value):\n        frame = self.current_frame()\n        assert frame.indent is not None and frame.indent == indent\n        self.pop_frame()\n        self.append_child_field(linenum, indent, field_name, field_value)", "response": "Append a sibling field to the current line number."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append_value_continuation(self, linenum, indent, continuation):\n        frame = self.current_frame()\n        assert isinstance(frame,FieldFrame) or isinstance(frame,ValueContinuationFrame)\n        if isinstance(frame, FieldFrame):\n            assert frame.indent < indent and frame.container.contains(ROOT_PATH, frame.field_name)\n        if isinstance(frame, ValueContinuationFrame):\n            assert frame.indent == indent and frame.container.contains(ROOT_PATH, frame.field_name)\n            self.pop_frame()\n        field_value = frame.field_value + '\\n' + continuation\n        frame.container.put_field(ROOT_PATH, frame.field_name, field_value)\n        frame = ValueContinuationFrame(linenum, indent, frame.path, frame.container, frame.field_name, field_value)\n        self.push_frame(frame)", "response": "Append a continuation to the current level of the log file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef append_list_continuation(self, linenum, indent, continuation):\n        frame = self.current_frame()\n        assert isinstance(frame,FieldFrame) or isinstance(frame,ListContinuationFrame)\n        if isinstance(frame, FieldFrame):\n            assert frame.indent < indent and frame.container.contains(ROOT_PATH, frame.field_name)\n        if isinstance(frame, ListContinuationFrame):\n            assert frame.indent == indent and frame.container.contains(ROOT_PATH, frame.field_name)\n            self.pop_frame()\n        frame.container.append_field(ROOT_PATH, frame.field_name, continuation)\n        frame = ListContinuationFrame(linenum, indent, frame.path, frame.container, frame.field_name, continuation)\n        self.push_frame(frame)", "response": "Append a continuation to the current stack."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dict_to_querystring(dictionary):\n    s = u\"\"\n    for d in dictionary.keys():\n        s = unicode.format(u\"{0}{1}={2}&\", s, d, dictionary[d])\n    return s[:-1]", "response": "Converts a dictionary to a querystring suitable to be appended to a URL."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a string representation of the log file", "response": "def logging_format(verbose=2, style='txt'):\n    \"\"\"returns a format\n    :parameter:\n        - str style: defines style of output format (defaults to txt)\n            - txt plain text\n            - dict like text which can be casted to dict\n    \"\"\"\n    frmt = \"'dt':'%(asctime)s', 'lv':'%(levelname)-7s', 'ln':'%(name)s'\"\n\n    if verbose > 1:\n        frmt += \",\\t'Func': '%(funcName)-12s','line':%(lineno)5d, 'module':'%(module)s'\"\n    if verbose > 2:\n        frmt += \",\\n\\t'file':'%(filename)s',\\t'Process':['%(processName)s', %(process)d], \\\n                'thread':['%(threadName)s', %(thread)d], 'ms':%(relativeCreated)d\"\n    frmt += \",\\n\\t'msg':'%(message)s'\"\n    if style == \"dict\":\n        frmt = \"{\" + frmt + \"}\"\n        frmt = frmt.replace(\" \", \"\").replace(\"\\n\", \"\").replace(\"\\t\", \"\")\n    if style == \"txt\":\n        frmt = frmt.replace(\"'\", \"\").replace(\",\", \"\")\n    return frmt"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef auto_retry(exception_t, retries=3, sleepSeconds=1, back_of_factor=1, msg='', auto_log=1, raise_on_failure=True):\n    def wrapper(func):\n        def fun_call(*args, **kwargs):\n            tries = 0\n            while tries < retries:\n                try:\n                    return func(*args, **kwargs)\n                except exception_t as e:\n                    tries += 1\n                    sleep_seconds = sleepSeconds * tries * back_of_factor\n                    if auto_log > 0:\n                        ermsg = auto_retry_msg_frmt.format(class_name_str(e, True), e, tries, retries, sleep_seconds, func.__name__, args, kwargs, msg)\n                    if tries < retries:\n                        if auto_log > 1:\n                            LOG.info(ermsg)\n                        time.sleep(sleep_seconds)\n                    else:\n                        if auto_log > 0:\n                            LOG.exception(ermsg)\n                        if raise_on_failure:\n                            raise\n                        return e\n        return fun_call\n    return wrapper", "response": "a generic auto - retry function"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pp_obj(obj, out_path=None, indent=4, sort_keys=False, ensure_ascii=False, default=None):\n    rt = anyjson.dumps(obj, sort_keys=sort_keys, indent=indent, ensure_ascii=ensure_ascii,\n                       separators=(',', ': '), default=default, namedtuple_as_object=False)\n    # unicode_available\n    if out_path is None:\n        return rt\n    else:\n        with open(out_path, 'w') as out:\n            out.write(rt)", "response": "pretty prints a dict or list tuple to a file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef time_func(func):\n    def timed(*args, **kwargs):\n        ts = time.time()\n        result = func(*args, **kwargs)\n        secs = time.time() - ts\n        ops_ps = kwargs.get('operations', secs) / secs\n        print (\"finc{} took: {} {:2.4f} operations/sec={:5.2f}\".format(func.__name__, seconds_to_DHMS(secs), secs, ops_ps))\n        return result\n    return timed", "response": "time a function decorator\n    :param args: any args to pass to the function\n    :paran kwargs: any key arguments to pass to the function\n        (if 'operations' is in kwargs keys it is used to calculate operations per second)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvisualises as seq or dictionary", "response": "def visualise(seq, sort=lambda x: x[0]):\n    \"\"\"visualises as seq or dictionary\"\"\"\n    frmt = \"{:6} {:8,d} {}\"\n    if isinstance(seq, dict):\n        seq = seq.items()\n    if sort:\n        seq = sorted(seq, key=sort)\n    mx, mn = max([i[1] for i in seq]), min([i[1] for i in seq])  \n    range = mx - mn\n    for i in seq:\n        v = int((i[1] * 100) / range)\n        print (frmt.format(i[0], i[1], \"*\" * v))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef color_code(cls, color):\n        if not isinstance(color, tuple):\n            color = cls.colors[color]\n        return \"{:d};{}\".format(color[0], str(color[1]) if len(color) == 2 else \"\")", "response": "returns code for color\n        "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_all_cached_commit_times(root_folder):\n    result = []\n    location = cache_location(root_folder)\n\n    if os.path.exists(location):\n        try:\n            result = json.load(open(location))\n        except (TypeError, ValueError) as error:\n            log.warning(\"Failed to open gitmit cached commit_times\\tlocation=%s\\terror=%s\", location, error)\n        else:\n            if type(result) is not list or not all(type(item) is dict for item in result):\n                log.warning(\"Gitmit cached commit_times needs to be a list of dictionaries\\tlocation=%s\\tgot=%s\", location, type(result))\n                result = []\n\n    return result", "response": "Find the gitmit cached commit_times and return them if they are the right shape."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_cached_commit_times(root_folder, parent_dir, sorted_relpaths):\n    result = get_all_cached_commit_times(root_folder)\n\n    for item in result:\n        if sorted(item.get(\"sorted_relpaths\", [])) == sorted_relpaths and item.get(\"parent_dir\") == parent_dir:\n            return item.get(\"commit\"), item.get(\"commit_times\")\n\n    return None, {}", "response": "Get the cached commit times for the combination of this parent_dir and relpaths"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_cached_commit_times(root_folder, parent_dir, first_commit, commit_times, sorted_relpaths):\n    current = get_all_cached_commit_times(root_folder)\n    location = cache_location(root_folder)\n\n    found = False\n    for item in current:\n        if sorted(item.get(\"sorted_relpaths\", [])) == sorted_relpaths and item.get(\"parent_dir\") == parent_dir:\n            item[\"commit_times\"] = commit_times\n            item[\"commit\"] = str(first_commit)\n            found = True\n            break\n\n    if not found:\n        current.append({\"commit\": str(first_commit), \"parent_dir\": parent_dir, \"commit_times\": commit_times, \"sorted_relpaths\": sorted_relpaths})\n\n    # Make sure it doesn't grow too big....\n    # Arbitrary number is arbitrary\n    while len(current) > 5:\n        current.pop(0)\n\n    try:\n        log.info(\"Writing gitmit cached commit_times\\tlocation=%s\", location)\n        with open(location, \"w\") as fle:\n            json.dump(current, fle)\n    except (TypeError, ValueError, IOError) as error:\n        log.warning(\"Failed to dump gitmit mtime cache\\tlocation=%s\\terror=%s\", location, error)", "response": "Set the cached commit times in a json file at root_folder."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend an email from the user to the receiver with attachments attached.", "response": "async def send_with_attachments(subject, message, filepaths, config):\n    \"\"\"Send an email from the user (a gmail) to the receiver.\n\n    Args:\n        subject (str): Subject of the email.\n        message (str): A message.\n        filepaths (list(str)): Filepaths to files to be attached.\n        config (defaultdict): A defaultdict.\n    \"\"\"\n    email_ = MIMEMultipart()\n    email_.attach(MIMEText(message))\n    email_[\"Subject\"] = subject\n    email_[\"From\"] = get_attribute_from_config(config, EMAIL_SECTION_KEY, USER_KEY)\n    email_[\"To\"] = get_attribute_from_config(config, EMAIL_SECTION_KEY, RECEIVER_KEY)\n    _attach_files(filepaths, email_)\n    await _send_email(email_, config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake a list of filepaths and attachs the files to a MIMEMultipart email_.", "response": "def _attach_files(filepaths, email_):\n    \"\"\"Take a list of filepaths and attach the files to a MIMEMultipart.\n\n    Args:\n        filepaths (list(str)): A list of filepaths.\n        email_ (email.MIMEMultipart): A MIMEMultipart email_.\n    \"\"\"\n    for filepath in filepaths:\n        base = os.path.basename(filepath)\n        with open(filepath, \"rb\") as file:\n            part = MIMEApplication(file.read(), Name=base)\n            part[\"Content-Disposition\"] = 'attachment; filename=\"%s\"' % base\n            email_.attach(part)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending an email. Args: email_ (email.MIMEMultipart): The email to send. config (defaultdict): A defaultdict.", "response": "async def _send_email(email_, config, loop=asyncio.get_event_loop()):\n    \"\"\"Send an email.\n\n    Args:\n        email_ (email.MIMEMultipart): The email to send.\n        config (defaultdict): A defaultdict.\n    \"\"\"\n    smtp_server = get_attribute_from_config(config, EMAIL_SECTION_KEY, SMTP_SERVER_KEY)\n    smtp_port = int(get_attribute_from_config(config, EMAIL_SECTION_KEY, SMTP_PORT_KEY))\n    user = get_attribute_from_config(config, EMAIL_SECTION_KEY, USER_KEY)\n    password = get_attribute_from_config(config, EMAIL_SECTION_KEY, PASSWORD_KEY)\n    server = aiosmtplib.SMTP(hostname=smtp_server, port=smtp_port, loop=loop, use_tls=False)\n    await server.connect()\n    await server.starttls()\n    await server.login(user, password)\n    await server.send_message(email_)\n    await server.quit()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend files using the config. ini settings.", "response": "async def send_files_preconf(filepaths, config_path=CONFIG_PATH):\n    \"\"\"Send files using the config.ini settings.\n\n    Args:\n        filepaths (list(str)): A list of filepaths.\n    \"\"\"\n    config = read_config(config_path)\n    subject = \"PDF files from pdfebc\"\n    message = \"\"\n    await send_with_attachments(subject, message, filepaths, config)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_assertions(input_pipe, other_pipes, output_pipe):\n        assert isinstance(input_pipe, elements.InPypElement), 'Wrong input element type, want a InPypElement!'\n        assert isinstance(output_pipe, elements.OutPypElement), 'Wrong output element type, want a OutPypElement!'\n        for other_pipe in other_pipes:\n            assert isinstance(other_pipe, elements.MidPypElement), 'Wrong middle element type, want a MidPypElement!'", "response": "Make the assertions for the pipe."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlets the pipe flow :return:", "response": "def run(self):\n        \"\"\"\n        Let the pipe flow\n        :return:\n        \"\"\"\n        assert len(self.elements) >= 2, \"In order flow, pipe needs 2 or more elements\"\n        in_pipe = self.elements[0]\n        other_pipes = self.elements[1:-1]\n        out_pipe = self.elements[-1]\n\n        self.make_assertions(in_pipe, other_pipes, out_pipe)\n\n        for data in in_pipe.grasp():\n            write = True\n\n            for element in other_pipes:\n                if isinstance(element, elements.DataPypElement):\n                    data = element.extend(data)\n                elif isinstance(element, elements.FilterPypElement):\n                    if not element.stay(data):\n                        write = False\n                        break\n            if write:\n                out_pipe.extract(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register_link(self, obj, attr=None):\n        name = repr(self)\n        if not name:\n            return self\n        l = self.__class__._get_links()\n        if name not in l:\n            l[name] = set()\n        v = WeakAttrLink(obj, attr)\n        if v not in l[name]:\n            l[name].add(v)\n        return self", "response": "creates a link from obj. attr to self\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving a link from obj. attr", "response": "def remove_link(self, obj, attr=None):\n        \"\"\"\n        removes link from obj.attr\n        \"\"\"\n        name = repr(self)\n        if not name:\n            return self\n        l = self.__class__._get_links()\n        v = WeakAttrLink(None, obj) if attr is None else WeakAttrLink(obj, attr)\n        if name in l:\n            if v in l[name]:\n                l[name].remove(v)\n            if not l[name]:\n                l.pop(name)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the link dictionary with the new object.", "response": "def update_link(self):\n        \"\"\"\n        redirects all links to self (the new linked object)\n        \"\"\"\n        name = repr(self)\n        if not name:\n            return self\n        l = self.__class__._get_links()\n        to_be_changed = list()\n        if name in l:\n\n            for wal in l[name]:\n                if wal.ref_obj and self is not wal():\n                    to_be_changed.append((wal.ref_obj, wal.attr))\n\n        for o, a in to_be_changed:\n            setattr(o, a, self)\n\n        self.clean_up_link_dict()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef handle_import(self, options):\n\n        blog_id = options.get(\"blog_id\")\n        if blog_id is None:\n            raise CommandError(\"Usage is import_blogger %s\" % self.args)\n\n        try:\n            from gdata import service\n        except ImportError:\n            raise CommandError(\"Could not import the gdata library.\")\n\n        blogger = service.GDataService()\n        blogger.service = \"blogger\"\n        blogger.server = \"www.blogger.com\"\n\n        start_index = 1\n        processed_posts = []\n        new_posts = 1\n\n        while new_posts:\n            new_posts = 0\n\n            query = service.Query()\n            query.feed = \"/feeds/%s/posts/full\" % blog_id\n            query.max_results = 500\n            query.start_index = start_index\n\n            try:\n                feed = blogger.Get(query.ToUri())\n            except service.RequestError as err:\n                message = \"There was a service error. The response was: \" \\\n                    \"%(status)s %(reason)s - %(body)s\" % err.message\n                raise CommandError(message, blogger.server + query.feed,\n                                   err.message[\"status\"])\n\n            for (i, entry) in enumerate(feed.entry):\n                # this basically gets the unique post ID from the URL to itself\n                # and pulls the ID off the end.\n                post_id = entry.GetSelfLink().href.split(\"/\")[-1]\n\n                # Skip duplicate posts. Important for the last query.\n                if post_id in processed_posts:\n                    continue\n\n                title = entry.title.text\n                content = entry.content.text\n                # this strips off the time zone info off the end as we want UTC\n                clean_date = entry.published.text[:re.search(r\"\\.\\d{3}\",\n                    entry.published.text).end()]\n\n                published_date = self.parse_datetime(clean_date)\n\n                # TODO - issues with content not generating correct <P> tags\n\n                tags = [tag.term for tag in entry.category]\n                post = self.add_post(title=title, content=content,\n                                     pub_date=published_date, tags=tags)\n\n                # get the comments from the post feed and then add them to\n                # the post details\n                comment_url = \"/feeds/%s/%s/comments/full?max-results=1000\"\n                comments = blogger.Get(comment_url % (blog_id, post_id))\n\n                for comment in comments.entry:\n                    email = comment.author[0].email.text\n                    author_name = comment.author[0].name.text\n                    # Strip off the time zone info off the end as we want UTC\n                    clean_date = comment.published.text[:re.search(r\"\\.\\d{3}\",\n                        comment.published.text).end()]\n\n                    comment_date = self.parse_datetime(clean_date)\n\n                    website = \"\"\n                    if comment.author[0].uri:\n                        website = comment.author[0].uri.text\n                    body = comment.content.text\n\n                    # add the comment as a dict to the end of the comments list\n                    self.add_comment(post=post, name=author_name, email=email,\n                                     body=body, website=website,\n                                     pub_date=comment_date)\n\n                processed_posts.append(post_id)\n                new_posts += 1\n\n            start_index += 500", "response": "Handles the import of the Blogger posts."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a dict mapping context names to lists of recipients.", "response": "def recipients(preferences, message, valid_paths, config):\n    \"\"\" The main API function.\n\n    Accepts a fedmsg message as an argument.\n\n    Returns a dict mapping context names to lists of recipients.\n    \"\"\"\n\n    rule_cache = dict()\n    results = defaultdict(list)\n    notified = set()\n\n    for preference in preferences:\n        user = preference['user']\n        context = preference['context']\n        if (user['openid'], context['name']) in notified:\n            continue\n\n        for filter in preference['filters']:\n            if matches(filter, message, valid_paths, rule_cache, config):\n                for detail_value in preference['detail_values']:\n                    results[context['name']].append({\n                        'user': user['openid'],\n                        context['detail_name']: detail_value,\n                        'filter_name': filter['name'],\n                        'filter_id': filter['id'],\n                        'filter_oneshot': filter['oneshot'],\n                        'markup_messages': preference['markup_messages'],\n                        'triggered_by_links': preference['triggered_by_links'],\n                        'shorten_links': preference['shorten_links'],\n                        'verbose': preference['verbose'],\n                    })\n                notified.add((user['openid'], context['name']))\n                break\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if the given filter matches the given message.", "response": "def matches(filter, message, valid_paths, rule_cache, config):\n    \"\"\" Returns True if the given filter matches the given message. \"\"\"\n\n    if not filter['rules']:\n        return False\n\n    for rule in filter['rules']:\n        fn = rule['fn']\n        negated = rule['negated']\n        arguments = rule['arguments']\n        rule_cache_key = rule['cache_key']\n\n        try:\n            if rule_cache_key not in rule_cache:\n                value = fn(config, message, **arguments)\n                if negated:\n                    value = not value\n                rule_cache[rule_cache_key] =  value\n\n            if not rule_cache[rule_cache_key]:\n                return False\n        except Exception as e:\n            log.exception(e)\n            # If something throws an exception then we do *not* have a match.\n            return False\n\n    # Then all rules matched on this filter..\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_preferences(session, config, valid_paths,\n                     cull_disabled=False, openid=None,\n                     cull_backends=None):\n    \"\"\" Every rule for every filter for every context for every user.\n\n    Any preferences in the DB that are for contexts that are disabled in the\n    config are omitted here.\n\n    If the `openid` argument is None, then this is an expensive query that\n    loads, practically, the whole database.  However, if an openid string is\n    submitted, then only the preferences of that user are returned (and this is\n    less expensive).\n    \"\"\"\n\n    cull_backends = cull_backends or []\n\n    query = session.query(fmn.lib.models.Preference)\n\n    if openid:\n        query = query.filter(fmn.lib.models.Preference.openid==openid)\n\n    preferences = query.all()\n    return [\n        preference.__json__(reify=True)\n        for preference in preferences\n        if (\n            preference.context.name in config['fmn.backends']\n            and preference.context.name not in cull_backends\n            and (not cull_disabled or preference.enabled)\n        )\n    ]", "response": "Load preferences from DB."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_rules(root='fmn.rules'):\n\n    module = __import__(root, fromlist=[root.split('.')[0]])\n\n    hinting_helpers = fmn.lib.hinting.__dict__.values()\n\n    rules = {}\n    for name in dir(module):\n        obj = getattr(module, name)\n\n        # Ignore non-callables.\n        if not callable(obj):\n            continue\n\n        # Ignore our decorator and its friends\n        if obj in hinting_helpers:\n            continue\n\n        doc = inspect.getdoc(obj)\n\n        # It's crazy, but inspect (stdlib!) doesn't return unicode objs on py2.\n        if doc and hasattr(doc, 'decode'):\n            doc = doc.decode('utf-8')\n\n        if doc:\n            # If we have a docstring, then mark it up beautifully for display\n            # in the web app.\n            # FWIW, this should probably be moved into fmn.web since nowhere\n            # else are we going to want HTML... we'll still want raw .rst.\n            title, doc_as_rst = doc.split('\\n', 1)\n            doc = docutils.examples.html_parts(doc_as_rst)['body']\n            soup = bs4.BeautifulSoup(doc, 'html5lib')\n            doc_no_links = ''.join(map(six.text_type, strip_anchor_tags(soup)))\n            doc = markupsafe.Markup(doc)\n            doc_no_links = markupsafe.Markup(doc_no_links)\n        else:\n            title = \"UNDOCUMENTED\"\n            doc = \"No docs for %s:%s %r\" % (root, name, obj)\n            doc_no_links = doc\n\n        rules[name] = {\n            'func': obj,\n            'submodule': obj.__module__.split('.')[-1],\n            'title': title.strip(),\n            'doc': doc.strip(),\n            'doc-no-links': doc_no_links.strip(),\n            'args': inspect.getargspec(obj)[0],\n            'datanommer-hints': getattr(obj, 'hints', {}),\n            'hints-invertible': getattr(obj, 'hinting_invertible', True),\n            'hints-callable': getattr(obj, 'hinting_callable', None),\n        }\n\n    rules = OrderedDict(\n        sorted(rules.items(), key=lambda x: x[1]['title'])\n    )\n\n    return {root: rules}", "response": "Load the big list of allowed callable rules."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\napplying a function on the attributes of the object", "response": "def use_with(data, fn, *attrs):\n    \"\"\"Apply a function on the attributes of the data\n\n    :param data: an object\n    :param fn: a function\n    :param attrs: some attributes of the object\n    :returns: an object\n\n    Let's create some data first::\n\n        >>> from collections import namedtuple\n        >>> Person = namedtuple('Person', ('name', 'age', 'gender'))\n        >>> alice = Person('Alice', 30, 'F')\n\n    Usage::\n\n        >>> make_csv_row = lambda n, a, g: '%s,%d,%s' % (n, a, g)\n        >>> use_with(alice, make_csv_row, 'name', 'age', 'gender')\n        'Alice,30,F'\n\n    \"\"\"\n    args = [getattr(data, x) for x in attrs]\n    return fn(*args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rmap(fn, coll, is_iterable=None):\n    result = []\n    for x in coll:\n        if is_iterable is None:\n            is_iterable = isiterable\n\n        if is_iterable(x):\n            y = rmap(fn, x)\n        else:\n            y = fn(x)\n        result.append(y)\n    return result", "response": "A recursive map function for a list of items in a recursive fashion."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef replace(x, old, new, fn=operator.eq):\n    return new if fn(x, old) else x", "response": "Replace x with new if fn is True."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef compose(*fns):\n    def compose2(f, g):\n        return lambda x: f(g(x))\n    return reduce(compose2, fns)", "response": "Returns the function composed with the given functions\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef groupby(fn, coll):\n    d = collections.defaultdict(list)\n    for item in coll:\n        key = fn(item)\n        d[key].append(item)\n    return dict(d)", "response": "Group elements in sub - collections by fn"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reductions(fn, seq, acc=None):\n    indexes = xrange(len(seq))\n    if acc:\n        return map(lambda i: reduce(lambda x, y: fn(x, y), seq[:i+1], acc), indexes)\n    else:\n        return map(lambda i: reduce(lambda x, y: fn(x, y), seq[:i+1]), indexes)", "response": "Return the intermediate values of a function\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef split(coll, factor):\n    groups = groupby(lambda x: x[0], itertools.izip(factor, coll))\n    return dmap(lambda x: [y[1] for y in x], groups)", "response": "Split a collection by using a factor"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nassociating a key with a value in a dictionary", "response": "def assoc(_d, key, value):\n    \"\"\"Associate a key with a value in a dictionary\n\n    :param _d: a dictionary\n    :param key: a key in the dictionary\n    :param value: a value for the key\n    :returns: a new dictionary\n\n    >>> data = {}\n    >>> new_data = assoc(data, 'name', 'Holy Grail')\n    >>> new_data\n    {'name': 'Holy Grail'}\n    >>> data\n    {}\n\n    .. note:: the original dictionary is not modified\n\n    \"\"\"\n    d = deepcopy(_d)\n    d[key] = value\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying functions recursively on your data", "response": "def pipe(data, *fns):\n    \"\"\"Apply functions recursively on your data\n\n    :param data: the data\n    :param fns: functions\n    :returns: an object\n\n    >>> inc = lambda x: x + 1\n    >>> pipe(42, inc, str)\n    '43'\n\n    \"\"\"\n    return reduce(lambda acc, f: f(acc), fns, data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef shift(func, *args, **kwargs):\n    @wraps(func)\n    def wrapped(x):\n        return func(x, *args, **kwargs)\n    return wrapped", "response": "This is basically a beefed up lambda x : func ( x * args ** kwargs )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(records, column, values):\n    new_records = deepcopy(records)\n\n    if values.__class__.__name__ == 'function':\n        for row in new_records:\n            row[column] = values(row[column])\n    elif isiterable(values):\n        for i, row in enumerate(new_records):\n            row[column] = values[i]\n    else:\n        msg = \"You must provide a function or an iterable.\"\n        raise ValueError(msg)\n    return new_records", "response": "Update the column of records with the given values."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the duplicated items in the given collection", "response": "def duplicates(coll):\n    \"\"\"Return the duplicated items in the given collection\n\n    :param coll: a collection\n    :returns: a list of the duplicated items in the collection\n\n    >>> duplicates([1, 1, 2, 3, 3, 4, 1, 1])\n    [1, 3]\n\n    \"\"\"\n    return list(set(x for x in coll if coll.count(x) > 1))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pluck(record, *keys, **kwargs):\n    default = kwargs.get('default', None)\n    return reduce(lambda a, x: assoc(a, x, record.get(x, default)), keys, {})", "response": "Return the record with the selected keys"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the records with the selected columns", "response": "def pluck_each(records, columns):\n    \"\"\"Return the records with the selected columns\n\n    :param records: a list of dictionaries\n    :param columns: a list or a tuple\n    :returns: a list of dictionaries with the selected columns\n\n    >>> movies = [\n    ... {'title': 'The Holy Grail', 'year': 1975, 'budget': 4E5, 'total_gross': 5E6},\n    ... {'title': 'Life of Brian', 'year': 1979, 'budget': 4E6, 'total_gross': 20E6},\n    ... {'title': 'The Meaning of Life', 'year': 1983, 'budget': 9E6, 'total_gross': 14.9E6}\n    ... ]\n    >>> pluck_each(movies, ('title', 'year'))\n    [{'year': 1975, 'title': 'The Holy Grail'}, {'year': 1979, 'title': 'Life of Brian'}, {'year': 1983, 'title': 'The Meaning of Life'}]\n\n    \"\"\"\n    return [pluck(records[i], *columns) for i, _ in enumerate(records)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef use(data, attrs):\n    if isinstance(data, dict):\n        if not isiterable(attrs):\n            attrs = [attrs]\n        coll = map(data.get, attrs)\n    else:\n        coll = map(lambda x: getattr(data, x), attrs)\n    return coll", "response": "Return the values of the attributes for the given data structure."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_in(record, *keys, **kwargs):\n    default = kwargs.get('default', None)\n    return reduce(lambda a, x: a.get(x, default), keys, record)", "response": "Get the value corresponding to the keys in a nested record."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract the value corresponding to the given key in all the dictionaries", "response": "def valueof(records, key):\n    \"\"\"Extract the value corresponding to the given key in all the dictionaries\n\n    >>> bands = [{'name': 'Led Zeppelin', 'singer': 'Robert Plant', 'guitarist': 'Jimmy Page'},\n    ... {'name': 'Metallica', 'singer': 'James Hetfield', 'guitarist': 'Kirk Hammet'}]\n    >>> valueof(bands, 'singer')\n    ['Robert Plant', 'James Hetfield']\n\n    \"\"\"\n    if isinstance(records, dict):\n        records = [records]\n    return map(operator.itemgetter(key), records)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\napplying a function on the record and return the corresponding new record", "response": "def find(fn, record):\n    \"\"\"Apply a function on the record and return the corresponding new record\n\n    :param fn: a function\n    :param record: a dictionary\n    :returns: a dictionary\n\n    >>> find(max, {'Terry': 30, 'Graham': 35, 'John': 27})\n    {'Graham': 35}\n\n    \"\"\"\n    values_result = fn(record.values())\n    keys_result = [k for k, v in record.items() if v == values_result]\n    return {keys_result[0]: values_result}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving all the occurrences of a given value from a collection", "response": "def remove(coll, value):\n    \"\"\"Remove all the occurrences of a given value\n\n    :param coll: a collection\n    :param value: the value to remove\n    :returns: a list\n\n    >>> data = ('NA', 0, 1, 'NA', 1, 2, 3, 'NA', 5)\n    >>> remove(data, 'NA')\n    (0, 1, 1, 2, 3, 5)\n\n    \"\"\"\n    coll_class = coll.__class__\n    return coll_class(x for x in coll if x != value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True for each item in the collection", "response": "def are_in(items, collection):\n    \"\"\"Return True for each item in the collection\n\n    :param items: a sub-collection\n    :param collection: a collection\n    :returns: a list of booleans\n\n    >>> are_in(['Terry', 'James'], ['Terry', 'John', 'Eric'])\n    [True, False]\n\n    \"\"\"\n    if not isinstance(items, (list, tuple)):\n        items = (items, )\n    return map(lambda x: x in collection, items)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndetermining the monotony of a sequence", "response": "def monotony(seq):\n    \"\"\"Determine the monotony of a sequence\n\n    :param seq: a sequence\n\n    :returns: 1 if the sequence is sorted (increasing)\n    :returns: 0 if it is not sorted\n    :returns: -1 if it is sorted in reverse order (decreasing)\n\n    >>> monotony([1, 2, 3])\n    1\n    >>> monotony([1, 3, 2])\n    0\n    >>> monotony([3, 2, 1])\n    -1\n\n    \"\"\"\n    if seq == sorted(seq):\n        return 1\n    elif seq == list(reversed(sorted(seq))):\n        return -1\n    else:\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all the non callable and non special attributes of the input data", "response": "def attributes(data):\n    \"\"\"Return all the non callable and non special attributes of the input data\n\n    :param data: an object\n    :returns: a list\n\n    >>> class table:\n    ...     def __init__(self, name, rows, cols):\n    ...         self.name = name\n    ...         self.rows = rows\n    ...         self.cols = cols\n\n    >>> t = table('people', 100, 3)\n    >>> attributes(t)\n    ['cols', 'name', 'rows']\n\n    \"\"\"\n    return [x for x in dir(data) if not callable(x) and not x.startswith('__')]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dfilter(fn, record):\n    return dict([(k, v) for k, v in record.items() if fn(v)])", "response": "filter for a directory\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfilter the occurrences with respect to the selected relational operators", "response": "def _filter_occurrences(count, relat_op):\n    \"\"\"Filter the occurrences with respect to the selected relational operators\"\"\"\n    # Filter the occurrences equal (or not equal) to a given value\n    if \"eq\" in relat_op:\n        count = dfilter(lambda x: x == relat_op[\"eq\"], count)\n    elif \"ne\" in relat_op:\n        count = dfilter(lambda x: x != relat_op[\"ne\"], count)\n\n    # Filter the occurrences lower (or equal) than a given value\n    if \"lt\" in relat_op:\n        count = dfilter(lambda x: x < relat_op[\"lt\"], count)\n    elif \"le\" in relat_op:\n        count = dfilter(lambda x: x <= relat_op[\"le\"], count)\n\n    # Filter the occurrences greater (or equal) than a given value\n    if \"gt\" in relat_op:\n        count = dfilter(lambda x: x > relat_op[\"gt\"], count)\n    elif \"ge\" in relat_op:\n        count = dfilter(lambda x: x >= relat_op[\"ge\"], count)\n    return count"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the occurrences of the elements in the collection that have a value.", "response": "def occurrences(coll, value=None, **options):\n    \"\"\"Return the occurrences of the elements in the collection\n\n    :param coll: a collection\n    :param value: a value in the collection\n    :param options: \n        an optional keyword used as a criterion to filter the\n        values in the collection\n    :returns: the frequency of the values in the collection as a dictionary\n\n    >>> occurrences((1, 1, 2, 3))\n    {1: 2, 2: 1, 3: 1}\n    >>> occurrences((1, 1, 2, 3), 1)\n    2\n\n    Filter the values of the occurrences that are \n    <, <=, >, >=, == or != than a given number::\n\n        >>> occurrences((1, 1, 2, 3), lt=3)\n        {1: 2, 2: 1, 3: 1}\n        >>> occurrences((1, 1, 2, 3), gt=1)\n        {1: 2}\n        >>> occurrences((1, 1, 2, 3), ne=1)\n        {1: 2}\n\n    \"\"\"\n    count = {}\n    for element in coll:\n        count[element] = count.get(element, 0) + 1\n\n    if options:\n        count = _filter_occurrences(count, options)\n\n    if value:\n        count = count.get(value, 0)\n    return count"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the index of the item in the collection", "response": "def indexof(coll, item, start=0, default=None):\n    \"\"\"Return the index of the item in the collection\n\n    :param coll: iterable\n    :param item: scalar\n    :param start: (optional) The start index\n    :default: The default value of the index if the item is not in the collection\n\n    :returns: idx -- The index of the item in the collection\n\n    >>> monties = ['Eric', 'John', 'Terry', 'Terry', 'Graham', 'Mickael']\n    >>> indexof(monties, 'Terry')\n    2\n\n    >>> indexof(monties, 'Terry', start=3)\n    3\n\n    >>> indexof(monties, 'Terry', start=4) is None\n    True\n\n    \"\"\"\n    if item in coll[start:]:\n        return list(coll).index(item, start)\n    else:\n        return default"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef indexesof(coll, item):\n    return [indexof(coll, item, i) for i in xrange(len(coll)) if coll[i] == item]", "response": "Return all the indexes of the item in the collection\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef count(fn, coll):\n    return len([x for x in coll if fn(x) is True])", "response": "Return the count of True values returned by the predicate function applied to the the\n    collection"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_application(self, environ):\n        host = self._get_host(environ)\n        subdomain = self._extract_subdomain(host)\n        return self._get_application(subdomain)", "response": "Retrieve an application for a wsgi environ object"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_application(self, subdomain):\n        with self.lock:\n            app = self.instances.get(subdomain)\n            if app is None:\n                app = self.create_application(subdomain=subdomain)\n                self.instances[subdomain] = app\n            return app", "response": "Returns a WSGI application for the given subdomain."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract a subdomain from a host.", "response": "def _extract_subdomain(host):\n        \"\"\" Returns a subdomain from a host. This host is typically the\n        HTTP_HOST request envvar.  If the host is an IP address, `None` is\n        returned\n\n        :param host: Request's target host\n        \"\"\"\n        host = host.split(':')[0]\n        # If the host is an IP address, there is no subdomain to extract\n        try:\n            # Check if the host is an ip address\n            socket.inet_aton(host)\n        except socket.error:\n            # It isn't an IP address, return the subdomain\n            return '.'.join(host.split('.')[:-2])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _val_to_store_info(self, val):\n        if isinstance(val, str):\n            return val, 0\n        elif isinstance(val, int):\n            return \"%d\" % val, Client._FLAG_INTEGER\n        elif isinstance(val, long):\n            return \"%d\" % val, Client._FLAG_LONG\n        return pickle.dumps(val, protocol=pickle.HIGHEST_PROTOCOL), Client._FLAG_PICKLE", "response": "Transform a value to a storable representation returning a tuple of the flags length of the new value and the new value itself."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef are_labels_overlapping(label1, label2):\n\n        if (\n                                label2.start_seconds > label1.end_seconds and\n                                label2.start_seconds > label1.start_seconds and\n                                label2.end_seconds > label1.start_seconds and\n                                label2.end_seconds > label1.start_seconds) or (\n                                label2.start_seconds < label1.start_seconds and\n                                label2.end_seconds < label1.start_seconds and\n                                label2.start_seconds < label1.end_seconds and\n                                label2.end_seconds < label1.end_seconds):\n            return False\n        else:\n            return True", "response": "Check if two labels are overlapping."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading all the files in each directory as values in a dict with the key Invitement being the relative file path of the directory.", "response": "def multiple_directory_files_loader(*args):\n    \"\"\"\n    Loads all the files in each directory as values in a dict with the key\n    being the relative file path of the directory.  Updates the value if\n    subsequent file paths are the same.\n    \"\"\"\n    d = dict()\n\n    def load_files(folder):\n        for (dirpath, dirnames, filenames) in os.walk(folder):\n            for f in filenames:\n                filepath = os.path.join(dirpath, f)\n                with open( filepath, 'r' ) as f:\n                    key = filepath[len(os.path.commonprefix([root, filepath]))+1:]\n                    d[ key ] = f.read()\n            for foldername in dirnames:\n                load_files(os.path.join(dirpath, foldername))\n\n    for root in args:\n        load_files(root)\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send_root_file(self, filename):\n        cache_timeout = self.get_send_file_max_age(filename)\n        return send_from_directory(self.config['ROOT_FOLDER'], filename,\n                                   cache_timeout=cache_timeout)", "response": "Function used to send static files from the root of the domain."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send_media_file(self, filename):\n        cache_timeout = self.get_send_file_max_age(filename)\n        return send_from_directory(self.config['MEDIA_FOLDER'], filename,\n                                   cache_timeout=cache_timeout)", "response": "Function used to send media files from the media folder to the browser."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send_theme_file(self, filename):\n        cache_timeout = self.get_send_file_max_age(filename)\n        return send_from_directory(self.config['THEME_STATIC_FOLDER'], filename,\n                                   cache_timeout=cache_timeout)", "response": "Function used to send static theme files from the theme folder to the browser."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite a message to stdout", "response": "def info(message, *args, **kwargs):\n    \"\"\"\n    write a message to stdout\n\n    \"\"\"\n    if 'end' in kwargs:\n        end = kwargs['end']\n    else:\n        end = '\\n'\n\n    if len(args) == 0:\n        sys.stdout.write(message)\n    else:\n        sys.stdout.write(message % args)\n    sys.stdout.write(end)\n    sys.stdout.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef error(message, *args, **kwargs):\n    if 'end' in kwargs:\n        end = kwargs['end']\n    else:\n        end = '\\n'\n\n    if len(args) == 0:\n        sys.stderr.write(message)\n    else:\n        sys.stderr.write(message % args)\n    sys.stderr.write(end)\n    sys.stderr.flush()", "response": "write a message to stderr"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting a debug message to stderr.", "response": "def debug(message, *args, **kwargs):\n    \"\"\"\n    debug output goes to stderr so you can still redirect the stdout to a file\n    or another program. Controlled by the JUT_DEBUG environment variable being\n    present\n\n    \"\"\"\n    if 'end' in kwargs:\n        end = kwargs['end']\n    else:\n        end = '\\n'\n\n    if DEBUG: \n        if len(args) == 0:\n            sys.stderr.write(message)\n        else:\n            sys.stderr.write(message % args)\n\n        sys.stderr.write(end)\n        sys.stderr.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd an item to the work queue.", "response": "def add(self, item):\n        \"\"\"\n        Add an item to the work queue.\n\n        :param item: The work item to add.  An item may be of any\n                     type; however, if it is not hashable, then the\n                     work queue must either be initialized with\n                     ``unique`` set to ``False``, or a ``key``\n                     callable must have been provided.\n        \"\"\"\n\n        # Are we to uniquify work items?\n        if self._unique:\n            key = self._key(item) if self._key else item\n\n            # If it already has been added to the queue, do nothing\n            if key in self._seen:\n                return\n\n            self._seen.add(key)\n\n        # Add the item to the queue\n        self._work.append(item)\n\n        # We'll keep a count of the number of items that have been\n        # through the queue\n        self._count += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntrues if specified value exists in int enum ; otherwise False.", "response": "def has_value(cls, value: int) -> bool:\n        \"\"\"True if specified value exists in int enum; otherwise, False.\"\"\"\n        return any(value == item.value for item in cls)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_name(cls, name: str, default: T = None) -> T:\n        if not name:\n            return default\n        name = name.lower()\n        return next((item for item in cls if name == item.name.lower()), default)", "response": "Parse specified name for IntEnum ; return default if not found."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses specified value for IntEnum.", "response": "def parse_value(cls, value: int, default: T = None) -> T:\n        \"\"\"Parse specified value for IntEnum; return default if not found.\"\"\"\n        return next((item for item in cls if value == item.value), default)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse specified names for IntEnum ; return default if not found.", "response": "def parse_names(cls, names: List[str]) -> T:\n        \"\"\"Parse specified names for IntEnum; return default if not found.\"\"\"\n        value = 0\n        iterable = cls  # type: Iterable\n        for name in names:\n            name = name.lower()\n            flag = next((item for item in iterable if name == item.name.lower()), None)\n            if not flag:\n                raise ValueError(\"{} is not a member of {}\".format(\n                    name, cls.__name__))\n            value = value | int(flag)\n        return cls(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_pubkey_line(cls, line):\n        options, key_without_options = cls._extract_options(line)\n        if key_without_options == '':\n            raise ValueError(\"Empty key\")\n        # the key (with options stripped out) should consist of the fields\n        # \"type\", \"data\", and optionally \"comment\", separated by a space.\n        # The comment field may contain additional spaces\n        fields = key_without_options.strip().split(None, 2)  # maxsplit=2\n        if len(fields) == 3:\n            type_str, data64, comment = fields\n        elif len(fields) == 2:\n            type_str, data64 = fields\n            comment = None\n        else:  # len(fields) <= 1\n            raise ValueError(\"Key has insufficient number of fields\")\n\n        try:\n            data = b64decode(data64)\n        except (binascii.Error, TypeError):\n            raise ValueError(\"Key contains invalid data\")\n\n        key_type = next(iter_prefixed(data))\n\n        if key_type == b'ssh-rsa':\n            key_class = RSAKey\n        elif key_type == b'ssh-dss':\n            key_class = DSAKey\n        elif key_type.startswith(b'ecdsa-'):\n            key_class = ECDSAKey\n        else:\n            raise ValueError('Unknown key type {}'.format(key_type))\n\n        return key_class(b64decode(data64), comment, options=options)", "response": "Generate a Key instance from a string. Raise ValueError if string is malformed."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_pubkey_file(cls, file):\n        if hasattr(file, 'read'):\n            return cls.from_pubkey_line(file.read())\n\n        return cls.from_pubkey_line(open(file).read())", "response": "Generate a Key instance from a file. Raise ValueError is key is\n        malformed"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _init():\n    import importlib\n    import os\n    import re\n\n    filenames = os.listdir(os.path.dirname(__file__))\n\n    module_names = set()\n    for filename in filenames:\n        match = re.match(r'^(?P<name>[A-Z_a-z]\\w*)\\.py[co]?$', filename)\n        if match:\n            module_names.add(match.group('name'))\n\n    for module_name in module_names:\n        try:\n            module = importlib.import_module('.' + module_name, __name__)\n        except ImportError:\n            continue\n\n        for name, member in module.__dict__.items():\n            if not isinstance(member, type):\n                # skip non-new-style classes\n                continue\n            if not issubclass(member, Engine):\n                # skip non-subclasses of Engine\n                continue\n            if member is Engine:\n                # skip \"abstract\" class Engine\n                continue\n\n            try:\n                handle = member.handle\n            except AttributeError:\n                continue\n\n            engines[handle] = member", "response": "Dynamically import engines that initialize successfully."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntransforms value into a representation suitable for substitution.", "response": "def str(self, value, tolerant=False, limit=1000, seen=frozenset()):\n        \"\"\"Transform value into a representation suitable for substitution.\"\"\"\n        if value is None:\n            if tolerant:\n                return \"\"\n\n            raise ValueError(\"value is None\")\n\n        if isinstance(value, (bool, numbers.Number, basestring)):\n            return str(value)\n\n        if not isinstance(value, collections.Iterable):\n            if not tolerant:\n                raise ValueError(\"unknown value type\")\n\n            try:\n                name = value.name\n            except AttributeError:\n                try:\n                    name = value.__name__\n                except AttributeError:\n                    try:\n                        name = value.__class__.__name__\n                    except AttributeError:\n                        return \"<?>\"\n\n            return \"<%s>\" % (name,)\n\n        is_mapping = isinstance(value, collections.Mapping)\n\n        if not seen:\n            wrap = \"%s\"\n        elif is_mapping:\n            wrap = \"{%s}\"\n        else:\n            wrap = \"[%s]\"\n\n        id_ = id(value)\n        if id_ in seen:\n            if tolerant:\n                return wrap % (\"...\",)\n            raise ValueError(\"recursive representation\")\n        seen = seen.union((id_,))\n\n        if is_mapping:\n            items = [(self.str(n, tolerant=tolerant, limit=limit, seen=seen),\n                      self.str(v, tolerant=tolerant, limit=limit, seen=seen))\n                     for n, v in value.items()]\n            items.sort()\n            items = (\"%s=%s\" for n, v in items)\n        else:\n            it = iter(value)\n            items = [self.str(item, tolerant=tolerant, limit=limit, seen=seen)\n                     for item in itertools.islice(\n                         it,\n                         len(value)\n                         if isinstance(value, collections.Sized)\n                         else limit)]\n            items.sort()\n            try:\n                next(it)\n            except StopIteration:\n                pass\n            else:\n                if not tolerant:\n                    raise ValueError(\"iterable too long\")\n                items.append(\"...\")\n\n        return wrap % (\", \".join(items),)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if doc matches the where condition.", "response": "def _match(self, doc, where):\n        \"\"\"Return True if 'doc' matches the 'where' condition.\"\"\"\n        assert isinstance(where, dict), \"where is not a dictionary\"\n        assert isinstance(doc, dict), \"doc is not a dictionary\"\n        try:\n            return all([doc[k] == v for k, v in where.items()])\n        except KeyError:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef import_module(module_name):\n    if import_path != sys.path:\n        # Such a kludge. Only restrict imports if the `import_path` has\n        # been changed. We don't want to always restrict imports, since\n        # providing a path to `imp.find_module` stops it from searching\n        # in special locations for built ins or frozen modules.\n        #\n        # The problem here is that this relies on the `sys.path` not being\n        # independently changed since the initialization of this module.\n        # If it is changed, then some packages may fail.\n        #\n        # Any other options available?\n\n        # Raises an exception if the parent module cannot be imported.\n        # This hopefully ensures that we only explicitly import modules\n        # contained in `pydoc.import_path`.\n        imp.find_module(module_name.split('.')[0], import_path)\n\n    if module_name in sys.modules:\n        return sys.modules[module_name]\n    else:\n        __import__(module_name)\n        return sys.modules[module_name]", "response": "Imports a module and returns the corresponding entry\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _safe_import(module_name):\n    class _Null (object):\n        def write(self, *_):\n            pass\n\n    sout, serr = sys.stdout, sys.stderr\n    sys.stdout, sys.stderr = _Null(), _Null()\n    try:\n        m = import_module(module_name)\n    except:\n        m = None\n    sys.stdout, sys.stderr = sout, serr\n    return m", "response": "A function for safely importing a module_name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _var_docstrings(tree, module, cls=None, init=False):\n    vs = {}\n    children = list(ast.iter_child_nodes(tree))\n    for i, child in enumerate(children):\n        if isinstance(child, ast.Assign) and len(child.targets) == 1:\n            if not init and isinstance(child.targets[0], ast.Name):\n                name = child.targets[0].id\n            elif (isinstance(child.targets[0], ast.Attribute)\n                    and isinstance(child.targets[0].value, ast.Name)\n                    and child.targets[0].value.id == 'self'):\n                name = child.targets[0].attr\n            else:\n                continue\n            if not _is_exported(name) \\\n                    and name not in getattr(module, '__all__', []):\n                continue\n\n            docstring = ''\n            if (i+1 < len(children)\n                    and isinstance(children[i+1], ast.Expr)\n                    and isinstance(children[i+1].value, ast.Str)):\n                docstring = children[i+1].value.s\n\n            vs[name] = Variable(name, module, docstring, cls=cls)\n    return vs", "response": "Extracts variable docstrings given a tree and a module."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a method resolution list of documentation objects for cls which must be a documentation object.", "response": "def mro(self, cls):\n        \"\"\"\n        Returns a method resolution list of documentation objects\n        for `cls`, which must be a documentation object.\n\n        The list will contain objects belonging to `pydoc.Class` or\n        `pydoc.External`. Objects belonging to the former are exported\n        classes either in this module or in one of its sub-modules.\n        \"\"\"\n        ups = inspect.getmro(cls.cls)\n        return list(map(lambda c: self.find_class(c), ups))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef descendents(self, cls):\n        if cls.cls == type or not hasattr(cls.cls, '__subclasses__'):\n            # Is this right?\n            return []\n\n        downs = cls.cls.__subclasses__()\n        return list(map(lambda c: self.find_class(c), downs))", "response": "Returns a list of documentation objects for cls which must be a documentation object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a Python cls object try to find it in this module or in any of the exported identifiers of the submodules.", "response": "def find_class(self, cls):\n        \"\"\"\n        Given a Python `cls` object, try to find it in this module\n        or in any of the exported identifiers of the submodules.\n        \"\"\"\n        for doc_cls in self.classes():\n            if cls is doc_cls.cls:\n                return doc_cls\n        for module in self.submodules():\n            doc_cls = module.find_class(cls)\n            if not isinstance(doc_cls, External):\n                return doc_cls\n        return External('%s.%s' % (cls.__module__, cls.__name__))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsearches this module and all of its sub - modules for an exported analyzed version of an analyzed version of an external version of the given identifier.", "response": "def find_ident(self, name):\n        \"\"\"\n        Searches this module and **all** of its sub-modules for an\n        identifier with name `name` in its list of exported\n        identifiers according to `pydoc`. Note that unexported\n        sub-modules are searched.\n\n        A bare identifier (without `.` separators) will only be checked\n        for in this module.\n\n        The documentation object corresponding to the identifier is\n        returned. If one cannot be found, then an instance of\n        `External` is returned populated with the given identifier.\n        \"\"\"\n        if name in self.refdoc:\n            return self.refdoc[name]\n        for module in self.submodules():\n            o = module.find_ident(name)\n            if not isinstance(o, External):\n                return o\n        return External(name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn all documented module level variables in the module level sorted alphabetically as a list of pydoc. Variable.", "response": "def variables(self):\n        \"\"\"\n        Returns all documented module level variables in the module\n        sorted alphabetically as a list of `pydoc.Variable`.\n        \"\"\"\n        p = lambda o: isinstance(o, Variable) and self._docfilter(o)\n        return sorted(filter(p, self.doc.values()))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn all documented module level classes in the module level classes sorted alphabetically as a list of pydoc. Class.", "response": "def classes(self):\n        \"\"\"\n        Returns all documented module level classes in the module\n        sorted alphabetically as a list of `pydoc.Class`.\n        \"\"\"\n        p = lambda o: isinstance(o, Class) and self._docfilter(o)\n        return sorted(filter(p, self.doc.values()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef functions(self):\n        p = lambda o: isinstance(o, Function) and self._docfilter(o)\n        return sorted(filter(p, self.doc.values()))", "response": "Returns all documented module level functions in the module level sorted alphabetically as a list of pydoc. Function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all documented sub - modules in the module sorted alphabetically as a list of pydoc. Module.", "response": "def submodules(self):\n        \"\"\"\n        Returns all documented sub-modules in the module sorted\n        alphabetically as a list of `pydoc.Module`.\n        \"\"\"\n        p = lambda o: isinstance(o, Module) and self._docfilter(o)\n        return sorted(filter(p, self.doc.values()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_submodule(self, name):\n        return self.name != name and name.startswith(self.name)", "response": "Returns True if and only if name starts with the full\n        import path of self."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __is_exported(self, name, module):\n        if hasattr(self.module, '__all__'):\n            return name in self.module.__all__\n        if not _is_exported(name):\n            return False\n        if module is None:\n            return False\n        if module is not None and self.module.__name__ != module.__name__:\n            return name in self._declared_variables\n        return True", "response": "Returns True if name is exported for this module."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __public_objs(self):\n        members = dict(inspect.getmembers(self.module))\n        return dict([(name, obj)\n                     for name, obj in members.items()\n                     if self.__is_exported(name, inspect.getmodule(obj))])", "response": "Returns a dictionary mapping a public identifier name to a\n        Python object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __new_submodule(self, name, obj):\n        # Forcefully set the module name so that it is always the absolute\n        # import path. We can't rely on `obj.__name__`, since it doesn't\n        # necessarily correspond to the public exported name of the module.\n        obj.__dict__['__budoc_module_name'] = '%s.%s' % (self.refname, name)\n        return Module(obj,\n                      docfilter=self._docfilter,\n                      allsubmodules=self._allsubmodules)", "response": "Create a new submodule for this object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning all documented class variables in the class sorted by name.", "response": "def class_variables(self):\n        \"\"\"\n        Returns all documented class variables in the class, sorted\n        alphabetically as a list of `pydoc.Variable`.\n        \"\"\"\n        p = lambda o: isinstance(o, Variable) and self.module._docfilter(o)\n        return filter(p, self.doc.values())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all instance variables in the class sorted by name.", "response": "def instance_variables(self):\n        \"\"\"\n        Returns all instance variables in the class, sorted\n        alphabetically as a list of `pydoc.Variable`. Instance variables\n        are attributes of `self` defined in a class's `__init__`\n        method.\n        \"\"\"\n        p = lambda o: isinstance(o, Variable) and self.module._docfilter(o)\n        return filter(p, self.doc_init.values())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn all documented methods as pydoc. Function objects in the class sorted alphabetically with __init__ always coming first.", "response": "def methods(self):\n        \"\"\"\n        Returns all documented methods as `pydoc.Function` objects in\n        the class, sorted alphabetically with `__init__` always coming\n        first.\n\n        Unfortunately, this also includes class methods.\n        \"\"\"\n        p = lambda o: (isinstance(o, Function)\n                       and o.method\n                       and self.module._docfilter(o))\n        return filter(p, self.doc.values())"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfills the inheritance of this class with missing documentation from its ancestor list.", "response": "def _fill_inheritance(self):\n        \"\"\"\n        Traverses this class's ancestor list and attempts to fill in\n        missing documentation from its ancestor's documentation.\n\n        The first pass connects variables, methods and functions with\n        their inherited couterparts. (The templates will decide how to\n        display docstrings.) The second pass attempts to add instance\n        variables to this class that were only explicitly declared in\n        a parent class. This second pass is necessary since instance\n        variables are only discoverable by traversing the abstract\n        syntax tree.\n        \"\"\"\n        mro = filter(lambda c: c != self and isinstance(c, Class),\n                     self.module.mro(self))\n\n        def search(d, fdoc):\n            for c in mro:\n                doc = fdoc(c)\n                if d.name in doc and isinstance(d, type(doc[d.name])):\n                    return doc[d.name]\n            return None\n        for fdoc in (lambda c: c.doc_init, lambda c: c.doc):\n            for d in fdoc(self).values():\n                dinherit = search(d, fdoc)\n                if dinherit is not None:\n                    d.inherits = dinherit\n\n        # Since instance variables aren't part of a class's members,\n        # we need to manually deduce inheritance. Oh lawdy.\n        for c in mro:\n            for name in filter(lambda n: n not in self.doc_init, c.doc_init):\n                d = c.doc_init[name]\n                self.doc_init[name] = Variable(d.name, d.module, '', cls=self)\n                self.doc_init[name].inherits = d"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __public_objs(self):\n        _budoc = getattr(self.module.module, '__budoc__', {})\n\n        def forced_out(name):\n            return _budoc.get('%s.%s' % (self.name, name), False) is None\n\n        def exported(name):\n            exported = name == '__init__' or _is_exported(name)\n            return not forced_out(name) and exported\n\n        idents = dict(inspect.getmembers(self.cls))\n        return dict([(n, o) for n, o in idents.items() if exported(n)])", "response": "Returns a dictionary mapping a public identifier name to a\n        Python object. This counts the __init__ method as being\n        public."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef params(self):\n        def fmt_param(el):\n            if isinstance(el, str) or isinstance(el, unicode):\n                return el\n            else:\n                return '(%s)' % (', '.join(map(fmt_param, el)))\n        try:\n            getspec = getattr(inspect, 'getfullargspec', inspect.getargspec)\n            s = getspec(self.func)\n        except TypeError:\n            # I guess this is for C builtin functions?\n            return ['...']\n\n        params = []\n        for i, param in enumerate(s.args):\n            if param.lower() == 'self':\n                continue\n            if s.defaults is not None and len(s.args) - i <= len(s.defaults):\n                defind = len(s.defaults) - (len(s.args) - i)\n                default_value = s.defaults[defind]\n                value = repr(default_value).strip()\n                if value[0] == '<' and value[-1] == '>':\n                    if type(default_value) == types.TypeType:\n                        value = default_value.__name__\n                    elif type(default_value) == types.ObjectType:\n                        value = '%s()'%(default_value.__class__.__name__)\n                params.append('%s=%s' % (param, value))\n            else:\n                params.append(fmt_param(param))\n        if s.varargs is not None:\n            params.append('*%s' % s.varargs)\n\n        # TODO: This needs to be adjusted in Python 3. There's more stuff\n        #       returned from getfullargspec than what we're looking at here.\n        keywords = getattr(s, 'varkw', getattr(s, 'keywords', None))\n        if keywords is not None:\n            params.append('**%s' % keywords)\n        return params", "response": "Returns a list of the nicely formatted parameter names for this function."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dict of default args from the environment which can be overridden by command line args.", "response": "def _defaults():\n    \"\"\"Returns a dict of default args from the environment, which can be\n    overridden by command line args.\n    \"\"\"\n    d = {}\n    d['url'] = os.environ.get('BUGZSCOUT_URL')\n    d['user'] = os.environ.get('BUGZSCOUT_USER')\n    d['project'] = os.environ.get('BUGZSCOUT_PROJECT')\n    d['area'] = os.environ.get('BUGZSCOUT_AREA')\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _from_args(args):\n    return bugzscout.BugzScout(args.url, args.user, args.project, args.area)", "response": "Factory method to create a new instance from command line args."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nenable logging o stream.", "response": "def _init_logging(verbose):\n    \"\"\"Enable logging o stream.\"\"\"\n    hdlr = logging.StreamHandler()\n    hdlr.setFormatter(logging.Formatter(\n        '%(asctime)s [%(levelname)s] [%(module)s] %(message)s'))\n    LOG.addHandler(hdlr)\n    if verbose:\n        LOG.setLevel(logging.DEBUG)\n        LOG.debug('Verbose output enabled.')\n    else:\n        LOG.setLevel(logging.INFO)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse and return command line arguments.", "response": "def _parse_args():\n    \"\"\"Parse and return command line arguments.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=_CliFormatter)\n    parser.add_argument('-v', '--verbose', action='store_true',\n                        help='Enable verbose output.')\n\n    fb_group = parser.add_argument_group('FogBugz arguments')\n    fb_group.add_argument(\n        '-u', '--url', help=(\n            'URL for bugzscout requests to be sent. Should be something '\n            'like .../scoutSubmit.asp.'))\n    fb_group.add_argument(\n        '--user', help='User to designate when submitting via bugzscout.')\n    fb_group.add_argument(\n        '--project', help='Fogbugz project to file cases under.')\n    fb_group.add_argument(\n        '--area', help='Fogbugz area to file cases under.')\n\n    error_group = parser.add_argument_group('error arguments')\n    error_group.add_argument('-e', '--extra',\n                             help='Extra data to send with error.')\n    error_group.add_argument('--default-message',\n                             help='Set default message if case is new.')\n    error_group.add_argument('description',\n                             help=('Description of error. Will be matched '\n                                   'against existing cases.'))\n\n    parser.set_defaults(**_defaults())\n\n    return parser.parse_args()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new instance and publish an error from command line args.", "response": "def main():\n    \"\"\"Create a new instance and publish an error from command line args.\n\n    There is a console script for invoking this function from the command\n    line directly.\n    \"\"\"\n    args = _parse_args()\n    _init_logging(args.verbose)\n    client = _from_args(args)\n    client.submit_error(args.description, args.extra,\n                        default_message=args.default_message)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nplotting original signal low - pass filtered and high - pass filtered signals", "response": "def plot_lf_hf(x, xlf, xhf, title=''):\n    '''Plot original signal, low-pass filtered, and high-pass filtered signals\n\n    Args\n    ----\n    x: ndarray\n        Signal data array\n    xlf: ndarray\n        Low-pass filtered signal\n    xhf: ndarray\n        High-pass filtered signal\n    title: str\n        Main title of plot\n    '''\n    from . import plotutils\n\n    fig, (ax1, ax2, ax3) = plt.subplots(3,1, sharex=True, sharey=True)\n\n    plt.title(title)\n\n    #ax1.title.set_text('All freqencies')\n    ax1.plot(range(len(x)), x, color=_colors[0], linewidth=_linewidth,\n             label='original')\n    ax1.legend(loc='upper right')\n\n    #ax2.title.set_text('Low-pass filtered')\n    ax2.plot(range(len(xlf)), xlf, color=_colors[1], linewidth=_linewidth,\n             label='low-pass')\n    ax2.legend(loc='upper right')\n    ax2.set_ylabel('Frequency (Hz)')\n\n    #ax3.title.set_text('High-pass filtered')\n    ax3.plot(range(len(xhf)), xhf, color=_colors[2], linewidth=_linewidth,\n             label='high-pass')\n    ax3.legend(loc='upper right')\n\n\n    ax1, ax2, ax3 = plotutils.add_alpha_labels([ax1, ax2, ax3], color='black',\n                                               facecolor='none',\n                                               edgecolor='none')\n\n    # TODO break into util function\n    # Convert sample # ticks to times\n    total_seconds = ax3.get_xticks()/16\n\n    # with timedelta: (stop - start).total_seconds()\n    hours, remainder = divmod(total_seconds, 3600)\n    minutes, seconds = divmod(remainder, 60)\n    strtime = lambda minutes, seconds: '{:.0f}:{:02.0f}'.format(minutes, seconds)\n    labels = list(map(strtime, minutes, seconds))\n\n    ax3.set_xticklabels(labels)\n\n    plt.xlabel('Sample time (minute:second)')\n    plt.show()\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plot_acc_pry_depth(A_g_lf, A_g_hf, pry_deg, depths, glide_mask=None):\n    '''Plot the acceleration with the pitch, roll, and heading\n\n    Args\n    ----\n    A_g_lf: ndarray\n        Low-pass filtered calibration accelerometer signal\n    A_g_hf: ndarray\n        High-pass filtered calibration accelerometer signal\n    pry_deg: ndarray\n        Pitch roll and heading in degrees\n    depths: ndarray\n        Depth data for all samples\n    glide_mask: ndarray\n        Boolean array for slicing glides from tag data\n    '''\n\n    import numpy\n\n    fig, (ax1, ax2, ax3) = plt.subplots(3,1, sharex=True)\n\n    ax1.title.set_text('acceleromter')\n    ax1.plot(range(len(A_g_lf)), A_g_lf, color=_colors[0])\n\n    ax1.title.set_text('PRH')\n    ax2.plot(range(len(pry_deg)), pry_deg, color=_colors[1])\n\n    ax3.title.set_text('depth')\n    ax3.plot(range(len(depths)), depths, color=_colors[2])\n    ax3.invert_yaxis()\n\n    if glide_mask is not None:\n        ind = range(len(glide_mask))\n        ax1 = plot_shade_mask(ax1, ind, glide_mask)\n        ax2 = plot_shade_mask(ax2, ind, glide_mask)\n        ax3 = plot_shade_mask(ax3, ind, glide_mask)\n\n    plt.show()\n\n    return None", "response": "Plot the acceleration with the pitch roll and heading in degrees."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nplot welch PSD with peaks as scatter points", "response": "def plot_welch_peaks(f, S, peak_loc=None, title=''):\n    '''Plot welch PSD with peaks as scatter points\n\n    Args\n    ----\n    f: ndarray\n        Array of frequencies produced with PSD\n    S: ndarray\n        Array of powers produced with PSD\n    peak_loc: ndarray\n        Indices of peak locations in signal\n    title: str\n        Main title for plot\n    '''\n    plt.plot(f, S, linewidth=_linewidth)\n    plt.title(title)\n    plt.xlabel('Fequency (Hz)')\n    plt.ylabel('\"Power\" (g**2 Hz**\u22121)')\n\n    if peak_loc is not None:\n        plt.scatter(f[peak_loc], S[peak_loc], label='peaks')\n        plt.legend(loc='upper right')\n\n    plt.show()\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nplotting the FFT of the frequency and power of the frequency and the sensor of the frequency S.", "response": "def plot_fft(f, S, dt):\n    '''Plot fft\n\n    Args\n    ----\n    f: ndarray\n        Array of frequencies produced with PSD\n    S: ndarray\n        Array of powers produced with PSD\n    dt: ndarray\n        Sampling rate of sensor\n    '''\n    import numpy\n\n    xf = numpy.linspace(0.0, 1/(2.0*dt), N/2)\n    plt.plot(xf, 2.0/N * numpy.abs(S[:N//2]), linewidth=_linewidth)\n    plt.show()\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nplots Welch perdiogram Args ---- x: ndarray Signal array fs: float Sampling frequency nperseg: float Length of each data segment in PSD", "response": "def plot_welch_perdiogram(x, fs, nperseg):\n    '''Plot Welch perdiogram\n\n    Args\n    ----\n    x: ndarray\n        Signal array\n    fs: float\n        Sampling frequency\n    nperseg: float\n        Length of each data segment in PSD\n    '''\n    import scipy.signal\n    import numpy\n\n    # Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by\n    # 0.001V**2/Hz of white noise sampled at 10 kHz.\n    N = len(x)\n    time = numpy.arange(N) / fs\n\n    # Compute and plot the power spectral density.\n    f, Pxx_den = scipy.signal.welch(x, fs, nperseg=nperseg)\n\n    plt.semilogy(f, Pxx_den)\n    plt.ylim([0.5e-3, 1])\n    plt.xlabel('frequency [Hz]')\n    plt.ylabel('PSD [V**2/Hz]')\n    plt.show()\n\n    # If we average the last half of the spectral density, to exclude the peak,\n    # we can recover the noise power on the signal.\n    numpy.mean(Pxx_den[256:])  # 0.0009924865443739191\n\n    # compute power spectrum\n    f, Pxx_spec = scipy.signal.welch(x, fs, 'flattop', 1024,\n                                     scaling='spectrum')\n\n    plt.figure()\n    plt.semilogy(f, numpy.sqrt(Pxx_spec))\n    plt.xlabel('frequency [Hz]')\n    plt.ylabel('Linear spectrum [V RMS]')\n    plt.show()\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nplotting the frequency response and filter overlay for butter filtered data", "response": "def plot_data_filter(data, data_f, b, a, cutoff, fs):\n    '''Plot frequency response and filter overlay for butter filtered data\n\n    Args\n    ----\n    data: ndarray\n        Signal array\n    data_f: float\n        Signal sampling rate\n    b: array_like\n        Numerator of a linear filter\n    a: array_like\n        Denominator of a linear filter\n    cutoff: float\n        Cutoff frequency for the filter\n    fs: float\n        Sampling rate of the signal\n\n    Notes\n    -----\n    http://stackoverflow.com/a/25192640/943773\n    '''\n    import matplotlib.pyplot as plt\n    import numpy\n    import scipy.signal\n\n    n = len(data)\n    T = n/fs\n    t = numpy.linspace(0, T, n, endpoint=False)\n\n    # Calculate frequency response\n    w, h = scipy.signal.freqz(b, a, worN=8000)\n\n    # Plot the frequency response.\n    fig, (ax1, ax2) = plt.subplots(2,1)\n\n    ax1.title.set_text('Lowpass Filter Frequency Response')\n    ax1.plot(0.5*fs * w/numpy.pi, numpy.abs(h), 'b')\n    ax1.plot(cutoff, 0.5*numpy.sqrt(2), 'ko')\n    ax1.axvline(cutoff, color='k')\n    ax1.set_xlim(0, 0.5*fs)\n    ax1.set_xlabel('Frequency [Hz]')\n    ax2.legend()\n\n    # Demonstrate the use of the filter.\n    ax2.plot(t, data, linewidth=_linewidth, label='data')\n    ax2.plot(t, data_f, linewidth=_linewidth, label='filtered data')\n    ax2.set_xlabel('Time [sec]')\n    ax2.legend()\n\n    plt.show()\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding url from args", "response": "def _build_url(self, host, sport, method, id, format, parameters):\n        \"\"\"\n            build url from args\n        \"\"\"\n        path = \"/\".join(filter(None, (sport, method, id)))\n        url = \"https://\" + host + \"/\" + path + \".\" + format\n        if parameters:\n            paramstring = urllib.parse.urlencode(parameters)\n            url = url + \"?\" + paramstring\n        return url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning json current roster of team", "response": "def get_teams(self):\n        \"\"\" Return json current roster of team \"\"\"\n        return self.make_request(host=\"erikberg.com\", sport='nba',\n                                 method=\"teams\", id=None,\n                                 format=\"json\",\n                                 parameters={})"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the pitch roll and heading for triaxial movement signalsi", "response": "def prh(ax, ay, az):\n    '''Calculate the pitch, roll and heading for triaxial movement signalsi\n\n    Args\n    ----\n    ax: ndarray\n        x-axis acceleration values\n    ay: ndarray\n        y-axis acceleration values\n    az: ndarray\n        z-axis acceleration values\n\n    Returns\n    -------\n    pitch: ndarray\n        Pitch angle in radians\n    roll: ndarray\n        Pitch angle in radians\n    yaw: ndarray\n        Pitch angle in radians\n    '''\n\n    p = pitch(ax, ay, az)\n    r = roll(ax, ay, az)\n    y = yaw(ax, ay, az)\n\n    #from dtag_toolbox_python.dtag2 import a2pr\n    #pitch, roll, A_norm = a2pr.a2pr(A_g)\n\n    return p, r, y"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the pitch angle in radians", "response": "def pitch(ax, ay, az):\n    '''Angle of x-axis relative to ground (theta)\n\n    Args\n    ----\n    ax: ndarray\n        x-axis acceleration values\n    ay: ndarray\n        y-axis acceleration values\n    az: ndarray\n        z-axis acceleration values\n\n    Returns\n    -------\n    pitch: ndarray\n        Pitch angle in radians\n    '''\n    import numpy\n    # arctan2 not needed here to cover all quadrants, just for consistency\n    return numpy.arctan(ax, numpy.sqrt(ay**2+az**2))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns ndarray of integers representing the absolute degrees of the base of the base of the base of the base of the base of the base of the base of the base of the base.", "response": "def absdeg(deg):\n    '''Change from signed degrees to 0-180 or 0-360 ranges\n\n    deg: ndarray\n        Movement data in pitch, roll, yaw (degrees)\n\n    Returns\n    -------\n    deg_abs: ndarray\n        Movement translated from -180:180/-90:90 degrees to 0:360/0:180 degrees\n\n    Example\n    -------\n    deg = numpy.array([-170, -120, 0, 90])\n    absdeg(deg) # returns array([190, 240,   0,  90])\n    '''\n    import numpy\n\n    d = numpy.copy(deg)\n\n    if numpy.max(numpy.abs(deg)) > 90.0:\n        d[deg < 0] = 360 + deg[deg < 0]\n    else:\n        d[deg < 0] = 180 + deg[deg < 0]\n\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint val in green on STDOUT", "response": "def pok(self, val, ok='OK'):\n        \"\"\" Print val: OK in green on STDOUT \"\"\"\n        self.pstd(self.color.green('{}: {}'.format(val, ok)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint val in png on STDOUT", "response": "def png(self, val, ng='ERR'):\n        \"\"\" Print val: ERR in red on STDOUT \"\"\"\n        self.pstd(self.color.red('{}: {}'.format(val, ng)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pwa(self, val, wa='WARN'):\n        self.pstd(self.color.yellow('{}: {}'.format(val, wa)))", "response": "Print val in yellow on STDOUT"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconsoles verbose message to STDOUT", "response": "def pverb(self, *args, **kwargs):\n        \"\"\" Console verbose message to STDOUT \"\"\"\n        if not self.verbose:\n            return\n        self.pstd(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read(self, prompt='', clean=lambda x: x):\n        ans = read(prompt + ' ')\n        return clean(ans)", "response": "Display a prompt and ask user for a new entry in the cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rvpl(self, prompt, error='Entered value is invalid', intro=None,\n             validator=lambda x: x != '', clean=lambda x: x.strip(),\n             strict=True, default=None):\n        \"\"\" Start a read-validate-print loop\n\n        The RVPL will read the user input, validate it, and loop until the\n        entered value passes the validation, then return it.\n\n        Error message can be customized using the ``error`` argument. If the\n        value is a callable, it will be called with the value and it will be\n        expected to return a printable message. Exceptions raised by the\n        ``error`` function are not trapped.\n\n        When ``intro`` is passed, it is printed above the prompt.\n\n        The ``validator`` argument is is a function that validates the user\n        input. Default validator simply validates if user entered any value.\n\n        The ``clean`` argument specifies a function for the ``read()`` method\n        with the same semantics.\n        \"\"\"\n        if intro:\n            self.pstd(utils.rewrap_long(intro))\n        val = self.read(prompt, clean)\n        while not validator(val):\n            if not strict:\n                return default\n            if hasattr(error, '__call__'):\n                self.perr(error(val))\n            else:\n                self.perr(error)\n            val = self.read(prompt, clean)\n        return val", "response": "Read a user input from the user and return the value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nasking user for yes or no answer.", "response": "def yesno(self, prompt, error='Please type either y or n', intro=None,\n              default=None):\n        \"\"\" Ask user for yes or no answer\n\n        The prompt will include a typical '(y/n):' at the end. Depending on\n        whether ``default`` was specified, this may also be '(Y/n):' or\n        '(y/N):'.\n\n        The ``default`` argument can be ``True`` or ``False``, with meaning of\n        'yes' and 'no' respectively. Default is ``None`` which means no\n        default. When default value is specified, malformed or empty response\n        will cause the ``default`` value to be returned.\n\n        Optional ``intro`` text can be specified which will be shown above the\n        prompt.\n        \"\"\"\n        if default is None:\n            prompt += ' (y/n):'\n        else:\n            if default is True:\n                prompt += ' (Y/n):'\n                default = 'y'\n            if default is False:\n                prompt += ' (y/N):'\n                default = 'n'\n        validator = lambda x: x in ['y', 'yes', 'n', 'no']\n        val = self.rvpl(prompt, error=error, intro=intro, validator=validator,\n                        clean=lambda x: x.strip().lower(),\n                        strict=default is None, default=default)\n        return val in ['y', 'yes']"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprint a menu entry for the specified items.", "response": "def menu(self, choices, prompt='Please choose from the provided options:',\n             error='Invalid choice', intro=None, strict=True, default=None,\n             numerator=lambda x: [i + 1 for i in range(x)],\n             formatter=lambda x, y: '{0:>3}) {1}'.format(x, y),\n             clean=utils.safeint):\n        \"\"\" Print a menu\n\n        The choices must be an iterable of two-tuples where the first value is\n        the value of the menu item, and the second is the label for that\n        matches the value.\n\n        The menu will be printed with numeric choices. For example::\n\n            1) foo\n            2) bar\n\n        Formatting of the number is controlled by the formatter function which\n        can be overridden by passing the ``formatter`` argument.\n\n        The numbers used for the menu are generated using the numerator\n        function which can be specified using the ``numerator`` function. This\n        function must take the number of choices and return the same number of\n        items that will be used as choice characters as a list.\n\n        The cleaner function is passed to ``pvpl()`` method can be customized\n        using ``clean`` argument. This function should generally be customized\n        whenever ``numerator`` is customized, as default cleaner converts\n        input to integers to match the default numerator.\n\n        Optional ``intro`` argument can be passed to print a message above the\n        menu.\n\n        The return value of this method is the value user has chosen. The\n        prompt will keep asking the user for input until a valid choice is\n        selected. Each time an invalid selection is made, error message is\n        printed. This message can be customized using ``error`` argument.\n\n        If ``strict`` argument is set, then only values in choices are allowed,\n        otherwise any value will be allowed. The ``default`` argument can be\n        used to define what value is returned in case user select an invalid\n        value when strict checking is off.\n        \"\"\"\n        numbers = list(numerator(len(choices)))\n        labels = (label for _, label in choices)\n        values = [value for value, _ in choices]\n        # Print intro and menu itself\n        if intro:\n            self.pstd('\\n' + utils.rewrap_long(intro))\n        for n, label in zip(numbers, labels):\n            self.pstd(formatter(n, label))\n        # Define the validator\n        validator = lambda x: x in numbers\n        val = self.rvpl(prompt, error=error, validator=validator, clean=clean,\n                        strict=strict, default=default)\n        if not strict and val == default:\n            return val\n        return values[numbers.index(val)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns iterator that iterates over STDIN line by line .", "response": "def readpipe(self, chunk=None):\n        \"\"\" Return iterator that iterates over STDIN line by line\n\n        If ``chunk`` is set to a positive non-zero integer value, then the\n        reads are performed in chunks of that many lines, and returned as a\n        list. Otherwise the lines are returned one by one.\n        \"\"\"\n        read = []\n        while True:\n            l = sys.stdin.readline()\n            if not l:\n                if read:\n                    yield read\n                    return\n                return\n            if not chunk:\n                yield l\n            else:\n                read.append(l)\n                if len(read) == chunk:\n                    yield read"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef error(self, msg='Program error: {err}', exit=None):\n        def handler(exc):\n            if msg:\n                self.perr(msg.format(err=exc))\n            if exit is not None:\n                self.quit(exit)\n        return handler", "response": "Error handler factory\n\n        This function takes a message with optional ``{err}`` placeholder and\n        returns a function that takes an exception object, prints the error\n        message to STDERR and optionally quits.\n\n        If no message is supplied (e.g., passing ``None`` or ``False`` or empty\n        string), then nothing is output to STDERR.\n\n        The ``exit`` argument can be set to a non-zero value, in which case the\n        program quits after printing the message using its value as return\n        value of the program.\n\n        The returned function can be used with the ``progress()`` context\n        manager as error handler."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef progress(self, msg, onerror=None, sep='...', end='DONE', abrt='FAIL',\n                 prog='.', excs=(Exception,), reraise=True):\n        \"\"\" Context manager for handling interactive prog indication\n\n        This context manager streamlines presenting banners and prog\n        indicators. To start the prog, pass ``msg`` argument as a start\n        message. For example::\n\n            printer = Console(verbose=True)\n            with printer.progress('Checking files') as prog:\n                # Do some checks\n                if errors:\n                    prog.abrt()\n                prog.end()\n\n        The context manager returns a ``Progress`` instance, which provides\n        methods like ``abrt()`` (abort), ``end()`` (end), and ``prog()`` (print\n        prog indicator).\n\n        The prog methods like ``abrt()`` and ``end()`` will raise an\n        exception that interrupts the prog. These exceptions are\n        ``ProgressEnd`` exception subclasses and are ``ProgressAbrt`` and\n        ``ProgressOK`` respectively. They are silenced and not handled in any\n        way as they only serve the purpose of flow control.\n\n        Other exceptions are trapped and ``abrt()`` is called. The exceptions\n        that should be trapped can be customized using the ``excs`` argument,\n        which should be a tuple of exception classes.\n\n        If a handler function is passed using ``onerror`` argument, then this\n        function takes the raised exception and handles it. By default, the\n        ``error()`` factory is called with no arguments to generate the default\n        error handler. If string is passed, then ``error()`` factory is called\n        with that string.\n\n        Finally, when prog is aborted either naturally or when exception is\n        raised, it is possible to reraise the ``ProgressAbrt`` exception. This\n        is done using the ``reraise`` flag. Default is to reraise.\n        \"\"\"\n        if not onerror:\n            onerror = self.error()\n        if type(onerror) is str:\n            onerror = self.error(msg=onerror)\n        self.pverb(msg, end=sep)\n        prog = progress.Progress(self.pverb, end=end, abrt=abrt, prog=prog)\n        try:\n            yield prog\n            prog.end()\n        except self.ProgressOK:\n            pass\n        except self.ProgressAbrt as err:\n            if reraise:\n                raise err\n        except KeyboardInterrupt:\n            raise\n        except excs as err:\n            prog.abrt(noraise=True)\n            if onerror:\n                onerror(err)\n            if self.debug:\n                traceback.print_exc()\n            if reraise:\n                raise self.ProgressAbrt()", "response": "This function returns a progress message that is printed to the console."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_register(self, register):\n\t\tif(self._lock):\n\t\t\traise SetupError(\"RegisterInterface is already running, no changes to the register layout can be performed\")\n\t\tif(len(self.registers_by_index) >= self.size):\n\t\t\traise SetupError(\"Number of Registers would exceed the address space({})\".format(self.size))\n\t\tif(register.name in self.registers_by_name):\n\t\t\traise SetupError(\"Register with name '{}' already added.\".format(register.name))\n\t\tself.registers_by_name[register.name] = register\n\t\tself.registers_by_index.append(register)\n\t\treturn len(self.registers_by_index) - 1", "response": "_add_register adds the register to the interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites a word in the Register with the specified name or index.", "response": "def write(self, name_or_index, word):\n\t\t\"\"\"\n\t\tWrite a word in the Register with the name ``name_or_index`` or with the index ``name_or_index``.\n\t\t``name_or_index`` hat to be either ``str`` or ``int``. If the type of ``name_or_index``\n\t\tis wrong an AttributeError will be raised.\n\n\t\tIf there is no Register with the specified name or index, a NameError will be raised.\n\t\t\"\"\"\n\t\tif(isinstance(name_or_index, str)):\n\t\t\tif(name_or_index in self.registers_by_name):\n\t\t\t\tself.registers_by_name[name_or_index].write(word)\n\t\t\telse:\n\t\t\t\traise NameError(\"No Register with name '{}'\".format(name_or_index))\n\t\telif( isinstance(name_or_index, int)):\n\t\t\tif(name_or_index < len(self.registers_by_index)):\n\t\t\t\tself.registers_by_index[name_or_index].write(word)\n\t\t\telse:\n\t\t\t\traise NameError(\"No Register with index '{}'\".format(name_or_index))\n\t\telse:\n\t\t\traise AttributeError(\"name_or_index has to be `str` or `int`, but is {}\".format(type(name_or_index)))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef en_dis_able_interrupts(self, mask):\n\t\tfor shift, interrupt in enumerate(self.interrupts):\n\t\t\tif(mask & (1 << shift)):\n\t\t\t\tinterrupt.enable = True\n\t\t\telse:\n\t\t\t\tinterrupt.enable = False", "response": "Enables or disables Interrupts."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_interrupt(self, interrupt):\n\t\tself.interrupts.append(interrupt)\n\t\tself.constants[interrupt.name] = interrupt.address", "response": "Adds the interrupt to the internal interrupt storage and registers the interrupt address in the internal constants."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninterrupts the Processor and forces him to jump to address.", "response": "def interrupt(self, address):\n\t\t\"\"\"\n\t\tInterrupts the Processor and forces him to jump to ``address``.\n\t\tIf ``push_pc`` is enabled this will push the PC to the stack.\n\t\t\"\"\"\n\t\tif(self.push_pc):\n\t\t\tself.memory_bus.write_word(self.sp, self.pc)\n\t\t\tself._set_sp(self.sp - 1)\n\t\tself._set_pc(address)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nresetting the control registers of the Processor_ and the memory bus.", "response": "def reset(self):\n\t\t\"\"\"\n\t\tResets the control registers of the Processor_(PC_, ECR_ and SP_)\n\t\t\"\"\"\n\t\trom = self.memory_bus.devices[0]\n\t\tif(self.memory_bus.device_count() > 1):\n\t\t\tram = self.memory_bus.devices[1]\n\t\t\tself._set_sp(rom.size + ram.size - 1)\n\t\tself._set_pc(0)\n\t\tself._set_ecr(0)\n\t\tself.cycles = 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_command(self, command):\n\t\tif(command.opcode() in self.commands_by_opcode):\n\t\t\traise SetupError(\"Command with opcode {}(mnemonic: {}) already registered\".format(command.opcode(), command.mnemonic()))\n\t\tcommand.membus = self.memory_bus\n\t\tcommand.devbus = self.device_bus\n\t\tcommand.register_interface = self.register_interface\n\t\tself.commands_by_opcode[command.opcode()] = command", "response": "Register a command in the Processor."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find(self, haystack, needle):\n        try:\n            qstatus = haystack.find(needle)\n        except AttributeError:\n            if needle in haystack:\n                return True\n            else:\n                return False\n        if qstatus == -1:\n            return False\n        elif qstatus != -1:\n            return True", "response": "Searches in haystack and returns True if found False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send(self, msg, error_check=False):\n        with self.lock:\n            msg = msg.replace('\\r', '\\\\r').replace('\\n', '\\\\n') + self._crlf\n            try:\n                data = msg.encode(self.encoding)\n            except UnicodeEncodeError:\n                data = msg.encode(self.fallback_encoding)\n            if len(data) > 512:\n                raise self.MessageTooLong(\"LurklibError: MessageTooLong\")\n            self._socket.send(data)\n            if error_check and self.readable():\n                self._recv()\n                self.stepback()", "response": "Send a string with the CR - LF appended to it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuffering IRC data and handle PING and PONG.", "response": "def _mcon(self):\n        \"\"\" Buffer IRC data and handle PING/PONG. \"\"\"\n        with self.lock:\n            sdata = ' '\n            while sdata[-1] != self._crlf[-1]:\n                if sdata == ' ':\n                    sdata = ''\n                try:\n                    sdata = sdata + \\\n                    self._socket.recv(4096).decode(self.encoding)\n                except UnicodeDecodeError:\n                    sdata = sdata + \\\n                    self._socket.recv(4096).decode(self.fallback_encoding)\n\n            lines = sdata.split(self._crlf)\n            for line in lines:\n                if line.find('PING :') == 0:\n                    self.send(line.replace('PING', 'PONG'))\n                if line != '':\n                    self._buffer.append(line)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _raw_recv(self):\n        with self.lock:\n            if self._index >= len(self._buffer):\n                self._mcon()\n            if self._index >= 199:\n                self._resetbuffer()\n                self._mcon()\n            msg = self._buffer[self._index]\n            while self.find(msg, 'PING :'):\n                self._index += 1\n                try:\n                    msg = self._buffer[self._index]\n                except IndexError:\n                    self._mcon()\n                    self.stepback(append=False)\n\n            self._index += 1\n            return msg", "response": "Return the next available IRC message in the buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readable(self, timeout=2):\n        with self.lock:\n            if len(self._buffer) > self._index:\n                return True\n            else:\n                if self._select([self._socket], [], [], timeout)[0] == []:\n                    return False\n                else:\n                    return True", "response": "Checks whether the socket is readable or not."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprocess nick!user@host data. Returns a tuple containing, the nick, user and host. If a valid hostmask isn't found, return the data as is. Required arguments: * who - nick!user@host data.", "response": "def _from_(self, who):\n        \"\"\"\n        Processes nick!user@host data.\n        Returns a tuple containing, the nick, user and host.\n        If a valid hostmask isn't found, return the data as is.\n        Required arguments:\n        * who - nick!user@host data.\n        \"\"\"\n        try:\n            host = who.split('@', 1)\n            nickident = host[0].split('!', 1)\n            nick = nickident[0]\n            ident = nickident[1]\n            host = host[1]\n            return nick, ident, host\n        except IndexError:\n            return who, '', ''"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreceive and processes an IRC protocol message.", "response": "def _recv(self, rm_colon=False, blocking=True,\n              expected_replies=None, default_rvalue=[''],\n              ignore_unexpected_replies=True, rm_first=True, recur_limit=10):\n        \"\"\"\n        Receives and processes an IRC protocol message.\n        Optional arguments:\n        * rm_colon=False - If True:\n                        If the message is > 3 items long:\n                            Remove the colon(if found) from the [3] item.\n                        Else:\n                        Remove the colon(if found) from the [2] item.\n        * blocking=True - Should this call block?\n        * expected_replies=None - If specified:\n                     If no matching reply is found:\n                        Return the default_rvalue.\n                    Else:\n                        Return the message.\n        * default_rvalue=[''] - If no message or a matching message;\n                            is found, return default_rvalue.\n        * ignore_unexpected_replies=True - If an,\n                                    unexpected reply is encountered,\n                                    should we keep going,\n                                    until we get a valid reply?\n                                    If False, it will just return\n                        default_rvalue(If a valid reply isn't found).\n        * rm_first=True - If True,\n        remove [0] from the message before returning it.\n        \"\"\"\n        append = False\n        if expected_replies:\n            if len(expected_replies) > 1:\n                append = True\n\n        if self.readable():\n            msg = self._raw_recv()\n        else:\n            if not blocking:\n                return default_rvalue\n            else:\n                msg = self._raw_recv()\n\n        msg = msg.split(None, 3)\n\n        if msg[1] in self.error_dictionary:\n            self.exception(msg[1])\n        if rm_colon:\n            if len(msg) > 3:\n                if msg[3][0] == ':':\n                    msg[3] = msg[3][1:]\n            elif len(msg) > 2:\n                if msg[2][0] == ':':\n                    msg[2] = msg[2][1:]\n        if expected_replies:\n            if msg[1] not in expected_replies:\n                self.stepback(append)\n                if ignore_unexpected_replies and recur_limit > 0:\n                    recur_limit -= 1\n                    return self._recv(rm_colon=rm_colon, blocking=blocking, \\\n                               expected_replies=expected_replies, \\\n                               default_rvalue=default_rvalue, \\\n            ignore_unexpected_replies=ignore_unexpected_replies,\n            rm_first=rm_first, recur_limit=recur_limit)\n\n                return default_rvalue\n        if rm_first:\n            return msg[1:]\n        return msg"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef recv(self, timeout=None):\n        with self.lock:\n            if timeout != None:\n                if self.readable(timeout) == False:\n                    return None\n            data = self._raw_recv()\n            segments = data.split()\n\n            if segments[1] == 'JOIN':\n                who = self._from_(segments[0][1:])\n                channel = segments[2][1:]\n                if channel not in self.channels:\n                    self.stepback(append=False)\n                    return 'JOIN', self.join_(channel, process_only=True)\n                else:\n                    self.channels[channel]['USERS'][who[0]] = \\\n                    ['', '', '', '', '']\n                return 'JOIN', (who, channel)\n\n            elif segments[1] == 'PART':\n                who = self._from_(segments[0].replace(':', '', 1))\n                channel = segments[2]\n                del self.channels[channel]['USERS'][who[0]]\n                try:\n                    reason = ' '.join(segments[3:]).replace(':', '', 1)\n                    return 'PART', (who, channel, reason)\n                except IndexError:\n                    who = self._from_(segments[0].replace(':', '', 1))\n                    return 'PART', (who, channel, '')\n\n            elif segments[1] == 'PRIVMSG':\n                who = self._from_(segments[0].replace(':', '', 1))\n                msg = ' '.join(segments[3:]).replace(':', '', 1)\n                rvalue = 'PRIVMSG', (who, segments[2], msg)\n\n                if msg.find('\\001') == 0:\n                    rctcp = self.ctcp_decode(msg)\n                    return 'CTCP', (rvalue[1][0], rvalue[1][1], rctcp)\n                else:\n                    return rvalue\n\n            elif segments[1] == 'NOTICE':\n                who = self._from_(segments[0].replace(':', '', 1))\n                msg = ' '.join(segments[3:]).replace(':', '', 1)\n                if msg.find('\\001') == 0:\n                    msg = self.ctcp_decode(msg)\n                    return 'CTCP_REPLY', (who, segments[2], msg)\n                return 'NOTICE', (who, segments[2], msg)\n\n            elif segments[1] == 'MODE':\n                mode = ' '.join(segments[3:]).replace(':', '', 1)\n                who = self._from_(segments[0][1:])\n                target = segments[2]\n                if target != self.current_nick:\n                    self.parse_cmode_string(mode, target)\n                    return 'MODE', (who, segments[2], mode)\n                else:\n                    return 'MODE', (who, mode.replace(':', '', 1))\n\n            elif segments[1] == 'KICK':\n                who = self._from_(segments[0].replace(':', '', 1))\n                if self.current_nick == segments[3]:\n                    del self.channels[segments[2]]\n                else:\n                    del self.channels[segments[2]]['USERS'][segments[3]]\n                reason = ' '.join(segments[4:]).replace(':', '', 1)\n                return 'KICK', (who, segments[2], segments[3], reason)\n\n            elif segments[1] == 'INVITE':\n                who = self._from_(segments[0].replace(':', '', 1))\n                channel = segments[3].replace(':', '', 1)\n                return 'INVITE', (who, segments[2], channel)\n\n            elif segments[1] == 'NICK':\n                who = self._from_(segments[0].replace(':', '', 1))\n                new_nick = ' '.join(segments[2:]).replace(':', '', 1)\n                if self.current_nick == who[0]:\n                    self.current_nick = new_nick\n                for channel in self.channels:\n                    if who[0] in self.channels[channel]['USERS']:\n                        priv_level = self.channels[channel]['USERS'][who[0]]\n                        del self.channels[channel]['USERS'][who[0]]\n                        self.channels[channel]['USERS'][new_nick] = priv_level\n                return 'NICK', (who, new_nick)\n\n            elif segments[1] == 'TOPIC':\n                who = self._from_(segments[0].replace(':', '', 1))\n                channel = segments[2]\n                topic = ' '.join(segments[3:]).replace(':', '', 1)\n                self.channels[channel]['TOPIC'] = topic\n                return 'TOPIC', (who, channel, topic)\n\n            elif segments[1] == 'QUIT':\n                who = self._from_(segments[0].replace(':', '', 1))\n                msg = ' '.join(segments[2:]).replace(':', '', 1)\n                for channel in self.channels:\n                    if who[0] in self.channels[channel]['USERS']:\n                        del self.channels[channel]['USERS'][who[0]]\n                return 'QUIT', (who, msg)\n\n            elif segments[1] == '250':\n                self.lusers['HIGHESTCONNECTIONS'] = segments[6]\n                self.lusers['TOTALCONNECTIONS'] = segments[9][1:]\n                return 'LUSERS', self.lusers\n\n            elif segments[1] == '251':\n                self.lusers['USERS'] = segments[5]\n                self.lusers['INVISIBLE'] = segments[8]\n                self.lusers['SERVERS'] = segments[11]\n                return 'LUSERS', self.lusers\n\n            elif segments[1] == '252':\n                self.lusers['OPERATORS'] = segments[3]\n                return 'LUSERS', self.lusers\n\n            elif segments[1] == '253':\n                self.lusers['UNKNOWN'] = segments[3]\n                return 'LUSERS', self.lusers\n\n            elif segments[1] == '254':\n                self.lusers['CHANNELS'] = segments[3]\n                return 'LUSERS', self.lusers\n\n            elif segments[1] == '255':\n                self.lusers['CLIENTS'] = segments[5]\n                self.lusers['LSERVERS'] = segments[8]\n                return 'LUSERS', self.lusers\n\n            elif segments[1] == '265':\n                self.lusers['LOCALUSERS'] = segments[6]\n                self.lusers['LOCALMAX'] = segments[8]\n                return 'LUSERS', self.lusers\n\n            elif segments[1] == '266':\n                self.lusers['GLOBALUSERS'] = segments[6]\n                self.lusers['GLOBALMAX'] = segments[8]\n                return 'LUSERS', self.lusers\n\n            elif segments[0] == 'ERROR':\n                self.quit()\n                return 'ERROR', ' '.join(segments[1:]).replace(':', '', 1)\n            else:\n                self.stepback(append=False)\n                return 'UNKNOWN', self._recv(rm_first=False)", "response": "Receive a message from the server."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncase in - sensitive comparison of two strings.", "response": "def compare(self, first, second):\n        \"\"\"\n        Case in-sensitive comparison of two strings.\n        Required arguments:\n        * first - The first string to compare.\n        * second - The second string to compare.\n        \"\"\"\n        if first.lower() == second.lower():\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nposts json data to the url provided and verify the requests was successful", "response": "def post(json_data,\n         url,\n         dry_run=False):\n    \"\"\"\n    POST json data to the url provided and verify the requests was successful\n\n    \"\"\"\n\n    if dry_run:\n        info('POST: %s' % json.dumps(json_data, indent=4))\n    else:\n        response = SESSION.post(url,\n                                data=json.dumps(json_data),\n                                headers={'content-type': 'application/json'})\n\n        if response.status_code != 200:\n            raise Exception(\"Failed to import %s with %s: %s\" %\n                            (json_data, response.status_code, response.text))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef push_json_file(json_file,\n                   url,\n                   dry_run=False,\n                   batch_size=100,\n                   anonymize_fields=[],\n                   remove_fields=[],\n                   rename_fields=[]):\n    \"\"\"\n    read the json file provided and POST in batches no bigger than the\n    batch_size specified to the specified url.\n\n    \"\"\"\n    batch = []\n    json_data = json.loads(json_file.read())\n\n    if isinstance(json_data, list):\n        for item in json_data:\n\n            # anonymize fields\n            for field_name in anonymize_fields:\n                if field_name in item:\n                    item[field_name] = md5sum(item[field_name])\n\n            # remove fields\n            for field_name in remove_fields:\n                if field_name in item:\n                    del item[field_name]\n\n            # rename fields\n            for (field_name, new_field_name) in rename_fields:\n                if field_name in item:\n                    item[new_field_name] = item[field_name]\n                    del item[field_name]\n\n            batch.append(item)\n\n            if len(batch) >= batch_size:\n                post(batch,\n                     url,\n                     dry_run=dry_run)\n                batch = []\n\n        if len(batch) > 0:\n            post(batch,\n                 url,\n                 dry_run=dry_run)\n\n    else:\n        post(json_data,\n             url,\n             dry_run=dry_run)", "response": "Pushes the json file to the specified url."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads the name and inventory of the object", "response": "def load(self):\n        \"\"\" Loads the shop name and inventory\n        \"\"\"\n        pg = self.usr.getPage(\"http://www.neopets.com/objects.phtml?type=shop&obj_type=\" + self.id)\n        \n        self.name = pg.find(\"td\", \"contentModuleHeader\").text.strip()\n        self.inventory = MainShopInventory(self.usr, self.id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding a random string.", "response": "def random_token(length=10):\n    \"\"\"\n    Builds a random string.\n\n    :param length: Token length. **Default:** 10\n    :type length: int\n    :return: str\n    \"\"\"\n    return ''.join(random.choice(string.ascii_uppercase + string.digits)\n                   for _ in range(length))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the path to the home directory of the current user.", "response": "def home_dir():\n    '''\n    Returns:\n\n        str : Path to home directory (or ``Documents`` directory on Windows).\n    '''\n    if os.name == 'nt':\n        from win32com.shell import shell, shellcon\n\n        return shell.SHGetFolderPath(0, shellcon.CSIDL_PERSONAL, 0, 0)\n    else:\n        return os.path.expanduser('~')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_plugins_directory(config_path=None, microdrop_user_root=None):\n    '''\n    Resolve plugins directory.\n\n    Plugins directory is resolved as follows, highest-priority first:\n\n     1. ``plugins`` directory specified in provided :data:`config_path`.\n     2. ``plugins`` sub-directory of specified MicroDrop profile path (i.e.,\n        :data:`microdrop_user_root`)\n     3. ``plugins`` sub-directory of parent directory of configuration file\n        path specified using ``MICRODROP_CONFIG`` environment variable.\n     4. ``plugins`` sub-directory of MicroDrop profile path specified using\n        ``MICRODROP_PROFILE`` environment variable.\n     5. Plugins directory specified in\n        ``<home directory>/MicroDrop/microdrop.ini``.\n     6. Plugins directory in default profile location, i.e.,\n        ``<home directory>/MicroDrop/plugins``.\n\n    Parameters\n    ----------\n    config_path : str, optional\n        Configuration file path (i.e., path to ``microdrop.ini``).\n    microdrop_user_root : str, optional\n        Path to MicroDrop user data directory.\n\n    Returns\n    -------\n    path\n        Absolute path to plugins directory.\n    '''\n    RESOLVED_BY_NONE = 'default'\n    RESOLVED_BY_CONFIG_ARG = 'config_path argument'\n    RESOLVED_BY_PROFILE_ARG = 'microdrop_user_root argument'\n    RESOLVED_BY_CONFIG_ENV = 'MICRODROP_CONFIG environment variable'\n    RESOLVED_BY_PROFILE_ENV = 'MICRODROP_PROFILE environment variable'\n\n    resolved_by = [RESOLVED_BY_NONE]\n\n    # # Find plugins directory path #\n    if microdrop_user_root is not None:\n        microdrop_user_root = path(microdrop_user_root).realpath()\n        resolved_by.append(RESOLVED_BY_PROFILE_ARG)\n    elif 'MICRODROP_PROFILE' in os.environ:\n        microdrop_user_root = path(os.environ['MICRODROP_PROFILE']).realpath()\n        resolved_by.append(RESOLVED_BY_PROFILE_ENV)\n    else:\n        microdrop_user_root = path(home_dir()).joinpath('MicroDrop')\n\n    if config_path is not None:\n        config_path = path(config_path).expand()\n        resolved_by.append(RESOLVED_BY_CONFIG_ARG)\n    elif 'MICRODROP_CONFIG' in os.environ:\n        config_path = path(os.environ['MICRODROP_CONFIG']).realpath()\n        resolved_by.append(RESOLVED_BY_CONFIG_ENV)\n    else:\n        config_path = microdrop_user_root.joinpath('microdrop.ini')\n\n    try:\n        # Look up plugins directory stored in configuration file.\n        plugins_directory = path(configobj.ConfigObj(config_path)\n                                 ['plugins']['directory'])\n        if not plugins_directory.isabs():\n            # Plugins directory stored in configuration file as relative path.\n            # Interpret as relative to parent directory of configuration file.\n            plugins_directory = config_path.parent.joinpath(plugins_directory)\n        if not plugins_directory.isdir():\n            raise IOError('Plugins directory does not exist: {}'\n                          .format(plugins_directory))\n    except Exception, why:\n        # Error looking up plugins directory in configuration file (maybe no\n        # plugins directory was listed in configuration file?).\n        plugins_directory = microdrop_user_root.joinpath('plugins')\n        logger.warning('%s.  Using default plugins directory: %s', why,\n                       plugins_directory)\n        if resolved_by[-1] in (RESOLVED_BY_CONFIG_ARG, RESOLVED_BY_CONFIG_ENV):\n            resolved_by.pop()\n    logger.info('Resolved plugins directory by %s: %s', resolved_by[-1],\n                plugins_directory)\n    return plugins_directory", "response": "Resolve plugins directory.\n\n    Plugins directory is resolved as follows, highest-priority first:\n\n     1. ``plugins`` directory specified in provided :data:`config_path`.\n     2. ``plugins`` sub-directory of specified MicroDrop profile path (i.e.,\n        :data:`microdrop_user_root`)\n     3. ``plugins`` sub-directory of parent directory of configuration file\n        path specified using ``MICRODROP_CONFIG`` environment variable.\n     4. ``plugins`` sub-directory of MicroDrop profile path specified using\n        ``MICRODROP_PROFILE`` environment variable.\n     5. Plugins directory specified in\n        ``<home directory>/MicroDrop/microdrop.ini``.\n     6. Plugins directory in default profile location, i.e.,\n        ``<home directory>/MicroDrop/plugins``.\n\n    Parameters\n    ----------\n    config_path : str, optional\n        Configuration file path (i.e., path to ``microdrop.ini``).\n    microdrop_user_root : str, optional\n        Path to MicroDrop user data directory.\n\n    Returns\n    -------\n    path\n        Absolute path to plugins directory."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef plugin_request(plugin_str):\n    '''\n    Extract plugin name and version specifiers from plugin descriptor string.\n\n    .. versionchanged:: 0.25.2\n        Import from `pip_helpers` locally to avoid error `sci-bots/mpm#5`_.\n\n        .. _sci-bots/mpm#5: https://github.com/sci-bots/mpm/issues/5\n    '''\n    from pip_helpers import CRE_PACKAGE\n\n    match = CRE_PACKAGE.match(plugin_str)\n    if not match:\n        raise ValueError('Invalid plugin descriptor. Must be like \"foo\", '\n                         '\"foo==1.0\", \"foo>=1.0\", etc.')\n    return match.groupdict()", "response": "Extract plugin name and version specifiers from plugin descriptor string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninstall a MicroDrop plugin package into a new MicroDrop user plugins directory.", "response": "def install(plugin_package, plugins_directory, server_url=DEFAULT_SERVER_URL):\n    '''\n    Parameters\n    ----------\n    plugin_package : str\n        Name of plugin package hosted on MicroDrop plugin index. Version\n        constraints are also supported (e.g., ``\"foo\", \"foo==1.0\",\n        \"foo>=1.0\"``, etc.)  See `version specifiers`_ reference for more\n        details.\n    plugins_directory : str\n        Path to MicroDrop user plugins directory.\n    server_url : str\n        URL of JSON request for MicroDrop plugins package index.  See\n        ``DEFAULT_SERVER_URL`` for default.\n\n    Returns\n    -------\n    (path, dict)\n        Path to directory of installed plugin and plugin package metadata\n        dictionary.\n\n\n    .. _version specifiers:\n        https://www.python.org/dev/peps/pep-0440/#version-specifiers\n\n    .. versionchanged:: 0.25.2\n        Import `pip_helpers` locally to avoid error `sci-bots/mpm#5`_.\n\n        .. _sci-bots/mpm#5: https://github.com/sci-bots/mpm/issues/5\n    '''\n    import pip_helpers\n\n    if path(plugin_package).isfile():\n        plugin_is_file = True\n        with open(plugin_package, 'rb') as plugin_file:\n            # Plugin package is a file.\n            plugin_file_metadata = extract_metadata(plugin_file)\n        name = plugin_file_metadata['package_name']\n        version = plugin_file_metadata['version']\n    else:\n        plugin_is_file = False\n        # Look up latest release matching specifiers.\n        try:\n            name, releases = pip_helpers.get_releases(plugin_package,\n                                                      server_url=server_url)\n            version, release = releases.items()[-1]\n        except KeyError:\n            raise\n\n    # Check existing version (if any).\n    plugin_path = plugins_directory.joinpath(name)\n\n    if not plugin_path.isdir():\n        existing_version = None\n    else:\n        plugin_metadata = yaml.load(plugin_path.joinpath('properties.yml')\n                                    .bytes())\n        existing_version = plugin_metadata['version']\n\n    if version == existing_version:\n        # Package already installed.\n        raise ValueError('`{}=={}` is already installed.'.format(name,\n                                                                 version))\n\n    if existing_version is not None:\n        # Uninstall existing package.\n        uninstall(name, plugins_directory)\n\n    # Install latest release\n    # ======================\n    print 'Installing `{}=={}`.'.format(name, version)\n\n    if not plugin_is_file:\n        # Download plugin release archive.\n        download = requests.get(release['url'], stream=True)\n\n        plugin_archive_bytes = StringIO.StringIO()\n        total_bytes = int(download.headers['Content-length'])\n        bytes_read = 0\n\n        with progressbar.ProgressBar(max_value=total_bytes) as bar:\n            while bytes_read < total_bytes:\n                chunk_i = download.raw.read(1 << 8)\n                bytes_read += len(chunk_i)\n                plugin_archive_bytes.write(chunk_i)\n                bar.update(bytes_read)\n\n        # Extract downloaded plugin to install path.\n        plugin_archive_bytes.seek(0)\n    else:\n        plugin_archive_bytes = open(plugin_package, 'rb')\n\n    plugin_path, plugin_metadata = install_fileobj(plugin_archive_bytes,\n                                                   plugin_path)\n    # Ensure installed package and version does not match requested version.\n    assert(all([plugin_metadata['package_name'] == name,\n                plugin_metadata['version'] == version]))\n    print '  \\--> done'\n    plugin_archive_bytes.close()\n    return plugin_path, plugin_metadata"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef extract_metadata(fileobj):\n    '''\n    Extract metadata from plugin archive file-like object (e.g., opened file,\n    ``StringIO``).\n\n    Parameters\n    ----------\n    fileobj : file-like\n        MicroDrop plugin archive file object.\n\n    Returns\n    -------\n    dict\n        Metadata dictionary for plugin.\n    '''\n    tar = tarfile.open(mode=\"r:gz\", fileobj=fileobj)\n\n    plugin_path = path(tmp.mkdtemp(prefix='mpm-'))\n    try:\n        tar.extractall(plugin_path)\n\n        return yaml.load(plugin_path.joinpath('properties.yml').bytes())\n    finally:\n        fileobj.seek(0)\n        plugin_path.rmtree()", "response": "Extract metadata from plugin archive file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextracting and install a MicroDrop plugin from file - like object.", "response": "def install_fileobj(fileobj, plugin_path):\n    '''\n    Extract and install plugin from file-like object (e.g., opened file,\n    ``StringIO``).\n\n    Parameters\n    ----------\n    fileobj : file-like\n        MicroDrop plugin file object to extract and install.\n    plugin_path : path\n        Target plugin install directory path.\n\n    Returns\n    -------\n    (path, dict)\n        Directory of installed plugin and metadata dictionary for plugin.\n    '''\n    plugin_path = path(plugin_path)\n    tar = tarfile.open(mode=\"r:gz\", fileobj=fileobj)\n\n    try:\n        tar.extractall(plugin_path)\n\n        plugin_metadata = yaml.load(plugin_path.joinpath('properties.yml').bytes())\n        fileobj.seek(0)\n    except:\n        # Error occured, so delete extracted plugin.\n        plugin_path.rmtree()\n        raise\n\n    # TODO Handle `requirements.txt`.\n    return plugin_path, plugin_metadata"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfreezes the user - installed plugins directory.", "response": "def freeze(plugins_directory):\n    '''\n    Parameters\n    ----------\n    plugins_directory : str\n        Path to MicroDrop user plugins directory.\n\n    Returns\n    -------\n    list\n        List of package strings corresponding to installed plugin versions.\n    '''\n    # Check existing version (if any).\n    package_versions = []\n    for plugin_path_i in plugins_directory.dirs():\n        try:\n            plugin_metadata = yaml.load(plugin_path_i\n                                        .joinpath('properties.yml').bytes())\n            if plugin_path_i.name != plugin_metadata['package_name']:\n                continue\n            package_versions.append((plugin_metadata['package_name'],\n                                     plugin_metadata['version']))\n        except:\n            continue\n    return ['%s==%s' % v for v in package_versions]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef search(plugin_package, server_url=DEFAULT_SERVER_URL):\n    '''\n    Parameters\n    ----------\n    plugin_package : str\n        Name of plugin package hosted on MicroDrop plugin index. Version\n        constraints are also supported (e.g., ``\"foo\", \"foo==1.0\",\n        \"foo>=1.0\"``, etc.)  See `version specifiers`_ reference for more\n        details.\n    server_url : str\n        URL of JSON request for MicroDrop plugins package index.  See\n        ``DEFAULT_SERVER_URL`` for default.\n\n    Returns\n    -------\n    (str, OrderedDict)\n        Name of found plugin and mapping of version strings to plugin package\n        metadata dictionaries.\n\n\n    .. _version specifiers:\n        https://www.python.org/dev/peps/pep-0440/#version-specifiers\n\n    .. versionchanged:: 0.25.2\n        Import `pip_helpers` locally to avoid error `sci-bots/mpm#5`_.\n\n        .. _sci-bots/mpm#5: https://github.com/sci-bots/mpm/issues/5\n    '''\n    import pip_helpers\n\n    # Look up latest release matching specifiers.\n    return pip_helpers.get_releases(plugin_package, server_url=server_url)", "response": "Search for a given plugin package and return a dict of version strings to plugin package metadata dictionaries."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tweetqueue(ctx, dry_run, config):\n    ctx.obj = {}\n    ctx.obj['DRYRUN'] = dry_run\n\n    # If the subcommand is \"config\", bypass all setup code\n    if ctx.invoked_subcommand == 'config':\n        return\n\n    # If the config file wasn't provided, attempt to load the default one.\n    if config is None:\n        user_home = os.path.expanduser(\"~\")\n        default_config = os.path.join(user_home, \".tweetqueue\")\n\n        if not os.path.isfile(default_config):\n            click.echo(\"Default configuration was not found and none was provided.\")\n            click.echo(\"Run 'tweetqueue config' to create one.\")\n            ctx.exit(1)\n\n        config = open(default_config, 'rb')\n\n    try:\n        ctx.obj['config'] = json.load(config)\n    except Exception as e:\n        click.echo(\"Unable to read configuration file.\")\n        click.echo(\"Are you sure it is valid JSON\")\n        click.echo(\"JSON Error: \" + e.message)\n        ctx.exit(1)\n\n    # Verify that the config file has all required options\n    required_config = [\n        'API_KEY',\n        'API_SECRET',\n        'ACCESS_TOKEN',\n        'ACCESS_TOKEN_SECRET',\n        'DATABASE_LOCATION'\n\n    ]\n    if not all(key in ctx.obj['config'] for key in required_config):\n        click.echo(\"Missing required value in config file.\")\n        ctx.exit(1)\n\n    # Make a tweepy api object for the context\n    auth = tweepy.OAuthHandler(\n        ctx.obj['config']['API_KEY'],\n        ctx.obj['config']['API_SECRET']\n    )\n    auth.set_access_token(\n        ctx.obj['config']['ACCESS_TOKEN'],\n        ctx.obj['config']['ACCESS_TOKEN_SECRET']\n    )\n    ctx.obj['TWEEPY_API'] = tweepy.API(auth)\n\n\n    ctx.obj['TWEETLIST'] = TweetList(ctx.obj['config']['DATABASE_LOCATION'])", "response": "A command line tool for time - delaying your tweets."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tweet(ctx, message):\n    if not valid_tweet(message):\n        click.echo(\"Message is too long for twitter.\")\n        click.echo(\"Message:\" + message)\n        ctx.exit(2)\n\n    if not ctx.obj['DRYRUN']:\n        ctx.obj['TWEEPY_API'].update_status(message)\n    else:\n        click.echo(\"Tweet not sent due to dry-run mode.\")", "response": "Sends a tweet directly to your timeline"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef queue(ctx, message):\n    if not valid_tweet(message):\n        click.echo(\"Message is too long for twitter.\")\n        click.echo(\"Message: \" + message)\n        ctx.exit(2)\n\n    if ctx.obj['DRYRUN']:\n        click.echo(\"Message not queue due to dry-run mode.\")\n        ctx.exit(0)\n\n    ctx.obj['TWEETLIST'].append(message)", "response": "Add a message to your twitter queue"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dequeue(ctx):\n    tweet =ctx.obj['TWEETLIST'].peek()\n\n    if tweet is None:\n        click.echo(\"Nothing to dequeue.\")\n        ctx.exit(1)\n\n    if ctx.obj['DRYRUN']:\n        click.echo(tweet)\n    else:\n        tweet = ctx.obj['TWEETLIST'].pop()\n        ctx.obj['TWEEPY_API'].update_status(tweet)", "response": "Sends a tweet from the queue"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef config(ctx):\n    home_directory = os.path.expanduser('~')\n    default_config_file = os.path.join(home_directory, '.tweetqueue')\n    default_database_file = os.path.join(home_directory, '.tweetqueue.db')\n\n    config = {}\n\n    config['API_KEY'] = click.prompt('API Key')\n    config['API_SECRET'] = click.prompt('API Secret')\n    config['ACCESS_TOKEN'] = click.prompt('Access Token')\n    config['ACCESS_TOKEN_SECRET'] = click.prompt('Access Token Secret')\n    config['DATABASE_LOCATION'] = click.prompt('Database', default=default_database_file)\n\n    config_file = click.prompt('\\nSave to', default=default_config_file)\n\n    if click.confirm('Do you want to save this configuration?', abort=True):\n        f = open(config_file, 'wb')\n        json.dump(config, f, indent=4, separators=(',',': '))\n        f.close()", "response": "Create a tweetqueue configuration file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting a tweet from the queue with a given ID", "response": "def delete(ctx,tweet):\n    \"\"\"Deletes a tweet from the queue with a given ID\"\"\"\n    if not ctx.obj['DRYRUN']:\n        try:\n            ctx.obj['TWEETLIST'].delete(tweet)\n        except ValueError as e:\n            click.echo(\"Now tweet was found with that id.\")\n            ctx.exit(1)\n    else:\n        click.echo(\"Not ran due to dry-run.\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_request(self, model, action, url_params={}, post_data=None):\n        '''\n        Send request to API then validate, parse, and return the response\n        '''\n        url = self._create_url(model, **url_params)\n        headers = self._headers(action)\n\n        try:\n            response = requests.request(action, url, headers=headers, data=post_data)\n        except Exception as e:\n            raise APIError(\"There was an error communicating with Union: %s\" % e)\n\n        if not self._is_valid(response):\n            raise ValidationError(\"The Union response returned an error: %s\" % response.content)\n\n        return self._parse_response(response)", "response": "Send request to API then validate and parse and return the response\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of primary contributors with primary being defined as those contributors with highest role assigned. Only permitted contributors are returned.", "response": "def get_primary_contributors(self):\n        \"\"\"\n        Returns a list of primary contributors, with primary being defined\n        as those contributors that have the highest role assigned (in terms\n        of priority). Only permitted contributors are returned.\n        \"\"\"\n        primary_credits = []\n        credits = self.credits.exclude(credit_option=None).order_by(\n            'credit_option__role_priority'\n        )\n        if credits:\n            primary_role_priority = credits[0].credit_option.role_priority\n            for credit in credits:\n                if credit.credit_option.role_priority == primary_role_priority:\n                    primary_credits.append(credit)\n\n        contributors = []\n        for credit in primary_credits:\n            contributor = credit.contributor\n            if contributor.is_permitted:\n                contributors.append(contributor)\n\n        return contributors"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwait until method returns a value that bool ( value ) == True*. Returns last value.", "response": "def wait(method, timeout, fail_on_timeout=None, **kwargs):\n    \"\"\"\n    Wait ``timeout`` seconds until ``method(**kwargs)`` returns a ``value`` that *bool(value)==True*.\n    Returns last ``value``.\n     If time expired and ``fail_on_timeout`` specified, then raise TimeoutException.\n\n    :param method:\n    :param timeout:\n    :param fail_on_timeout:\n    :param kwargs:\n    :return:\n    \"\"\"\n    return Waiter(lambda value: bool(value)).start(method, timeout, fail_on_timeout, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwaits until method returns a value that value == True.", "response": "def wait_not(method, timeout, fail_on_timeout=None, **kwargs):\n    \"\"\"\n    Wait ``timeout`` seconds until ``method(**kwargs)`` returns a ``value`` that *not value==True*.\n    Returns last ``value``.\n     If time expired and ``fail_on_timeout`` specified, then raise TimeoutException.\n\n    :param method:\n    :param timeout:\n    :param fail_on_timeout:\n    :param kwargs:\n    :return:\n    \"\"\"\n    return Waiter(lambda value: not value).start(method, timeout, fail_on_timeout, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wait_displayed(element, timeout=None, fail_on_timeout=None):\n    return wait(lambda: element.is_displayed(), timeout or element.wait_timeout, fail_on_timeout)", "response": "Wait until the element is visible or time out."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wait_not_displayed(element, timeout=None, fail_on_timeout=None):\n    return wait(lambda: not element.is_displayed(), timeout or element.wait_timeout, fail_on_timeout)", "response": "Wait until the element is not displayed."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a filter for status == waiting and time older than lte_time", "response": "def waiting_filter(lte_time, conn=None):\n    \"\"\"\n    generates a filter for status==waiting and\n    time older than lte_time\n    \"\"\"\n    if RBO.index_list().contains(IDX_OUTPUT_JOB_ID).run(conn):\n        return (r.row[START_FIELD] <= lte_time)\n    else:\n        return ((r.row[STATUS_FIELD] == WAITING) &\n            (r.row[START_FIELD] <= lte_time))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a filter for status == waiting and time older than lte_time", "response": "def expire_filter(lte_time, conn=None):\n    \"\"\"\n    generates a filter for status==waiting and\n    time older than lte_time\n    \"\"\"\n    if RBO.index_list().contains(IDX_OUTPUT_JOB_ID).run(conn):\n        return (r.row[EXPIRE_FIELD] <= lte_time)\n    else:\n        return (\n            (\n                (r.row[STATUS_FIELD] == WAITING) |\n                (r.row[STATUS_FIELD] == READY)\n            ) &\n            (r.row[EXPIRE_FIELD] <= lte_time)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef insert_jobs(jobs, verify_jobs=True, conn=None):\n    assert isinstance(jobs, list)\n    if verify_jobs \\\n            and not verify({Jobs.DESCRIPTOR.name: jobs}, Jobs()):\n        raise ValueError(\"Invalid Jobs\")\n    inserted = RBJ.insert(jobs).run(conn)\n    return inserted", "response": "insert_jobs function inserts data into Brain. Jobs table\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_job_status(job_id, status, conn=None):\n    if status not in VALID_STATES:\n        raise ValueError(\"Invalid status\")\n    job_update = RBJ.get(job_id).update({STATUS_FIELD: status}).run(conn)\n    if job_update[\"replaced\"] == 0 and job_update[\"unchanged\"] == 0:\n        raise ValueError(\"Unknown job_id: {}\".format(job_id))\n    output_job_status = {OUTPUTJOB_FIELD: {STATUS_FIELD: status}}\n    if RBO.index_list().contains(IDX_OUTPUT_JOB_ID).run(conn):\n        # NEW\n        output_update = RBO.get_all(job_id, index=IDX_OUTPUT_JOB_ID).update(output_job_status).run(conn)\n    else:\n        # OLD\n        id_filter = (r.row[OUTPUTJOB_FIELD][ID_FIELD] == job_id)\n        output_update = RBO.filter(id_filter).update(output_job_status).run(conn)\n    return {str(RBJ): job_update, str(RBO): output_update}", "response": "Updates a job to a new status"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write_output(job_id, content, conn=None):\n    output_job = get_job_by_id(job_id, conn)\n    results = {}\n    if output_job is not None:\n        entry = {\n            OUTPUTJOB_FIELD: output_job,\n            CONTENT_FIELD: content\n        }\n        results = RBO.insert(entry, conflict=RDB_REPLACE).run(conn)\n    return results", "response": "writes output to the output table\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_plugin(plugin_name, conn=None):\n    results = {}\n    if not plugin_exists(plugin_name, conn=conn):\n        results = RPX.table_create(plugin_name,\n                                   primary_key=COMMAND_NAME_KEY).run(conn)\n    return results", "response": "Creates a new plugin with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef destroy_plugin(plugin_name, conn=None):\n    results = {}\n    if plugin_exists(plugin_name, conn=conn):\n        results = RPX.table_drop(plugin_name).run(conn)\n    return results", "response": "Destroy a plugin from rethinkdb"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_words(numberofwords, wordlist, secure=None):\n    if not secure:\n        chooser = random.choice\n    else:\n        chooser = random.SystemRandom().choice\n    return [chooser(wordlist) for _ in range(numberofwords)]", "response": "Generate a list of random words from wordlist."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload a file stream from the package resources.", "response": "def load_stream(filename):\n    \"\"\"Load a file stream from the package resources.\"\"\"\n    rawfile = pkg_resources.resource_stream(__name__, filename)\n    if six.PY2:\n        return rawfile\n    return io.TextIOWrapper(rawfile, 'utf-8')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning the command line interface.", "response": "def cli():\n    \"\"\"Run the command line interface.\"\"\"\n    args = docopt.docopt(__doc__, version=__VERSION__)\n    secure = args['--secure']\n    numberofwords = int(args['<numberofwords>'])\n\n    dictpath = args['--dict']\n    if dictpath is not None:\n        dictfile = open(dictpath)\n    else:\n        dictfile = load_stream('words.txt')\n    with dictfile:\n        wordlist = read_wordlist(dictfile)\n\n    words = generate_words(numberofwords, wordlist, secure=secure)\n    print(' '.join(words))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load(self):\n        self.items = {}\n        pg = self.usr.getPage(\"http://www.neopets.com/objects.phtml?type=inventory\")\n        \n        # Indicates an empty inventory\n        if \"You aren't carrying anything\" in pg.content:\n            return\n        \n        try:\n            for row in pg.find_all(\"td\", \"contentModuleContent\")[1].table.find_all(\"tr\"):\n                for item in row.find_all(\"td\"):\n                    name = item.text\n                    \n                    # Some item names contain extra information encapsulated in paranthesis\n                    if \"(\" in name:\n                        name = name.split(\"(\")[0]\n                    \n                    tmpItem = Item(name)\n                    tmpItem.id = item.a['onclick'].split(\"(\")[1].replace(\");\", \"\")\n                    tmpItem.img = item.img['src']\n                    tmpItem.desc = item.img['alt']\n                    tmpItem.usr = self.usr\n                    \n                    self.items[name] = tmpItem\n        except Exception:\n            logging.getLogger(\"neolib.inventory\").exception(\"Unable to parse user inventory.\", {'pg': pg})\n            raise parseException", "response": "Loads a user s inventory and adds it to the inventory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a line class spec into a dict of line no class name", "response": "def parselinenos(spec, nlines=None):\n    \"\"\"Parse a line class spec into a dict of line no: class name\n\n    \"\"\"\n\n    items = {}\n    parts = spec.split(',')\n\n    for part in parts:\n        line_class = LINECLASS_RE.match(part)\n        start = int(line_class.group('start'))\n\n        if line_class.group('range'):\n            if line_class.group('end'):\n                end = int(line_class.group('end'))\n            else:\n                end = nlines\n\n            for line_no in range(start, end + 1):\n                items[line_no] = line_class.group('class')\n\n        else:\n            items[start] = line_class.group('class')\n\n    return items"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef autodiscover():\n    global LOADED\n    if LOADED:\n        return\n    LOADED = True\n    for app in get_app_name_list():\n        try:\n            module = import_module(app)\n        except ImportError:\n            pass\n        else:\n            try:\n                import_module(\"%s.page_processors\" % app)\n            except:\n                if module_has_submodule(module, \"page_processors\"):\n                    raise", "response": "Auto - discover the base base."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbases on jmbo. models. can_vote.", "response": "def can_vote_on_poll(self, request):\n        \"\"\"Based on jmbo.models.can_vote.\"\"\"\n\n        # can't vote if liking is closed\n        if self.votes_closed:\n            return False, 'closed'\n\n        # can't vote if liking is disabled\n        if not self.votes_enabled:\n            return False, 'disabled'\n\n        # anonymous users can't vote if anonymous votes are disabled\n        if not request.user.is_authenticated() and not \\\n                self.anonymous_votes:\n            return False, 'auth_required'\n\n        # return false if existing votes are found\n        votes = Vote.objects.filter(\n            object_id__in=[o.id for o in self.polloption_set.all()],\n            token=request.secretballot_token\n        )\n        if votes.exists():\n            return False, 'voted'\n        else:\n            return True, 'can_vote'"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the total number of votes cast across all the poll s options.", "response": "def vote_count(self):\n        \"\"\"\n        Returns the total number of votes cast across all the\n        poll's options.\n        \"\"\"\n        return Vote.objects.filter(\n            content_type=ContentType.objects.get(app_label='poll', model='polloption'),\n            object_id__in=[o.id for o in self.polloption_set.all()]\n        ).aggregate(Sum('vote'))['vote__sum'] or 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef vote_count(self):\n        return Vote.objects.filter(\n            content_type=ContentType.objects.get_for_model(self),\n            object_id=self.id\n        ).aggregate(Sum('vote'))['vote__sum'] or 0", "response": "Returns the total number of votes cast for this\n            poll options."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef percentage(self):\n        total_vote_count = self.poll.vote_count\n        if total_vote_count:\n            return self.vote_count * 100.0 / total_vote_count\n        return 0", "response": "Returns the percentage of votes cast for this poll option in\n        relation to all of its poll s other options."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprevent methods from mutating the receiver", "response": "def does_not_mutate(func):\n    \"\"\"Prevents methods from mutating the receiver\"\"\"\n    def wrapper(self, *args, **kwargs):\n        new = self.copy()\n        return func(new, *args, **kwargs)\n    wrapper.__name__ = func.__name__\n    wrapper.__doc__ = func.__doc__\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding first record subject to restrictions in kwargs + Raise RecordNotFound if no such record exists.", "response": "def find_by(self, **kwargs):\n        \"\"\"\n        Find first record subject to restrictions in +kwargs+, raising\n        RecordNotFound if no such record exists.\n        \"\"\"\n        result = self.where(**kwargs).first()\n        if result:\n            return result\n        else:\n            raise RecordNotFound(kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef first(self, count=1):\n        if count == 0:\n            raise QueryInvalid(\"Count cannot be zero.\")\n        self.limit_count = count\n        records = self._do_query().fetchall()\n        if not records:\n            return None\n        if count == 1:\n            record = records[0]\n            args = dict(zip(self.attributes, record))\n            return self.model.from_dict(**args)\n        return self", "response": "Returns the first count records in the query."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef last(self, count=1):\n        if self._order_with:\n            order = self._order_with.values()[0]\n            order = \"desc\" if order == \"asc\" else \"asc\"\n            order_with = self._order_with\n            self._order_with = {}\n            result = self.order_by(**{order_with.keys()[0]: order}).first(count)\n            self._order_with = order_with\n            return result\n        else:\n            return self.order_by(id=\"desc\").first(count)", "response": "Returns the last count records in the query."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef order_by(self, **kwargs):\n        # Only get one thing from kwargs (we can only order by one thing...)\n        if self._order_with:\n            raise QueryInvalid(\"Cannot order by more than one column\")\n        self._order_with = dict([kwargs.popitem()])\n        return self", "response": "Orders the query by the key passed in kwargs."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nallow the query to be subject to the passed records.", "response": "def where(self, *custom_restrictions, **restrictions):\n        \"\"\"\n        Restricts the records to the query subject to the passed\n        +restrictions+. Analog to \"WHERE\" in SQL. Can pass multiple\n        restrictions, and can invoke this method multiple times per query.\n        \"\"\"\n        for attr, value in restrictions.items():\n            self.where_query[attr] = value\n        if custom_restrictions:\n            self.custom_where.append(tuple(custom_restrictions))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef joins(self, table):\n\n        def do_join(table, model):\n            while model is not associations.model_from_name(table):\n                # ex) Category -> Forum -> Thread -> Post\n                # Category: {\"posts\": \"forums\"}\n                # Forum: {\"posts\": \"threads\"}\n                # Thread: {\"posts\": None}\n                # >>> Category.joins(\"posts\")\n                # => [\n                #       {'table': 'forums', 'on': ['category_id', 'id']}\n                #       {'table': 'threads', 'on': ['forum_id', 'id']}\n                #       {'table': 'posts', 'on': ['thread_id', 'id']}\n                #    ]\n                if table in associations.associations_for(model):\n                    # This to next: one-many (they have the fk)\n                    # If associations.associations_for(model)[table] is None, then this is\n                    # terminal (i.e. table is the FINAL association in the\n                    # chain)\n                    next_level = associations.associations_for(model)[table] or table\n                    next_model = associations.model_from_name(next_level)\n                    foreign_key = associations.foreign_keys_for(model).get(\n                        next_level,\n                        inflector.foreignKey(model.__name__))\n                    yield {'table': next_level, 'on': [foreign_key, 'id']}\n                else:\n                    # One-One or Many-One\n                    # singular table had better be in associations.associations_for(model)\n                    singular = inflector.singularize(table)\n                    next_level = associations.associations_for(model)[singular] or singular\n                    next_model = associations.model_from_name(next_level)\n                    this_table_name = Repo.table_name(model)\n                    foreign_key = associations.foreign_keys_for(model).get(\n                        next_level,\n                        inflector.foreignKey(model.__name__))\n                    if associations.model_has_foreign_key_for_table(table,\n                                                                    model):\n                        # we have the foreign key\n                        order = ['id', foreign_key]\n                    else:\n                        # They have the foreign key\n                        order = [foreign_key, 'id']\n                    yield {'table': inflector.pluralize(next_level), 'on': order}\n                model = next_model\n\n        self.join_args = list(do_join(table, self.model))\n        return self", "response": "A generator that joins the passed table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create(self, **attributes):\n        record = self.build(**attributes)\n        record.save()\n        return record", "response": "Creates a new record suject to the restructions in the query and with\n        the passed +attributes +. Operates using build."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef build(self, **kwargs):\n        build_args = dict(self.where_query)\n        build_args.update(kwargs)\n        record = self.model(**record_args(build_args))\n        if self.join_args:\n            # EXAMPLE:\n            # Say we have a many-to-many relation like so:\n            #   Post -> Tagging -> Tag\n            # If we are adding a tag to a post, we need to create the tagging\n            # in addition to the tag. To do this, we add a \"related record\" to\n            # the tag which is the tagging. By building the previous record,\n            # if it exists, we can recursively build a long object tree.\n            # That is, when we do post.tags(), we get a query that looks like:\n            # Query(Tag).joins(\"taggings\").where(taggings={\"post_id\":post.id})\n            # The call to \"build\" then creates a tag using kwargs and the where\n            # constraint, and creates a tagging that looks like:\n            # Tagging(post_id = post.id) and adds it to the tag's related\n            # records. The tagging's tag_id is added once the tag is saved\n            # which is the first time it gets an id\n            # Join args will never have just one element\n            next_to_build = getattr(self.record, self.join_args[-2]['table']).build()\n            record._related_records.append(next_to_build)\n        return record", "response": "Builds a new record with the given kwargs and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding the passed + record + to satisfy the query.", "response": "def append(self, record):\n        \"\"\"\n        Adds the passed +record+ to satisfy the query. Only intended to be\n        used in conjunction with associations (i.e. do not use if self.record\n        is None).\n\n        Intended use case (DO THIS):\n\n        post.comments.append(comment)\n\n        NOT THIS:\n\n        Query(Post).where(content=\"foo\").append(post)\n        \"\"\"\n        if self.record:\n            self._validate_record(record)\n            if self.join_args:\n                # As always, the related record is created when the primary\n                # record is saved\n                build_args = dict(self.where_query)\n                # The +final_join+ is what connects the record chain to the\n                # passed +record+\n                final_join = self.join_args[-2]\n                # don't need to worry about one-to-many through because\n                # there is not enough information to find or create the\n                # joining record\n                # i.e. in the Forum -> Thread -> Post example\n                # forum.posts.append(post) doesn't make sense since there\n                # is no information about what thread it will be attached to\n                # Thus, this only makes sense on many-to-many. BUT we still\n                # have to consider the case where there is a one-many-many\n                # To make that work, we need to treat this like when doing\n                # building\n                joining_relation = getattr(self.record, final_join['table'])\n                # Uses the lookup info in the join to figure out what ids to\n                # set, and where to get the id value from\n                joining_args = {final_join['on'][0]:\n                                getattr(record, final_join['on'][1])}\n                build_args.update(joining_args)\n                joining_record = joining_relation.build(**build_args)\n                self.record._related_records.append(joining_record)\n            else:\n                # Add our id to their foreign key so that the relationship is\n                # created\n                setattr(record,\n                        foreign_key(record, self.record),\n                        self.record.id)\n                # Add to the list of related records so that it is saved when\n                # we are\n                self.record._related_records.append(record)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete(self, record):\n        # note: does (and should) not delete or destroy the record\n        if self.record:\n            self._validate_record(record)\n            if self.join_args:\n                # Need to find out who has the foreign key\n                # If record has it, set to None, then done.\n                # If one level up has it, mark the record for destruction\n                final_table = self.join_args[0]['table']\n                if final_table in associations.associations_for(self.model):\n                    # +record+ does not have the foreign key\n                    # Find the record one level up, then mark for destruction\n                    related_class = associations.model_from_name(\n                        final_table)\n                    related_record = related_class.find_by(\n                        **self._related_args(record, related_class))\n                    # mark the joining record to be destroyed the primary is saved\n                    self.record._delete_related_records.append(related_record)\n                else:\n                    # We have the foreign key\n                    # Look up in the foreign key table, bearing in mind that\n                    # this is a belongs_to, so the entry will be singular,\n                    # whereas the table name is plural (we need to remove the\n                    # 's' at the end)\n                    key = associations.foreign_keys_for(self.model\n                            )[inflector.singularize(final_table)]\n                    # Set the foreign key to None to deassociate\n                    setattr(record, key, None)\n            else:\n                setattr(record, foreign_key(record, self.record), None)\n                # Ensure that the change is persisted on save\n                self.record._related_records.append(record)", "response": "Removes a record from an association table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a Dictionary at spellchecker_cache_path with technical words.", "response": "def create(technical_terms_filename, spellchecker_cache_path):\n    \"\"\"Create a Dictionary at spellchecker_cache_path with technical words.\"\"\"\n    user_dictionary = os.path.join(os.getcwd(), \"DICTIONARY\")\n    user_words = read_dictionary_file(user_dictionary)\n\n    technical_terms_set = set(user_words)\n\n    if technical_terms_filename:\n        with open(technical_terms_filename) as tech_tf:\n            technical_terms_set |= set(tech_tf.read().splitlines())\n\n    return Dictionary(technical_terms_set,\n                      \"technical_words\",\n                      dictionary_sources=[technical_terms_filename,\n                                          user_dictionary],\n                      cache=spellchecker_cache_path)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread raw text from the connection stream.", "response": "def reader(self):\n        \"\"\"\n        Reads raw text from the connection stream.\n        Ensures proper exception handling.\n\n        :return bytes: request\n        \"\"\"\n        request_stream = ''\n        with self.connect() as request:\n            if request.msg != 'OK':\n                raise HTTPError\n            request_stream = request.read().decode('utf-8')\n        return request_stream"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nserializing json text stream into python dictionary.", "response": "def json(self):\n        \"\"\"\n        Serializes json text stream into python dictionary.\n\n        :return dict: json\n        \"\"\"\n        _json = json.loads(self.reader)\n        if _json.get('error', None):\n            raise HTTPError(_json['error']['errors'])\n        return _json"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the command line and generate a dictionary of job order parameters", "response": "def parse_command_lines(self, acd_def):\n        \"\"\"\n        parse the command line to generate an abstract job order dictionary,\n        based on the parameters defined in the ACD\n        structure of job order is that for each defined parameter, there is\n        a dictionary entry containing its value and the value of its various\n        qualifiers\n        \"\"\"\n        command_line_string = ' '.join([cl.command_line for cl in\n                                        self.command_lines])\n        command_line_string = command_line_string.replace('=',' ')\n        command_line_array = [param_value for\n                              param_value in command_line_string.split(' ')\n                              if param_value != '']\n        job_order = {}\n        for parameter in acd_def.desc_parameters():\n            job_order[parameter.name]={'value':None}\n        \"\"\"dictionary describing the parameter values passed to the job\"\"\"\n        cl_chunks = iter(command_line_array)\n        parameters_count = 0\n        for chunk in cl_chunks:\n            if chunk.replace('-','') in ['auto', 'stdout', 'debug', 'filter',\n                                         'help', 'options']:\n                # ignore all global qualifiers?\n                #ignore auto qualifier, which should be automatically set by\n                #wrappers\n                continue\n            if chunk.startswith('-'):\n                # parameter values that start with the -name\n                name = chunk[1:]\n                parameter = acd_def.parameter_by_name(name)\n                if parameter is not None:\n                    if isinstance(parameter, BooleanParameter) or isinstance(\n                            parameter, ToggleParameter):\n                        parameter_value = True\n                    else:\n                        parameter_value = six.next(cl_chunks)\n                    if parameter.qualifiers.get('parameter', {'default_value': False}).get('default_value') == True:\n                        parameters_count += 1\n                    job_order[parameter.name]['value'] = parameter_value\n                else:\n                    if name.startswith('no') and acd_def.parameter_by_name(\n                            name[2:]) is not None:\n                        parameter = acd_def.parameter_by_name(\n                            name[2:])\n                        job_order[parameter.name]['value'] = False\n                    else:\n                        index = None\n                        if name[-1].isdigit():\n                            #if digits are used for explicit ordering of\n                            # qualifiers\n                            index = int(name[-1])-1\n                            name = name[:-1]\n                        parameters = acd_def.parameter_by_qualifier_name(\n                            name)\n                        if len(parameters)==1:\n                            parameter = parameters[0][0]\n                            qualifier_name = parameters[0][1]\n                            if parameters[0][2]['value_type']=='bool':\n                                parameter_value = True\n                            else:\n                                parameter_value = six.next(cl_chunks)\n                            job_order[parameter.name][qualifier_name] = parameter_value\n                        elif len(parameters)>1:\n                            # ambiguous qualifier name\n                            if index is not None:\n                                parameter = parameters[index][0]\n                                qualifier_name = parameters[index][1]\n                                if parameters[index][2]['value_type']=='bool':\n                                    parameter_value = True\n                                else:\n                                    parameter_value = six.next(cl_chunks)\n                                job_order[parameter.name][qualifier_name] = parameter_value\n                            else:\n                                # in case multiple parameters match for the\n                                # qualifier, we set it for all the\n                                # parameters, assuming these are\n                                # 'toggle-controlled'\n                                for match in parameters:\n                                    parameter = match[0]\n                                    qualifier_name = match[1]\n                                    if match[2]['default_value']=='bool':\n                                        parameter_value = True\n                                    else:\n                                        parameter_value = six.next(cl_chunks)\n                                    job_order[parameter.name][\n                                        qualifier_name] = parameter_value\n                        else: #len(parameters)==0\n                            # testing for a no-prefixed qualifier\n                            parameters = acd_def.parameter_by_qualifier_name(\n                                name[2:])\n                            if len(parameters) == 1:\n                                parameter = parameters[0][0]\n                                qualifier_name = parameters[0][1]\n                                job_order[parameter.name][\n                                    qualifier_name] = False\n                            elif len(parameters) > 1:\n                                # ambiguous qualifier name\n                                if index is not None:\n                                    parameter = parameters[index][0]\n                                    qualifier_name = parameters[index][1]\n                                    job_order[parameter.name][\n                                        qualifier_name] = False\n                                else:\n                                    #in case multiple parameters match for the\n                                    # qualifier, we set it for all the\n                                    # parameters, assuming these are\n                                    # 'toggle-controlled'\n                                    for match in parameters:\n                                        parameter = match[0]\n                                        qualifier_name = match[1]\n                                        job_order[parameter.name][\n                                            qualifier_name] = False\n                            else:  # len(parameters)==0\n                                #if absolutely no matching parameter found,\n                                # it may be an abbreviation for a global\n                                # qualifier\n                                if [gq for gq in ['auto', 'stdout',\n                                                         'debug', 'filter',\n                                                         'help', 'options']\n                                    if gq.startswith(name)]:\n                                        continue\n                                #if not, raise an error\n                                raise UnknownOptionParseException(name)\n            else:\n                # parameter values by position on the command line\n                parameter = acd_def.parameter_by_index(parameters_count)\n                job_order[parameter.name]['value'] = chunk\n                if parameter.qualifiers.get('parameter', {'default_value': False}).get('default_value')==True:\n                    parameters_count += 1\n        input_lines_array = [line.input_line for line in self.input_lines]\n        for parameter in acd_def.desc_parameters():\n            if len(input_lines_array)==0:\n                break\n            if job_order[parameter.name]['value'] is None:\n                job_order[parameter.name]['value']=input_lines_array.pop(0)\n        for key in list(job_order.keys()):\n            if job_order[key]=={'value':None}:\n                del job_order[key]\n        return job_order"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads and return a class in the specified classpath.", "response": "def import_class(classpath, package=None):\n    \"\"\"\n    Load and return a class\n    \"\"\"\n    if '.' in classpath:\n        module, classname = classpath.rsplit('.', 1)\n        if package and not module.startswith('.'):\n            module = '.{0}'.format(module)\n        mod = import_module(module, package)\n    else:\n        classname = classpath\n        mod = import_module(package)\n\n    return getattr(mod, classname)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nregistering a module. You could indicate position inside inner list. :param module: must be a string or a module object to register. :type module: str :param idx: position where you want to insert new module. By default it is inserted at the end. :type idx: int", "response": "def register_module(self, module, idx=-1):\n        \"\"\"\n        Register a module. You could indicate position inside inner list.\n\n        :param module: must be a string or a module object to register.\n        :type module: str\n        :param idx: position where you want to insert new module. By default it is inserted at the end.\n        :type idx: int\n        \"\"\"\n\n        if module in self._modules:\n            raise AlreadyRegisteredError(\"Module '{0}' is already registered on loader.\".format(module))\n\n        if idx < 0:\n            self._modules.append(module)\n        else:\n            self._modules.insert(idx, module)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_class(self, classname):\n\n        module_list = self._get_module_list()\n\n        for module in module_list:\n            try:\n                return import_class(classname, module.__name__)\n            except (AttributeError, ImportError):\n                pass\n\n        raise ImportError(\"Class '{0}' could not be loaded.\".format(classname))", "response": "Loads a class from the module list."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef factory(self, classname, *args, **kwargs):\n\n        klass = self.load_class(classname)\n\n        return self.get_factory_by_class(klass)(*args, **kwargs)", "response": "Creates an instance of classname by loading it from the registry and calling it s get_factory_by_class method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a custom factory for the given class. By default it will return the class itself.", "response": "def get_factory_by_class(self, klass):\n        \"\"\"\n        Returns a custom factory for class. By default it will return the class itself.\n\n        :param klass: Class type\n        :type klass: type\n        :return: Class factory\n        :rtype: callable\n        \"\"\"\n        for check, factory in self._factories.items():\n            if klass is check:\n                return factory(self, klass)\n        for check, factory in self._factories.items():\n            if issubclass(klass, check):\n                return factory(self, klass)\n        return klass"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters a module with the specified namespace.", "response": "def register_module(self, module, namespace=None):\n        \"\"\"\n        Register a module.\n\n        :param module: must be a string or a module object to register.\n        :type module: str\n        :param namespace: Namespace tag. If it is None module will be used as namespace tag\n        :type namespace: str\n        \"\"\"\n        namespace = namespace if namespace is not None else module \\\n            if isinstance(module, str) else module.__name__\n        self.register_namespace(namespace, module)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nregister a namespace. :param namespace: Namespace tag. :type namespace: str :param module: must be a string or a module object to register. :type module: str", "response": "def register_namespace(self, namespace, module):\n        \"\"\"\n        Register a namespace.\n\n        :param namespace: Namespace tag.\n        :type namespace: str\n        :param module: must be a string or a module object to register.\n        :type module: str\n        \"\"\"\n        if namespace in self._namespaces:\n            raise AlreadyRegisteredError(\"Namespace '{0}' is already registered on loader.\".format(namespace))\n\n        self._namespaces[namespace] = module"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unregister_module(self, module):\n        if module not in self._namespaces.values():\n            raise NoRegisteredError(\"Module '{0}' is not registered on loader.\".format(module))\n\n        for ns, mod in list(self._namespaces.items()):\n            if mod == module:\n                self.unregister_namespace(ns)", "response": "Unregister a module.\n\n        :param module: must be a string or a module object to unregistered\n        :type module: str"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading a class from the loader.", "response": "def load_class(self, classname, namespace=None):\n        \"\"\"\n        Loads a class looking for it in each module registered. It's possible to load a class from\n        specific namespace using **namespace** parameter or using classname as \"namespace:classname\".\n\n        :param classname: Class name you want to load.\n        :type classname: str\n        :param namespace: Specific namespace where to look for class.\n        :type namespace: str\n        :return: Class object\n        :rtype: type\n        \"\"\"\n        if namespace is None and ':' in classname:\n            namespace, classname = classname.split(':', 1)\n            return self.load_class(classname, namespace)\n        if namespace:\n            if namespace not in self._namespaces:\n                raise NoRegisteredError(\"Namespace '{0}' is not registered on loader.\".format(namespace))\n            try:\n                module = importlib.import_module(self._namespaces[namespace]) \\\n                    if isinstance(self._namespaces[namespace], str) else self._namespaces[namespace]\n\n                return import_class(classname, module.__name__)\n            except (AttributeError, ImportError):\n                raise ImportError(\"Class '{0}' could not be loaded from namespace '{1}'.\".format(classname,\n                                                                                                 namespace))\n        return super(LoaderNamespace, self).load_class(classname)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef close(self):\n        self._execute_plugin_hooks_sync(hook='close')\n\n        if not self.session.closed:\n            ensure_future(self.session.close(), loop=self.loop)", "response": "Close the service client and its plugins."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, path, strict):\n        item, pathinfo = self._get(path, strict)\n\n        if item is None:\n            if strict:\n                return None, pathinfo\n\n            else:\n                return self._item, pathinfo\n\n        else:\n            return item, pathinfo", "response": "Gets the item for the given path."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the item for the given path and returns the item.", "response": "def set(self, path, item, replace):\n        \"\"\" Sets item for `path` and returns the item.\n        Replaces existing item with `item` when `replace` is true\n\n        :param path: Path for item\n        :param item: New item\n        :param replace: Updating mode\n        :type path: list\n        :type item: object\n        :type replace: bool\n        \"\"\"\n        if len(path) == 0:\n            if self._item is None or replace:\n                self._item = item\n\n            return self._item\n\n        else:\n            head, tail = path[0], path[1:]\n\n            if head.startswith(':'):\n                default = (head[1:], self.__class__())\n                _, rtree = self._subtrees.setdefault(self._WILDCARD, default)\n                return rtree.set(tail, item, replace)\n\n            else:\n                rtree = self._subtrees.setdefault(head, self.__class__())\n                return rtree.set(tail, item, replace)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build_ajax_rsvps(event, user_profile):\n    if user_profile in event.rsvps.all():\n        link_string = True\n    else:\n        link_string = False\n\n    if not event.rsvps.all().count():\n        list_string = 'No RSVPs.'\n    else:\n        list_string = 'RSVPs:'\n        for counter, profile in enumerate(event.rsvps.all()):\n            if counter > 0:\n                list_string += ','\n\n            list_string += \\\n                ' <a class=\"page_link\" title=\"View Profile\" href=\"{url}\">' \\\n                    '{name}</a>'.format(\n                        url=reverse(\n                            'member_profile',\n                            kwargs={'targetUsername': profile.user.username}\n                        ),\n                        name='You' if profile.user == user_profile.user \\\n                            else profile.user.get_full_name(),\n                    )\n    return (link_string, list_string)", "response": "Return link and list strings for a given event."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _call(self, method_proxy, *args):\n        request = self._gw.addRequest(method_proxy, *args)\n\n        if self._auto_execute:\n            response = self._gw.execute_single(request)\n\n            if response.status == remoting.STATUS_ERROR:\n                if hasattr(response.body, 'raiseException'):\n                    try:\n                        response.body.raiseException()\n                    except:\n                        raise\n                else:\n                    raise remoting.RemotingError\n\n            return response.body\n\n        return request", "response": "Executes a single request to the remote gateway."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef addHeader(self, name, value, must_understand=False):\n        self.headers[name] = value\n        self.headers.set_required(name, must_understand)", "response": "Sets a persistent header to send with each request."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a ServiceProxy object for the supplied name.", "response": "def getService(self, name, auto_execute=True):\n        \"\"\"\n        Returns a L{ServiceProxy} for the supplied name. Sets up an object that\n        can have method calls made to it that build the AMF requests.\n\n        @rtype: L{ServiceProxy}\n        \"\"\"\n        if not isinstance(name, basestring):\n            raise TypeError('string type required')\n\n        return ServiceProxy(self, name, auto_execute)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getRequest(self, id_):\n        for request in self.requests:\n            if request.id == id_:\n                return request\n\n        raise LookupError(\"Request %r not found\" % (id_,))", "response": "Gets a request based on the id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef addRequest(self, service, *args):\n        wrapper = RequestWrapper(self, '/%d' % self.request_number,\n            service, *args)\n\n        self.request_number += 1\n        self.requests.append(wrapper)\n\n        if self.logger:\n            self.logger.debug('Adding request %s%r', wrapper.service, args)\n\n        return wrapper", "response": "Adds a request to the list of requests to be sent to the remoting gateway."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves a request from the pending request list.", "response": "def removeRequest(self, service, *args):\n        \"\"\"\n        Removes a request from the pending request list.\n\n        \"\"\"\n        if isinstance(service, RequestWrapper):\n            if self.logger:\n                self.logger.debug('Removing request: %s',\n                    self.requests[self.requests.index(service)])\n            del self.requests[self.requests.index(service)]\n\n            return\n\n        for request in self.requests:\n            if request.service == service and request.args == args:\n                if self.logger:\n                    self.logger.debug('Removing request: %s',\n                        self.requests[self.requests.index(request)])\n                del self.requests[self.requests.index(request)]\n\n                return\n\n        raise LookupError(\"Request not found\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getAMFRequest(self, requests):\n        envelope = remoting.Envelope(self.amf_version)\n\n        if self.logger:\n            self.logger.debug('AMF version: %s' % self.amf_version)\n\n        for request in requests:\n            service = request.service\n            args = list(request.args)\n\n            envelope[request.id] = remoting.Request(str(service), args)\n\n        envelope.headers = self.headers\n\n        return envelope", "response": "Builds an AMF request from a list of requests."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef execute_single(self, request):\n        if self.logger:\n            self.logger.debug('Executing single request: %s', request)\n\n        self.removeRequest(request)\n\n        body = remoting.encode(self.getAMFRequest([request]), strict=self.strict)\n\n        http_request = urllib2.Request(self._root_url, body.getvalue(),\n            self._get_execute_headers())\n\n        if self.proxy_args:\n            http_request.set_proxy(*self.proxy_args)\n\n        envelope = self._getResponse(http_request)\n\n        return envelope[request.id]", "response": "Executes a single request and returns the response."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild sends and handles the responses to all requests listed in self. requests.", "response": "def execute(self):\n        \"\"\"\n        Builds, sends and handles the responses to all requests listed in\n        C{self.requests}.\n        \"\"\"\n        requests = self.requests[:]\n\n        for r in requests:\n            self.removeRequest(r)\n\n        body = remoting.encode(self.getAMFRequest(requests),\n            strict=self.strict)\n\n        http_request = urllib2.Request(self._root_url, body.getvalue(),\n            self._get_execute_headers())\n\n        if self.proxy_args:\n            http_request.set_proxy(*self.proxy_args)\n\n        envelope = self._getResponse(http_request)\n\n        return envelope"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget and handles the HTTP response from the remote gateway.", "response": "def _getResponse(self, http_request):\n        \"\"\"\n        Gets and handles the HTTP response from the remote gateway.\n        \"\"\"\n        if self.logger:\n            self.logger.debug('Sending POST request to %s', self._root_url)\n\n        try:\n            fbh = self.opener(http_request)\n        except urllib2.URLError, e:\n            if self.logger:\n                self.logger.exception('Failed request for %s',\n                    self._root_url)\n\n            raise remoting.RemotingError(str(e))\n\n        http_message = fbh.info()\n\n        content_encoding = http_message.getheader('Content-Encoding')\n        content_length = http_message.getheader('Content-Length') or -1\n        content_type = http_message.getheader('Content-Type')\n        server = http_message.getheader('Server')\n\n        if self.logger:\n            self.logger.debug('Content-Type: %r', content_type)\n            self.logger.debug('Content-Encoding: %r', content_encoding)\n            self.logger.debug('Content-Length: %r', content_length)\n            self.logger.debug('Server: %r', server)\n\n        if content_type != remoting.CONTENT_TYPE:\n            if self.logger:\n                self.logger.debug('Body = %s', fbh.read())\n\n            raise remoting.RemotingError('Incorrect MIME type received. '\n                '(got: %s)' % (content_type,))\n\n        bytes = fbh.read(int(content_length))\n\n        if self.logger:\n            self.logger.debug('Read %d bytes for the response', len(bytes))\n\n        if content_encoding and content_encoding.strip().lower() == 'gzip':\n            if not GzipFile:\n                raise remoting.RemotingError(\n                    'Decompression of Content-Encoding: %s not available.' % (\n                        content_encoding,))\n\n            compressedstream = StringIO(bytes)\n            gzipper = GzipFile(fileobj=compressedstream)\n            bytes = gzipper.read()\n            gzipper.close()\n\n        response = remoting.decode(bytes, strict=self.strict)\n\n        if self.logger:\n            self.logger.debug('Response: %s', response)\n\n        if remoting.APPEND_TO_GATEWAY_URL in response.headers:\n            self.original_url += response.headers[remoting.APPEND_TO_GATEWAY_URL]\n\n            self._setUrl(self.original_url)\n        elif remoting.REPLACE_GATEWAY_URL in response.headers:\n            self.original_url = response.headers[remoting.REPLACE_GATEWAY_URL]\n\n            self._setUrl(self.original_url)\n\n        if remoting.REQUEST_PERSISTENT_HEADER in response.headers:\n            data = response.headers[remoting.REQUEST_PERSISTENT_HEADER]\n\n            for k, v in data.iteritems():\n                self.headers[k] = v\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the authentication credentials for accessing the remote gateway.", "response": "def setCredentials(self, username, password):\n        \"\"\"\n        Sets authentication credentials for accessing the remote gateway.\n        \"\"\"\n        self.addHeader('Credentials', dict(userid=username.decode('utf-8'),\n            password=password.decode('utf-8')), True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef patch_gevent_hub():\n    from gevent.hub import Hub\n\n    def patched_handle_error(self, context, etype, value, tb):\n        \"\"\" Patched to not print KeyboardInterrupt exceptions. \"\"\"\n        if isinstance(value, str):\n            value = etype(value)\n        not_error = issubclass(etype, self.NOT_ERROR)\n        system_error = issubclass(etype, self.SYSTEM_ERROR)\n        if not not_error and not issubclass(etype, KeyboardInterrupt):\n            self.print_exception(context, etype, value, tb)\n        if context is None or system_error:\n            self.handle_system_error(etype, value)\n\n    Hub._original_handle_error = Hub.handle_error\n    Hub.handle_error = patched_handle_error", "response": "Patches the error handler in the gevent Hub object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntargeting should be a Table or SyntheticTable", "response": "def add(self, name, target):\n    \"target should be a Table or SyntheticTable\"\n    if not isinstance(target, (table.Table, SyntheticTable)):\n      raise TypeError(type(target), target)\n    if name in self:\n      # note: this is critical for avoiding cycles\n      raise ScopeCollisionError('scope already has', name)\n    self.names[name] = target"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrefs is a NameX or AttrX. return (canonical_table_name column_name.", "response": "def resolve_column(self, ref):\n    \"ref is a NameX or AttrX. return (canonical_table_name, column_name).\"\n    if isinstance(ref, sqparse2.AttrX):\n      if ref.parent.name not in self:\n        raise ScopeUnkError('unk table or table alias', ref.parent.name)\n      return ref.parent.name, ref.attr.name\n    elif isinstance(ref, sqparse2.NameX):\n      matches = set()\n      for name, target in self.names.items():\n        if isinstance(target, SyntheticTable):\n          if ref.name in target.columns(self):\n            matches.add(name)\n        elif isinstance(target, table.Table):\n          try: target.get_column(ref.name)\n          except KeyError: pass\n          else: matches.add(name)\n        else:\n          raise TypeError('expected SyntheticTable', type(target), target)\n      if not matches: raise ScopeUnkError(ref)\n      elif len(matches) > 1: raise ScopeCollisionError(matches, ref)\n      else: return list(matches)[0], ref.name\n    else:\n      raise TypeError('unexpected', type(ref), ref)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild a Scope given a TablesDict from - expression and optional list of CTEs.", "response": "def from_fromx(class_, tables, fromx, ctes=()):\n    \"\"\"Build a Scope given TablesDict, from-expression and optional list of CTEs.\n    fromx is a list of expressions (e.g. SelectX.tables). The list elts can be:\n      1. string (i.e. tablename)\n      2. AliasX(SelectX as name)\n      3. AliasX(name as name)\n    \"\"\"\n    if ctes: raise NotImplementedError # note: I don't think any other part of the program supports CTEs yet either\n    scope_ = class_(fromx)\n    for exp in fromx:\n      if isinstance(exp, basestring):\n        scope_.add(exp, tables[exp])\n      elif isinstance(exp, sqparse2.AliasX) and isinstance(exp.name, sqparse2.NameX):\n        scope_.add(exp.alias, tables[exp.name.name])\n      elif isinstance(exp, sqparse2.AliasX) and isinstance(exp.name, sqparse2.SelectX):\n        scope_.add(exp.alias, SyntheticTable(exp.name))\n      elif isinstance(exp, sqparse2.JoinX):\n        raise NotImplementedError('todo: join')\n      else:\n        raise TypeError('bad fromx type', type(exp), exp)\n    return scope_"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclone a non - existent package using the upstream registry.", "response": "def clone_from_upstream(pkg_name, repo_url):\n        \"\"\"Clone a non-existent package using the upstream registry.\"\"\"\n        msg = \"Spawning a cloning task for %s from upstream due to API req.\"\n        LOG.info(msg % pkg_name)\n\n        upstream_url = settings.UPSTREAM_BOWER_REGISTRY\n        upstream_pkg = bowerlib.get_package(upstream_url, pkg_name)\n\n        if upstream_pkg is None:\n            raise Http404\n\n        task = tasks.clone_repo.delay(pkg_name, upstream_pkg['url'])\n        try:\n            result = task.get(timeout=5)\n        except tasks.TimeoutError:\n            # Not done yet. What to return?\n            raise ServiceUnavailable\n\n        return result.to_package(repo_url)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef updateConfig(self):\n        config = self.getConfig()\n        if not config:\n            return\n        self.ssh.servicename = config.get(\"SSH\", \"servicename\")\n        self.ssh.ip = config.get(\"SSH\", \"ip\")\n        self.ssh.port = int(config.get(\"SSH\", \"port\"))\n        self.ssh.pidfile = config.get(\"SSH\", \"pidfile\")\n        self.ssh.username = str(config.get(\"SSH\", \"username\"))\n        self.ssh.keydir = config.get(\"SSH\", \"keydir\")\n        self.ssh.privkey = config.get(\"SSH\", \"privkey\")\n        self.ssh.pubkey = config.get(\"SSH\", \"pubkey\")\n        self.ssh.localdir = config.get(\"SSH\", \"localdir\")\n        self.ssh.userdirtemplate = config.get(\"SSH\", \"userdirtemplate\")\n        self.ssh.userauthkeys = config.get(\"SSH\", \"userauthkeys\")\n        self.ssh.usesystemkeys = eval(config.get(\"SSH\", \"usesystemkeys\"))\n        self.ssh.banner = str(config.get(\"SSH\", \"banner\"))\n        return config", "response": "This method updates the in - memory config values with the values from the config file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nallocate an unused port.", "response": "def allocate_port():\n    \"\"\"Allocate an unused port.\n\n    There is a small race condition here (between the time we allocate the\n    port, and the time it actually gets used), but for the purposes for which\n    this function gets used it isn't a problem in practice.\n    \"\"\"\n    sock = socket.socket()\n    try:\n        sock.bind((\"localhost\", 0))\n        return get_port(sock)\n    finally:\n        sock.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef spawn(self):\n        self._process = subprocess.Popen(\n            [self.path], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n        self.addCleanup(self._process_kill)", "response": "Spawn the fake executable using subprocess. Popen."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmake the fake executable listen to the specified port.", "response": "def listen(self, port=None):\n        \"\"\"Make the fake executable listen to the specified port.\n\n        Possible values for 'port' are:\n\n        - None: Allocate immediately a free port and instruct the fake\n          executable to use it when it's invoked. This is subject to\n          a race condition, if that port that was free when listen() was\n          invoked later becomes used before the fake executable had chance\n          to bind to it. However it has the advantage of exposing the\n          free port as FakeExecutable.port instance variable, that can easily\n          be consumed by tests.\n\n        - An integer: Listen to this specific port.\n        \"\"\"\n        if port is None:\n            port = allocate_port()\n        self.port = port\n        self.line(\"import socket\")\n        self.line(\"sock = socket.socket()\")\n        self.line(\"sock.bind(('localhost', {}))\".format(self.port))\n        self.log(\"listening: %d\" % self.port)\n        self.line(\"sock.listen(0)\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _process_kill(self):\n        if self._process.poll() is None:  # pragma: no cover\n            self._process.kill()\n            self._process.wait(timeout=5)", "response": "Kill the fake executable process if it s still running."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn details about the fake process.", "response": "def _process_info(self):\n        \"\"\"Return details about the fake process.\"\"\"\n        if not self._process:\n            return []\n\n        output, error = self._process.communicate(timeout=5)\n        if error is None:\n            error = b\"\"\n        output = output.decode(\"utf-8\").strip()\n        error = error.decode(\"utf-8\").strip()\n        info = (u\"returncode: %r\\n\"\n                u\"output:\\n%s\\n\"\n                u\"error:\\n%s\\n\" % (self._process.returncode, output, error))\n        return [info.encode(\"utf-8\")]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef addClusterId(self,line):\n        if isinstance(line,dict):\n            jsonObj = line\n        else:\n            jsonObj = json.loads(line)\n        concat_str=''\n        for item in jsonObj['cluster']:\n            concat_str += item['uri']\n        cluster_id = \"http://dig.isi.edu/ht/data/\" + str(hash(concat_str)% 982451653)\n        for item in jsonObj['cluster']:\n            item['cluster_id']=cluster_id\n            yield item", "response": "Reads all the ads in particular cluster and adds that as cluster_id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nimport specified python module and returns subclasses of BaseTask from it", "response": "def load_tasks_from_file(self, file_path):\n        \"\"\" Imports specified python module and returns subclasses of BaseTask from it\n\n        :param file_path: a fully qualified file path for a python module to import CustomTasks from\n        :type file_path: `str`\n        :return: a dict of CustomTasks, where key is CustomTask.name, and value is a CustomClass task itself\n        :rtype: `dict`\n        \"\"\"\n        file_name, module_path, objects = Loader.import_custom_python_file(file_path)\n        result = {}\n        for entry in objects:\n            try:\n                if issubclass(entry, BaseTask):\n                    if entry.__name__ != BaseTask.__name__ and entry.name == BaseTask.name:\n                        raise GOSTaskException(\"Class {class_name} form file {file_name} does not have a unique `name` class field. \"\n                                               \"All custom tasks must have a unique `name` class field for them, tat is used for future reference\"\n                                               \"\".format(class_name=entry.name, file_name=os.path.join(module_path, file_name)))\n                    result[entry.name] = entry\n            except TypeError:\n                continue\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_tasks_from_dir(self, dir_path, propagate_exceptions=False):\n        if not os.path.exists(dir_path):\n            raise GOSTaskException()\n        if os.path.isfile(dir_path):\n            raise GOSTaskException()\n        result = {}\n        for file_basename in os.listdir(dir_path):\n            full_file_path = os.path.join(dir_path, file_basename)\n            try:\n                result.update(self.load_tasks_from_file(full_file_path))\n            except (GOSTaskException, GOSIOException):\n                if propagate_exceptions:\n                    raise\n        return result", "response": "Loads all python modules in a directory and returns subclasses of BaseTask"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_tasks(self, paths, propagate_exception=False):\n        try:\n            result = {}\n            for path in paths:\n                try:\n                    if os.path.isdir(path):\n                        result.update(self.load_tasks_from_dir(dir_path=path, propagate_exceptions=propagate_exception))\n                    elif os.path.isfile(path):\n                        result.update(self.load_tasks_from_file(file_path=path))\n                except (GOSTaskException, GOSIOException):\n                    if propagate_exception:\n                        raise\n            return result\n        except TypeError:\n            raise GOSTaskException(\"Argument for `load_tasks` method must be iterable\")", "response": "Loads all subclasses of BaseTask from modules that are contained in the supplied directory paths or direct modules."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef activate(self, prefix=None, backend=None):\n        if isinstance(prefix, compat.string_types):\n            self.prefix = prefix\n\n        if isinstance(backend, RmoqStorageBackend):\n            self.backend = backend\n\n        def activate(func):\n            if isinstance(func, type):\n                return self._decorate_class(func)\n\n            def wrapper(*args, **kwargs):\n                with self:\n                    return func(*args, **kwargs)\n\n            return wrapper\n\n        return activate", "response": "A decorator used to activate the mocker."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _process_call(self, req, resource):\n        if resource == \"ports\":\n            if req.method.upper() in ('PUT', 'POST'):\n                # Pass the request back to be processed by other filters\n                #   and Neutron first\n                resp = req.get_response(self.app)\n                if resp.status_code not in (200, 204):\n                    return resp\n                resp_body = resp.json\n\n                # Variables for Nova Call, obtained from Neutron response\n                action = \"create\"\n                address = resp_body['port']['mac_address']\n                fixed_ips = resp_body['port']['fixed_ips']\n                instance_id = resp_body['port']['instance_id']\n                network_id = resp_body['port']['network_id']\n                port_id = resp_body['port']['id']\n                tenant_id = resp_body['port']['tenant_id']\n\n            elif req.method.upper() == \"DELETE\":\n                action = \"delete\"\n                port_id = req.path.split(\"/\")\n                port_id = port_id[port_id.index(\"ports\") + 1]\n\n                # DELETEs do not have all the port info that we need, so a\n                # call to Neutron must be made first.\n                neutron_conn = NeutronConn(log=self.log,\n                                           port=self.neutron_port,\n                                           url=self.neutron_url,\n                                           verify_ssl=self.neutron_verify_ssl)\n                status, neutron_resp = neutron_conn.ports(port_id=port_id)\n                if isinstance(neutron_resp, Exception):\n                    return neutron_resp\n                elif status not in (200, 204):\n                    resp = Response()\n                    resp.status = 500\n                    new_body = {\"neutron_callback\":\n                                {\"port_id\": port_id,\n                                 \"status\": \"error\",\n                                 \"error\": neutron_resp}}\n                    resp.body = json.dumps(new_body)\n                    return resp\n\n                # Now that we have the port info, we can make the variables\n                # for the Nova Call\n                address = neutron_resp['port']['mac_address']\n                fixed_ips = neutron_resp['port']['fixed_ips']\n                instance_id = neutron_resp['port']['instance_id']\n                network_id = neutron_resp['port']['network_id']\n                tenant_id = neutron_resp['port']['tenant_id']\n\n                # Port info saved, now send the request back to processed by\n                #   other filters and Neutron\n                resp = req.get_response(self.app)\n                if resp.status_code not in (200, 204):\n                    return resp\n                else:\n                    new_body = resp.json\n                    new_body['neutron_callback'] = {\"port_id\": port_id,\n                                                    \"status\": \"success\"}\n                    resp.body = json.dumps(new_body)\n\n            nova_conn = NovaConn(log=self.log, url=self.nova_url,\n                                 verify_ssl=self.nova_verify_ssl)\n            status, nova_resp = nova_conn.admin_virtual_interfaces(\n                action=action, address=address, fixed_ips=fixed_ips,\n                network_id=network_id, port_id=port_id, tenant_id=tenant_id,\n                instance_id=instance_id)\n            if isinstance(nova_resp, Exception):\n                return nova_resp\n            elif status not in (200, 204):\n                # We'll likely want to provide the customer with a call here\n                # such as virtual-interface-delete/virtual-interface-update\n                resp.status = 500\n                new_body = resp.json\n                new_body['nova_callback'] = {\"instance_id\": instance_id,\n                                             \"status\": \"error\",\n                                             \"error\": nova_resp}\n                resp.body = json.dumps(new_body)\n            else:\n                new_body = resp.json\n                new_body['nova_callback'] = {\"instance_id\": instance_id,\n                                             \"status\": \"success\"}\n                resp.body = json.dumps(new_body)\n            return resp\n        elif resource == \"ip_addresses\":\n            pass  # Insert logic to call Nova for ip_addresses changes here\n        return resp", "response": "This method is called by the client to process the call to Neutron."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nkeeping all the output generated within a with - block on one line.", "response": "def keep_on_one_line():\n    \"\"\"\n    Keep all the output generated within a with-block on one line.  Whenever a \n    new line would be printed, instead reset the cursor to the beginning of the \n    line and print the new line without a line break.\n    \"\"\"\n\n    class CondensedStream:\n\n        def __init__(self):\n            self.sys_stdout = sys.stdout\n\n        def write(self, string):\n            with swap_streams(self.sys_stdout):\n                string = string.replace('\\n', ' ')\n                string = truncate_to_fit_terminal(string)\n                if string.strip():\n                    update(string)\n\n        def flush(self):\n            with swap_streams(self.sys_stdout):\n                flush()\n\n\n    with swap_streams(CondensedStream()):\n        yield"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_color(string, name, style='normal', when='auto'):\n    write(color(string, name, style, when))", "response": "Writes a string to standard out."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_color(string, name, style='normal', when='auto'):\n    clear()\n    write_color(string, name, style, when)", "response": "Update the current line with the given colored string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef progress_color(current, total, name, style='normal', when='auto'):\n    update_color('[%d/%d] ' % (current, total), name, style, when)", "response": "Display a simple colored progress report."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nchange the color of the given string.", "response": "def color(string, name, style='normal', when='auto'):\n    \"\"\" Change the color of the given string. \"\"\"\n    if name not in colors:\n        from .text import oxford_comma\n        raise ValueError(\"unknown color '{}'.\\nknown colors are: {}\".format(\n            name, oxford_comma([\"'{}'\".format(x) for x in sorted(colors)])))\n\n    if style not in styles:\n        from .text import oxford_comma\n        raise ValueError(\"unknown style '{}'.\\nknown styles are: {}\".format(\n            style, oxford_comma([\"'{}'\".format(x) for x in sorted(styles)])))\n\n    prefix = '\\033[%d;%dm' % (styles[style], colors[name])\n    suffix = '\\033[%d;%dm' % (styles['normal'], colors['normal'])\n    color_string = prefix + string + suffix\n\n    if when == 'always':\n        return color_string\n    elif when == 'auto':\n        return color_string if sys.stdout.isatty() else string\n    elif when == 'never':\n        return string\n    else:\n        raise ValueError(\"when must be one of: 'always', 'auto', 'never'\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncompiling a binary into a chkrootkit binary", "response": "def compile_binary(source):\n    \"\"\"\n    Prepare chkrootkit binary\n    $ tar xzvf chkrootkit.tar.gz\n    $ cd chkrootkit-0.52\n    $ make sense\n    sudo mv chkrootkit-0.52 /usr/local/chkrootkit\n    sudo ln -s\n    \"\"\"\n    cmd = 'make sense'\n    slink = '/usr/local/bin/chkrootkit'\n    target = '/usr/local/chkrootkit/chkrootkit'\n    # Tar Extraction\n    t = tarfile.open(source, 'r')\n    t.extractall(TMPDIR)\n    if isinstance(t.getnames(), list):\n        extract_dir = t.getnames()[0].split('/')[0]\n        os.chdir(TMPDIR + '/' + extract_dir)\n        logger.info('make output: \\n%s' % subprocess.getoutput(cmd))\n        # move directory in place\n        os.rename(TMPDIR + '/' + extract_dir, 'usr/local/chkrootkit')\n        # create symlink to binary in directory\n        os.symlink(target, slink)\n        return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndownloads a list of files from the specified file path.", "response": "def download(objects):\n    \"\"\"\n    Retrieve remote file object\n    \"\"\"\n    def exists(object):\n        if os.path.exists(TMPDIR + '/' + filename):\n            return True\n        else:\n            msg = 'File object %s failed to download to %s. Exit' % (filename, TMPDIR)\n            logger.warning(msg)\n            stdout_message('%s: %s' % (inspect.stack()[0][3], msg))\n            return False\n    try:\n        for file_path in objects:\n            filename = file_path.split('/')[-1]\n            r = urllib.request.urlretrieve(file_path, TMPDIR + '/' + filename)\n            if not exists(filename):\n                return False\n    except urllib.error.HTTPError as e:\n        logger.exception(\n            '%s: Failed to retrive file object: %s. Exception: %s, data: %s' %\n            (inspect.stack()[0][3], file_path, str(e), e.read()))\n        raise e\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the dependency is complete", "response": "def precheck():\n    \"\"\"\n    Pre-run dependency check\n    \"\"\"\n    binaries = ['make']\n    for bin in binaries:\n        if not which(bin):\n            msg = 'Dependency fail -- Unable to locate rquired binary: '\n            stdout_message('%s: %s' % (msg, ACCENT + bin + RESET))\n            return False\n        elif not root():\n            return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_workshift_context(request):\n    if not request.user.is_authenticated():\n        return {}\n\n    if Semester.objects.count() < 1:\n        return {\n            \"WORKSHIFT_ENABLED\": False,\n        }\n\n    # Current semester is for navbar notifications\n    try:\n        current_semester = Semester.objects.get(current=True)\n    except Semester.DoesNotExist:\n        current_semester = None\n    except Semester.MultipleObjectsReturned:\n        current_semester = Semester.objects.filter(\n            current=True,\n        ).latest(\"start_date\")\n        workshift_emails = []\n        for pos in Manager.objects.filter(workshift_manager=True, active=True):\n            if pos.email:\n                workshift_emails.append(pos.email)\n            elif pos.incumbent.email_visible and pos.incumbent.user.email:\n                workshift_emails.append(pos.incumbent.user.email)\n        if workshift_emails:\n            workshift_email_str = \" ({})\".format(\n                \", \".join(\n                    \"<a href=\\\"mailto:{0}\\\">{0}</a>\".format(i)\n                    for i in workshift_emails\n                ),\n            )\n        else:\n            workshift_email_str = \"\"\n        messages.add_message(\n            request,\n            messages.WARNING,\n            MESSAGES[\"MULTIPLE_CURRENT_SEMESTERS\"].format(\n                admin_email=settings.ADMINS[0][1],\n                workshift_emails=workshift_email_str,\n            ),\n        )\n\n    today = localtime(now()).date()\n\n    days_passed = None\n    total_days = None\n    semester_percentage = None\n    standing = None\n    happening_now = None\n    workshift_profile = None\n\n    if current_semester:\n        # number of days passed in this semester\n        days_passed = (today - current_semester.start_date).days\n\n        # total number of days in this semester\n        total_days = (\n            current_semester.end_date - current_semester.start_date\n        ).days\n        semester_percentage = round((days_passed / total_days) * 100, 2)\n\n    # Semester is for populating the current page\n    try:\n        semester = request.semester\n    except AttributeError:\n        semester = current_semester\n\n    try:\n        workshift_profile = WorkshiftProfile.objects.get(\n            semester=semester,\n            user=request.user,\n            )\n    except WorkshiftProfile.DoesNotExist:\n        workshift_profile = None\n\n    workshift_manager = utils.can_manage(request.user, semester=semester)\n\n    upcoming_shifts = WorkshiftInstance.objects.filter(\n        workshifter=workshift_profile,\n        closed=False,\n        date__gte=today,\n        date__lte=today + timedelta(days=2),\n    )\n\n    # TODO: Add a fudge factor of an hour to this?\n    time = localtime(now()).time()\n    happening_now = []\n    for shift in upcoming_shifts:\n        if shift.week_long:\n            happening_now.append(shift)\n            continue\n        if shift.date != today:\n            continue\n        if shift.start_time is None:\n            if shift.end_time is not None:\n                if time < shift.end_time:\n                    happening_now.append(shift)\n            else:\n                happening_now.append(shift)\n            continue\n        if shift.end_time is None:\n            if shift.start_time is not None:\n                if time > shift.start_time:\n                    happening_now.append(shift)\n            else:\n                happening_now.append(shift)\n            continue\n        if time > shift.start_time and time < shift.end_time:\n            happening_now.append(shift)\n\n    if workshift_profile:\n        try:\n            standing = workshift_profile.pool_hours.get(\n                pool__is_primary=True,\n            ).standing\n        except (PoolHours.DoesNotExist, PoolHours.MultipleObjectsReturned):\n            pass\n\n    return {\n        \"WORKSHIFT_ENABLED\": True,\n        \"SEMESTER\": semester,\n        \"CURRENT_SEMESTER\": current_semester,\n        \"WORKSHIFT_MANAGER\": workshift_manager,\n        \"WORKSHIFT_PROFILE\": workshift_profile,\n        \"STANDING\": standing,\n        \"DAYS_PASSED\": days_passed,\n        \"TOTAL_DAYS\": total_days,\n        \"SEMESTER_PERCENTAGE\": semester_percentage,\n        \"UPCOMING_SHIFTS\": zip(upcoming_shifts, happening_now),\n    }", "response": "Add workshift variables to all dictionaries passed to templates."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitiating a semester\"s worth of workshift, with the option to copy workshift types from the previous semester.", "response": "def start_semester_view(request):\n    \"\"\"\n    Initiates a semester\"s worth of workshift, with the option to copy\n    workshift types from the previous semester.\n    \"\"\"\n    page_name = \"Start Semester\"\n    year, season = utils.get_year_season()\n    start_date, end_date = utils.get_semester_start_end(year, season)\n\n    semester_form = SemesterForm(\n        data=request.POST or None,\n        initial={\n            \"year\": year,\n            \"season\": season,\n            \"start_date\": start_date.strftime(date_formats[0]),\n            \"end_date\": end_date.strftime(date_formats[0]),\n        },\n        prefix=\"semester\",\n    )\n\n    pool_forms = []\n    try:\n        prev_semester = Semester.objects.latest(\"end_date\")\n    except Semester.DoesNotExist:\n        pass\n    else:\n        pools = WorkshiftPool.objects.filter(\n            semester=prev_semester,\n            is_primary=False,\n        )\n        for pool in pools:\n            form = StartPoolForm(\n                data=request.POST or None,\n                initial={\n                    \"title\": pool.title,\n                    \"hours\": pool.hours,\n                },\n                prefix=\"pool-{}\".format(pool.pk),\n            )\n            pool_forms.append(form)\n\n    if semester_form.is_valid() and all(i.is_valid() for i in pool_forms):\n        # And save this semester\n        semester = semester_form.save()\n        for pool_form in pool_forms:\n            pool_form.save(semester=semester)\n        return HttpResponseRedirect(wurl(\"workshift:manage\",\n                                         sem_url=semester.sem_url))\n\n    return render_to_response(\"start_semester.html\", {\n        \"page_name\": page_name,\n        \"semester_form\": semester_form,\n        \"pool_forms\": pool_forms,\n    }, context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndisplay a table of workshifts for the given semester.", "response": "def semester_view(request, semester, profile=None):\n    \"\"\"\n    Displays a table of the workshifts for the week, shift assignments,\n    accumulated statistics (Down hours), reminders for any upcoming shifts, and\n    links to sign off on shifts. Also links to the rest of the workshift pages.\n    \"\"\"\n    template_dict = {}\n    template_dict[\"page_name\"] = \"Workshift for {} {}\".format(\n        semester.get_season_display(),\n        semester.year,\n    )\n\n    today = localtime(now()).date()\n    template_dict[\"semester_percentage\"] = int(\n        (today - semester.start_date).days /\n        (semester.end_date - semester.start_date).days * 100\n    )\n\n    # We want a form for verification, a notification of upcoming shifts, and a\n    # chart displaying the entire house's workshift for the day as well as\n    # weekly shifts.\n    #\n    # The chart should have left and right arrows on the sides to switch the\n    # day, with a dropdown menu to select the day from a calendar. Ideally,\n    # switching days should use AJAX to appear more seemless to users.\n\n    # Recent History\n    day = _get_date(request, \"day\", today)\n    start_date = _get_date(request, \"start_date\", day)\n    end_date = _get_date(request, \"end_date\", day)\n\n    template_dict[\"day\"] = day\n    template_dict[\"start_date\"] = start_date\n    template_dict[\"end_date\"] = end_date\n    template_dict[\"long_range\"] = (end_date - start_date).days > 7\n\n    if day > semester.start_date:\n        template_dict[\"prev_day\"] = (start_date - timedelta(days=1)).strftime(\"%Y-%m-%d\")\n    if day < semester.end_date:\n        template_dict[\"next_day\"] = (end_date + timedelta(days=1)).strftime(\"%Y-%m-%d\")\n\n    if Semester.objects.count() > 1:\n        switch_form = SwitchSemesterForm(\n            data=request.POST if \"switch_semester\" in request.POST else None\n        )\n        template_dict[\"switch_form\"] = switch_form\n\n        if switch_form.is_valid():\n            semester = switch_form.save()\n            return HttpResponseRedirect(semester.get_view_url())\n\n    # Grab the shifts for just today, as well as week-long shifts\n    day_shifts = WorkshiftInstance.objects.filter(\n        date__gte=start_date,\n        date__lte=end_date,\n    ).exclude(\n        Q(weekly_workshift__week_long=True) |\n        Q(info__week_long=True),\n    )\n\n    last_monday = start_date - timedelta(days=start_date.weekday())\n    next_sunday = end_date - timedelta(days=end_date.weekday() + 1) + timedelta(weeks=1)\n\n    week_shifts = WorkshiftInstance.objects.filter(\n        Q(weekly_workshift__week_long=True) |\n        Q(info__week_long=True),\n        date__gte=last_monday, date__lte=next_sunday,\n    )\n\n    template_dict[\"last_monday\"] = last_monday.strftime(\"%Y-%m-%d\")\n    template_dict[\"next_sunday\"] = next_sunday.strftime(\"%Y-%m-%d\")\n\n    # Add a login form for anonymous user\n    if profile is None and request.user.username == ANONYMOUS_USERNAME:\n        anonymous_form = AnonymousUserLogin(\n            data=request.POST or None,\n            prefix=\"anon\",\n            semester=semester,\n        )\n\n        if anonymous_form.is_valid():\n            profile = anonymous_form.save()\n\n        template_dict[\"anonymous_form\"] = anonymous_form\n\n    template_dict[\"day_shifts\"] = [\n        (shift, _get_forms(\n            profile, shift, request,\n            undo=utils.can_manage(request.user, semester=semester, pool=shift.pool),\n        ))\n        for shift in day_shifts\n    ]\n    template_dict[\"week_shifts\"] = [\n        (shift, _get_forms(\n            profile, shift, request,\n            undo=utils.can_manage(request.user, semester=semester, pool=shift.pool),\n        ))\n        for shift in week_shifts\n    ]\n\n    # Save any forms that were submitted\n    all_forms = [\n        form\n        for instance, forms in template_dict[\"day_shifts\"]\n        for form in forms\n    ] + [\n        form\n        for instance, forms in template_dict[\"week_shifts\"]\n        for form in forms\n    ]\n    for form in all_forms:\n        if form.is_valid():\n            form.save()\n            return HttpResponseRedirect(\n                semester.get_view_url() + _get_date_params(request)\n            )\n        else:\n            for error in form.errors.values():\n                messages.add_message(request, messages.ERROR, error)\n\n    return render_to_response(\n        \"semester.html\",\n        template_dict,\n        context_instance=RequestContext(request),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the list of forms for a given profile interacting with an instance of a shift.", "response": "def _get_forms(profile, instance, request, undo=False, prefix=\"\"):\n    \"\"\"\n    Gets the forms for profile interacting with an instance of a shift. This\n    includes verify shift, mark shift as blown, sign in, and sign out.\n    \"\"\"\n    anonymous = profile is None and request.user.username == ANONYMOUS_USERNAME\n\n    if not profile and not anonymous:\n        return []\n\n    if prefix:\n        prefix += \"-{}\".format(instance.pk)\n    else:\n        prefix = \"{}\".format(instance.pk)\n\n    kwargs = dict(\n        initial={\"pk\": instance.pk},\n        profile=profile,\n        prefix=prefix,\n        undo=undo,\n    )\n\n    ret = []\n    if (not instance.closed or undo) and instance.workshifter:\n        workshifter = instance.workshifter or instance.liable\n        pool = instance.pool\n\n        if not profile:\n            managers = []\n        else:\n            managers = Manager.objects.filter(incumbent__user=profile.user)\n\n        verify, blow = False, False\n\n        # The many ways a person can be eligible to verify a shift...\n        if instance.verify == AUTO_VERIFY:\n            pass\n        elif instance.verify == SELF_VERIFY:\n            verify = True\n        elif instance.verify == OTHER_VERIFY and profile != workshifter:\n            verify = True\n        elif instance.verify == ANY_MANAGER_VERIFY and managers:\n            verify = True\n        elif instance.verify == POOL_MANAGER_VERIFY and \\\n          set(managers).intersections(pool.managers):\n            verify = True\n        elif instance.verify == WORKSHIFT_MANAGER_VERIFY and \\\n          any(i.workshift_manager for i in managers):\n            verify = True\n\n        if verify and not instance.verifier:\n            # Verify Shift\n            action = \"{}-{}\".format(VerifyShiftForm.action_name, instance.pk)\n            ret.append(\n                VerifyShiftForm(\n                    data=request.POST if action in request.POST else None,\n                    **kwargs\n                )\n            )\n\n        if pool.any_blown:\n            blow = True\n\n        if profile:\n            pool_managers = pool.managers.filter(incumbent__user=profile.user)\n            if pool_managers.count():\n                blow = True\n\n        if blow and not instance.blown:\n            # Blown Shift\n            action = \"{}-{}\".format(BlownShiftForm.action_name, instance.pk)\n            ret.append(\n                BlownShiftForm(\n                    data=request.POST if action in request.POST else None,\n                    **kwargs\n                )\n            )\n\n    if profile is not None:\n        marked_blown = UndoShiftForm.check_marked_blown(instance, profile)\n\n        if marked_blown or instance.verifier == profile:\n            # Undo Verify Shift\n            action = \"{}-{}\".format(UndoShiftForm.action_name, instance.pk)\n            ret.append(\n                UndoShiftForm(\n                    data=request.POST if action in request.POST else None,\n                    **kwargs\n                )\n            )\n\n    if not instance.closed:\n        if not instance.workshifter:\n            # Sign In\n            action = \"{}-{}\".format(SignInForm.action_name, instance.pk)\n            ret.append(\n                SignInForm(\n                    data=request.POST if action in request.POST else None,\n                    **kwargs\n                )\n            )\n        liable = instance.workshifter or instance.liable\n        if (undo and liable is not None) or \\\n           instance.workshifter == profile:\n            # Sign Out\n            action = \"{}-{}\".format(SignOutForm.action_name, instance.pk)\n            ret.append(\n                SignOutForm(\n                    data=request.POST if action in request.POST else None,\n                    **kwargs\n                )\n            )\n\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if a user is marked a particular instance s workshift type as preferred.", "response": "def _is_preferred(instance, profile):\n    \"\"\"\n    Check if a user has marked an instance's workshift type as preferred.\n    \"\"\"\n    if not instance.weekly_workshift:\n        return False\n    if profile and profile.ratings.filter(\n            workshift_type=instance.weekly_workshift.workshift_type,\n            rating=WorkshiftRating.LIKE,\n    ).count() == 0:\n        return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshows the user their preferences for the given semester.", "response": "def preferences_view(request, semester, targetUsername, profile=None):\n    \"\"\"\n    Show the user their preferences for the given semester.\n    \"\"\"\n    # TODO: Change template to show descriptions in tooltip / ajax show box?\n    wprofile = get_object_or_404(\n        WorkshiftProfile,\n        user__username=targetUsername,\n    )\n    full_management = utils.can_manage(request.user, semester=semester)\n\n    if wprofile.user != request.user and \\\n       not full_management:\n        messages.add_message(\n            request,\n            messages.ERROR,\n            MESSAGES[\"ADMINS_ONLY\"],\n        )\n        return HttpResponseRedirect(semester.get_view_url())\n\n    rating_forms = []\n    for wtype in WorkshiftType.objects.filter(rateable=True):\n        try:\n            rating = wprofile.ratings.get(workshift_type=wtype)\n        except WorkshiftRating.DoesNotExist:\n            rating = WorkshiftRating(workshift_type=wtype)\n        form = WorkshiftRatingForm(\n            data=request.POST or None,\n            prefix=\"rating-{}\".format(wtype.pk),\n            instance=rating,\n            profile=wprofile,\n        )\n        rating_forms.append(form)\n\n    time_formset = TimeBlockFormSet(\n        data=request.POST or None,\n        prefix=\"time\",\n        profile=wprofile,\n    )\n    note_form = ProfileNoteForm(\n        data=request.POST or None,\n        instance=wprofile,\n        prefix=\"note\",\n    )\n\n    if all(i.is_valid() for i in rating_forms) and time_formset.is_valid() and \\\n       note_form.is_valid():\n        for form in rating_forms:\n            form.save()\n        time_formset.save()\n        note_form.save()\n        if wprofile.preference_save_time is None:\n            wprofile.preference_save_time = now()\n            wprofile.save()\n        messages.add_message(\n            request,\n            messages.INFO,\n            \"Preferences saved.\",\n        )\n        return HttpResponseRedirect(wurl(\n            \"workshift:preferences\",\n            sem_url=semester.sem_url,\n            targetUsername=request.user.username,\n        ))\n\n    if wprofile == profile:\n        page_name = \"My Workshift Preferences\"\n    else:\n        page_name = \"{}'s Workshift Preferences\".format(\n            wprofile.user.get_full_name(),\n        )\n    return render_to_response(\"preferences.html\", {\n        \"page_name\": page_name,\n        \"profile\": wprofile,\n        \"rating_forms\": rating_forms,\n        \"time_formset\": time_formset,\n        \"note_form\": note_form,\n    }, context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nviewing all members' preferences. This view also includes forms to create an entire semester's worth of weekly workshifts.", "response": "def manage_view(request, semester, profile=None):\n    \"\"\"\n    View all members' preferences. This view also includes forms to create an\n    entire semester's worth of weekly workshifts.\n    \"\"\"\n    page_name = \"Manage Workshift\"\n    pools = WorkshiftPool.objects.filter(semester=semester)\n    full_management = utils.can_manage(request.user, semester=semester)\n    edit_semester_form = None\n    close_semester_form = None\n    open_semester_form = None\n\n    if not full_management:\n        pools = pools.filter(managers__incumbent__user=request.user)\n        if not pools.count():\n            messages.add_message(request, messages.ERROR,\n                                 MESSAGES[\"ADMINS_ONLY\"])\n            return HttpResponseRedirect(semester.get_view_url())\n    else:\n        edit_semester_form = FullSemesterForm(\n            data=request.POST if \"edit_semester\" in request.POST else None,\n            instance=semester,\n        )\n        if semester.current:\n            close_semester_form = CloseSemesterForm(\n                data=request.POST if \"close_semester\" in request.POST else None,\n                semester=semester,\n            )\n        else:\n            open_semester_form = OpenSemesterForm(\n                data=request.POST if \"open_semester\" in request.POST else None,\n                semester=semester\n            )\n\n    if edit_semester_form and edit_semester_form.is_valid():\n        semester = edit_semester_form.save()\n        messages.add_message(\n            request,\n            messages.INFO,\n            \"Semester successfully updated.\",\n        )\n        return HttpResponseRedirect(wurl(\n            \"workshift:manage\",\n            sem_url=semester.sem_url,\n        ))\n\n    if close_semester_form and close_semester_form.is_valid():\n        close_semester_form.save()\n        messages.add_message(request, messages.INFO, \"Semester closed.\")\n        return HttpResponseRedirect(wurl(\n            \"workshift:manage\",\n            sem_url=semester.sem_url,\n        ))\n\n    if open_semester_form and open_semester_form.is_valid():\n        open_semester_form.save()\n        messages.add_message(request, messages.INFO, \"Semester reopened.\")\n        return HttpResponseRedirect(wurl(\n            \"workshift:manage\",\n            sem_url=semester.sem_url,\n        ))\n\n    pools = pools.order_by(\"-is_primary\", \"title\")\n    workshifters = WorkshiftProfile.objects.filter(semester=semester)\n    pool_hours = [\n        [\n            workshifter.pool_hours.get(pool=pool)\n            for pool in pools\n        ]\n        for workshifter in workshifters\n    ]\n\n    return render_to_response(\"manage.html\", {\n        \"page_name\": page_name,\n        \"pools\": pools,\n        \"full_management\": full_management,\n        \"edit_semester_form\": edit_semester_form,\n        \"close_semester_form\": close_semester_form,\n        \"open_semester_form\": open_semester_form,\n        \"workshifters\": zip(workshifters, pool_hours),\n    }, context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef assign_shifts_view(request, semester):\n    page_name = \"Assign Shifts\"\n\n    auto_assign_shifts_form = None\n    random_assign_instances_form = None\n    clear_assign_form = None\n\n    if WorkshiftPool.objects.filter(semester=semester).count():\n        auto_assign_shifts_form = AutoAssignShiftForm(\n            data=request.POST if AutoAssignShiftForm.name in request.POST else None,\n            semester=semester,\n        )\n        random_assign_instances_form = RandomAssignInstancesForm(\n            data=request.POST if RandomAssignInstancesForm.name in request.POST else None,\n            semester=semester,\n        )\n        clear_assign_form = ClearAssignmentsForm(\n            data=request.POST if ClearAssignmentsForm.name in request.POST else None,\n            semester=semester,\n        )\n\n    forms = [auto_assign_shifts_form, random_assign_instances_form,\n             clear_assign_form]\n\n    if auto_assign_shifts_form and auto_assign_shifts_form.is_valid():\n        unassigned_profiles = auto_assign_shifts_form.save()\n        message = \"Assigned workshifters to regular workshifts.\"\n        if unassigned_profiles:\n            message += \" The following workshifters were not given \" \\\n              \"complete assignments: \"\n            message += \", \".join(i.user.get_full_name() for i in unassigned_profiles)\n        messages.add_message(request, messages.INFO, message)\n        return HttpResponseRedirect(wurl(\n            \"workshift:assign_shifts\",\n            sem_url=semester.sem_url,\n        ))\n\n    if random_assign_instances_form and random_assign_instances_form.is_valid():\n        unassigned_profiles, unassigned_shifts = \\\n          random_assign_instances_form.save()\n        message = \"Assigned workshifters randomly to instances within {}.\" \\\n          .format(random_assign_instances_form.cleaned_data[\"pool\"])\n        if unassigned_profiles:\n            message += \"The following workshifers were not given \" \\\n              \"complete assignments: \"\n            message += \", \".join(i.user.get_full_name() for i in unassigned_profiles)\n        messages.add_message(request, messages.INFO, message)\n        return HttpResponseRedirect(wurl(\n            \"workshift:assign_shifts\",\n            sem_url=semester.sem_url,\n        ))\n\n    if clear_assign_form and clear_assign_form.is_valid():\n        clear_assign_form.save()\n        messages.add_message(\n            request,\n            messages.INFO,\n            \"Cleared all workshifters from their regular workshift \"\n            \"assignments\",\n        )\n        return HttpResponseRedirect(wurl(\n            \"workshift:assign_shifts\",\n            sem_url=semester.sem_url,\n        ))\n\n    shifts = RegularWorkshift.objects.filter(\n        pool__semester=semester,\n        active=True,\n    ).exclude(\n        workshift_type__assignment=WorkshiftType.NO_ASSIGN,\n    )\n\n    assign_forms = []\n    for shift in shifts:\n        form = AssignShiftForm(\n            data=request.POST if \"individual_assign\" in request.POST else None,\n            prefix=\"shift-{}\".format(shift.pk),\n            instance=shift,\n            semester=semester,\n        )\n        assign_forms.append(form)\n\n    if assign_forms and all(i.is_valid() for i in assign_forms):\n        for form in assign_forms:\n            form.save()\n        messages.add_message(\n            request,\n            messages.INFO,\n            \"Workshift assignments saved.\",\n        )\n        return HttpResponseRedirect(wurl(\n            \"workshift:assign_shifts\",\n            sem_url=semester.sem_url,\n        ))\n\n    workshifters = WorkshiftProfile.objects.filter(semester=semester)\n    pools = WorkshiftPool.objects.filter(semester=semester).order_by(\n        \"-is_primary\", \"title\",\n    )\n\n    pool_hours = []\n    for workshifter in workshifters:\n        hours_owed = []\n        for pool in pools:\n            hours = workshifter.pool_hours.get(pool=pool)\n            hours_owed.append(hours.hours - hours.assigned_hours)\n\n        if any(i > 0 for i in hours_owed):\n            pool_hours.append(hours_owed)\n\n    total_pool_hours = [\n        sum(hours[i] for hours in pool_hours)\n        for i in range(len(pool_hours[0]) if len(pool_hours) > 0 else 0)\n    ]\n\n    return render_to_response(\"assign_shifts.html\", {\n        \"page_name\": page_name,\n        \"forms\": forms,\n        \"assign_forms\": assign_forms,\n        \"unassigned_profiles\": zip(workshifters, pool_hours),\n        \"pools\": pools,\n        \"total_pool_hours\": total_pool_hours,\n    }, context_instance=RequestContext(request))", "response": "View all members preferences. This view includes forms to create an anonymized list of workshifts. This view includes forms to create anonymized list of workshifts. This view includes forms to create anonymized list of workshifts. This view includes forms to create anonymized list of workshifts."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nview for Adjust Hours.", "response": "def adjust_hours_view(request, semester):\n    \"\"\"\n    Adjust members' workshift hours requirements.\n    \"\"\"\n    page_name = \"Adjust Hours\"\n\n    pools = WorkshiftPool.objects.filter(semester=semester).order_by(\n        \"-is_primary\", \"title\",\n    )\n    workshifters = WorkshiftProfile.objects.filter(semester=semester)\n    pool_hour_forms = []\n\n    for workshifter in workshifters:\n        forms_list = []\n        for pool in pools:\n            hours = workshifter.pool_hours.get(pool=pool)\n            forms_list.append((\n                AdjustHoursForm(\n                    data=request.POST or None,\n                    prefix=\"pool_hours-{}\".format(hours.pk),\n                    instance=hours,\n                ),\n                hours,\n            ))\n        pool_hour_forms.append(forms_list)\n\n    if all(\n            form.is_valid()\n            for workshifter_forms in pool_hour_forms\n            for form, pool_hours in workshifter_forms\n    ):\n        for workshifter_forms in pool_hour_forms:\n            for form, pool_hours in workshifter_forms:\n                form.save()\n        messages.add_message(request, messages.INFO, \"Updated hours.\")\n        return HttpResponseRedirect(wurl(\n            \"workshift:adjust_hours\",\n            sem_url=semester.sem_url,\n        ))\n\n    return render_to_response(\"adjust_hours.html\", {\n        \"page_name\": page_name,\n        \"pools\": pools,\n        \"workshifters_tuples\": zip(workshifters, pool_hour_forms),\n    }, context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_workshifter_view(request, semester):\n    page_name = \"Add Workshifter\"\n\n    existing = [\n        i.user.pk for i in WorkshiftProfile.objects.filter(semester=semester)\n    ]\n    users = User.objects.exclude(\n        Q(pk__in=existing) |\n        Q(is_active=False) |\n        Q(userprofile__status=UserProfile.ALUMNUS)\n    )\n\n    add_workshifter_forms = []\n    for user in users:\n        form = AddWorkshifterForm(\n            data=request.POST or None,\n            prefix=\"user-{}\".format(user.pk),\n            user=user,\n            semester=semester,\n        )\n        add_workshifter_forms.append(form)\n\n    if add_workshifter_forms and \\\n       all(form.is_valid() for form in add_workshifter_forms):\n        for form in add_workshifter_forms:\n            form.save()\n        messages.add_message(\n            request,\n            messages.INFO,\n            \"Workshifters added.\",\n        )\n        return HttpResponseRedirect(wurl(\n            \"workshift:manage\",\n            sem_url=semester.sem_url,\n        ))\n\n    return render_to_response(\"add_workshifter.html\", {\n        \"page_name\": page_name,\n        \"add_workshifter_forms\": add_workshifter_forms,\n    }, context_instance=RequestContext(request))", "response": "View for adding new member workshift profiles for people who join mid - semester."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nview for the workshift manager to create new workshift pools.", "response": "def add_pool_view(request, semester):\n    \"\"\"\n    View for the workshift manager to create new workshift pools (i.e. HI\n    Hours).\n    \"\"\"\n    page_name = \"Add Workshift Pool\"\n    add_pool_form = PoolForm(\n        data=request.POST or None,\n        semester=semester,\n        full_management=True,\n    )\n    if add_pool_form.is_valid():\n        add_pool_form.save()\n        messages.add_message(\n            request,\n            messages.INFO,\n            \"Workshift pool added.\",\n        )\n        return HttpResponseRedirect(wurl(\n            \"workshift:manage\",\n            sem_url=semester.sem_url,\n        ))\n    return render_to_response(\"add_pool.html\", {\n        \"page_name\": page_name,\n        \"add_pool_form\": add_pool_form,\n    }, context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fill_shifts_view(request, semester):\n    page_name = \"Fill Shifts\"\n\n    fill_regular_shifts_form = None\n    fill_social_shifts_form = None\n    fill_humor_shifts_form = None\n    fill_bathroom_shifts_form = None\n    fill_hi_shifts_form = None\n    reset_all_shifts_form = None\n\n    managers = Manager.objects.filter(incumbent__user=request.user)\n    admin = utils.can_manage(request.user, semester=semester)\n\n    if admin:\n        fill_regular_shifts_form = FillRegularShiftsForm(\n            data=request.POST,\n            semester=semester,\n        )\n        fill_humor_shifts_form = FillHumorShiftsForm(\n            data=request.POST,\n            semester=semester,\n        )\n        fill_bathroom_shifts_form = FillBathroomShiftsForm(\n            data=request.POST,\n            semester=semester,\n        )\n        reset_all_shifts_form = ResetAllShiftsForm(\n            data=request.POST,\n            semester=semester,\n        )\n    # XXX: BAD! We should filter by pool owners? By Manager bool flags? By\n    # arbitrary django permissions?\n    if admin or managers.filter(title=\"Social Manager\"):\n        fill_social_shifts_form = FillSocialShiftsForm(\n            data=request.POST,\n            semester=semester,\n        )\n    # XXX: See above\n    if admin or managers.filter(title=\"Maintenance Manager\"):\n        fill_hi_shifts_form = FillHIShiftsForm(\n            data=request.POST,\n            semester=semester,\n        )\n\n    fill_forms = [\n        fill_regular_shifts_form, fill_social_shifts_form,\n        fill_humor_shifts_form, fill_bathroom_shifts_form,\n        fill_hi_shifts_form, reset_all_shifts_form,\n    ]\n    fill_forms = [\n        form\n        for form in fill_forms\n        if form is not None\n    ]\n\n    for form in fill_forms:\n        if form and form.is_valid():\n            count = form.save()\n            messages.add_message(\n                request,\n                messages.INFO,\n                \"{} {} {}\".format(\n                    form.message, count, p.plural(\"workshift\", count),\n                ),\n            )\n            return HttpResponseRedirect(wurl(\n                \"workshift:fill_shifts\",\n                sem_url=semester.sem_url,\n            ))\n\n    return render_to_response(\"fill_shifts.html\", {\n        \"page_name\": page_name,\n        \"forms\": fill_forms,\n    }, context_instance=RequestContext(request))", "response": "This function handles the request for the fill_shifts_form and fill_humor_shifts_form and fill_hi_shifts_form methods."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_shift_view(request, semester):\n    page_name = \"Add Workshift\"\n    any_management = utils.can_manage(request.user, semester, any_pool=True)\n\n    if not any_management:\n        messages.add_message(\n            request,\n            messages.ERROR,\n            MESSAGES[\"ADMINS_ONLY\"],\n        )\n        return HttpResponseRedirect(semester.get_view_url())\n\n    # Check what pools this person can manage\n    pools = WorkshiftPool.objects.filter(semester=semester)\n    full_management = utils.can_manage(request.user, semester=semester)\n\n    if not full_management:\n        pools = pools.filter(managers__incumbent__user=request.user)\n\n    # Forms\n    add_type_form = WorkshiftTypeForm(\n        data=request.POST if \"add_type\" in request.POST else None,\n        prefix=\"type\",\n    )\n    shifts_formset = RegularWorkshiftFormSet(\n        data=request.POST if \"add_type\" in request.POST else None,\n        prefix=\"shifts\",\n        queryset=RegularWorkshift.objects.none(),\n        pools=pools,\n    )\n\n    if add_type_form.is_valid() and shifts_formset.is_valid():\n        wtype = add_type_form.save()\n        shifts_formset.save(workshift_type=wtype)\n        return HttpResponseRedirect(wurl(\n            \"workshift:manage\",\n            sem_url=semester.sem_url,\n        ))\n\n    add_instance_form = WorkshiftInstanceForm(\n        data=request.POST if \"add_instance\" in request.POST else None,\n        pools=pools,\n        semester=semester,\n    )\n    if add_instance_form.is_valid():\n        add_instance_form.save()\n        return HttpResponseRedirect(wurl(\n            \"workshift:manage\",\n            sem_url=semester.sem_url,\n        ))\n\n    return render_to_response(\"add_shift.html\", {\n        \"page_name\": page_name,\n        \"add_type_form\": add_type_form,\n        \"shifts_formset\": shifts_formset,\n        \"add_instance_form\": add_instance_form,\n    }, context_instance=RequestContext(request))", "response": "View for the workshift manager to create new types of workshifts."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nview the details of a particular RegularWorkshift.", "response": "def shift_view(request, semester, pk, profile=None):\n    \"\"\"\n    View the details of a particular RegularWorkshift.\n    \"\"\"\n    shift = get_object_or_404(RegularWorkshift, pk=pk)\n    page_name = shift.workshift_type.title\n\n    if shift.is_manager_shift:\n        president = Manager.objects.filter(\n            incumbent__user=request.user,\n            president=True,\n        ).count() > 0\n        can_edit = request.user.is_superuser or president\n    else:\n        can_edit = utils.can_manage(\n            request.user,\n            semester=semester,\n            pool=shift.pool,\n        )\n\n    instances = WorkshiftInstance.objects.filter(\n        weekly_workshift=shift,\n        date__gte=localtime(now()).date(),\n    )\n    instance_tuples = [\n        (\n            instance,\n            _get_forms(profile, instance, request, undo=can_edit),\n        )\n        for instance in instances\n    ]\n\n    # Save any forms that were submitted\n    all_forms = [form for instance, forms in instance_tuples for form in forms]\n    for form in all_forms:\n        if form.is_valid():\n            form.save()\n            return HttpResponseRedirect(shift.get_view_url())\n        else:\n            for error in form.errors.values():\n                messages.add_message(request, messages.ERROR, error)\n\n    return render_to_response(\"view_shift.html\", {\n        \"page_name\": page_name,\n        \"shift\": shift,\n        \"instance_tuples\": instance_tuples,\n        \"can_edit\": can_edit,\n    }, context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef edit_shift_view(request, semester, pk, profile=None):\n    shift = get_object_or_404(RegularWorkshift, pk=pk)\n\n    if shift.is_manager_shift:\n        # XXX: Bad way of doing this, we should make manager_shift point to\n        # the related Manager object directly\n        try:\n            manager = Manager.objects.get(title=shift.workshift_type.title)\n        except Manager.DoesNotExist:\n            pass\n        else:\n            return HttpResponseRedirect(manager.get_edit_url())\n\n    if not utils.can_manage(request.user, semester=semester, pool=shift.pool):\n        messages.add_message(\n            request,\n            messages.ERROR,\n            MESSAGES[\"ADMINS_ONLY\"],\n        )\n        return HttpResponseRedirect(semester.get_view_url())\n\n    edit_form = RegularWorkshiftForm(\n        data=request.POST if \"edit\" in request.POST else None,\n        instance=shift,\n        semester=semester,\n    )\n\n    if \"delete\" in request.POST:\n        # Open instances are deleted automatically\n        shift.delete()\n        return HttpResponseRedirect(wurl(\n            \"workshift:manage\",\n            sem_url=semester.sem_url,\n        ))\n    elif edit_form.is_valid():\n        shift = edit_form.save()\n        return HttpResponseRedirect(shift.get_view_url())\n\n    page_name = \"Edit {}\".format(shift)\n\n    return render_to_response(\"edit_shift.html\", {\n        \"page_name\": page_name,\n        \"shift\": shift,\n        \"edit_form\": edit_form,\n    }, context_instance=RequestContext(request))", "response": "View for a manager to edit the details of a particular RegularWorkshift."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nview the details of a particular WorkshiftInstance.", "response": "def instance_view(request, semester, pk, profile=None):\n    \"\"\"\n    View the details of a particular WorkshiftInstance.\n    \"\"\"\n    instance = get_object_or_404(WorkshiftInstance, pk=pk)\n    page_name = instance.title\n    management = utils.can_manage(\n        request.user,\n        semester=semester,\n        pool=instance.pool,\n    )\n    interact_forms = _get_forms(\n        profile, instance, request,\n        undo=management,\n        prefix=\"interact\",\n    )\n\n    note_form = NoteForm(\n        data=request.POST or None,\n        prefix=\"note\",\n    )\n\n    # Save any forms that were submitted\n    if note_form.is_valid():\n        for form in interact_forms:\n            if form.is_valid():\n                note = note_form.save()\n                form.save(note=note)\n                return HttpResponseRedirect(instance.get_view_url())\n            else:\n                for error in form.errors.values():\n                    messages.add_message(request, messages.ERROR, error)\n\n    edit_hours_form = None\n    if instance.weekly_workshift and instance.weekly_workshift.is_manager_shift:\n        president = Manager.objects.filter(\n            incumbent__user=request.user,\n            president=True\n        ).count() > 0\n        can_edit = request.user.is_superuser or president\n    else:\n        can_edit = utils.can_manage(\n            request.user, semester=instance.pool.semester, pool=instance.pool,\n        )\n\n    if can_edit:\n        edit_hours_form = EditHoursForm(\n            data=request.POST if \"edit_hours\" in request.POST else None,\n            instance=instance,\n            profile=profile,\n        )\n        if edit_hours_form.is_valid():\n            edit_hours_form.save()\n            messages.add_message(\n                request,\n                messages.INFO,\n                \"Updated instance's hours.\",\n            )\n            return HttpResponseRedirect(instance.get_view_url())\n\n    return render_to_response(\"view_instance.html\", {\n        \"page_name\": page_name,\n        \"can_edit\": can_edit,\n        \"instance\": instance,\n        \"interact_forms\": interact_forms,\n        \"note_form\": note_form,\n        \"edit_hours_form\": edit_hours_form,\n    }, context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nviews for a manager to edit the details of a particular WorkshiftInstance.", "response": "def edit_instance_view(request, semester, pk, profile=None):\n    \"\"\"\n    View for a manager to edit the details of a particular WorkshiftInstance.\n    \"\"\"\n    instance = get_object_or_404(WorkshiftInstance, pk=pk)\n\n    if instance.weekly_workshift and instance.weekly_workshift.is_manager_shift:\n        president = Manager.objects.filter(\n            incumbent__user=request.user,\n            president=True\n        ).count() > 0\n        can_edit = request.user.is_superuser or president\n        message = MESSAGES[\"PRESIDENTS_ONLY\"]\n    else:\n        can_edit = utils.can_manage(\n            request.user, semester=semester, pool=instance.pool,\n        )\n        message = MESSAGES[\"ADMINS_ONLY\"]\n\n    if not can_edit:\n        messages.add_message(request, messages.ERROR, message)\n        return HttpResponseRedirect(semester.get_view_url())\n\n    page_name = \"Edit \" + instance.title\n\n    edit_form = WorkshiftInstanceForm(\n        data=request.POST if \"edit\" in request.POST else None,\n        instance=instance,\n        semester=semester,\n        edit_hours=False,\n    )\n\n    if \"delete\" in request.POST:\n        instance.delete()\n        return HttpResponseRedirect(wurl(\n            \"workshift:manage\",\n            sem_url=semester.sem_url,\n        ))\n    elif edit_form.is_valid():\n        instance = edit_form.save()\n        return HttpResponseRedirect(instance.get_view_url())\n\n    return render_to_response(\"edit_instance.html\", {\n        \"page_name\": page_name,\n        \"instance\": instance,\n        \"edit_form\": edit_form,\n    }, context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_types_view(request, semester, profile=None):\n    page_name = \"Workshift Types\"\n    full_management = utils.can_manage(request.user, semester)\n    any_management = utils.can_manage(request.user, semester, any_pool=True)\n\n    types = WorkshiftType.objects.all()\n    type_shifts = [\n        RegularWorkshift.objects.filter(\n            workshift_type=i,\n            pool__semester=semester,\n        ).order_by(\"day\")\n        for i in types\n    ]\n    shift_edits = [\n        [\n            (\n                shift,\n                full_management or\n                utils.can_manage(request.user, semester, pool=shift.pool),\n            )\n            for shift in shifts\n        ]\n        for shifts in type_shifts\n    ]\n\n    return render_to_response(\"list_types.html\", {\n        \"page_name\": page_name,\n        \"type_tuples\": zip(types, shift_edits),\n        \"can_edit\": any_management,\n    }, context_instance=RequestContext(request))", "response": "View the details of a particular WorkshiftType."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nviewing the details of a particular WorkshiftType.", "response": "def type_view(request, semester, pk, profile=None):\n    \"\"\"\n    View the details of a particular WorkshiftType.\n    \"\"\"\n    any_management = utils.can_manage(request.user, semester, any_pool=True)\n    wtype = get_object_or_404(WorkshiftType, pk=pk)\n    page_name = wtype.title\n    regular_shifts = RegularWorkshift.objects.filter(\n        workshift_type=wtype,\n        pool__semester=semester,\n    )\n    return render_to_response(\"view_type.html\", {\n        \"page_name\": page_name,\n        \"wtype\": wtype,\n        \"regular_shifts\": regular_shifts,\n        \"can_edit\": any_management,\n    }, context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef edit_type_view(request, semester, pk, profile=None):\n    wtype = get_object_or_404(WorkshiftType, pk=pk)\n    full_management = utils.can_manage(request.user, semester)\n    any_management = utils.can_manage(request.user, semester, any_pool=True)\n\n    if not any_management:\n        messages.add_message(\n            request,\n            messages.ERROR,\n            MESSAGES[\"ADMINS_ONLY\"],\n        )\n        return HttpResponseRedirect(semester.get_view_url())\n\n    if full_management:\n        if \"delete\" in request.POST:\n            messages.add_message(\n                request,\n                messages.INFO,\n                \"Workshift type deleted.\",\n            )\n            wtype.delete()\n            return HttpResponseRedirect(wurl(\n                \"workshift:list_types\",\n                sem_url=semester.sem_url,\n            ))\n\n    edit_form = WorkshiftTypeForm(\n        data=request.POST if \"edit\" in request.POST else None,\n        instance=wtype,\n        prefix=\"edit\",\n        read_only=not full_management,\n    )\n\n    queryset = RegularWorkshift.objects.filter(\n        workshift_type=wtype,\n    )\n\n    if not full_management:\n        queryset = queryset.filter(\n            pool__managers__incumbent__user=request.user,\n        )\n\n    shifts_formset = RegularWorkshiftFormSet(\n        data=request.POST if \"edit\" in request.POST else None,\n        prefix=\"shifts\",\n        queryset=queryset,\n    )\n\n    if edit_form.is_valid() and shifts_formset.is_valid():\n        if full_management:\n            wtype = edit_form.save()\n        shifts_formset.save(wtype)\n        return HttpResponseRedirect(wtype.get_view_url())\n\n    page_name = \"Edit {}\".format(wtype.title)\n\n    return render_to_response(\"edit_type.html\", {\n        \"page_name\": page_name,\n        \"shift\": wtype,\n        \"edit_form\": edit_form,\n        \"shifts_formset\": shifts_formset,\n    }, context_instance=RequestContext(request))", "response": "View for a manager to edit the details of a particular WorkshiftType."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _import_modules(dir_path):\n\n    def _import_module(module):\n        \"\"\" Imports the specified module.\n            \"\"\"\n        # already loaded, skip\n        if module in mods_loaded:\n            return False\n\n        __import__(module)\n        mods_loaded.append(module)\n\n    mods_loaded = []\n\n    # check if provided path exists\n    if not os.path.isdir(dir_path):\n        return\n\n    try:\n        # update import search path\n        sys.path.insert(0, dir_path)\n\n        # check for modules in the dir path\n        for entry in os.listdir(dir_path):\n            path = os.path.join(dir_path, entry)\n\n            if os.path.isdir(path):  # directory\n                _import_module(entry)\n\n            elif _RE_PY_EXT.search(entry):  # python file\n                if not _RE_INIT_PY.match(entry):  # exclude init\n                    name = _RE_PY_EXT.sub('', entry)\n                    _import_module(name)\n    finally:\n        # remove inserted path\n        sys.path.pop(0)", "response": "Attempts to import modules in the specified directory path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate data directories structure.", "response": "def _setup_directories(self):\n        \"\"\" Creates data directory structure.\n\n            * Raises a ``DirectorySetupFail`` exception if error occurs\n              while creating directories.\n            \"\"\"\n        dirs = [self._data_dir]\n        dirs += [os.path.join(self._data_dir, name) for name\n                 in self.DATA_SUBDIRS]\n\n        for path in dirs:\n            if not os.path.isdir(path):\n                try:\n                    os.makedirs(path)  # recursive mkdir\n                    os.chmod(path, 0755)  # rwxr-xr-x\n\n                except OSError:\n                    raise errors.DirectorySetupFail()\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _setup_task(self, load):\n\n        if not self._task:\n            self._task = Task(self._data_dir)\n\n        if load:\n            self._task.load()", "response": "Sets up the Task object and loads active file for task."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _load_plugins(self):\n\n        # import base plugin modules\n        try:\n            __import__('focus.plugin.modules')\n            #import focus.plugin.modules\n        except ImportError as exc:\n            raise errors.PluginImport(unicode(exc))\n\n        # load user defined plugin modules\n        try:\n            user_plugin_dir = os.path.join(self._data_dir, 'plugins')\n            _import_modules(user_plugin_dir)\n\n        except Exception as exc:\n            raise errors.UserPluginImport(unicode(exc))", "response": "Attempts to load plugin modules according to the order of available\n            plugin directories."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads in resources needed for this environment.", "response": "def load(self):\n        \"\"\" Loads in resources needed for this environment, including loading a\n            new or existing task, establishing directory structures, and\n            importing plugin modules.\n            \"\"\"\n\n        self._setup_directories()\n        self._load_plugins()\n        self._setup_task(load=True)\n        self._loaded = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef resize(image, width=None, height=None, crop=False, namespace=\"resized\"):\n    return resize_lazy(image=image, width=width, height=height, crop=crop,\n                       namespace=namespace, as_url=True)", "response": "Resizes an image and returns the url of the resized image"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef conditional_resize(image, ratio, width=None, height=None, upcrop=True,\n                       namespace=\"resized\"):\n    \"\"\"\n    Crop the image based on a ratio\n\n    If upcrop is true, crops the images that have a higher ratio than the given\n    ratio, if false crops the images that have a lower ratio\n    \"\"\"\n    aspect = float(image.width) / float(image.height)\n    crop = False\n\n    if (aspect > ratio and upcrop) or (aspect <= ratio and not upcrop):\n        crop = True\n\n    return resize_lazy(image=image, width=width, height=height, crop=crop,\n                       namespace=namespace, as_url=True)", "response": "Conditional resize of an image based on a ratio"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the closest match to string s if exceeds threshold else returns None", "response": "def choose(s, possibilities, threshold=.6):\n    \"\"\"\n    Returns the closest match to string s if exceeds threshold, else returns None\n    \"\"\"\n    if not possibilities: return None\n    if s in possibilities: return s\n    if s == '': return None\n    startswith = [x for x in possibilities if x.lower().startswith(s.lower())]\n    if len(startswith) == 1: return startswith[0]\n    contained = [x for x in possibilities if s.lower() in x.lower()]\n    if len(contained) == 1: return contained[0]\n    best = max([(x, Levenshtein.jaro_winkler(s, x, .05)) for x in possibilities], key=itemgetter(1))\n    if best[1] < threshold:\n        #print 'did you mean %s?' % best[0]\n        return None\n    return best[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a normalized vector for arbitrary axis", "response": "def normalized(a, axis=-1, order=2):\n    '''Return normalized vector for arbitrary axis\n\n    Args\n    ----\n    a: ndarray (n,3)\n        Tri-axial vector data\n    axis: int\n        Axis index to overwhich to normalize\n    order: int\n        Order of nomalization to calculate\n\n    Notes\n    -----\n    This function was adapted from the following StackOverflow answer:\n    http://stackoverflow.com/a/21032099/943773\n    '''\n    import numpy\n\n    l2 = numpy.atleast_1d(numpy.linalg.norm(a, order, axis))\n    l2[l2==0] = 1\n\n    return a / numpy.expand_dims(l2, axis)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef findzc(x, thresh, t_max=None):\n    '''\n    Find cues to each zero-crossing in vector x.\n\n    To be accepted as a zero-crossing, the signal must pass from below\n    -thresh to above thresh, or vice versa, in no more than t_max samples.\n\n    Args\n    ----\n    thresh: (float)\n        magnitude threshold for detecting a zero-crossing.\n    t_max: (int)\n        maximum duration in samples between threshold crossings.\n\n    Returns\n    -------\n    zc: ndarray\n        Array containing the start **zc_s**, finish **zc_f** and direction **S**\n        of zero crossings\n\n        where:\n\n        * zc_s: the cue of the first threshold-crossing in samples\n        * zc_f: the cue of the second threshold-crossing in samples\n        * S: the sign of each zero-crossing (1 = positive-going, -1 = negative-going).\n\n    Notes\n    -----\n    This routine is a reimplementation of Mark Johnson's Dtag toolbox method\n    and tested against the Matlab version to be sure it has the same result.\n    '''\n    import numpy\n\n    # positive threshold: p (over) n (under)\n    pt_p = x > thresh\n    pt_n = ~pt_p\n\n    # negative threshold: p (over) n (under)\n    nt_n = x < -thresh\n    nt_p = ~nt_n\n\n    # Over positive threshold +thresh\n    # neg to pos\n    pt_np = (pt_p[:-1] & pt_n[1:]).nonzero()[0]\n    # pos to neg\n    pt_pn = (pt_n[:-1] & pt_p[1:]).nonzero()[0] + 1\n\n    # Over positive threshold +thresh\n    # neg to pos\n    nt_np = (nt_p[:-1] & nt_n[1:]).nonzero()[0] + 1\n    # pos to neg\n    nt_pn = (nt_n[:-1] & nt_p[1:]).nonzero()[0]\n\n    # Concat indices, order sequentially\n    ind_all = numpy.hstack((pt_np, nt_np, pt_pn, nt_pn))\n    ind_all.sort()\n\n    # Omit rows where just touching but not crossing\n    crossing_mask = ~(numpy.diff(numpy.sign(x[ind_all])) == 0)\n\n    # Append a False to make the same length as ind_all\n    crossing_mask = numpy.hstack((crossing_mask, False))\n\n    # Get 1st and 2nd crossings\n    ind_1stx = ind_all[crossing_mask]\n    ind_2ndx = ind_all[numpy.where(crossing_mask)[0]+1]\n\n    # TODO odd option to replace with NaNs rather than delete?\n    # Delete indices that do not have a second crossing\n    del_ind = numpy.where(ind_2ndx > len(x)-1)[0]\n    for i in del_ind:\n        ind_1stx = numpy.delete(ind_1stx, i)\n        ind_2ndx = numpy.delete(ind_1stx, i)\n\n    # Get direction/sign of crossing\n    signs = numpy.sign(x[ind_1stx])*-1\n\n    # Add column of direction and transpose\n    zc = numpy.vstack((ind_1stx, ind_2ndx, signs)).T\n\n    # TODO not mentioned in docstring, remove?\n    #x_norm? = ((x[:, 1] * zc[:, 0]) - (x[:, 0] * zc[:, 1])) / x[:, 1] - x[:, 0]\n\n    if t_max:\n        zc = zc[zc[:, 1] - zc[:, 0] <= t_max, :]\n\n    return zc.astype(int)", "response": "This function finds all zero crossings in vector x."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef butter_filter(cutoff, fs, order=5, btype='low'):\n    '''Create a digital butter fileter with cutoff frequency in Hz\n\n    Args\n    ----\n    cutoff: float\n        Cutoff frequency where filter should separate signals\n    fs: float\n        sampling frequency\n    btype: str\n        Type of filter type to create. 'low' creates a low-frequency filter and\n        'high' creates a high-frequency filter (Default 'low).\n\n    Returns\n    -------\n    b: ndarray\n        Numerator polynomials of the IIR butter filter\n    a: ndarray\n        Denominator polynomials of the IIR butter filter\n\n    Notes\n    -----\n    This function was adapted from the following StackOverflow answer:\n    http://stackoverflow.com/a/25192640/943773\n    '''\n    import scipy.signal\n\n    nyq = 0.5 * fs\n    normal_cutoff = cutoff / nyq\n    b, a = scipy.signal.butter(order, normal_cutoff, btype=btype, analog=False)\n\n    return b, a", "response": "Create a digital butter fileter with cutoff frequency in Hz\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef butter_apply(b, a, data):\n    '''Apply filter with filtfilt to allign filtereted data with input\n\n    The filter is applied once forward and once backward to give it linear\n    phase, using Gustafsson's method to give the same length as the original\n    signal.\n\n    Args\n    ----\n    b: ndarray\n        Numerator polynomials of the IIR butter filter\n    a: ndarray\n        Denominator polynomials of the IIR butter filter\n\n    Returns\n    -------\n    x: ndarray\n        Filtered data with linear phase\n\n    Notes\n    -----\n    This function was adapted from the following StackOverflow answer:\n    http://stackoverflow.com/a/25192640/943773\n    '''\n    import scipy.signal\n\n    return scipy.signal.filtfilt(b, a, data, method='gust')", "response": "Apply filter with filtfilt to allign filtereted data with linear phase."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndetects local maxima and minima in a vector A point is considered a maximum peak if it has the maximal value, and was preceded (to the left) by a value lower by `delta`. Args ---- y: ndarray array of values to find local maxima and minima in delta: float minimum change in `y` since previous peak to be considered new peak. It should be positive and it's absolute value taken to ensure this. x: ndarray corresponding x-axis positions to y array Returns ------- max_ind: ndarray Indices of local maxima min_ind: ndarray Indices of local minima Example ------- max_ind, min_ind = simple_peakfinder(x, y, delta) # get values of `y` at local maxima local_max = y[max_ind] Notes ----- Matlab Author: Eli Billauer http://billauer.co.il/peakdet.html Python translation: Chris Muktar https://gist.github.com/endolith/250860 Python cleanup: Ryan J. Dillon", "response": "def simple_peakfinder(x, y, delta):\n    '''Detect local maxima and minima in a vector\n\n    A point is considered a maximum peak if it has the maximal value, and was\n    preceded (to the left) by a value lower by `delta`.\n\n    Args\n    ----\n    y: ndarray\n        array of values to find local maxima and minima in\n    delta: float\n        minimum change in `y` since previous peak to be considered new peak.\n        It should be positive and it's absolute value taken to ensure this.\n    x: ndarray\n        corresponding x-axis positions to y array\n\n    Returns\n    -------\n    max_ind: ndarray\n        Indices of local maxima\n    min_ind: ndarray\n        Indices of local minima\n\n    Example\n    -------\n    max_ind, min_ind = simple_peakfinder(x, y, delta)\n\n    # get values of `y` at local maxima\n    local_max = y[max_ind]\n\n    Notes\n    -----\n    Matlab Author:      Eli Billauer   http://billauer.co.il/peakdet.html\n    Python translation: Chris Muktar   https://gist.github.com/endolith/250860\n    Python cleanup:     Ryan J. Dillon\n    '''\n    import numpy\n\n    y = numpy.asarray(y)\n\n    max_ind = list()\n    min_ind = list()\n\n    local_min     = numpy.inf\n    local_max     = -numpy.inf\n    local_min_pos = numpy.nan\n    local_max_pos = numpy.nan\n\n    lookformax = True\n\n    for i in range(len(y)):\n\n        if y[i] > local_max:\n            local_max = y[i]\n            local_max_pos = x[i]\n\n        if y[i] < local_min:\n            local_min = y[i]\n            local_min_pos = x[i]\n\n        if lookformax:\n            if y[i] < local_max-abs(delta):\n                max_ind.append(local_max_pos)\n                local_min = y[i]\n                local_min_pos = x[i]\n                lookformax = False\n        else:\n            if y[i] > local_min+abs(delta):\n                min_ind.append(local_min_pos)\n                local_max = y[i]\n                local_max_pos = x[i]\n                lookformax = True\n\n    return numpy.array(max_ind), numpy.array(min_ind)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_near(lat, lon, *, n=10, session=None):\n    search_params = {'npoints': n, 'clat': lat, 'clon': lon, \n                     'Columns[]': ['Subregion', 'Notes', 'CollectionYear', \n                                   'ReservoirAge', 'ReservoirErr', 'C14age', \n                                   'C14err', 'LabID', 'Delta13C', 'nextime', \n                                   'Genus', 'Species', 'Feeding', 'Name']}\n    resp = _query_near(session=session, **search_params)\n    df = _response_to_dataframe(resp)\n    df_clean = _clean_dataframe(df)\n    return df_clean", "response": "Return n results for a given latitude and longitude"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nquery marine database with given query string values and keys", "response": "def _query_near(*, session=None, **kwargs):\n    \"\"\"Query marine database with given query string values and keys\"\"\"\n    url_endpoint = 'http://calib.org/marine/index.html'\n    if session is not None:\n        resp = session.get(url_endpoint, params=kwargs)\n    else:\n        with requests.Session() as s:\n            # Need to get the index page before query. Otherwise get bad query response that seems legit.\n            s.get('http://calib.org/marine/index.html')\n            resp = s.get(url_endpoint, params=kwargs)\n    return resp"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef render_content(self):\n        if not self.has_content:\n            return \"\"\n        template = self.template\n        if isinstance(self.template, str):\n            template = self.app.ps.jinja2.env.get_template(self.template)\n        context = self.render_vars()\n        content = template.render(app=self.app, request=self.request, **context)\n        return content", "response": "Render the panel s content."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef retry(exception_to_check, tries=5, delay=5, multiplier=2):\n    '''Tries to call the wrapped function again, after an incremental delay\n\n    :param exception_to_check: Exception(s) to check for, before retrying.\n    :type exception_to_check: Exception\n    :param tries: Number of time to retry before failling.\n    :type tries: int\n    :param delay: time in second to sleep before retrying.\n    :type delay: int\n    :param multiplier: multiply the delay each time the exception_to_check\n        occurs.\n    :type multiplier: int\n    '''\n    def deco_retry(func):\n        '''Creates the retry decorator'''\n\n        @wraps(func)\n        def func_retry(*args, **kwargs):\n            '''Actual wrapped function'''\n            if multiplier >= 1 is not True:\n                raise ValueError(\n                    'multiplier = {}. It has to be superior to 1.'.format(\n                        multiplier\n                    )\n                )\n            mtries, mdelay = tries, delay\n            while mtries > 1:\n                try:\n                    return func(*args, **kwargs)\n                except exception_to_check as err:\n                    message = \"%s, retrying in %d seconds...\" % (\n                        str(err), mdelay)\n                    print(message)\n                    sleep(mdelay)\n                    mtries -= 1\n                    mdelay *= multiplier\n            return func(*args, **kwargs)\n\n        return func_retry\n    return deco_retry", "response": "Decorator to retry a function in a node tree."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating a measure of a model in an output directory averaged over all times when the model is at steady - state.", "response": "def get_average_measure(dirname, measure_func, t_steady=None):\n    \"\"\"\n    Calculate a measure of a model in an output directory, averaged over\n    all times when the model is at steady-state.\n\n    Parameters\n    ----------\n    dirname: str\n        Output directory\n    measure_func: function\n        Function which takes a :class:`Model` instance as a single argument,\n        and returns the measure of interest, and its uncertainty.\n    t_steady: None or float\n        Time to consider the model to be at steady-state.\n        `None` means just consider the latest time.\n\n    Returns\n    -------\n    measure: numpy.ndarray\n        Measure.\n    measure_errs: numpy.ndarray\n        Measure uncertainty.\n        If no averaging is done, this is taken from the measure_func.\n        Otherwise, the standard error over all samples is used.\n    \"\"\"\n    if t_steady is None:\n        meas, meas_err = measure_func(get_recent_model(dirname))\n        return meas, meas_err\n    else:\n        ms = [filename_to_model(fname) for fname in get_filenames(dirname)]\n        ms_steady = [m for m in ms if m.t > t_steady]\n        meas_list = [measure_func(m) for m in ms_steady]\n        meases, meas_errs = zip(*meas_list)\n        return np.mean(meases), sem(meases)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates a measure of a set of model output directories and a measure function which returns an associated uncertainty.", "response": "def measures(dirnames, measure_func, t_steady=None):\n    \"\"\"Calculate a measure of a set of model output directories,\n    for a measure function which returns an associated uncertainty.\n\n    Parameters\n    ----------\n    dirnames: list[str]\n        Model output directory paths.\n    measure_func: function\n        Function which takes a :class:`Model` instance as a single argument,\n        and returns the measure of interest, and its uncertainty.\n    t_steady: None or float\n        Time to consider the model to be at steady-state.\n        The measure will be averaged over all later times.\n        `None` means just consider the latest time.\n\n    Returns\n    -------\n    measures: numpy.ndarray\n        Measures.\n    measure_errs: numpy.ndarray\n        Uncertainties.\n    \"\"\"\n    measures, measure_errs = [], []\n    for dirname in dirnames:\n        meas, meas_err = get_average_measure(dirname, measure_func, t_steady)\n        measures.append(meas)\n        measure_errs.append(meas_err)\n    return np.array(measures), np.array(measure_errs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate a parameter of a set of model output directories and a measure function which returns an associated uncertainty.", "response": "def params(dirnames, param_func, t_steady=None):\n    \"\"\"Calculate a parameter of a set of model output directories,\n    for a measure function which returns an associated uncertainty.\n\n    Parameters\n    ----------\n    dirnames: list[str]\n        Model output directory paths.\n    param_func: function\n        Function which takes a :class:`Model` instance as a single argument,\n        and returns the parameter of interest.\n\n    Returns\n    -------\n    params: numpy.ndarray\n        Parameters.\n    \"\"\"\n    return np.array([param_func(get_recent_model(d)) for d in dirnames])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating a measure over time for a single output directory.", "response": "def t_measures(dirname, time_func, measure_func):\n    \"\"\"Calculate a measure over time for a single output directory,\n    and its uncertainty.\n\n    Parameters\n    ----------\n    dirname: str\n        Path to a model output directory.\n    time_func: function\n        Function which takes a :class:`Model` instance as a single argument,\n        and returns its time.\n    measure_func: function\n        Function which takes a :class:`Model` instance as a single argument,\n        and returns the measure of interest, and its uncertainty.\n\n    Returns\n    -------\n    ts: np.ndarray\n        Times.\n    measures: np.ndarray\n        Measures.\n    measure_errs: np.ndarray\n        Measure uncertainties.\n    \"\"\"\n    ts, measures, measure_errs = [], [], []\n    for fname in get_filenames(dirname):\n        m = filename_to_model(fname)\n        ts.append(time_func(m))\n        meas, meas_err = measure_func(m)\n        measures.append(meas)\n        measure_errs.append(meas_err)\n    return np.array(ts), np.array(measures), np.array(measure_errs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef group_by_key(dirnames, key):\n    groups = defaultdict(lambda: [])\n    for dirname in dirnames:\n        m = get_recent_model(dirname)\n        groups[m.__dict__[key]].append(dirname)\n    return dict(groups)", "response": "Groups a set of output directories according to a model parameter."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding an error to the MultiResult.", "response": "def _add_err(self, exinfo):\n        \"\"\"\n        Sets the error on this MultiResult. Will be ignored if an error is\n        already set.\n        :param exinfo: Return value from ``sys.exc_info()``\n        \"\"\"\n        if self._err:\n            return\n        self._err = exinfo\n        self.all_ok = False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _add_bad_rc(self, rc, result):\n        if not rc:\n            return\n\n        self.all_ok = False\n        if rc == C.LCB_KEY_ENOENT and self._quiet:\n            return\n\n        try:\n            raise pycbc_exc_lcb(rc)\n        except PyCBC.default_exception as e:\n            e.all_results = self\n            e.key = result.key\n            e.result = result\n            self._add_err(sys.exc_info())", "response": "Adds an error with a bad return code. Handles quiet logic\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _decr_remaining(self):\n        assert self._remaining > 0\n        self._remaining -= 1\n        if not self._remaining:\n            self._cdata = None\n            return True", "response": "Call when a result is received to decrement the remaining count\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nraising any deferred exceptions set via _add_err.", "response": "def _maybe_throw(self):\n        \"\"\"\n        Throw any deferred exceptions set via :meth:`_add_err`\n        \"\"\"\n        if self._err:\n            ex_cls, ex_obj, ex_bt = self._err\n            self._err = None\n            PyCBC.raise_helper(ex_cls, ex_obj, ex_bt)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nunwrap the single Result item.", "response": "def unwrap_single(self):\n        \"\"\"\n        Unwrap the single Result item. Call this from single-operation\n        methods to return the actual result\n        :return: The actual result\n        \"\"\"\n        try:\n            return next(self.itervalues())\n        except AttributeError:\n            return next(iter(self.values()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pearson_correlation(self):\n        x, y, dt = self.data\n        X, Y = np.array(x), np.array(y)\n        ''' Compute Pearson Correlation Coefficient. '''\n        # Normalise X and Y\n        X -= X.mean(0)\n        Y -= Y.mean(0)\n        # Standardise X and Y\n        X /= X.std(0)\n        Y /= Y.std(0)\n        # Compute mean product\n        return (np.mean(X*Y) ** 2) * 100", "response": "Compute Pearson Correlation Coefficient."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds a dictionary of IntervalTrees indexed by chrom from a BED file or a stream - like object.", "response": "def intervalTrees(reffh, scoreType=int, verbose=False):\n  \"\"\"\n  Build a dictionary of interval trees indexed by chrom from a BED stream or\n  file\n\n  :param reffh: This can be either a string, or a stream-like object. In the\n                former case, it is treated as a filename. The format of the\n                file/stream must be BED.\n  :param scoreType: The data type for scores (the fifth column) in the BED\n                    file.\n  :param verbose: output progress messages to sys.stderr if True\n  \"\"\"\n  if type(reffh).__name__ == \"str\":\n    fh = open(reffh)\n  else:\n    fh = reffh\n\n  # load all the regions and split them into lists for each chrom\n  elements = {}\n  if verbose and fh != sys.stdin:\n    totalLines = linesInFile(fh.name)\n    pind = ProgressIndicator(totalToDo=totalLines,\n                             messagePrefix=\"completed\",\n                             messageSuffix=\"of loading \" + fh.name)\n  for element in BEDIterator(fh, scoreType=scoreType, verbose=verbose):\n    if element.chrom not in elements:\n      elements[element.chrom] = []\n    elements[element.chrom].append(element)\n    if verbose and fh != sys.stdin:\n      pind.done += 1\n      pind.showProgress()\n\n  # create an interval tree for each list\n  trees = {}\n  if verbose:\n    totalLines = len(elements)\n    pind = ProgressIndicator(totalToDo=totalLines,\n                             messagePrefix=\"completed\",\n                             messageSuffix=\"of making interval trees\")\n  for chrom in elements:\n    trees[chrom] = IntervalTree(elements[chrom], openEnded=True)\n    if verbose:\n      pind.done += 1\n      pind.showProgress()\n\n  return trees"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning an iterator for a BED file.", "response": "def BEDIterator(filehandle, sortedby=None, verbose=False, scoreType=int,\n                dropAfter=None):\n  \"\"\"\n  Get an iterator for a BED file\n\n  :param filehandle: this can be either a string, or a stream-like object. In\n                     the former case, it is treated as a filename. The format\n                     of the file/stream must be BED.\n  :param sortedby: if None, order is not checked.\n                   if == ITERATOR_SORTED_START, elements in file must\n                   be sorted by chrom and start index (an exception\n                   is raised if they are not)\n                   if == ITERATOR_SORTED_END, element must be sorted\n                   by chrom and end index.\n  :param verbose: if True, output additional progress messages to stderr\n  :param scoreType: The data type for scores (the fifth column) in the BED\n                    file.\n  :param dropAfter: an int indicating that any fields after and including this\n                    field should be ignored as they don't conform to the BED\n                    format. By default, None, meaning we use all fields. Index\n                    from zero.\n  :return: iterator where subsequent calls to next() yield the next BED\n           element in the stream as a GenomicInterval object.\n  \"\"\"\n  chromsSeen = set()\n  prev = None\n  if type(filehandle).__name__ == \"str\":\n    filehandle = open(filehandle)\n\n  if verbose:\n    try:\n      pind = ProgressIndicator(totalToDo=os.path.getsize(filehandle.name),\n                               messagePrefix=\"completed\",\n                               messageSuffix=\"of processing \" +\n                                             filehandle.name)\n    except (AttributeError, OSError) as e:\n      sys.stderr.write(\"BEDIterator -- warning: \" +\n                       \"unable to show progress for stream\")\n      verbose = False\n\n  for line in filehandle:\n    if verbose:\n      pind.done = filehandle.tell()\n      pind.showProgress()\n\n    if line.strip() == \"\":\n      continue\n    try:\n      e = parseBEDString(line, scoreType, dropAfter=dropAfter)\n    except GenomicIntervalError as e:\n      raise BEDError(str(e) + \" on line \" + line)\n\n    # sorting by name?\n    if ((sortedby == ITERATOR_SORTED_NAME and prev is not None) and\n       (prev.name > e.name)):\n      raise BEDError(\"bed file \" + filehandle.name +\n                     \" not sorted by element name\" +\n                     \" found \" + e.name + \" after \" +\n                     prev.name)\n\n    # first item\n    if prev is None:\n      chromsSeen.add(e.chrom)\n\n    # on same chrom as the prev item, make sure order is right\n    if prev is not None and sortedby is not None and e.chrom == prev.chrom:\n      if sortedby == ITERATOR_SORTED_START and prev.start > e.start:\n        raise BEDError(\"bed file \" + filehandle.name +\n                       \" not sorted by start index - saw item \" +\n                       str(prev) + \" before \" + str(e))\n      if sortedby == ITERATOR_SORTED_END and prev.end > e.end:\n        raise BEDError(\"bed file \" + filehandle.name +\n                       \" not sorted by end index - saw item \" +\n                       str(prev) + \" before \" + str(e))\n\n    # starting a new chrom.. make sure we haven't already seen it\n    if prev is not None and prev.chrom != e.chrom:\n      if (sortedby == ITERATOR_SORTED_START or\n          sortedby == ITERATOR_SORTED_END or\n          sortedby == ITERATOR_SORTED_CHROM) and\\\n         (e.chrom in chromsSeen or prev.chrom > e.chrom):\n        try:\n          e_fn = filehandle.name\n        except AttributeError:\n          e_fn = \"UNNAMED STREAM\"\n        raise BEDError(\"BED file \" + e_fn + \" not sorted by chrom\")\n      chromsSeen.add(e.chrom)\n\n    # all good..\n    yield e\n    prev = e"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pairedBEDIterator(inputStreams, mirror=False, mirrorScore=None,\n                      ignoreStrand=False, ignoreScore=True, ignoreName=True,\n                      sortedby=ITERATOR_SORTED_END, scoreType=float,\n                      verbose=False):\n  \"\"\"\n  Iterate over multiple BED format files simultaneously and yield lists of\n  genomic intervals for each matching set of intervals found. By default,\n  regions which are not found in all files will be skipped (mirror = false).\n  Optionally (by setting mirror to true) if a file is missing an interval,\n  it can be added on-the-fly, and will have the same chrom, start and end and\n  name as in other files. The score will be taken from the first file in\n  inputStreams if mirrorScore is not set, otherwise that value will be used.\n\n  :param inputStreams: a list of input streams in BED format\n  :param mirror: if true, add missing elements so all streams contain the\n                 same elements. Inserted elements will have the same\n  :param ignoreStrand: ignore strand when comparing elements for equality?\n  :param ignoreScore: ignore score when comparing elements for equality?\n  :param ignoreScore: ignore name when comparing elements for equality?\n  :param sortedby: must be set to one of the sorting orders for BED streams;\n                   we require the streams to be sorted in some fashion.\n  :param scoreType: interpret scores as what type? Defaults to float, which\n                    is generally the most flexible.\n  \"\"\"\n\n  # let's build our sorting order...\n  sortOrder = [\"chrom\"]\n  if sortedby == ITERATOR_SORTED_START:\n    sortOrder.append(\"start\")\n    sortOrder.append(\"end\")\n  elif sortedby == ITERATOR_SORTED_END:\n    sortOrder.append(\"end\")\n    sortOrder.append(\"start\")\n  if not ignoreStrand:\n    sortOrder.append(\"strand\")\n  if not ignoreName:\n    sortOrder.append(\"name\")\n  if not ignoreScore:\n    sortOrder.append(\"score\")\n  keyFunc = attrgetter(*sortOrder)\n\n  def next_item(iterator):\n    \"\"\" little internal function to return the next item, or None \"\"\"\n    try:\n      return iterator.next()\n    except StopIteration:\n      return None\n\n  bIterators = [BEDIterator(bfh, verbose=verbose,\n                            sortedby=sortedby,\n                            scoreType=scoreType) for bfh in inputStreams]\n  elements = [next_item(it) for it in bIterators]\n\n  while True:\n    assert(len(elements) >= 2)\n    if None not in elements and len(set([keyFunc(x) for x in elements])) == 1:\n      # All equal -- yield and move on for all streams\n      yield [e for e in elements]\n      elements = [next_item(it) for it in bIterators]\n    else:\n      # something wasn't equal.. find the smallest thing, it's about to drop\n      # out of range and will never have the chance to match anything again\n      minElement = min([x for x in elements if x is not None], key=keyFunc)\n      minIndices = [i for i in range(0, len(elements))\n                    if elements[i] is not None and\n                    keyFunc(elements[i]) == keyFunc(minElement)]\n      if mirror:\n        # mirror the min item for any streams in which it doesn't match\n        score = minElement.score if mirrorScore is None else mirrorScore\n        yield [elements[i] if i in minIndices\n               else GenomicInterval(minElement.chrom, minElement.start,\n                                    minElement.end, minElement.name,\n                                    score, minElement.strand,\n                                    scoreType=scoreType)\n               for i in range(0, len(elements))]\n\n      # move the smallest element onwards now, we're done with it\n      for index in minIndices:\n        elements[index] = next_item(bIterators[index])\n\n    # stop once all streams are exhausted\n    if reduce(lambda x, y: x and y, [e is None for e in elements]):\n      break", "response": "Iterate over multiple BED files simultaneously and yield genomic intervals."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_forum_votes(sender, **kwargs):\r\n    vote = kwargs['instance']\r\n    if vote.content_type.app_label != \"fretboard\":\r\n        return\r\n    if vote.content_type.model == \"topic\":\r\n        t = get_model('fretboard', 'Topic').objects.get(id=vote.object.id)\r\n        t.votes = t.score()\r\n        t.save(update_fields=['votes'])\r\n    elif vote.content_type.model == \"post\":\r\n        p = get_model('fretboard', 'Post').objects.get(id=vote.object.id)\r\n        p.votes = p.score()\r\n        p.save(update_fields=['votes'])", "response": "Updates the vote count for a forum."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nactivating the connection object and returns the SSHClient object.", "response": "def _connect_uncached(self):\n        ''' activates the connection object '''\n\n        if not HAVE_PARAMIKO:\n            raise errors.AnsibleError(\"paramiko is not installed\")\n\n        user = self.runner.remote_user\n\n        vvv(\"ESTABLISH CONNECTION FOR USER: %s on PORT %s TO %s\" % (user, self.port, self.host), host=self.host)\n\n        ssh = paramiko.SSHClient()\n        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\n        allow_agent = True\n        if self.runner.remote_pass is not None:\n            allow_agent = False\n        try:\n            private_key = None\n            key_filename = None\n            \n            if self.runner.private_key:\n                private_key = paramiko.RSAKey.from_private_key(StringIO.StringIO(self.runner.private_key))                          \n            \n            if self.runner.private_key_file:\n                key_filename = os.path.expanduser(self.runner.private_key_file)\n                \n            \n            ssh.connect(self.host, username=user, allow_agent=allow_agent, look_for_keys=True,\n                key_filename=key_filename, pkey=private_key,\n                password=self.runner.remote_pass,\n                timeout=self.runner.timeout, port=self.port)\n        except Exception, e:\n            msg = str(e)\n            if \"PID check failed\" in msg:\n                raise errors.AnsibleError(\"paramiko version issue, please upgrade paramiko on the machine running ansible\")\n            elif \"Private key file is encrypted\" in msg:\n                msg = 'ssh %s@%s:%s : %s\\nTo connect as a different user, use -u <username>.' % (\n                    user, self.host, self.port, msg)\n                raise errors.AnsibleConnectionFailed(msg)\n            else:\n                raise errors.AnsibleConnectionFailed(msg)\n\n        return ssh"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun a command on the remote host", "response": "def exec_command(self, cmd, tmp_path, sudo_user, sudoable=False, executable='/bin/sh'):\n        ''' run a command on the remote host '''\n\n        bufsize = 4096\n        try:\n            chan = self.ssh.get_transport().open_session()\n        except Exception, e:\n            msg = \"Failed to open session\"\n            if len(str(e)) > 0:\n                msg += \": %s\" % str(e)\n            raise errors.AnsibleConnectionFailed(msg)\n        chan.get_pty()\n\n        if not self.runner.sudo or not sudoable:\n            if executable:\n                quoted_command = executable + ' -c ' + pipes.quote(cmd)\n            else:\n                quoted_command = cmd\n            vvv(\"EXEC %s\" % quoted_command, host=self.host)\n            chan.exec_command(quoted_command)\n        else:\n            shcmd, prompt = utils.make_sudo_cmd(sudo_user, executable, cmd)\n            vvv(\"EXEC %s\" % shcmd, host=self.host)\n            sudo_output = ''\n            try:\n                chan.exec_command(shcmd)\n                if self.runner.sudo_pass:\n                    while not sudo_output.endswith(prompt):\n                        chunk = chan.recv(bufsize)\n                        if not chunk:\n                            if 'unknown user' in sudo_output:\n                                raise errors.AnsibleError(\n                                    'user %s does not exist' % sudo_user)\n                            else:\n                                raise errors.AnsibleError('ssh connection ' +\n                                    'closed waiting for password prompt')\n                        sudo_output += chunk\n                    chan.sendall(self.runner.sudo_pass + '\\n')\n            except socket.timeout:\n                raise errors.AnsibleError('ssh timed out waiting for sudo.\\n' + sudo_output)\n\n        stdout = ''.join(chan.makefile('rb', bufsize))\n        stderr = ''.join(chan.makefile_stderr('rb', bufsize))\n        return (chan.recv_exit_status(), '', stdout, stderr)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntransfer a file from local to remote", "response": "def put_file(self, in_path, out_path):\n        ''' transfer a file from local to remote '''\n        vvv(\"PUT %s TO %s\" % (in_path, out_path), host=self.host)\n        if not os.path.exists(in_path):\n            raise errors.AnsibleFileNotFound(\"file or module does not exist: %s\" % in_path)\n        try:\n            self.sftp = self.ssh.open_sftp()\n        except:\n            raise errors.AnsibleError(\"failed to open a SFTP connection\")\n        try:\n            self.sftp.put(in_path, out_path)\n        except IOError:\n            raise errors.AnsibleError(\"failed to transfer file to %s\" % out_path)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching a remote file to the specified path", "response": "def fetch_file(self, in_path, out_path):\n        ''' save a remote file to the specified path '''\n        vvv(\"FETCH %s TO %s\" % (in_path, out_path), host=self.host)\n        try:\n            self.sftp = self._connect_sftp()\n        except:\n            raise errors.AnsibleError(\"failed to open a SFTP connection\")\n        try:\n            self.sftp.get(in_path, out_path)\n        except IOError:\n            raise errors.AnsibleError(\"failed to transfer file from %s\" % in_path)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse(self, line=None):\n        args = self.parser.parse_args(args=line)\n        return args.func(args)", "response": "parses the line provided uses sys. argv"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndumping the memory data into a string.", "response": "def dump(data):\n    \"\"\"\n    Dump the memory data, e.g.:\n    \n    00 cc 30 31 30 30 72 30 05 80 20 c0 92 00 31 36         ..0100r0.. ...16\n    38 39 39 30 30 31 31 32 33 34 35 36 37 38 39 30         8990011234567890\n    30 30 30 30 30 30 30 30 30 30 30 30 30 32 30 30         0000000000000200\n    30 30 31 34 39 34 35 30 34 34 39 34 38 30 30 32         0014945044948002\n    33 31 31 37 30 35 31 31 31 32 30 38 31 34 39 30         3117051112081490\n    30 31 30 30 30 30 33 32 38 39 39 30 30 31 31 32         0100003289900112\n    33 34 35 36 37 38 39 30 44 31 38 30 39 32 30 31         34567890D1809201\n    31 38 37 32 33 30 30 30 31 30 30 30 31 33 33 37         1872300010001337\n    39 39 39 39 39 39 39 39 39 39 39 39 30 30 31 36         9999999999990016\n    34 33 2b 68 7a ef c3 4b 1a 89 30 34 39 82 02 00         43+hz..K..049...\n    00 9a 03 17 05 11 95 05 00 00 04 08 80 9f 10 02         ................\n    00 00 9f 26 08 ed 2c d0 d2 98 94 fb aa 9f 36 02         ...&..,.......6.\n    00 01 9f 37 04 8f a4 f2 bd 9f 1a 02 06 43               ...7.........C\n    \"\"\"\n\n    i = 1\n\n    if( isinstance(data, bytes) == False ):\n        raise TypeError('tracetools.dump(): data is expected to be bytes, not {}'.format(type(data)))\n\n    dump = '\\t'\n    dump_ascii = ''\n    padding = '        '\n    \n    for c in data:\n        try: # python 3\n            dump += '{:02x} '.format(c) \n            if chr(c) >= ' ' and chr(c) < '~':\n                dump_ascii += chr(c)\n            else:\n                dump_ascii += '.'\n                \n        except: # python 2.x\n            dump += '{:02x} '.format(ord(c))\n            if c >= ' ' and c < '~':\n                dump_ascii += c\n            else:\n                dump_ascii += '.'\n\n        if(i % 16 == 0):\n            dump = dump + padding + dump_ascii + '\\n\\t'\n            dump_ascii = ''\n        i+=1\n\n    if dump_ascii:\n        for i in range(16 - len(dump_ascii)):\n            padding += '   '\n        dump = dump + padding + dump_ascii + '\\n\\t'\n\n    return dump"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef trace(data, title=None):\n    if title:\n        print('{} {}\\n{}'.format(get_timestamp(), title, dump(data)))\n    else:\n        print('{}\\n{}'.format(get_timestamp(), dump(data)))", "response": "Trace the binary data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading input from the server and return a list of images.", "response": "def interpret(self, msg):\n        \"\"\" Load input \"\"\"\n        slides = msg.get('slides', [])\n\n        result = []\n        for slide in slides:\n            image = self.layout(slide)\n\n            result.append(image)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning layout information for slide", "response": "def layout(self, slide):\n        \"\"\" Return layout information for slide \"\"\"\n\n        image = Image.new('RGB', (WIDTH, HEIGHT), 'black')\n        draw = ImageDraw.Draw(image)\n        draw.font = self.font\n        \n        self.vertical_layout(draw, slide)\n        \n        self.horizontal_layout(draw, slide)\n\n        return slide"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\naugments a slide with vertical layout info.", "response": "def vertical_layout(self, draw, slide):\n        \"\"\" Augment slide with vertical layout info \"\"\"\n        padding = self.padding\n        heading = slide['heading']\n\n        width, height = draw.textsize(heading['text'])\n        top = padding\n        left = padding\n\n        # Calculate size and location of heading\n        heading.update(dict(\n            width = width,\n            height = height,\n            top = self.padding,\n            left = self.padding))\n\n        top += height + padding\n\n        # count how many rows just text and how many have image\n        rows = slide['rows']\n        text_rows = 0\n        image_rows = 0\n\n        # calculate size of all text objects\n        total_height = top\n        for row in rows:\n\n            row_height = 0\n\n            images = 0\n            for item in row['items']:\n                if item.get('image'):\n                    images += 1\n\n                text = item.get('text')\n                \n                if text is None: continue\n                    \n                width, height = draw.textsize(text)\n\n                item.update(dict(\n                    width = width,\n                    height = height))\n\n                row_height = max(row_height, height)\n                \n\n            if images:\n                image_rows += 1\n                row['images'] = images\n            else:\n                row['height'] = row_height\n                text_rows += 1\n\n            total_height += row_height + padding\n                \n        # Calculate average height for image rows\n        if image_rows:\n            \n            available = HEIGHT - total_height\n\n            image_height = available // image_rows\n\n            image_text_offset = image_height // 2\n\n        # now spin through rows again setting top\n        # (and height for images)\n        for row in rows:\n            text_top = top\n            \n            images = row.get('images', 0)\n            if images:\n                text_top += image_text_offset\n\n            for item in row['items']:\n                if item.get('text') is not None:\n                    item['top'] = text_top\n                else:\n                    # image\n                    item['top'] = top\n                    item['height'] = image_height\n                    row['height'] = image_height\n\n            \n            top += row.get('height', 0) + padding\n\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef horizontal_layout(self, draw, slide):\n        padding = self.padding\n        heading = slide['heading']\n\n        top = padding\n        left = padding\n\n        top += heading['height'] + padding\n\n        rows = slide['rows']\n\n        for row in rows:\n\n            images = row.get('images', 0)\n\n            items = row['items']\n            \n            used_width = sum(x.get('width', 0) for x in items)\n\n            available_width = WIDTH - (\n                used_width + ((1 + len(items)) * padding))\n\n            if images:\n                image_width = available_width // images\n\n            # OK, now set left for all items and image_width for images\n            left = padding\n            for item in row['items']:\n\n                if item.get('image'):\n                    item['width'] = image_width\n\n                item['left'] = left    \n\n                left += item['width'] + padding\n\n        return", "response": "Augment slide with horizontal layout info"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _mk_imp_override(srcname, replacement):\n    class DummyImporter(object):\n        def find_module(self, fullname, path):\n            if fullname == srcname:\n                return self\n\n            return None\n\n        def load_module(self, fullname):\n            if fullname != srcname:\n                raise ImportError\n            sys.modules[fullname] = replacement\n            return replacement\n\n    obj = DummyImporter()\n    sys.meta_path.append(obj)", "response": "Create a simple one for one replacement for a module\n   ."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef special_target_typecheck(value):\n    result = True\n    # if key:Optional exists, it must be a dict object\n    result &= isinstance(value.get(TARGET_OPTIONAL_FIELD, dict()), dict)\n    return result", "response": "Checks if the target object is a dict."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a dictionary into a proto object.", "response": "def converts_to_proto(value, msg, raise_err=False):\n    \"\"\"\n    Boolean response if a dictionary can convert into the proto's schema\n\n    :param value: <dict>\n    :param msg: <proto object>\n    :param raise_err: <bool> (default false) raise for troubleshooting\n    :return: <bool> whether the dict can covert\n    \"\"\"\n    result = True\n    try:\n        dict_to_protobuf.dict_to_protobuf(value, msg)\n    except TypeError as type_error:\n        if raise_err:\n            raise type_error\n        result = False\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a boolean response if a message contains correct information to serialize .", "response": "def successfuly_encodes(msg, raise_err=False):\n    \"\"\"\n    boolean response if a message contains correct information to serialize\n\n    :param msg: <proto object>\n    :param raise_err: <bool>\n    :return: <bool>\n    \"\"\"\n    result = True\n    try:\n        msg.SerializeToString()\n    except EncodeError as encode_error:\n        if raise_err:\n            raise encode_error\n        result = False\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstripping all non - essential keys from the value dictionary with arbitrary keys", "response": "def strip(value, msg):\n    \"\"\"\n    Strips all non-essential keys from the value dictionary\n    given the message format protobuf\n\n    raises ValueError exception if value does not have all required keys\n\n    :param value: <dict> with arbitrary keys\n    :param msg: <protobuf> with a defined schema\n    :return: NEW <dict> with keys defined by msg, omits any other key\n    \"\"\"\n    dict_to_protobuf.dict_to_protobuf(value, msg)\n    try:\n        msg.SerializeToString()  #raise error for insufficient input\n    except EncodeError as encode_error:\n        raise ValueError(str(encode_error))\n    output = dict_to_protobuf.protobuf_to_dict(msg)\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn an svg object.", "response": "def svg(*args, **kw):\n    \"\"\"\n    Use in this way:\n    \n    \u00b4from remarkuple import helper as h, svg\u00b4\n    \n    \"\"\"\n    class svg(type(helper.svg())):\n        \n        def __init__(self, *args, **kw):\n            super(self.__class__, self).__init__(*args, **kw)\n            # cartesian grid on/off\n            self.__dict__['grid'] = False\n            # axes on/off\n            self.__dict__['axes'] = False\n            # show origin\n            self.__dict__['origin'] = False\n            # grid aspects\n            self.__dict__['grid_aspects'] = (4, 8)\n            # x\n            self.__dict__['x'] = 200\n            # y\n            self.__dict__['y'] = 200\n            # elements\n            self.__dict__['elements'] = []\n            # size of the svg canvas, width and height\n            self.__dict__['size'] = (100, 100)\n            # grid id\n            self.__dict__['grid_id'] = \"gid%s\" % id(self)\n            # grid item id\n            self.__dict__['grid_item_id'] = \"gitem%s\" % id(self)\n            # grid width\n            width = kw['width'] if kw.has_key('width') else self.__dict__['x']*2\n            # grid height\n            height = kw['height'] if kw.has_key('height') else self.__dict__['y']*2\n            self.set_size(width, height)\n        \n        def set_grid(self, grid = True):\n            self.__dict__['grid'] = grid\n            return self\n        \n        def set_axes(self, axes = True):\n            self.__dict__['axes'] = axes\n            return self\n        \n        def set_origin(self, origin = True):\n            self.__dict__['origin'] = origin\n            return self\n        \n        def set_size(self, width, height):\n            self.__dict__['x'] = width/2\n            self.__dict__['y'] = height/2\n            self.__dict__['size'] = (width, height)\n            self.width = width\n            self.height = height\n            self.viewbox = \"0 0 %s %s\" % (width+1, height+1)\n            return self\n        \n        def set_text(self, *args, **kw):\n            kw['x'] = self.__dict__['x']+kw['x'] if kw.has_key('x') else self.__dict__['x'] \n            kw['y'] = self.__dict__['y']-kw['y'] if kw.has_key('y') else self.__dict__['y']\n            self.__dict__['elements'].append(helper.text(*args, **kw))\n            return self\n        \n        def set_rectangle(self, *args, **kw):\n            kw['x'] = self.__dict__['x']+kw['x'] if kw.has_key('x') else self.__dict__['x']\n            kw['y'] = self.__dict__['y']-kw['y'] if kw.has_key('y') else self.__dict__['y']\n            self.__dict__['elements'].append(helper.rect(*args, **kw))\n            return self\n        \n        def set_group(self, *args, **kw):\n            self.__dict__['elements'].append(helper.g(*args, **kw))\n            return self\n        \n        def set_defs(self, *args, **kw):\n            self.__dict__['elements'].append(helper.defs(*args, **kw))\n            return self\n        \n        def set_line(self, *args, **kw):\n            kw['x1'] = self.__dict__['x']+kw['x1'] if kw.has_key('x1') else self.__dict__['x']\n            kw['y1'] = self.__dict__['y']-kw['y1'] if kw.has_key('y1') else self.__dict__['y']\n            kw['x2'] = self.__dict__['x']+kw['x2'] if kw.has_key('x2') else self.__dict__['x'] + 10\n            kw['y2'] = self.__dict__['y']-kw['y2'] if kw.has_key('y2') else self.__dict__['y'] + 10\n            self.__dict__['elements'].append(helper.line(*args, **kw))\n            return self\n        \n        def set_circle(self, *args, **kw):\n            kw['cx'] = self.__dict__['x']+kw['cx'] if kw.has_key('cx') else self.__dict__['x']\n            kw['cy'] = self.__dict__['y']-kw['cy'] if kw.has_key('cy') else self.__dict__['y']\n            self.__dict__['elements'].append(helper.circle(*args, **kw))\n            return self\n        \n        def set_triangle(self, *args, **kw):\n            kw['sides'] = 3\n            return self.set_regular_polygon(*args, **kw)\n        \n        def set_square(self, *args, **kw):\n            kw['sides'] = 4\n            return self.set_regular_polygon(*args, **kw)\n        \n        def set_pentagon(self, *args, **kw):\n            kw['sides'] = 5\n            return self.set_regular_polygon(*args, **kw)\n        \n        def set_hexagon(self, *args, **kw):\n            kw['sides'] = 6\n            return self.set_regular_polygon(*args, **kw)\n        \n        def set_regular_polygon(self, *args, **kw):\n            # set default properties for vertex\n            kw['cx'] = kw['cx']+self.__dict__['x'] if kw.has_key('cx') else self.__dict__['x']\n            kw['cy'] = kw['cy']-self.__dict__['y'] if kw.has_key('cy') else self.__dict__['y']\n            kw['radius'] = kw['radius'] if kw.has_key('radius') else 1\n            kw['sides'] = kw['sides'] if kw.has_key('sides') else 4\n            kw['degrees'] = kw['degrees'] if kw.has_key('degrees') else 0\n            # set generate polygon points\n            points = self.polygon_points(self.vertex(cx=kw['cx'],\n                                                     cy=kw['cy'],\n                                                     radius=kw['radius'],\n                                                     sides=kw['sides'],\n                                                     degrees=kw['degrees']))\n            # delete default properties\n            del kw['cx']\n            del kw['cy']\n            del kw['radius']\n            del kw['sides']\n            del kw['degrees']\n            # create polygon with given points and keywords\n            self.__dict__['elements'].append(helper.polygon(points=points, *args, **kw))\n            return self\n        \n        def polygon_points(self, vertex):\n            return ' '.join(['%s,%s' % (point[0], point[1]) for point in vertex])\n        \n        def vertex(self, cx = 0, cy = 0, sides = 4, radius = 1, degrees = 0):\n            centerAng = 2*pi/sides\n            startAng = pi*degrees/180\n            points = []\n            for i in range(0, sides):\n                ang = startAng + (i*centerAng);\n                x = round(cx + radius*cos(ang), 2)\n                y = round(cy - radius*sin(ang), 2)\n                points.append([x,y])\n            return points\n        \n        def _set_grid(self):\n            \"\"\" Set up background grid for drawing canvas \"\"\"\n            grid_sizex = self.__dict__['size'][0]/self.__dict__['grid_aspects'][0]\n            grid_sizey = self.__dict__['size'][1]/self.__dict__['grid_aspects'][0]\n            \n            sizex = grid_sizex*(1.0/self.__dict__['grid_aspects'][1])\n            sizey = grid_sizey*(1.0/self.__dict__['grid_aspects'][1])\n            \n            defs = helper.defs()\n            defs += helper.pattern(helper.path(**{'d': 'M %s 0 L 0 0 0 %s' % (sizex, sizey), 'fill': 'none', 'stroke': 'gray', 'stroke-width': 0.5}),\n                                   **{'id': self.__dict__['grid_item_id'], 'width': sizex, 'height': sizey, 'patternUnits': 'userSpaceOnUse'})\n            defs += helper.pattern(helper.path(**{'d': 'M %s 0 L 0 0 0 %s' % (grid_sizex, grid_sizey), 'fill': 'none', 'stroke': 'gray', 'stroke-width': 1}),\n                                   helper.rect(width=grid_sizex, height=grid_sizey, fill=\"url(#%s)\" % self.__dict__['grid_item_id']),\n                                   **{'id': self.__dict__['grid_id'], 'width': grid_sizex, 'height': grid_sizey, 'patternUnits': 'userSpaceOnUse'})\n            self += defs\n            self += helper.rect(fill=\"white\", height=self.__dict__['size'][0]+1, width=self.__dict__['size'][1]+1)\n            self += helper.rect(fill=\"url(#%s)\" % self.__dict__['grid_id'], height=self.__dict__['size'][0]+1, width=self.__dict__['size'][1]+1)\n            \n        def _set_axes(self):\n            \"\"\" Set up x and y axis for drawing canvas \"\"\"\n            self += helper.line(stroke=\"black\", x1=self.__dict__['x'], x2=self.__dict__['x'], y1=0, y2=self.__dict__['y']*2)\n            self += helper.line(stroke=\"black\", x1=0, x2=self.__dict__['x']*2, y1=self.__dict__['y'], y2=self.__dict__['y'])\n        \n        def _set_origin(self):\n            \"\"\" Set up origin dot and x/y coordinates for drawing canvas \"\"\"\n            self += helper.circle(cx=self.__dict__['x'], cy=self.__dict__['y'], r=2, fill=\"black\", stroke=\"black\", style=\"fill-opacity: 50%\")\n            self += helper.text(\"(0,0)\", x=self.__dict__['x']+5, y=self.__dict__['y']-5, style=\"fill-opacity: 50%\")\n        \n        def __str__(self):\n            if self.__dict__['grid']:\n                self._set_grid()\n            if self.__dict__['axes']:\n                self._set_axes()\n            if self.__dict__['origin']:\n                self._set_origin()\n            if self.__dict__['elements']:\n                for element in self.__dict__['elements']:\n                    self += element\n            return super(self.__class__, self).__str__()\n    \n    return svg(*args, **kw)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a string with a German number into a Decimal object.", "response": "def clean_german_number(x):\n    \"\"\"Convert a string with a German number into a Decimal\n\n    Parameters\n    ----------\n    x : str, list, tuple, numpy.ndarray, pandas.DataFrame\n        A string with a number with German formatting,\n        or an array of these strings, e.g. list, ndarray, df.\n\n    Returns\n    -------\n    y : str, list, tuple, numpy.ndarray, pandas.DataFrame\n        A string or array of strings that can be converted\n        to a numeric data type (e.g. Decimal, float, int).\n\n    Example\n    -------\n    The function aims to convert a string as follows\n\n        '1.234'     => '1234'\n        '1234'      => '1234'\n        '1.234,56'  => '1234.56'\n        '1.234.560' => '1234560'\n        '+123'      => '123'\n        '-123'      => '-123'\n\n    Code Example\n    ------------\n        print(clean_german_number('1.234,56'))\n        '1234.56'\n\n\n    Behavior\n    --------\n    - The function will return None if the element is not a string\n    - The function assumes that provided string are German numbers.\n    - There will NO check if it is a regular number.\n    - No conversion to a numeric data type (have to be done afterwards)\n\n    Notes\n    -----\n    The command `x.dropna().apply(proc_elem)` is not working for\n    pandas dataframes. Maybe the `proc_elem` sub function is too big\n    or complex for pandas' apply method.\n\n    \"\"\"\n    import numpy as np\n    import pandas as pd\n    import re\n\n    def proc_elem(e):\n        # abort if it is not a string\n        if not isinstance(e, str):\n            return None\n\n        # strip all char except digits, \".\", \",\" and \"-\"\n        s = re.sub('[^0-9\\.\\,\\-]+', '', e)\n\n        # abort if nothing is left\n        if len(s) is 0:\n            return None\n\n        # extra check regarding \"-\" modifier\n        m = \"\"\n        if s[0] is \"-\":\n            if len(s) > 1:\n                m = \"-\"\n                s = s[1:]\n            else:\n                return None\n\n        # remove the \"-\" from the string\n        s = re.sub('[^0-9\\.\\,]+', '', s)\n\n        # abort if nothing is left\n        if len(s) is 0:\n            return None\n\n        # abort if the number of \",\" (decimal sep) is bigger than 1\n        if s.count(',') > 1:\n            return None\n\n        # about if the decimal sep \",\" occurs before a 000' sep \".\"\n        if s.count('.') > 0 and s.count(',') > 0:\n            rev = s[::-1]\n            if rev.find(\",\") > rev.find(\".\"):\n                return None\n\n        # remove 000' seperators \".\"\n        s = s.replace('.', '')\n\n        # convert comma to dot\n        s = s.replace(',', '.')\n\n        # if just a dot is left \".\"\n        if s == \".\":\n            return None\n\n        # reattach the \"-\" modifier\n        return m + s\n\n    def proc_list(x):\n        return [proc_elem(e) for e in x]\n\n    def proc_ndarray(x):\n        tmp = proc_list(list(x.reshape((x.size,))))\n        return np.array(tmp).reshape(x.shape)\n\n    # transform string, list/tuple, numpy array, pandas dataframe\n    if isinstance(x, str):\n        return proc_elem(x)\n    elif isinstance(x, (list, tuple)):\n        return proc_list(x)\n    elif isinstance(x, np.ndarray):\n        return proc_ndarray(x)\n    elif isinstance(x, pd.DataFrame):\n        return pd.DataFrame(proc_ndarray(x.values),\n                            columns=x.columns, index=x.index)\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rpc(method):\n    @wraps(method)\n    def rpc_wrapper(*args, **kwargs):\n        controller_instance = args[0]\n\n        if not isinstance(controller_instance, RemoteControllerDeamon):\n            raise Exception(\"'rpc' decorator must use in a RemoteControllerDeamon (-derived) class method!\")\n\n        # Decide the call origin: if the current pid is the daemon pid, this is server side,\n        # so call registered method. If not, start a jsonrpc request.\n        call_from_server = os.getpid() == controller_instance.get_pid()\n\n        logger.debug(\"Initiate RPC method '%s' in '%s'\", method.__name__, 'daemon' if call_from_server else 'cli')\n\n        if call_from_server:\n            return method(*args, **kwargs)\n        else:\n            url = \"http://{}:{}/jsonrpc\".format(controller_instance.host, controller_instance.port)\n            headers = {'content-type': 'application/json'}\n\n            payload = {\n                \"method\": method.__name__,\n                \"params\": kwargs,\n                \"jsonrpc\": \"2.0\",\n                \"id\": 0,\n            }\n            try:\n                response = requests.post(url, data=json.dumps(payload), headers=headers).json()\n                if 'result' in response:\n                    return response['result']\n                else:\n                    logger.error(\"There is an error during rpc call. Response:\\n%s\", json.dumps(response, indent=4))\n                    return \"Error: {}. (see logs for details)\".format(response['error']['message'])\n            except requests.exceptions.ConnectionError as e:\n                logger.error(\"Command server not runnning (%s), args: %s, kwargs: %s\", e, args, kwargs)\n                return None\n\n    rpc_wrapper.registered_for_rpc = method\n    return rpc_wrapper", "response": "Decorator for registering method for RPC."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning pylint on a package and returns a score", "response": "def score(package_path):\n    \"\"\"\n    Runs pylint on a package and returns a score\n    Lower score is better\n\n    :param package_path: path of the package to score\n    :return: number of score\n    \"\"\"\n    python_files = find_files(package_path, '*.py')\n\n    total_counter = Counter()\n\n    for python_file in python_files:\n        output = run_pylint(python_file)\n        counter = parse_pylint_output(output)\n        total_counter += counter\n\n    score_value = 0\n\n    for count, stat in enumerate(total_counter):\n        score_value += SCORING_VALUES[stat] * count\n\n    return score_value / 5"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse pylint output and returns a Counter object", "response": "def parse_pylint_output(output):\n    \"\"\"\n    Parses pylint output, counting number of errors, conventions, etc\n    :param output: output list generated by run_pylint()\n    :return:\n    \"\"\"\n\n    stripped_output = [x[0] for x in output]\n\n    counter = Counter(stripped_output)\n\n    return counter"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning pylint on a given file and returns a list of lines", "response": "def run_pylint(filename):\n    \"\"\"\n    Runs pylint on a given file\n    :param filename:\n    :return: list of pylint errors\n    \"\"\"\n    ARGS = [\n        '-r',\n        'n'\n    ]\n    pylint_output = WritableObject()\n    Run([filename]+ARGS, reporter=TextReporter(pylint_output), exit=False)\n\n    lines = []\n    for line in pylint_output.read():\n        if not line.startswith('*') and line != '\\n':\n            lines.append(line)\n\n    return lines"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_files(directory, pattern):\n    for root, __, files in os.walk(directory):\n        for basename in files:\n            if fnmatch.fnmatch(basename, pattern):\n                filename = os.path.join(root, basename)\n                yield filename", "response": "Recusively finds files in a directory and returns a generator with filenames matching pattern"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register(self, key: Any, factory: Callable[['Container'], Any],\n                 shared: bool = True) -> None:\n        \"\"\"\n        Registers a factory function for creating the class\n        :argument key name under which the dependencies will be\n        registered\n        :argument factory a function that receives the constructor as first\n        argument and is used to create the class\n        :argument shared if True, the factory result will be saved for reuse.\n        This means that the same instance will be returned once the same key\n        is requested again. If False requesting the same key will always return\n        a new instance. Autoresolved classes will always be shared\n        \"\"\"\n        if shared:\n            self._factories[key] = SingletonFactory(factory)\n        else:\n            self._factories[key] = Factory(factory)", "response": "Registers a factory function for creating the class with the given key."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resolve(self, key: Any) -> Any:\n        if key not in self._singletons:\n            # if registered, determine if the result will be shared\n            if key in self._factories:\n                factory = self._factories[key]\n                result = factory(self)\n                if isinstance(factory, SingletonFactory):\n                    self._singletons[key] = result\n                return result\n            # if not registered, try to automatically resolve it based on\n            # its annotations. Automatically resolved keys are always shared\n            elif isinstance(type(key), type):\n                result = self._resolve_class(key)\n                self._singletons[key] = result\n                return result\n            else:\n                msg = 'Unable to resolve factory for key %s' % key\n                raise ResolveException(msg)\n        else:\n            return self._singletons[key]", "response": "Fetches an instance or creates one using the registered factory method\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npoint a key to another keyset", "response": "def alias(self, source: type, target: Any) -> Any:\n        \"\"\"\n        Point a key to another key\n        :argument source the key to resolve when the target is requested\n        :argument target the name of the alias\n        \"\"\"\n        self.register(target, lambda c: c.resolve(source))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _resolve_class(self, clazz: Any) -> object:\n        arguments = {}\n        if hasattr(clazz.__init__, '__annotations__'):\n            annotations = clazz.__init__.__annotations__\n            for name, type_hint in annotations.items():\n                if name != 'return':\n                    arguments[name] = self.resolve(type_hint)\n        return clazz(**arguments)", "response": "Resolves the class with the given arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef discover(url, options={}):\n    try:\n        resp = requests.get(url, headers=Patchboard.default_headers)\n    except Exception as e:\n        raise PatchboardError(\"Problem discovering API: {0}\".format(e))\n\n    # Parse as JSON (Requests uses json.loads())\n    try:\n        api_spec = resp.json()\n    except ValueError as e:\n        raise PatchboardError(\"Unparseable API description: {0}\".format(e))\n\n    # Return core handle object\n    return Patchboard(api_spec, options)", "response": "Discover the API definition from the given URL and construct a Patchboard object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef spawn(self, context=None):\n        if context is None:\n            context = self.default_context\n\n        if isinstance(context, collections.Callable):\n            context = context()\n\n        if not isinstance(context, collections.Mapping):\n            raise PatchboardError('Cannot determine a valid context')\n\n        return Client(self, context, self.api, self.endpoint_classes)", "response": "Spawn a new client."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_version(form='short'):\n    versions = {}\n    branch = \"%s.%s\" % (VERSION[0], VERSION[1])\n    tertiary = VERSION[2]\n    type_ = VERSION[3]\n    type_num = VERSION[4]\n    \n    versions[\"branch\"] = branch\n    v = versions[\"branch\"]\n    if tertiary:\n        versions[\"tertiary\"] = \".\" + str(tertiary)\n        v += versions[\"tertiary\"]\n    versions['short'] = v\n    if form is \"short\":\n        return v\n    v += \" \" + type_ + \" \" + str(type_num)\n    versions[\"normal\"] = v\n    if form is \"normal\":\n        return v\n    v += \" @\" + git_sha()\n    versions[\"verbose\"] = v\n    if form is \"verbose\":\n        return v\n    if form is \"all\":\n        return versions", "response": "Returns the version string of the current version of the current branch."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _download_article(self, article_number, max_retries=10):\n        log.debug('downloading article {0} from {1}'.format(article_number, self.name))\n        _connection = self.session.connections.get()\n        try:\n            i = 0\n            while True:\n                if i >= max_retries:\n                    return False\n\n                try:\n                    _connection.group(self.name)\n                    resp = _connection.article(article_number)\n                    log.debug('downloaded article {0} from {1}'.format(article_number,\n                                                                       self.name))\n                    return resp\n\n                # Connection closed, transient error, retry forever.\n                except EOFError:\n                    log.warning('EOFError, refreshing connection retrying -- '\n                                'article={0}, group={1}'.format(article_number, self.name))\n                    self.session.refresh_connection(_connection)\n                    time.sleep(2)\n                    _connection = self.session.connections.get()\n\n                # NNTP Error.\n                except nntplib.NNTPError as exc:\n                    log.warning('NNTPError: {0} -- article={1}, '\n                                'group={2}'.format(exc, article_number, self.name))\n                    if any(s in exc.response for s in ['430', '423']):\n                        # Don't retry, article probably doesn't exist.\n                        i = max_retries\n                    else:\n                        i += 1\n                except:\n                    self.session.refresh_connection(_connection)\n                    time.sleep(2)\n                    _connection = self.session.connections.get()\n\n        # Always return connection back to the pool!\n        finally:\n            self.session.connections.put(_connection)", "response": "Download an article from the NNTP server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd an article to the index file.", "response": "def index_article(self, msg_str, article_number, start, length):\n        \"\"\"Add article to index file.\n\n        :type msg_str: str\n        :param msg_str: the message string to index.\n\n        :type article_number: str\n        :param article_number: the article number to index.\n\n        :type start: int\n        :param start: the byte-offset where a given message starts in the\n                      corresponding mbox file.\n\n        :type length: int\n        :param length: the byte-length of the message.\n\n        :rtype: bool\n        :returns: True\n\n        \"\"\"\n        f = cStringIO.StringIO(msg_str)\n        message = rfc822.Message(f)\n        f.close()\n\n        # Replace header dict None values with '', and any tabs or\n        # newlines with ' '.\n        h = dict()\n        for key in message.dict:\n            if not message.dict[key]:\n                h[key] = ''\n            h[key] = message.dict[key]\n            h[key] = utf8_encode_str(message.dict[key])\n            if '\\n' in h[key]:\n                h[key] = h[key].replace('\\n', ' ')\n            if '\\t' in h[key]:\n                h[key] = h[key].replace('\\t', ' ')\n\n        date = h.get('NNTP-Posting-Date')\n        if not date:\n            date = h.get('date', '')\n        date = get_utc_iso_date(date)\n\n        idx_line = (date, h.get('message-id'), h.get('from'), h.get('newsgroups'),\n                    h.get('subject'), h.get('references', ''), start, length)\n        idx_fname = '{name}.{date}.mbox.csv'.format(**self.__dict__)\n\n        s = cStringIO.StringIO()\n        writer = csv.writer(s, dialect='excel-tab')\n        writer.writerow(idx_line)\n        with self._idx_lock:\n            with open(idx_fname, 'a') as fp:\n                fp.write(s.getvalue())\n        s.close()\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compress_and_sort_index(self):\n        idx_fname = '{name}.{date}.mbox.csv'.format(**self.__dict__)\n        try:\n            reader = csv.reader(open(idx_fname), dialect='excel-tab')\n        except IOError:\n            return False\n        index = [x for x in reader if x]\n        sorted_index = sorted(index, key=itemgetter(0))\n        gzip_idx_fname = idx_fname + '.gz'\n\n        # Include UTF-8 BOM in header.\n        header = [\n            '\\xef\\xbb\\xbf#date', 'msg_id', 'from', 'newsgroups', 'subject', 'references',\n            'start', 'length',\n        ]\n\n        s = cStringIO.StringIO()\n        writer = csv.writer(s, dialect='excel-tab')\n        writer.writerow(header)\n        for line in sorted_index:\n            writer.writerow(line)\n        compressed_index = inline_compress_chunk(s.getvalue())\n        s.close()\n\n        with open(gzip_idx_fname, 'ab') as fp:\n            fp.write(compressed_index)\n        os.remove(idx_fname)\n        return True", "response": "Sort index add header and compress."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_device(self, word_device):\n\t\tif(self._lock):\n\t\t\traise BUSSetupError(\"BUS already locked.\")\n\t\tsize = word_device.size\n\t\tif(self.current_max_offset + size >= self.max_addr):\n\t\t\traise BUSSetupError(\"Addresspace({}) would exceed width of BUS({})\".format(self.current_max_offset+ size,\n\t\t\t\t\t\tself.width))\n\t\tself.start_addresses[word_device] = self.current_max_offset\n\t\tres = self.current_max_offset\n\t\tself.current_max_offset += size\n\t\tself.index[range(res, self.current_max_offset)] = word_device\n\t\tself.devices.append(word_device)\n\t\treturn res", "response": "_register_device registers the word_device in the bus and returns the start address of the device."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_word(self, offset, word):\n\t\tself._lock = True\n\t\tif(offset > self.current_max_offset):\n\t\t\traise BUSError(\"Offset({}) exceeds address space of BUS({})\".format(offset, self.current_max_offset)) \n\t\tself.writes += 1\n\t\t\n\t\tself.truncate.setvalue(word)\n\t\tfor addresspace, device in self.index.items():\n\t\t\tif(offset in addresspace):\n\t\t\t\tdevice.write(offset - self.start_addresses[device], self.truncate.getvalue())", "response": "Write a word from a device."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the value of the Integer.", "response": "def setvalue(self, value):\n\t\t\"\"\"\n\t\t.. _setvalue:\n\n\t\tSet the signed value of the Integer.\n\t\t\"\"\"\n\t\tself._value = abs(value)\n\t\tself._sign = 0\n\t\tif(value < 0):\n\t\t\tself._sign = 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write(self, offset, value):\n\t\tif(not self.mode & 0b10):\n\t\t\traise ReadOnlyError(\"Device is Read-Only\")\n\t\tif(offset >= self.size):\n\t\t\traise AddressError(\"Offset({}) not in address space({})\".format(offset, self.size))\n\t\tself.repr_[offset].setvalue(value)", "response": "_write writes the memory word at offset to value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save(self, data):\n        if not self.is_connected:\n            raise Exception(\"No database selected\")\n        if not data:\n            return False\n        if isinstance(data, dict):\n            doc = couchdb.Document()\n            doc.update(data)\n            self.db.create(doc)\n        elif isinstance(data, couchdb.Document):\n            self.db.update(data)\n        elif isinstance(data, list):\n            self.db.update(data)\n        return True", "response": "Save a document or list of documents"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nneeding to be admin", "response": "def win_register():\n    \"need to be admin\"\n    try:\n        with winreg.CreateKey(winreg.HKEY_CLASSES_ROOT, \"austere.HTTP\") as k:\n            # winreg.SetValue(k, None, winreg.REG_SZ,  \"{} austere\".format(sys.argv[0]))\n            logger.debug(\"\\shell\")\n            with winreg.CreateKey(k, \"shell\") as shellkey:\n                logger.debug(\"\\open\")\n                with winreg.CreateKey(shellkey, \"open\") as openkey:\n                    logger.debug(\"\\command\")\n                    with winreg.CreateKey(openkey, \"command\") as cmdkey:\n                        winreg.SetValue(cmdkey, None, winreg.REG_SZ,  '\"{} austere\" \"%1\"'.format(sys.argv[0]))\n        # with winreg.CreateKey(winreg.HKEY_CLASSES_ROOT, \"austere.HTTPS\") as kssl:\n        #     winreg.SetValue(kssl, None, winreg.REG_SZ,  \"{} austere\".format(sys.argv[0]))\n    except OSError as e:\n        logger.error(e)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_config(path=None, defaults=None):\n\n    if defaults is None:\n        defaults = DEFAULT_FILES\n\n    config = configparser.SafeConfigParser(allow_no_value=True)\n\n    if defaults:\n        config.read(defaults)\n\n    if path:\n        with open(path) as fh:\n            config.readfp(fh)\n\n    return config", "response": "Loads and parses an INI style configuration file using Python s built - in ConfigParser module."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads a value from a schema defined string.", "response": "def load_value_from_schema(v):\n    \"\"\"\n    Load a value from a schema defined string.\n    \"\"\"\n    x = urllib.parse.urlparse(v)\n\n    if x.scheme.lower() == 'decimal':\n        v = Decimal(x.netloc)\n    elif x.scheme.lower() in ['int', 'integer']:\n        v = int(x.netloc)\n    elif x.scheme.lower() == 'float':\n        v = float(x.netloc)\n    elif x.scheme.lower() in ['s', 'str', 'string']:\n        v = str(x.netloc)\n    elif x.scheme.lower() in ['u', 'unicode']:\n        v = six.u(x.netloc)\n    elif x.scheme.lower() == 'email':\n        v = six.u(x.netloc)\n    elif x.scheme.lower() == 'bool':\n        v = bool(x.netloc)\n    elif x.scheme.lower() in ['b', 'bytes']:\n        v = six.b(x.netloc)\n    elif x.scheme.lower() in ['ts.iso8601', 'timestamp.iso8601']:\n        v = MayaDT.from_iso8601(x.netloc).datetime()\n    elif x.scheme.lower() in ['ts.rfc2822', 'timestamp.rfc2822']:\n        v = MayaDT.from_rfc2822(x.netloc).datetime()\n    elif x.scheme.lower() in ['ts.rfc3339', 'timestamp.rfx3339']:\n        v = MayaDT.from_rfc3339(x.netloc).datetime()\n    elif x.scheme.lower() in ['ts', 'timestamp']:\n        v = maya.parse(x.netloc).datetime()\n    elif x.scheme.lower() == 'date':\n        v = datetime.date.fromtimestamp(float(x.netloc))\n    elif x.scheme.lower() == 'time':\n        v = time.gmtime(float(x.netloc))\n    else:\n        v = None\n\n    return v"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a string received on the command - line into a value or None.", "response": "def parse_value(v, parser, config, description):\n    \"\"\"\n    Convert a string received on the command-line into\n    a value or None.\n\n    :param str v:\n        The value to parse.\n    :param parser:\n        The fallback callable to load the value if loading\n        from scheme fails.\n    :param dict config:\n        The config to use.\n    :param str description:\n        Description (for debugging)\n    :return:\n        The parsed value\n    :rtype:\n        object\n    \"\"\"\n    val = None\n\n    if v == '':\n        return\n\n    if v is not None:\n        try:\n            val = load_value_from_schema(v)\n        except Exception as e:\n            six.raise_from(\n                CertifierTypeError(\n                    message='{kind}'.format(\n                        description=description,\n                        kind=type(v).__name__,\n                    ),\n                    required=config['required'],\n                    value=v,\n                ),\n                e)\n        else:\n            if val is None:\n                try:\n                    return parser(v)\n                except CertifierTypeError:\n                    raise\n                except CertifierValueError:\n                    raise\n                except TypeError as e:\n                    six.raise_from(\n                        CertifierTypeError(\n                            message='{kind}'.format(\n                                description=description,\n                                kind=type(v).__name__,\n                            ),\n                            required=config['required'],\n                            value=v,\n                        ),\n                        e)\n                except ValueError as e:\n                    six.raise_from(\n                        CertifierValueError(\n                            message='{value}'.format(\n                                description=description,\n                                value=v,\n                            ),\n                            required=config['required'],\n                            value=v,\n                        ),\n                        e)\n\n    return val"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gp_ptspec():\n  fenergies = ['19', '27', '39', '62', ]# '200']\n  nen = len(fenergies)\n  mee_keys = ['pi0', 'LMR', 'omega', 'phi', 'IMR', 'jpsi']\n  #mee_keys = ['LMR', ]\n  mee_dict = OrderedDict((k,'') for k in mee_keys)\n  yscale = { '200': '300', '62': '5000', '39': '50', '27': '0.3', '19': '0.001' }\n  inDir, outDir = getWorkDirs()\n  data, data_avpt, dpt_dict = {}, {}, {}\n  yvals, yvalsPt = [], []\n  scale = {\n      '19': 1.3410566491548412, '200': 1.0, '39': 1.2719203877292842,\n      '27': 1.350873678084769, '62': 1.2664666321635087\n  }\n  lmr_label = None\n  for filename in os.listdir(inDir):\n    # import data\n    file_url = os.path.join(inDir, filename)\n    filebase = os.path.splitext(filename)[0] # unique\n    energy, mee_name, mee_range, data_type = splitFileName(filebase)\n    if mee_name == 'LMR':\n        mee_range_split = map(float, mee_range.split('-'))\n        lmr_label = 'LMR: %g < M_{ee} < %g GeV/c^{2}' % (\n          mee_range_split[0], mee_range_split[1]\n        )\n    if energy == '200': continue\n    if mee_name not in mee_keys: continue\n    mee_dict[mee_name] = mee_range\n    data[filebase] = np.loadtxt(open(file_url, 'rb'))\n    if data_type == 'data':\n        #print data[filebase]\n        data[filebase] = data[filebase][:-1] # skip mT<0.4 point\n    if energy == '200': data[filebase][:,(1,3,4)] /= 0.5\n    # calculate average pT first\n    mask = (data[filebase][:,0] > 0.4) & (data[filebase][:,0] < 2.2)\n    avpt_data = data[filebase][mask]\n    pTs = avpt_data[:,0]\n    wghts = avpt_data[:,1]\n    probs = unp.uarray(avpt_data[:,1], avpt_data[:,3]) # dN/pT\n    probs /= umath.fsum(probs) # probabilities\n    avpt = umath.fsum(pTs*probs)\n    logging.info(('%s: {} %g' % (\n        filebase, np.average(pTs, weights = wghts)\n    )).format(avpt)) # TODO: syst. uncertainties\n    # save datapoint for average pT and append to yvalsPt for yaxis range\n    dp = [ float(getEnergy4Key(energy)), avpt.nominal_value, 0., avpt.std_dev, 0. ]\n    avpt_key = mee_name\n    if data_type == 'cocktail': avpt_key += '_c'\n    if data_type == 'medium': avpt_key += '_m'\n    if data_type == 'mediumMedOnly': avpt_key += '_mMed'\n    if data_type == 'mediumQgpOnly': avpt_key += '_mQgp'\n    if avpt_key in data_avpt: data_avpt[avpt_key].append(dp)\n    else: data_avpt[avpt_key] = [ dp ]\n    yvalsPt.append(avpt.nominal_value)\n    # now adjust data for panel plot and append to yvals\n    if data_type != 'data':\n      data[filebase][:,(1,3,4)] /= scale[energy]\n    data[filebase][:,(1,3,4)] *= float(yscale[energy])\n    if data_type == 'cocktail' or fnmatch(data_type, '*medium*'):\n        data[filebase][:,2:] = 0.\n    yvals += [v for v in data[filebase][:,1] if v > 0]\n    # prepare dict for panel plot\n    dpt_dict_key = getSubplotTitle(mee_name, mee_range)\n    if dpt_dict_key not in dpt_dict:\n        ndsets = nen*2\n        # TODO: currently only 19/39/62 medium avail. w/ med/qgp/tot for each\n        # July14: all energies available; TODO: fix dsidx\n        if mee_name == 'LMR': ndsets += 4*3\n        dpt_dict[dpt_dict_key] = [ [None]*ndsets, [None]*ndsets, [None]*ndsets ]\n    enidx = fenergies.index(energy)\n    dsidx = enidx\n    if fnmatch(data_type, '*medium*'):\n      # 19: 0-2, 27: 3-5, 39: 6-8, 62: 9-11\n      dsidx = (energy=='19')*0 + (energy=='27')*3 + (energy=='39')*6 + (energy=='62')*9\n      dsidx += (data_type=='mediumQgpOnly')*0 + (data_type=='mediumMedOnly')*1\n      dsidx += (data_type=='medium')*2\n    else:\n      dsidx += int(mee_name == 'LMR') * 4 * 3 # number of medium calc avail.\n    dsidx += int(data_type == 'data') * len(fenergies)\n    dpt_dict[dpt_dict_key][0][dsidx] = data[filebase] # data\n    if data_type == 'data': # properties\n      dpt_dict[dpt_dict_key][1][dsidx] = 'lt 1 lw 4 ps 1.5 lc %s pt 18' % default_colors[enidx]\n    elif data_type == 'medium':\n      dpt_dict[dpt_dict_key][1][dsidx] = 'with lines lt 1 lw 5 lc %s' % default_colors[enidx]\n    else:\n      dpt_dict[dpt_dict_key][1][dsidx] = 'with lines lt %d lw 5 lc %s' % (\n          2+(data_type=='mediumMedOnly')+(data_type=='mediumQgpOnly')*2, default_colors[enidx]\n      )\n    dpt_dict[dpt_dict_key][2][dsidx] = ' '.join([ # legend titles\n        getEnergy4Key(energy), 'GeV', '{/Symbol \\264} %g' % (\n          Decimal(yscale[energy])#.as_tuple().exponent\n        )\n      ]) if data_type == 'data' else ''\n  # use mass range in dict key to sort dpt_dict with increasing mass\n  plot_key_order = dpt_dict.keys()\n  plot_key_order.sort(key=lambda x: float(x.split(':')[1].split('-')[0]))\n  # sort data_avpt by energy and apply x-shift for better visibility\n  for k in data_avpt: data_avpt[k].sort(key=lambda x: x[0])\n  energies = [ dp[0] for dp in data_avpt[mee_keys[0]] ]\n  energies.append(215.) # TODO: think of better upper limit\n  linsp = {}\n  for start,stop in zip(energies[:-1],energies[1:]):\n    linsp[start] = np.linspace(start, stop, num = 4*len(mee_keys))\n  for k in data_avpt:\n    key = k.split('_')[0]\n    for i in xrange(len(data_avpt[k])):\n      data_avpt[k][i][0] = linsp[energies[i]][mee_keys.index(key)]\n  # make panel plot\n  yMin, yMax = 0.5*min(yvals), 3*max(yvals)\n  make_panel(\n    dpt_dict = OrderedDict((k,dpt_dict[k]) for k in plot_key_order),\n    name = os.path.join(outDir, 'ptspec'),\n    ylabel = '1/N@_{mb}^{evt} d^{2}N@_{ee}^{acc.}/dp_{T}dM_{ee} (c^3/GeV^2)',\n    xlabel = 'dielectron transverse momentum, p_{T} (GeV/c)',\n    ylog = True, xr = [0, 2.2], yr = [1e-9, 1e4],\n    #lmargin = 0.12, bmargin = 0.10, tmargin = 1., rmargin = 1.,\n    key = ['bottom left', 'samplen 0.5', 'width -2', 'opaque'],\n    arrow_bar = 0.002, layout = '3x2', size = '8in,8in'\n  )\n  #make plot for LMR spectra only\n  #lmr_key = getSubplotTitle('LMR', '0.4-0.76')\n  #if energy == '200':\n  #    lmr_key = getSubplotTitle('LMR', '0.3-0.76')\n  #pseudo_point = np.array([[-1,0,0,0,0]])\n  #model_titles = ['Cocktail + Model', 'Cocktail', 'in-Medium', 'QGP']\n  #model_props = [\n  #  'with lines lc %s lw 5 lt %d' % (default_colors[-2], i+1)\n  #  for i in xrange(len(model_titles))\n  #]\n  #make_plot(\n  #  data = dpt_dict[lmr_key][0] + [ pseudo_point ] * len(model_titles),\n  #  properties = dpt_dict[lmr_key][1] + model_props,\n  #  titles = dpt_dict[lmr_key][2] + model_titles,\n  #  name = os.path.join(outDir, 'ptspecLMR'),\n  #  ylabel = '1/N@_{mb}^{evt} d^{2}N@_{ee}^{acc.}/dp_{T}dM_{ee} (c^3/GeV^2)',\n  #  xlabel = 'dielectron transverse momentum, p_{T} (GeV/c)',\n  #  ylog = True, xr = [0, 2.0], yr = [1e-8, 100],\n  #  lmargin = 0.15, bmargin = 0.08, rmargin = 0.98, tmargin = 0.84,\n  #  key = ['maxrows 4', 'samplen 0.7', 'width -2', 'at graph 1.,1.2'],\n  #  arrow_bar = 0.005, size = '10in,13in',\n  #  labels = {\n  #    'stat. errors only': [0.7,0.95,False], lmr_label: [0.05,0.03,False],\n  #    'STAR Preliminary': [0.05,0.07,False],\n  #  }\n  #)\n  # make mean pt plot\n  #yMinPt, yMaxPt = 0.95*min(yvalsPt), 1.05*max(yvalsPt)\n  #make_plot(\n  #  data = [ # cocktail\n  #    np.array(data_avpt[k+'_c']) for k in mee_keys\n  #  ] + [ # medium\n  #    np.array(data_avpt['LMR_m'])\n  #  ] + [ # data\n  #    np.array(data_avpt[k]) for k in mee_keys\n  #  ],\n  #  properties = [\n  #   'with lines lt 1 lw 4 lc %s' % default_colors[i if i < 5 else i+1]\n  #    for i in xrange(len(mee_keys))\n  #  ] + [\n  #   'with lines lt 2 lw 4 lc %s' % default_colors[mee_keys.index('LMR')]\n  #  ] + [\n  #   'lt 1 lw 4 ps 1.5 lc %s pt 18' % default_colors[i if i < 5 else i+1]\n  #    for i in xrange(len(mee_keys))\n  #  ],\n  #  titles = [ getMeeLabel(k) for k in mee_keys ] + ['']*(len(mee_keys)+1),\n  #  name = os.path.join(outDir, 'meanPt'),\n  #  xlabel = '{/Symbol \\326}s_{NN} (GeV)',\n  #  ylabel = '{/Symbol \\341}p_{T}{/Symbol \\361} in STAR Acceptance (GeV/c)',\n  #  xlog = True, xr = [17,220], yr = [yMinPt, yMaxPt], size = '11in,9in',\n  #  key = [ 'maxrows 1', 'at graph 1, 1.1' ],\n  #  lmargin = 0.11, bmargin = 0.11, tmargin = 1., rmargin = 1.,\n  #  gpcalls = [\n  #    'format x \"%g\"',\n  #    'xtics (20,\"\" 30, 40,\"\" 50, 60,\"\" 70,\"\" 80,\"\" 90, 100, 200)',\n  #  ]\n  #)\n  ## make mean pt plot for LMR only\n  #make_plot(\n  #  data = [\n  #    np.array(data_avpt['LMR_c']),\n  #    np.array(data_avpt['LMR_m']),\n  #    np.array(data_avpt['LMR'])\n  #  ],\n  #  properties = [\n  #   'with lines lt 2 lw 4 lc %s' % default_colors[0],\n  #   'with lines lt 1 lw 4 lc %s' % default_colors[0],\n  #   'lt 1 lw 4 ps 1.5 lc %s pt 18' % default_colors[0]\n  #  ],\n  #  titles = [\n  #      'cocktail', 'HMBT', getMeeLabel('data')\n  #  ],\n  #  name = os.path.join(outDir, 'meanPtLMR'),\n  #  xlabel = '{/Symbol \\326}s_{NN} (GeV)',\n  #  ylabel = 'LMR {/Symbol \\341}p_{T}{/Symbol \\361} in STAR Acceptance (GeV/c)',\n  #  lmargin = 0.17, bmargin = 0.15, tmargin = 0.95, xlog = True, xr = [17,80],\n  #  yr = [0.65,1.05], #yr = [yMinPt, yMaxPt],\n  #  key = [ 'bottom right' ],\n  #  gpcalls = [\n  #    'format x \"%g\"',\n  #    'xtics (20, 30, 40,\"\" 50, 60,\"\" 70,\"\" 80,\"\" 90, 100, 200)',\n  #  ],\n  #  labels = {\n  #      'stat. errors only': [0.7,0.95,False], lmr_label: [0.05,0.07,False],\n  #      '0.4 < p_{T} < 2.2 GeV/c': [0.05,0.14,False]\n  #  }\n  #)\n  return 'done'", "response": "example for a 2D - panel plot etc."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef deserialize(self, obj=None, ignore_non_existing=False):\n    if not isinstance(obj, dict):\n      if ignore_non_existing:\n        return\n\n      raise TypeError(\"Wrong data '{}' passed for '{}' deserialization\".format(obj, self.__class__.__name__))\n\n    definitions = {k: v for k, v in self.__class__.__dict__.items() if k[:1] != \"_\"}\n    def_property_keys = set(definitions.keys())\n    property_keys = set(obj.keys())\n\n    existing_keys = def_property_keys & property_keys\n    non_defined_keys = property_keys - def_property_keys\n    non_existing_keys = def_property_keys - property_keys\n\n    if not ignore_non_existing and non_defined_keys:\n      raise TypeError(self.__class__.__name__ + \" doesn't contain properties: {}\".format(\", \".join(non_defined_keys)))\n\n    for k in existing_keys:\n      v = obj[k]\n      attr_type = definitions[k]\n\n      try:\n        if isinstance(attr_type, list) and self._isclass(attr_type[0], BaseView):\n          if isinstance(v, list):\n            obj_list = [attr_type[0](serialized_obj=v_item, ignore_non_existing=ignore_non_existing) for v_item in v]\n          else:\n            obj_list = [attr_type[0](serialized_obj=v, ignore_non_existing=ignore_non_existing)]\n\n          self.__setattr__(k, obj_list)\n        elif self._isclass(attr_type, BaseView):\n          self.__setattr__(k, attr_type(v))\n        else:\n          self.__setattr__(k, v)\n      except IndexError:\n        self.__setattr__(k, v)  # check test_empty_view_deserialization test suite for test-case\n\n    for k in non_existing_keys:\n      attr_type = definitions[k]\n\n      if attr_type is None:\n        self.__setattr__(k, None)\n      elif isinstance(attr_type, (list, set, tuple, dict)) and len(attr_type) == 0:\n        self.__setattr__(k, attr_type.__class__())\n      elif isinstance(attr_type, (list, set, tuple)) and self._isclass(attr_type[0], BaseView):\n        self.__setattr__(k, attr_type.__class__())\n      else:\n        self.__setattr__(k, attr_type.__class__(attr_type))\n\n    return self", "response": "Deserialize the object into this object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef serialize(self, null_values=False):\n    ret = {}\n    property_dict = dict(self.__class__.__dict__)  # contain view definition defaults\n    property_dict.update(self.__dict__)  # overrides done at runtime\n\n    for k in property_dict.keys():\n      if k[:1] == \"_\" or (property_dict[k] is None and not null_values):\n        continue\n\n      v = property_dict[k]\n\n      if isinstance(v, list):\n        v_items = []\n        for v_item in v:\n          if self._isclass(v_item.__class__, BaseView):\n            v_item_val = v_item.serialize(null_values=null_values)\n            if not null_values and len(v_item_val) == 0:\n              continue\n            v_items.append(v_item_val)\n          elif self._isclass(v_item, BaseView):  # when were passed Class instead of instance\n            pass\n          else:\n            v_items.append(v_item)\n\n        ret[k] = v_items\n      elif self._isclass(v.__class__, BaseView):\n        ret[k] = v.serialize(null_values=null_values)\n      elif self._isclass(v, BaseView):  # when were passed Class instead of instance\n        pass\n      else:\n        ret[k] = v\n\n    return ret", "response": "Returns a dictionary containing the current object s properties."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if the given date is valid and returns bool", "response": "def date_is_valid(dates):\n    \"\"\"Checks if dates (e.g. [\"17\", \"11\"] ) is valid and returns bool\n\n    Checks if the first element is between 1 and 31\n    and the second element is between 1 and 12.\n\n\n    Keyword arguments:\n    dates -- list of numbers\n\n    Returns:\n    True if the date is valid, False otherwise.\n    \"\"\"\n    if (int(dates[0]) < 1 or\n            int(dates[0]) > 31 or\n            int(dates[1]) < 1 or\n            int(dates[1]) > 12):\n\n        return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_simple_date(datestring):\n    simple_date = re.compile(r\"\\d{1,2}(\\.)\\d{1,2}\")\n    date = simple_date.search(datestring)\n    if date:\n        dates = date.group().split(\".\")\n        if len(dates[0]) == 1:\n            dates[0] = add_zero(dates[0])\n        if len(dates[1]) == 1:\n            dates[1] = add_zero(dates[1])\n\n        if date_is_valid(dates):\n            return '.'.join(dates) + '.'\n        return \"Failed\"", "response": "Transforms a datestring into a shorter date 7. 9. 2017 > 07. 09. 2017. Returns string Failed."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntransforms a written month into corresponding month number.", "response": "def get_month(datestring):\n    \"\"\"Transforms a written month into corresponding month number.\n\n    E.g. November -> 11, or May -> 05.\n\n    Keyword arguments:\n    datestring -- a string\n\n    Returns:\n    String, or None if the transformation fails\n    \"\"\"\n    convert_written = re.compile(r\"jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec\", re.IGNORECASE)\n    month = convert_written.search(datestring)\n    month_number = None\n\n    # If there's a match, convert the month to its corresponding number\n    if month:\n        month_number = strptime(month.group(), \"%b\").tm_mon\n        if month_number < 10:\n            month_number = add_zero(month_number)\n\n    return str(month_number)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntransforms an ordinal number into a plain number with padding zero.", "response": "def get_day_of_month(datestring):\n    \"\"\"Transforms an ordinal number into plain number with padding zero.\n\n    E.g. 3rd -> 03, or 12th -> 12\n\n    Keyword arguments:\n    datestring -- a string\n\n    Returns:\n    String, or None if the transformation fails\n    \"\"\"\n    get_day = re.compile(r\"\\d{1,2}(st|nd|rd|th)?\", re.IGNORECASE)\n    day = get_day.search(datestring)\n    the_day = None\n\n    if day:\n        if bool(re.search(r\"[st|nd|rd|th]\", day.group().lower())):\n            the_day = day.group()[:-2]\n        else:\n            the_day = day.group()\n        if int(the_day) < 10:\n            the_day = add_zero(the_day)\n\n    return str(the_day)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstrips matching regular expressions from string", "response": "def strip_string(self, string, *args):\n        \"\"\"Strips matching regular expressions from string\n\n        Keyword arguments:\n        string -- The given string, that will be stripped\n        *args -- List of regex strings, that are used in parsing\n\n        Returns:\n        String with *args removed from string\n        \"\"\"\n        res = string\n        for r in args:\n            res = re.sub(r, \"\", res.strip(),\n                         flags=re.IGNORECASE|re.MULTILINE)\n        return res.strip()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef strip_between(self, string, start, end):\n        regex = start + r'.*?' + end + r'\\s*'\n        res = re.sub(regex, '', string,\n                     flags=re.DOTALL|re.IGNORECASE|re.MULTILINE)\n        return res", "response": "Removes everything between start and end from string"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef distance_between(self, string, start, end):\n        count = 0\n        started = False\n\n        for line in string.split(\"\\n\"):\n\n            if self.scan_line(line, start) and not started:\n                started = True\n\n            if self.scan_line(line, end):\n                return count\n\n            if started:\n                count += 1\n\n        return count", "response": "Returns the number of lines between start and end"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef scan_line(self, line, regex):\n        return bool(re.search(regex, line, flags=re.IGNORECASE))", "response": "Checks if regex is in line returns bool"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scan_message(self, message, regex):\n        for line in message.split(\"\\n\"):\n            if bool(re.search(\n                    regex,\n                    line,\n                    flags=re.IGNORECASE|re.MULTILINE)):\n                return line\n        return \"\"", "response": "Scans regex from a message and returns the line that matches the regex."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nformatting various date formats to dd. MM.", "response": "def format_date(self, dl_string):\n        \"\"\"Formats various date formats to dd.MM.\n\n        Examples\n        - January 15th      --> 15.01.\n        - 15.01.2017        --> 15.01.\n        - 15th of January   --> 15.01.\n        - 15.1.             --> 15.01.\n\n        Keyword arguments:\n        dl_string -- a string to be formatted\n\n        Returns:\n        Date string in format dd.MM. or \"None.None\"\n        \"\"\"\n        thedate = get_simple_date(dl_string)\n        if thedate != \"Failed\" and thedate:\n            return thedate\n\n        day = get_day_of_month(dl_string)\n        month = get_month(dl_string)\n\n        return day + '.' + month + '.'"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_user(self, user_id, custom_properties=None, headers=None, endpoint_url=None):\n        endpoint_url = endpoint_url or self._endpoint_url\n\n        url = endpoint_url + '/users'\n\n        headers = headers or self._default_headers()\n        payload = {\"user_id\": user_id}\n\n        if custom_properties is not None:\n            payload[\"user_properties\"] = custom_properties\n\n        response = requests.post(url, headers=headers, json=payload)\n\n        return response", "response": "Adds a user to the identified user store."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_event(self, user_id, event_name, event_properties=None, headers=None, endpoint_url=None):\n        endpoint_url = endpoint_url or self._endpoint_url\n\n        url = endpoint_url + '/users/' + user_id + '/events'\n        headers = headers or self._default_headers()\n\n        event_properties = event_properties or {}\n        payload = {\n            \"event_name\": event_name,\n            \"custom_properties\": event_properties\n        }\n\n        response = requests.post(url, headers=headers, json=payload)\n\n        return response", "response": "Send an event to the user s ID and optionally add it to the event list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef decrease_user_property(self, user_id, property_name, value=0, headers=None, endpoint_url=None):\n        endpoint_url = endpoint_url or self._endpoint_url\n\n        url = endpoint_url + \"/users/\" + user_id + \"/properties/\" + property_name + \"/decrease/\" + value.__str__()\n        headers = headers or self._default_headers(content_type=\"\")\n\n        response = requests.post(url, headers=headers)\n\n        return response", "response": "Decrease a user s property by a value."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate a user s properties with values provided in user_properties dictionary.", "response": "def update_user_properties(self, user_id, user_properties, headers=None, endpoint_url=None):\n        \"\"\"\n        Update a user's properties with values provided in \"user_properties\" dictionary\n\n        :param str user_id: identified user's ID\n        :param dict user_properties: user properties to update with a new values\n        :param dict headers: custom request headers (if isn't set default values are used)\n        :param str endpoint_url: where to send the request (if isn't set default value is used)\n        :return: Response\n        \"\"\"\n        endpoint_url = endpoint_url or self._endpoint_url\n\n        url = endpoint_url + '/users/' + user_id + '/properties'\n        headers = headers or self._default_headers()\n        payload = user_properties\n\n        response = requests.put(url, headers=headers, json=payload)\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef link_user_to_group(self, user_id, group_id, headers=None, endpoint_url=None):\n        endpoint_url = endpoint_url or self._endpoint_url\n\n        url = endpoint_url + '/groups/' + group_id + '/link/' + user_id\n        headers = headers or self._default_headers()\n\n        response = requests.post(url, headers=headers)\n\n        return response", "response": "Links a user to a group"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_group_properties(self, group_id, group_properties, headers=None, endpoint_url=None):\n        endpoint_url = endpoint_url or self._endpoint_url\n\n        url = endpoint_url + '/groups/' + group_id + '/properties'\n        headers = headers or self._default_headers()\n        payload = group_properties\n\n        response = requests.put(url, headers=headers, json=payload)\n\n        return response", "response": "Update a group s properties with values provided in group_properties dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting default headers for API request", "response": "def _default_headers(self, content_type=CONTENT_TYPE, token=None):\n        \"\"\"\n        Get default headers for API request\n        :param unicode content_type: HTTP request content type\n        :param: str token: customer app ID\n        :return: dictionary\n        \"\"\"\n        headers = {\n            self.HEADER_CLIENT_TYPE: self.CLIENT_TYPE,\n            self.HEADER_TIMESTAMP: str(self._now()),\n            self.HEADER_CUSTOMER_APP_ID: token or self._token\n        }\n\n        if content_type is not None or content_type is not False:\n            headers[self.HEADER_CONTENT_TYPE] = content_type\n\n        return headers"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating and returns a new instance of the manager class.", "response": "def get_a_manager(threadPool_settings=None):\n    \"\"\" On first call, creates and returns a @mirte.core.Manager.  On\n        subsequent calls, returns the previously created instance.\n\n        If it is the first call, it will initialize the threadPool\n        with @threadPool_settings. \"\"\"\n    global __singleton_manager\n    if __singleton_manager is None:\n        def _thread_entry():\n            if prctl:\n                prctl.set_name('mirte manager')\n            m.run()\n            l.info('manager.run() returned')\n        l = logging.getLogger('mirte.get_a_manager')\n        l.info(\"Creating new instance\")\n        m = Manager(logging.getLogger('mirte'))\n        if threadPool_settings:\n            m.update_instance('threadPool', threadPool_settings)\n        threading.Thread(target=_thread_entry).start()\n        m.running_event.wait()\n        __singleton_manager = m\n    return __singleton_manager"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntimes execution of function. Returns res and seconds.", "response": "def timeit(func, *args, **kwargs):\n    \"\"\"\n    Time execution of function. Returns (res, seconds).\n\n    >>> res, timing = timeit(time.sleep, 1)\n    \"\"\"\n    start_time = time.time()\n    res = func(*args, **kwargs)\n    timing = time.time() - start_time\n    return res, timing"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef timing(self, stats, value):\n        self.update_stats(stats, value, self.SC_TIMING)", "response": "Log timing information\n\n        >>> client = StatsdClient()\n        >>> client.timing('example.timing', 500)\n        >>> client.timing(('example.timing23', 'example.timing29'), 500)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a gauge to the log", "response": "def gauge(self, stats, value):\n        \"\"\"\n        Log gauges\n\n        >>> client = StatsdClient()\n        >>> client.gauge('example.gauge', 47)\n        >>> client.gauge(('example.gauge41', 'example.gauge43'), 47)\n        \"\"\"\n        self.update_stats(stats, value, self.SC_GAUGE)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set(self, stats, value):\n        self.update_stats(stats, value, self.SC_SET)", "response": "Set the log level to the given value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef count(self, stats, value, sample_rate=1):\n        self.update_stats(stats, value, self.SC_COUNT, sample_rate)", "response": "Updates one or more stats counters by arbitrary value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef timeit(self, metric, func, *args, **kwargs):\n        (res, seconds) = timeit(func, *args, **kwargs)\n        self.timing(metric, seconds * 1000.0)\n        return res", "response": "Times given function and log metric in ms for duration of execution."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsamples the data dict for a specific time period", "response": "def sample(data, sample_rate):\n        \"\"\"\n        Sample data dict\n        TODO(rbtz@): Convert to generator\n\n        >>> StatsdClient.sample({\"example.sample2\": \"2\"}, 1)\n        {'example.sample2': '2'}\n        >>> StatsdClient.sample({\"example.sample3\": \"3\"}, 0)\n        {}\n        >>> from random import seed\n        >>> seed(1)\n        >>> StatsdClient.sample({\"example.sample5\": \"5\",\n        ... \"example.sample7\": \"7\"}, 0.99)\n        {'example.sample5': '5|@0.99', 'example.sample7': '7|@0.99'}\n        >>> StatsdClient.sample({\"example.sample5\": \"5\",\n        ... \"example.sample7\": \"7\"}, 0.01)\n        {}\n        \"\"\"\n        if sample_rate >= 1:\n            return data\n        elif sample_rate < 1:\n            if random() <= sample_rate:\n                sampled_data = {}\n                for stat, value in data.items():\n                    sampled_data[stat] = \"{0}|@{1}\".format(value, sample_rate)\n                return sampled_data\n        return {}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send(_dict, addr):\n        # TODO(rbtz@): IPv6 support\n        udp_sock = socket(AF_INET, SOCK_DGRAM)\n        # TODO(rbtz@): Add batch support\n        for item in _dict.items():\n            udp_sock.sendto(\":\".join(item).encode('utf-8'), addr)", "response": "Send a dict of key - value pairs via UDP."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef jars(self, absolute=True):\n        '''\n        List of jars in the jar path\n        '''\n        jars = glob(os.path.join(self._jar_path, '*.jar'))\n        return jars if absolute else map(lambda j: os.path.abspath(j), jars)", "response": "Returns a list of jars in the jar path"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef download_jars_to(cls, folder):\n        '''\n        Download missing jars to a specific folder\n        '''\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n        for info in JARS:\n            jar = MavenJar(info[0], info[1], info[2])\n            path = os.path.join(folder, jar.filename)\n\n            if os.path.isfile(path):\n                print(\"Skipping already downloaded file: %s\" % jar.filename)\n                continue\n\n            print(\"Downloading %s...\" % jar.filename)\n            jar.download_to(folder)", "response": "Download missing jars to a specific folder."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite properties from environmental variables to a file for KCL s MultiLangDaemon", "response": "def write_properties_from_env(cls, path):\n        '''\n        Uses environmental variables to write a *.properties file for KCL's MultiLangDaemon\n        '''\n        with open(path, 'w') as f:\n            f.write(\"# Autogenerated by kclboot v%s on %s\\n\\n\" % (PACKAGE_VERSION, datetime.now()))\n            for env_var, prop_var in ENV_TO_PROPERTY.items():\n                env_value = os.environ.get(env_var)\n                if env_value:\n                    f.write(\"%s=%s\\n\" % (prop_var, env_value))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reStructuredText_to_html(input, output, css_file):\n\n    LOGGER.info(\"{0} | Converting '{1}' reStructuredText file to html!\".format(\n        reStructuredText_to_html.__name__, input))\n    os.system(\"{0} --stylesheet-path='{1}' '{2}' > '{3}'\".format(RST2HTML,\n                                                                 os.path.join(os.path.dirname(__file__), css_file),\n                                                                 input,\n                                                                 output))\n\n    LOGGER.info(\"{0} | Formatting html file!\".format(\"Tidy\"))\n    os.system(\"tidy -config {0} -m '{1}'\".format(os.path.join(os.path.dirname(__file__), TIDY_SETTINGS_FILE), output))\n\n    file = File(output)\n    file.cache()\n    LOGGER.info(\"{0} | Replacing spaces with tabs!\".format(reStructuredText_to_html.__name__))\n    file.content = [line.replace(\" \" * 4, \"\\t\") for line in file.content]\n    file.write()\n\n    return True", "response": "Converts a reStructuredText file to html."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main():\n\n    args = get_command_line_arguments()\n    args.css_file = args.css_file if foundations.common.path_exists(args.css_file) else CSS_FILE\n    return reStructuredText_to_html(args.input,\n                                    args.output,\n                                    args.css_file)", "response": "Starts the Application.\n\n    :return: Definition success.\n    :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef attributes_from_dict(document):\n    attributes = dict()\n    for attr in document:\n        name = str(attr['name'])\n        attributes[name] = Attribute(\n            name,\n            attr['value']\n        )\n    return attributes", "response": "Convert a Json representation of a set of attribute instances into a dictionary of Attribute objects keyed by their name and value."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntransform a dictionary of attribute instances into a list of Json objects i. e. list of key - value pairs.", "response": "def attributes_to_dict(attributes):\n    \"\"\"Transform a dictionary of attribute instances into a list of Json\n    objects, i.e., list of key-value pairs.\n\n    Parameters\n    ----------\n    attributes : dict(Attribute)\n        Dictionary of attribute instances\n\n    Returns\n    -------\n    list(dict(name:..., value:...))\n        List of key-value pairs.\n    \"\"\"\n    result = []\n    for key in attributes:\n        result.append({\n            'name' : key,\n            'value' : attributes[key].value\n        })\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_dict(attributes, definitions):\n    # Create a list of valis parameter names\n    valid_names = {}\n    for para in definitions:\n        valid_names[para.identifier] = para\n    result = {}\n    if not attributes is None:\n        for element in attributes:\n            if isinstance(element, dict):\n                # Create attribute from dictionary\n                for key in ['name', 'value']:\n                    if not key in element:\n                        raise ValueError('object has no key ' + key + ': ' + str(element))\n                name = str(element['name'])\n                if not name in valid_names:\n                    raise ValueError('invalid parameter name: ' + name)\n                try:\n                    value = valid_names[name].data_type.from_string(\n                        element['value']\n                    )\n                except ValueError as ex:\n                    raise ValueError(str(ex))\n                attr = Attribute(name, value)\n            else:\n                # Element is expected to be an attribute object\n                attr = element\n                # Make sure that the attribute value is of valid type. Make\n                # sure that attr.name is valid.\n                if attr.name in valid_names:\n                    valid_names[attr.name].data_type.test_value(attr.value)\n                else:\n                    raise ValueError('invalid parameter name: ' + attr.name)\n            if attr.name in result:\n                raise ValueError('duplicate attribute: ' + attr.name)\n            result[attr.name] = attr\n    return result", "response": "Create a dictionary of attributes from a given list of key - value pairs."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate attribute definition form Json - like object represenation.", "response": "def from_dict(document):\n        \"\"\"Create attribute definition form Json-like object represenation.\n\n        Parameters\n        ----------\n        document : dict\n            Json-like object represenation\n\n        Returns\n        -------\n        AttributeDefinition\n        \"\"\"\n        if 'default' in document:\n            default = document['default']\n        else:\n            default = None\n        return AttributeDefinition(\n            document['id'],\n            document['name'],\n            document['description'],\n            AttributeType.from_dict(document['type']),\n            default=default\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting attribute definition into a dictionary.", "response": "def to_dict(self):\n        \"\"\"Convert attribute definition into a dictionary.\n\n        Returns\n        -------\n        dict\n            Json-like dictionary representation of the attribute definition\n        \"\"\"\n        obj = {\n            'id' : self.identifier,\n            'name' : self.name,\n            'description' : self.description,\n            'type' : self.data_type.to_dict()\n        }\n        if not self.default is None:\n            obj['default'] = self.default\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates data type definition form Json - like object represenation.", "response": "def from_dict(document):\n        \"\"\"Create data type definition form Json-like object represenation.\n\n        Parameters\n        ----------\n        document : dict\n            Json-like object represenation\n\n        Returns\n        -------\n        AttributeType\n        \"\"\"\n        # Get the type name from the document\n        type_name = document['name']\n        if type_name == ATTR_TYPE_INT:\n            return IntType()\n        elif type_name == ATTR_TYPE_FLOAT:\n            return FloatType()\n        elif type_name == ATTR_TYPE_ENUM:\n            return EnumType(document['values'])\n        elif type_name == ATTR_TYPE_DICT:\n            return DictType()\n        elif type_name == ATTR_TYPE_LIST:\n            return ListType()\n        else:\n            raise ValueError('invalid attribute type: ' + str(type_name))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_string(self, value):\n        # Remove optional {}\n        if value.startswith('{') and value.endswith('}'):\n            text = value[1:-1].strip()\n        else:\n            text = value.strip()\n        # Result is a dictionary\n        result = {}\n        # Convert each pair of <int>:<float> into a key, value pair.\n        for val in text.split(','):\n            tokens = val.split(':')\n            if len(tokens) != 2:\n                raise ValueError('invalid entry in dictionary: ' + val)\n            result[str(int(tokens[0].strip()))] = float(tokens[1].strip())\n        return result", "response": "Convert string to dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts string to enum value.", "response": "def from_string(self, value):\n        \"\"\"Convert string to enum value.\"\"\"\n        if not isinstance(value, basestring):\n            raise ValueError('expected string value: ' + str(type(value)))\n        self.test_value(value)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts the enumeration data type definition into a dictionary.", "response": "def to_dict(self):\n        \"\"\"Convert enum data type definition into a dictionary. Overrides the\n        super class method to add list of enumeration values.\n\n        Returns\n        -------\n        dict\n            Json-like dictionary representation of the attribute data type\n        \"\"\"\n        obj = super(EnumType, self).to_dict()\n        obj['values'] = self.values\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting string to list.", "response": "def from_string(self, value):\n        \"\"\"Convert string to list.\"\"\"\n        # Remove optional []\n        if value.startswith('[') and value.endswith(']'):\n            text = value[1:-1].strip()\n        else:\n            text = value.strip()\n        # Result is a list\n        result = []\n        # If value starts with '(' assume a list of pairs\n        if text.startswith('('):\n            tokens = text.split(',')\n            if len(tokens) % 2 != 0:\n                raise ValueError('not a valid list of pairs')\n            pos = 0\n            while (pos < len(tokens)):\n                val1 = float(tokens[pos].strip()[1:].strip())\n                val2 = float(tokens[pos + 1].strip()[:-1])\n                result.append((val1, val2))\n                pos += 2\n        else:\n            for val in text.split(','):\n                result.append(float(val))\n        # Ensure that the result contains at least two elements\n        if len(result) < 2:\n            raise ValueError('invalid number of elements in list: ' + str(len(result)))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef visible(self):\n        visible = self.all()\n        if not settings.COMMENTS_UNAPPROVED_VISIBLE:\n            visible = visible.filter(is_public=True)\n        if not settings.COMMENTS_REMOVED_VISIBLE:\n            visible = visible.filter(is_removed=False)\n        return visible", "response": "Return the comments that are visible based on the COMMENTS_XXX_VISIBLE settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_or_create_iexact(self, **kwargs):\n        lookup = dict(**kwargs)\n        try:\n            lookup[\"title__iexact\"] = lookup.pop(\"title\")\n        except KeyError:\n            pass\n        try:\n            return self.filter(**lookup)[0], False\n        except IndexError:\n            return self.create(**kwargs), True", "response": "Returns the first instance of the record that matches the keyword arguments."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_unused(self, keyword_ids=None):\n        if keyword_ids is None:\n            keywords = self.all()\n        else:\n            keywords = self.filter(id__in=keyword_ids)\n        keywords.filter(assignments__isnull=True).delete()", "response": "Deletes all instances that are not assigned to any object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters template directories of apps to Lookups.", "response": "def setup_lookup(apps, lookup_class=TemplateLookup):\n    \"\"\" Registering template directories of apps to Lookup.\n\n    Lookups will be set up as dictionary, app name\n    as key and lookup for this app will be it's value.\n    Each lookups is correspond to each template directories of apps._lookups.\n    The directory should be named 'templates', and put under app directory.\n    \"\"\"\n    global _lookups\n\n    _lookups = {}\n    for app in apps:\n        app_template_dir = os.path.join(os.path.dirname(app.__file__),\n                                        'templates')\n        app_lookup = lookup_class(directories=[app_template_dir],\n                                  output_encoding='utf-8',\n                                  encoding_errors='replace')\n        _lookups[app.__name__] = app_lookup"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_app_template(name):\n    app_name, template_name = name.split(':')\n    return get_lookups()[app_name].get_template(template_name)", "response": "Get the template for the given application name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sqlalchemy_escape(val, escape_char, special_chars):\n    if sys.version_info[:2] >= (3, 0):\n        assert isinstance(val, str)\n    else:\n        assert isinstance(val, basestring)\n    result = []\n    for c in val:\n        if c in special_chars + escape_char:\n            result.extend(escape_char + c)\n        else:\n            result.extend(c)\n    return ''.join(result)", "response": "Escape a string according to use in LIKE operator."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts keys from unicode to str type.", "response": "def _remove_unicode_keys(dictobj):\n    \"\"\"Convert keys from 'unicode' to 'str' type.\n\n    workaround for <http://bugs.python.org/issue2646>\n    \"\"\"\n    if sys.version_info[:2] >= (3, 0): return dictobj\n\n    assert isinstance(dictobj, dict)\n\n    newdict = {}\n    for key, value in dictobj.items():\n        if type(key) is unicode:\n            key = key.encode('utf-8')\n        newdict[key] = value\n    return newdict"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nresetting the database to its initial state.", "response": "def reset(self):\n        \"\"\"Reset the database\n\n        Drop all tables and recreate them\n        \"\"\"\n        self.metadata.drop_all(self.engine)\n        self.metadata.create_all(self.engine)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef transaction(self, session=None):\n        local_session = None\n        if session is None:\n            local_session = session = self.create_scoped_session()\n        try:\n            yield session\n        finally:\n            # Since ``local_session`` was created locally, close it here itself\n            if local_session is not None:\n                # but wait!\n                # http://groups.google.com/group/sqlalchemy/browse_thread/thread/7c1eb642435adde7\n                # To workaround this issue with sqlalchemy, we can either:\n                #  1) pass the session object explicitly\n                #  2) do not close the session at all (bad idea - could lead to memory leaks)\n                #\n                # Till pypm implements atomic transations in client.installer,\n                # we retain this hack (i.e., we choose (2) for now)\n                pass", "response": "Start a new transaction based on the passed session object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_from(cls, another, **kwargs):\n        reused_fields = {}\n        for field, value in another.get_fields():\n            if field in cls.FIELDS:\n                reused_fields[field] = value\n        reused_fields.update(kwargs)\n        return cls(**reused_fields)", "response": "Create from another object of different type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __assert_field_mapping(self, mapping):\n        passed_keys = set(mapping.keys())\n        class_fields = set(self.FIELDS)\n\n        if passed_keys != class_fields:\n            raise ValueError('\\n'.join([\n                \"{0} got different fields from expected\".format(\n                    self.__class__),\n                \"  got     : {0}\".format(list(sorted(passed_keys))),\n                \"  expected: {0}\".format(list(sorted(class_fields)))]))", "response": "Assert that mapping. keys() == FIELDS."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a brightness message", "response": "def brightness(sequence_number, brightness):\n        \"\"\"Create a brightness message\"\"\"\n        return MessageWriter().string(\"brightness\").uint64(sequence_number).uint8(int(brightness*255)).get()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mainswitch_state(sequence_number, state):\n        return MessageWriter().string(\"mainswitch.state\").uint64(sequence_number).bool(state).get()", "response": "Create a mainswitch. state message"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef animation_add(sequence_number, animation_id, name):\n        return MessageWriter().string(\"animation.add\").uint64(sequence_number).uint32(animation_id).string(name).get()", "response": "Create a animation. add message"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef scene_active(sequence_number, scene_id):\n        return MessageWriter().string(\"scene.setactive\").uint64(sequence_number).uint32(scene_id).get()", "response": "Create a scene. setactive message"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a scene. add message", "response": "def scene_add(sequence_number, scene_id, animation_id, name, color, velocity, config):\n        \"\"\"Create a scene.add message\"\"\"\n        (red, green, blue) = (int(color[0]*255), int(color[1]*255), int(color[2]*255))\n        return MessageWriter().string(\"scene.add\").uint64(sequence_number).uint32(scene_id).uint32(animation_id).string(name) \\\n                              .uint8_3(red, green, blue).uint32(int(velocity * 1000)).string(config).get()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a scene. rm message", "response": "def scene_remove(sequence_number, scene_id):\n        \"\"\"Create a scene.rm message\"\"\"\n        return MessageWriter().string(\"scene.rm\").uint64(sequence_number).uint32(scene_id).get()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a scene. name message", "response": "def scene_name(sequence_number, scene_id, name):\n        \"\"\"Create a scene.name message\"\"\"\n        return MessageWriter().string(\"scene.name\").uint64(sequence_number).uint32(scene_id).string(name).get()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a scene. config message", "response": "def scene_config(sequence_number, scene_id, config):\n        \"\"\"Create a scene.config message\"\"\"\n        return MessageWriter().string(\"scene.config\").uint64(sequence_number).uint32(scene_id).string(config).get()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a scene. color message", "response": "def scene_color(sequence_number, scene_id, color):\n        \"\"\"Create a scene.color message\"\"\"\n        return MessageWriter().string(\"scene.color\").uint64(sequence_number).uint32(scene_id) \\\n                              .uint8_3(int(color[0]*255), int(color[1]*255), int(color[2]*255)).get()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef scene_velocity(sequence_number, scene_id, velocity):\n        return MessageWriter().string(\"scene.velocity\").uint64(sequence_number).uint32(scene_id).uint32(int(velocity*1000)).get()", "response": "Create a scene. velocity message"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nappending a frame containing a uint8", "response": "def uint8(self, val):\n        \"\"\"append a frame containing a uint8\"\"\"\n        try:\n            self.msg += [pack(\"B\", val)]\n        except struct.error:\n            raise ValueError(\"Expected uint32\")\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef uint8_3(self, val1, val2, val3):\n        try:\n            self.msg += [pack(\"BBB\", val1, val2, val3)]\n        except struct.error:\n            raise ValueError(\"Expected uint8\")\n        return self", "response": "append a frame containing 3 uint8"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef uint32(self, val):\n        try:\n            self.msg += [pack(\"!I\", val)]\n        except struct.error:\n            raise ValueError(\"Expected uint32\")\n        return self", "response": "append a frame containing a uint32"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nappending a frame containing a uint64", "response": "def uint64(self, val):\n        \"\"\"append a frame containing a uint64\"\"\"\n        try:\n            self.msg += [pack(\"!Q\", val)]\n        except struct.error:\n            raise ValueError(\"Expected uint64\")\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef brightness(frames):\n        reader = MessageReader(frames)\n        res = reader.string(\"command\").uint32(\"brightness\").assert_end().get()\n        if res.command != \"brightness\":\n            raise MessageParserError(\"Command is not 'brightness'\")\n        return (res.brightness/1000,)", "response": "parse a brightness message"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mainswitch_state(frames):\n        reader = MessageReader(frames)\n        res = reader.string(\"command\").bool(\"state\").assert_end().get()\n        if res.command != \"mainswitch.state\":\n            raise MessageParserError(\"Command is not 'mainswitch.state'\")\n        return (res.state,)", "response": "parse a mainswitch. state message"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef scene_add(frames):\n        reader = MessageReader(frames)\n        results = reader.string(\"command\").uint32(\"animation_id\").string(\"name\").uint8_3(\"color\").uint32(\"velocity\").string(\"config\").get()\n        if results.command != \"scene.add\":\n            raise MessageParserError(\"Command is not 'scene.add'\")\n        return (results.animation_id, results.name, np.array([results.color[0]/255, results.color[1]/255, results.color[2]/255]),\n                results.velocity/1000, results.config)", "response": "parse a scene. add message"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing a scene. color message", "response": "def scene_color(frames):\n        \"\"\"parse a scene.color message\"\"\"\n        # \"scene.color\" <scene_id> <color>\n        reader = MessageReader(frames)\n        results = reader.string(\"command\").uint32(\"scene_id\").uint8_3(\"color\").assert_end().get()\n        if results.command != \"scene.color\":\n            raise MessageParserError(\"Command is not 'scene.color'\")\n        return (results.scene_id, np.array([results.color[0]/255, results.color[1]/255, results.color[2]/255]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses a scene. config message", "response": "def scene_config(frames):\n        \"\"\"parse a scene.config message\"\"\"\n        # \"scene.config\" <scene_id> <config>\n        reader = MessageReader(frames)\n        results = reader.string(\"command\").uint32(\"scene_id\").string(\"config\").assert_end().get()\n        if results.command != \"scene.config\":\n            raise MessageParserError(\"Command is not 'scene.config'\")\n        return (results.scene_id, results.config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses a scene. name message", "response": "def scene_name(frames):\n        \"\"\"parse a scene.name message\"\"\"\n        # \"scene.name\" <scene_id> <config>\n        reader = MessageReader(frames)\n        results = reader.string(\"command\").uint32(\"scene_id\").string(\"name\").assert_end().get()\n        if results.command != \"scene.name\":\n            raise MessageParserError(\"Command is not 'scene.name'\")\n        return (results.scene_id, results.name)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a scene. rm message", "response": "def scene_remove(frames):\n        \"\"\"parse a scene.rm message\"\"\"\n        # \"scene.rm\" <scene_id>\n        reader = MessageReader(frames)\n        results = reader.string(\"command\").uint32(\"scene_id\").assert_end().get()\n        if results.command != \"scene.rm\":\n            raise MessageParserError(\"Command is not 'scene.rm'\")\n        return (results.scene_id,)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing a scene. velocity message", "response": "def scene_velocity(frames):\n        \"\"\"parse a scene.velocity message\"\"\"\n        # \"scene.velocity\" <scene_id> <velocity>\n        reader = MessageReader(frames)\n        results = reader.string(\"command\").uint32(\"scene_id\").uint32(\"velocity\").assert_end().get()\n        if results.command != \"scene.velocity\":\n            raise MessageParserError(\"Command is not 'scene.velocity'\")\n        return (results.scene_id, results.velocity/1000)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse a string frame", "response": "def string(self, name):\n        \"\"\"parse a string frame\"\"\"\n        self._assert_is_string(name)\n        frame = self._next_frame()\n        try:\n            val = frame.decode('utf-8')\n            self.results.__dict__[name] = val\n        except UnicodeError as err:\n            raise MessageParserError(\"Message contained invalid Unicode characters\") \\\n                from err\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef bool(self, name):\n        self._assert_is_string(name)\n        frame = self._next_frame()\n        if len(frame) != 1:\n            raise MessageParserError(\"Expected exacty 1 byte for boolean value\")\n        val = frame != b\"\\x00\"\n        self.results.__dict__[name] = val\n        return self", "response": "parse a boolean frame"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a tuple of 3 uint8 values", "response": "def uint8_3(self, name):\n        \"\"\"parse a tuple of 3 uint8 values\"\"\"\n        self._assert_is_string(name)\n        frame = self._next_frame()\n        if len(frame) != 3:\n            raise MessageParserError(\"Expected exacty 3 byte for 3 unit8 values\")\n        vals = unpack(\"BBB\", frame)\n        self.results.__dict__[name] = vals\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a uint32 value", "response": "def uint32(self, name):\n        \"\"\"parse a uint32 value\"\"\"\n        self._assert_is_string(name)\n        frame = self._next_frame()\n        if len(frame) != 4:\n            raise MessageParserError(\"Expected exacty 4 byte for uint32 value\")\n        (val,) = unpack(\"!I\", frame)\n        self.results.__dict__[name] = val\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cached_read(self, kind):\n        if not kind in self.cache:\n            self.pull_stats(kind)\n        if self.epochnow() - self.cache[kind]['lastcall'] > self.cache_timeout:\n            self.pull_stats(kind)\n        return self.cache[kind]['lastvalue']", "response": "Get the last value of a cache entry"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn value for specific key", "response": "def get(self, key, name=None):\n        \"\"\"Return value for specific key\"\"\"\n        if name is None:\n            self.nodename = self.local_name\n            self.nodeid = self.local_id\n        else:\n            self.logger.debug('Replacing nodename \"{0}\" with \"{1}\"'.format(self.nodename, name))\n            self.nodename = name\n            self.find_name()\n        return get_value(self.stats(), fix_key(key))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef detect_circle(nodes):\n    # Verify nodes and traveled types\n    if not isinstance(nodes, dict):\n        raise TypeError('\"nodes\" must be a dictionary')\n\n    dependencies = set(nodes.keys())\n    traveled = []\n\n    heads = _detect_circle(nodes, dependencies, traveled)\n\n    return DependencyTree(heads)", "response": "Wrapper for recursive _detect_circle function"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _do(self, nodes):\n        if not isinstance(nodes, dict):\n            raise TypeError('\"nodes\" must be a dictionary')\n\n        if not nodes:\n            # we're done!\n            return\n        starting_num_nodes = len(nodes)\n        newly_instantiated = set()\n\n        # Instantiate services with an empty dependency set\n        for (name, dependency_set) in six.iteritems(nodes):\n            if dependency_set:\n                # Skip non-empty dependency sets\n                continue\n\n            # Instantiate\n            config = self._config[name]\n            service = self._factory.create_from_dict(config)\n            self._factory.add_instantiated_service(name, service)\n\n            newly_instantiated.add(name)\n\n        # We ALWAYS should have instantiated a new service\n        # or we'll end up in an infinite loop.\n        if not newly_instantiated:\n            raise Exception('No newly instantiated services')\n\n        # Remove from Nodes\n        for name in newly_instantiated:\n            del nodes[name]\n\n        # Check if the number of nodes have changed\n        # to prevent infinite loops.\n        # We should ALWAYS have removed a node.\n        if starting_num_nodes == len(nodes):\n            raise Exception('No nodes removed!')\n\n        # Remove newly instantiated services from dependency sets\n        for (name, dependency_set) in six.iteritems(nodes):\n            nodes[name] = dependency_set.difference(newly_instantiated)\n\n        # Recursion is recursion is ...\n        self._do(nodes)", "response": "Recursively creates services and returns the entry - point of the new services."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _init_nodes(self, config):\n        if not isinstance(config, dict):\n            raise TypeError('\"config\" must be a dictionary')\n\n        for (name, conf) in six.iteritems(config):\n            args = [] if 'args' not in conf else conf['args']\n            kwargs = {} if 'kwargs' not in conf else conf['kwargs']\n\n            dependencies = set()\n            arg_deps = self._get_dependencies_from_args(args)\n            kwarg_deps = self._get_dependencies_from_kwargs(kwargs)\n\n            dependencies.update(arg_deps)\n            dependencies.update(kwarg_deps)\n\n            self._nodes[name] = dependencies", "response": "Initializes the _nodes dictionary with the dependencies of the nodes in the config."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_dependencies_from_args(self, args):\n        if not isinstance(args, list):\n            raise TypeError('\"args\" must be a list')\n\n        dependency_names = set()\n        for arg in args:\n            new_names = self._check_arg(arg)\n            dependency_names.update(new_names)\n        return dependency_names", "response": "Parse arguments and return a set of all the dependencies of the user - specified ones."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_dependencies_from_kwargs(self, args):\n        if not isinstance(args, dict):\n            raise TypeError('\"kwargs\" must be a dictionary')\n\n        dependency_names = set()\n        for arg in args.values():\n            new_names = self._check_arg(arg)\n            dependency_names.update(new_names)\n        return dependency_names", "response": "Parse keyed arguments and return a set of dependency names."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck individual argument for dependencies", "response": "def _check_arg(self, arg):\n        \"\"\" Check individual argument (list/tuple/string/etc) \"\"\"\n        if isinstance(arg, list):\n            return self._get_dependencies_from_args(arg)\n        elif isinstance(arg, dict):\n            return self._get_dependencies_from_kwargs(arg)\n\n        if not is_dependency_name(arg):\n            return set()\n        return set([arg[1:]])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load(self, prof_name):\n\t\n\t\t\"\"\"\n\t\tLoad the profile with the given name.\n\t\t\n\t\t:param str prof_name:\n\t\t   Profile name.\n\t\t:rtype:\n\t\t   ProfileStub\n\t\t:return:\n\t\t   An stub to loaded profile.\n\t\t\"\"\"\n\t\t\n\t\tprof_dir = self.__profile_dir(prof_name)\n\t\tprof_ini_path = self.__profile_ini_path(prof_dir)\n\t\tif not os.path.exists(prof_ini_path):\n\t\t\tmsg = \"Profile '{}' does not exist\"\n\t\t\traise Exception(msg.format(prof_name))\n\t\t\t\n\t\t# Load profile\n\t\tprof_ini_file = open(prof_ini_path, \"r\")\n\t\tprof_ini = configparser.ConfigParser()\n\t\tprof_ini.read_file(prof_ini_file)\n\t\tprof_ini_file.close()\n\t\t\n\t\t# Prepare profile\n\t\tprof_type = prof_ini[\"profile\"][\"type\"]\n\t\tprof_stub = self.__profile_stub(prof_name, prof_type, prof_dir)\n\t\tprof_stub.prepare(prof_ini[\"properties\"])\n\t\t\n\t\treturn prof_stub", "response": "Load the profile with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef store(self, prof_name, prof_type):\n\t\n\t\t\"\"\"\n\t\tStore a profile with the given name and type.\n\t\t\n\t\t:param str prof_name:\n\t\t   Profile name.\n\t\t:param str prof_type:\n\t\t   Profile type.\n\t\t\"\"\"\n\t\t\n\t\tprof_dir = self.__profile_dir(prof_name)\n\t\tprof_stub = self.__profile_stub(prof_name, prof_type, prof_dir)\n\t\tif not os.path.exists(prof_dir):\n\t\t\tos.makedirs(prof_dir)\n\t\tprof_ini_path = self.__profile_ini_path(prof_dir)\n\t\t\n\t\t# Load previous properties\n\t\tif os.path.exists(prof_ini_path):\n\t\t\tprof_ini_file = open(prof_ini_path, \"r\")\n\t\t\tprof_ini = configparser.ConfigParser()\n\t\t\tprof_ini.read_file(prof_ini_file)\n\t\t\tprof_ini_file.close()\n\t\t\tprev_props = prof_ini[\"properties\"]\n\t\telse:\n\t\t\tprev_props = {}\n\t\t\t\n\t\t# Prepare and store profile\n\t\tprof_ini = configparser.ConfigParser()\n\t\tprof_ini[\"profile\"] = {}\n\t\tprof_ini[\"profile\"][\"type\"] = prof_type\n\t\tprof_ini[\"properties\"] = prof_stub.prepare(prev_props)\n\t\tprof_ini_file = open(prof_ini_path, \"w\")\n\t\tprof_ini.write(prof_ini_file)\n\t\tprof_ini_file.close()", "response": "Stores a profile with the given name and type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an execution context.", "response": "def context(self):\n\t\n\t\t\"\"\"\n\t\tCreate an exectution context.\n\t\t\n\t\t:rtype:\n\t\t   execution.Context\n\t\t:return:\n\t\t   The created execution context.\n\t\t\"\"\"\n\t\t\n\t\treturn execution.Context(self.__base_dir, self.__prof_dir,\n\t\t\t\tself.__prof_name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef component_list(self):\n\t\n\t\t\"\"\"\n\t\tList of :class:`ComponentStub` instances for this profile.\n\t\t\n\t\t:rtype:\n\t\t   list\n\t\t\"\"\"\n\t\t\n\t\tcomp_list = []\n\t\tself.__component_list(self.component(None), comp_list)\n\t\treturn sorted(comp_list)", "response": "Returns a list of ComponentStub instances for this profile."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nyielding all ComponentStubs that depend on this component.", "response": "def dependencies(self):\n\t\n\t\t\"\"\"\n\t\tYield :class:`ComponentStub` of dependencies of this component.\n\t\t\"\"\"\n\t\t\n\t\ttry:\n\t\t\tfor dep_name in self.__prof.dependencies(self.name()):\n\t\t\t\tyield self.__comp_stub_reg.get(dep_name)\n\t\texcept TypeError:\n\t\t\tyield from ()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef insert(self, context, plan):\n\t\n\t\t\"\"\"\n\t\tInclude an insert operation to the given plan.\n\t\t\n\t\t:param execution.Context context:\n\t\t   Current execution context.\n\t\t:param list plan:\n\t\t   List of :class:`execution.Operation` instances.\n\t\t\"\"\"\n\t\t\n\t\top = execution.Insert(self.__comp_name, self.__comp())\n\t\tif op not in plan and self.available(context) != True:\n\t\t\tfor dep_stub in self.dependencies():\n\t\t\t\tdep_stub.insert(context, plan)\n\t\t\tplan.append(op)", "response": "Insert an operation into the given plan."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete(self, context, plan):\n\t\n\t\t\"\"\"\n\t\tInclude a delete operation to the given plan.\n\t\t\n\t\t:param execution.Context context:\n\t\t   Current execution context.\n\t\t:param list plan:\n\t\t   List of :class:`execution.Operation` instances.\n\t\t\"\"\"\n\t\t\n\t\top = execution.Delete(self.__comp_name, self.__comp())\n\t\tif op not in plan and self.available(context) != False:\n\t\t\tfor dep_stub in self.__dependents(self.__comp_stub_reg.get(None)):\n\t\t\t\tdep_stub.delete(context, plan)\n\t\t\tplan.append(op)", "response": "Include a delete operation to the given plan."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the specified component.", "response": "def get(self, comp_name):\n\t\n\t\t\"\"\"\n\t\tGet the specified component.\n\t\t\n\t\t:param str comp_name:\n\t\t   Specified component name.\n\t\t:rtype:\n\t\t   ComponentStub\n\t\t:return:\n\t\t   Specified component stub.\n\t\t\"\"\"\n\t\t\n\t\ttry:\n\t\t\treturn self.__cache[comp_name]\n\t\texcept KeyError:\n\t\t\tcomp_stub = ComponentStub(self, comp_name, self.__prof)\n\t\t\tself.__cache[comp_name] = comp_stub\n\t\t\treturn comp_stub"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a list of all regions.", "response": "def get_all_regions(db_connection):\n    \"\"\" Gets a list of all regions.\n\n    :return: A list of all regions. Results have regionID and regionName.\n    :rtype: list\n    \"\"\"\n\n    if not hasattr(get_all_regions, '_results'):\n        sql = 'CALL get_all_regions();'\n        results = execute_sql(sql, db_connection)\n        get_all_regions._results = results\n\n    return get_all_regions._results"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_all_not_wh_regions(db_connection):\n\n    if not hasattr(get_all_not_wh_regions, '_results'):\n        sql = 'CALL get_all_not_wh_regions();'\n        results = execute_sql(sql, db_connection)\n        get_all_not_wh_regions._results = results\n\n    return get_all_not_wh_regions._results", "response": "Gets a list of all not WH regions."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of all regions connected to the specified region.", "response": "def get_all_regions_connected_to_region(db_connection, region_id):\n    \"\"\" Gets a list of all regions connected to the region ID passed in.\n\n    :param region_id: Region ID to find all regions connected to.\n    :type region_id: int\n\n    :return: A list of all regions connected to the specified region ID. Results have regionID and regionName.\n    :rtype: list\n    \"\"\"\n\n    sql = 'CALL get_all_regions_connected_to_region({});'.format(region_id)\n    results = execute_sql(sql, db_connection)\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_configuration(configuration):\n    for key, val in REQUIRED_SETTINGS.items():\n        if val in [\"$username\", \"$groupname\"]:\n            val = get_username()\n\n        configuration = conf_writer.add_or_update(configuration, key, val)\n\n    return configuration", "response": "Update the given configuration file content."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new configuration file and the directory where it should be stored and set correct permissions.", "response": "def create_config(cnf_file, uid, overwrite):\n    \"\"\"\n    Creates configuration file and the directory where it should be stored and\n    set correct permissions.\n\n    Args:\n        cnf_file (str): Path to the configuration file.\n        uid (int): User ID - will be used for chown.\n        overwrite (bool): Overwrite the configuration with :attr:`CLEAN_CONFIG`.\n    \"\"\"\n    conf = None\n\n    # needed also on suse, because pyClamd module\n    if not os.path.exists(settings.DEB_CONF_PATH):\n        os.makedirs(settings.DEB_CONF_PATH, 0755)\n        os.chown(settings.DEB_CONF_PATH, uid, -1)\n\n    if not os.path.exists(cnf_file):       # create new conf file\n        conf = CLEAN_CONFIG\n    elif overwrite:                        # ovewrite old conf file\n        backup_name = cnf_file + \"_\"\n        if not os.path.exists(backup_name):\n            shutil.copyfile(cnf_file, backup_name)\n            os.chown(backup_name, uid, -1)\n\n        conf = CLEAN_CONFIG\n    else:                                  # switch variables in existing file\n        with open(cnf_file) as f:\n            conf = f.read()\n\n    # write the conf file\n    with open(cnf_file, \"w\") as f:\n        f.write(update_configuration(conf))\n\n    # permission check (uid)\n    os.chown(cnf_file, uid, -1)\n    os.chmod(cnf_file, 0644)\n\n    symlink = settings.DEB_CONF_PATH + settings.CONF_FILE\n    if not settings.is_deb_system() and not os.path.exists(symlink):\n        os.symlink(cnf_file, symlink)\n        os.chown(symlink, uid, -1)\n        os.chmod(symlink, 0644)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating log file and set necessary permissions.", "response": "def create_log(log_file, uid):\n    \"\"\"\n    Create log file and set necessary permissions.\n\n    Args:\n        log_file (str): Path to the log file.\n        uid (int): User ID - will be used for chown.\n    \"\"\"\n    if not os.path.exists(log_file):  # create new log file\n        dir_name = os.path.dirname(log_file)\n        if not os.path.exists(dir_name):\n            os.makedirs(dir_name, 0755)\n            os.chown(dir_name, uid, -1)\n\n        with open(log_file, \"w\") as f:\n            f.write(\"\")\n\n    os.chown(log_file, uid, -1)\n    os.chmod(log_file, 0640)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates configuration and log file. Restart the daemon when configuration is done.", "response": "def main(conf_file, overwrite, logger):\n    \"\"\"\n    Create configuration and log file. Restart the daemon when configuration\n    is done.\n\n    Args:\n        conf_file (str): Path to the configuration file.\n        overwrite (bool): Overwrite the configuration file with `clean` config?\n    \"\"\"\n    uid = pwd.getpwnam(get_username()).pw_uid\n\n    # stop the daemon\n    logger.info(\"Stopping the daemon.\")\n    sh.service(get_service_name(), \"stop\")\n\n    # create files\n    logger.info(\"Creating config file.\")\n    create_config(\n        cnf_file=conf_file,\n        uid=uid,\n        overwrite=overwrite\n    )\n    logger.info(\"Creating log file.\")\n    create_log(\n        log_file=REQUIRED_SETTINGS[\"LogFile\"],\n        uid=uid\n    )\n\n    # start the daemon\n    logger.info(\"Starting the daemon..\")\n    sh.service(get_service_name(), \"start\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setup_debug_logging():\n\n    logger = logging.getLogger(\"xbahn\")\n    logger.setLevel(logging.DEBUG)\n\n    ch = logging.StreamHandler()\n    ch.setLevel(logging.DEBUG)\n    ch.setFormatter(logging.Formatter(\"%(name)s: %(message)s\"))\n\n    logger.addHandler(ch)", "response": "set up debug logging"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef shell(ctx):\n\n    shell = code.InteractiveConsole({\"engineer\": getattr(ctx.parent, \"widget\", None)})\n    shell.interact(\"\\n\".join([\n        \"Engineer connected to %s\" % ctx.parent.params[\"host\"],\n        \"Dispatch available through the 'engineer' object\"\n    ]))", "response": "Open an engineer shell"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef engineer_list_commands(self):\n\n        \"\"\"\n        Returns a list of all api end points (commands) exposed\n        to engineer\n        \"\"\"\n\n        rv = []\n        for k in dir(self):\n            attr = getattr(self,k)\n            if type(getattr(attr, \"engineer\", None)) == dict:\n                rv.append(k)\n        return rv", "response": "Returns a list of all api end points exposed to engineer\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the engineer command information for the specified engineer action", "response": "def engineer_info(self, action):\n\n        \"\"\"\n        Returns:\n            dict: engineer command information\n                - arguments (list<dict>): command arguments\n                    - args (list):  args to pass through to click.argument\n                    - kwargs (dict): keyword arguments to pass through to click.argument\n                - options (list<dict>): command options\n                    - args (list):  args to pass through to click.option\n                    - kwargs (dict): keyword options to pass through to click.option\n        \"\"\"\n\n        fn = getattr(self, action, None)\n        if not fn:\n            raise AttributeError(\"Engineer action not found: %s\" % action)\n        if not hasattr(fn, \"engineer\"):\n            raise AttributeError(\"Engineer action not exposed: %s\" % action)\n\n        return fn.engineer"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef connect(self, ctx):\n\n        \"\"\"\n        establish xbahn connection and store on click context\n        \"\"\"\n\n        if hasattr(ctx,\"conn\") or \"host\" not in ctx.params:\n            return\n\n        ctx.conn = conn = connect(ctx.params[\"host\"])\n        lnk = link.Link()\n        lnk.wire(\"main\", receive=conn, send=conn)\n        ctx.client = api.Client(link=lnk)\n        ctx.widget = ClientWidget(ctx.client, \"engineer\")", "response": "Establish xbahn connection and store on click context\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_commands(self, ctx):\n\n        \"\"\"\n        list all commands exposed to engineer\n        \"\"\"\n\n\n        self.connect(ctx)\n\n        if not hasattr(ctx, \"widget\"):\n            return super(Engineer, self).list_commands(ctx)\n\n        return ctx.widget.engineer_list_commands() + super(Engineer, self).list_commands(ctx)", "response": "list all commands exposed to engineer"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets click command from engineer exposed xbahn command specs", "response": "def get_command(self, ctx, name):\n\n        \"\"\"\n        get click command from engineer exposed xbahn command specs\n        \"\"\"\n\n        # connect to xbahn\n        self.connect(ctx)\n\n        if not hasattr(ctx, \"widget\") or name in [\"shell\"]:\n            return super(Engineer, self).get_command(ctx, name)\n\n        if name == \"--help\":\n            return None\n\n        # get the command specs (description, arguments and options)\n        info = ctx.widget.engineer_info(name)\n\n        # make command from specs\n        return self.make_command(ctx, name, info)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_command(self, ctx, name, info):\n\n        \"\"\"\n        make click sub-command from command info\n        gotten from xbahn engineer\n        \"\"\"\n\n        @self.command()\n        @click.option(\"--debug/--no-debug\", default=False, help=\"Show debug information\")\n        @doc(info.get(\"description\"))\n        def func(*args, **kwargs):\n            if \"debug\" in kwargs:\n                del kwargs[\"debug\"]\n            fn = getattr(ctx.widget, name)\n            result = fn(*args, **kwargs)\n            click.echo(\"%s: %s> %s\" % (ctx.params[\"host\"],name,result))\n            ctx.conn.close()\n\n        ctx.info_name = \"%s %s\" % (ctx.info_name , ctx.params[\"host\"])\n\n        for a in info.get(\"arguments\",[]):\n            deco = click.argument(*a[\"args\"], **a[\"kwargs\"])\n            func = deco(func)\n        for o in info.get(\"options\",[]):\n            deco = click.option(*o[\"args\"], **o[\"kwargs\"])\n            func = deco(func)\n\n        return func", "response": "make click sub - command from info"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a message to a chat", "response": "def sendMessage(self,chat_id,text,parse_mode=None,disable_web=None,reply_msg_id=None,markup=None):\n\t\t''' On failure returns False\n\t\tOn success returns Message Object '''\n\t\tpayload={'chat_id' : chat_id, 'text' : text, 'parse_mode': parse_mode , 'disable_web_page_preview' : disable_web , 'reply_to_message_id' : reply_msg_id}\n\t\t\n\t\tif(markup):\n\t\t\tpayload['reply_markup']=json.dumps(markup)\n\t\t\t\n\t\tresponse_str = self._command('sendMessage',payload,method='post')\n\t\t\n\t\treturn _validate_response_msg(response_str)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef if_callable_call_with_formatted_string(callback, formattable_string, *args):\n    try:\n        formatted_string = formattable_string.format(*args)\n    except IndexError:\n        raise ValueError(\"Mismatch metween amount of insertion points in the formattable string\\n\"\n                         \"and the amount of args given.\")\n    if callable(callback):\n        callback(formatted_string)", "response": "Calls the callback with the formatted string with the args and makes a call."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef feeling_lucky(cls, obj):\n        if isinstance(obj, six.string_types):\n            return cls.from_str(obj)\n        elif isinstance(obj, six.integer_types) and obj <= MAX_POSIX_TIMESTAMP:\n            return cls.from_posix_timestamp(obj)\n        elif isinstance(obj, datetime):\n            return cls.from_datetime(obj)\n        else:\n            raise ValueError(\n                u\"Don't know how to get timestamp from '{}'\".format(obj)\n            )", "response": "Tries to convert given object to an UTC timestamp is ms based\n            on its type."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fix_mispelled_day(cls, timestr):\n        day_extraction = cls.START_WITH_DAY_OF_WEEK.match(timestr)\n        if day_extraction is not None:\n            day = day_extraction.group(1).lower()\n            if len(day) == 3:\n                dataset = DAYS_ABBR\n            else:\n                dataset = DAYS\n            if day not in dataset:\n                days = list(dataset)\n                days.sort(key=lambda e: levenshtein(day, e))\n                return days[0] + day_extraction.group(2)", "response": "fix mispelled day when written in english\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting rid of parenthesis around timezone", "response": "def remove_parenthesis_around_tz(cls, timestr):\n        \"\"\"get rid of parenthesis around timezone: (GMT) => GMT\n\n        :return: the new string if parenthesis were found, `None` otherwise\n        \"\"\"\n        parenthesis = cls.TIMEZONE_PARENTHESIS.match(timestr)\n        if parenthesis is not None:\n            return parenthesis.group(1)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove quotes around timezone otherwise dateutil. parser. parse raises", "response": "def remove_quotes_around_tz(cls, timestr):\n        \"\"\"Remove quotes (single and double) around timezone otherwise\n        `dateutil.parser.parse` raises\n        \"\"\"\n        quoted = cls.QUOTED_TIMEZONE.match(timestr)\n        if quoted is not None:\n            return quoted.group(1) + quoted.group(2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_timezone(cls, timestr):\n        if re.match(r\".*[\\-+]?\\d{2}:\\d{2}$\", timestr):\n            return re.sub(\n                r\"(.*)(\\s[\\+-]?\\d\\d:\\d\\d)$\",\n                r\"\\1\",\n                timestr\n            )", "response": "Completely remove timezone information from a string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fix_timezone_separator(cls, timestr):\n        tz_sep = cls.TIMEZONE_SEPARATOR.match(timestr)\n        if tz_sep is not None:\n            return tz_sep.group(1) + tz_sep.group(2) + ':' + tz_sep.group(3)\n        return timestr", "response": "Replace invalid timezone separator to prevent\n        dateutil. parser. parse to raise."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nusing dateutil module to parse the given string and return a new object.", "response": "def from_str(cls, timestr, shaked=False):\n        \"\"\"Use `dateutil` module to parse the give string\n\n        :param basestring timestr: string representing a date to parse\n        :param bool shaked: whether the input parameter been already\n        cleaned or not.\n        \"\"\"\n        orig = timestr\n        if not shaked:\n            timestr = cls.fix_timezone_separator(timestr)\n        try:\n            date = parser.parse(timestr)\n        except ValueError:\n            if not shaked:\n                shaked = False\n                for shaker in [\n                        cls.fix_mispelled_day,\n                        cls.remove_parenthesis_around_tz,\n                        cls.remove_quotes_around_tz]:\n                    new_timestr = shaker(timestr)\n                    if new_timestr is not None:\n                        timestr = new_timestr\n                        shaked = True\n                if shaked:\n                    try:\n                        return cls.from_str(timestr, shaked=True)\n                    except ValueError:\n                        # raise ValueError below with proper message\n                        pass\n            msg = u\"Unknown string format: {!r}\".format(orig)\n            raise ValueError(msg), None, sys.exc_info()[2]\n        else:\n            try:\n                return cls.from_datetime(date)\n            except ValueError:\n                new_str = cls.remove_timezone(orig)\n                if new_str is not None:\n                    return cls.from_str(new_str)\n                else:\n                    raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef next_redirect(request, fallback, **get_kwargs):\n    next = request.POST.get('next')\n    if not is_safe_url(url=next, allowed_hosts=request.get_host()):\n        next = resolve_url(fallback)\n\n    if get_kwargs:\n        if '#' in next:\n            tmp = next.rsplit('#', 1)\n            next = tmp[0]\n            anchor = '#' + tmp[1]\n        else:\n            anchor = ''\n\n        joiner = ('?' in next) and '&' or '?'\n        next += joiner + urlencode(get_kwargs) + anchor\n    return HttpResponseRedirect(next)", "response": "This function handles the where should I go next? part of comment views."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef confirmation_view(template, doc=\"Display a confirmation view.\"):\n    def confirmed(request):\n        comment = None\n        if 'c' in request.GET:\n            try:\n                comment = comments.get_model().objects.get(pk=request.GET['c'])\n            except (ObjectDoesNotExist, ValueError):\n                pass\n        return render(request, template, {'comment': comment})\n\n    confirmed.__doc__ = textwrap.dedent(\"\"\"\\\n        %s\n\n        Templates: :template:`%s``\n        Context:\n            comment\n                The posted comment\n        \"\"\" % (doc, template)\n    )\n    return confirmed", "response": "Return a confirmation view generator for the comment was\n    posted flagged deleted approved views."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check(self, password: str) -> bool:\n        return (\n            pbkdf2_sha512.verify(password, self.password) or\n            pbkdf2_sha512.verify(password,\n                                 pbkdf2_sha512.encrypt(self.api_key))\n        )", "response": "Checks the given password with the one stored\n        in the database and returns True if the password is valid False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if complex exists in our database.", "response": "def complex_exists(self, complex: str) -> bool:\n        \"\"\"\n        Shortcut to check if complex exists in our database.\n        \"\"\"\n        try:\n            self.check_complex(complex)\n        except exceptions.RumetrComplexNotFound:\n            return False\n\n        return True"}
