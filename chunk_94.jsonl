{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef handle_memory(self, pkt):\n        self.logger.debug(\"handle memory\")\n\n        # get the frame number, we start from 0\n        self.frame = self.decode_frameno(pkt.z & 0o7777) - 1\n        try:\n            fb = self.server.controller.get_frame(self.frame)\n        except KeyError:\n            # the selected frame does not exist, create it\n            fb = self.server.controller.init_frame(self.frame)\n\n        self.x = pkt.x & XYMASK\n        self.y = pkt.y & XYMASK\n        self.logger.debug(\"memory frame=%d x,y=%d,%d fb width=%s height=%s\" % (\n            self.frame, self.x, self.y, fb.width, fb.height))\n\n        if (pkt.tid & IIS_READ):\n            self.logger.debug(\"start memory read\")\n\n            # read the data and send back to server\n            start = self.x + self.y * fb.width\n            end = start + pkt.nbytes\n            data = fb.buffer[start:end]\n            if len(data) != pkt.nbytes:\n                self.logger.warning(\"buffer length/packet size mismatch: %d != %d\" % (\n                    len(data), pkt.nbytes))\n            #data.reverse()\n            #self.logger.debug(\"DATA=%s\" % str(data))\n            buf = data.tostring()\n            pkt.dataout.write(buf)\n            pkt.dataout.flush()\n            self.logger.debug(\"end memory read\")\n\n        else:\n            self.logger.debug(\"start memory write\")\n            # read the data from socket\n            self.logger.debug(\"data bytes=%d needs_update=%s\" % (\n                pkt.nbytes, self.needs_update))\n            if (fb.width is not None) and (fb.height is not None):\n                if not self.needs_update:\n                    #del fb.buffer\n                    #fb.buffer = array.array('B', ' ' * fb.width * fb.height)\n                    if len(fb.buffer) != fb.width * fb.height:\n                        fb.buffer = array.array('B', '\\000' * fb.width * fb.height)\n                        #self.needs_update = True\n                start = self.x + self.y * fb.width\n                end = start + pkt.nbytes\n                fb.buffer[start:end] = array.array('B', pkt.datain.read(pkt.nbytes))\n            else:\n                self.logger.warning(\"uninitialized framebuffer frame=%d\" % (\n                    self.frame))\n                if not self.needs_update:\n                    # init the framebuffer\n                    fb.buffer.fromstring(pkt.datain.read(pkt.nbytes))\n                    fb.buffer.reverse()\n                    #self.needs_update = True\n                else:\n                    data = array.array('B', pkt.datain.read(pkt.nbytes))\n                    data.reverse()\n                    fb.buffer += data\n\n            self.needs_update = True\n            self.logger.debug(\"end memory write\")", "response": "This part of the protocol is used by IRAF to read and write image data in memory."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef handle(self):\n        self.logger = self.server.logger\n\n        # create a packet structure\n        packet = iis()\n        packet.datain = self.rfile\n        packet.dataout = self.wfile\n\n        # decode the header\n        size = struct.calcsize('8h')\n        line = packet.datain.read(size)\n        n = len(line)\n        if n < size:\n            return\n\n        while n > 0:\n            try:\n                bytes = struct.unpack('8h', line)\n            except Exception:\n                self.logger.error('error unpacking the data.')\n                for exctn in sys.exc_info():\n                    print(exctn)\n\n            # TODO: verify checksum\n\n            # decode the packet fields\n            subunit = bytes[2]\n            subunit077 = subunit & 0o77\n            tid = bytes[0]\n            x = bytes[4] & 0o177777\n            y = bytes[5] & 0o177777\n            z = bytes[6] & 0o177777\n            t = bytes[7] & 0o17777\n            ndatabytes = - bytes[1]\n\n            # are the bytes packed?\n            if (not(tid & PACKED)):\n                ndatabytes *= 2\n\n            # populate the packet structure\n            packet.subunit = subunit\n            packet.subunit077 = subunit077\n            packet.tid = tid\n            packet.x = x\n            packet.y = y\n            packet.z = z\n            packet.t = t\n            packet.nbytes = ndatabytes\n\n            # decide what to do, depending on the\n            # value of subunit\n            self.logger.debug(\"PACKET IS %o\" % packet.subunit)\n\n            if packet.subunit077 == FEEDBACK:\n                self.handle_feedback(packet)\n\n            elif packet.subunit077 == LUT:\n                self.handle_lut(packet)\n                # read the next packet\n                line = packet.datain.read(size)\n                n = len(line)\n                continue\n\n            elif packet.subunit077 == MEMORY:\n                self.handle_memory(packet)\n                if self.needs_update:\n                    #self.display_image()\n                    pass\n                # read the next packet\n                line = packet.datain.read(size)\n                n = len(line)\n                continue\n\n            elif packet.subunit077 == WCS:\n                self.handle_wcs(packet)\n                line = packet.datain.read(size)\n                n = len(line)\n                continue\n\n            elif packet.subunit077 == IMCURSOR:\n                self.handle_imcursor(packet)\n                line = packet.datain.read(size)\n                n = len(line)\n                continue\n\n            else:\n                self.logger.debug('?NO OP (0%o)' % (packet.subunit077))\n\n            if not (packet.tid & IIS_READ):\n                # OK, discard the rest of the data\n                nbytes = packet.nbytes\n                while nbytes > 0:\n                    # for (nbytes = ndatabytes;  nbytes > 0;  nbytes -= n):\n                    if nbytes < SZ_FIFOBUF:\n                        n = nbytes\n                    else:\n                        n = SZ_FIFOBUF\n                    m = self.rfile.read(n)\n                    if m <= 0:\n                        break\n                    nbytes -= n\n\n            # read the next packet\n            line = packet.datain.read(size)\n            n = len(line)\n            if n < size:\n                return\n        # <--- end of the while (n) loop\n        if self.needs_update:\n            self.display_image()\n            self.needs_update = False", "response": "This function handles the action for the\n            command."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef display_image(self, reset=1):\n        try:\n            fb = self.server.controller.get_frame(self.frame)\n        except KeyError:\n            # the selected frame does not exist, create it\n            fb = self.server.controller.init_frame(self.frame)\n\n        if not fb.height:\n            width = fb.width\n            height = int(len(fb.buffer) / width)\n            fb.height = height\n\n            # display the image\n            if (len(fb.buffer) > 0) and (height > 0):\n                self.server.controller.display(self.frame, width, height,\n                                               True)\n        else:\n            self.server.controller.display(self.frame, fb.width, fb.height,\n                                           False)", "response": "Utility routine used to display an image from a framebuffer."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a callback for image info.", "response": "def add_image_info_cb(self, viewer, channel, image_info):\n        \"\"\"Almost the same as add_image_cb(), except that the image\n        may not be loaded in memory.\n        \"\"\"\n        chname = channel.name\n        name = image_info.name\n        self.logger.debug(\"name=%s\" % (name))\n\n        # Updates of any extant information\n        try:\n            image = channel.get_loaded_image(name)\n        except KeyError:\n            # images that are not yet loaded will show \"N/A\" for keywords\n            image = None\n\n        self.add_image_cb(viewer, chname, image, image_info)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_image_info_cb(self, viewer, channel, image_info):\n        return self.remove_image_cb(viewer, channel.name,\n                                    image_info.name, image_info.path)", "response": "This is the callback function that is called when the image is removed from the database."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling when a channel is added from the main interface. This method is called when a channel is added from the main interface.", "response": "def add_channel_cb(self, viewer, channel):\n        \"\"\"Called when a channel is added from the main interface.\n        Parameter is a channel (a Channel object).\"\"\"\n        chname = channel.name\n\n        # add old highlight set to channel external data\n        channel.extdata.setdefault('contents_old_highlight', set([]))\n\n        # Add the channel to the treeview\n        file_dict = {}\n        self.name_dict.setdefault(chname, file_dict)\n\n        if not self.gui_up:\n            return False\n\n        tree_dict = {chname: {}}\n        if self.gui_up:\n            self.treeview.add_tree(tree_dict)\n\n        self._rebuild_channels()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_channel_cb(self, viewer, channel):\n        chname = channel.name\n        del self.name_dict[chname]\n\n        # Unhighlight\n        un_hilite_set = set([])\n        for path in self._hl_path:\n            if path[0] == chname:\n                un_hilite_set.add(path)\n        self._hl_path -= un_hilite_set\n\n        if self.gui_up:\n            self.recreate_toc()\n\n        self._rebuild_channels()", "response": "Called when a channel is deleted from the main interface."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _highlight_path(self, hl_path, tf):\n        fc = self.settings.get('row_font_color', 'green')\n\n        try:\n            self.treeview.highlight_path(hl_path, tf, font_color=fc)\n        except Exception as e:\n            self.logger.info('Error changing highlight on treeview path '\n                             '({0}): {1}'.format(hl_path, str(e)))", "response": "Highlight or unhighlight a single entry."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef redo(self, channel, image):\n\n        imname = image.get('name', 'none')\n        chname = channel.name\n        # is image in contents tree yet?\n        in_contents = self.is_in_contents(chname, imname)\n\n        # get old highlighted entries for this channel -- will be\n        # an empty set or one key\n        old_highlight = channel.extdata.contents_old_highlight\n\n        # calculate new highlight keys -- again, an empty set or one key\n        if image is not None:\n            key = self._get_hl_key(chname, image)\n            new_highlight = set([key])\n        else:\n            # no image has the focus\n            new_highlight = set([])\n\n        # Only highlights active image in the current channel\n        if self.highlight_tracks_keyboard_focus:\n            if in_contents:\n                self.update_highlights(self._hl_path, new_highlight)\n            self._hl_path = new_highlight\n\n        # Highlight all active images in all channels\n        else:\n            if in_contents:\n                self.update_highlights(old_highlight, new_highlight)\n            channel.extdata.contents_old_highlight = new_highlight\n\n        return True", "response": "This method is called when an image is set in a channel."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef index_to_widget(self, idx):\n        nchild = self.widget.get_nth_page(idx)\n        return self._native_to_child(nchild)", "response": "Returns the child corresponding to idx"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the widget corresponding to idx", "response": "def index_to_widget(self, idx):\n        \"\"\"Returns child corresponding to `idx`\"\"\"\n        nchild = self.mdi_w.get_nth_page(idx)\n        return self._native_to_child(nchild)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_mode_cb(self, mode, tf):\n        if tf:\n            if mode == 'select':\n                mode = 'pick'\n            self.canvas.set_draw_mode(mode)\n            if mode == 'edit':\n                self.edit_select_region()\n        return True", "response": "Called when one of the Select Draw or Edit radio buttons is selected."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmark or unmark a star as selected.", "response": "def mark_selection(self, star, fromtable=False):\n        \"\"\"Mark or unmark a star as selected.  (fromtable)==True if the\n        selection action came from the table (instead of the star plot).\n        \"\"\"\n        self.logger.debug(\"star selected name=%s ra=%s dec=%s\" % (\n            star['name'], star['ra'], star['dec']))\n\n        if star in self.selected:\n            # Item is already selected--so unselect it\n            self.selected.remove(star)\n            try:\n                # remove selection from table\n                self._unselect_tv(star, fromtable=fromtable)\n            except Exception as e:\n                self.logger.warning(\"Error unhilighting star: %s\" % (str(e)))\n\n            self.catalog.update_selected()\n            return False\n        else:\n            if self.selection_mode == 'single':\n                # if selection mode is 'single' unselect any existing selection\n                for star2 in self.selected:\n                    self.selected.remove(star2)\n                    try:\n                        self._unselect_tv(star2, fromtable=fromtable)\n                    except Exception as e:\n                        self.logger.warning(\n                            \"Error unhilighting star: %s\" % (str(e)))\n            self.selected.append(star)\n            try:\n                # highlight line in table\n                self._select_tv(star, fromtable=fromtable)\n                if self.catalog.pan_to_selected:\n                    self.catalog.pan_to_star(star)\n            except Exception as e:\n                self.logger.warning(\"Error hilighting star: %s\" % (str(e)))\n\n            self.catalog.update_selected()\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef show_selection(self, star):\n        try:\n            # NOTE: this works around a quirk of Qt widget set where\n            # selecting programatically in the table triggers the widget\n            # selection callback (see select_star_cb() in Catalogs.py for Qt)\n            self._select_flag = True\n            self.mark_selection(star)\n\n        finally:\n            self._select_flag = False", "response": "This method is called when the user clicks on a plotted star in the\n            table."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the data of the object.", "response": "def set_data(self, data_np, metadata=None, order=None, astype=None):\n        \"\"\"Use this method to SHARE (not copy) the incoming array.\n        \"\"\"\n        if astype:\n            data = data_np.astype(astype, copy=False)\n        else:\n            data = data_np\n        self._data = data\n\n        self._calc_order(order)\n\n        if metadata:\n            self.update_metadata(metadata)\n\n        self._set_minmax()\n\n        self.make_callback('modified')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _calc_order(self, order):\n        if order is not None and order != '':\n            self.order = order.upper()\n        else:\n            shape = self.shape\n            if len(shape) <= 2:\n                self.order = 'M'\n            else:\n                depth = shape[-1]\n                # TODO: need something better here than a guess!\n                if depth == 1:\n                    self.order = 'M'\n                elif depth == 2:\n                    self.order = 'AM'\n                elif depth == 3:\n                    self.order = 'RGB'\n                elif depth == 4:\n                    self.order = 'RGBA'", "response": "Calculates the order of a multi - channel image."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncut out data area based on coords.", "response": "def cutout_data(self, x1, y1, x2, y2, xstep=1, ystep=1, astype=None):\n        \"\"\"cut out data area based on coords.\n        \"\"\"\n        view = np.s_[y1:y2:ystep, x1:x2:xstep]\n        data = self._slice(view)\n        if astype:\n            data = data.astype(astype, copy=False)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cutout_cross(self, x, y, radius):\n        n = radius\n        wd, ht = self.get_size()\n        x0, x1 = max(0, x - n), min(wd - 1, x + n)\n        y0, y1 = max(0, y - n), min(ht - 1, y + n)\n\n        xview = np.s_[y, x0:x1 + 1]\n        yview = np.s_[y0:y1 + 1, x]\n\n        xarr = self._slice(xview)\n        yarr = self._slice(yview)\n\n        return (x0, y0, xarr, yarr)", "response": "Cut two data subarrays that have a center at x y and with a radius from ( image."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_shape_mask(self, shape_obj):\n        wd, ht = self.get_size()\n        yi = np.mgrid[:ht].reshape(-1, 1)\n        xi = np.mgrid[:wd].reshape(1, -1)\n        pts = np.asarray((xi, yi)).T\n        contains = shape_obj.contains_pts(pts)\n        return contains", "response": "Return full mask where True marks pixels within the given shape."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_shape_view(self, shape_obj, avoid_oob=True):\n        x1, y1, x2, y2 = [int(np.round(n)) for n in shape_obj.get_llur()]\n\n        if avoid_oob:\n            # avoid out of bounds indexes\n            wd, ht = self.get_size()\n            x1, x2 = max(0, x1), min(x2, wd - 1)\n            y1, y2 = max(0, y1), min(y2, ht - 1)\n\n        # calculate pixel containment mask in bbox\n        yi = np.mgrid[y1:y2 + 1].reshape(-1, 1)\n        xi = np.mgrid[x1:x2 + 1].reshape(1, -1)\n        pts = np.asarray((xi, yi)).T\n        contains = shape_obj.contains_pts(pts)\n\n        view = np.s_[y1:y2 + 1, x1:x2 + 1]\n        return (view, contains)", "response": "Calculate a view that accesses the shape_obj and a mask that is True only for the pixels enclosed in the region."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncuts out and return a portion of the data corresponding to shape_obj.", "response": "def cutout_shape(self, shape_obj):\n        \"\"\"\n        Cut out and return a portion of the data corresponding to `shape_obj`.\n        A masked numpy array is returned, where the pixels not enclosed in\n        the shape are masked out.\n        \"\"\"\n\n        view, mask = self.get_shape_view(shape_obj)\n\n        # cutout our enclosing (possibly shortened) bbox\n        data = self._slice(view)\n\n        # mask non-containing members\n        mdata = np.ma.array(data, mask=np.logical_not(mask))\n        return mdata"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract a region of the image defined by corners (x1, y1) and (x2, y2) and resample it to fit dimensions (new_wd, new_ht). `method` describes the method of interpolation used, where the default \"basic\" is nearest neighbor.", "response": "def get_scaled_cutout_wdht(self, x1, y1, x2, y2, new_wd, new_ht,\n                               method='basic'):\n        \"\"\"Extract a region of the image defined by corners (x1, y1) and\n        (x2, y2) and resample it to fit dimensions (new_wd, new_ht).\n\n        `method` describes the method of interpolation used, where the\n        default \"basic\" is nearest neighbor.\n        \"\"\"\n\n        if method in ('basic', 'view'):\n            shp = self.shape\n\n            (view, (scale_x, scale_y)) = \\\n                trcalc.get_scaled_cutout_wdht_view(shp, x1, y1, x2, y2,\n                                                   new_wd, new_ht)\n            newdata = self._slice(view)\n\n        else:\n            data_np = self._get_data()\n            (newdata, (scale_x, scale_y)) = \\\n                trcalc.get_scaled_cutout_wdht(data_np, x1, y1, x2, y2,\n                                              new_wd, new_ht,\n                                              interpolation=method,\n                                              logger=self.logger)\n\n        res = Bunch.Bunch(data=newdata, scale_x=scale_x, scale_y=scale_y)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nextract a region of the image defined by corners (x1, y1) and (x2, y2) and scale it by scale factors (scale_x, scale_y). `method` describes the method of interpolation used, where the default \"basic\" is nearest neighbor.", "response": "def get_scaled_cutout_basic(self, x1, y1, x2, y2, scale_x, scale_y,\n                                method='basic'):\n        \"\"\"Extract a region of the image defined by corners (x1, y1) and\n        (x2, y2) and scale it by scale factors (scale_x, scale_y).\n\n        `method` describes the method of interpolation used, where the\n        default \"basic\" is nearest neighbor.\n        \"\"\"\n\n        new_wd = int(round(scale_x * (x2 - x1 + 1)))\n        new_ht = int(round(scale_y * (y2 - y1 + 1)))\n\n        return self.get_scaled_cutout_wdht(x1, y1, x2, y2, new_wd, new_ht,\n                                           # TODO:\n                                           # this causes a problem for the\n                                           # current Glue plugin--update that\n                                           #method=method\n                                           )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_pixels_on_line(self, x1, y1, x2, y2, getvalues=True):\n        # NOTE: seems to be necessary or we get a non-terminating result\n        x1, y1, x2, y2 = int(x1), int(y1), int(x2), int(y2)\n\n        dx = abs(x2 - x1)\n        dy = abs(y2 - y1)\n        if x1 < x2:\n            sx = 1\n        else:\n            sx = -1\n        if y1 < y2:\n            sy = 1\n        else:\n            sy = -1\n        err = dx - dy\n\n        res = []\n        x, y = x1, y1\n        while True:\n            if getvalues:\n                try:\n                    val = self.get_data_xy(x, y)\n                except Exception:\n                    val = np.NaN\n                res.append(val)\n            else:\n                res.append((x, y))\n            if (x == x2) and (y == y2):\n                break\n            e2 = 2 * err\n            if e2 > -dy:\n                err = err - dy\n                x += sx\n            if e2 < dx:\n                err = err + dx\n                y += sy\n\n        return res", "response": "Returns a list of the pixels along a line."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_callback(self, name, fn, *args, **kwargs):\n        try:\n            tup = (fn, args, kwargs)\n            if tup in self.cb[name]:\n                self.cb[name].remove(tup)\n        except KeyError:\n            raise CallbackError(\"No callback category of '%s'\" % (\n                name))", "response": "Remove a specific callback that was added."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a Ginga colormap into a QPixmap", "response": "def cmap2pixmap(cmap, steps=50):\n    \"\"\"Convert a Ginga colormap into a QPixmap\n    \"\"\"\n    import numpy as np\n\n    inds = np.linspace(0, 1, steps)\n    n = len(cmap.clst) - 1\n    tups = [cmap.clst[int(x * n)] for x in inds]\n    rgbas = [QColor(int(r * 255), int(g * 255),\n                    int(b * 255), 255).rgba() for r, g, b in tups]\n    im = QImage(steps, 1, QImage.Format_Indexed8)\n    im.setColorTable(rgbas)\n    for i in range(steps):\n        im.setPixel(i, 0, i)\n    im = im.scaled(128, 32)\n    pm = QPixmap.fromImage(im)\n    return pm"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the number of degrees and direction of a scroll motion Qt event.", "response": "def get_scroll_info(event):\n    \"\"\"\n    Returns the (degrees, direction) of a scroll motion Qt event.\n    \"\"\"\n\n    # 15 deg is standard 1-click turn for a wheel mouse\n    # delta() usually returns 120\n    if have_pyqt5:\n        # TODO: use pixelDelta() for better handling on hi-res devices?\n        point = event.angleDelta()\n        dx, dy = point.x(), point.y()\n        delta = math.sqrt(dx ** 2 + dy ** 2)\n        if dy < 0:\n            delta = -delta\n\n        ang_rad = math.atan2(dy, dx)\n        direction = math.degrees(ang_rad) - 90.0\n        direction = math.fmod(direction + 360.0, 360.0)\n\n    else:\n        delta = event.delta()\n        orientation = event.orientation()\n\n        direction = None\n        if orientation == QtCore.Qt.Horizontal:\n            if delta > 0:\n                direction = 270.0\n            elif delta < 0:\n                direction = 90.0\n        else:\n            if delta > 0:\n                direction = 0.0\n            elif delta < 0:\n                direction = 180.0\n\n    num_degrees = abs(delta) / 8.0\n\n    return (num_degrees, direction)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef popup(self, title, callfn, initialdir=None, filename=None):\n        self.cb = callfn\n        filenames = QtGui.QFileDialog.getOpenFileNames(\n            self.parent, title, initialdir, filename)\n\n        # Special handling for PyQt5, see\n        # https://www.reddit.com/r/learnpython/comments/2xhagb/pyqt5_trouble_with_openinggetting_the_name_of_the/\n        if ginga.toolkit.get_toolkit() == 'qt5':\n            filenames = filenames[0]\n\n        all_paths = []\n        for filename in filenames:\n\n            # Special handling for wildcard or extension.\n            # This is similar to open_files() in FBrowser plugin.\n            if '*' in filename or '[' in filename:\n                info = iohelper.get_fileinfo(filename)\n                ext = iohelper.get_hdu_suffix(info.numhdu)\n                files = glob.glob(info.filepath)  # Expand wildcard\n                paths = ['{0}{1}'.format(f, ext) for f in files]\n                if self.all_at_once:\n                    all_paths.extend(paths)\n                else:\n                    for path in paths:\n                        self.cb(path)\n\n            else:\n                # Normal load\n                if self.all_at_once:\n                    all_paths.append(filename)\n                else:\n                    self.cb(filename)\n\n        if self.all_at_once and len(all_paths) > 0:\n            self.cb(all_paths)", "response": "This method opens a file dialog and returns the file name and the list of loaded files."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef popup(self, title, callfn, initialdir=None):\n        self.cb = callfn\n        dirname = QtGui.QFileDialog.getExistingDirectory(\n            self.parent, title, initialdir)\n        if dirname:\n            self.cb(dirname)", "response": "Let user select a directory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstarting the timer. If `duration` is not None, it should specify the time to expiration in seconds.", "response": "def start(self, duration=None):\n        \"\"\"Start the timer.  If `duration` is not None, it should\n        specify the time to expiration in seconds.\n        \"\"\"\n        if duration is None:\n            duration = self.duration\n\n        self.set(duration)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _snap_cb(self, w):\n        # Clear the snap image viewer\n        self.scrnimage.clear()\n        self.scrnimage.redraw_now(whence=0)\n        self.fv.update_pending()\n\n        format = self.tosave_type\n\n        if self._screen_size:\n            # snap image using actual viewer\n            self.fv.error_wrap(self.fitsimage.save_rgb_image_as_file,\n                               self.tmpname, format=format)\n\n        else:\n            # we will be using shot generator, not actual viewer.\n            # check that shot generator size matches UI params\n            self.check_and_adjust_dimensions()\n\n            # copy background color of viewer to shot generator\n            bg = self.fitsimage.get_bg()\n            self.shot_generator.set_bg(*bg)\n\n            # add the main canvas from channel viewer to shot generator\n            c1 = self.fitsimage.get_canvas()\n            c2 = self.shot_generator.get_canvas()\n            c2.delete_all_objects(redraw=False)\n            c2.add(c1, redraw=False)\n            # hack to fix a few problem graphics\n            self.shot_generator._imgobj = self.fitsimage._imgobj\n\n            # scale of the shot generator should be the scale of channel\n            # viewer multiplied by the ratio of window sizes\n            scale_x, scale_y = self.fitsimage.get_scale_xy()\n            c1_wd, c1_ht = self.fitsimage.get_window_size()\n            c2_wd, c2_ht = self.shot_generator.get_window_size()\n\n            scale_wd = float(c2_wd) / float(c1_wd)\n            scale_ht = float(c2_ht) / float(c1_ht)\n            scale = max(scale_wd, scale_ht)\n            scale_x *= scale\n            scale_y *= scale\n            self.shot_generator.scale_to(scale_x, scale_y)\n\n            self.fitsimage.copy_attributes(self.shot_generator,\n                                           self.transfer_attrs)\n\n            # snap image\n            self.fv.error_wrap(self.shot_generator.save_rgb_image_as_file,\n                               self.tmpname, format=format)\n\n            c2.delete_all_objects(redraw=False)\n            self.shot_generator._imgobj = None\n\n        self.saved_type = format\n        img = RGBImage(logger=self.logger)\n        img.load_file(self.tmpname)\n\n        # load the snapped image into the screenshot viewer\n        self.scrnimage.set_image(img)", "response": "This function is called when the user clicks the Snap button."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _save_cb(self, w):\n        format = self.saved_type\n        if format is None:\n            return self.fv.show_error(\"Please save an image first.\")\n\n        # create filename\n        filename = self.w.name.get_text().strip()\n        if len(filename) == 0:\n            return self.fv.show_error(\"Please set a name for saving the file\")\n        self.save_name = filename\n\n        if not filename.lower().endswith('.' + format):\n            filename = filename + '.' + format\n\n        # join to path\n        path = self.w.folder.get_text().strip()\n        if path == '':\n            path = filename\n        else:\n            self.save_path = path\n            path = os.path.join(path, filename)\n\n        # copy last saved file\n        self.fv.error_wrap(shutil.copyfile, self.tmpname, path)", "response": "This function is called when the user clicks the Save button. We save the last taken shot to the folder and name specified."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _lock_aspect_cb(self, w, tf):\n        self._lock_aspect = tf\n        self.w.aspect.set_enabled(tf)\n        if self._lock_aspect:\n            self._set_aspect_cb()\n        else:\n            wd, ht = self.get_wdht()\n            _as = self.calc_aspect_str(wd, ht)\n            self.w.aspect.set_text(_as)", "response": "This function is called when the user clicks the Lock aspect checkbox. tf is True if checked False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _screen_size_cb(self, w, tf):\n        self._screen_size = tf\n        self.w.width.set_enabled(not tf)\n        self.w.height.set_enabled(not tf)\n        self.w.lock_aspect.set_enabled(not tf)\n        if self._screen_size:\n            wd, ht = self.fitsimage.get_window_size()\n            self._configure_cb(self.fitsimage, wd, ht)", "response": "This function is called when the user clicks the Screen size checkbox. tf is True if checked False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading an ASDF object into a tuple of data WCS and header.", "response": "def load_asdf(asdf_obj, data_key='sci', wcs_key='wcs', header_key='meta'):\n    \"\"\"\n    Load from an ASDF object.\n\n    Parameters\n    ----------\n    asdf_obj : obj\n        ASDF or ASDF-in-FITS object.\n\n    data_key, wcs_key, header_key : str\n        Key values to specify where to find data, WCS, and header\n        in ASDF.\n\n    Returns\n    -------\n    data : ndarray or `None`\n        Image data, if found.\n\n    wcs : obj or `None`\n        GWCS object or models, if found.\n\n    ahdr : dict\n        Header containing metadata.\n\n    \"\"\"\n    asdf_keys = asdf_obj.keys()\n\n    if wcs_key in asdf_keys:\n        wcs = asdf_obj[wcs_key]\n    else:\n        wcs = None\n\n    if header_key in asdf_keys:\n        ahdr = asdf_obj[header_key]\n    else:\n        ahdr = {}\n\n    # TODO: What about non-image ASDF data, such as table?\n    if data_key in asdf_keys:\n        data = np.asarray(asdf_obj[data_key])\n    else:\n        data = None\n\n    return data, wcs, ahdr"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads an object from an ASDF file.", "response": "def loader(filepath, logger=None, **kwargs):\n    \"\"\"\n    Load an object from an ASDF file.\n    See :func:`ginga.util.loader` for more info.\n\n    TODO: kwargs may contain info about what part of the file to load\n    \"\"\"\n    # see ginga.util.loader module\n    # TODO: return an AstroTable if loading a table, etc.\n    #   for now, assume always an image\n    from ginga import AstroImage\n    image = AstroImage.AstroImage(logger=logger)\n\n    with asdf.open(filepath) as asdf_f:\n        #image.load_asdf(asdf_f, **kwargs)\n        image.load_asdf(asdf_f)\n\n    return image"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchanges the ColorBar s rgbmap to match the cut levels or rgbmap used in a ginga ImageView.", "response": "def _match_cmap(self, fitsimage, colorbar):\n        \"\"\"\n        Help method to change the ColorBar to match the cut levels or\n        colormap used in a ginga ImageView.\n        \"\"\"\n        rgbmap = fitsimage.get_rgbmap()\n        loval, hival = fitsimage.get_cut_levels()\n        colorbar.set_range(loval, hival)\n        # If we are sharing a ColorBar for all channels, then store\n        # to change the ColorBar's rgbmap to match our\n        colorbar.set_rgbmap(rgbmap)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef change_range_cb(self, setting, value, fitsimage):\n        if not self.gui_up:\n            return\n        if fitsimage != self.fv.getfocus_viewer():\n            # values have changed in a channel that doesn't have the focus\n            return False\n        loval, hival = value\n        self.colorbar.set_range(loval, hival)", "response": "This method is called when the cut level values have changed in a channel. We adjust them in the ColorBar to match the cut level values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cbar_value_cb(self, cbar, value, event):\n        if self.cursor_obj is not None:\n            readout = self.cursor_obj.readout\n            if readout is not None:\n                maxv = readout.maxv\n                text = \"Value: %-*.*s\" % (maxv, maxv, value)\n                readout.set_text(text)", "response": "This method is called when the user clicks the mouse over the color bar and the user clicks the value in the ColorBar. It displays the value in the Readout if any."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rgbmap_cb(self, rgbmap, channel):\n        if not self.gui_up:\n            return\n        fitsimage = channel.fitsimage\n        if fitsimage != self.fv.getfocus_fitsimage():\n            return False\n        self.change_cbar(self.fv, channel)", "response": "This method is called when the RGBMap is changed. We update the ColorBar to match the ColorBar."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef show_pan_mark(viewer, tf, color='red'):\n    tag = '_$pan_mark'\n    radius = 10\n\n    canvas = viewer.get_private_canvas()\n    try:\n        mark = canvas.get_object_by_tag(tag)\n        if not tf:\n            canvas.delete_object_by_tag(tag)\n        else:\n            mark.color = color\n\n    except KeyError:\n        if tf:\n            Point = canvas.get_draw_class('point')\n            canvas.add(Point(0, 0, radius, style='plus', color=color,\n                             coord='cartesian'),\n                       tag=tag, redraw=False)\n\n    canvas.update_canvas(whence=3)", "response": "Show a pan mark in the center of window."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshows a keyboard mode indicator in one of the corners.", "response": "def show_mode_indicator(viewer, tf, corner='ur'):\n    \"\"\"Show a keyboard mode indicator in one of the corners.\n\n    Parameters\n    ----------\n    viewer : an ImageView subclass instance\n        If True, show the color bar; else remove it if present.\n\n    tf : bool\n        If True, show the mark; else remove it if present.\n\n    corner : str\n        One of 'll', 'lr', 'ul' or 'ur' selecting a corner.\n        The default is 'ur'.\n\n    \"\"\"\n    tag = '_$mode_indicator'\n\n    canvas = viewer.get_private_canvas()\n    try:\n        indic = canvas.get_object_by_tag(tag)\n        if not tf:\n            canvas.delete_object_by_tag(tag)\n        else:\n            indic.corner = corner\n\n    except KeyError:\n        if tf:\n            # force a redraw if the mode changes\n            bm = viewer.get_bindmap()\n            bm.add_callback('mode-set',\n                            lambda *args: viewer.redraw(whence=3))\n\n            Indicator = canvas.get_draw_class('modeindicator')\n            canvas.add(Indicator(corner=corner),\n                       tag=tag, redraw=False)\n\n    canvas.update_canvas(whence=3)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_color_bar(viewer, tf, side='bottom'):\n\n    tag = '_$color_bar'\n    canvas = viewer.get_private_canvas()\n    try:\n        cbar = canvas.get_object_by_tag(tag)\n        if not tf:\n            canvas.delete_object_by_tag(tag)\n        else:\n            cbar.side = side\n\n    except KeyError:\n        if tf:\n            Cbar = canvas.get_draw_class('colorbar')\n            canvas.add(Cbar(side=side), tag=tag, redraw=False)\n\n    canvas.update_canvas(whence=3)", "response": "Show a color bar in the window."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_focus_indicator(viewer, tf, color='white'):\n\n    tag = '_$focus_indicator'\n    canvas = viewer.get_private_canvas()\n    try:\n        fcsi = canvas.get_object_by_tag(tag)\n        if not tf:\n            canvas.delete_object_by_tag(tag)\n        else:\n            fcsi.color = color\n\n    except KeyError:\n        if tf:\n            Fcsi = canvas.get_draw_class('focusindicator')\n            fcsi = Fcsi(color=color)\n            canvas.add(fcsi, tag=tag, redraw=False)\n            viewer.add_callback('focus', fcsi.focus_cb)\n\n    canvas.update_canvas(whence=3)", "response": "Show a focus indicator in the window."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds zoom buttons to a private canvas.", "response": "def add_zoom_buttons(viewer, canvas=None, color='black'):\n    \"\"\"Add zoom buttons to a canvas.\n\n    Parameters\n    ----------\n    viewer : an ImageView subclass instance\n        If True, show the color bar; else remove it if present.\n\n    canvas : a DrawingCanvas instance\n        The canvas to which the buttons should be added.  If not supplied\n        defaults to the private canvas of the viewer.\n\n    color : str\n        A color name, hex triplet. The default is 'black'.\n\n    \"\"\"\n    def zoom(box, canvas, event, pt, viewer, n):\n        zl = viewer.get_zoom()\n        zl += n\n        if zl == 0.0:\n            zl += n\n        viewer.zoom_to(zl + n)\n\n    def add_buttons(viewer, canvas, tag):\n        objs = []\n        wd, ht = viewer.get_window_size()\n        SquareBox = canvas.get_draw_class('squarebox')\n        Text = canvas.get_draw_class('text')\n        Compound = canvas.get_draw_class('compoundobject')\n        x1, y1 = wd - 20, ht // 2 + 20\n        zoomin = SquareBox(x1, y1, 15, color='yellow', fill=True,\n                           fillcolor='gray', fillalpha=0.5, coord='window')\n        zoomin.editable = False\n        zoomin.pickable = True\n        zoomin.add_callback('pick-down', zoom, viewer, 1)\n        objs.append(zoomin)\n        x2, y2 = wd - 20, ht // 2 - 20\n        zoomout = SquareBox(x2, y2, 15, color='yellow', fill=True,\n                            fillcolor='gray', fillalpha=0.5, coord='window')\n        zoomout.editable = False\n        zoomout.pickable = True\n        zoomout.add_callback('pick-down', zoom, viewer, -1)\n        objs.append(zoomout)\n        objs.append(Text(x1 - 4, y1 + 6, text='+', fontsize=18, color=color,\n                         coord='window'))\n        objs.append(Text(x2 - 4, y2 + 6, text='--', fontsize=18, color=color,\n                         coord='window'))\n        obj = Compound(*objs)\n        obj.opaque = False\n        canvas.add(obj, tag=tag)\n\n    def zoom_resize(viewer, width, height, canvas, tag):\n        try:\n            canvas.get_object_by_tag(tag)\n        except KeyError:\n            return False\n\n        canvas.delete_object_by_tag(tag)\n        add_buttons(viewer, canvas, tag)\n\n    tag = '_$zoom_buttons'\n    if canvas is None:\n        canvas = viewer.get_private_canvas()\n    canvas.ui_set_active(True)\n    canvas.register_for_cursor_drawing(viewer)\n    canvas.set_draw_mode('pick')\n    viewer.add_callback('configure', zoom_resize, canvas, tag)\n\n    add_buttons(viewer, canvas, tag)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef search(self, **params):\n\n        self.logger.debug(\"search params=%s\" % (str(params)))\n        ra, dec = params['ra'], params['dec']\n        if not (':' in ra):\n            # Assume RA and DEC are in degrees\n            ra_deg = float(ra)\n            dec_deg = float(dec)\n        else:\n            # Assume RA and DEC are in standard string notation\n            ra_deg = wcs.hmsStrToDeg(ra)\n            dec_deg = wcs.dmsStrToDeg(dec)\n\n        # Convert to degrees for search radius\n        radius_deg = float(params['r']) / 60.0\n        # radius_deg = float(params['r'])\n\n        # Note requires astropy 0.3.x+\n        c = coordinates.SkyCoord(ra_deg * units.degree,\n                                 dec_deg * units.degree,\n                                 frame='icrs')\n        self.logger.info(\"Querying catalog: %s\" % (self.full_name))\n        time_start = time.time()\n        with warnings.catch_warnings():  # Ignore VO warnings\n            warnings.simplefilter('ignore')\n            results = conesearch.conesearch(\n                c, radius_deg * units.degree, catalog_db=self.full_name,\n                verbose=False)\n        time_elapsed = time.time() - time_start\n        numsources = results.array.size\n        self.logger.info(\"Found %d sources in %.2f sec\" % (\n            numsources, time_elapsed))\n\n        # Scan the returned fields to find ones we need to extract\n        # particulars from (ra, dec, id, magnitude)\n        mags = []\n        ext = {}\n        fields = results.array.dtype.names\n        for name in fields:\n            ucd = results.get_field_by_id(name).ucd\n            ucd = str(ucd).lower()\n            if ucd == 'id_main':\n                ext['id'] = name\n            elif ucd == 'pos_eq_ra_main':\n                ext['ra'] = name\n            elif ucd == 'pos_eq_dec_main':\n                ext['dec'] = name\n            if ('phot_' in ucd) or ('phot.' in ucd):\n                mags.append(name)\n        self.logger.debug(\"possible magnitude fields: %s\" % str(mags))\n        if len(mags) > 0:\n            magfield = mags[0]\n        else:\n            magfield = None\n\n        # prepare the result list\n        starlist = []\n        arr = results.array\n        for i in range(numsources):\n            source = dict(zip(fields, arr[i]))\n            starlist.append(self.toStar(source, ext, magfield))\n\n        # metadata about the list\n        columns = [('Name', 'name'),\n                   ('RA', 'ra'),\n                   ('DEC', 'dec'),\n                   ('Mag', 'mag'),\n                   ('Preference', 'preference'),\n                   ('Priority', 'priority'),\n                   ('Description', 'description'),\n                   ]\n        # Append extra columns returned by search to table header\n        # TODO: what if not all sources have same record structure?\n        # is this possible with VO?\n        cols = list(fields)\n        cols.remove(ext['ra'])\n        cols.remove(ext['dec'])\n        cols.remove(ext['id'])\n        columns.extend(zip(cols, cols))\n\n        # which column is the likely one to color source circles\n        colorCode = 'Mag'\n\n        info = Bunch.Bunch(columns=columns, color=colorCode)\n        return starlist, info", "response": "Search for VO in the catalog."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef search(self, dstpath, **params):\n\n        self.logger.debug(\"search params=%s\" % (str(params)))\n        ra, dec = params['ra'], params['dec']\n        if not (':' in ra):\n            # Assume RA and DEC are in degrees\n            ra_deg = float(ra)\n            dec_deg = float(dec)\n        else:\n            # Assume RA and DEC are in standard string notation\n            ra_deg = wcs.hmsStrToDeg(ra)\n            dec_deg = wcs.dmsStrToDeg(dec)\n\n        # Convert to degrees for search\n        wd_deg = float(params['width']) / 60.0\n        ht_deg = float(params['height']) / 60.0\n\n        # Note requires astropy 3.x+\n        c = coordinates.SkyCoord(ra_deg * units.degree,\n                                 dec_deg * units.degree,\n                                 frame='icrs')\n        self.logger.info(\"Querying catalog: %s\" % (self.full_name))\n        # time_start = time.time()\n        results = self.querymod.get_image_list(\n            c, image_width=wd_deg * units.degree,\n            image_height=ht_deg * units.degree)\n        # time_elapsed = time.time() - time_start\n\n        if len(results) > 0:\n            self.logger.info(\"Found %d images\" % len(results))\n        else:\n            self.logger.warning(\"Found no images in this area\" % len(results))\n            return None\n\n        # For now, we pick the first one found\n        url = results[0]\n        # fitspath = results[0].make_dataset_filename(dir=\"/tmp\")\n\n        # TODO: download file\n        fitspath = url\n\n        # explicit return\n        return fitspath", "response": "Search the image catalog for the image in the specified path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsearch for the related items in the service.", "response": "def search(self, **params):\n        \"\"\"\n        For compatibility with generic star catalog search.\n        \"\"\"\n\n        self.logger.debug(\"search params=%s\" % (str(params)))\n        ra, dec = params['ra'], params['dec']\n        if not (':' in ra):\n            # Assume RA and DEC are in degrees\n            ra_deg = float(ra)\n            dec_deg = float(dec)\n        else:\n            # Assume RA and DEC are in standard string notation\n            ra_deg = wcs.hmsStrToDeg(ra)\n            dec_deg = wcs.dmsStrToDeg(dec)\n\n        # Convert to degrees for search radius\n        radius_deg = float(params['r']) / 60.0\n        # radius_deg = float(params['r'])\n\n        # initialize our query object with the service's base URL\n        query = pyvo.scs.SCSQuery(self.url)\n        query.ra = ra_deg\n        query.dec = dec_deg\n        query.radius = radius_deg\n        self.logger.info(\"Will query: %s\" % query.getqueryurl(True))\n\n        time_start = time.time()\n        results = query.execute()\n        time_elapsed = time.time() - time_start\n\n        numsources = len(results)\n        self.logger.info(\"Found %d sources in %.2f sec\" % (\n            numsources, time_elapsed))\n\n        # Scan the returned fields to find ones we need to extract\n        # particulars from (ra, dec, id, magnitude)\n        mags = []\n        ext = {}\n        fields = results.fielddesc()\n        for field in fields:\n            ucd = str(field.ucd).lower()\n            if ucd == 'id_main':\n                ext['id'] = field.name\n            elif ucd == 'pos_eq_ra_main':\n                ext['ra'] = field.name\n            elif ucd == 'pos_eq_dec_main':\n                ext['dec'] = field.name\n            if ('phot_' in ucd) or ('phot.' in ucd):\n                mags.append(field.name)\n        self.logger.debug(\"possible magnitude fields: %s\" % str(mags))\n        if len(mags) > 0:\n            magfield = mags[0]\n        else:\n            magfield = None\n\n        self.logger.info(\"Found %d sources\" % len(results))\n\n        starlist = []\n        for source in results:\n            data = dict(source.items())\n            starlist.append(self.toStar(data, ext, magfield))\n\n        # metadata about the list\n        columns = [('Name', 'name'),\n                   ('RA', 'ra'),\n                   ('DEC', 'dec'),\n                   ('Mag', 'mag'),\n                   ('Preference', 'preference'),\n                   ('Priority', 'priority'),\n                   ('Description', 'description'),\n                   ]\n        # Append extra columns returned by search to table header\n        cols = list(source.keys())\n        cols.remove(ext['ra'])\n        cols.remove(ext['dec'])\n        cols.remove(ext['id'])\n        columns.extend(zip(cols, cols))\n\n        # which column is the likely one to color source circles\n        colorCode = 'Mag'\n\n        info = Bunch.Bunch(columns=columns, color=colorCode)\n        return starlist, info"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef search(self, dstpath, **params):\n\n        self.logger.debug(\"search params=%s\" % (str(params)))\n        ra, dec = params['ra'], params['dec']\n        if not (':' in ra):\n            # Assume RA and DEC are in degrees\n            ra_deg = float(ra)\n            dec_deg = float(dec)\n        else:\n            # Assume RA and DEC are in standard string notation\n            ra_deg = wcs.hmsStrToDeg(ra)\n            dec_deg = wcs.dmsStrToDeg(dec)\n\n        # Convert to degrees for search\n        wd_deg = float(params['width']) / 60.0\n        ht_deg = float(params['height']) / 60.0\n        # wd_deg = float(params['width'])\n        # ht_deg = float(params['height'])\n\n        # initialize our query object with the service's base URL\n        query = pyvo.sia.SIAQuery(self.url)\n        query.ra = ra_deg\n        query.dec = dec_deg\n        query.size = (wd_deg, ht_deg)\n        query.format = 'image/fits'\n        self.logger.info(\"Will query: %s\" % query.getqueryurl(True))\n\n        results = query.execute()\n        if len(results) > 0:\n            self.logger.info(\"Found %d images\" % len(results))\n        else:\n            self.logger.warning(\"Found no images in this area\" % len(results))\n            return None\n\n        # For now, we pick the first one found\n\n        # REQUIRES FIX IN PYVO:\n        # imfile = results[0].cachedataset(dir=\"/tmp\")\n        #\n        # Workaround:\n        fitspath = results[0].make_dataset_filename(dir=\"/tmp\")\n        results[0].cachedataset(fitspath)\n\n        # explicit return\n        return fitspath", "response": "Search for images in the image catalog."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_plain_image_as_file(self, filepath, format='png', quality=90):\n        pixbuf = self.get_plain_image_as_pixbuf()\n        options = {}\n        if format == 'jpeg':\n            options['quality'] = str(quality)\n        pixbuf.save(filepath, format, options)", "response": "Used for generating thumbnails. Does not include overlaid\n        graphics."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef expose_event(self, widget, event):\n        x, y, width, height = event.area\n        self.logger.debug(\"surface is %s\" % self.surface)\n        if self.surface is not None:\n            win = widget.get_window()\n            cr = win.cairo_create()\n\n            # set clip area for exposed region\n            cr.rectangle(x, y, width, height)\n            cr.clip()\n\n            # Paint from off-screen surface\n            cr.set_source_surface(self.surface, 0, 0)\n            cr.set_operator(cairo.OPERATOR_SOURCE)\n            cr.paint()\n\n        return False", "response": "Exposes an event to the current area of the window."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef size_request(self, widget, requisition):\n        requisition.width, requisition.height = self.get_desired_size()\n        return True", "response": "Callback function to request our desired size."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate and set the scrollbar handles from the pan and zoom positions.", "response": "def _calc_scrollbars(self, viewer, whence):\n        \"\"\"Calculate and set the scrollbar handles from the pan and\n        zoom positions.\n        \"\"\"\n        if self._scrolling or whence > 0:\n            return\n\n        # flag that suppresses a cyclical callback\n        self._adjusting = True\n        try:\n            bd = self.viewer.get_bindings()\n            res = bd.calc_pan_pct(self.viewer, pad=self.pad)\n            if res is None:\n                return\n\n            page_x, page_y = (float(res.thm_pct_x * 100),\n                              float(res.thm_pct_y * 100))\n            self.rng_x, self.rng_y = 100 - page_x, 100 - page_y\n            val_x, val_y = (float(res.pan_pct_x * self.rng_x),\n                            float((1.0 - res.pan_pct_y) * self.rng_y))\n\n            upper_x, upper_y = 100.0, 100.0\n\n            adj = self.hsb.get_adjustment()\n            adj.configure(val_x, 0.0, upper_x, 1.0, page_x, page_x)\n            self.hsb.set_adjustment(adj)\n            adj = self.vsb.get_adjustment()\n            adj.configure(val_y, 0.0, upper_y, 1.0, page_y, page_y)\n            self.vsb.set_adjustment(adj)\n\n        finally:\n            self._adjusting = False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _scroll_contents(self, adj):\n        if self._adjusting:\n            return True\n\n        try:\n            pos_x = self.hsb.get_value()\n            pos_y = self.vsb.get_value()\n\n            pct_x = pos_x / self.rng_x\n            # invert Y pct because of orientation of scrollbar\n            pct_y = 1.0 - (pos_y / self.rng_y)\n\n            bd = self.viewer.get_bindings()\n            bd.pan_by_pct(self.viewer, pct_x, pct_y, pad=self.pad)\n\n            # This shouldn't be necessary, but seems to be\n            self.viewer.redraw(whence=0)\n\n        finally:\n            self._scrolling = False\n\n        return True", "response": "Called when the scroll bars are adjusted by the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef call_local_plugin_method(self, chname, plugin_name, method_name,\n                                 args, kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        chname : str\n            The name of the channel containing the plugin.\n\n        plugin_name : str\n            The name of the local plugin containing the method to call.\n\n        method_name : str\n            The name of the method to call.\n\n        args : list or tuple\n            The positional arguments to the method\n\n        kwargs : dict\n            The keyword arguments to the method\n\n        Returns\n        -------\n        result : return value from calling the method\n        \"\"\"\n        channel = self.get_channel(chname)\n        opmon = channel.opmon\n        p_obj = opmon.get_plugin(plugin_name)\n        method = getattr(p_obj, method_name)\n        return self.gui_call(method, *args, **kwargs)", "response": "Calls the local method on the local plugin with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef call_global_plugin_method(self, plugin_name, method_name,\n                                  args, kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        plugin_name : str\n            The name of the global plugin containing the method to call.\n\n        method_name : str\n            The name of the method to call.\n\n        args : list or tuple\n            The positional arguments to the method\n\n        kwargs : dict\n            The keyword arguments to the method\n\n        Returns\n        -------\n        result : return value from calling the method\n        \"\"\"\n        p_obj = self.gpmon.get_plugin(plugin_name)\n        method = getattr(p_obj, method_name)\n        return self.gui_call(method, *args, **kwargs)", "response": "Calls the global plugin method with the given name with the given arguments and keyword arguments."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_plugin_spec(self, name):\n        l_name = name.lower()\n        for spec in self.plugins:\n            name = spec.get('name', spec.get('klass', spec.module))\n            if name.lower() == l_name:\n                return spec\n        raise KeyError(name)", "response": "Get the specification attributes for a plugin with name name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef help_text(self, name, text, text_kind='plain', trim_pfx=0):\n\n        if trim_pfx > 0:\n            # caller wants to trim some space off the front\n            # of each line\n            text = toolbox.trim_prefix(text, trim_pfx)\n\n        if text_kind == 'rst':\n            # try to convert RST to HTML using docutils\n            try:\n                overrides = {'input_encoding': 'ascii',\n                             'output_encoding': 'utf-8'}\n                text_html = publish_string(text, writer_name='html',\n                                           settings_overrides=overrides)\n                # docutils produces 'bytes' output, but webkit needs\n                # a utf-8 string\n                text = text_html.decode('utf-8')\n                text_kind = 'html'\n\n            except Exception as e:\n                self.logger.error(\"Error converting help text to HTML: %s\" % (\n                    str(e)))\n                # revert to showing RST as plain text\n\n        else:\n            raise ValueError(\n                \"I don't know how to display text of kind '%s'\" % (text_kind))\n\n        if text_kind == 'html':\n            self.help(text=text, text_kind='html')\n\n        else:\n            self.show_help_text(name, text)", "response": "This method will convert the text to HTML and display it in the WBrowser plugin."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show_help_text(self, name, help_txt, wsname='right'):\n        tabname = 'HELP: {}'.format(name)\n        group = 1\n        tabnames = self.ds.get_tabnames(group)\n        if tabname in tabnames:\n            # tab is already up somewhere\n            return\n\n        vbox = Widgets.VBox()\n        vbox.set_margins(4, 4, 4, 4)\n        vbox.set_spacing(2)\n\n        msg_font = self.get_font('fixed', 12)\n        tw = Widgets.TextArea(wrap=False, editable=False)\n        tw.set_font(msg_font)\n        tw.set_text(help_txt)\n        vbox.add_widget(tw, stretch=1)\n\n        btns = Widgets.HBox()\n        btns.set_border_width(4)\n        btns.set_spacing(3)\n\n        def _close_cb(w):\n            self.ds.remove_tab(tabname)\n\n        btn = Widgets.Button(\"Close\")\n        btn.add_callback('activated', _close_cb)\n        btns.add_widget(btn, stretch=0)\n        btns.add_widget(Widgets.Label(''), stretch=1)\n\n        vbox.add_widget(btns, stretch=0)\n\n        self.ds.add_tab(wsname, vbox, group, tabname)\n        self.ds.raise_tab(tabname)", "response": "Show the help text in a closeable tab window."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading a single image into a data object.", "response": "def load_image(self, filespec, idx=None, show_error=True):\n        \"\"\"\n        A wrapper around ginga.util.loader.load_data()\n\n        Parameters\n        ----------\n        filespec : str\n            The path of the file to load (must reference a single file).\n\n        idx : str, int or tuple; optional, defaults to None\n            The index of the image to open within the file.\n\n        show_error : bool, optional, defaults to True\n            If `True`, then display an error in the GUI if the file\n            loading process fails.\n\n        Returns\n        -------\n        data_obj : data object named by filespec\n        \"\"\"\n        inherit_prihdr = self.settings.get('inherit_primary_header',\n                                           False)\n        try:\n            data_obj = loader.load_data(filespec, logger=self.logger,\n                                        idx=idx,\n                                        inherit_primary_header=inherit_prihdr)\n        except Exception as e:\n            errmsg = \"Failed to load file '%s': %s\" % (\n                filespec, str(e))\n            self.logger.error(errmsg)\n            try:\n                (type, value, tb) = sys.exc_info()\n                tb_str = \"\\n\".join(traceback.format_tb(tb))\n            except Exception as e:\n                tb_str = \"Traceback information unavailable.\"\n            if show_error:\n                self.gui_do(self.show_error, errmsg + '\\n' + tb_str)\n            raise ControlError(errmsg)\n\n        self.logger.debug(\"Successfully loaded file into object.\")\n        return data_obj"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_file(self, filepath, chname=None, wait=True,\n                  create_channel=True, display_image=True,\n                  image_loader=None):\n        \"\"\"Load a file and display it.\n\n        Parameters\n        ----------\n        filepath : str\n            The path of the file to load (must reference a local file).\n\n        chname : str, optional\n            The name of the channel in which to display the image.\n\n        wait : bool, optional\n            If `True`, then wait for the file to be displayed before returning\n            (synchronous behavior).\n\n        create_channel : bool, optional\n            Create channel.\n\n        display_image : bool, optional\n            If not `False`, then will load the image.\n\n        image_loader : func, optional\n            A special image loader, if provided.\n\n        Returns\n        -------\n        image\n            The image object that was loaded.\n\n        \"\"\"\n        if not chname:\n            channel = self.get_current_channel()\n        else:\n            if not self.has_channel(chname) and create_channel:\n                self.gui_call(self.add_channel, chname)\n            channel = self.get_channel(chname)\n        chname = channel.name\n\n        if image_loader is None:\n            image_loader = self.load_image\n\n        cache_dir = self.settings.get('download_folder', self.tmpdir)\n\n        info = iohelper.get_fileinfo(filepath, cache_dir=cache_dir)\n\n        # check that file is locally accessible\n        if not info.ondisk:\n            errmsg = \"File must be locally loadable: %s\" % (filepath)\n            self.gui_do(self.show_error, errmsg)\n            return\n\n        filepath = info.filepath\n\n        kwargs = {}\n        idx = None\n        if info.numhdu is not None:\n            kwargs['idx'] = info.numhdu\n\n        try:\n            image = image_loader(filepath, **kwargs)\n\n        except Exception as e:\n            errmsg = \"Failed to load '%s': %s\" % (filepath, str(e))\n            self.gui_do(self.show_error, errmsg)\n            return\n\n        future = Future.Future()\n        future.freeze(image_loader, filepath, **kwargs)\n\n        # Save a future for this image to reload it later if we\n        # have to remove it from memory\n        image.set(loader=image_loader, image_future=future)\n\n        if image.get('path', None) is None:\n            image.set(path=filepath)\n\n        # Assign a name to the image if the loader did not.\n        name = image.get('name', None)\n        if name is None:\n            name = iohelper.name_image_from_path(filepath, idx=idx)\n            image.set(name=name)\n\n        if display_image:\n            # Display image.  If the wait parameter is False then don't wait\n            # for the image to load into the viewer\n            if wait:\n                self.gui_call(self.add_image, name, image, chname=chname)\n            else:\n                self.gui_do(self.add_image, name, image, chname=chname)\n        else:\n            self.gui_do(self.bulk_add_image, name, image, chname)\n\n        # Return the image\n        return image", "response": "Loads a file and displays it."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhanding off a download to the Downloads plugin if it is present.", "response": "def add_download(self, info, future):\n        \"\"\"\n        Hand off a download to the Downloads plugin, if it is present.\n\n        Parameters\n        ----------\n        info : `~ginga.misc.Bunch.Bunch`\n            A bunch of information about the URI as returned by\n            `ginga.util.iohelper.get_fileinfo()`\n\n        future : `~ginga.misc.Future.Future`\n            A future that represents the future computation to be performed\n            after downloading the file.  Resolving the future will trigger\n            the computation.\n        \"\"\"\n        if self.gpmon.has_plugin('Downloads'):\n            obj = self.gpmon.get_plugin('Downloads')\n            self.gui_do(obj.add_download, info, future)\n        else:\n            self.show_error(\"Please activate the 'Downloads' plugin to\"\n                            \" enable download functionality\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef open_uri_cont(self, filespec, loader_cont_fn):\n        info = iohelper.get_fileinfo(filespec)\n\n        # download file if necessary\n        if ((not info.ondisk) and (info.url is not None) and\n                (not info.url.startswith('file:'))):\n            # create up a future to do the download and set up a\n            # callback to handle it when finished\n            def _download_cb(future):\n                filepath = future.get_value(block=False)\n                self.logger.debug(\"downloaded: %s\" % (filepath))\n                self.gui_do(loader_cont_fn, filepath + info.idx)\n\n            future = Future.Future()\n            future.add_callback('resolved', _download_cb)\n            self.add_download(info, future)\n            return\n\n        # invoke the continuation\n        loader_cont_fn(info.filepath + info.idx)", "response": "Open a URI and load it."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef open_file_cont(self, pathspec, loader_cont_fn):\n        info = iohelper.get_fileinfo(pathspec)\n\n        filepath = info.filepath\n\n        if not os.path.exists(filepath):\n            errmsg = \"File does not appear to exist: '%s'\" % (filepath)\n            self.gui_do(self.show_error, errmsg)\n            return\n\n        try:\n            typ, subtyp = iohelper.guess_filetype(filepath)\n\n        except Exception as e:\n            self.logger.warning(\"error determining file type: %s; \"\n                                \"assuming 'image/fits'\" % (str(e)))\n            # Can't determine file type: assume and attempt FITS\n            typ, subtyp = 'image', 'fits'\n\n        mimetype = \"%s/%s\" % (typ, subtyp)\n        try:\n            opener_class = loader.get_opener(mimetype)\n\n        except KeyError:\n            # TODO: here pop up a dialog asking which loader to use\n            errmsg = \"No registered opener for: '%s'\" % (mimetype)\n            self.gui_do(self.show_error, errmsg)\n            return\n\n        # kwd args to pass to opener\n        kwargs = dict()\n        inherit_prihdr = self.settings.get('inherit_primary_header',\n                                           False)\n        kwargs['inherit_primary_header'] = inherit_prihdr\n\n        # open the file and load the items named by the index\n        opener = opener_class(self.logger)\n        try:\n            with opener.open_file(filepath) as io_f:\n                io_f.load_idx_cont(info.idx, loader_cont_fn, **kwargs)\n\n        except Exception as e:\n            errmsg = \"Error opening '%s': %s\" % (filepath, str(e))\n            try:\n                (type, value, tb) = sys.exc_info()\n                tb_str = \"\\n\".join(traceback.format_tb(tb))\n            except Exception as e:\n                tb_str = \"Traceback information unavailable.\"\n            self.gui_do(self.show_error, errmsg + '\\n' + tb_str)", "response": "Open a file and do some action on it."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nopen a set of URIs into the current channel.", "response": "def open_uris(self, uris, chname=None, bulk_add=False):\n        \"\"\"Open a set of URIs.\n\n        Parameters\n        ----------\n        uris : list of str\n            The URIs of the files to load\n\n        chname: str, optional (defaults to channel with focus)\n            The name of the channel in which to load the items\n\n        bulk_add : bool, optional (defaults to False)\n            If True, then all the data items are loaded into the\n            channel without disturbing the current item there.\n            If False, then the first item loaded will be displayed\n            and the rest of the items will be loaded as bulk.\n\n        \"\"\"\n        if len(uris) == 0:\n            return\n\n        if chname is None:\n            channel = self.get_channel_info()\n            if channel is None:\n                # No active channel to load these into\n                return\n            chname = channel.name\n        channel = self.get_channel_on_demand(chname)\n\n        def show_dataobj_bulk(data_obj):\n            self.gui_do(channel.add_image, data_obj, bulk_add=True)\n\n        def load_file_bulk(filepath):\n            self.nongui_do(self.open_file_cont, filepath, show_dataobj_bulk)\n\n        def show_dataobj(data_obj):\n            self.gui_do(channel.add_image, data_obj, bulk_add=False)\n\n        def load_file(filepath):\n            self.nongui_do(self.open_file_cont, filepath, show_dataobj)\n\n        # determine whether first file is loaded as a bulk load\n        if bulk_add:\n            self.open_uri_cont(uris[0], load_file_bulk)\n        else:\n            self.open_uri_cont(uris[0], load_file)\n        self.update_pending()\n\n        for uri in uris[1:]:\n            # rest of files are all loaded using bulk load\n            self.open_uri_cont(uri, load_file_bulk)\n            self.update_pending()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef zoom_in(self):\n        viewer = self.getfocus_viewer()\n        if hasattr(viewer, 'zoom_in'):\n            viewer.zoom_in()\n        return True", "response": "Zoom the view in one zoom step."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef zoom_out(self):\n        viewer = self.getfocus_viewer()\n        if hasattr(viewer, 'zoom_out'):\n            viewer.zoom_out()\n        return True", "response": "Zoom the view out one zoom step."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nzooms the view to a 1 to 1 pixel ratio.", "response": "def zoom_1_to_1(self):\n        \"\"\"Zoom the view to a 1 to 1 pixel ratio (100 %%).\n        \"\"\"\n        viewer = self.getfocus_viewer()\n        if hasattr(viewer, 'scale_to'):\n            viewer.scale_to(1.0, 1.0)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef zoom_fit(self):\n        viewer = self.getfocus_viewer()\n        if hasattr(viewer, 'zoom_fit'):\n            viewer.zoom_fit()\n        return True", "response": "Zoom the view to fit the image entirely in the window."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngo to the previous image in the workspace.", "response": "def prev_img_ws(self, ws, loop=True):\n        \"\"\"Go to the previous image in the focused channel in the workspace.\n        \"\"\"\n        channel = self.get_active_channel_ws(ws)\n        if channel is None:\n            return\n        channel.prev_image()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef next_img_ws(self, ws, loop=True):\n        channel = self.get_active_channel_ws(ws)\n        if channel is None:\n            return\n        channel.next_image()\n        return True", "response": "Go to the next image in the workspace."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef prev_img(self, loop=True):\n        channel = self.get_current_channel()\n        if channel is None:\n            self.show_error(\"Please create a channel.\", raisetab=True)\n            return\n        channel.prev_image()\n        return True", "response": "Go to the previous image in the channel."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngoing to the next image in the channel.", "response": "def next_img(self, loop=True):\n        \"\"\"Go to the next image in the channel.\n        \"\"\"\n        channel = self.get_current_channel()\n        if channel is None:\n            self.show_error(\"Please create a channel.\", raisetab=True)\n            return\n        channel.next_image()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nclose all plugins associated with the channel.", "response": "def close_plugins(self, channel):\n        \"\"\"Close all plugins associated with the channel.\"\"\"\n        opmon = channel.opmon\n        for key in opmon.get_active():\n            obj = opmon.get_plugin(key)\n            try:\n                self.gui_call(obj.close)\n\n            except Exception as e:\n                self.logger.error(\n                    \"Failed to continue operation: %s\" % (str(e)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_channel(self, chname, workspace=None,\n                    num_images=None, settings=None,\n                    settings_template=None,\n                    settings_share=None, share_keylist=None):\n        \"\"\"Create a new Ginga channel.\n\n        Parameters\n        ----------\n        chname : str\n            The name of the channel to create.\n\n        workspace : str or None\n            The name of the workspace in which to create the channel\n\n        num_images : int or None\n            The cache size for the number of images to keep in memory\n\n        settings : `~ginga.misc.Settings.SettingGroup` or `None`\n            Viewer preferences. If not given, one will be created.\n\n        settings_template : `~ginga.misc.Settings.SettingGroup` or `None`\n            Viewer preferences template\n\n        settings_share : `~ginga.misc.Settings.SettingGroup` or `None`\n            Viewer preferences instance to share with newly created settings\n\n        share_keylist : list of str\n            List of names of settings that should be shared\n\n        Returns\n        -------\n        channel : `~ginga.misc.Bunch.Bunch`\n            The channel info bunch.\n\n        \"\"\"\n        with self.lock:\n            if self.has_channel(chname):\n                return self.get_channel(chname)\n\n            if chname in self.ds.get_tabnames(None):\n                raise ValueError(\"Tab name already in use: '%s'\" % (chname))\n\n            name = chname\n            if settings is None:\n                settings = self.prefs.create_category('channel_' + name)\n                try:\n                    settings.load(onError='raise')\n\n                except Exception as e:\n                    self.logger.warning(\"no saved preferences found for channel \"\n                                        \"'%s': %s\" % (name, str(e)))\n\n                    # copy template settings to new channel\n                    if settings_template is not None:\n                        osettings = settings_template\n                        osettings.copy_settings(settings)\n                    else:\n                        try:\n                            # use channel_Image as a template if one was not\n                            # provided\n                            osettings = self.prefs.get_settings('channel_Image')\n                            self.logger.debug(\"Copying settings from 'Image' to \"\n                                              \"'%s'\" % (name))\n                            osettings.copy_settings(settings)\n                        except KeyError:\n                            pass\n\n            if (share_keylist is not None) and (settings_share is not None):\n                # caller wants us to share settings with another viewer\n                settings_share.share_settings(settings, keylist=share_keylist)\n\n            # Make sure these preferences are at least defined\n            if num_images is None:\n                num_images = settings.get('numImages',\n                                          self.settings.get('numImages', 1))\n            settings.set_defaults(switchnew=True, numImages=num_images,\n                                  raisenew=True, genthumb=True,\n                                  focus_indicator=False,\n                                  preload_images=False, sort_order='loadtime')\n\n            self.logger.debug(\"Adding channel '%s'\" % (chname))\n            channel = Channel(chname, self, datasrc=None,\n                              settings=settings)\n\n            bnch = self.add_viewer(chname, settings,\n                                   workspace=workspace)\n            # for debugging\n            bnch.image_viewer.set_name('channel:%s' % (chname))\n\n            opmon = self.get_plugin_manager(self.logger, self,\n                                            self.ds, self.mm)\n\n            channel.widget = bnch.widget\n            channel.container = bnch.container\n            channel.workspace = bnch.workspace\n            channel.connect_viewer(bnch.image_viewer)\n            channel.viewer = bnch.image_viewer\n            # older name, should eventually be deprecated\n            channel.fitsimage = bnch.image_viewer\n            channel.opmon = opmon\n\n            name = chname.lower()\n            self.channel[name] = channel\n\n            # Update the channels control\n            self.channel_names.append(chname)\n            self.channel_names.sort()\n\n            if len(self.channel_names) == 1:\n                self.cur_channel = channel\n\n            # Prepare local plugins for this channel\n            for spec in self.get_plugins():\n                opname = spec.get('klass', spec.get('module'))\n                if spec.get('ptype', 'global') == 'local':\n                    opmon.load_plugin(opname, spec, chinfo=channel)\n\n            self.make_gui_callback('add-channel', channel)\n            return channel", "response": "Creates a new Ginga channel."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting a given channel from viewer.", "response": "def delete_channel(self, chname):\n        \"\"\"Delete a given channel from viewer.\"\"\"\n        name = chname.lower()\n\n        if len(self.channel_names) < 1:\n            self.logger.error('Delete channel={0} failed. '\n                              'No channels left.'.format(chname))\n            return\n\n        with self.lock:\n            channel = self.channel[name]\n\n            # Close local plugins open on this channel\n            self.close_plugins(channel)\n\n            try:\n                idx = self.channel_names.index(chname)\n            except ValueError:\n                idx = 0\n\n            # Update the channels control\n            self.channel_names.remove(channel.name)\n            self.channel_names.sort()\n\n            self.ds.remove_tab(chname)\n            del self.channel[name]\n            self.prefs.remove_settings('channel_' + chname)\n\n            # pick new channel\n            num_channels = len(self.channel_names)\n            if num_channels > 0:\n                if idx >= num_channels:\n                    idx = num_channels - 1\n                self.change_channel(self.channel_names[idx])\n            else:\n                self.cur_channel = None\n\n        self.make_gui_callback('delete-channel', channel)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a menu with name to the global menu bar. Returns a menu widget.", "response": "def add_menu(self, name):\n        \"\"\"Add a menu with name `name` to the global menu bar.\n        Returns a menu widget.\n        \"\"\"\n        if self.menubar is None:\n            raise ValueError(\"No menu bar configured\")\n        return self.menubar.add_name(name)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_menu(self, name):\n        if self.menubar is None:\n            raise ValueError(\"No menu bar configured\")\n        return self.menubar.get_menu(name)", "response": "Get the menu with name from the global menu bar. Returns a menu widget."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters a channel viewer with the reference viewer.", "response": "def register_viewer(self, vclass):\n        \"\"\"Register a channel viewer with the reference viewer.\n        `vclass` is the class of the viewer.\n        \"\"\"\n        self.viewer_db[vclass.vname] = Bunch.Bunch(vname=vclass.vname,\n                                                   vclass=vclass,\n                                                   vtypes=vclass.vtypes)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of viewer names that can view dataobj.", "response": "def get_viewer_names(self, dataobj):\n        \"\"\"Returns a list of viewer names that are registered that\n        can view `dataobj`.\n        \"\"\"\n        res = []\n        for bnch in self.viewer_db.values():\n            for vtype in bnch.vtypes:\n                if isinstance(dataobj, vtype):\n                    res.append(bnch.vname)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_viewer(self, vname, channel):\n        if vname not in self.viewer_db:\n            raise ValueError(\"I don't know how to build a '%s' viewer\" % (\n                vname))\n\n        stk_w = channel.widget\n\n        bnch = self.viewer_db[vname]\n\n        viewer = bnch.vclass(logger=self.logger,\n                             settings=channel.settings)\n        stk_w.add_widget(viewer.get_widget(), title=vname)\n\n        # let the GUI respond to this widget addition\n        self.update_pending()\n\n        # let the channel object do any necessary initialization\n        channel.connect_viewer(viewer)\n\n        # finally, let the viewer do any viewer-side initialization\n        viewer.initialize_channel(self, channel)", "response": "Make a viewer whose type name is vname and add it to channel."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntoggle collapsing the left or right panes.", "response": "def collapse_pane(self, side):\n        \"\"\"\n        Toggle collapsing the left or right panes.\n        \"\"\"\n        # TODO: this is too tied to one configuration, need to figure\n        # out how to generalize this\n        hsplit = self.w['hpnl']\n        sizes = hsplit.get_sizes()\n        lsize, msize, rsize = sizes\n        if self._lsize is None:\n            self._lsize, self._rsize = lsize, rsize\n        self.logger.debug(\"left=%d mid=%d right=%d\" % (\n            lsize, msize, rsize))\n        if side == 'right':\n            if rsize < 10:\n                # restore pane\n                rsize = self._rsize\n                msize -= rsize\n            else:\n                # minimize pane\n                self._rsize = rsize\n                msize += rsize\n                rsize = 0\n        elif side == 'left':\n            if lsize < 10:\n                # restore pane\n                lsize = self._lsize\n                msize -= lsize\n            else:\n                # minimize pane\n                self._lsize = lsize\n                msize += lsize\n                lsize = 0\n        hsplit.set_sizes([lsize, msize, rsize])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef showxy(self, viewer, data_x, data_y):\n        # This is an optimization to get around slow coordinate\n        # transformation by astropy and possibly other WCS packages,\n        # which causes delay for other mouse tracking events, e.g.\n        # the zoom plugin.\n        # We only update the under cursor information every period\n        # defined by (self.cursor_interval) sec.\n        #\n        # If the refresh interval has expired then update the info;\n        # otherwise (re)set the timer until the end of the interval.\n        cur_time = time.time()\n        elapsed = cur_time - self._cursor_last_update\n        if elapsed > self.cursor_interval:\n            # cancel timer\n            self._cursor_task.clear()\n            self.gui_do_oneshot('field-info', self._showxy,\n                                viewer, data_x, data_y)\n        else:\n            # store needed data into the timer data area\n            self._cursor_task.data.setvals(viewer=viewer,\n                                           data_x=data_x, data_y=data_y)\n            # calculate delta until end of refresh interval\n            period = self.cursor_interval - elapsed\n            # set timer conditionally (only if it hasn't yet been set)\n            self._cursor_task.cond_set(period)\n        return True", "response": "Called by the mouse - tracking callback to handle reporting of the cursor position to various plugins that subscribe to the field - info callback."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _cursor_timer_cb(self, timer):\n        data = timer.data\n        self.gui_do_oneshot('field-info', self._showxy,\n                            data.viewer, data.data_x, data.data_y)", "response": "Callback when the cursor timer expires."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _showxy(self, viewer, data_x, data_y):\n        self._cursor_last_update = time.time()\n        try:\n            image = viewer.get_image()\n            if (image is None) or not isinstance(image, BaseImage.BaseImage):\n                # No compatible image loaded for this channel\n                return\n\n            settings = viewer.get_settings()\n            info = image.info_xy(data_x, data_y, settings)\n\n            # Are we reporting in data or FITS coordinates?\n            off = self.settings.get('pixel_coords_offset', 0.0)\n            info.x += off\n            info.y += off\n\n        except Exception as e:\n            self.logger.warning(\n                \"Can't get info under the cursor: %s\" % (str(e)))\n            return\n\n        # TODO: can this be made more efficient?\n        chname = self.get_channel_name(viewer)\n        channel = self.get_channel(chname)\n\n        self.make_callback('field-info', channel, info)\n\n        self.update_pending()\n        return True", "response": "Update the info from the last position recorded under the cursor."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef motion_cb(self, viewer, button, data_x, data_y):\n        self.showxy(viewer, data_x, data_y)\n        return True", "response": "Motion event in the channel viewer window."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef keypress(self, viewer, event, data_x, data_y):\n        keyname = event.key\n        chname = self.get_channel_name(viewer)\n        self.logger.debug(\"key press (%s) in channel %s\" % (\n            keyname, chname))\n        # TODO: keyboard accelerators to raise tabs need to be integrated into\n        #   the desktop object\n        if keyname == 'Z':\n            self.ds.raise_tab('Zoom')\n        ## elif keyname == 'T':\n        ##     self.ds.raise_tab('Thumbs')\n        elif keyname == 'I':\n            self.ds.raise_tab('Info')\n        elif keyname == 'H':\n            self.ds.raise_tab('Header')\n        elif keyname == 'C':\n            self.ds.raise_tab('Contents')\n        elif keyname == 'D':\n            self.ds.raise_tab('Dialogs')\n        elif keyname == 'F':\n            self.build_fullscreen()\n        elif keyname == 'f':\n            self.toggle_fullscreen()\n        elif keyname == 'm':\n            self.maximize()\n        elif keyname == '<':\n            self.collapse_pane('left')\n        elif keyname == '>':\n            self.collapse_pane('right')\n        elif keyname == 'n':\n            self.next_channel()\n        elif keyname == 'J':\n            self.cycle_workspace_type()\n        elif keyname == 'k':\n            self.add_channel_auto()\n        elif keyname == 'K':\n            self.remove_channel_auto()\n        elif keyname == 'f1':\n            self.show_channel_names()\n        ## elif keyname == 'escape':\n        ##     self.reset_viewer()\n        elif keyname in ('up',):\n            self.prev_img()\n        elif keyname in ('down',):\n            self.next_img()\n        elif keyname in ('left',):\n            self.prev_channel()\n        elif keyname in ('right',):\n            self.next_channel()\n        return True", "response": "Handles a key press event in a channel window."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall when a drop operation is performed on a channel viewer. We are called back with a URL and we attempt to open it if it is a file.", "response": "def dragdrop(self, chviewer, uris):\n        \"\"\"Called when a drop operation is performed on a channel viewer.\n        We are called back with a URL and we attempt to (down)load it if it\n        names a file.\n        \"\"\"\n        # find out our channel\n        chname = self.get_channel_name(chviewer)\n        self.open_uris(uris, chname=chname)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef focus_cb(self, viewer, tf, name):\n        if not self.settings.get('channel_follows_focus', False):\n            return True\n\n        self.logger.debug(\"focus %s=%s\" % (name, tf))\n        if tf:\n            if viewer != self.getfocus_viewer():\n                self.change_channel(name, raisew=False)\n\n        return True", "response": "Called when the user gets the focus."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show_channel_names(self):\n        for name in self.get_channel_names():\n            channel = self.get_channel(name)\n            channel.fitsimage.onscreen_message(name, delay=2.5)", "response": "Show each channel s name in its image viewer."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _short_color_list(self):\n        return [c for c in colors.get_colors() if not re.search(r'\\d', c)]", "response": "Color list is too long. Discard variations with numbers."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef redo(self):\n        if not self.gui_up:\n            return\n\n        self.clear_marking()\n        self.tree_dict = Bunch.caselessDict()\n        self.treeviewbad.clear()\n        bad_tree_dict = Bunch.caselessDict()\n        nbad = 0\n        self._xarr = []\n        self._yarr = []\n        self._treepaths = []\n\n        image = self.fitsimage.get_image()\n        if image is None:\n            return\n\n        if not hasattr(image, 'radectopix'):\n            self.logger.error(\n                'Image as no radectopix() method for coordinates conversion')\n            return\n\n        objlist = []\n        seqno = 1\n        max_x = image.width - 1\n        max_y = image.height - 1\n\n        for key, coords in self.coords_dict.items():\n            if len(coords) == 0:\n                continue\n\n            marktype, marksize, markcolor = key\n            kstr = ','.join(map(str, key))\n            sub_dict = {}\n            bad_sub_dict = {}\n            self.tree_dict[kstr] = sub_dict\n            bad_tree_dict[kstr] = bad_sub_dict\n\n            for args in coords:\n                ra, dec, x, y = args[:4]\n\n                # Use X and Y positions directly. Convert to RA and DEC (deg).\n                if ra is None or dec is None:\n                    ra, dec = image.pixtoradec(x, y)\n\n                # RA and DEC already in degrees. Convert to pixel X and Y.\n                else:\n                    x, y = image.radectopix(ra, dec)\n\n                # Display original X/Y (can be 0- or 1-indexed) using\n                # our internal 0-indexed values.\n                xdisp = x + self.pixelstart\n                ydisp = y + self.pixelstart\n\n                seqstr = '{0:04d}'.format(seqno)  # Prepend 0s for proper sort\n                bnch = Bunch.Bunch(zip(self.extra_columns, args[4:]))  # Extra\n                bnch.update(Bunch.Bunch(MARKID=seqstr, RA=ra, DEC=dec,\n                                        X=xdisp, Y=ydisp))\n\n                # Do not draw out of bounds\n                if (not np.isfinite(x) or x < 0 or x > max_x or\n                        not np.isfinite(y) or y < 0 or y > max_y):\n                    self.logger.debug('Ignoring RA={0}, DEC={1} '\n                                      '(x={2}, y={3})'.format(ra, dec, x, y))\n                    bad_sub_dict[seqstr] = bnch\n                    nbad += 1\n\n                # Display point\n                else:\n                    obj = self._get_markobj(\n                        x, y, marktype, marksize, markcolor, self.markwidth)\n                    objlist.append(obj)\n\n                    sub_dict[seqstr] = bnch\n                    self._xarr.append(x)\n                    self._yarr.append(y)\n                    self._treepaths.append((kstr, seqstr))\n\n                seqno += 1\n\n        n_obj = len(objlist)\n        self.logger.debug('Displaying {0} markings'.format(n_obj))\n\n        if nbad > 0:\n            self.treeviewbad.set_tree(bad_tree_dict)\n\n        if n_obj == 0:\n            return\n\n        # Convert to Numpy arrays to avoid looping later\n        self._xarr = np.array(self._xarr)\n        self._yarr = np.array(self._yarr)\n        self._treepaths = np.array(self._treepaths)\n\n        # Display info table\n        self.recreate_toc()\n\n        # Draw on canvas\n        self.marktag = self.canvas.add(self.dc.CompoundObject(*objlist))\n        self.fitsimage.redraw()", "response": "Redraw the treeviewbad and redraw the treeviewbad."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating canvas object for given mark parameters.", "response": "def _get_markobj(self, x, y, marktype, marksize, markcolor, markwidth):\n        \"\"\"Generate canvas object for given mark parameters.\"\"\"\n        if marktype == 'circle':\n            obj = self.dc.Circle(\n                x=x, y=y, radius=marksize, color=markcolor, linewidth=markwidth)\n        elif marktype in ('cross', 'plus'):\n            obj = self.dc.Point(\n                x=x, y=y, radius=marksize, color=markcolor, linewidth=markwidth,\n                style=marktype)\n        elif marktype == 'box':\n            obj = self.dc.Box(\n                x=x, y=y, xradius=marksize, yradius=marksize, color=markcolor,\n                linewidth=markwidth)\n        else:  # point, marksize\n            obj = self.dc.Box(\n                x=x, y=y, xradius=1, yradius=1, color=markcolor,\n                linewidth=markwidth, fill=True, fillcolor=markcolor)\n\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nclears marking from image. This does not clear loaded coordinates from memory.", "response": "def clear_marking(self):\n        \"\"\"Clear marking from image.\n        This does not clear loaded coordinates from memory.\"\"\"\n        if self.marktag:\n            try:\n                self.canvas.delete_object_by_tag(self.marktag, redraw=False)\n            except Exception:\n                pass\n\n        if self.markhltag:\n            try:\n                self.canvas.delete_object_by_tag(self.markhltag, redraw=False)\n            except Exception:\n                pass\n\n        self.treeview.clear()  # Clear table too\n        self.w.nshown.set_text('0')\n        self.fitsimage.redraw()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef forget_coords(self):\n        self.w.ntotal.set_text('0')\n        self.coords_dict.clear()\n        self.redo()", "response": "Forget all loaded coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload a file into the current object.", "response": "def load_file(self, filename):\n        \"\"\"Load coordinates file.\n\n        Results are appended to previously loaded coordinates.\n        This can be used to load one file per color.\n\n        \"\"\"\n        if not os.path.isfile(filename):\n            return\n\n        self.logger.info('Loading coordinates from {0}'.format(filename))\n\n        if filename.endswith('.fits'):\n            fmt = 'fits'\n        else:  # Assume ASCII\n            fmt = 'ascii'\n\n        try:\n            tab = Table.read(filename, format=fmt)\n        except Exception as e:\n            self.logger.error('{0}: {1}'.format(e.__class__.__name__, str(e)))\n            return\n\n        if self.use_radec:\n            colname0 = self.settings.get('ra_colname', 'ra')\n            colname1 = self.settings.get('dec_colname', 'dec')\n        else:\n            colname0 = self.settings.get('x_colname', 'x')\n            colname1 = self.settings.get('y_colname', 'y')\n\n        try:\n            col_0 = tab[colname0]\n            col_1 = tab[colname1]\n        except Exception as e:\n            self.logger.error('{0}: {1}'.format(e.__class__.__name__, str(e)))\n            return\n\n        nrows = len(col_0)\n        dummy_col = [None] * nrows\n\n        try:\n            oldrows = int(self.w.ntotal.get_text())\n        except ValueError:\n            oldrows = 0\n\n        self.w.ntotal.set_text(str(oldrows + nrows))\n\n        if self.use_radec:\n            ra = self._convert_radec(col_0)\n            dec = self._convert_radec(col_1)\n            x = y = dummy_col\n        else:\n            ra = dec = dummy_col\n\n            # X and Y always 0-indexed internally\n            x = col_0.data - self.pixelstart\n            y = col_1.data - self.pixelstart\n\n        args = [ra, dec, x, y]\n\n        # Load extra columns\n        for colname in self.extra_columns:\n            try:\n                col = tab[colname].data\n            except Exception as e:\n                self.logger.error(\n                    '{0}: {1}'.format(e.__class__.__name__, str(e)))\n                col = dummy_col\n\n            args.append(col)\n\n        # Use list to preserve order. Does not handle duplicates.\n        key = (self.marktype, self.marksize, self.markcolor)\n        self.coords_dict[key] += list(zip(*args))\n\n        self.redo()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _convert_radec(self, val):\n        try:\n            ans = val.to('deg')\n        except Exception as e:\n            self.logger.error('Cannot convert, assume already in degrees')\n            ans = val.data\n        else:\n            ans = ans.value\n\n        return ans", "response": "Convert RA or DEC table column to degrees and extract data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hl_table2canvas(self, w, res_dict):\n        objlist = []\n        width = self.markwidth + self._dwidth\n\n        # Remove existing highlight\n        if self.markhltag:\n            try:\n                self.canvas.delete_object_by_tag(self.markhltag, redraw=False)\n            except Exception:\n                pass\n\n        # Display highlighted entries only in second table\n        self.treeviewsel.set_tree(res_dict)\n\n        for kstr, sub_dict in res_dict.items():\n            s = kstr.split(',')\n            marktype = s[0]\n            marksize = float(s[1])\n            markcolor = s[2]\n\n            for bnch in sub_dict.values():\n                obj = self._get_markobj(bnch.X - self.pixelstart,\n                                        bnch.Y - self.pixelstart,\n                                        marktype, marksize, markcolor, width)\n                objlist.append(obj)\n\n        nsel = len(objlist)\n        self.w.nselected.set_text(str(nsel))\n\n        # Draw on canvas\n        if nsel > 0:\n            self.markhltag = self.canvas.add(self.dc.CompoundObject(*objlist))\n\n        self.fitsimage.redraw()", "response": "Highlights the highlighted entries on canvas when user click on table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhighlight all markings inside user drawn box on table.", "response": "def hl_canvas2table_box(self, canvas, tag):\n        \"\"\"Highlight all markings inside user drawn box on table.\"\"\"\n        self.treeview.clear_selection()\n\n        # Remove existing box\n        cobj = canvas.get_object_by_tag(tag)\n        if cobj.kind != 'rectangle':\n            return\n        canvas.delete_object_by_tag(tag, redraw=False)\n\n        # Remove existing highlight\n        if self.markhltag:\n            try:\n                canvas.delete_object_by_tag(self.markhltag, redraw=True)\n            except Exception:\n                pass\n\n        # Nothing to do if no markings are displayed\n        try:\n            obj = canvas.get_object_by_tag(self.marktag)\n        except Exception:\n            return\n\n        if obj.kind != 'compound':\n            return\n\n        # Nothing to do if table has no data\n        if (len(self._xarr) == 0 or len(self._yarr) == 0 or\n                len(self._treepaths) == 0):\n            return\n\n        # Find markings inside box\n        mask = cobj.contains_arr(self._xarr, self._yarr)\n\n        for hlpath in self._treepaths[mask]:\n            self._highlight_path(hlpath)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hl_canvas2table(self, canvas, button, data_x, data_y):\n        self.treeview.clear_selection()\n\n        # Remove existing highlight\n        if self.markhltag:\n            try:\n                canvas.delete_object_by_tag(self.markhltag, redraw=True)\n            except Exception:\n                pass\n\n        # Nothing to do if no markings are displayed\n        try:\n            obj = canvas.get_object_by_tag(self.marktag)\n        except Exception:\n            return\n\n        if obj.kind != 'compound':\n            return\n\n        # Nothing to do if table has no data\n        if (len(self._xarr) == 0 or len(self._yarr) == 0 or\n                len(self._treepaths) == 0):\n            return\n\n        sr = 10  # self.settings.get('searchradius', 10)\n        dx = data_x - self._xarr\n        dy = data_y - self._yarr\n        dr = np.sqrt(dx * dx + dy * dy)\n        mask = dr <= sr\n\n        for hlpath in self._treepaths[mask]:\n            self._highlight_path(hlpath)", "response": "Highlight marking on table when user click on canvas."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhighlights an entry in the table and associated marking.", "response": "def _highlight_path(self, hlpath):\n        \"\"\"Highlight an entry in the table and associated marking.\"\"\"\n        self.logger.debug('Highlighting {0}'.format(hlpath))\n        self.treeview.select_path(hlpath)\n\n        # TODO: Does not work in Qt. This is known issue in Ginga.\n        self.treeview.scroll_to_path(hlpath)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_marktype_cb(self, w, index):\n        self.marktype = self._mark_options[index]\n\n        # Mark size is not used for point\n        if self.marktype != 'point':\n            self.w.mark_size.set_enabled(True)\n        else:\n            self.w.mark_size.set_enabled(False)", "response": "Set mark type of marking."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_marksize(self):\n        try:\n            sz = float(self.w.mark_size.get_text())\n        except ValueError:\n            self.logger.error('Cannot set mark size')\n            self.w.mark_size.set_text(str(self.marksize))\n        else:\n            self.marksize = sz", "response": "Set size of marking."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets width of marking.", "response": "def set_markwidth(self):\n        \"\"\"Set width of marking.\"\"\"\n        try:\n            sz = int(self.w.mark_width.get_text())\n        except ValueError:\n            self.logger.error('Cannot set mark width')\n            self.w.mark_width.set_text(str(self.markwidth))\n        else:\n            self.markwidth = sz"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef prepare_mosaic(self, image, fov_deg, name=None):\n        header = image.get_header()\n        ra_deg, dec_deg = header['CRVAL1'], header['CRVAL2']\n\n        data_np = image.get_data()\n        #dtype = data_np.dtype\n        dtype = None\n        self.bg_ref = iqcalc.get_median(data_np)\n\n        # TODO: handle skew (differing rotation for each axis)?\n\n        skew_limit = self.settings.get('skew_limit', 0.1)\n        (rot_deg, cdelt1, cdelt2) = wcs.get_rotation_and_scale(\n            header, skew_threshold=skew_limit)\n        self.logger.debug(\"image0 rot=%f cdelt1=%f cdelt2=%f\" % (\n            rot_deg, cdelt1, cdelt2))\n\n        # Prepare pixel scale for each axis\n        px_scale = (math.fabs(cdelt1), math.fabs(cdelt2))\n        cdbase = [np.sign(cdelt1), np.sign(cdelt2)]\n\n        reuse_image = self.settings.get('reuse_image', False)\n        if (not reuse_image) or (self.img_mosaic is None):\n            self.logger.debug(\"creating blank image to hold mosaic\")\n            self.fv.gui_do(self._prepare_mosaic1, \"Creating blank image...\")\n\n            # GC old mosaic\n            self.img_mosaic = None\n\n            img_mosaic = dp.create_blank_image(ra_deg, dec_deg,\n                                               fov_deg, px_scale,\n                                               rot_deg,\n                                               cdbase=cdbase,\n                                               logger=self.logger,\n                                               pfx='mosaic',\n                                               dtype=dtype)\n\n            if name is not None:\n                img_mosaic.set(name=name)\n            imname = img_mosaic.get('name', image.get('name', \"NoName\"))\n            self.logger.debug(\"mosaic name is '%s'\" % (imname))\n\n            # avoid making a thumbnail of this if seed image is also that way\n            nothumb = not self.settings.get('make_thumbs', False)\n            if nothumb:\n                img_mosaic.set(nothumb=True)\n\n            # image is not on disk, set indication for other plugins\n            img_mosaic.set(path=None)\n\n            # TODO: fill in interesting/select object headers from seed image\n\n            self.img_mosaic = img_mosaic\n            self.logger.info(\"adding mosaic image '%s' to channel\" % (imname))\n            self.fv.gui_call(self.fv.add_image, imname, img_mosaic,\n                             chname=self.mosaic_chname)\n\n        else:\n            # <-- reuse image (faster)\n            self.logger.debug(\"Reusing previous mosaic image\")\n            self.fv.gui_do(\n                self._prepare_mosaic1, \"Reusing previous mosaic image...\")\n\n            img_mosaic = dp.recycle_image(self.img_mosaic,\n                                          ra_deg, dec_deg,\n                                          fov_deg, px_scale,\n                                          rot_deg,\n                                          cdbase=cdbase,\n                                          logger=self.logger,\n                                          pfx='mosaic')\n\n        header = img_mosaic.get_header()\n        (rot, cdelt1, cdelt2) = wcs.get_rotation_and_scale(\n            header, skew_threshold=skew_limit)\n        self.logger.debug(\"mosaic rot=%f cdelt1=%f cdelt2=%f\" % (\n            rot, cdelt1, cdelt2))\n\n        return img_mosaic", "response": "Prepare a new mosaic image based on the pointing of the image and fov_deg."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef display_fitsfile(self, chname, fitspath, dowait):\n        # TEMP: dowait ignored\n        self.fv.gui_do(self.fv.open_uris, [fitspath], chname=chname)\n        return 0", "response": "Display a FITS file into a channel."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef blank(self, channel):\n        self._image = None\n        info = channel.extdata._header_info\n        info.table.clear()", "response": "This is called when image is cleared."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload files and load them into the cache.", "response": "def open_files(self, path):\n        \"\"\"Load file(s) -- image*.fits, image*.fits[ext].\n        Returns success code (True or False).\n        \"\"\"\n        paths = []\n        input_list = _patt.findall(path)\n        if not input_list:\n            input_list = [path]\n\n        for path in input_list:\n            # Strips trailing wildcard\n            if path.endswith('*'):\n                path = path[:-1]\n\n            if os.path.isdir(path):\n                continue\n\n            self.logger.debug('Opening files matched by {0}'.format(path))\n            info = iohelper.get_fileinfo(path)\n            ext = iohelper.get_hdu_suffix(info.numhdu)\n            files = glob.glob(info.filepath)  # Expand wildcard\n            paths.extend(['{0}{1}'.format(f, ext) for f in files])\n\n        if len(paths) > 0:\n            self.load_paths(paths)\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clock_resized_cb(self, viewer, width, height):\n        self.logger.info(\"resized canvas to %dx%d\" % (width, height))\n        # add text objects to canvas\n\n        self.canvas.delete_all_objects()\n\n        Text = self.canvas.get_draw_class('text')\n        x, y = 20, int(height * 0.55)\n        # text object for the time\n        self.time_txt = Text(x, y, text='', color=self.color,\n                             font=self.font, fontsize=self.largesize,\n                             coord='window')\n        self.canvas.add(self.time_txt, tag='_time', redraw=False)\n\n        # for supplementary info (date, timezone, etc)\n        self.suppl_txt = Text(x, height - 10, text='', color=self.color,\n                              font=self.font, fontsize=self.smallsize,\n                              coord='window')\n        self.canvas.add(self.suppl_txt, tag='_suppl', redraw=False)\n\n        self.canvas.update_canvas(whence=3)", "response": "This method is called when an individual clock is resized. It deletes and reconstructs the placement of the text objects in the canvas and adds the time and supplementary info objects to the canvas."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a clock to the grid.", "response": "def add_clock(self, timezone, color='lightgreen', show_seconds=None):\n        \"\"\"Add a clock to the grid.  `timezone` is a string representing\n        a valid timezone.\n        \"\"\"\n        if show_seconds is None:\n            show_seconds = self.options.show_seconds\n\n        clock = Clock(self.app, self.logger, timezone, color=color,\n                      font=self.options.font, show_seconds=show_seconds)\n        clock.widget.cfg_expand(0x7, 0x7)\n\n        num_clocks = len(self.clocks)\n        cols = self.settings.get('columns')\n        row = num_clocks // cols\n        col = num_clocks % cols\n        self.clocks[timezone] = clock\n\n        self.grid.add_widget(clock.widget, row, col, stretch=1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef timer_cb(self, timer):\n        dt_now = datetime.utcnow().replace(tzinfo=pytz.utc)\n        self.logger.debug(\"timer fired. utc time is '%s'\" % (str(dt_now)))\n\n        for clock in self.clocks.values():\n            clock.update_clock(dt_now)\n\n        # update clocks approx every second\n        timer.start(1.0)", "response": "Timer callback. Update all our clocks."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_table_cb(self, viewer, table):\n        self.clear()\n        tree_dict = OrderedDict()\n\n        # Extract data as astropy table\n        a_tab = table.get_data()\n\n        # Fill masked values, if applicable\n        try:\n            a_tab = a_tab.filled()\n        except Exception:  # Just use original table\n            pass\n\n        # This is to get around table widget not sorting numbers properly\n        i_fmt = '{{0:0{0}d}}'.format(len(str(len(a_tab))))\n\n        # Table header with units\n        columns = [('Row', '_DISPLAY_ROW')]\n        for c in a_tab.columns.values():\n            col_str = '{0:^s}\\n{1:^s}'.format(c.name, str(c.unit))\n            columns.append((col_str, c.name))\n\n        self.widget.setup_table(columns, 1, '_DISPLAY_ROW')\n\n        # Table contents\n        for i, row in enumerate(a_tab, 1):\n            bnch = Bunch.Bunch(zip(row.colnames, row.as_void()))\n            i_str = i_fmt.format(i)\n            bnch['_DISPLAY_ROW'] = i_str\n            tree_dict[i_str] = bnch\n\n        self.widget.set_tree(tree_dict)\n\n        # Resize column widths\n        n_rows = len(tree_dict)\n        if n_rows < self.settings.get('max_rows_for_col_resize', 5000):\n            self.widget.set_optimal_column_widths()\n            self.logger.debug('Resized columns for {0} row(s)'.format(n_rows))\n\n        tablename = table.get('name', 'NoName')\n        self.logger.debug('Displayed {0}'.format(tablename))", "response": "Display the given table object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef redo(self, channel, image):\n        chname = channel.name\n        if image is None:\n            # shouldn't happen, but let's play it safe\n            return\n\n        imname = image.get('name', 'none')\n        iminfo = channel.get_image_info(imname)\n        timestamp = iminfo.time_modified\n\n        if timestamp is None:\n            reason = iminfo.get('reason_modified', None)\n            if reason is not None:\n                self.fv.show_error(\n                    \"{0} invoked 'modified' callback to ChangeHistory with a \"\n                    \"reason but without a timestamp. The plugin invoking the \"\n                    \"callback is no longer be compatible with Ginga. \"\n                    \"Please contact plugin developer to update the plugin \"\n                    \"to use self.fv.update_image_info() like Mosaic \"\n                    \"plugin.\".format(imname))\n\n            # Image somehow lost its history\n            self.remove_image_info_cb(self.fv, channel, iminfo)\n            return\n\n        self.add_entry(chname, iminfo)", "response": "Add an entry with image modification info."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_image_info_cb(self, gshell, channel, iminfo):\n        chname = channel.name\n        if chname not in self.name_dict:\n            return\n\n        fileDict = self.name_dict[chname]\n\n        name = iminfo.name\n        if name not in fileDict:\n            return\n\n        del fileDict[name]\n        self.logger.debug('{0} removed from ChangeHistory'.format(name))\n\n        if not self.gui_up:\n            return False\n\n        self.clear_selected_history()\n        self.recreate_toc()", "response": "Delete entries related to deleted image."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd entries related to an added image.", "response": "def add_image_info_cb(self, gshell, channel, iminfo):\n        \"\"\"Add entries related to an added image.\"\"\"\n\n        timestamp = iminfo.time_modified\n        if timestamp is None:\n            # Not an image we are interested in tracking\n            return\n\n        self.add_entry(channel.name, iminfo)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling when a channel is deleted from the main interface.", "response": "def delete_channel_cb(self, gshell, chinfo):\n        \"\"\"Called when a channel is deleted from the main interface.\n        Parameter is chinfo (a bunch).\"\"\"\n        chname = chinfo.name\n\n        if chname not in self.name_dict:\n            return\n\n        del self.name_dict[chname]\n        self.logger.debug('{0} removed from ChangeHistory'.format(chname))\n\n        if not self.gui_up:\n            return False\n\n        self.clear_selected_history()\n        self.recreate_toc()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef drag_drop_cb(self, viewer, urls):\n        channel = self.fv.get_current_channel()\n        if channel is None:\n            return\n        self.fv.open_uris(urls, chname=channel.name, bulk_add=True)\n        return True", "response": "Open the URLs for the current channel and open them if needed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_channel_cb(self, viewer, channel):\n        fitsimage = channel.fitsimage\n        fitssettings = fitsimage.get_settings()\n        for name in ['cuts']:\n            fitssettings.get_setting(name).add_callback(\n                'set', self.cutset_cb, fitsimage)\n        fitsimage.add_callback('transform', self.transform_cb)\n\n        rgbmap = fitsimage.get_rgbmap()\n        rgbmap.add_callback('changed', self.rgbmap_cb, fitsimage)\n\n        # add old highlight set to channel external data\n        channel.extdata.setdefault('thumbs_old_highlight', set([]))", "response": "Called when a new channel is added from the main interface. This method is called when a new channel is added from the main interface."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_highlights(self, old_highlight_set, new_highlight_set):\n        with self.thmblock:\n            un_hilite_set = old_highlight_set - new_highlight_set\n            re_hilite_set = new_highlight_set - old_highlight_set\n\n            # highlight new labels that should be\n            bg = self.settings.get('label_bg_color', 'lightgreen')\n            fg = self.settings.get('label_font_color', 'black')\n\n            # unhighlight thumb labels that should NOT be highlighted any more\n            for thumbkey in un_hilite_set:\n                if thumbkey in self.thumb_dict:\n                    namelbl = self.thumb_dict[thumbkey].get('namelbl')\n                    namelbl.color = fg\n\n            for thumbkey in re_hilite_set:\n                if thumbkey in self.thumb_dict:\n                    namelbl = self.thumb_dict[thumbkey].get('namelbl')\n                    namelbl.color = bg\n\n        if self.gui_up:\n            self.c_view.redraw(whence=3)", "response": "Unhighlight the thumbnails represented by old_highlight_set and highlight the ones represented by new_highlight_set."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if we already have a thumbnail version of this image otherwise False.", "response": "def have_thumbnail(self, fitsimage, image):\n        \"\"\"Returns True if we already have a thumbnail version of this image\n        cached, False otherwise.\n        \"\"\"\n        chname = self.fv.get_channel_name(fitsimage)\n\n        # Look up our version of the thumb\n        idx = image.get('idx', None)\n        path = image.get('path', None)\n        if path is not None:\n            path = os.path.abspath(path)\n            name = iohelper.name_image_from_path(path, idx=idx)\n        else:\n            name = 'NoName'\n\n        # get image name\n        name = image.get('name', name)\n\n        thumbkey = self.get_thumb_key(chname, name, path)\n        with self.thmblock:\n            return thumbkey in self.thumb_dict"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_channel_cb(self, viewer, channel):\n        chname_del = channel.name\n        # TODO: delete thumbs for this channel!\n        self.logger.debug(\"deleting thumbs for channel '%s'\" % (chname_del))\n        with self.thmblock:\n            new_thumb_list = []\n            un_hilite_set = set([])\n            for thumbkey in self.thumb_list:\n                chname = thumbkey[0]\n                if chname != chname_del:\n                    new_thumb_list.append(thumbkey)\n                else:\n                    if thumbkey in self.thumb_dict:\n                        del self.thumb_dict[thumbkey]\n                    un_hilite_set.add(thumbkey)\n\n            self.thumb_list = new_thumb_list\n            self._tkf_highlight -= un_hilite_set  # Unhighlight\n\n        self.fv.gui_do_oneshot('thumbs-reorder', self.reorder_thumbs)", "response": "Called when a channel is deleted from the main interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nscrolls the window to the thumb.", "response": "def auto_scroll(self, thumbkey):\n        \"\"\"Scroll the window to the thumb.\"\"\"\n        if not self.gui_up:\n            return\n        # force scroll to bottom of thumbs, if checkbox is set\n        scrollp = self.w.auto_scroll.get_state()\n        if not scrollp:\n            return\n\n        bnch = self.thumb_dict[thumbkey]\n\n        # override X parameter because we only want to scroll vertically\n        pan_x, pan_y = self.c_view.get_pan()\n        self.c_view.panset_xy(pan_x, bnch.image.y)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clear_widget(self):\n        if not self.gui_up:\n            return\n        canvas = self.c_view.get_canvas()\n        canvas.delete_all_objects()\n        self.c_view.redraw(whence=0)", "response": "Clears the display widget of all thumbnails but does not remove them from the thumb_dict or thumb_list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a context menu.", "response": "def _mk_context_menu(self, thumbkey, chname, info):\n        \"\"\"NOTE: currently not used, but left here to be reincorporated\n        at some point.\n        \"\"\"\n        menu = Widgets.Menu()\n        item = menu.add_name(\"Display\")\n        item.add_callback('activated',\n                          lambda w: self.load_file(\n                              thumbkey, chname, info.name, info.path,\n                              info.image_future))\n        menu.add_separator()\n        item = menu.add_name(\"Remove\")\n        item.add_callback('activated',\n                          lambda w: self.fv.remove_image_by_name(\n                              chname, info.name, impath=info.path))\n\n        return menu"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_nddata(self, ndd, naxispath=None):\n        self.clear_metadata()\n\n        # Make a header based on any NDData metadata\n        ahdr = self.get_header()\n        ahdr.update(ndd.meta)\n\n        self.setup_data(ndd.data, naxispath=naxispath)\n\n        if ndd.wcs is None:\n            # no wcs in ndd obj--let's try to make one from the header\n            self.wcs = wcsmod.WCS(logger=self.logger)\n            self.wcs.load_header(ahdr)\n        else:\n            # already have a valid wcs in the ndd object\n            # we assume it needs an astropy compatible wcs\n            wcsinfo = wcsmod.get_wcs_class('astropy')\n            self.wcs = wcsinfo.wrapper_class(logger=self.logger)\n            self.wcs.load_nddata(ndd)", "response": "Load from an astropy. nddata. NDData object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads from an ASDF object.", "response": "def load_asdf(self, asdf_obj, **kwargs):\n        \"\"\"\n        Load from an ASDF object.\n        See :func:`ginga.util.io_asdf.load_asdf` for more info.\n        \"\"\"\n        self.clear_metadata()\n\n        data, wcs, ahdr = io_asdf.load_asdf(asdf_obj, **kwargs)\n\n        self.setup_data(data, naxispath=None)\n\n        wcsinfo = wcsmod.get_wcs_class('astropy_ape14')\n        self.wcs = wcsinfo.wrapper_class(logger=self.logger)\n        self.wcs.wcs = wcs\n\n        if wcs is not None:\n            self.wcs.coordsys = wcs.output_frame.name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_naxispath(self, naxispath):\n        revnaxis = list(naxispath)\n        revnaxis.reverse()\n\n        # construct slice view and extract it\n        view = tuple(revnaxis + [slice(None), slice(None)])\n        data = self.get_mddata()[view]\n\n        if len(data.shape) != 2:\n            raise ImageError(\n                \"naxispath does not lead to a 2D slice: {}\".format(naxispath))\n\n        self.naxispath = naxispath\n        self.revnaxis = revnaxis\n\n        self.set_data(data)", "response": "Choose a slice out of multidimensional data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting an item from the fits header if any.", "response": "def get_keyword(self, kwd, *args):\n        \"\"\"Get an item from the fits header, if any.\"\"\"\n        try:\n            kwds = self.get_header()\n            return kwds[kwd]\n        except KeyError:\n            # return a default if there is one\n            if len(args) > 0:\n                return args[0]\n            raise KeyError(kwd)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_data(self, data_np, metadata=None, astype=None):\n        self.set_data(data_np.copy(), metadata=metadata,\n                      astype=astype)", "response": "Update the data of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef as_nddata(self, nddata_class=None):\n        \"Return a version of ourself as an astropy.nddata.NDData object\"\n        if nddata_class is None:\n            from astropy.nddata import NDData\n            nddata_class = NDData\n\n        # transfer header, preserving ordering\n        ahdr = self.get_header()\n        header = OrderedDict(ahdr.items())\n        data = self.get_mddata()\n\n        wcs = None\n        if hasattr(self, 'wcs') and self.wcs is not None:\n            # for now, assume self.wcs wraps an astropy wcs object\n            wcs = self.wcs.wcs\n\n        ndd = nddata_class(data, wcs=wcs, meta=header)\n        return ndd", "response": "Return a version of ourself as an astropy. nddata. NDData object"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef as_hdu(self):\n        \"Return a version of ourself as an astropy.io.fits.PrimaryHDU object\"\n        from astropy.io import fits\n\n        # transfer header, preserving ordering\n        ahdr = self.get_header()\n        header = fits.Header(ahdr.items())\n        data = self.get_mddata()\n\n        hdu = fits.PrimaryHDU(data=data, header=header)\n        return hdu", "response": "Return a version of ourself as an astropy. io. fits. PrimaryHDU object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef astype(self, type_name):\n        if type_name == 'nddata':\n            return self.as_nddata()\n\n        if type_name == 'hdu':\n            return self.as_hdu()\n\n        raise ValueError(\"Unrecognized conversion type '%s'\" % (type_name))", "response": "Convert AstroImage object to some other kind of object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calc_radius_xy(self, x, y, radius_deg):\n        # calculate ra/dec of x,y pixel\n        ra_deg, dec_deg = self.pixtoradec(x, y)\n\n        # Calculate position 1 degree from the given one\n        # NOTE: this needs to add in DEC, not RA\n        ra2_deg, dec2_deg = wcs.add_offset_radec(ra_deg, dec_deg,\n                                                 0.0, 1.0)\n\n        # Calculate the length of this segment--it is pixels/deg\n        x2, y2 = self.radectopix(ra2_deg, dec2_deg)\n        px_per_deg_e = math.sqrt(math.fabs(x2 - x)**2 + math.fabs(y2 - y)**2)\n\n        # calculate radius based on desired radius_deg\n        radius_px = px_per_deg_e * radius_deg\n        return radius_px", "response": "Calculate a radius from the point x y to a circle\n        defined by radius in degrees."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndrop new images into the current image (if there is room), relocating them according the WCS between the two images.", "response": "def mosaic_inline(self, imagelist, bg_ref=None, trim_px=None,\n                      merge=False, allow_expand=True, expand_pad_deg=0.01,\n                      max_expand_pct=None,\n                      update_minmax=True, suppress_callback=False):\n        \"\"\"Drops new images into the current image (if there is room),\n        relocating them according the WCS between the two images.\n        \"\"\"\n        # Get our own (mosaic) rotation and scale\n        header = self.get_header()\n        ((xrot_ref, yrot_ref),\n         (cdelt1_ref, cdelt2_ref)) = wcs.get_xy_rotation_and_scale(header)\n\n        scale_x, scale_y = math.fabs(cdelt1_ref), math.fabs(cdelt2_ref)\n\n        # drop each image in the right place in the new data array\n        mydata = self._get_data()\n\n        count = 1\n        res = []\n        for image in imagelist:\n            name = image.get('name', 'image%d' % (count))\n            count += 1\n\n            data_np = image._get_data()\n            if 0 in data_np.shape:\n                self.logger.info(\"Skipping image with zero length axis\")\n                continue\n\n            # Calculate sky position at the center of the piece\n            ctr_x, ctr_y = trcalc.get_center(data_np)\n            ra, dec = image.pixtoradec(ctr_x, ctr_y)\n\n            # User specified a trim?  If so, trim edge pixels from each\n            # side of the array\n            ht, wd = data_np.shape[:2]\n            if trim_px:\n                xlo, xhi = trim_px, wd - trim_px\n                ylo, yhi = trim_px, ht - trim_px\n                data_np = data_np[ylo:yhi, xlo:xhi, ...]\n                ht, wd = data_np.shape[:2]\n\n            # If caller asked us to match background of pieces then\n            # get the median of this piece\n            if bg_ref is not None:\n                bg = iqcalc.get_median(data_np)\n                bg_inc = bg_ref - bg\n                data_np = data_np + bg_inc\n\n            # Determine max/min to update our values\n            if update_minmax:\n                maxval = np.nanmax(data_np)\n                minval = np.nanmin(data_np)\n                self.maxval = max(self.maxval, maxval)\n                self.minval = min(self.minval, minval)\n\n            # Get rotation and scale of piece\n            header = image.get_header()\n            ((xrot, yrot),\n             (cdelt1, cdelt2)) = wcs.get_xy_rotation_and_scale(header)\n            self.logger.debug(\"image(%s) xrot=%f yrot=%f cdelt1=%f \"\n                              \"cdelt2=%f\" % (name, xrot, yrot, cdelt1, cdelt2))\n\n            # scale if necessary\n            # TODO: combine with rotation?\n            if (not np.isclose(math.fabs(cdelt1), scale_x) or\n                not np.isclose(math.fabs(cdelt2), scale_y)):\n                nscale_x = math.fabs(cdelt1) / scale_x\n                nscale_y = math.fabs(cdelt2) / scale_y\n                self.logger.debug(\"scaling piece by x(%f), y(%f)\" % (\n                    nscale_x, nscale_y))\n                data_np, (ascale_x, ascale_y) = trcalc.get_scaled_cutout_basic(\n                    data_np, 0, 0, wd - 1, ht - 1, nscale_x, nscale_y,\n                    logger=self.logger)\n\n            # Rotate piece into our orientation, according to wcs\n            rot_dx, rot_dy = xrot - xrot_ref, yrot - yrot_ref\n\n            flip_x = False\n            flip_y = False\n\n            # Optomization for 180 rotations\n            if (np.isclose(math.fabs(rot_dx), 180.0) or\n                np.isclose(math.fabs(rot_dy), 180.0)):\n                rotdata = trcalc.transform(data_np,\n                                           flip_x=True, flip_y=True)\n                rot_dx = 0.0\n                rot_dy = 0.0\n            else:\n                rotdata = data_np\n\n            # Finish with any necessary rotation of piece\n            if not np.isclose(rot_dy, 0.0):\n                rot_deg = rot_dy\n                self.logger.debug(\"rotating %s by %f deg\" % (name, rot_deg))\n                rotdata = trcalc.rotate(rotdata, rot_deg,\n                                        #rotctr_x=ctr_x, rotctr_y=ctr_y\n                                        logger=self.logger)\n\n            # Flip X due to negative CDELT1\n            if np.sign(cdelt1) != np.sign(cdelt1_ref):\n                flip_x = True\n\n            # Flip Y due to negative CDELT2\n            if np.sign(cdelt2) != np.sign(cdelt2_ref):\n                flip_y = True\n\n            if flip_x or flip_y:\n                rotdata = trcalc.transform(rotdata,\n                                           flip_x=flip_x, flip_y=flip_y)\n\n            # Get size and data of new image\n            ht, wd = rotdata.shape[:2]\n            ctr_x, ctr_y = trcalc.get_center(rotdata)\n\n            # Find location of image piece (center) in our array\n            x0, y0 = self.radectopix(ra, dec)\n\n            # Merge piece as closely as possible into our array\n            # Unfortunately we lose a little precision rounding to the\n            # nearest pixel--can't be helped with this approach\n            x0, y0 = int(np.round(x0)), int(np.round(y0))\n            self.logger.debug(\"Fitting image '%s' into mosaic at %d,%d\" % (\n                name, x0, y0))\n\n            # This is for useful debugging info only\n            my_ctr_x, my_ctr_y = trcalc.get_center(mydata)\n            off_x, off_y = x0 - my_ctr_x, y0 - my_ctr_y\n            self.logger.debug(\"centering offsets: %d,%d\" % (off_x, off_y))\n\n            # Sanity check piece placement\n            xlo, xhi = x0 - ctr_x, x0 + wd - ctr_x\n            ylo, yhi = y0 - ctr_y, y0 + ht - ctr_y\n            assert (xhi - xlo == wd), \\\n                Exception(\"Width differential %d != %d\" % (xhi - xlo, wd))\n            assert (yhi - ylo == ht), \\\n                Exception(\"Height differential %d != %d\" % (yhi - ylo, ht))\n\n            mywd, myht = self.get_size()\n            if xlo < 0 or xhi > mywd or ylo < 0 or yhi > myht:\n                if not allow_expand:\n                    raise Exception(\"New piece doesn't fit on image and \"\n                                    \"allow_expand=False\")\n\n                # <-- Resize our data array to allow the new image\n\n                # determine amount to pad expansion by\n                expand_x = max(int(expand_pad_deg / scale_x), 0)\n                expand_y = max(int(expand_pad_deg / scale_y), 0)\n\n                nx1_off, nx2_off = 0, 0\n                if xlo < 0:\n                    nx1_off = abs(xlo) + expand_x\n                if xhi > mywd:\n                    nx2_off = (xhi - mywd) + expand_x\n                xlo, xhi = xlo + nx1_off, xhi + nx1_off\n\n                ny1_off, ny2_off = 0, 0\n                if ylo < 0:\n                    ny1_off = abs(ylo) + expand_y\n                if yhi > myht:\n                    ny2_off = (yhi - myht) + expand_y\n                ylo, yhi = ylo + ny1_off, yhi + ny1_off\n\n                new_wd = mywd + nx1_off + nx2_off\n                new_ht = myht + ny1_off + ny2_off\n\n                # sanity check on new mosaic size\n                old_area = mywd * myht\n                new_area = new_wd * new_ht\n                expand_pct = new_area / old_area\n                if ((max_expand_pct is not None) and\n                        (expand_pct > max_expand_pct)):\n                    raise Exception(\"New area exceeds current one by %.2f %%;\"\n                                    \"increase max_expand_pct (%.2f) to allow\" %\n                                    (expand_pct * 100, max_expand_pct))\n\n                # go for it!\n                new_data = np.zeros((new_ht, new_wd))\n                # place current data into new data\n                new_data[ny1_off:ny1_off + myht, nx1_off:nx1_off + mywd] = \\\n                    mydata\n                self._data = new_data\n                mydata = new_data\n\n                if (nx1_off > 0) or (ny1_off > 0):\n                    # Adjust our WCS for relocation of the reference pixel\n                    crpix1, crpix2 = self.get_keywords_list('CRPIX1', 'CRPIX2')\n                    kwds = dict(CRPIX1=crpix1 + nx1_off,\n                                CRPIX2=crpix2 + ny1_off)\n                    self.update_keywords(kwds)\n\n            # fit image piece into our array\n            try:\n                if merge:\n                    mydata[ylo:yhi, xlo:xhi, ...] += rotdata[0:ht, 0:wd, ...]\n                else:\n                    idx = (mydata[ylo:yhi, xlo:xhi, ...] == 0.0)\n                    mydata[ylo:yhi, xlo:xhi, ...][idx] = \\\n                        rotdata[0:ht, 0:wd, ...][idx]\n\n            except Exception as e:\n                self.logger.error(\"Error fitting tile: %s\" % (str(e)))\n                raise\n\n            res.append((xlo, ylo, xhi, yhi))\n\n        # TODO: recalculate min and max values\n        # Can't use usual techniques because it adds too much time to the\n        # mosacing\n        #self._set_minmax()\n\n        # Notify watchers that our data has changed\n        if not suppress_callback:\n            self.make_callback('modified')\n\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hmsToDeg(h, m, s):\n    return h * degPerHMSHour + m * degPerHMSMin + s * degPerHMSSec", "response": "Convert RA hours minutes seconds into an angle in degrees."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dmsToDeg(sign, deg, min, sec):\n    return sign * (deg + min * degPerDmsMin + sec * degPerDmsSec)", "response": "Convert a dec sign degrees minutes seconds into a signed angle in\n    degrees."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef decTimeToDeg(sign_sym, deg, min, sec):\n    if sign_sym == -1 or sign_sym == '-':\n        sign = -1\n    else:\n        sign = 1\n    return dmsToDeg(sign, deg, min, sec)", "response": "Convert a dec sign degrees minutes seconds into a signed angle in\n    degrees."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert the ra ( in degrees ) to HMS three tuple.", "response": "def degToHms(ra):\n    \"\"\"Converts the ra (in degrees) to HMS three tuple.\n    H and M are in integer and the S part is in float.\n    \"\"\"\n    assert (ra >= 0.0), WCSError(\"RA (%f) is negative\" % (ra))\n    assert ra < 360.0, WCSError(\"RA (%f) > 360.0\" % (ra))\n    rah = ra / degPerHMSHour\n    ramin = (ra % degPerHMSHour) * HMSMinPerDeg\n    rasec = (ra % degPerHMSMin) * HMSSecPerDeg\n    return (int(rah), int(ramin), rasec)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert the dec in degrees to an integer sign D M and S tuple.", "response": "def degToDms(dec, isLatitude=True):\n    \"\"\"Convert the dec, in degrees, to an (sign,D,M,S) tuple.\n    D and M are integer, and sign and S are float.\n    \"\"\"\n    if isLatitude:\n        assert dec <= 90, WCSError(\"DEC (%f) > 90.0\" % (dec))\n        assert dec >= -90, WCSError(\"DEC (%f) < -90.0\" % (dec))\n\n    if dec < 0.0:\n        sign = -1.0\n    else:\n        sign = 1.0\n    dec = dec * sign\n\n    #mnt = (dec % 1.0) * 60.0\n    #sec = (dec % (1.0/60.0)) * 3600.0\n    # this calculation with return values produces conversion problem.\n    # e.g. dec +311600.00 -> 31.2666666667 degree\n    # deg=31 min=15 sec=60 instead deg=31 min=16 sec=0.0\n    # bug fixed\n    mnt, sec = divmod(dec * 3600, 60)\n    deg, mnt = divmod(mnt, 60)\n\n    return (int(sign), int(deg), int(mnt), sec)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hmsStrToDeg(ra):\n    hour, min, sec = ra.split(':')\n    ra_deg = hmsToDeg(int(hour), int(min), float(sec))\n    return ra_deg", "response": "Convert a string representation of RA into a float in degrees."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dmsStrToDeg(dec):\n    sign_deg, min, sec = dec.split(':')\n    sign = sign_deg[0:1]\n    if sign not in ('+', '-'):\n        sign = '+'\n        deg = sign_deg\n    else:\n        deg = sign_deg[1:]\n    dec_deg = decTimeToDeg(sign, int(deg), int(min), float(sec))\n    return dec_deg", "response": "Convert a string representation of DEC into a float in degrees."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef eqToEq2000(ra_deg, dec_deg, eq):\n    ra_rad = math.radians(ra_deg)\n    dec_rad = math.radians(dec_deg)\n\n    x = math.cos(dec_rad) * math.cos(ra_rad)\n    y = math.cos(dec_rad) * math.sin(ra_rad)\n    z = math.sin(dec_rad)\n\n    p11, p12, p13, p21, p22, p23, p31, p32, p33 = trans_coeff(eq, x, y, z)\n\n    x0 = p11 * x + p21 * y + p31 * z\n    y0 = p12 * x + p22 * y + p32 * z\n    z0 = p13 * x + p23 * y + p33 * z\n\n    new_dec = math.asin(z0)\n    if x0 == 0.0:\n        new_ra = math.pi / 2.0\n    else:\n        new_ra = math.atan(y0 / x0)\n\n    if ((y0 * math.cos(new_dec) > 0.0 and x0 * math.cos(new_dec) <= 0.0) or\n            (y0 * math.cos(new_dec) <= 0.0 and x0 * math.cos(new_dec) < 0.0)):\n        new_ra += math.pi\n\n    elif new_ra < 0.0:\n        new_ra += 2.0 * math.pi\n\n    #new_ra = new_ra * 12.0 * 3600.0 / math.pi\n    new_ra_deg = new_ra * 12.0 / math.pi * 15.0\n\n    #new_dec = new_dec * 180.0 * 3600.0 / math.pi\n    new_dec_deg = new_dec * 180.0 / math.pi\n\n    return (new_ra_deg, new_dec_deg)", "response": "Convert Eq to Eq 2000."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_xy_rotation_and_scale(header):\n\n    def calc_from_cd(cd1_1, cd1_2, cd2_1, cd2_2):\n\n        # TODO: Check if first coordinate in CTYPE is latitude\n        # if (ctype EQ 'DEC-') or (strmid(ctype, 1) EQ 'LAT')  then $\n        #    cd = reverse(cd,1)\n\n        det = cd1_1 * cd2_2 - cd1_2 * cd2_1\n        if det < 0:\n            sgn = -1\n        else:\n            sgn = 1\n        ## if det > 0:\n        ##     raise ValueError(\"Astrometry is for a right-handed coordinate system\")\n\n        if (cd2_1 == 0.0) or (cd1_2 == 0.0):\n            # Unrotated coordinates?\n            xrot = 0.0\n            yrot = 0.0\n            cdelt1 = cd1_1\n            cdelt2 = cd2_2\n        else:\n            xrot = math.atan2(sgn * cd1_2, sgn * cd1_1)\n            yrot = math.atan2(-cd2_1, cd2_2)\n\n            cdelt1 = sgn * math.sqrt(cd1_1**2 + cd1_2**2)\n            cdelt2 = math.sqrt(cd1_1**2 + cd2_1**2)\n\n        return xrot, yrot, cdelt1, cdelt2\n\n    def calc_from_crota():\n        try:\n            crota1 = float(header['CROTA1'])\n            xrot = crota1\n        except KeyError:\n            xrot = None\n\n        try:\n            crota2 = float(header['CROTA2'])\n            yrot = crota2\n        except KeyError:\n            yrot = 0.0\n\n        if xrot is None:\n            xrot = yrot\n\n        cdelt1 = float(header.get('CDELT1', 1.0))\n        cdelt2 = float(header.get('CDELT2', 1.0))\n\n        return xrot, yrot, cdelt1, cdelt2\n\n    # 1st, check for presence of PC matrix\n    try:\n        pc1_1 = header['PC1_1']\n        pc1_2 = header['PC1_2']\n        pc2_1 = header['PC2_1']\n        pc2_2 = header['PC2_2']\n\n        cdelt1 = float(header['CDELT1'])\n        cdelt2 = float(header['CDELT2'])\n\n        cd1_1, cd1_2 = pc1_1 * cdelt1, pc1_2 * cdelt1\n        cd2_1, cd2_2 = pc2_1 * cdelt2, pc2_2 * cdelt2\n\n        xrot, yrot, cdelt1p, cdelt2p = calc_from_cd(pc1_1, pc1_2,\n                                                    pc2_1, pc2_2)\n\n    except KeyError:\n        # 2nd, check for presence of CD matrix\n        try:\n            cd1_1 = header['CD1_1']\n            cd1_2 = header['CD1_2']\n            cd2_1 = header['CD2_1']\n            cd2_2 = header['CD2_2']\n            xrot, yrot, cdelt1, cdelt2 = calc_from_cd(cd1_1, cd1_2,\n                                                      cd2_1, cd2_2)\n\n        except KeyError:\n            # 3rd, check for presence of CROTA keyword\n            #  (or default is north=up)\n            xrot, yrot, cdelt1, cdelt2 = calc_from_crota()\n\n    xrot, yrot = math.degrees(xrot), math.degrees(yrot)\n\n    return ((xrot, yrot), (cdelt1, cdelt2))", "response": "Calculates the x y rotation and scale of the current IDL record."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating rotation and scale.", "response": "def get_rotation_and_scale(header, skew_threshold=0.001):\n    \"\"\"Calculate rotation and CDELT.\"\"\"\n    ((xrot, yrot),\n     (cdelt1, cdelt2)) = get_xy_rotation_and_scale(header)\n\n    if math.fabs(xrot) - math.fabs(yrot) > skew_threshold:\n        raise ValueError(\"Skew detected: xrot=%.4f yrot=%.4f\" % (\n            xrot, yrot))\n    rot = yrot\n\n    lonpole = float(header.get('LONPOLE', 180.0))\n    if lonpole != 180.0:\n        rot += 180.0 - lonpole\n\n    return (rot, cdelt1, cdelt2)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompute the relative orientation and scale of an image to a reference image.", "response": "def get_relative_orientation(image, ref_image):\n    \"\"\"Computes the relative orientation and scale of an image to a reference\n    image.\n\n    Parameters\n    ----------\n    image\n        AstroImage based object\n\n    ref_image\n        AstroImage based object\n\n    Returns\n    -------\n    result\n        Bunch object containing the relative scale in x and y\n        and the relative rotation in degrees.\n\n    \"\"\"\n    # Get reference image rotation and scale\n    header = ref_image.get_header()\n    ((xrot_ref, yrot_ref),\n     (cdelt1_ref, cdelt2_ref)) = get_xy_rotation_and_scale(header)\n\n    scale_x, scale_y = math.fabs(cdelt1_ref), math.fabs(cdelt2_ref)\n\n    # Get rotation and scale of image\n    header = image.get_header()\n    ((xrot, yrot),\n     (cdelt1, cdelt2)) = get_xy_rotation_and_scale(header)\n\n    # Determine relative scale of this image to the reference\n    rscale_x = math.fabs(cdelt1) / scale_x\n    rscale_y = math.fabs(cdelt2) / scale_y\n\n    # Figure out rotation relative to our orientation\n    rrot_dx, rrot_dy = xrot - xrot_ref, yrot - yrot_ref\n\n    # flip_x = False\n    # flip_y = False\n\n    # ## # Flip X due to negative CDELT1\n    # ## if np.sign(cdelt1) < 0:\n    # ##     flip_x = True\n\n    # ## # Flip Y due to negative CDELT2\n    # ## if np.sign(cdelt2) < 0:\n    # ##     flip_y = True\n\n    # # Optomization for 180 rotations\n    # if np.isclose(math.fabs(rrot_dx), 180.0):\n    #     flip_x = not flip_x\n    #     rrot_dx = 0.0\n    # if np.isclose(math.fabs(rrot_dy), 180.0):\n    #     flip_y = not flip_y\n    #     rrot_dy = 0.0\n\n    rrot_deg = max(rrot_dx, rrot_dy)\n\n    res = Bunch.Bunch(rscale_x=rscale_x, rscale_y=rscale_y,\n                      rrot_deg=rrot_deg)\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating a set of WCS keywords for a 2D simple instrument FITS file with a 'standard' RA/DEC pixel projection. Parameters ---------- px_x (ZERO-based) reference pixel of field in X (usually center of field) px_y (ZERO-based) reference pixel of field in Y (usually center of field) ra_deg RA (in deg) for the reference point dec_deg DEC (in deg) for the reference point px_scale_deg_px Pixel scale (deg/pixel); can be a tuple for different x,y scales rot_deg Rotation angle of the field (in deg) cdbase CD base Returns ------- res : dict Ordered dictionary object containing WCS headers.", "response": "def simple_wcs(px_x, px_y, ra_deg, dec_deg, px_scale_deg_px, rot_deg,\n               cdbase=[1, 1]):\n    \"\"\"Calculate a set of WCS keywords for a 2D simple instrument FITS\n    file with a 'standard' RA/DEC pixel projection.\n\n    Parameters\n    ----------\n    px_x\n        (ZERO-based) reference pixel of field in X\n        (usually center of field)\n\n    px_y\n        (ZERO-based) reference pixel of field in Y\n        (usually center of field)\n\n    ra_deg\n        RA (in deg) for the reference point\n\n    dec_deg\n        DEC (in deg) for the reference point\n\n    px_scale_deg_px\n        Pixel scale (deg/pixel); can be a tuple for different x,y scales\n\n    rot_deg\n        Rotation angle of the field (in deg)\n\n    cdbase\n        CD base\n\n    Returns\n    -------\n    res : dict\n        Ordered dictionary object containing WCS headers.\n\n    \"\"\"\n    # center of the projection\n    crpix = (px_x + 1, px_y + 1)  # pixel position (WCS is 1 based)\n    crval = (ra_deg, dec_deg)  # RA, Dec (degrees)\n\n    # image scale in deg/pix\n    cdelt = np.array(cdbase) * np.array(px_scale_deg_px)\n\n    # Create rotation matrix for position angle of north (radians E of N)\n    rot_rad = np.radians(rot_deg)\n    cpa = np.cos(rot_rad)\n    spa = np.sin(rot_rad)\n    # a) clockwise rotation\n    pc = np.array([[cpa, spa], [-spa, cpa]])\n    # b) counter clockwise\n    #pc = np.array([[cpa, -spa], [spa, cpa]])\n\n    #cd = pc * cdelt\n\n    res = OrderedDict((('CRVAL1', crval[0]),\n                       ('CRVAL2', crval[1]),\n                       ('CRPIX1', crpix[0]),\n                       ('CRPIX2', crpix[1]),\n                       ('CUNIT1', 'deg'),\n                       ('CUNIT2', 'deg'),\n                       ('CTYPE1', 'RA---TAN'),\n                       ('CTYPE2', 'DEC--TAN'),\n                       ('RADESYS', 'FK5'),\n                       # Either PC + CDELT or CD should appear\n                       # PC + CDELT seems to be the preferred approach\n                       # according to the Calabretta papers\n                       ('CDELT1', cdelt[0]),\n                       ('CDELT2', cdelt[1]),\n                       ('PC1_1', pc[0, 0]),\n                       ('PC1_2', pc[0, 1]),\n                       ('PC2_1', pc[1, 0]),\n                       ('PC2_2', pc[1, 1])\n                       ## ('CD1_1' , cd[0, 0]),\n                       ## ('CD1_2' , cd[0, 1]),\n                       ## ('CD2_1' , cd[1, 0]),\n                       ## ('CD2_2' , cd[1, 1]),\n                       ))\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dispos(dra0, decd0, dra, decd):\n    radian = 180.0 / math.pi\n\n    # coord transformed in radians\n    alf = dra / radian\n    alf0 = dra0 / radian\n    del_ = decd / radian\n    del0 = decd0 / radian\n\n    sd0 = math.sin(del0)\n    sd = math.sin(del_)\n    cd0 = math.cos(del0)\n    cd = math.cos(del_)\n    cosda = math.cos(alf - alf0)\n    cosd = sd0 * sd + cd0 * cd * cosda\n    dist = math.acos(cosd)\n    phi = 0.0\n    if dist > 0.0000004:\n        sind = math.sin(dist)\n        cospa = (sd * cd0 - cd * sd0 * cosda) / sind\n        #if cospa > 1.0:\n        #    cospa=1.0\n        if math.fabs(cospa) > 1.0:\n            # 2005-06-02: fix from awicenec@eso.org\n            cospa = cospa / math.fabs(cospa)\n        sinpa = cd * math.sin(alf - alf0) / sind\n        phi = math.acos(cospa) * radian\n        if sinpa < 0.0:\n            phi = 360.0 - phi\n    dist *= radian\n    dist *= 60.0\n    if decd0 == 90.0:\n        phi = 180.0\n    if decd0 == -90.0:\n        phi = 0.0\n    return (phi, dist)", "response": "Compute distance and position angle solving a spherical\n    triangle."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the delta in degrees between two points in the spherical triangulation.", "response": "def deltaStarsRaDecDeg1(ra1_deg, dec1_deg, ra2_deg, dec2_deg):\n    \"\"\"Spherical triangulation.\"\"\"\n    phi, dist = dispos(ra1_deg, dec1_deg, ra2_deg, dec2_deg)\n    return arcsecToDeg(dist * 60.0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_starsep_RaDecDeg(ra1_deg, dec1_deg, ra2_deg, dec2_deg):\n    sep = deltaStarsRaDecDeg(ra1_deg, dec1_deg, ra2_deg, dec2_deg)\n    sgn, deg, mn, sec = degToDms(sep)\n    if deg != 0:\n        txt = '%02d:%02d:%06.3f' % (deg, mn, sec)\n    else:\n        txt = '%02d:%06.3f' % (mn, sec)\n    return txt", "response": "Calculate separation between two points."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate offset between two RA and DEC.", "response": "def get_RaDecOffsets(ra1_deg, dec1_deg, ra2_deg, dec2_deg):\n    \"\"\"Calculate offset.\"\"\"\n    delta_ra_deg = ra1_deg - ra2_deg\n    adj = math.cos(math.radians(dec2_deg))\n    if delta_ra_deg > 180.0:\n        delta_ra_deg = (delta_ra_deg - 360.0) * adj\n    elif delta_ra_deg < -180.0:\n        delta_ra_deg = (delta_ra_deg + 360.0) * adj\n    else:\n        delta_ra_deg *= adj\n\n    delta_dec_deg = dec1_deg - dec2_deg\n    return (delta_ra_deg, delta_dec_deg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert longitude to degrees.", "response": "def lon_to_deg(lon):\n    \"\"\"Convert longitude to degrees.\"\"\"\n    if isinstance(lon, str) and (':' in lon):\n        # TODO: handle other coordinate systems\n        lon_deg = hmsStrToDeg(lon)\n    else:\n        lon_deg = float(lon)\n    return lon_deg"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef lat_to_deg(lat):\n    if isinstance(lat, str) and (':' in lat):\n        # TODO: handle other coordinate systems\n        lat_deg = dmsStrToDeg(lat)\n    else:\n        lat_deg = float(lat)\n    return lat_deg", "response": "Convert latitude to degrees."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_ruler_distances(image, p1, p2):\n    x1, y1 = p1[:2]\n    x2, y2 = p2[:2]\n\n    dx, dy = x2 - x1, y2 - y1\n    res = Bunch.Bunch(x1=x1, y1=y1, x2=x2, y2=y2,\n                      theta=np.arctan2(y2 - y1, x2 - x1),\n                      dx_pix=dx, dy_pix=dy,\n                      dh_pix=np.sqrt(dx**2 + dy**2),\n                      ra_org=None, dec_org=None,\n                      ra_dst=None, dec_dst=None,\n                      ra_heel=None, dec_heel=None,\n                      dx_deg=None, dy_deg=None, dh_deg=None)\n\n    if image is not None and hasattr(image, 'wcs') and image.wcs is not None:\n        # Calculate RA and DEC for the three points\n        try:\n            # origination point\n            ra_org, dec_org = image.pixtoradec(x1, y1)\n            res.ra_org, res.dec_org = ra_org, dec_org\n\n            # destination point\n            ra_dst, dec_dst = image.pixtoradec(x2, y2)\n            res.ra_dst, res.dec_dst = ra_dst, dec_dst\n\n            # \"heel\" point making a right triangle\n            ra_heel, dec_heel = image.pixtoradec(x2, y1)\n            res.ra_heel, res.dec_heel = ra_heel, dec_heel\n\n            res.dh_deg = deltaStarsRaDecDeg(ra_org, dec_org,\n                                            ra_dst, dec_dst)\n            res.dx_deg = deltaStarsRaDecDeg(ra_org, dec_org,\n                                            ra_heel, dec_heel)\n            res.dy_deg = deltaStarsRaDecDeg(ra_heel, dec_heel,\n                                            ra_dst, dec_dst)\n        except Exception as e:\n            pass\n\n    return res", "response": "Calculate the distance between two points."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nuse for generating thumbnails. Does not include overlaid graphics.", "response": "def get_plain_image_as_widget(self):\n        \"\"\"Used for generating thumbnails.  Does not include overlaid\n        graphics.\n        \"\"\"\n        pixbuf = self.get_plain_image_as_pixbuf()\n        image = Gtk.Image()\n        image.set_from_pixbuf(pixbuf)\n        image.show()\n        return image"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nuse for generating thumbnails. Does not include overlaid graphics.", "response": "def save_plain_image_as_file(self, filepath, format='png', quality=90):\n        \"\"\"Used for generating thumbnails.  Does not include overlaid\n        graphics.\n        \"\"\"\n        pixbuf = self.get_plain_image_as_pixbuf()\n        options, values = [], []\n        if format == 'jpeg':\n            options.append('quality')\n            values.append(str(quality))\n        pixbuf.savev(filepath, format, options, values)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a data point to a given coordinate system.", "response": "def datapt_to_system(self, datapt, system=None, coords='data',\n                         naxispath=None):\n        \"\"\"\n        Map points to given coordinate system.\n\n        Parameters\n        ----------\n        datapt : array-like\n            Pixel coordinates in the format of\n            ``[[x0, y0, ...], [x1, y1, ...], ..., [xn, yn, ...]]``.\n\n        system : str or None, optional, default to 'icrs'\n            Coordinate system name.\n\n        coords : 'data' or None, optional, default to 'data'\n            Expresses whether the data coordinate is indexed from zero\n\n        naxispath : list-like or None, optional, defaults to None\n            A sequence defining the pixel indexes > 2D, if any\n\n        Returns\n        -------\n        coord : SkyCoord\n\n        \"\"\"\n        if self.coordsys == 'raw':\n            raise common.WCSError(\"No usable WCS\")\n\n        if system is None:\n            system = 'icrs'\n\n        wcspt = self.datapt_to_wcspt(datapt, coords=coords,\n                                     naxispath=naxispath)\n\n        frame_class = coordinates.frame_transform_graph.lookup_name(\n            self.coordsys)\n        ra_deg = wcspt[:, 0]\n        dec_deg = wcspt[:, 1]\n        coord = frame_class(ra_deg * units.degree, dec_deg * units.degree)\n        to_class = coordinates.frame_transform_graph.lookup_name(system)\n        # Skip if input and output is the same (no realize_frame\n        # call in astropy)\n        if to_class != frame_class:\n            coord = coord.transform_to(to_class)\n\n        return coord"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_font(font_file, font_name=None):\n    global font_dir\n\n    if font_name is None:\n        # determine family name from filename of font\n        dirname, filename = os.path.split(font_file)\n        font_name, ext = os.path.splitext(filename)\n\n    font_dir[font_name] = Bunch.Bunch(name=font_name, font_path=font_file)\n\n    return font_name", "response": "Add a font description to our internal font directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if the given font name is registered as one of our externally loadable fonts.", "response": "def have_font(font_name):\n    \"\"\"Return True if the given font name is registered as one of our\n    externally loadable fonts.  If `font_name` is not found, it will try\n    to look it up as an alias and report if that is found.\n    \"\"\"\n    if font_name in font_dir:\n        return True\n\n    # try it as an alias\n    font_name = resolve_alias(font_name, font_name)\n    return font_name in font_dir"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_font_info(font_name, subst_ok=True):\n    global font_dir\n    if font_name in font_dir:\n        font_info = font_dir[font_name]\n    elif subst_ok:\n        # substitute an alternate font\n        font_name = resolve_alias('fixed', 'fixed')\n        font_info = font_dir[font_name]\n    else:\n        raise KeyError(font_name)\n\n    return font_info", "response": "Return known info on a font."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nplot a cuts plot for the current object.", "response": "def cuts(self, data,\n             xtitle=None, ytitle=None, title=None, rtitle=None,\n             color=None):\n        \"\"\"data: pixel values along a line.\n        \"\"\"\n        y = data\n        x = np.arange(len(data))\n\n        self.plot(x, y, color=color, drawstyle='steps-mid',\n                  xtitle=xtitle, ytitle=ytitle, title=title, rtitle=rtitle,\n                  alpha=1.0, linewidth=1.0, linestyle='-')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmultiply the alpha value of a set of images.", "response": "def alpha_multiply(self, alpha, data, shape=None):\n        \"\"\"(alpha) can be a scalar or an array.\n        \"\"\"\n        # alpha can be a scalar or an array\n        if shape is None:\n            shape = data.shape\n\n        if len(data.shape) == 2:\n            res = alpha * data\n            # If desired shape is monochrome then return a mono image\n            # otherwise broadcast to a grey color image.\n            if len(shape) == 2:\n                return res\n\n            # note: in timing tests, dstack was not as efficient here...\n            data = np.empty(shape)\n            data[:, :, 0] = res[:, :]\n            data[:, :, 1] = res[:, :]\n            data[:, :, 2] = res[:, :]\n            return data\n\n        else:\n            # note: in timing tests, dstack was not as efficient here...\n            res = np.empty(shape)\n            res[:, :, 0] = data[:, :, 0] * alpha\n            res[:, :, 1] = data[:, :, 1] * alpha\n            res[:, :, 2] = data[:, :, 2] * alpha\n            return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef zscale(image, nsamples=1000, contrast=0.25):\n\n    # Sample the image\n    samples = zsc_sample(image, nsamples)\n\n    return zscale_samples(samples, contrast=contrast)", "response": "Implement IRAF zscale algorithm"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nenabling or disable Create Mask button based on drawn objects.", "response": "def toggle_create_button(self):\n        \"\"\"Enable or disable Create Mask button based on drawn objects.\"\"\"\n        if len(self._drawn_tags) > 0:\n            self.w.create_mask.set_enabled(True)\n        else:\n            self.w.create_mask.set_enabled(False)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate boolean mask from drawing.", "response": "def create_mask(self):\n        \"\"\"Create boolean mask from drawing.\n\n        All areas enclosed by all the shapes drawn will be set to 1 (True)\n        in the mask. Otherwise, the values will be set to 0 (False).\n        The mask will be inserted as a new image buffer, like ``Mosaic``.\n\n        \"\"\"\n        ntags = len(self._drawn_tags)\n\n        if ntags == 0:\n            return\n\n        old_image = self.fitsimage.get_image()\n\n        if old_image is None:\n            return\n\n        mask = None\n        obj_kinds = set()\n\n        # Create mask\n        for tag in self._drawn_tags:\n            obj = self.canvas.get_object_by_tag(tag)\n\n            try:\n                cur_mask = old_image.get_shape_mask(obj)\n            except Exception as e:\n                self.logger.error('Cannot create mask: {0}'.format(str(e)))\n                continue\n\n            if mask is not None:\n                mask |= cur_mask\n            else:\n                mask = cur_mask\n\n            obj_kinds.add(obj.kind)\n\n        # Might be useful to inherit header from displayed image (e.g., WCS)\n        # but the displayed image should not be modified.\n        # Bool needs to be converted to int so FITS writer would not crash.\n        image = dp.make_image(mask.astype('int16'), old_image, {},\n                              pfx=self._mask_prefix)\n        imname = image.get('name')\n\n        # Insert new image\n        self.fv.gui_call(self.fv.add_image, imname, image, chname=self.chname)\n\n        # Add description to ChangeHistory\n        s = 'Mask created from {0} drawings ({1})'.format(\n            ntags, ','.join(sorted(obj_kinds)))\n        info = dict(time_modified=datetime.utcnow(), reason_modified=s)\n        self.fv.update_image_info(image, info)\n        self.logger.info(s)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cmd_help(self, *args):\n        if len(args) > 0:\n            cmdname = args[0].lower()\n            try:\n                method = getattr(self, \"cmd_\" + cmdname)\n                doc = method.__doc__\n                if doc is None:\n                    self.log(\"Sorry, no documentation found for '%s'\" % (\n                        cmdname))\n                else:\n                    self.log(\"%s: %s\" % (cmdname, doc))\n            except AttributeError:\n                self.log(\"No such command '%s'; type help for general help.\" % (\n                    cmdname))\n        else:\n            res = []\n            for attrname in dir(self):\n                if attrname.startswith('cmd_'):\n                    method = getattr(self, attrname)\n                    doc = method.__doc__\n                    cmdname = attrname[4:]\n                    if doc is None:\n                        doc = \"no documentation\"\n                    res.append(\"%s: %s\" % (cmdname, doc))\n            self.log('\\n'.join(res))", "response": "help [ cmd ] get general help or help for command cmd."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cmd_reload_global(self, plname):\n        gpmon = self.fv.gpmon\n        p_info = gpmon.get_plugin_info(plname)\n        gpmon.stop_plugin(p_info)\n        self.fv.update_pending(0.5)\n        self.fv.mm.load_module(plname)\n        gpmon.reload_plugin(plname)\n        self.fv.start_global_plugin(plname)\n        return True", "response": "reload_global plname Reload the global plugin named plname"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexecuting list files command", "response": "def cmd_ls(self, *args):\n        \"\"\"ls [options]\n\n        Execute list files command\n        \"\"\"\n        cmd_str = ' '.join(['ls'] + list(args))\n        self.plugin.exec_shell(cmd_str)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cmd_load(self, *args, **kwargs):\n        ch = kwargs.get('ch', None)\n\n        for item in args:\n            # TODO: check for URI syntax\n            files = glob.glob(item)\n            self.fv.gui_do(self.fv.open_uris, files, chname=ch)", "response": "load file... ch = chname can\n        = None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncut lo = val hi = val ch = chname", "response": "def cmd_cuts(self, lo=None, hi=None, ch=None):\n        \"\"\"cuts lo=val hi=val ch=chname\n\n        If neither `lo` nor `hi` is provided, returns the current cut levels.\n        Otherwise sets the corresponding cut level for the given channel.\n        If `ch` is omitted, assumes the current channel.\n        \"\"\"\n        viewer = self.get_viewer(ch)\n        if viewer is None:\n            self.log(\"No current viewer/channel.\")\n            return\n\n        loval, hival = viewer.get_cut_levels()\n\n        if (lo is None) and (hi is None):\n            self.log(\"lo=%f hi=%f\" % (loval, hival))\n\n        else:\n            if lo is not None:\n                loval = lo\n            if hi is not None:\n                hival = hi\n            viewer.cut_levels(loval, hival)\n\n            self.log(\"lo=%f hi=%f\" % (loval, hival))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_cm(self, nm=None, ch=None):\n        viewer = self.get_viewer(ch)\n        if viewer is None:\n            self.log(\"No current viewer/channel.\")\n            return\n\n        if nm is None:\n            rgbmap = viewer.get_rgbmap()\n            cmap = rgbmap.get_cmap()\n            self.log(cmap.name)\n\n        else:\n            viewer.set_color_map(nm)", "response": "cm nm = color_map_name ch = channel chname = chname"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cmd_cminv(self, ch=None):\n        viewer = self.get_viewer(ch)\n        if viewer is None:\n            self.log(\"No current viewer/channel.\")\n            return\n\n        viewer.invert_cmap()", "response": "cminv ch = chname"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cmd_dist(self, nm=None, ch=None):\n        viewer = self.get_viewer(ch)\n        if viewer is None:\n            self.log(\"No current viewer/channel.\")\n            return\n\n        if nm is None:\n            rgbmap = viewer.get_rgbmap()\n            dist = rgbmap.get_dist()\n            self.log(str(dist))\n        else:\n            viewer.set_color_algorithm(nm)", "response": "dist nm = dist_name ch = chname"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cmd_imap(self, nm=None, ch=None):\n        viewer = self.get_viewer(ch)\n        if viewer is None:\n            self.log(\"No current viewer/channel.\")\n            return\n\n        if nm is None:\n            rgbmap = viewer.get_rgbmap()\n            imap = rgbmap.get_imap()\n            self.log(imap.name)\n\n        else:\n            viewer.set_intensity_map(nm)", "response": "imap nm = intensity_map_name ch = chname"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrotting deg = num_deg ch = chname", "response": "def cmd_rot(self, deg=None, ch=None):\n        \"\"\"rot deg=num_deg ch=chname\n\n        Rotate the image for the given viewer/channel by the given\n        number of degrees.\n        If no value is given, reports the current rotation.\n        \"\"\"\n        viewer = self.get_viewer(ch)\n        if viewer is None:\n            self.log(\"No current viewer/channel.\")\n            return\n\n        if deg is None:\n            self.log(\"%f deg\" % (viewer.get_rotation()))\n\n        else:\n            viewer.rotate(deg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nscaling x y ch", "response": "def cmd_scale(self, x=None, y=None, ch=None):\n        \"\"\"scale x=scale_x y=scale_y ch=chname\n\n        Scale the image for the given viewer/channel by the given amounts.\n        If only one scale value is given, the other is assumed to be the\n        same.  If no value is given, reports the current scale.\n        \"\"\"\n        viewer = self.get_viewer(ch)\n        if viewer is None:\n            self.log(\"No current viewer/channel.\")\n            return\n\n        scale_x, scale_y = viewer.get_scale_xy()\n\n        if x is None and y is None:\n            self.log(\"x=%f y=%f\" % (scale_x, scale_y))\n\n        else:\n            if x is not None:\n                if y is None:\n                    y = x\n            if y is not None:\n                if x is None:\n                    x = y\n            viewer.scale_to(x, y)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cmd_z(self, lvl=None, ch=None):\n        viewer = self.get_viewer(ch)\n        if viewer is None:\n            self.log(\"No current viewer/channel.\")\n            return\n\n        cur_lvl = viewer.get_zoom()\n\n        if lvl is None:\n            self.log(\"zoom=%f\" % (cur_lvl))\n\n        else:\n            viewer.zoom_to(lvl)", "response": "z lvl = level ch = chname"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cmd_c(self, ch=None):\n        viewer = self.get_viewer(ch)\n        if viewer is None:\n            self.log(\"No current viewer/channel.\")\n            return\n\n        viewer.center_image()", "response": "c ch = chname"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cmd_pan(self, x=None, y=None, ch=None):\n        viewer = self.get_viewer(ch)\n        if viewer is None:\n            self.log(\"No current viewer/channel.\")\n            return\n\n        pan_x, pan_y = viewer.get_pan()\n\n        if x is None and y is None:\n            self.log(\"x=%f y=%f\" % (pan_x, pan_y))\n\n        else:\n            if x is not None:\n                if y is None:\n                    y = pan_y\n            if y is not None:\n                if x is None:\n                    x = pan_x\n            viewer.set_pan(x, y)", "response": "pan x y ch = chname x = pan_x y = pan_y"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add(self, timer):\n        with self.lock:\n            if self.heap:\n                top = self.heap[0]\n            else:\n                top = None\n\n            assert timer not in self.timers\n            self.timers[timer] = timer\n            heapq.heappush(self.heap, timer)\n\n            # Check to see if we need to reschedule our main timer.\n            # Only do this if we aren't expiring in the other thread.\n            if self.heap[0] != top and not self.expiring:\n                if self.rtimer is not None:\n                    self.rtimer.cancel()\n                    # self.rtimer.join()\n                    self.rtimer = None\n\n            # If we are expiring timers right now then that will reschedule\n            # as appropriate otherwise let's start a timer if we don't have\n            # one\n            if self.rtimer is None and not self.expiring:\n                top = self.heap[0]\n                ival = top.expire - time.time()\n                if ival < 0:\n                    ival = 0\n                self.rtimer = threading.Timer(ival, self.expire)\n                self.rtimer.start()", "response": "Add a timer to the heap"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove timer from heap lock and presence are assumed", "response": "def _remove(self, timer):\n        \"\"\"Remove timer from heap lock and presence are assumed\"\"\"\n        assert timer.timer_heap == self\n        del self.timers[timer]\n        assert timer in self.heap\n        self.heap.remove(timer)\n        heapq.heapify(self.heap)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove(self, timer):\n        with self.lock:\n            # This is somewhat expensive as we have to heapify.\n            if timer in self.timers:\n                self._remove(timer)\n                return False\n            else:\n                return True", "response": "Remove a timer from the heap return True if already run"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving all waiting timers and terminate any blocking threads.", "response": "def remove_all_timers(self):\n        \"\"\"Remove all waiting timers and terminate any blocking threads.\"\"\"\n        with self.lock:\n            if self.rtimer is not None:\n                self.rtimer.cancel()\n\n            self.timers = {}\n            self.heap = []\n            self.rtimer = None\n            self.expiring = False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_llur(self):\n        points = np.array([obj.get_llur() for obj in self.objects])\n        t_ = points.T\n        x1, y1 = t_[0].min(), t_[1].min()\n        x2, y2 = t_[2].max(), t_[3].max()\n        return (x1, y1, x2, y2)", "response": "Get lower - left and upper - right coordinates of the bounding box\n        of this compound object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget image as a buffer in format.", "response": "def get_buffer(self, format, output=None):\n        \"\"\"Get image as a buffer in (format).\n        Format should be 'jpeg', 'png', etc.\n        \"\"\"\n        return self.io.get_buffer(self._get_data(), self.get_header(),\n                                  format, output=output)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef build_gui(self, container):\n        vbox = Widgets.VBox()\n        vbox.set_border_width(0)\n\n        w = Viewers.GingaViewerWidget(viewer=self)\n        vbox.add_widget(w, stretch=1)\n\n        # need to put this in an hbox with an expanding label or the\n        # browser wants to resize the canvas, distorting it\n        hbox = Widgets.HBox()\n        hbox.add_widget(vbox, stretch=0)\n        hbox.add_widget(Widgets.Label(''), stretch=1)\n\n        container.set_widget(hbox)", "response": "This method is responsible for building the viewer s UI. It should generate a custom GUI. It should generate a custom UI. It should generate a custom UI. It should generate a custom UI."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nembeds a viewer into a Jupyter notebook.", "response": "def embed(self, width=600, height=650):\n        \"\"\"\n        Embed a viewer into a Jupyter notebook.\n        \"\"\"\n        from IPython.display import IFrame\n        return IFrame(self.url, width, height)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nopen this viewer in a new browser window or tab.", "response": "def open(self, new=1):\n        \"\"\"\n        Open this viewer in a new browser window or tab.\n        (requires `webbrowser` module)\n        \"\"\"\n        import webbrowser\n        webbrowser.open(self.url, new=new)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show(self, fmt=None):\n        # force any delayed redraws\n        # TODO: this really needs to be addressed in get_rgb_image_as_bytes()\n        # of the various superclasses, as it affects other backends as well\n        self.redraw_now()\n\n        from IPython.display import Image\n\n        if fmt is None:\n            # what format are we using for the HTML5 canvas--use that\n            settings = self.get_settings()\n            fmt = settings.get('html5_canvas_format', 'png')\n\n        return Image(data=bytes(self.get_rgb_image_as_bytes(format=fmt)),\n                     format=fmt, embed=True)", "response": "Displays the window of a viewer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_fits(self, filepath):\n        image = AstroImage.AstroImage(logger=self.logger)\n        image.load_file(filepath)\n\n        self.set_image(image)", "response": "Load a FITS file into the viewer."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads an HDU into the viewer.", "response": "def load_hdu(self, hdu):\n        \"\"\"\n        Load an HDU into the viewer.\n        \"\"\"\n        image = AstroImage.AstroImage(logger=self.logger)\n        image.load_hdu(hdu)\n\n        self.set_image(image)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads raw numpy data into the viewer.", "response": "def load_data(self, data_np):\n        \"\"\"\n        Load raw numpy data into the viewer.\n        \"\"\"\n        image = AstroImage.AstroImage(logger=self.logger)\n        image.set_data(data_np)\n\n        self.set_image(image)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the format used for rendering to the HTML5 canvas.", "response": "def set_html5_canvas_format(self, fmt):\n        \"\"\"\n        Sets the format used for rendering to the HTML5 canvas.\n        'png' offers greater clarity, especially for small text, but\n        does not have as good of performance as 'jpeg'.\n        \"\"\"\n        fmt = fmt.lower()\n        if fmt not in ('jpeg', 'png'):\n            raise ValueError(\"Format must be one of {jpeg|png} not '%s'\" % (\n                fmt))\n\n        settings = self.get_settings()\n        settings.set(html5_canvas_format=fmt)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef build_gui(self, container):\n        vbox = Widgets.VBox()\n        vbox.set_border_width(2)\n        vbox.set_spacing(1)\n\n        w = Viewers.GingaViewerWidget(viewer=self)\n        vbox.add_widget(w, stretch=1)\n\n        # set up to capture cursor movement for reading out coordinates\n\n        # coordinates reported in base 1 or 0?\n        self.pixel_base = 1.0\n\n        self.readout = Widgets.Label(\"\")\n        vbox.add_widget(self.readout, stretch=0)\n\n        #self.set_callback('none-move', self.motion_cb)\n        self.set_callback('cursor-changed', self.motion_cb)\n\n        # need to put this in an hbox with an expanding label or the\n        # browser wants to resize the canvas, distorting it\n        hbox = Widgets.HBox()\n        hbox.add_widget(vbox, stretch=0)\n        hbox.add_widget(Widgets.Label(''), stretch=1)\n\n        container.set_widget(hbox)", "response": "This method is responsible for building the GUI for the current locale. It should be responsible for building the viewer s UI. It should be responsible for building the UI. It should be responsible for building the viewer s UI."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting an existing viewer by viewer id.", "response": "def get_viewer(self, v_id, viewer_class=None, width=512, height=512,\n                   force_new=False):\n        \"\"\"\n        Get an existing viewer by viewer id.  If the viewer does not yet\n        exist, make a new one.\n        \"\"\"\n        if not force_new:\n            try:\n                return self.viewers[v_id]\n            except KeyError:\n                pass\n\n        #  create top level window\n        window = self.app.make_window(\"Viewer %s\" % v_id, wid=v_id)\n\n        # We get back a record with information about the viewer\n        v_info = self.make_viewer(window, viewer_class=viewer_class,\n                                  width=width, height=height)\n\n        # Save it under this viewer id\n        self.viewers[v_id] = v_info\n        return v_info"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef detailxy(self, canvas, button, data_x, data_y):\n        if button == 0:\n            # TODO: we could track the focus changes to make this check\n            # more efficient\n            chviewer = self.fv.getfocus_viewer()\n            # Don't update global information if our chviewer isn't focused\n            if chviewer != self.fitsimage:\n                return True\n\n            # Add offsets from cutout\n            data_x = data_x + self.pick_x1\n            data_y = data_y + self.pick_y1\n\n            return self.fv.showxy(chviewer, data_x, data_y)", "response": "Show the pointing pick fits window."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates reference viewer from command line.", "response": "def reference_viewer(sys_argv):\n    \"\"\"Create reference viewer from command line.\"\"\"\n    viewer = ReferenceViewer(layout=default_layout)\n    viewer.add_default_plugins()\n    viewer.add_separately_distributed_plugins()\n\n    # Parse command line options with optparse module\n    from optparse import OptionParser\n\n    usage = \"usage: %prog [options] cmd [args]\"\n    optprs = OptionParser(usage=usage,\n                          version=('%%prog %s' % version.version))\n    viewer.add_default_options(optprs)\n\n    (options, args) = optprs.parse_args(sys_argv[1:])\n\n    if options.display:\n        os.environ['DISPLAY'] = options.display\n\n    # Are we debugging this?\n    if options.debug:\n        import pdb\n\n        pdb.run('viewer.main(options, args)')\n\n    # Are we profiling this?\n    elif options.profile:\n        import profile\n\n        print((\"%s profile:\" % sys_argv[0]))\n        profile.run('viewer.main(options, args)')\n\n    else:\n        viewer.main(options, args)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding the ginga - distributed default set of plugins to the current object.", "response": "def add_default_plugins(self, except_global=[], except_local=[]):\n        \"\"\"\n        Add the ginga-distributed default set of plugins to the\n        reference viewer.\n        \"\"\"\n        # add default global plugins\n        for spec in plugins:\n            ptype = spec.get('ptype', 'local')\n            if ptype == 'global' and spec.module not in except_global:\n                self.add_plugin_spec(spec)\n\n            if ptype == 'local' and spec.module not in except_local:\n                self.add_plugin_spec(spec)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds the default startup options to an OptionParser instance optprs.", "response": "def add_default_options(self, optprs):\n        \"\"\"\n        Adds the default reference viewer startup options to an\n        OptionParser instance `optprs`.\n        \"\"\"\n        optprs.add_option(\"--bufsize\", dest=\"bufsize\", metavar=\"NUM\",\n                          type=\"int\", default=10,\n                          help=\"Buffer length to NUM\")\n        optprs.add_option('-c', \"--channels\", dest=\"channels\",\n                          help=\"Specify list of channels to create\")\n        optprs.add_option(\"--debug\", dest=\"debug\", default=False,\n                          action=\"store_true\",\n                          help=\"Enter the pdb debugger on main()\")\n        optprs.add_option(\"--disable-plugins\", dest=\"disable_plugins\",\n                          metavar=\"NAMES\",\n                          help=\"Specify plugins that should be disabled\")\n        optprs.add_option(\"--display\", dest=\"display\", metavar=\"HOST:N\",\n                          help=\"Use X display on HOST:N\")\n        optprs.add_option(\"--fitspkg\", dest=\"fitspkg\", metavar=\"NAME\",\n                          default=None,\n                          help=\"Prefer FITS I/O module NAME\")\n        optprs.add_option(\"-g\", \"--geometry\", dest=\"geometry\",\n                          default=None, metavar=\"GEOM\",\n                          help=\"X geometry for initial size and placement\")\n        optprs.add_option(\"--modules\", dest=\"modules\", metavar=\"NAMES\",\n                          help=\"Specify additional modules to load\")\n        optprs.add_option(\"--norestore\", dest=\"norestore\", default=False,\n                          action=\"store_true\",\n                          help=\"Don't restore the GUI from a saved layout\")\n        optprs.add_option(\"--nosplash\", dest=\"nosplash\", default=False,\n                          action=\"store_true\",\n                          help=\"Don't display the splash screen\")\n        optprs.add_option(\"--numthreads\", dest=\"numthreads\", type=\"int\",\n                          default=30, metavar=\"NUM\",\n                          help=\"Start NUM threads in thread pool\")\n        optprs.add_option(\"--opencv\", dest=\"opencv\", default=False,\n                          action=\"store_true\",\n                          help=\"Use OpenCv acceleration\")\n        optprs.add_option(\"--opencl\", dest=\"opencl\", default=False,\n                          action=\"store_true\",\n                          help=\"Use OpenCL acceleration\")\n        optprs.add_option(\"--plugins\", dest=\"plugins\", metavar=\"NAMES\",\n                          help=\"Specify additional plugins to load\")\n        optprs.add_option(\"--profile\", dest=\"profile\", action=\"store_true\",\n                          default=False,\n                          help=\"Run the profiler on main()\")\n        optprs.add_option(\"--sep\", dest=\"separate_channels\", default=False,\n                          action=\"store_true\",\n                          help=\"Load files in separate channels\")\n        optprs.add_option(\"-t\", \"--toolkit\", dest=\"toolkit\", metavar=\"NAME\",\n                          default=None,\n                          help=\"Prefer GUI toolkit (gtk|qt)\")\n        optprs.add_option(\"--wcspkg\", dest=\"wcspkg\", metavar=\"NAME\",\n                          default=None,\n                          help=\"Prefer WCS module NAME\")\n        log.addlogopts(optprs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nshows help for optional keywords.", "response": "def show_help(self, plugin=None, no_url_callback=None):\n        \"\"\"See `~ginga.GingaPlugin` for usage of optional keywords.\"\"\"\n        if not Widgets.has_webkit:\n            return\n\n        self.fv.nongui_do(self._download_doc, plugin=plugin,\n                          no_url_callback=no_url_callback)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_contours(data, levels):\n    if not have_skimage:\n        raise Exception(\"Please install scikit-image > 0.13\"\n                        \"to use this function\")\n    res = [filter(lambda arr: len(arr) >= 3,\n                  measure.find_contours(data, level))\n           for level in levels]\n    res = [map(lambda arr: np.roll(arr, 1, axis=1),\n               arrs) for arrs in res]\n    return res", "response": "Get sets of contour points for numpy array data."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the contour points for numpy array data.", "response": "def calc_contours(data, num_contours):\n    \"\"\"Get sets of contour points for numpy array `data`.\n    `num_contours` specifies the number (int) of contours to make.\n    Returns a list of numpy arrays of points--each array makes a polygon\n    if plotted as such.\n    \"\"\"\n    mn = np.nanmean(data)\n    top = np.nanmax(data)\n    levels = np.linspace(mn, top, num_contours)\n    return get_contours(data, levels)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating and return a compound object for ginga canvas consisting of a number of contour polygons.", "response": "def create_contours_obj(canvas, contour_groups, colors=None, **kwargs):\n    \"\"\"Create and return a compound object for ginga `canvas`, consisting\n    of a number of contour polygons.  `contour_groups` is a list of\n    numpy arrays of points representing polygons, such as returned by\n    calc_contours() or get_contours().\n    `colors` (if provided) is a list of colors for each polygon.\n    Any other keyword parameters are passed on to the Polygon class.\n    \"\"\"\n    if colors is None:\n        colors = ['black']\n    Polygon = canvas.get_draw_class('polygon')\n    Compound = canvas.get_draw_class('compoundobject')\n    objs = [Polygon(contour, color=colors[i % len(colors)], **kwargs)\n            for i, contours in enumerate(contour_groups)\n            for n, contour in enumerate(contours)\n            ]\n    contours_obj = Compound(*objs)\n    return contours_obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall this method with the Jupyter image widget that will be used.", "response": "def set_widget(self, jp_img):\n        \"\"\"Call this method with the Jupyter image widget (image_w)\n        that will be used.\n        \"\"\"\n        self.jp_img = jp_img\n\n        # TODO: need configure (resize) event callback\n\n        # see reschedule_redraw() method\n        self._defer_task = JpHelp.Timer()\n        self._defer_task.add_callback('expired',\n                                      lambda timer: self.delayed_redraw())\n        self.msgtask = JpHelp.Timer()\n        self.msgtask.add_callback('expired',\n                                  lambda timer: self.onscreen_message(None))\n\n        # for some reason these are stored as strings!\n        wd, ht = int(jp_img.width), int(jp_img.height)\n        self.configure_surface(wd, ht)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_widget(self, jp_imgw):\n        super(ImageViewEvent, self).set_widget(jp_imgw)\n\n        self.jp_evt = EventListener(source=jp_imgw)\n        self.jp_evt.watched_events = [\n            'keydown', 'keyup', 'mouseenter', 'mouseleave',\n            'mousedown', 'mouseup', 'mousemove', 'wheel',\n            'contextmenu'\n        ]\n        self.jp_evt.prevent_default_action = True\n\n        self.jp_evt.on_dom_event(self._handle_event)\n        self.logger.info(\"installed event handlers\")\n\n        return self.make_callback('map')", "response": "Set the Jupyter image widget that will be used."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndisplaying the color image of a viewer.", "response": "def show(self, fmt=None):\n        \"\"\"\n        Capture the window of a viewer.\n        \"\"\"\n        # force any delayed redraws\n        # TODO: this really needs to be addressed in get_rgb_image_as_bytes()\n        # of the various superclasses, as it affects other backends as well\n        self.redraw_now()\n\n        from IPython.display import Image\n\n        if fmt is None:\n            # what format are we using for the Jupyter image--use that\n            fmt = self.jp_img.format\n\n        return Image(data=bytes(self.get_rgb_image_as_bytes(format=fmt)),\n                     format=fmt, embed=True)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating mean for valid values.", "response": "def get_mean(data_np):\n    \"\"\"Calculate mean for valid values.\n\n    Parameters\n    ----------\n    data_np : ndarray\n        Input array.\n\n    Returns\n    -------\n    result : float\n        Mean of array values that are finite.\n        If array contains no finite values, returns NaN.\n\n    \"\"\"\n    i = np.isfinite(data_np)\n    if not np.any(i):\n        return np.nan\n    return np.mean(data_np[i])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_median(data_np):\n    i = np.isfinite(data_np)\n    if not np.any(i):\n        return np.nan\n    return np.median(data_np[i])", "response": "Like get_mean but for median."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calc_fwhm_gaussian(self, arr1d, medv=None, gauss_fn=None):\n        if gauss_fn is None:\n            gauss_fn = self.gaussian\n\n        N = len(arr1d)\n        X = np.array(list(range(N)))\n        Y = arr1d\n        # Fitting works more reliably if we do the following\n        # a. subtract sky background\n        if medv is None:\n            medv = get_median(Y)\n        Y = Y - medv\n        maxv = Y.max()\n        # b. clamp to 0..max (of the sky subtracted field)\n        Y = Y.clip(0, maxv)\n\n        # Fit a gaussian\n        p0 = [0, N - 1, maxv]              # Inital guess\n        # Distance to the target function\n        errfunc = lambda p, x, y: gauss_fn(x, p) - y  # noqa\n        # Least square fit to the gaussian\n        with self.lock:\n            # NOTE: without this mutex, optimize.leastsq causes a fatal error\n            # sometimes--it appears not to be thread safe.\n            # The error is:\n            # \"SystemError: null argument to internal routine\"\n            # \"Fatal Python error: GC object already tracked\"\n            p1, success = optimize.leastsq(errfunc, p0[:], args=(X, Y))\n\n        if not success:\n            raise IQCalcError(\"FWHM gaussian fitting failed\")\n\n        mu, sdev, maxv = p1\n        self.logger.debug(\"mu=%f sdev=%f maxv=%f\" % (mu, sdev, maxv))\n\n        # Now that we have the sdev from fitting, we can calculate FWHM\n        fwhm = 2.0 * np.sqrt(2.0 * np.log(2.0)) * sdev\n        # some routines choke on numpy values and need \"pure\" Python floats\n        # e.g. when marshalling through a remote procedure interface\n        fwhm = float(fwhm)\n        mu = float(mu)\n        sdev = float(sdev)\n        maxv = float(maxv)\n\n        res = Bunch.Bunch(fwhm=fwhm, mu=mu, sdev=sdev, maxv=maxv,\n                          fit_fn=gauss_fn, fit_args=[mu, sdev, maxv])\n        return res", "response": "Calculate the FWHM of a 1D array by using least square fitting of a gaussian function on the data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef calc_fwhm_moffat(self, arr1d, medv=None, moffat_fn=None):\n        if moffat_fn is None:\n            moffat_fn = self.moffat\n\n        N = len(arr1d)\n        X = np.array(list(range(N)))\n        Y = arr1d\n        # Fitting works more reliably if we do the following\n        # a. subtract sky background\n        if medv is None:\n            medv = get_median(Y)\n        Y = Y - medv\n        maxv = Y.max()\n        # b. clamp to 0..max (of the sky subtracted field)\n        Y = Y.clip(0, maxv)\n\n        # Fit a moffat\n        p0 = [0, N - 1, 2, maxv]              # Inital guess\n        # Distance to the target function\n        errfunc = lambda p, x, y: moffat_fn(x, p) - y  # noqa\n        # Least square fit to the gaussian\n        with self.lock:\n            # NOTE: without this mutex, optimize.leastsq causes a fatal error\n            # sometimes--it appears not to be thread safe.\n            # The error is:\n            # \"SystemError: null argument to internal routine\"\n            # \"Fatal Python error: GC object already tracked\"\n            p1, success = optimize.leastsq(errfunc, p0[:], args=(X, Y))\n\n        if not success:\n            raise IQCalcError(\"FWHM moffat fitting failed\")\n\n        mu, width, power, maxv = p1\n        width = np.abs(width)\n        self.logger.debug(\"mu=%f width=%f power=%f maxv=%f\" % (\n            mu, width, power, maxv))\n\n        fwhm = 2.0 * width * np.sqrt(2.0 ** (1.0 / power) - 1.0)\n\n        # some routines choke on numpy values and need \"pure\" Python floats\n        # e.g. when marshalling through a remote procedure interface\n        fwhm = float(fwhm)\n        mu = float(mu)\n        width = float(width)\n        power = float(power)\n        maxv = float(maxv)\n\n        res = Bunch.Bunch(fwhm=fwhm, mu=mu, width=width, power=power,\n                          maxv=maxv, fit_fn=moffat_fn,\n                          fit_args=[mu, width, power, maxv])\n        return res", "response": "Calculates the FWHM of a 1D array by using least square fitting of a Moffat function on the data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the FWHM value of the object at the coordinates x y using the radius.", "response": "def get_fwhm(self, x, y, radius, data, medv=None, method_name='gaussian'):\n        \"\"\"Get the FWHM value of the object at the coordinates (x, y) using\n        radius.\n        \"\"\"\n        if medv is None:\n            medv = get_median(data)\n\n        # Get two cuts of the data, one in X and one in Y\n        x0, y0, xarr, yarr = self.cut_cross(x, y, radius, data)\n\n        # Calculate FWHM in each direction\n        x_res = self.calc_fwhm(xarr, medv=medv, method_name=method_name)\n        fwhm_x, cx = x_res.fwhm, x_res.mu\n\n        y_res = self.calc_fwhm(yarr, medv=medv, method_name=method_name)\n        fwhm_y, cy = y_res.fwhm, y_res.mu\n\n        ctr_x = x0 + cx\n        ctr_y = y0 + cy\n        self.logger.debug(\"fwhm_x,fwhm_y=%f,%f center=%f,%f\" % (\n            fwhm_x, fwhm_y, ctr_x, ctr_y))\n        return (fwhm_x, fwhm_y, ctr_x, ctr_y, x_res, y_res)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_bright_peaks(self, data, threshold=None, sigma=5, radius=5):\n        if threshold is None:\n            # set threshold to default if none provided\n            threshold = self.get_threshold(data, sigma=sigma)\n            self.logger.debug(\"threshold defaults to %f (sigma=%f)\" % (\n                threshold, sigma))\n\n        #self.logger.debug(\"filtering\")\n        data_max = filters.maximum_filter(data, radius)\n        maxima = (data == data_max)\n        diff = data_max > threshold\n        maxima[diff == 0] = 0\n\n        #self.logger.debug(\"finding\")\n        labeled, num_objects = ndimage.label(maxima)\n        slices = ndimage.find_objects(labeled)\n        peaks = []\n        for dy, dx in slices:\n            xc = (dx.start + dx.stop - 1) / 2.0\n            yc = (dy.start + dy.stop - 1) / 2.0\n\n            # This is only an approximate center; use FWHM or centroid\n            # calculation to refine further\n            peaks.append((xc, yc))\n\n        self.logger.debug(\"peaks=%s\" % (str(peaks)))\n        return peaks", "response": "Find bright peaks in data."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a cut region ( radius ) pixels away from x y in data.", "response": "def cut_region(self, x, y, radius, data):\n        \"\"\"Return a cut region (radius) pixels away from (x, y) in (data).\n        \"\"\"\n        n = radius\n        ht, wd = data.shape\n        x0, x1 = max(0, x - n), min(wd - 1, x + n)\n        y0, y1 = max(0, y - n), min(ht - 1, y + n)\n        arr = data[y0:y1 + 1, x0:x1 + 1]\n        return (x0, y0, arr)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncutting two data subarrays that have a center at x y and with a radius from ( data. Returns the starting pixel x0 y0 xarr yarr yarr.", "response": "def cut_cross(self, x, y, radius, data):\n        \"\"\"Cut two data subarrays that have a center at (x, y) and with\n        radius (radius) from (data).  Returns the starting pixel (x0, y0)\n        of each cut and the respective arrays (xarr, yarr).\n        \"\"\"\n        n = int(round(radius))\n        ht, wd = data.shape\n        x, y = int(round(x)), int(round(y))\n        x0, x1 = int(max(0, x - n)), int(min(wd - 1, x + n))\n        y0, y1 = int(max(0, y - n)), int(min(ht - 1, y + n))\n        xarr = data[y, x0:x1 + 1]\n        yarr = data[y0:y1 + 1, x]\n        return (x0, y0, xarr, yarr)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef brightness(self, x, y, radius, medv, data):\n        x0, y0, arr = self.cut_region(x, y, radius, data)\n        arr2 = np.sort(arr.flat)\n        idx = int(len(arr2) * 0.8)\n        res = arr2[idx] - medv\n        return float(res)", "response": "Return the brightness value found in a region ( radius ) pixels away\n        from ( x y ) in data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning imported module for the given name.", "response": "def my_import(name, path=None):\n    \"\"\"Return imported module for the given name.\"\"\"\n\n    # Documentation for importlib says this may be needed to pick up\n    # modules created after the program has started\n    if hasattr(importlib, 'invalidate_caches'):\n        # python 3.3+\n        importlib.invalidate_caches()\n\n    if path is not None:\n        directory, src_file = os.path.split(path)\n\n        # TODO: use the importlib.util machinery\n        sys.path.insert(0, directory)\n        try:\n            mod = importlib.import_module(name)\n        finally:\n            sys.path.pop(0)\n\n    else:\n        mod = importlib.import_module(name)\n\n    return mod"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_module(self, module_name, pfx=None, path=None):\n        try:\n            if pfx:\n                name = pfx + '.' + module_name\n            else:\n                name = module_name\n\n            if name in sys.modules:\n                module = sys.modules[name]\n                self.logger.info(\"Reloading module '%s'...\" % module_name)\n                module = importlib.reload(module)\n\n            else:\n                self.logger.info(\"Loading module '%s'...\" % module_name)\n                module = my_import(name, path=path)\n\n            self.module[module_name] = module\n            return module\n\n        except Exception as e:\n            self.logger.error(\"Failed to load module '%s': %s\" % (\n                module_name, str(e)))\n            raise ModuleManagerError(e)", "response": "Load the module with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_module(self, module_name):\n        try:\n            return self.module[module_name]\n\n        except KeyError:\n            return sys.modules[module_name]", "response": "Return loaded module from the given name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing a string into a mode modulation and trigger.", "response": "def parse_combo(self, combo, modes_set, modifiers_set, pfx):\n        \"\"\"\n        Parse a string into a mode, a set of modifiers and a trigger.\n        \"\"\"\n        mode, mods, trigger = None, set([]), combo\n        if '+' in combo:\n            if combo.endswith('+'):\n                # special case: probably contains the keystroke '+'\n                trigger, combo = '+', combo[:-1]\n                if '+' in combo:\n                    items = set(combo.split('+'))\n                else:\n                    items = set(combo)\n            else:\n                # trigger is always specified last\n                items = combo.split('+')\n                trigger, items = items[-1], set(items[:-1])\n\n            if '*' in items:\n                items.remove('*')\n                # modifier wildcard\n                mods = '*'\n            else:\n                mods = items.intersection(modifiers_set)\n\n            mode = items.intersection(modes_set)\n            if len(mode) == 0:\n                mode = None\n            else:\n                mode = mode.pop()\n\n        if pfx is not None:\n            trigger = pfx + trigger\n\n        return (mode, mods, trigger)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef enable(self, **kwdargs):\n        for feat, value in kwdargs:\n            feat = feat.lower()\n            if feat not in self.features:\n                raise ValueError(\"'%s' is not a feature. Must be one of %s\" % (\n                    feat, str(self.features)))\n\n            attr = self.features[feat]\n            setattr(self, attr, bool(value))", "response": "General enable function encompassing all user interface features."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating values for vertical or horizontal panning by percentages from the current pan position.", "response": "def calc_pan_pct(self, viewer, pad=0):\n        \"\"\"Calculate values for vertical/horizontal panning by percentages\n        from the current pan position.\n        \"\"\"\n        limits = viewer.get_limits()\n\n        tr = viewer.tform['data_to_scrollbar']\n\n        # calculate the corners of the entire image in unscaled cartesian\n        mxwd, mxht = limits[1][:2]\n        mxwd, mxht = mxwd + pad, mxht + pad\n        mnwd, mnht = limits[0][:2]\n        mnwd, mnht = mnwd - pad, mnht - pad\n\n        arr = np.array([(mnwd, mnht), (mxwd, mnht),\n                        (mxwd, mxht), (mnwd, mxht)],\n                       dtype=np.float)\n        x, y = tr.to_(arr).T\n\n        rx1, rx2 = np.min(x), np.max(x)\n        ry1, ry2 = np.min(y), np.max(y)\n\n        rect = viewer.get_pan_rect()\n        arr = np.array(rect, dtype=np.float)\n        x, y = tr.to_(arr).T\n\n        qx1, qx2 = np.min(x), np.max(x)\n        qy1, qy2 = np.min(y), np.max(y)\n\n        # this is the range of X and Y of the entire image\n        # in the viewer (unscaled)\n        rng_x, rng_y = abs(rx2 - rx1), abs(ry2 - ry1)\n\n        # this is the *visually shown* range of X and Y\n        abs_x, abs_y = abs(qx2 - qx1), abs(qy2 - qy1)\n\n        # calculate the width of the slider arms as a ratio\n        min_pct = self.settings.get('pan_min_scroll_thumb_pct', 0.0)\n        max_pct = self.settings.get('pan_max_scroll_thumb_pct', 0.9)\n        xthm_pct = max(min_pct, min(abs_x / (rx2 - rx1), max_pct))\n        ythm_pct = max(min_pct, min(abs_y / (ry2 - ry1), max_pct))\n\n        # calculate the pan position as a ratio\n        pct_x = min(max(0.0, abs(0.0 - rx1) / rng_x), 1.0)\n        pct_y = min(max(0.0, abs(0.0 - ry1) / rng_y), 1.0)\n\n        bnch = Bunch.Bunch(rng_x=rng_x, rng_y=rng_y, vis_x=abs_x, vis_y=abs_y,\n                           thm_pct_x=xthm_pct, thm_pct_y=ythm_pct,\n                           pan_pct_x=pct_x, pan_pct_y=pct_y)\n        return bnch"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npans the screen by a percentage of pixels.", "response": "def pan_by_pct(self, viewer, pct_x, pct_y, pad=0):\n        \"\"\"Called when the scroll bars are adjusted by the user.\n        \"\"\"\n        # Sanity check on inputs\n        pct_x = min(1.0, max(0.0, pct_x))\n        pct_y = min(1.0, max(0.0, pct_y))\n\n        limits = viewer.get_limits()\n\n        tr = viewer.tform['data_to_scrollbar']\n\n        mxwd, mxht = limits[1][:2]\n        mxwd, mxht = mxwd + pad, mxht + pad\n        mnwd, mnht = limits[0][:2]\n        mnwd, mnht = mnwd - pad, mnht - pad\n\n        arr = np.array([(mnwd, mnht), (mxwd, mnht),\n                        (mxwd, mxht), (mnwd, mxht)],\n                       dtype=np.float)\n        x, y = tr.to_(arr).T\n\n        rx1, rx2 = np.min(x), np.max(x)\n        ry1, ry2 = np.min(y), np.max(y)\n\n        crd_x = rx1 + (pct_x * (rx2 - rx1))\n        crd_y = ry1 + (pct_y * (ry2 - ry1))\n\n        pan_x, pan_y = tr.from_((crd_x, crd_y))\n        self.logger.debug(\"crd=%f,%f pan=%f,%f\" % (\n            crd_x, crd_y, pan_x, pan_y))\n\n        viewer.panset_xy(pan_x, pan_y)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_direction(self, direction, rev=False):\n        if (direction < 90.0) or (direction >= 270.0):\n            if not rev:\n                return 'up'\n            else:\n                return 'down'\n        elif (90.0 <= direction < 270.0):\n            if not rev:\n                return 'down'\n            else:\n                return 'up'\n        else:\n            return 'none'", "response": "Translate a direction in compass degrees into up or down."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _nav_naxis(self, viewer, axis, direction, msg=True):\n        image = viewer.get_image()\n        if image is None:\n            return\n        mddata = image.get_mddata()\n        if len(mddata.shape) < (axis + 1):\n            # image dimensions < 3D\n            return\n\n        naxispath = list(image.naxispath)\n        axis_lim = mddata.shape[axis]\n        m = axis - 2\n\n        idx = naxispath[m]\n        if direction == 'down':\n            idx = (idx + 1) % axis_lim\n        else:\n            idx = idx - 1\n            if idx < 0:\n                idx = axis_lim - 1\n\n        naxispath[m] = idx\n        image.set_naxispath(naxispath)", "response": "Interactively change the slice of the image in a data cube\n        by scrolling."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the pan position under the cursor.", "response": "def kp_pan_set(self, viewer, event, data_x, data_y, msg=True):\n        \"\"\"Sets the pan position under the cursor.\"\"\"\n        if self.canpan:\n            self._panset(viewer, data_x, data_y, msg=msg)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the pan position under the cursor.", "response": "def kp_pan_zoom_set(self, viewer, event, data_x, data_y, msg=True):\n        \"\"\"Sets the pan position under the cursor.\"\"\"\n        if self.canpan:\n            reg = 1\n            with viewer.suppress_redraw:\n                viewer.panset_xy(data_x, data_y)\n                scale_x, scale_y = self._save.get((viewer, 'scale', reg),\n                                                  (1.0, 1.0))\n                viewer.scale_to(scale_x, scale_y)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef kp_pan_zoom_save(self, viewer, event, data_x, data_y, msg=True):\n        reg = 1\n        scale = viewer.get_scale_xy()\n        self._save[(viewer, 'scale', reg)] = scale\n        if msg:\n            viewer.onscreen_message(\"Saved current scale\", delay=0.5)\n        return True", "response": "Save the current viewer scale for future use with with\n        kp_pan_zoom_set ( )."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef kp_pan_px_center(self, viewer, event, data_x, data_y, msg=True):\n        if not self.canpan:\n            return False\n        self.pan_center_px(viewer)\n        return True", "response": "This pans so that the cursor is over the center of the theCOOKIE."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nzoom the image by dragging the cursor left or right.", "response": "def ms_zoom(self, viewer, event, data_x, data_y, msg=True):\n        \"\"\"Zoom the image by dragging the cursor left or right.\n        \"\"\"\n        if not self.canzoom:\n            return True\n        msg = self.settings.get('msg_zoom', msg)\n\n        x, y = self.get_win_xy(viewer)\n\n        if event.state == 'move':\n            self._zoom_xy(viewer, x, y)\n\n        elif event.state == 'down':\n            if msg:\n                viewer.onscreen_message(\"Zoom (drag mouse L-R)\",\n                                        delay=1.0)\n            self._start_x, self._start_y = x, y\n\n        else:\n            viewer.onscreen_message(None)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ms_zoom_in(self, viewer, event, data_x, data_y, msg=False):\n        if not self.canzoom:\n            return True\n\n        if not (event.state == 'down'):\n            return True\n\n        with viewer.suppress_redraw:\n            viewer.panset_xy(data_x, data_y)\n\n            if self.settings.get('scroll_zoom_direct_scale', True):\n                zoom_accel = self.settings.get('scroll_zoom_acceleration', 1.0)\n                # change scale by 100%\n                amount = self._scale_adjust(2.0, 15.0, zoom_accel, max_limit=4.0)\n                self._scale_image(viewer, 0.0, amount, msg=msg)\n            else:\n                viewer.zoom_in()\n\n            if hasattr(viewer, 'center_cursor'):\n                viewer.center_cursor()\n            if msg:\n                viewer.onscreen_message(viewer.get_scale_text(),\n                                        delay=1.0)\n        return True", "response": "Zoom in one level by a mouse click."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ms_rotate(self, viewer, event, data_x, data_y, msg=True):\n        if not self.canrotate:\n            return True\n        msg = self.settings.get('msg_rotate', msg)\n\n        x, y = self.get_win_xy(viewer)\n\n        if event.state == 'move':\n            self._rotate_xy(viewer, x, y)\n\n        elif event.state == 'down':\n            if msg:\n                viewer.onscreen_message(\"Rotate (drag around center)\",\n                                        delay=1.0)\n            self._start_x, self._start_y = x, y\n            self._start_rot = viewer.get_rotation()\n\n        else:\n            viewer.onscreen_message(None)\n        return True", "response": "Rotate the image by dragging the cursor left or right."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ms_contrast(self, viewer, event, data_x, data_y, msg=True):\n        if not self.cancmap:\n            return True\n        msg = self.settings.get('msg_contrast', msg)\n\n        x, y = self.get_win_xy(viewer)\n\n        if event.state == 'move':\n            self._tweak_colormap(viewer, x, y, 'preview')\n\n        elif event.state == 'down':\n            self._start_x, self._start_y = x, y\n            if msg:\n                viewer.onscreen_message(\n                    \"Shift and stretch colormap (drag mouse)\", delay=1.0)\n        else:\n            viewer.onscreen_message(None)\n        return True", "response": "Shift the colormap by dragging the cursor left or right or down. Stretch the colormap by dragging the cursor up or down."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ms_pan(self, viewer, event, data_x, data_y):\n        if not self.canpan:\n            return True\n\n        x, y = viewer.get_last_win_xy()\n        if event.state == 'move':\n            data_x, data_y = self.get_new_pan(viewer, x, y,\n                                              ptype=self._pantype)\n            viewer.panset_xy(data_x, data_y)\n\n        elif event.state == 'down':\n            self.pan_set_origin(viewer, x, y, data_x, data_y)\n            self.pan_start(viewer, ptype=2)\n\n        else:\n            self.pan_stop(viewer)\n        return True", "response": "A drag or proportional pan where the image is panned by dragging the canvas up or down."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ms_cutlo(self, viewer, event, data_x, data_y):\n        if not self.cancut:\n            return True\n\n        x, y = self.get_win_xy(viewer)\n\n        if event.state == 'move':\n            self._cutlow_xy(viewer, x, y)\n\n        elif event.state == 'down':\n            self._start_x, self._start_y = x, y\n            self._loval, self._hival = viewer.get_cut_levels()\n\n        else:\n            viewer.onscreen_message(None)\n        return True", "response": "An interactive way to set the low cut level."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ms_cutall(self, viewer, event, data_x, data_y):\n        if not self.cancut:\n            return True\n\n        x, y = self.get_win_xy(viewer)\n\n        if event.state == 'move':\n            self._cutboth_xy(viewer, x, y)\n\n        elif event.state == 'down':\n            self._start_x, self._start_y = x, y\n            image = viewer.get_image()\n            #self._loval, self._hival = viewer.get_cut_levels()\n            self._loval, self._hival = viewer.autocuts.calc_cut_levels(image)\n\n        else:\n            viewer.onscreen_message(None)\n        return True", "response": "An interactive way to set the low and high cut levels."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sc_cuts_coarse(self, viewer, event, msg=True):\n        if self.cancut:\n            # adjust the cut by 10% on each end\n            self._adjust_cuts(viewer, event.direction, 0.1, msg=msg)\n        return True", "response": "Adjusts the cuts interactively by setting the low AND high cut\n            levels."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadjust the cuts algorithm interactively.", "response": "def sc_cuts_alg(self, viewer, event, msg=True):\n        \"\"\"Adjust cuts algorithm interactively.\n        \"\"\"\n        if self.cancut:\n            direction = self.get_direction(event.direction)\n            self._cycle_cuts_alg(viewer, msg, direction=direction)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sc_zoom(self, viewer, event, msg=True):\n        self._sc_zoom(viewer, event, msg=msg, origin=None)\n        return True", "response": "Interactively zoom the image by scrolling motion."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sc_zoom_origin(self, viewer, event, msg=True):\n        origin = (event.data_x, event.data_y)\n        self._sc_zoom(viewer, event, msg=msg, origin=origin)\n        return True", "response": "zoom the image to the origin of the window"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sc_pan(self, viewer, event, msg=True):\n        if not self.canpan:\n            return True\n\n        # User has \"Pan Reverse\" preference set?\n        rev = self.settings.get('pan_reverse', False)\n        direction = event.direction\n\n        if rev:\n            direction = math.fmod(direction + 180.0, 360.0)\n\n        pan_accel = self.settings.get('scroll_pan_acceleration', 1.0)\n        # Internal factor to adjust the panning speed so that user-adjustable\n        # scroll_pan_acceleration is normalized to 1.0 for \"normal\" speed\n        scr_pan_adj_factor = 1.4142135623730951\n        amount = (event.amount * scr_pan_adj_factor * pan_accel) / 360.0\n\n        self.pan_omni(viewer, direction, amount)\n        return True", "response": "Interactively pan the image by scrolling motion."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sc_naxis(self, viewer, event, msg=True):\n        # TODO: be able to pick axis\n        axis = 2\n        direction = self.get_direction(event.direction)\n\n        return self._nav_naxis(viewer, axis, direction, msg=msg)", "response": "Interactively change the slice of the image in a data cube by scrolling."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sc_imap(self, viewer, event, msg=True):\n        direction = self.get_direction(event.direction)\n        self._cycle_imap(viewer, msg, direction=direction)\n        return True", "response": "Interactively change the intensity map by scrolling."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nzooming and rotate the viewer by a pinch gesture.", "response": "def pi_zoom(self, viewer, event, msg=True):\n        \"\"\"Zoom and/or rotate the viewer by a pinch gesture.\n        (the back end must support gestures)\n        \"\"\"\n        return self._pinch_zoom_rotate(viewer, event.state, event.rot_deg,\n                                       event.scale, msg=msg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pi_zoom_origin(self, viewer, event, msg=True):\n        origin = (event.data_x, event.data_y)\n        return self._pinch_zoom_rotate(viewer, event.state, event.rot_deg,\n                                       event.scale, msg=msg, origin=origin)", "response": "This is a wrapper around pinch_zoom_rotate that takes an event and returns the image that was zoomed at that origin."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pa_pan(self, viewer, event, msg=True):\n        return self.gs_pan(viewer, event.state,\n                           event.delta_x, event.delta_y, msg=msg)", "response": "Interactively pan the image by a pan gesture."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pa_zoom(self, viewer, event, msg=True):\n        event = self._pa_synth_scroll_event(event)\n        if event.state != 'move':\n            return False\n        self._sc_zoom(viewer, event, msg=msg, origin=None)\n        return True", "response": "Interactively zoom the image by a pan gesture."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pa_zoom_origin(self, viewer, event, msg=True):\n        event = self._pa_synth_scroll_event(event)\n        if event.state != 'move':\n            return False\n        origin = (event.data_x, event.data_y)\n        self._sc_zoom(viewer, event, msg=msg, origin=origin)\n        return True", "response": "Zoom the image in the same position as the current image."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mode_key_up(self, viewer, keyname):\n        # Is this a mode key?\n        if keyname not in self.mode_map:\n            # <== no\n            return False\n\n        bnch = self.mode_map[keyname]\n        if self._kbdmode == bnch.name:\n            # <-- the current mode key is being released\n            if bnch.type == 'held':\n                if self._button == 0:\n                    # if no button is being held, then reset mode\n                    self.reset_mode(viewer)\n                else:\n                    self._delayed_reset = True\n            return True\n\n        return False", "response": "This method is called when a key is pressed in a mode and was\n            is not handled by other handlers with precedence with precedence with precedence with precedence."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_4pt_bezier(steps, points):\n    for i in range(steps):\n        t = i / float(steps)\n\n        xloc = (math.pow(1 - t, 3) * points[0][0] +\n                3 * t * math.pow(1 - t, 2) * points[1][0] +\n                3 * (1 - t) * math.pow(t, 2) * points[2][0] +\n                math.pow(t, 3) * points[3][0])\n        yloc = (math.pow(1 - t, 3) * points[0][1] +\n                3 * t * math.pow(1 - t, 2) * points[1][1] +\n                3 * (1 - t) * math.pow(t, 2) * points[2][1] +\n                math.pow(t, 3) * points[3][1])\n\n        yield (xloc, yloc)", "response": "Gets a series of bezier curve points with 1 set of 4\n    control points."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a series of bezier curve points with any number of sets of 4 control points.", "response": "def get_bezier(steps, points):\n    \"\"\"Gets a series of bezier curve points with any number of sets\n    of 4 control points.\"\"\"\n    res = []\n    num_pts = len(points)\n    for i in range(0, num_pts + 1, 3):\n        if i + 4 < num_pts + 1:\n            res.extend(list(get_4pt_bezier(steps, points[i:i + 4])))\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_bezier_ellipse(x, y, xradius, yradius, kappa=0.5522848):\n\n    xs, ys = x - xradius, y - yradius\n    ox, oy = xradius * kappa, yradius * kappa\n    xe, ye = x + xradius, y + yradius\n\n    pts = [(xs, y),\n           (xs, y - oy), (x - ox, ys), (x, ys),\n           (x + ox, ys), (xe, y - oy), (xe, y),\n           (xe, y + oy), (x + ox, ye), (x, ye),\n           (x - ox, ye), (xs, y + oy), (xs, y)]\n    return pts", "response": "Get a set of 12 bezier control points necessary to form an anonymized ellipse."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_imap_cb(self, w, index):\n        name = imap.get_names()[index]\n        self.t_.set(intensity_map=name)", "response": "This callback is invoked when the user selects a new intensity\n        map from the preferences pane."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_calg_cb(self, w, index):\n        #index = w.get_index()\n        name = self.calg_names[index]\n        self.t_.set(color_algorithm=name)", "response": "This callback is invoked when the user selects a new color\n        hashing algorithm from the preferences pane."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef autocut_params_changed_cb(self, paramObj, ac_obj):\n        args, kwdargs = paramObj.get_params()\n        params = list(kwdargs.items())\n        self.t_.set(autocut_params=params)", "response": "This callback is called when the user changes the attributes of\n        an object via the paramSet."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_sort_cb(self, w, index):\n        name = self.sort_options[index]\n        self.t_.set(sort_order=name)", "response": "This callback is invoked when the user selects a new sort order\n        from the preferences pane."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef zoomset_cb(self, setting, value, channel):\n        if not self.gui_up:\n            return\n        info = channel.extdata._info_info\n        if info is None:\n            return\n        #scale_x, scale_y = fitsimage.get_scale_xy()\n        scale_x, scale_y = value\n\n        # Set text showing zoom factor (1X, 2X, etc.)\n        if scale_x == scale_y:\n            text = self.fv.scale2text(scale_x)\n        else:\n            textx = self.fv.scale2text(scale_x)\n            texty = self.fv.scale2text(scale_y)\n            text = \"X: %s  Y: %s\" % (textx, texty)\n        info.winfo.zoom.set_text(text)", "response": "This callback is called when the main window is zoomed."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_naxis(self, idx, n):\n        self.play_idx = idx\n        self.logger.debug(\"naxis %d index is %d\" % (n + 1, idx + 1))\n\n        image = self.fitsimage.get_image()\n        slidername = 'choose_naxis%d' % (n + 1)\n        try:\n            if image is None:\n                raise ValueError(\"Please load an image cube\")\n\n            m = n - 2\n\n            self.naxispath[m] = idx\n            self.logger.debug(\"m=%d naxispath=%s\" % (m, str(self.naxispath)))\n\n            image.set_naxispath(self.naxispath)\n            self.logger.debug(\"NAXIS%d slice %d loaded.\" % (n + 1, idx + 1))\n\n            if self.play_indices:\n                # save play index\n                self.play_indices[m] = idx\n                text = [i + 1 for i in self.naxispath]\n                if slidername in self.w:\n                    self.w[slidername].set_value(text[m])\n            else:\n                text = idx + 1\n                if slidername in self.w:\n                    self.w[slidername].set_value(text)\n            self.w.slice.set_text(str(text))\n\n            # schedule a redraw\n            self.fitsimage.redraw(whence=0)\n\n        except Exception as e:\n            errmsg = \"Error loading NAXIS%d slice %d: %s\" % (\n                n + 1, idx + 1, str(e))\n            self.logger.error(errmsg)\n            self.fv.error(errmsg)", "response": "Change the slice shown in the channel viewer."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalls when an image is set in the channel.", "response": "def redo(self):\n        \"\"\"Called when an image is set in the channel.\"\"\"\n        image = self.channel.get_current_image()\n        if image is None:\n            return True\n\n        path = image.get('path', None)\n        if path is None:\n            self.fv.show_error(\n                \"Cannot open image: no value for metadata key 'path'\")\n            return\n\n        # TODO: How to properly reset GUI components?\n        #       They are still showing info from prev FITS.\n        # No-op for ASDF\n        if path.endswith('asdf'):\n            return True\n\n        if path != self.img_path:\n            # <-- New file is being looked at\n            self.img_path = path\n\n            # close previous file opener, if any\n            if self.file_obj is not None:\n                try:\n                    self.file_obj.close()\n                except Exception:\n                    pass\n\n            self.file_obj = io_fits.get_fitsloader(logger=self.logger)\n\n            # TODO: specify 'readonly' somehow?\n            self.file_obj.open_file(path)\n\n            upper = len(self.file_obj) - 1\n            self.prep_hdu_menu(self.w.hdu, self.file_obj.hdu_info)\n            self.num_hdu = upper\n            self.logger.debug(\"there are %d hdus\" % (upper + 1))\n            self.w.numhdu.set_text(\"%d\" % (upper + 1))\n\n            self.w.hdu.set_enabled(len(self.file_obj) > 0)\n\n        name = image.get('name', iohelper.name_image_from_path(path))\n        idx = image.get('idx', None)\n        # remove index designation from root of name, if any\n        match = re.match(r'^(.+)\\[(.+)\\]$', name)\n        if match:\n            name = match.group(1)\n        self.name_pfx = name\n\n        htype = None\n        if idx is not None:\n            # set the HDU in the drop down if known\n            info = self.file_obj.hdu_db.get(idx, None)\n            if info is not None:\n                htype = info.htype.lower()\n                toc_ent = self._toc_fmt % info\n                self.w.hdu.show_text(toc_ent)\n\n        # rebuild the NAXIS controls, if necessary\n        # No two images in the same channel can have the same name.\n        # Here we keep track of the name to decide if we need to rebuild\n        if self.img_name != name:\n            self.img_name = name\n            dims = [0, 0]\n            data = image.get_data()\n            if data is None:\n                # <- empty data part to this HDU\n                self.logger.warning(\"Empty data part in HDU %s\" % (str(idx)))\n\n            elif htype in ('bintablehdu', 'tablehdu',):\n                pass\n\n            elif htype not in ('imagehdu', 'primaryhdu', 'compimagehdu'):\n                self.logger.warning(\"HDU %s is not an image (%s)\" % (\n                    str(idx), htype))\n\n            else:\n                mddata = image.get_mddata()\n                if mddata is not None:\n                    dims = list(mddata.shape)\n                    dims.reverse()\n\n            self.build_naxis(dims, image)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrotating an array of points x_arr y_arr by theta_deg", "response": "def rotate_pt(x_arr, y_arr, theta_deg, xoff=0, yoff=0):\n    \"\"\"\n    Rotate an array of points (x_arr, y_arr) by theta_deg offsetted\n    from a center point by (xoff, yoff).\n    \"\"\"\n    # TODO: use opencv acceleration if available\n    a_arr = x_arr - xoff\n    b_arr = y_arr - yoff\n    cos_t = np.cos(np.radians(theta_deg))\n    sin_t = np.sin(np.radians(theta_deg))\n    ap = (a_arr * cos_t) - (b_arr * sin_t)\n    bp = (a_arr * sin_t) + (b_arr * cos_t)\n    return np.asarray((ap + xoff, bp + yoff))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rotate_clip(data_np, theta_deg, rotctr_x=None, rotctr_y=None,\n                out=None, use_opencl=True, logger=None):\n    \"\"\"\n    Rotate numpy array `data_np` by `theta_deg` around rotation center\n    (rotctr_x, rotctr_y).  If the rotation center is omitted it defaults\n    to the center of the array.\n\n    No adjustment is done to the data array beforehand, so the result will\n    be clipped according to the size of the array (the output array will be\n    the same size as the input array).\n    \"\"\"\n\n    # If there is no rotation, then we are done\n    if math.fmod(theta_deg, 360.0) == 0.0:\n        return data_np\n\n    ht, wd = data_np.shape[:2]\n    dtype = data_np.dtype\n\n    if rotctr_x is None:\n        rotctr_x = wd // 2\n    if rotctr_y is None:\n        rotctr_y = ht // 2\n\n    if have_opencv:\n        if logger is not None:\n            logger.debug(\"rotating with OpenCv\")\n        # opencv is fastest\n        M = cv2.getRotationMatrix2D((rotctr_y, rotctr_x), theta_deg, 1)\n\n        if data_np.dtype == np.dtype('>f8'):\n            # special hack for OpenCv warpAffine bug on numpy arrays of\n            # dtype '>f8'-- it corrupts them\n            data_np = data_np.astype(np.float64)\n\n        newdata = cv2.warpAffine(data_np, M, (wd, ht))\n        new_ht, new_wd = newdata.shape[:2]\n        assert (wd == new_wd) and (ht == new_ht), \\\n            Exception(\"rotated cutout is %dx%d original=%dx%d\" % (\n                new_wd, new_ht, wd, ht))\n\n        newdata = newdata.astype(dtype, copy=False)\n\n        if out is not None:\n            out[:, :, ...] = newdata\n            newdata = out\n\n    elif have_opencl and use_opencl:\n        if logger is not None:\n            logger.debug(\"rotating with OpenCL\")\n        # opencl is very close, sometimes better, sometimes worse\n        if (data_np.dtype == np.uint8) and (len(data_np.shape) == 3):\n            # special case for 3D RGB images\n            newdata = trcalc_cl.rotate_clip_uint32(data_np, theta_deg,\n                                                   rotctr_x, rotctr_y,\n                                                   out=out)\n        else:\n            newdata = trcalc_cl.rotate_clip(data_np, theta_deg,\n                                            rotctr_x, rotctr_y,\n                                            out=out)\n\n    else:\n        if logger is not None:\n            logger.debug(\"rotating with numpy\")\n        yi, xi = np.mgrid[0:ht, 0:wd]\n        xi -= rotctr_x\n        yi -= rotctr_y\n        cos_t = np.cos(np.radians(theta_deg))\n        sin_t = np.sin(np.radians(theta_deg))\n\n        if have_numexpr:\n            ap = ne.evaluate(\"(xi * cos_t) - (yi * sin_t) + rotctr_x\")\n            bp = ne.evaluate(\"(xi * sin_t) + (yi * cos_t) + rotctr_y\")\n        else:\n            ap = (xi * cos_t) - (yi * sin_t) + rotctr_x\n            bp = (xi * sin_t) + (yi * cos_t) + rotctr_y\n\n        #ap = np.rint(ap).astype('int').clip(0, wd-1)\n        #bp = np.rint(bp).astype('int').clip(0, ht-1)\n        # Optomizations to reuse existing intermediate arrays\n        np.rint(ap, out=ap)\n        ap = ap.astype(np.int, copy=False)\n        ap.clip(0, wd - 1, out=ap)\n        np.rint(bp, out=bp)\n        bp = bp.astype(np.int, copy=False)\n        bp.clip(0, ht - 1, out=bp)\n\n        if out is not None:\n            out[:, :, ...] = data_np[bp, ap]\n            newdata = out\n        else:\n            newdata = data_np[bp, ap]\n            new_ht, new_wd = newdata.shape[:2]\n\n            assert (wd == new_wd) and (ht == new_ht), \\\n                Exception(\"rotated cutout is %dx%d original=%dx%d\" % (\n                    new_wd, new_ht, wd, ht))\n\n    return newdata", "response": "Rotate numpy array data_np by theta_deg around rotation center of the input array."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_scaled_cutout_wdht_view(shp, x1, y1, x2, y2, new_wd, new_ht):\n    x1, y1, x2, y2 = int(x1), int(y1), int(x2), int(y2)\n    new_wd, new_ht = int(new_wd), int(new_ht)\n\n    # calculate dimensions of NON-scaled cutout\n    old_wd = x2 - x1 + 1\n    old_ht = y2 - y1 + 1\n    max_x, max_y = shp[1] - 1, shp[0] - 1\n\n    if (new_wd != old_wd) or (new_ht != old_ht):\n        # Make indexes and scale them\n        # Is there a more efficient way to do this?\n        yi = np.mgrid[0:new_ht].reshape(-1, 1)\n        xi = np.mgrid[0:new_wd].reshape(1, -1)\n        iscale_x = float(old_wd) / float(new_wd)\n        iscale_y = float(old_ht) / float(new_ht)\n\n        xi = (x1 + xi * iscale_x).clip(0, max_x).astype(np.int, copy=False)\n        yi = (y1 + yi * iscale_y).clip(0, max_y).astype(np.int, copy=False)\n        wd, ht = xi.shape[1], yi.shape[0]\n\n        # bounds check against shape (to protect future data access)\n        xi_max, yi_max = xi[0, -1], yi[-1, 0]\n        assert xi_max <= max_x, ValueError(\"X index (%d) exceeds shape bounds (%d)\" % (xi_max, max_x))\n        assert yi_max <= max_y, ValueError(\"Y index (%d) exceeds shape bounds (%d)\" % (yi_max, max_y))\n\n        view = np.s_[yi, xi]\n\n    else:\n        # simple stepped view will do, because new view is same as old\n        wd, ht = old_wd, old_ht\n        view = np.s_[y1:y2 + 1, x1:x2 + 1]\n\n    # Calculate actual scale used (vs. desired)\n    old_wd, old_ht = max(old_wd, 1), max(old_ht, 1)\n    scale_x = float(wd) / old_wd\n    scale_y = float(ht) / old_ht\n\n    # return view + actual scale factors used\n    return (view, (scale_x, scale_y))", "response": "Returns the view of the non - scaled cutout from an image instead of the extraction itself."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_scaled_cutout_wdhtdp_view(shp, p1, p2, new_dims):\n    x1, y1, z1 = p1\n    x2, y2, z2 = p2\n    new_wd, new_ht, new_dp = new_dims\n\n    x1, y1, x2, y2 = int(x1), int(y1), int(x2), int(y2), int(z1), int(z2)\n    z1, z2, new_wd, new_ht = int(z1), int(z2), int(new_wd), int(new_ht)\n\n    # calculate dimensions of NON-scaled cutout\n    old_wd = x2 - x1 + 1\n    old_ht = y2 - y1 + 1\n    old_dp = z2 - z1 + 1\n    max_x, max_y, max_z = shp[1] - 1, shp[0] - 1, shp[2] - 1\n\n    if (new_wd != old_wd) or (new_ht != old_ht) or (new_dp != old_dp):\n        # Make indexes and scale them\n        # Is there a more efficient way to do this?\n        yi = np.mgrid[0:new_ht].reshape(-1, 1, 1)\n        xi = np.mgrid[0:new_wd].reshape(1, -1, 1)\n        zi = np.mgrid[0:new_dp].reshape(1, 1, -1)\n        iscale_x = float(old_wd) / float(new_wd)\n        iscale_y = float(old_ht) / float(new_ht)\n        iscale_z = float(old_dp) / float(new_dp)\n\n        xi = (x1 + xi * iscale_x).clip(0, max_x).astype(np.int, copy=False)\n        yi = (y1 + yi * iscale_y).clip(0, max_y).astype(np.int, copy=False)\n        zi = (z1 + zi * iscale_z).clip(0, max_z).astype(np.int, copy=False)\n        wd, ht, dp = xi.shape[1], yi.shape[0], zi.shape[2]\n\n        # bounds check against shape (to protect future data access)\n        xi_max, yi_max, zi_max = xi[0, -1, 0], yi[-1, 0, 0], zi[0, 0, -1]\n        assert xi_max <= max_x, ValueError(\"X index (%d) exceeds shape bounds (%d)\" % (xi_max, max_x))\n        assert yi_max <= max_y, ValueError(\"Y index (%d) exceeds shape bounds (%d)\" % (yi_max, max_y))\n        assert zi_max <= max_z, ValueError(\"Z index (%d) exceeds shape bounds (%d)\" % (zi_max, max_z))\n\n        view = np.s_[yi, xi, zi]\n\n    else:\n        # simple stepped view will do, because new view is same as old\n        wd, ht, dp = old_wd, old_ht, old_dp\n        view = np.s_[y1:y2 + 1, x1:x2 + 1, z1:z2 + 1]\n\n    # Calculate actual scale used (vs. desired)\n    old_wd, old_ht, old_dp = max(old_wd, 1), max(old_ht, 1), max(old_dp, 1)\n    scale_x = float(wd) / old_wd\n    scale_y = float(ht) / old_ht\n    scale_z = float(dp) / old_dp\n\n    # return view + actual scale factors used\n    return (view, (scale_x, scale_y, scale_z))", "response": "This function returns the view and slice of the given image as a tuple of the shape of the new image."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_scaled_cutout_basic_view(shp, p1, p2, scales):\n\n    x1, y1 = p1[:2]\n    x2, y2 = p2[:2]\n    scale_x, scale_y = scales[:2]\n    # calculate dimensions of NON-scaled cutout\n    old_wd = x2 - x1 + 1\n    old_ht = y2 - y1 + 1\n    # calculate dimensions of scaled cutout\n    new_wd = int(round(scale_x * old_wd))\n    new_ht = int(round(scale_y * old_ht))\n\n    if len(scales) == 2:\n        return get_scaled_cutout_wdht_view(shp, x1, y1, x2, y2, new_wd, new_ht)\n\n    z1, z2, scale_z = p1[2], p2[2], scales[2]\n    old_dp = z2 - z1 + 1\n    new_dp = int(round(scale_z * old_dp))\n    return get_scaled_cutout_wdhtdp_view(shp, p1, p2, (new_wd, new_ht, new_dp))", "response": "This function returns the view and slice to extract\n    from an image instead of the extraction itself"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef calc_image_merge_clip(p1, p2, dst, q1, q2):\n    x1, y1 = p1[:2]\n    x2, y2 = p2[:2]\n    dst_x, dst_y = dst[:2]\n    a1, b1 = q1[:2]\n    a2, b2 = q2[:2]\n    src_wd, src_ht = a2 - a1, b2 - b1\n\n    # Trim off parts of srcarr that would be \"hidden\"\n    # to the left and above the dstarr edge.\n    ex = y1 - dst_y\n    if ex > 0:\n        src_ht -= ex\n        dst_y += ex\n        b1 += ex\n\n    ex = x1 - dst_x\n    if ex > 0:\n        src_wd -= ex\n        dst_x += ex\n        a1 += ex\n\n    # Trim off parts of srcarr that would be \"hidden\"\n    # to the right and below dstarr edge.\n    ex = dst_y + src_ht - y2\n    if ex > 0:\n        src_ht -= ex\n        b2 -= ex\n\n    ex = dst_x + src_wd - x2\n    if ex > 0:\n        src_wd -= ex\n        a2 -= ex\n\n    if len(p1) > 2:\n        # 3D image\n        z1, z2, dst_z, c1, c2 = p1[2], p2[2], dst[2], q1[2], q2[2]\n        src_dp = c2 - c1\n\n        ex = z1 - dst_z\n        if ex > 0:\n            src_dp -= ex\n            dst_z += ex\n            c1 += ex\n\n        ex = dst_z + src_dp - z2\n        if ex > 0:\n            src_dp -= ex\n            c2 -= ex\n\n        return ((dst_x, dst_y, dst_z), (a1, b1, c1), (a2, b2, c2))\n\n    else:\n        return ((dst_x, dst_y), (a1, b1), (a2, b2))", "response": "Calculate the image to merge the two images."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreorders src_arr with order of color planes in src_order as dst_order.", "response": "def reorder_image(dst_order, src_arr, src_order):\n    \"\"\"Reorder src_arr, with order of color planes in src_order, as\n    dst_order.\n    \"\"\"\n    depth = src_arr.shape[2]\n    if depth != len(src_order):\n        raise ValueError(\"src_order (%s) does not match array depth (%d)\" % (\n            src_order, depth))\n\n    bands = []\n    if dst_order == src_order:\n        return np.ascontiguousarray(src_arr)\n\n    elif 'A' not in dst_order or 'A' in src_order:\n        # <-- we don't have to add an alpha plane, just create a new view\n        idx = np.array([src_order.index(c) for c in dst_order])\n        return np.ascontiguousarray(src_arr[..., idx])\n\n    else:\n        # <-- dst order requires missing alpha channel\n        indexes = [src_order.index(c) for c in dst_order.replace('A', '')]\n        bands = [src_arr[..., idx, np.newaxis] for idx in indexes]\n        ht, wd = src_arr.shape[:2]\n        dst_type = src_arr.dtype\n        dst_max_val = np.iinfo(dst_type).max\n        alpha = np.full((ht, wd, 1), dst_max_val, dtype=dst_type)\n        bands.insert(dst_order.index('A'), alpha)\n\n    return np.concatenate(bands, axis=-1)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef strip_z(pts):\n    pts = np.asarray(pts)\n    if pts.shape[-1] > 2:\n        pts = np.asarray((pts.T[0], pts.T[1])).T\n    return pts", "response": "Strips a Z component from pts if it is present."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pad_z(pts, value=0.0):\n    pts = np.asarray(pts)\n    if pts.shape[-1] < 3:\n        if len(pts.shape) < 2:\n            return np.asarray((pts[0], pts[1], value), dtype=pts.dtype)\n        pad_col = np.full(len(pts), value, dtype=pts.dtype)\n        pts = np.asarray((pts.T[0], pts.T[1], pad_col)).T\n    return pts", "response": "Adds a Z component from pts if it is missing."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_bounds(pts):\n    pts_t = np.asarray(pts).T\n    return np.asarray(([np.min(_pts) for _pts in pts_t],\n                       [np.max(_pts) for _pts in pts_t]))", "response": "Return the minimum point and maximum point bounding a\n    set of points."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfilling array dstarr with a color value.", "response": "def fill_array(dstarr, order, r, g, b, a):\n    \"\"\"Fill array dstarr with a color value. order defines the color planes\n    in the array.  (r, g, b, a) are expected to be in the range 0..1 and\n    are scaled to the appropriate values.\n\n    dstarr can be a 2D or 3D array.\n    \"\"\"\n    # TODO: can we make this more efficient?\n    dtype = dstarr.dtype\n    maxv = np.iinfo(dtype).max\n    bgval = dict(A=int(maxv * a), R=int(maxv * r), G=int(maxv * g),\n                 B=int(maxv * b))\n    bgtup = tuple([bgval[order[i]] for i in range(len(order))])\n    if dtype is np.uint8 and len(bgtup) == 4:\n        # optimiztion\n        bgtup = np.array(bgtup, dtype=dtype).view(np.uint32)[0]\n        dstarr = dstarr.view(np.uint32)\n\n    dstarr[..., :] = bgtup"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_filled_array(shp, dtype, order, r, g, b, a):\n    # TODO: can we make this more efficient?\n    maxv = np.iinfo(dtype).max\n    bgval = dict(A=int(maxv * a), R=int(maxv * r), G=int(maxv * g),\n                 B=int(maxv * b))\n    bgtup = tuple([bgval[order[i]] for i in range(len(order))])\n    if dtype is np.uint8 and len(bgtup) == 4:\n        # optimiztion when dealing with 32-bit RGBA arrays\n        fill_val = np.array(bgtup, dtype=dtype).view(np.uint32)\n        rgba = np.zeros(shp, dtype=dtype)\n        rgba_i = rgba.view(np.uint32)\n        rgba_i[:] = fill_val\n        return rgba\n    return np.full(shp, bgtup, dtype=dtype)", "response": "Return a filled array with a color value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfunctioning creates a new mosaic image and returns it", "response": "def mosaic(logger, itemlist, fov_deg=None):\n    \"\"\"\n    Parameters\n    ----------\n    logger : logger object\n        a logger object passed to created AstroImage instances\n    itemlist : sequence like\n        a sequence of either filenames or AstroImage instances\n    \"\"\"\n\n    if isinstance(itemlist[0], AstroImage.AstroImage):\n        image0 = itemlist[0]\n        name = image0.get('name', 'image0')\n    else:\n        # Assume it is a file and load it\n        filepath = itemlist[0]\n        logger.info(\"Reading file '%s' ...\" % (filepath))\n        image0 = AstroImage.AstroImage(logger=logger)\n        image0.load_file(filepath)\n        name = filepath\n\n    ra_deg, dec_deg = image0.get_keywords_list('CRVAL1', 'CRVAL2')\n    header = image0.get_header()\n    (rot_deg, cdelt1, cdelt2) = wcs.get_rotation_and_scale(header)\n    logger.debug(\"image0 rot=%f cdelt1=%f cdelt2=%f\" % (rot_deg,\n                                                        cdelt1, cdelt2))\n\n    px_scale = math.fabs(cdelt1)\n    expand = False\n    if fov_deg is None:\n        # TODO: calculate fov?\n        expand = True\n\n    cdbase = [np.sign(cdelt1), np.sign(cdelt2)]\n    img_mosaic = dp.create_blank_image(ra_deg, dec_deg,\n                                       fov_deg, px_scale, rot_deg,\n                                       cdbase=cdbase,\n                                       logger=logger)\n    header = img_mosaic.get_header()\n    (rot, cdelt1, cdelt2) = wcs.get_rotation_and_scale(header)\n    logger.debug(\"mosaic rot=%f cdelt1=%f cdelt2=%f\" % (rot, cdelt1, cdelt2))\n\n    logger.debug(\"Processing '%s' ...\" % (name))\n    tup = img_mosaic.mosaic_inline([image0],\n                                   allow_expand=expand)\n    logger.debug(\"placement %s\" % (str(tup)))\n\n    count = 1\n    for item in itemlist[1:]:\n        if isinstance(item, AstroImage.AstroImage):\n            image = item\n            name = image.get('name', 'image%d' % (count))\n        else:\n            # Create and load the image\n            filepath = item\n            logger.info(\"Reading file '%s' ...\" % (filepath))\n            image = AstroImage.AstroImage(logger=logger)\n            image.load_file(filepath)\n\n        logger.debug(\"Inlining '%s' ...\" % (name))\n        tup = img_mosaic.mosaic_inline([image])\n        logger.debug(\"placement %s\" % (str(tup)))\n        count += 1\n\n    logger.info(\"Done.\")\n    return img_mosaic"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_scroll_info(event):\n    valid, dx, dy = event.get_scroll_deltas()\n    if valid:\n        # we have a trackpad or some device that reports pixel deltas\n        delta = math.sqrt(dx ** 2 + dy ** 2)\n        if dy < 0:\n            delta = -delta\n\n        ang_rad = math.atan2(dy, dx)\n        direction = math.degrees(ang_rad) - 90.0\n        direction = math.fmod(direction + 360.0, 360.0)\n\n        # TODO: is this accurate?--NOT TESTED\n        num_degrees = delta / 8.0\n\n    else:\n        valid, direction = event.get_scroll_direction()\n        if valid:\n            if event.direction == Gdk.ScrollDirection.UP:\n                direction = 0.0\n            elif event.direction == Gdk.ScrollDirection.DOWN:\n                direction = 180.0\n            elif event.direction == Gdk.ScrollDirection.LEFT:\n                direction = 270.0\n            elif event.direction == Gdk.ScrollDirection.RIGHT:\n                direction = 90.0\n\n        else:\n            direction = None\n\n        # TODO: does Gtk encode the amount of scroll?\n        # 15 deg is standard 1-click turn for a wheel mouse\n        num_degrees = 15.0\n\n    return (num_degrees, direction)", "response": "Returns the number of degrees and direction of a scroll motion Gtk event."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlets user select a directory.", "response": "def popup(self, title, callfn, initialdir=None):\n        \"\"\"Let user select a directory.\"\"\"\n        super(DirectorySelection, self).popup(title, callfn, initialdir)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_mode_cb(self, mode, tf):\n        if tf:\n            self.canvas.set_draw_mode(mode)\n            if mode == 'edit':\n                self.edit_select_mark()\n        return True", "response": "Called when one of the Move Draw or Edit radio buttons is selected."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef draw(self, viewer):\n        cache = self.get_cache(viewer)\n\n        if not cache.drawn:\n            cache.drawn = True\n            viewer.redraw(whence=2)\n\n        cpoints = self.get_cpoints(viewer)\n        cr = viewer.renderer.setup_cr(self)\n\n        # draw optional border\n        if self.linewidth > 0:\n            cr.draw_polygon(cpoints)\n\n        if self.showcap:\n            self.draw_caps(cr, self.cap, cpoints)", "response": "General draw method for RGB image types."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntrim characters off of the beginningnings of a text line.", "response": "def trim_prefix(text, nchr):\n    \"\"\"Trim characters off of the beginnings of text lines.\n\n    Parameters\n    ----------\n    text : str\n        The text to be trimmed, with newlines (\\n) separating lines\n\n    nchr: int\n        The number of spaces to trim off the beginning of a line if\n        it starts with that many spaces\n\n    Returns\n    -------\n    text : str\n        The trimmed text\n    \"\"\"\n    res = []\n    for line in text.split('\\n'):\n        if line.startswith(' ' * nchr):\n            line = line[nchr:]\n        res.append(line)\n\n    return '\\n'.join(res)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate a config file documentation for a given config name.", "response": "def generate_cfg_example(config_name, cfgpath='examples/configs', **kwargs):\n    \"\"\"Generate config file documentation for a given config name.\n\n    If found, it will be a Python code block of the contents.\n    If not found, it will have a generic message that the config\n    is not available.\n\n    Parameters\n    ----------\n    config_name : str\n        Config name that is attached to the configuration file.\n        This is the same as input for ``prefs.createCategory()``.\n        For example, ``'general'``, ``'channel_Image'``, or\n        ``'plugin_Zoom'``.\n\n    cfgpath : str\n        Where it is within package data.\n\n    kwargs : dict\n        Optional keywords for :func:`~astropy.utils.data.get_pkg_data_contents`.\n\n    Returns\n    -------\n    docstr : str\n        Docstring to be inserted into documentation.\n\n    \"\"\"\n    cfgname = config_name + '.cfg'\n\n    try:\n        cfgfile = _find_pkg_data_path(os.path.join(cfgpath, cfgname), **kwargs)\n        with open(cfgfile) as f:\n            cfgdata = f.readlines()\n    except Exception as e:\n        warnings.warn(str(e), AstropyUserWarning)\n        return ''\n\n    homepath = '~'  # Symbol for HOME for doc only, not actual code\n    userfile = os.path.join(homepath, '.ginga', cfgname)\n\n    docstring = io.StringIO()\n    docstring.write(\"\"\"It is customizable using ``{0}``, where ``{1}``\nis your HOME directory:\n\n.. code-block:: Python\n\n\"\"\".format(userfile, homepath))\n\n    for line in cfgdata:\n        line = line.strip()\n\n        if len(line) == 0:\n            docstring.write('\\n')  # Prevent trailing spaces\n        else:\n            docstring.write('  {0}\\n'.format(line))\n\n    return docstring.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_figure(self, figure, handle=None):\n        self.figure = figure\n        self.bkimage = None\n        self._push_handle = handle\n\n        wd = figure.plot_width\n        ht = figure.plot_height\n\n        self.configure_window(wd, ht)\n\n        doc = curdoc()\n        #self.logger.info(str(dir(doc)))\n        doc.add_periodic_callback(self.timer_cb, 50)\n        self.logger.info(\"figure set\")", "response": "Call this with the figure object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_figure(self, figure, handle=None):\n        self.figure = figure\n        self.bkimage = None\n        self._push_handle = handle\n\n        wd = figure.plot_width\n        ht = figure.plot_height\n\n        self.configure_window(wd, ht)\n\n        doc = curdoc()\n        self.logger.info(str(dir(doc)))\n        #doc.add_periodic_callback(self.timer_cb, 100)\n        self.logger.info(\"figure set\")", "response": "Call this with the figure object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render_image(self, rgbobj, dst_x, dst_y):\n        self.logger.debug(\"redraw pixmap=%s\" % (self.pixmap))\n        if self.pixmap is None:\n            return\n        self.logger.debug(\"drawing to pixmap\")\n\n        # Prepare array for rendering\n        arr = rgbobj.get_array(self.rgb_order, dtype=np.uint8)\n        (height, width) = arr.shape[:2]\n\n        return self._render_offscreen(self.pixmap, arr, dst_x, dst_y,\n                                      width, height)", "response": "Render the image represented by rgbobj at dst_x dst_y in the offscreen pixmap."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_plain_image_as_widget(self):\n        arr = self.getwin_array(order=self.rgb_order)\n\n        # convert numpy array to native image widget\n        image_w = self._get_wimage(arr)\n        return image_w", "response": "Used for generating thumbnails. Does not include overlaid\n        graphics."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save_plain_image_as_file(self, filepath, format='png', quality=90):\n        img_w = self.get_plain_image_as_widget()\n        # assumes that the image widget has some method for saving to\n        # a file\n        img_w.save(filepath, format=format, quality=quality)", "response": "Saves the plain image as a file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_color(self, r, g, b):\n        clr = (r, g, b)\n        return clr", "response": "Convert red green and blue values specified in floats with\n        range 0 - 1 to whatever the native widget color object is."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef key_press_event(self, widget, event):\n        # get keyname or keycode and translate to ginga standard\n        # keyname =\n        # keycode =\n        keyname = ''  # self.transkey(keyname, keycode)\n        self.logger.debug(\"key press event, key=%s\" % (keyname))\n        return self.make_ui_callback('key-press', keyname)", "response": "Called when a key is pressed and the window has focus."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalls when a key is released after being pressed.", "response": "def key_release_event(self, widget, event):\n        \"\"\"\n        Called when a key is released after being pressed.\n        Adjust method signature as appropriate for callback.\n        \"\"\"\n        # get keyname or keycode and translate to ginga standard\n        # keyname =\n        # keycode =\n        keyname = ''  # self.transkey(keyname, keycode)\n        self.logger.debug(\"key release event, key=%s\" % (keyname))\n        return self.make_ui_callback('key-release', keyname)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalls when a mouse is turned in the trackpad and a scroll event occurs.", "response": "def scroll_event(self, widget, event):\n        \"\"\"\n        Called when a mouse is turned in the widget (and maybe for\n        finger scrolling in the trackpad).\n        Adjust method signature as appropriate for callback.\n        \"\"\"\n        x, y = event.x, event.y\n        num_degrees = 0\n        direction = 0\n\n        # x, y = coordinates of mouse\n        self.last_win_x, self.last_win_y = x, y\n\n        # calculate number of degrees of scroll and direction of scroll\n        # both floats in the 0-359.999 range\n        # num_degrees =\n        # direction =\n        self.logger.debug(\"scroll deg=%f direction=%f\" % (\n            num_degrees, direction))\n\n        data_x, data_y = self.check_cursor_location()\n\n        return self.make_ui_callback('scroll', direction, num_degrees,\n                                     data_x, data_y)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef drawBackground(self, painter, rect):\n        if not self.pixmap:\n            return\n        x1, y1, x2, y2 = rect.getCoords()\n        width = x2 - x1 + 1\n        height = y2 - y1 + 1\n\n        # redraw the screen from backing pixmap\n        rect = QtCore.QRect(x1, y1, width, height)\n        painter.drawPixmap(rect, self.pixmap, rect)", "response": "Draws the background from the pixmap."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndraw the event from the pixmap.", "response": "def paintEvent(self, event):\n        \"\"\"When an area of the window is exposed, we just copy out of the\n        server-side, off-screen pixmap to that area.\n        \"\"\"\n        if not self.pixmap:\n            return\n        rect = event.rect()\n        x1, y1, x2, y2 = rect.getCoords()\n        width = x2 - x1 + 1\n        height = y2 - y1 + 1\n\n        # redraw the screen from backing pixmap\n        painter = QPainter(self)\n        rect = QtCore.QRect(x1, y1, width, height)\n        painter.drawPixmap(rect, self.pixmap, rect)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nusing for generating thumbnails. Does not include overlaid graphics.", "response": "def get_plain_image_as_widget(self):\n        \"\"\"Used for generating thumbnails.  Does not include overlaid\n        graphics.\n        \"\"\"\n        arr = self.getwin_array(order=self.rgb_order)\n        image = self._get_qimage(arr, self.qimg_fmt)\n        return image"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nuses for generating thumbnails. Does not include overlaid graphics.", "response": "def save_plain_image_as_file(self, filepath, format='png', quality=90):\n        \"\"\"Used for generating thumbnails.  Does not include overlaid\n        graphics.\n        \"\"\"\n        qimg = self.get_plain_image_as_widget()\n        qimg.save(filepath, format=format, quality=quality)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\noverriding from QAbstractScrollArea. Resize the viewer widget when the viewport is resized.", "response": "def resizeEvent(self, event):\n        \"\"\"Override from QAbstractScrollArea.\n        Resize the viewer widget when the viewport is resized.\"\"\"\n        vp = self.viewport()\n        rect = vp.geometry()\n        x1, y1, x2, y2 = rect.getCoords()\n        width = x2 - x1 + 1\n        height = y2 - y1 + 1\n\n        self.v_w.resize(width, height)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates and set the scrollbar handles from the pan and zoom positions.", "response": "def _calc_scrollbars(self, viewer, whence):\n        \"\"\"Calculate and set the scrollbar handles from the pan and\n        zoom positions.\n        \"\"\"\n        if self._scrolling or whence > 0:\n            return\n\n        # flag that suppresses a cyclical callback\n        self._adjusting = True\n        try:\n            bd = self.viewer.get_bindings()\n            res = bd.calc_pan_pct(self.viewer, pad=self.pad)\n            if res is None:\n                return\n\n            hsb = self.horizontalScrollBar()\n            vsb = self.verticalScrollBar()\n\n            page_h, page_v = (int(round(res.thm_pct_x * self.range_h)),\n                              int(round(res.thm_pct_y * self.range_v)))\n            hsb.setPageStep(page_h)\n            vsb.setPageStep(page_v)\n\n            upper_h = max(1, self.range_h - page_h)\n            upper_v = max(1, self.range_v - page_v)\n            hsb.setRange(0, upper_h)\n            vsb.setRange(0, upper_v)\n            self.upper_h, self.upper_v = upper_h, upper_v\n\n            val_h, val_v = (int(round(res.pan_pct_x * self.upper_h)),\n                            int(round((1.0 - res.pan_pct_y) * self.upper_v)))\n            hsb.setValue(val_h)\n            vsb.setValue(val_v)\n\n        finally:\n            self._adjusting = False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\noverriding from QAbstractScrollArea. scrollContentsBy dx dy", "response": "def scrollContentsBy(self, dx, dy):\n        \"\"\"Override from QAbstractScrollArea.\n        Called when the scroll bars are adjusted by the user.\n        \"\"\"\n        if self._adjusting:\n            return\n\n        self._scrolling = True\n        try:\n            bd = self.viewer.get_bindings()\n            res = bd.calc_pan_pct(self.viewer, pad=self.pad)\n            if res is None:\n                return\n            pct_x, pct_y = res.pan_pct_x, res.pan_pct_y\n\n            # Only adjust pan setting for axes that have changed\n            if dx != 0:\n                hsb = self.horizontalScrollBar()\n                pos_x = float(hsb.value())\n                pct_x = pos_x / float(self.upper_h)\n            if dy != 0:\n                vsb = self.verticalScrollBar()\n                pos_y = float(vsb.value())\n                # invert Y pct because of orientation of scrollbar\n                pct_y = 1.0 - (pos_y / float(self.upper_v))\n\n            bd = self.viewer.get_bindings()\n            bd.pan_by_pct(self.viewer, pct_x, pct_y, pad=self.pad)\n\n            # This shouldn't be necessary, but seems to be\n            self.viewer.redraw(whence=0)\n\n        finally:\n            self._scrolling = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a catalog of available transforms.", "response": "def get_catalog():\n    \"\"\"Returns a catalog of available transforms.  These are used to\n    build chains for rendering with different back ends.\n    \"\"\"\n    tforms = {}\n    for name, value in list(globals().items()):\n        if name.endswith('Transform'):\n            tforms[name] = value\n\n    return Bunch.Bunch(tforms, caseless=True)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninvoking callbacks on all objects (i.e. layers) from the top to the bottom, returning when the first one returns True. If none returns True, then make the callback on our 'native' layer.", "response": "def make_ui_callback(self, name, *args, **kwdargs):\n        \"\"\"Invoke callbacks on all objects (i.e. layers) from the top to\n        the bottom, returning when the first one returns True.  If none\n        returns True, then make the callback on our 'native' layer.\n        \"\"\"\n        if hasattr(self, 'objects'):\n            # Invoke callbacks on all our layers that have the UI mixin\n            num = len(self.objects) - 1\n            while num >= 0:\n                obj = self.objects[num]\n                if isinstance(obj, UIMixin) and obj.ui_isActive():\n                    res = obj.make_ui_callback(name, *args, **kwdargs)\n                    if res:\n                        return res\n                num -= 1\n\n        if self.ui_active:\n            return super(UIMixin, self).make_callback(name, *args, **kwdargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_callback_children(self, name, *args, **kwdargs):\n        if hasattr(self, 'objects'):\n            # Invoke callbacks on all our layers that have the UI mixin\n            num = len(self.objects) - 1\n            while num >= 0:\n                obj = self.objects[num]\n                if isinstance(obj, Callbacks):\n                    obj.make_callback(name, *args, **kwdargs)\n                num -= 1\n\n        return super(UIMixin, self).make_callback(name, *args, **kwdargs)", "response": "Invoke callbacks on all objects in the top to\n        and bottom to get the first one returns True."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef masktorgb(mask, color='lightgreen', alpha=1.0):\n    mask = np.asarray(mask)\n\n    if mask.ndim != 2:\n        raise ValueError('ndim={0} is not supported'.format(mask.ndim))\n\n    ht, wd = mask.shape\n    r, g, b = colors.lookup_color(color)\n    rgbobj = RGBImage(data_np=np.zeros((ht, wd, 4), dtype=np.uint8))\n\n    rc = rgbobj.get_slice('R')\n    gc = rgbobj.get_slice('G')\n    bc = rgbobj.get_slice('B')\n    ac = rgbobj.get_slice('A')\n    ac[:] = 0  # Transparent background\n\n    rc[mask] = int(r * 255)\n    gc[mask] = int(g * 255)\n    bc[mask] = int(b * 255)\n    ac[mask] = int(alpha * 255)\n\n    # For debugging\n    #rgbobj.save_as_file('ztmp_rgbobj.png')\n\n    return rgbobj", "response": "Convert boolean mask to 2D image object for canvas overlay."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _find_rtd_version():\n    vstr = 'latest'\n    try:\n        import ginga\n        from bs4 import BeautifulSoup\n    except ImportError:\n        return vstr\n\n    # No active doc build before this release, just use latest.\n    if not minversion(ginga, '2.6.0'):\n        return vstr\n\n    # Get RTD download listing.\n    url = 'https://readthedocs.org/projects/ginga/downloads/'\n    with urllib.request.urlopen(url) as r:\n        soup = BeautifulSoup(r, 'html.parser')\n\n    # Compile a list of available HTML doc versions for download.\n    all_rtd_vernums = []\n    for link in soup.find_all('a'):\n        href = link.get('href')\n        if 'htmlzip' not in href:\n            continue\n        s = href.split('/')[-2]\n        if s.startswith('v'):  # Ignore latest and stable\n            all_rtd_vernums.append(s)\n    all_rtd_vernums.sort(reverse=True)\n\n    # Find closest match.\n    ginga_ver = ginga.__version__\n    for rtd_ver in all_rtd_vernums:\n        if ginga_ver > rtd_ver[1:]:  # Ignore \"v\" in comparison\n            break\n        else:\n            vstr = rtd_ver\n\n    return vstr", "response": "Find closest RTD doc version."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _download_rtd_zip(rtd_version=None, **kwargs):\n    # https://github.com/ejeschke/ginga/pull/451#issuecomment-298403134\n    if not toolkit.family.startswith('qt'):\n        raise ValueError('Downloaded documentation not compatible with {} '\n                         'UI toolkit browser'.format(toolkit.family))\n\n    if rtd_version is None:\n        rtd_version = _find_rtd_version()\n\n    data_path = os.path.dirname(\n        _find_pkg_data_path('help.html', package='ginga.doc'))\n    index_html = os.path.join(data_path, 'index.html')\n\n    # There is a previous download of documentation; Do nothing.\n    # There is no check if downloaded version is outdated; The idea is that\n    # this folder would be empty again when installing new version.\n    if os.path.isfile(index_html):\n        return index_html\n\n    url = ('https://readthedocs.org/projects/ginga/downloads/htmlzip/'\n           '{}/'.format(rtd_version))\n    local_path = urllib.request.urlretrieve(url, **kwargs)[0]\n\n    with zipfile.ZipFile(local_path, 'r') as zf:\n        zf.extractall(data_path)\n\n    # RTD makes an undesirable sub-directory, so move everything there\n    # up one level and delete it.\n    subdir = os.path.join(data_path, 'ginga-{}'.format(rtd_version))\n    for s in os.listdir(subdir):\n        src = os.path.join(subdir, s)\n        if os.path.isfile(src):\n            shutil.copy(src, data_path)\n        else:  # directory\n            shutil.copytree(src, os.path.join(data_path, s))\n    shutil.rmtree(subdir)\n\n    if not os.path.isfile(index_html):\n        raise OSError(\n            '{} is missing; Ginga doc download failed'.format(index_html))\n\n    return index_html", "response": "Download and extract HTML ZIP from RTD to installed doc data path."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_doc(logger=None, plugin=None, reporthook=None):\n    from ginga.GingaPlugin import GlobalPlugin, LocalPlugin\n\n    if isinstance(plugin, GlobalPlugin):\n        plugin_page = 'plugins_global'\n        plugin_name = str(plugin)\n    elif isinstance(plugin, LocalPlugin):\n        plugin_page = 'plugins_local'\n        plugin_name = str(plugin)\n    else:\n        plugin_page = None\n        plugin_name = None\n\n    try:\n        index_html = _download_rtd_zip(reporthook=reporthook)\n\n    # Download failed, use online resource\n    except Exception as e:\n        url = 'https://ginga.readthedocs.io/en/latest/'\n\n        if plugin_name is not None:\n            if toolkit.family.startswith('qt'):\n                # This displays plugin docstring.\n                url = None\n            else:\n                # This redirects to online doc.\n                url += 'manual/{}/{}.html'.format(plugin_page, plugin_name)\n\n        if logger is not None:\n            logger.error(str(e))\n\n    # Use local resource\n    else:\n        pfx = 'file:'\n        url = '{}{}'.format(pfx, index_html)\n\n        # https://github.com/rtfd/readthedocs.org/issues/2803\n        if plugin_name is not None:\n            url += '#{}'.format(plugin_name)\n\n    return url", "response": "Get URL to documentation. Attempt download if does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrender the image represented by rgbobj at dst_x dst_y in the pixel space.", "response": "def render_image(self, rgbobj, dst_x, dst_y):\n        \"\"\"Render the image represented by (rgbobj) at dst_x, dst_y\n        in the pixel space.\n        \"\"\"\n        self.logger.debug(\"redraw surface\")\n        if self.surface is None:\n            return\n\n        # Prepare array for Cairo rendering\n        # TODO: is there some high-bit depth option for Cairo?\n        arr = rgbobj.get_array(self.rgb_order, dtype=np.uint8)\n\n        daht, dawd, depth = arr.shape\n        self.logger.debug(\"arr shape is %dx%dx%d\" % (dawd, daht, depth))\n\n        cr = cairo.Context(self.surface)\n        # TODO: is it really necessary to hang on to this context?\n        self.cr = cr\n\n        # fill surface with background color\n        imgwin_wd, imgwin_ht = self.viewer.get_window_size()\n        cr.rectangle(0, 0, imgwin_wd, imgwin_ht)\n        r, g, b = self.viewer.get_bg()\n        cr.set_source_rgba(r, g, b)\n        cr.fill()\n\n        stride = cairo.ImageSurface.format_stride_for_width(cairo.FORMAT_ARGB32,\n                                                            dawd)\n        img_surface = cairo.ImageSurface.create_for_data(arr,\n                                                         cairo.FORMAT_ARGB32,\n                                                         dawd, daht, stride)\n\n        cr.set_source_surface(img_surface, dst_x, dst_y)\n        cr.set_operator(cairo.OPERATOR_SOURCE)\n\n        cr.mask_surface(img_surface, dst_x, dst_y)\n        cr.fill()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild the image list area.", "response": "def build_gui(self, container):\n        \"\"\"Build GUI such that image list area is maximized.\"\"\"\n\n        vbox, sw, orientation = Widgets.get_oriented_box(container)\n\n        captions = (('Channel:', 'label', 'Channel Name', 'combobox',\n                     'Modified only', 'checkbutton'), )\n        w, b = Widgets.build_info(captions, orientation=orientation)\n        self.w.update(b)\n\n        b.channel_name.set_tooltip('Channel for locating images to save')\n        b.channel_name.add_callback('activated', self.select_channel_cb)\n\n        mod_only = self.settings.get('modified_only', True)\n        b.modified_only.set_state(mod_only)\n        b.modified_only.add_callback('activated', lambda *args: self.redo())\n        b.modified_only.set_tooltip(\"Show only locally modified images\")\n\n        container.add_widget(w, stretch=0)\n\n        captions = (('Path:', 'llabel', 'OutDir', 'entry', 'Browse', 'button'),\n                    ('Suffix:', 'llabel', 'Suffix', 'entry'))\n        w, b = Widgets.build_info(captions, orientation=orientation)\n        self.w.update(b)\n\n        b.outdir.set_text(self.outdir)\n        b.outdir.set_tooltip('Output directory')\n        b.outdir.add_callback('activated', lambda w: self.set_outdir())\n\n        b.browse.set_tooltip('Browse for output directory')\n        b.browse.add_callback('activated', lambda w: self.browse_outdir())\n\n        b.suffix.set_text(self.suffix)\n        b.suffix.set_tooltip('Suffix to append to filename')\n        b.suffix.add_callback('activated', lambda w: self.set_suffix())\n\n        container.add_widget(w, stretch=0)\n\n        self.treeview = Widgets.TreeView(auto_expand=True,\n                                         sortable=True,\n                                         selection='multiple',\n                                         use_alt_row_color=True)\n        self.treeview.setup_table(self.columns, 1, 'IMAGE')\n        self.treeview.add_callback('selected', self.toggle_save_cb)\n        container.add_widget(self.treeview, stretch=1)\n\n        captions = (('Status', 'llabel'), )\n        w, b = Widgets.build_info(captions, orientation=orientation)\n        self.w.update(b)\n        b.status.set_text('')\n        b.status.set_tooltip('Status message')\n        container.add_widget(w, stretch=0)\n\n        btns = Widgets.HBox()\n        btns.set_border_width(4)\n        btns.set_spacing(3)\n\n        btn = Widgets.Button('Save')\n        btn.set_tooltip('Save selected image(s)')\n        btn.add_callback('activated', lambda w: self.save_images())\n        btn.set_enabled(False)\n        btns.add_widget(btn, stretch=0)\n        self.w.save = btn\n\n        btn = Widgets.Button('Close')\n        btn.add_callback('activated', lambda w: self.close())\n        btns.add_widget(btn, stretch=0)\n        btn = Widgets.Button(\"Help\")\n        btn.add_callback('activated', lambda w: self.help())\n        btns.add_widget(btn, stretch=0)\n        btns.add_widget(Widgets.Label(''), stretch=1)\n        container.add_widget(btns, stretch=0)\n\n        self.gui_up = True\n\n        # Initialize directory selection dialog\n        self.dirsel = DirectorySelection(self.fv.w.root.get_widget())\n\n        # Generate initial listing\n        self.update_channels()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating listing of images that user can save.", "response": "def redo(self, *args):\n        \"\"\"Generate listing of images that user can save.\"\"\"\n        if not self.gui_up:\n            return\n\n        mod_only = self.w.modified_only.get_state()\n        treedict = Bunch.caselessDict()\n        self.treeview.clear()\n        self.w.status.set_text('')\n\n        channel = self.fv.get_channel(self.chname)\n        if channel is None:\n            return\n\n        # Only list modified images for saving. Scanning Datasrc is enough.\n        if mod_only:\n            all_keys = channel.datasrc.keys(sort='alpha')\n\n        # List all images in the channel.\n        else:\n            all_keys = channel.get_image_names()\n\n        # Extract info for listing and saving\n        for key in all_keys:\n            iminfo = channel.get_image_info(key)\n            path = iminfo.get('path')\n            idx = iminfo.get('idx')\n            t = iminfo.get('time_modified')\n\n            if path is None:  # Special handling for generated buffer, eg mosaic\n                infile = key\n                is_fits = True\n            else:\n                infile = os.path.basename(path)\n                infile_ext = os.path.splitext(path)[1]\n                infile_ext = infile_ext.lower()\n                is_fits = False\n\n                if 'fit' in infile_ext:\n                    is_fits = True\n\n            # Only list FITS files unless it is Ginga generated buffer\n            if not is_fits:\n                continue\n\n            # Only list modified buffers\n            if mod_only and t is None:\n                continue\n\n            # More than one ext modified, append to existing entry\n            if infile in treedict:\n                if t is not None:\n                    treedict[infile].extlist.add(idx)\n                    elist = sorted(treedict[infile].extlist)\n                    treedict[infile].MODEXT = ';'.join(\n                        map(self._format_extname, elist))\n\n            # Add new entry\n            else:\n                if t is None:\n                    s = ''\n                    extlist = set()\n                else:\n                    s = self._format_extname(idx)\n                    extlist = set([idx])\n                treedict[infile] = Bunch.Bunch(\n                    IMAGE=infile, MODEXT=s, extlist=extlist, path=path)\n\n        self.treeview.set_tree(treedict)\n\n        # Resize column widths\n        n_rows = len(treedict)\n        if n_rows == 0:\n            self.w.status.set_text('Nothing available for saving')\n        elif n_rows < self.settings.get('max_rows_for_col_resize', 5000):\n            self.treeview.set_optimal_column_widths()\n            self.logger.debug('Resized columns for {0} row(s)'.format(n_rows))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_channels(self):\n        if not self.gui_up:\n            return\n\n        self.logger.debug(\"channel configuration has changed--updating gui\")\n        try:\n            channel = self.fv.get_channel(self.chname)\n\n        except KeyError:\n            channel = self.fv.get_channel_info()\n\n        if channel is None:\n            raise ValueError('No channel available')\n\n        self.chname = channel.name\n\n        w = self.w.channel_name\n        w.clear()\n\n        self.chnames = list(self.fv.get_channel_names())\n        #self.chnames.sort()\n        for chname in self.chnames:\n            w.append_text(chname)\n\n        # select the channel that is the current one\n        try:\n            i = self.chnames.index(channel.name)\n        except IndexError:\n            i = 0\n        self.w.channel_name.set_index(i)\n\n        # update the image listing\n        self.redo()", "response": "Update the GUI to reflect channels and image listing."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbrowse for output directory.", "response": "def browse_outdir(self):\n        \"\"\"Browse for output directory.\"\"\"\n        self.dirsel.popup(\n            'Select directory', self.w.outdir.set_text, initialdir=self.outdir)\n        self.set_outdir()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_outdir(self):\n        dirname = self.w.outdir.get_text()\n        if os.path.isdir(dirname):\n            self.outdir = dirname\n            self.logger.debug('Output directory set to {0}'.format(self.outdir))\n        else:\n            self.w.outdir.set_text(self.outdir)\n            self.logger.error('{0} is not a directory'.format(dirname))", "response": "Set the output directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites change history to given HDU header.", "response": "def _write_history(self, pfx, hdu, linechar=60, indentchar=2):\n        \"\"\"Write change history to given HDU header.\n        Limit each HISTORY line to given number of characters.\n        Subsequent lines of the same history will be indented.\n        \"\"\"\n        channel = self.fv.get_channel(self.chname)\n        if channel is None:\n            return\n\n        history_plgname = 'ChangeHistory'\n        try:\n            history_obj = self.fv.gpmon.getPlugin(history_plgname)\n        except Exception:\n            self.logger.error(\n                '{0} plugin is not loaded. No HISTORY will be written to '\n                '{1}.'.format(history_plgname, pfx))\n            return\n\n        if channel.name not in history_obj.name_dict:\n            self.logger.error(\n                '{0} channel not found in {1}. No HISTORY will be written to '\n                '{2}.'.format(channel.name, history_plgname, pfx))\n            return\n\n        file_dict = history_obj.name_dict[channel.name]\n        chistory = []\n        ind = ' ' * indentchar\n\n        # NOTE: List comprehension too slow!\n        for key in file_dict:\n            if not key.startswith(pfx):\n                continue\n            for bnch in file_dict[key].values():\n                chistory.append('{0} {1}'.format(bnch.MODIFIED, bnch.DESCRIP))\n\n        # Add each HISTORY prettily into header, sorted by timestamp\n        for s in sorted(chistory):\n            for i in range(0, len(s), linechar):\n                subs = s[i:i + linechar]\n                if i > 0:\n                    subs = ind + subs.lstrip()\n                hdu.header.add_history(subs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _write_header(self, image, hdu):\n        hduhdr = hdu.header\n\n        # Ginga image header object for the given extension only.\n        # Cannot use get_header() because that might also return PRI hdr.\n        ghdr = image.metadata['header']\n\n        for key in ghdr:\n            # Need this to avoid duplication because COMMENT is a weird field\n            if key.upper() == 'COMMENT':\n                continue\n\n            bnch = ghdr.get_card(key)\n\n            # Insert new keyword\n            if key not in hduhdr:\n                hduhdr[key] = (bnch.value, bnch.comment)\n\n            # Update existing keyword\n            elif hduhdr[key] != bnch.value:\n                hduhdr[key] = bnch.value", "response": "Write header from image object to given HDU."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite out mosaic data to a single - extension FITS file.", "response": "def _write_mosaic(self, key, outfile):\n        \"\"\"Write out mosaic data (or any new data generated within Ginga)\n        to single-extension FITS.\n\n        \"\"\"\n        maxsize = self.settings.get('max_mosaic_size', 1e8)  # Default 10k x 10k\n        channel = self.fv.get_channel(self.chname)\n        image = channel.datasrc[key]\n\n        # Prevent writing very large mosaic\n        if (image.width * image.height) > maxsize:\n            s = 'Mosaic too large to be written {0}'.format(image.shape)\n            self.w.status.set_text(s)\n            self.logger.error(s)\n            return\n\n        # Insert mosaic data and header into output HDU\n        hdu = fits.PrimaryHDU(image.get_data())\n        self._write_header(image, hdu)\n\n        # Write history to PRIMARY\n        self._write_history(key, hdu)\n\n        # Write to file\n        if minversion(astropy, '1.3'):\n            hdu.writeto(outfile, overwrite=True)\n        else:\n            hdu.writeto(outfile, clobber=True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _write_mef(self, key, extlist, outfile):\n        channel = self.fv.get_channel(self.chname)\n        with fits.open(outfile, mode='update') as pf:\n            # Process each modified data extension\n            for idx in extlist:\n                k = '{0}[{1}]'.format(key, self._format_extname(idx))\n                image = channel.datasrc[k]\n\n                # Insert data and header into output HDU\n                pf[idx].data = image.get_data()\n                self._write_header(image, pf[idx])\n\n            # Write history to PRIMARY\n            self._write_history(key, pf['PRIMARY'])", "response": "Write out regular multi - extension FITS data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsaving selected images. This uses Astropy FITS package to save the outputs no matter what user chose to load the images.", "response": "def save_images(self):\n        \"\"\"Save selected images.\n\n        This uses Astropy FITS package to save the outputs no matter\n        what user chose to load the images.\n\n        \"\"\"\n        res_dict = self.treeview.get_selected()\n        clobber = self.settings.get('clobber', False)\n        self.treeview.clear_selection()  # Automatically disables Save button\n\n        # If user gives empty string, no suffix.\n        if self.suffix:\n            sfx = '_' + self.suffix\n        else:\n            sfx = ''\n\n        # Also include channel name in suffix. This is useful if user likes to\n        # open the same image in multiple channels.\n        if self.settings.get('include_chname', True):\n            sfx += '_' + self.chname\n\n        # Process each selected file. Each can have multiple edited extensions.\n        for infile in res_dict:\n            f_pfx = os.path.splitext(infile)[0]  # prefix\n            f_ext = '.fits'  # Only FITS supported\n            oname = f_pfx + sfx + f_ext\n            outfile = os.path.join(self.outdir, oname)\n\n            self.w.status.set_text(\n                'Writing out {0} to {1} ...'.format(shorten_name(infile, 10),\n                                                    shorten_name(oname, 10)))\n            self.logger.debug(\n                'Writing out {0} to {1} ...'.format(infile, oname))\n\n            if os.path.exists(outfile) and not clobber:\n                self.logger.error('{0} already exists'.format(outfile))\n                continue\n\n            bnch = res_dict[infile]\n\n            if bnch.path is None or not os.path.isfile(bnch.path):\n                self._write_mosaic(f_pfx, outfile)\n            else:\n                shutil.copyfile(bnch.path, outfile)\n                self._write_mef(f_pfx, bnch.extlist, outfile)\n\n            self.logger.info('{0} written'.format(outfile))\n\n        self.w.status.set_text('Saving done, see log')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef font_info(font_str):\n    vals = font_str.split(';')\n    point_size, style, weight = 8, 'normal', 'normal'\n    family = vals[0]\n    if len(vals) > 1:\n        style = vals[1]\n    if len(vals) > 2:\n        weight = vals[2]\n\n    match = font_regex.match(family)\n    if match:\n        family, point_size = match.groups()\n        point_size = int(point_size)\n\n    return Bunch.Bunch(family=family, point_size=point_size,\n                       style=style, weight=weight)", "response": "Extract font information from a font string such as supplied to the\n    font argument to a widget."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the set of points that are used to draw the object.", "response": "def get_points(self):\n        \"\"\"Get the set of points that is used to draw the object.\n\n        Points are returned in *data* coordinates.\n        \"\"\"\n        if hasattr(self, 'points'):\n            points = self.crdmap.to_data(self.points)\n        else:\n            points = []\n        return points"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_data_points(self, points=None):\n        if points is None:\n            points = self.points\n        points = self.crdmap.to_data(points)\n        return points", "response": "Returns the data points in data coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the data points for the current object.", "response": "def set_data_points(self, points):\n        \"\"\"\n        Input `points` must be in data coordinates, will be converted\n        to the coordinate space of the object and stored.\n        \"\"\"\n        self.points = np.asarray(self.crdmap.data_to(points))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting our object from one coordinate map to another.", "response": "def convert_mapper(self, tomap):\n        \"\"\"\n        Converts our object from using one coordinate map to another.\n\n        NOTE: In some cases this only approximately preserves the\n        equivalent point values when transforming between coordinate\n        spaces.\n        \"\"\"\n        frommap = self.crdmap\n        if frommap == tomap:\n            return\n\n        # mild hack to convert radii on objects that have them\n        if hasattr(self, 'radius'):\n            # get coordinates of a point radius away from center\n            # under current coordmap\n            x0, y0 = frommap.offset_pt((self.x, self.y), (self.radius, 0))\n            pts = frommap.to_data(((self.x, self.y), (x0, y0)))\n            pts = tomap.data_to(pts)\n            self.radius = np.fabs(pts[1][0] - pts[0][0])\n\n        elif hasattr(self, 'xradius'):\n            # similar to above case, but there are 2 radii\n            x0, y0 = frommap.offset_pt((self.x, self.y), (self.xradius,\n                                                          self.yradius))\n            pts = frommap.to_data(((self.x, self.y), (x0, y0)))\n            pts = tomap.data_to(pts)\n            self.xradius = np.fabs(pts[1][0] - pts[0][0])\n            self.yradius = np.fabs(pts[1][1] - pts[0][1])\n\n        data_pts = self.get_data_points()\n\n        # set our map to the new map\n        self.crdmap = tomap\n\n        self.set_data_points(data_pts)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef point_within_radius(self, points, pt, canvas_radius,\n                            scales=(1.0, 1.0)):\n        \"\"\"Points `points` and point `pt` are in data coordinates.\n        Return True for points within the circle defined by\n        a center at point `pt` and within canvas_radius.\n        \"\"\"\n        scale_x, scale_y = scales\n        x, y = pt\n        a_arr, b_arr = np.asarray(points).T\n        dx = np.fabs(x - a_arr) * scale_x\n        dy = np.fabs(y - b_arr) * scale_y\n        new_radius = np.sqrt(dx**2 + dy**2)\n        res = (new_radius <= canvas_radius)\n        return res", "response": "Return True if points point pt are within canvas_radius."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if points point pt is within canvas_radius.", "response": "def within_radius(self, viewer, points, pt, canvas_radius):\n        \"\"\"Points `points` and point `pt` are in data coordinates.\n        Return True for points within the circle defined by\n        a center at point `pt` and within canvas_radius.\n        The distance between points is scaled by the canvas scale.\n        \"\"\"\n        scales = viewer.get_scale_xy()\n        return self.point_within_radius(points, pt, canvas_radius,\n                                        scales)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_pt(self, viewer, points, pt, canvas_radius=None):\n        if canvas_radius is None:\n            canvas_radius = self.cap_radius\n\n        if hasattr(self, 'rot_deg'):\n            # rotate point back to cartesian alignment for test\n            ctr_pt = self.get_center_pt()\n            pt = trcalc.rotate_coord(pt, [-self.rot_deg], ctr_pt)\n\n        res = self.within_radius(viewer, points, pt, canvas_radius)\n        return np.flatnonzero(res)", "response": "Takes an array of points and a target point pt and returns the first index of the point that is within the radius of the target point."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns True if points p_start p_stop are within canvas_radius.", "response": "def within_line(self, viewer, points, p_start, p_stop, canvas_radius):\n        \"\"\"Points `points` and line endpoints `p_start`, `p_stop` are in\n        data coordinates.\n        Return True for points within the line defined by a line from\n        p_start to p_end and within `canvas_radius`.\n        The distance between points is scaled by the viewer's canvas scale.\n        \"\"\"\n        scale_x, scale_y = viewer.get_scale_xy()\n        new_radius = canvas_radius * 1.0 / min(scale_x, scale_y)\n\n        return self.point_within_line(points, p_start, p_stop, new_radius)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_move_scale_rotate_pts(self, viewer):\n        scale = viewer.get_scale_min()\n        ref_x, ref_y = self.get_center_pt()\n        xl, yl, xu, yu = self.get_llur()\n        offset = 8.0 / scale\n        scl_x, scl_y = xl - offset, yl - offset\n        rot_x, rot_y = xu + offset, yu + offset\n        if hasattr(self, 'rot_deg'):\n            # if this is an object with a rotation attribute, pre rotate\n            # the control points in the opposite direction, because they\n            # will be rotated back\n            theta = -self.rot_deg\n            scl_x, scl_y = trcalc.rotate_pt(scl_x, scl_y, theta,\n                                            xoff=ref_x, yoff=ref_y)\n            rot_x, rot_y = trcalc.rotate_pt(rot_x, rot_y, theta,\n                                            xoff=ref_x, yoff=ref_y)\n        move_pt = MovePoint(ref_x, ref_y)\n        scale_pt = ScalePoint(scl_x, scl_y)\n        rotate_pt = RotatePoint(rot_x, rot_y)\n\n        return (move_pt, scale_pt, rotate_pt)", "response": "Returns 3 edit control points for editing this object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_bbox(self, points=None):\n        if points is None:\n            x1, y1, x2, y2 = self.get_llur()\n            return ((x1, y1), (x1, y2), (x2, y2), (x2, y1))\n        else:\n            return trcalc.strip_z(trcalc.get_bounds(points))", "response": "Get bounding box of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rescale_by(self, scale_x, scale_y, detail):\n        self.rescale_by_factors((scale_x, scale_y), detail)", "response": "Rescale the log entry to a given scale."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rotate(self, theta_deg, xoff=0, yoff=0):\n        self.rotate_deg([theta_deg], (xoff, yoff))", "response": "Rotate the current object by angle theta_deg degrees."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if a set of points is contained in another set of points.", "response": "def contains_arr(self, x_arr, y_arr):\n        \"\"\"For backward compatibility.  TO BE DEPRECATED--DO NOT USE.\n        Use contains_pts() instead.\n        \"\"\"\n        pts = np.asarray((x_arr, y_arr)).T\n        return self.contains_pts(pts)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nselects the set of pages that contain the given point.", "response": "def select_contains(self, viewer, x, y):\n        \"\"\"For backward compatibility.  TO BE DEPRECATED--DO NOT USE.\n        Use select_contains_pt() instead.\n        \"\"\"\n        return self.select_contains_pt(viewer, (x, y))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef resize(self, dims):\n        width, height = dims[:2]\n        self.dims = (width, height)\n        self.logger.debug(\"renderer reconfigured to %dx%d\" % (\n            width, height))\n\n        # create PIL surface the size of the window\n        # NOTE: pillow needs an RGB surface in order to draw with alpha\n        # blending, not RGBA\n        self.surface = Image.new('RGB', (width, height), color=0)", "response": "Resize our drawing area to encompass a space defined by the\n        given dimensions."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrender the image represented by rgbobj at dst_x dst_y in the pixel space.", "response": "def render_image(self, rgbobj, dst_x, dst_y):\n        \"\"\"Render the image represented by (rgbobj) at dst_x, dst_y\n        in the pixel space.\n        *** internal method-- do not use ***\n        \"\"\"\n        if self.surface is None:\n            return\n        self.logger.debug(\"redraw surface\")\n\n        # get window contents as a buffer and paste it into the PIL surface\n        # TODO: allow greater bit depths when support is better in PIL\n        rgb_arr = self.viewer.getwin_array(order=self.rgb_order, dtype=np.uint8)\n        p_image = Image.fromarray(rgb_arr)\n\n        if self.surface is None or p_image.size != self.surface.size:\n            # window size must have changed out from underneath us!\n            width, height = self.viewer.get_window_size()\n            self.resize((width, height))\n            if p_image.size != self.surface.size:\n                raise render.RenderError(\"Rendered image does not match window size\")\n\n        self.surface.paste(p_image)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set(self, time_sec, callback_fn, *args, **kwdargs):\n        timer = self.timer()\n        timer.set_callback('expired', callback_fn, *args, **kwdargs)\n        timer.set(time_sec)\n        return timer", "response": "Convenience function to create and set a timer."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_window_size(self, width, height):\n        self._imgwin_wd = int(width)\n        self._imgwin_ht = int(height)\n        self._ctr_x = width // 2\n        self._ctr_y = height // 2\n        self.logger.debug(\"widget resized to %dx%d\" % (width, height))\n\n        self.make_callback('configure', width, height)\n        self.redraw(whence=0)", "response": "Report the size of the window to display the image."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef configure(self, width, height):\n        self._imgwin_set = True\n        self.set_window_size(width, height)", "response": "Configure the window size."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the desired size of the image window.", "response": "def set_desired_size(self, width, height):\n        \"\"\"See :meth:`set_window_size`.\"\"\"\n        self._desired_size = (width, height)\n        if not self._imgwin_set:\n            self.set_window_size(width, height)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_renderer(self, renderer):\n        self.renderer = renderer\n        width, height = self.get_window_size()\n        if width > 0 and height > 0:\n            renderer.resize((width, height))", "response": "Set and initialize the renderer used by this instance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_canvas(self, canvas, private_canvas=None):\n        self.canvas = canvas\n        canvas.initialize(None, self, self.logger)\n        canvas.add_callback('modified', self.canvas_changed_cb)\n        canvas.set_surface(self)\n        canvas.ui_set_active(True)\n\n        self._imgobj = None\n\n        # private canvas set?\n        if private_canvas is not None:\n            self.private_canvas = private_canvas\n\n            if private_canvas != canvas:\n                private_canvas.set_surface(self)\n                private_canvas.ui_set_active(True)\n                private_canvas.add_callback('modified', self.canvas_changed_cb)\n\n        # sanity check that we have a private canvas, and if not,\n        # set it to the \"advertised\" canvas\n        if self.private_canvas is None:\n            self.private_canvas = canvas\n\n        # make sure private canvas has our non-private one added\n        if (self.private_canvas != self.canvas) and (\n                not self.private_canvas.has_object(canvas)):\n            self.private_canvas.add(canvas)\n\n        self.initialize_private_canvas(self.private_canvas)", "response": "Sets the canvas object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef initialize_private_canvas(self, private_canvas):\n        if self.t_.get('show_pan_position', False):\n            self.show_pan_mark(True)\n\n        if self.t_.get('show_focus_indicator', False):\n            self.show_focus_indicator(True)", "response": "Initialize the private canvas used by this instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef scale_and_shift_cmap(self, scale_pct, shift_pct):\n        rgbmap = self.get_rgbmap()\n        rgbmap.scale_and_shift(scale_pct, shift_pct)", "response": "Stretch and or shrink the color map."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the RGB map object used by this instance.", "response": "def set_rgbmap(self, rgbmap):\n        \"\"\"Set RGB map object used by this instance.\n        It controls how the values in the image are mapped to color.\n\n        Parameters\n        ----------\n        rgbmap : `~ginga.RGBMap.RGBMapper`\n            RGB map.\n\n        \"\"\"\n        self.rgbmap = rgbmap\n        t_ = rgbmap.get_settings()\n        t_.share_settings(self.t_, keylist=rgbmap.settings_keys)\n        rgbmap.add_callback('changed', self.rgbmap_cb)\n        self.redraw(whence=2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the image currently being displayed.", "response": "def get_image(self):\n        \"\"\"Get the image currently being displayed.\n\n        Returns\n        -------\n        image : `~ginga.AstroImage.AstroImage` or `~ginga.RGBImage.RGBImage`\n            Image object.\n\n        \"\"\"\n        if self._imgobj is not None:\n            # quick optomization\n            return self._imgobj.get_image()\n\n        canvas_img = self.get_canvas_image()\n        return canvas_img.get_image()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_canvas_image(self):\n        if self._imgobj is not None:\n            return self._imgobj\n\n        try:\n            # See if there is an image on the canvas\n            self._imgobj = self.canvas.get_object_by_tag(self._canvas_img_tag)\n            self._imgobj.add_callback('image-set', self._image_set_cb)\n\n        except KeyError:\n            # add a normalized image item to this canvas if we don't\n            # have one already--then just keep reusing it\n            NormImage = self.canvas.getDrawClass('normimage')\n            interp = self.t_.get('interpolation', 'basic')\n\n            # previous choice might not be available if preferences\n            # were saved when opencv was being used (and not used now)\n            # --if so, default to \"basic\"\n            if interp not in trcalc.interpolation_methods:\n                interp = 'basic'\n\n            self._imgobj = NormImage(0, 0, None, alpha=1.0,\n                                     interpolation=interp)\n            self._imgobj.add_callback('image-set', self._image_set_cb)\n\n        return self._imgobj", "response": "Get canvas image object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset an image to be displayed.", "response": "def set_image(self, image, add_to_canvas=True):\n        \"\"\"Set an image to be displayed.\n\n        If there is no error, the ``'image-unset'`` and ``'image-set'``\n        callbacks will be invoked.\n\n        Parameters\n        ----------\n        image : `~ginga.AstroImage.AstroImage` or `~ginga.RGBImage.RGBImage`\n            Image object.\n\n        add_to_canvas : bool\n            Add image to canvas.\n\n        \"\"\"\n        if not isinstance(image, BaseImage.BaseImage):\n            raise ValueError(\"Wrong type of object to load: %s\" % (\n                str(type(image))))\n\n        canvas_img = self.get_canvas_image()\n\n        old_image = canvas_img.get_image()\n        self.make_callback('image-unset', old_image)\n\n        with self.suppress_redraw:\n\n            # this line should force the callback of _image_set_cb()\n            canvas_img.set_image(image)\n\n            if add_to_canvas:\n                try:\n                    self.canvas.get_object_by_tag(self._canvas_img_tag)\n\n                except KeyError:\n                    self.canvas.add(canvas_img, tag=self._canvas_img_tag)\n                    #self.logger.debug(\"adding image to canvas %s\" % self.canvas)\n\n                # move image to bottom of layers\n                self.canvas.lower_object(canvas_img)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\napply a profile to the viewer.", "response": "def apply_profile_or_settings(self, image):\n        \"\"\"Apply a profile to the viewer.\n\n        Parameters\n        ----------\n        image : `~ginga.AstroImage.AstroImage` or `~ginga.RGBImage.RGBImage`\n            Image object.\n\n        This function is used to initialize the viewer when a new image\n        is loaded.  Either the embedded profile settings or the default\n        settings are applied as specified in the channel preferences.\n        \"\"\"\n        profile = image.get('profile', None)\n        keylist = []\n        with self.suppress_redraw:\n            if profile is not None:\n                if self.t_['profile_use_transform'] and 'flip_x' in profile:\n                    keylist.extend(['flip_x', 'flip_y', 'swap_xy'])\n\n                if self.t_['profile_use_scale'] and 'scale' in profile:\n                    keylist.extend(['scale'])\n\n                if self.t_['profile_use_pan'] and 'pan' in profile:\n                    keylist.extend(['pan'])\n\n                if self.t_['profile_use_rotation'] and 'rot_deg' in profile:\n                    keylist.extend(['rot_deg'])\n\n                if self.t_['profile_use_cuts'] and 'cuts' in profile:\n                    keylist.extend(['cuts'])\n\n                if self.t_['profile_use_color_map'] and 'color_map' in profile:\n                    keylist.extend(['color_algorithm', 'color_hashsize',\n                                    'color_map', 'intensity_map',\n                                    'color_array', 'shift_array'])\n\n                self.apply_profile(profile, keylist=keylist)\n\n            # proceed with initialization that is not in the profile\n            # initialize transforms\n            if self.t_['auto_orient'] and 'flip_x' not in keylist:\n                self.logger.debug(\n                    \"auto orient (%s)\" % (self.t_['auto_orient']))\n                self.auto_orient()\n\n            # initialize scale\n            if self.t_['autozoom'] != 'off' and 'scale' not in keylist:\n                self.logger.debug(\"auto zoom (%s)\" % (self.t_['autozoom']))\n                self.zoom_fit(no_reset=True)\n\n            # initialize pan position\n            # NOTE: False a possible value from historical use\n            if (self.t_['autocenter'] not in ('off', False) and\n                'pan' not in keylist):\n                self.logger.debug(\n                    \"auto center (%s)\" % (self.t_['autocenter']))\n                self.center_image(no_reset=True)\n\n            # initialize cuts\n            if self.t_['autocuts'] != 'off' and 'cuts' not in keylist:\n                self.logger.debug(\"auto cuts (%s)\" % (self.t_['autocuts']))\n                self.auto_levels()\n\n            # save the profile in the image\n            if self.use_image_profile:\n                self.checkpoint_profile()\n\n            self.redraw(whence=0)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\napply a profile to the viewer.", "response": "def apply_profile(self, profile, keylist=None):\n        \"\"\"Apply a profile to the viewer.\n\n        Parameters\n        ----------\n        profile : `~ginga.misc.Settings.SettingGroup`\n\n        This function is used to initialize the viewer to a known state.\n        The keylist, if given, will limit the items to be transferred\n        from the profile to viewer settings, otherwise all items are\n        copied.\n        \"\"\"\n        with self.suppress_redraw:\n            profile.copy_settings(self.t_, keylist=keylist,\n                                  callback=True)\n            self.redraw(whence=0)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_profile(self, **params):\n        image = self.get_image()\n        if (image is None):\n            return\n\n        profile = image.get('profile', None)\n        if profile is None:\n            # If image has no profile then create one\n            profile = Settings.SettingGroup()\n            image.set(profile=profile)\n\n        self.logger.debug(\"saving to image profile: params=%s\" % (\n            str(params)))\n        profile.set(**params)\n        return profile", "response": "Save the given parameters into the profile settings."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets an image to be displayed by providing raw data.", "response": "def set_data(self, data, metadata=None):\n        \"\"\"Set an image to be displayed by providing raw data.\n\n        This is a convenience method for first constructing an image\n        with `~ginga.AstroImage.AstroImage` and then calling :meth:`set_image`.\n\n        Parameters\n        ----------\n        data : ndarray\n            This should be at least a 2D Numpy array.\n\n        metadata : dict or `None`\n            Image metadata mapping keywords to their respective values.\n\n        \"\"\"\n        image = AstroImage.AstroImage(data, metadata=metadata,\n                                      logger=self.logger)\n        self.set_image(image)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nclearing the displayed image.", "response": "def clear(self):\n        \"\"\"Clear the displayed image.\"\"\"\n        self._imgobj = None\n        try:\n            # See if there is an image on the canvas\n            self.canvas.delete_object_by_tag(self._canvas_img_tag)\n            self.redraw()\n        except KeyError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nredrawing the canvas. Parameters ---------- whence See :meth:`get_rgb_object`.", "response": "def redraw(self, whence=0):\n        \"\"\"Redraw the canvas.\n\n        Parameters\n        ----------\n        whence\n            See :meth:`get_rgb_object`.\n\n        \"\"\"\n        with self._defer_lock:\n            whence = min(self._defer_whence, whence)\n\n            if not self.defer_redraw:\n                if self._hold_redraw_cnt == 0:\n                    self._defer_whence = self._defer_whence_reset\n                    self.redraw_now(whence=whence)\n                else:\n                    self._defer_whence = whence\n                return\n\n            elapsed = time.time() - self.time_last_redraw\n\n            # If there is no redraw scheduled, or we are overdue for one:\n            if (not self._defer_flag) or (elapsed > self.defer_lagtime):\n                # If more time than defer_lagtime has passed since the\n                # last redraw then just do the redraw immediately\n                if elapsed > self.defer_lagtime:\n                    if self._hold_redraw_cnt > 0:\n                        #self._defer_flag = True\n                        self._defer_whence = whence\n                        return\n\n                    self._defer_whence = self._defer_whence_reset\n                    self.logger.debug(\"lagtime expired--forced redraw\")\n                    self.redraw_now(whence=whence)\n                    return\n\n                # Indicate that a redraw is necessary and record whence\n                self._defer_flag = True\n                self._defer_whence = whence\n\n                # schedule a redraw by the end of the defer_lagtime\n                secs = self.defer_lagtime - elapsed\n                self.logger.debug(\"defer redraw (whence=%.2f) in %.f sec\" % (\n                    whence, secs))\n                self.reschedule_redraw(secs)\n\n            else:\n                # A redraw is already scheduled.  Just record whence.\n                self._defer_whence = whence\n                self.logger.debug(\"update whence=%.2f\" % (whence))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef canvas_changed_cb(self, canvas, whence):\n        self.logger.debug(\"root canvas changed, whence=%d\" % (whence))\n\n        # special check for whether image changed out from under us in\n        # a shared canvas scenario\n        try:\n            # See if there is an image on the canvas\n            canvas_img = self.canvas.get_object_by_tag(self._canvas_img_tag)\n            if self._imgobj is not canvas_img:\n                self._imgobj = canvas_img\n                self._imgobj.add_callback('image-set', self._image_set_cb)\n\n                self._image_set_cb(canvas_img, canvas_img.get_image())\n\n        except KeyError:\n            self._imgobj = None\n\n        self.redraw(whence=whence)", "response": "Handle callback for when canvas has changed."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delayed_redraw(self):\n\n        # This is the optimized redraw method\n        with self._defer_lock:\n            # pick up the lowest necessary level of redrawing\n            whence = self._defer_whence\n            self._defer_whence = self._defer_whence_reset\n            flag = self._defer_flag\n            self._defer_flag = False\n\n        if flag:\n            # If a redraw was scheduled, do it now\n            self.redraw_now(whence=whence)", "response": "Handle delayed redrawing of the canvas."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the lag time for redrawing the canvas.", "response": "def set_redraw_lag(self, lag_sec):\n        \"\"\"Set lag time for redrawing the canvas.\n\n        Parameters\n        ----------\n        lag_sec : float\n            Number of seconds to wait.\n\n        \"\"\"\n        self.defer_redraw = (lag_sec > 0.0)\n        if self.defer_redraw:\n            self.defer_lagtime = lag_sec"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_refresh_rate(self, fps):\n        self.rf_fps = fps\n        self.rf_rate = 1.0 / self.rf_fps\n        #self.set_redraw_lag(self.rf_rate)\n        self.logger.info(\"set a refresh rate of %.2f fps\" % (self.rf_fps))", "response": "Set the refresh rate for redrawing the canvas at a timed interval."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstarts redrawing the canvas at the previously set timed interval.", "response": "def start_refresh(self):\n        \"\"\"Start redrawing the canvas at the previously set timed interval.\n        \"\"\"\n        self.logger.debug(\"starting timed refresh interval\")\n        self.rf_flags['done'] = False\n        self.rf_draw_count = 0\n        self.rf_timer_count = 0\n        self.rf_late_count = 0\n        self.rf_late_total = 0.0\n        self.rf_early_count = 0\n        self.rf_early_total = 0.0\n        self.rf_delta_total = 0.0\n        self.rf_skip_total = 0.0\n        self.rf_start_time = time.time()\n        self.rf_deadline = self.rf_start_time\n        self.refresh_timer_cb(self.rf_timer, self.rf_flags)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstop redrawing the canvas at the previously set timed interval.", "response": "def stop_refresh(self):\n        \"\"\"Stop redrawing the canvas at the previously set timed interval.\n        \"\"\"\n        self.logger.debug(\"stopping timed refresh\")\n        self.rf_flags['done'] = True\n        self.rf_timer.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_refresh_stats(self):\n        if self.rf_draw_count == 0:\n            fps = 0.0\n        else:\n            interval = time.time() - self.rf_start_time\n            fps = self.rf_draw_count / interval\n\n        jitter = self.rf_delta_total / max(1, self.rf_timer_count)\n\n        late_avg = self.rf_late_total / max(1, self.rf_late_count)\n        late_pct = self.rf_late_count / max(1.0, float(self.rf_timer_count)) * 100\n\n        early_avg = self.rf_early_total / max(1, self.rf_early_count)\n        early_pct = self.rf_early_count / max(1.0, float(self.rf_timer_count)) * 100\n\n        balance = self.rf_late_total - self.rf_early_total\n\n        stats = dict(fps=fps, jitter=jitter,\n                     early_avg=early_avg, early_pct=early_pct,\n                     late_avg=late_avg, late_pct=late_pct,\n                     balance=balance)\n        return stats", "response": "Return the measured statistics for timed refresh intervals."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef refresh_timer_cb(self, timer, flags):\n        # this is the timer call back, from the GUI thread\n        start_time = time.time()\n\n        if flags.get('done', False):\n            return\n\n        # calculate next deadline\n        deadline = self.rf_deadline\n        self.rf_deadline += self.rf_rate\n\n        self.rf_timer_count += 1\n        delta = abs(start_time - deadline)\n        self.rf_delta_total += delta\n        adjust = 0.0\n\n        if start_time > deadline:\n            # we are late\n            self.rf_late_total += delta\n            self.rf_late_count += 1\n            late_avg = self.rf_late_total / self.rf_late_count\n            adjust = - (late_avg / 2.0)\n            self.rf_skip_total += delta\n            if self.rf_skip_total < self.rf_rate:\n                self.rf_draw_count += 1\n                # TODO: can we optimize whence?\n                self.redraw_now(whence=0)\n            else:\n                # <-- we are behind by amount of time equal to one frame.\n                # skip a redraw and attempt to catch up some time\n                self.rf_skip_total = 0\n        else:\n            if start_time < deadline:\n                # we are early\n                self.rf_early_total += delta\n                self.rf_early_count += 1\n                self.rf_skip_total = max(0.0, self.rf_skip_total - delta)\n                early_avg = self.rf_early_total / self.rf_early_count\n                adjust = early_avg / 4.0\n\n            self.rf_draw_count += 1\n            # TODO: can we optimize whence?\n            self.redraw_now(whence=0)\n\n        delay = max(0.0, self.rf_deadline - time.time() + adjust)\n        timer.start(delay)", "response": "This callback is called by the GUI - based timer thread when the timer expires. This callback will normally only be called internally."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef redraw_now(self, whence=0):\n        try:\n            time_start = time.time()\n            self.redraw_data(whence=whence)\n\n            # finally update the window drawable from the offscreen surface\n            self.update_image()\n\n            time_done = time.time()\n            time_delta = time_start - self.time_last_redraw\n            time_elapsed = time_done - time_start\n            self.time_last_redraw = time_done\n            self.logger.debug(\n                \"widget '%s' redraw (whence=%d) delta=%.4f elapsed=%.4f sec\" % (\n                    self.name, whence, time_delta, time_elapsed))\n\n        except Exception as e:\n            self.logger.error(\"Error redrawing image: %s\" % (str(e)))\n            try:\n                # log traceback, if possible\n                (type, value, tb) = sys.exc_info()\n                tb_str = \"\".join(traceback.format_tb(tb))\n                self.logger.error(\"Traceback:\\n%s\" % (tb_str))\n            except Exception:\n                tb_str = \"Traceback information unavailable.\"\n                self.logger.error(tb_str)", "response": "Redraw the displayed image."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef redraw_data(self, whence=0):\n        if not self._imgwin_set:\n            # window has not been realized yet\n            return\n\n        if not self._self_scaling:\n            rgbobj = self.get_rgb_object(whence=whence)\n            self.renderer.render_image(rgbobj, self._dst_x, self._dst_y)\n\n        self.private_canvas.draw(self)\n\n        self.make_callback('redraw', whence)\n\n        if whence < 2:\n            self.check_cursor_location()", "response": "Render image from RGB map and redraw private canvas."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_cursor_location(self):\n        # Check whether cursor data position has changed relative\n        # to previous value\n        data_x, data_y = self.get_data_xy(self.last_win_x,\n                                          self.last_win_y)\n        if (data_x != self.last_data_x or\n            data_y != self.last_data_y):\n            self.last_data_x, self.last_data_y = data_x, data_y\n            self.logger.debug(\"cursor location changed %.4f,%.4f => %.4f,%.4f\" % (\n                self.last_data_x, self.last_data_y, data_x, data_y))\n\n            # we make this call compatible with the motion callback\n            # for now, but there is no concept of a button here\n            button = 0\n\n            self.make_ui_callback('cursor-changed', button, data_x, data_y)\n\n        return data_x, data_y", "response": "Check whether the data location of the last known position has changed. If so issue a callback."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getwin_array(self, order='RGB', alpha=1.0, dtype=None):\n        order = order.upper()\n        depth = len(order)\n\n        if dtype is None:\n            rgbmap = self.get_rgbmap()\n            dtype = rgbmap.dtype\n\n        # Prepare data array for rendering\n        data = self._rgbobj.get_array(order, dtype=dtype)\n\n        # NOTE [A]\n        height, width, depth = data.shape\n\n        imgwin_wd, imgwin_ht = self.get_window_size()\n\n        # create RGBA image array with the background color for output\n        r, g, b = self.img_bg\n        outarr = trcalc.make_filled_array((imgwin_ht, imgwin_wd, len(order)),\n                                          dtype, order, r, g, b, alpha)\n\n        # overlay our data\n        trcalc.overlay_image(outarr, (self._dst_x, self._dst_y),\n                             data, dst_order=order, src_order=order,\n                             flipy=False, fill=False, copy=False)\n\n        return outarr", "response": "Get Numpy array for display window."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getwin_buffer(self, order='RGB', alpha=1.0, dtype=None):\n        outarr = self.getwin_array(order=order, alpha=alpha, dtype=dtype)\n\n        if not hasattr(outarr, 'tobytes'):\n            # older versions of numpy\n            return outarr.tostring(order='C')\n        return outarr.tobytes(order='C')", "response": "Same as getwin_array but with the output array converted\n            to C - order Python bytes."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the approximate bounding box of the displayed image.", "response": "def get_datarect(self):\n        \"\"\"Get the approximate bounding box of the displayed image.\n\n        Returns\n        -------\n        rect : tuple\n            Bounding box in data coordinates in the form of\n            ``(x1, y1, x2, y2)``.\n\n        \"\"\"\n        x1, y1, x2, y2 = self._org_x1, self._org_y1, self._org_x2, self._org_y2\n        return (x1, y1, x2, y2)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_limits(self, coord='data'):\n        limits = self.t_['limits']\n\n        if limits is None:\n            # No user defined limits.  If there is an image loaded\n            # use its dimensions as the limits\n            image = self.get_image()\n            if image is not None:\n                wd, ht = image.get_size()\n                limits = ((self.data_off, self.data_off),\n                          (float(wd - 1 + self.data_off),\n                           float(ht - 1 + self.data_off)))\n\n            else:\n                # Calculate limits based on plotted points, if any\n                canvas = self.get_canvas()\n                pts = canvas.get_points()\n                if len(pts) > 0:\n                    limits = trcalc.get_bounds(pts)\n                else:\n                    # No limits found, go to default\n                    limits = ((0.0, 0.0), (0.0, 0.0))\n\n        # convert to desired coordinates\n        crdmap = self.get_coordmap(coord)\n        limits = crdmap.data_to(limits)\n\n        return limits", "response": "Get the bounding box of the viewer extents."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the bounding box of the viewer extents.", "response": "def set_limits(self, limits, coord='data'):\n        \"\"\"Set the bounding box of the viewer extents.\n\n        Parameters\n        ----------\n        limits : tuple or None\n            A tuple setting the extents of the viewer in the form of\n            ``(ll_pt, ur_pt)``.\n        \"\"\"\n        if limits is not None:\n            if len(limits) != 2:\n                raise ValueError(\"limits takes a 2 tuple, or None\")\n\n            # convert to data coordinates\n            crdmap = self.get_coordmap(coord)\n            limits = crdmap.to_data(limits)\n\n        self.t_.set(limits=limits)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_rgb_object(self, whence=0):\n        time_start = t2 = t3 = time.time()\n        win_wd, win_ht = self.get_window_size()\n        order = self.get_rgb_order()\n\n        if (whence <= 0.0) or (self._rgbarr is None):\n            # calculate dimensions of window RGB backing image\n            pan_x, pan_y = self.get_pan(coord='data')[:2]\n            scale_x, scale_y = self.get_scale_xy()\n            wd, ht = self._calc_bg_dimensions(scale_x, scale_y,\n                                              pan_x, pan_y,\n                                              win_wd, win_ht)\n\n            # create backing image\n            depth = len(order)\n            rgbmap = self.get_rgbmap()\n            # make backing image with the background color\n            r, g, b = self.img_bg\n            rgba = trcalc.make_filled_array((ht, wd, depth), rgbmap.dtype,\n                                            order, r, g, b, 1.0)\n\n            self._rgbarr = rgba\n            t2 = time.time()\n\n        if (whence <= 2.0) or (self._rgbarr2 is None):\n            # Apply any RGB image overlays\n            self._rgbarr2 = np.copy(self._rgbarr)\n            self.overlay_images(self.private_canvas, self._rgbarr2,\n                                whence=whence)\n\n            # convert to output ICC profile, if one is specified\n            output_profile = self.t_.get('icc_output_profile', None)\n            working_profile = rgb_cms.working_profile\n            if (working_profile is not None) and (output_profile is not None):\n                self.convert_via_profile(self._rgbarr2, order,\n                                         working_profile, output_profile)\n            t3 = time.time()\n\n        if (whence <= 2.5) or (self._rgbobj is None):\n            rotimg = self._rgbarr2\n\n            # Apply any viewing transformations or rotations\n            # if not applied earlier\n            rotimg = self.apply_transforms(rotimg,\n                                           self.t_['rot_deg'])\n            rotimg = np.ascontiguousarray(rotimg)\n\n            self._rgbobj = RGBMap.RGBPlanes(rotimg, order)\n\n        time_end = time.time()\n        ## self.logger.debug(\"times: total=%.4f\" % (\n        ##     (time_end - time_start)))\n        self.logger.debug(\"times: t1=%.4f t2=%.4f t3=%.4f total=%.4f\" % (\n            t2 - time_start, t3 - t2, time_end - t3,\n            (time_end - time_start)))\n\n        return self._rgbobj", "response": "Create and return the RGB object for the current data entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _calc_bg_dimensions(self, scale_x, scale_y,\n                            pan_x, pan_y, win_wd, win_ht):\n        \"\"\"\n        Parameters\n        ----------\n        scale_x, scale_y : float\n            desired scale of viewer in each axis.\n\n        pan_x, pan_y : float\n            pan position in data coordinates.\n\n        win_wd, win_ht : int\n            window dimensions in pixels\n        \"\"\"\n\n        # Sanity check on the scale\n        sx = float(win_wd) / scale_x\n        sy = float(win_ht) / scale_y\n        if (sx < 1.0) or (sy < 1.0):\n            #self.logger.warning(\"new scale would exceed max/min; scale unchanged\")\n            raise ImageViewError(\"new scale would exceed pixel max; scale unchanged\")\n\n        # It is necessary to store these so that the get_pan_rect()\n        # (below) calculation can proceed\n        self._org_x, self._org_y = pan_x - self.data_off, pan_y - self.data_off\n        self._org_scale_x, self._org_scale_y = scale_x, scale_y\n        self._org_scale_z = (scale_x + scale_y) / 2.0\n\n        # calc minimum size of pixel image we will generate\n        # necessary to fit the window in the desired size\n\n        # get the data points in the four corners\n        a, b = trcalc.get_bounds(self.get_pan_rect())\n\n        # determine bounding box\n        a1, b1 = a[:2]\n        a2, b2 = b[:2]\n\n        # constrain to integer indexes\n        x1, y1, x2, y2 = int(a1), int(b1), int(np.round(a2)), int(np.round(b2))\n        x1 = max(0, x1)\n        y1 = max(0, y1)\n\n        self.logger.debug(\"approx area covered is %dx%d to %dx%d\" % (\n            x1, y1, x2, y2))\n\n        self._org_x1 = x1\n        self._org_y1 = y1\n        self._org_x2 = x2\n        self._org_y2 = y2\n\n        # Make a square from the scaled cutout, with room to rotate\n        slop = 20\n        side = int(math.sqrt(win_wd**2 + win_ht**2) + slop)\n        wd = ht = side\n\n        # Find center of new array\n        ncx, ncy = wd // 2, ht // 2\n        self._org_xoff, self._org_yoff = ncx, ncy\n\n        return (wd, ht)", "response": "Calculate the background dimensions of the image."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying transforms to the given data.", "response": "def apply_transforms(self, data, rot_deg):\n        \"\"\"Apply transformations to the given data.\n        These include flip/swap X/Y, invert Y, and rotation.\n\n        Parameters\n        ----------\n        data : ndarray\n            Data to be transformed.\n\n        rot_deg : float\n            Rotate the data by the given degrees.\n\n        Returns\n        -------\n        data : ndarray\n            Transformed data.\n\n        \"\"\"\n        start_time = time.time()\n\n        wd, ht = self.get_dims(data)\n        xoff, yoff = self._org_xoff, self._org_yoff\n\n        # Do transforms as necessary\n        flip_x, flip_y = self.t_['flip_x'], self.t_['flip_y']\n        swap_xy = self.t_['swap_xy']\n\n        data = trcalc.transform(data, flip_x=flip_x, flip_y=flip_y,\n                                swap_xy=swap_xy)\n        if flip_y:\n            yoff = ht - yoff\n        if flip_x:\n            xoff = wd - xoff\n        if swap_xy:\n            xoff, yoff = yoff, xoff\n\n        split_time = time.time()\n        self.logger.debug(\"reshape time %.3f sec\" % (\n            split_time - start_time))\n\n        # Rotate the image as necessary\n        if rot_deg != 0:\n            # This is the slowest part of the rendering--install the OpenCv or pyopencl\n            # packages to speed it up\n            data = np.ascontiguousarray(data)\n            data = trcalc.rotate_clip(data, -rot_deg, out=data,\n                                      logger=self.logger)\n\n        split2_time = time.time()\n\n        # apply other transforms\n        if self._invert_y:\n            # Flip Y for natural natural Y-axis inversion between FITS coords\n            # and screen coords\n            data = np.flipud(data)\n\n        self.logger.debug(\"rotate time %.3f sec, total reshape %.3f sec\" % (\n            split2_time - split_time, split2_time - start_time))\n\n        # dimensions may have changed in transformations\n        wd, ht = self.get_dims(data)\n\n        ctr_x, ctr_y = self._ctr_x, self._ctr_y\n        dst_x, dst_y = ctr_x - xoff, ctr_y - (ht - yoff)\n        self._dst_x, self._dst_y = dst_x, dst_y\n        self.logger.debug(\"ctr=%d,%d off=%d,%d dst=%d,%d cutout=%dx%d\" % (\n            ctr_x, ctr_y, xoff, yoff, dst_x, dst_y, wd, ht))\n\n        win_wd, win_ht = self.get_window_size()\n        self.logger.debug(\"win=%d,%d coverage=%d,%d\" % (\n            win_wd, win_ht, dst_x + wd, dst_y + ht))\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\noverlay images from any canvas image objects.", "response": "def overlay_images(self, canvas, data, whence=0.0):\n        \"\"\"Overlay data from any canvas image objects.\n\n        Parameters\n        ----------\n        canvas : `~ginga.canvas.types.layer.DrawingCanvas`\n            Canvas containing possible images to overlay.\n\n        data : ndarray\n            Output array on which to overlay image data.\n\n        whence\n             See :meth:`get_rgb_object`.\n\n        \"\"\"\n        #if not canvas.is_compound():\n        if not hasattr(canvas, 'objects'):\n            return\n\n        for obj in canvas.get_objects():\n            if hasattr(obj, 'draw_image'):\n                obj.draw_image(self, data, whence=whence)\n            elif obj.is_compound() and (obj != canvas):\n                self.overlay_images(obj, data, whence=whence)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting the given RGB image data from the working ICC profile into the output profile in - place.", "response": "def convert_via_profile(self, data_np, order, inprof_name, outprof_name):\n        \"\"\"Convert the given RGB data from the working ICC profile\n        to the output profile in-place.\n\n        Parameters\n        ----------\n        data_np : ndarray\n            RGB image data to be displayed.\n\n        order : str\n            Order of channels in the data (e.g. \"BGRA\").\n\n        inprof_name, outprof_name : str\n            ICC profile names (see :func:`ginga.util.rgb_cms.get_profiles`).\n\n        \"\"\"\n        # get rest of necessary conversion parameters\n        to_intent = self.t_.get('icc_output_intent', 'perceptual')\n        proofprof_name = self.t_.get('icc_proof_profile', None)\n        proof_intent = self.t_.get('icc_proof_intent', 'perceptual')\n        use_black_pt = self.t_.get('icc_black_point_compensation', False)\n\n        try:\n            rgbobj = RGBMap.RGBPlanes(data_np, order)\n            arr_np = rgbobj.get_array('RGB')\n\n            arr = rgb_cms.convert_profile_fromto(arr_np, inprof_name, outprof_name,\n                                                 to_intent=to_intent,\n                                                 proof_name=proofprof_name,\n                                                 proof_intent=proof_intent,\n                                                 use_black_pt=use_black_pt,\n                                                 logger=self.logger)\n            ri, gi, bi = rgbobj.get_order_indexes('RGB')\n\n            out = data_np\n            out[..., ri] = arr[..., 0]\n            out[..., gi] = arr[..., 1]\n            out[..., bi] = arr[..., 2]\n\n            self.logger.debug(\"Converted from '%s' to '%s' profile\" % (\n                inprof_name, outprof_name))\n\n        except Exception as e:\n            self.logger.warning(\"Error converting output from working profile: %s\" % (str(e)))\n            # TODO: maybe should have a traceback here\n            self.logger.info(\"Output left unprofiled\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the closest coordinates in the data array to those reported on the window.", "response": "def get_data_xy(self, win_x, win_y, center=None):\n        \"\"\"Get the closest coordinates in the data array to those\n        reported on the window.\n\n        Parameters\n        ----------\n        win_x, win_y : float or ndarray\n            Window coordinates.\n\n        center : bool\n            If `True`, then the coordinates are mapped such that the\n            pixel is centered on the square when the image is zoomed in past\n            1X. This is the specification of the FITS image standard,\n            that the pixel is centered on the integer row/column.\n\n        Returns\n        -------\n        coord : tuple\n            Data coordinates in the form of ``(x, y)``.\n\n        \"\"\"\n        if center is not None:\n            self.logger.warning(\"`center` keyword is ignored and will be deprecated\")\n\n        arr_pts = np.asarray((win_x, win_y)).T\n        return self.tform['data_to_native'].from_(arr_pts).T[:2]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef offset_to_data(self, off_x, off_y, center=None):\n        if center is not None:\n            self.logger.warning(\"`center` keyword is ignored and will be deprecated\")\n\n        arr_pts = np.asarray((off_x, off_y)).T\n        return self.tform['data_to_cartesian'].from_(arr_pts).T[:2]", "response": "Get the closest coordinates in the data array to those\n            in cartesian fixed ( non - scaled canvas coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef offset_to_window(self, off_x, off_y):\n        arr_pts = np.asarray((off_x, off_y)).T\n        return self.tform['cartesian_to_native'].to_(arr_pts).T[:2]", "response": "Convert data offset to window coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates new data size for the given axis ratios.", "response": "def get_data_pct(self, xpct, ypct):\n        \"\"\"Calculate new data size for the given axis ratios.\n        See :meth:`get_limits`.\n\n        Parameters\n        ----------\n        xpct, ypct : float\n            Ratio for X and Y, respectively, where 1 is 100%.\n\n        Returns\n        -------\n        x, y : int\n            Scaled dimensions.\n\n        \"\"\"\n        xy_mn, xy_mx = self.get_limits()\n        width = abs(xy_mx[0] - xy_mn[0])\n        height = abs(xy_mx[1] - xy_mn[1])\n\n        x, y = int(float(xpct) * width), int(float(ypct) * height)\n        return (x, y)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the coordinates in the actual data corresponding to the the area shown in the display for the current zoom level and pan.", "response": "def get_pan_rect(self):\n        \"\"\"Get the coordinates in the actual data corresponding to the\n        area shown in the display for the current zoom level and pan.\n\n        Returns\n        -------\n        points : list\n            Coordinates in the form of\n            ``[(x0, y0), (x1, y1), (x2, y2), (x3, y3)]``\n            from lower-left to lower-right.\n\n        \"\"\"\n        wd, ht = self.get_window_size()\n        #win_pts = np.asarray([(0, 0), (wd-1, 0), (wd-1, ht-1), (0, ht-1)])\n        win_pts = np.asarray([(0, 0), (wd, 0), (wd, ht), (0, ht)])\n        arr_pts = self.tform['data_to_window'].from_(win_pts)\n        return arr_pts"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the value at the given position.", "response": "def get_data(self, data_x, data_y):\n        \"\"\"Get the data value at the given position.\n        Indices are zero-based, as in Numpy.\n\n        Parameters\n        ----------\n        data_x, data_y : int\n            Data indices for X and Y, respectively.\n\n        Returns\n        -------\n        value\n            Data slice.\n\n        Raises\n        ------\n        ginga.ImageView.ImageViewNoDataError\n            Image not found.\n\n        \"\"\"\n        image = self.get_image()\n        if image is not None:\n            return image.get_data_xy(data_x, data_y)\n\n        raise ImageViewNoDataError(\"No image found\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the distance between the given pixel positions.", "response": "def get_pixel_distance(self, x1, y1, x2, y2):\n        \"\"\"Calculate distance between the given pixel positions.\n\n        Parameters\n        ----------\n        x1, y1, x2, y2 : number\n            Pixel coordinates.\n\n        Returns\n        -------\n        dist : float\n            Rounded distance.\n\n        \"\"\"\n        dx = abs(x2 - x1)\n        dy = abs(y2 - y1)\n        dist = np.sqrt(dx * dx + dy * dy)\n        dist = np.round(dist)\n        return dist"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _sanity_check_scale(self, scale_x, scale_y):\n        win_wd, win_ht = self.get_window_size()\n        if (win_wd <= 0) or (win_ht <= 0):\n            raise ImageViewError(\"window size undefined\")\n\n        # final sanity check on resulting output image size\n        if (win_wd * scale_x < 1) or (win_ht * scale_y < 1):\n            raise ValueError(\n                \"resulting scale (%f, %f) would result in image size of \"\n                \"<1 in width or height\" % (scale_x, scale_y))\n\n        sx = float(win_wd) / scale_x\n        sy = float(win_ht) / scale_y\n        if (sx < 1.0) or (sy < 1.0):\n            raise ValueError(\n                \"resulting scale (%f, %f) would result in pixel size \"\n                \"approaching window size\" % (scale_x, scale_y))", "response": "Do a sanity check on the proposed scale vs. window size. Raises an exception if there is a problem."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nscaling the image in a channel.", "response": "def set_scale(self, scale, no_reset=False):\n        \"\"\"Scale the image in a channel.\n        Also see :meth:`zoom_to`.\n\n        Parameters\n        ----------\n        scale : tuple of float\n            Scaling factors for the image in the X and Y axes.\n\n        no_reset : bool\n            Do not reset ``autozoom`` setting.\n\n        \"\"\"\n        return self.scale_to(*scale[:2], no_reset=no_reset)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nscales the image in a channel.", "response": "def scale_to(self, scale_x, scale_y, no_reset=False):\n        \"\"\"Scale the image in a channel.\n        This only changes the viewer settings; the image is not modified\n        in any way.  Also see :meth:`zoom_to`.\n\n        Parameters\n        ----------\n        scale_x, scale_y : float\n            Scaling factors for the image in the X and Y axes, respectively.\n\n        no_reset : bool\n            Do not reset ``autozoom`` setting.\n\n        \"\"\"\n        try:\n            self._sanity_check_scale(scale_x, scale_y)\n\n        except Exception as e:\n            self.logger.warning(\"Error in scaling: %s\" % (str(e)))\n            return\n\n        ratio = float(scale_x) / float(scale_y)\n        if ratio < 1.0:\n            # Y is stretched\n            scale_x_base, scale_y_base = 1.0, 1.0 / ratio\n        else:\n            # X may be stretched\n            scale_x_base, scale_y_base = ratio, 1.0\n\n        self.t_.set(scale_x_base=scale_x_base, scale_y_base=scale_y_base)\n\n        self._scale_to(scale_x, scale_y, no_reset=no_reset)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling callback related to image scaling.", "response": "def scale_cb(self, setting, value):\n        \"\"\"Handle callback related to image scaling.\"\"\"\n        zoomlevel = self.zoom.calc_level(value)\n        self.t_.set(zoomlevel=zoomlevel)\n\n        self.redraw(whence=0)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting stretch factors for X and Y.", "response": "def set_scale_base_xy(self, scale_x_base, scale_y_base):\n        \"\"\"Set stretch factors.\n\n        Parameters\n        ----------\n        scale_x_base, scale_y_base : float\n            Stretch factors for X and Y, respectively.\n\n        \"\"\"\n        self.t_.set(scale_x_base=scale_x_base, scale_y_base=scale_y_base)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_scale_text(self):\n        scalefactor = self.get_scale_max()\n        if scalefactor >= 1.0:\n            text = '%.2fx' % (scalefactor)\n        else:\n            text = '1/%.2fx' % (1.0 / scalefactor)\n        return text", "response": "Report current scaling in human - readable format."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the zoom level in a channel.", "response": "def zoom_to(self, zoomlevel, no_reset=False):\n        \"\"\"Set zoom level in a channel.\n        This only changes the relevant settings; The image is not modified.\n        Also see :meth:`scale_to`.\n\n        .. note::\n\n            In addition to the given zoom level, other zoom settings are\n            defined for the channel in preferences.\n\n        Parameters\n        ----------\n        zoomlevel : int\n            The zoom level to zoom the image.\n            Negative value to zoom out; positive to zoom in.\n\n        no_reset : bool\n            Do not reset ``autozoom`` setting.\n\n        \"\"\"\n        scale_x, scale_y = self.zoom.calc_scale(zoomlevel)\n        self._scale_to(scale_x, scale_y, no_reset=no_reset)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef zoom_in(self, incr=1.0):\n        level = self.zoom.calc_level(self.t_['scale'])\n        self.zoom_to(level + incr)", "response": "Zoom in a level."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nzooms out a level.", "response": "def zoom_out(self, decr=1.0):\n        \"\"\"Zoom out a level.\n        Also see :meth:`zoom_to`.\n\n        Parameters\n        ----------\n        decr : float (optional, defaults to 1)\n            The value to decrease the zoom level\n\n        \"\"\"\n        level = self.zoom.calc_level(self.t_['scale'])\n        self.zoom_to(level - decr)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef zoom_fit(self, no_reset=False):\n        # calculate actual width of the limits/image, considering rotation\n        try:\n            xy_mn, xy_mx = self.get_limits()\n\n        except ImageViewNoDataError:\n            return\n\n        try:\n            wwidth, wheight = self.get_window_size()\n            self.logger.debug(\"Window size is %dx%d\" % (wwidth, wheight))\n            if self.t_['swap_xy']:\n                wwidth, wheight = wheight, wwidth\n        except Exception:\n            return\n\n        # zoom_fit also centers image\n        with self.suppress_redraw:\n\n            self.center_image(no_reset=no_reset)\n\n            ctr_x, ctr_y, rot_deg = self.get_rotation_info()\n\n            # Find min/max extents of limits as shown by viewer\n            xs = np.array((xy_mn[0], xy_mx[0], xy_mx[0], xy_mn[0]))\n            ys = np.array((xy_mn[1], xy_mn[1], xy_mx[1], xy_mx[1]))\n            x0, y0 = trcalc.rotate_pt(xs, ys, rot_deg, xoff=ctr_x, yoff=ctr_y)\n\n            min_x, min_y = np.min(x0), np.min(y0)\n            max_x, max_y = np.max(x0), np.max(y0)\n\n            width, height = max_x - min_x, max_y - min_y\n            if min(width, height) <= 0:\n                return\n\n            # Calculate optimum zoom level to still fit the window size\n            scale_x = (float(wwidth) /\n                       (float(width) * self.t_['scale_x_base']))\n            scale_y = (float(wheight) /\n                       (float(height) * self.t_['scale_y_base']))\n\n            scalefactor = min(scale_x, scale_y)\n            # account for t_[scale_x/y_base]\n            scale_x = scalefactor * self.t_['scale_x_base']\n            scale_y = scalefactor * self.t_['scale_y_base']\n\n            self._scale_to(scale_x, scale_y, no_reset=no_reset)\n\n        if self.t_['autozoom'] == 'once':\n            self.t_.set(autozoom='off')", "response": "Zoom to fit display window."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_zoom_algorithm(self, name):\n        name = name.lower()\n        alg_names = list(zoom.get_zoom_alg_names())\n        if name not in alg_names:\n            raise ImageViewError(\"Alg '%s' must be one of: %s\" % (\n                name, ', '.join(alg_names)))\n        self.t_.set(zoom_algorithm=name)", "response": "Set zoom algorithm.\n\n        Parameters\n        ----------\n        name : str\n            Name of a zoom algorithm to use."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef zoomsetting_change_cb(self, setting, value):\n        alg_name = self.t_['zoom_algorithm']\n        self.zoom = zoom.get_zoom_alg(alg_name)(self)\n\n        self.zoom_to(self.get_zoom())", "response": "Handle callback related to changes in zoom."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef interpolation_change_cb(self, setting, value):\n        canvas_img = self.get_canvas_image()\n        canvas_img.interpolation = value\n        canvas_img.reset_optimize()\n        self.redraw(whence=0)", "response": "Handle callback related to changes in interpolation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_scale_limits(self, scale_min, scale_max):\n        # TODO: force scale to within limits if already outside?\n        self.t_.set(scale_min=scale_min, scale_max=scale_max)", "response": "Set the scale limits of the log entry."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nenable or disables autozoom on the related object.", "response": "def enable_autozoom(self, option):\n        \"\"\"Set ``autozoom`` behavior.\n\n        Parameters\n        ----------\n        option : {'on', 'override', 'once', 'off'}\n            Option for zoom behavior. A list of acceptable options can\n            also be obtained by :meth:`get_autozoom_options`.\n\n        Raises\n        ------\n        ginga.ImageView.ImageViewError\n            Invalid option.\n\n        \"\"\"\n        option = option.lower()\n        assert(option in self.autozoom_options), \\\n            ImageViewError(\"Bad autozoom option '%s': must be one of %s\" % (\n                str(self.autozoom_options)))\n        self.t_.set(autozoom=option)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_pan(self, pan_x, pan_y, coord='data', no_reset=False):\n        pan_pos = (pan_x, pan_y)\n\n        with self.suppress_redraw:\n            self.t_.set(pan=pan_pos, pan_coord=coord)\n            self._reset_bbox()\n\n        # If user specified \"override\" or \"once\" for auto center, then turn off\n        # auto center now that they have set the pan manually\n        if (not no_reset) and (self.t_['autocenter'] in ('override', 'once')):\n            self.t_.set(autocenter='off')", "response": "Set the pan position."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle callback related to changes in pan.", "response": "def pan_cb(self, setting, value):\n        \"\"\"Handle callback related to changes in pan.\"\"\"\n        pan_x, pan_y = value[:2]\n\n        self.logger.debug(\"pan set to %.2f,%.2f\" % (pan_x, pan_y))\n        self.redraw(whence=0)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_pan(self, coord='data'):\n        pan_x, pan_y = self.t_['pan'][:2]\n        if coord == 'wcs':\n            if self.t_['pan_coord'] == 'data':\n                image = self.get_image()\n                if image is not None:\n                    try:\n                        return image.pixtoradec(pan_x, pan_y)\n                    except Exception as e:\n                        pass\n            # <-- data already in coordinates form\n            return (pan_x, pan_y)\n\n        # <-- requesting data coords\n        if self.t_['pan_coord'] == 'data':\n            return (pan_x, pan_y)\n        image = self.get_image()\n        if image is not None:\n            try:\n                return image.radectopix(pan_x, pan_y)\n            except Exception as e:\n                pass\n        return (pan_x, pan_y)", "response": "Get the pan positions in the specified coordinate."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef panset_xy(self, data_x, data_y, no_reset=False):\n        pan_coord = self.t_['pan_coord']\n        # To center on the pixel\n        if pan_coord == 'wcs':\n            image = self.get_image()\n            if image is None:\n                return\n            pan_x, pan_y = image.pixtoradec(data_x, data_y)\n        else:\n            pan_x, pan_y = data_x, data_y\n\n        self.set_pan(pan_x, pan_y, coord=pan_coord, no_reset=no_reset)", "response": "Similar to set_pan except that input pan positions are always in data space."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef panset_pct(self, pct_x, pct_y):\n        try:\n            xy_mn, xy_mx = self.get_limits()\n\n        except Exception as e:\n            self.logger.error(\"Can't compute limits: %s\" % (str(e)))\n            return\n\n        data_x = (xy_mn[0] + xy_mx[0]) * pct_x\n        data_y = (xy_mn[1] + xy_mx[1]) * pct_y\n\n        self.panset_xy(data_x, data_y)", "response": "Similar to set_pan except that the pan positions are determined by multiplying data dimensions with the given pct_x and pct_y."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef center_image(self, no_reset=True):\n        try:\n            xy_mn, xy_mx = self.get_limits()\n            data_x = float(xy_mn[0] + xy_mx[0]) / 2.0\n            data_y = float(xy_mn[1] + xy_mx[1]) / 2.0\n\n        except ImageViewNoDataError:\n            # No data, so try to get center of any plotted objects\n            canvas = self.get_canvas()\n            try:\n                data_x, data_y = canvas.get_center_pt()[:2]\n\n            except Exception as e:\n                self.logger.error(\"Can't compute center point: %s\" % (str(e)))\n                return\n\n        self.panset_xy(data_x, data_y, no_reset=no_reset)\n\n        if self.t_['autocenter'] == 'once':\n            self.t_.set(autocenter='off')", "response": "Pan to the center of the image."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nenable automatic center behavior.", "response": "def enable_autocenter(self, option):\n        \"\"\"Set ``autocenter`` behavior.\n\n        Parameters\n        ----------\n        option : {'on', 'override', 'once', 'off'}\n            Option for auto-center behavior. A list of acceptable options can\n            also be obtained by :meth:`get_autocenter_options`.\n\n        Raises\n        ------\n        ginga.ImageView.ImageViewError\n            Invalid option.\n\n        \"\"\"\n        option = option.lower()\n        assert(option in self.autocenter_options), \\\n            ImageViewError(\"Bad autocenter option '%s': must be one of %s\" % (\n                str(self.autocenter_options)))\n        self.t_.set(autocenter=option)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\napply cut levels on the image view.", "response": "def cut_levels(self, loval, hival, no_reset=False):\n        \"\"\"Apply cut levels on the image view.\n\n        Parameters\n        ----------\n        loval, hival : float\n            Low and high values of the cut levels, respectively.\n\n        no_reset : bool\n            Do not reset ``autocuts`` setting.\n\n        \"\"\"\n        self.t_.set(cuts=(loval, hival))\n\n        # If user specified \"override\" or \"once\" for auto levels,\n        # then turn off auto levels now that they have set the levels\n        # manually\n        if (not no_reset) and (self.t_['autocuts'] in ('once', 'override')):\n            self.t_.set(autocuts='off')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\napply auto - cut levels on the image view.", "response": "def auto_levels(self, autocuts=None):\n        \"\"\"Apply auto-cut levels on the image view.\n\n        Parameters\n        ----------\n        autocuts : subclass of `~ginga.AutoCuts.AutoCutsBase` or `None`\n            An object that implements the desired auto-cut algorithm.\n            If not given, use algorithm from preferences.\n\n        \"\"\"\n        if autocuts is None:\n            autocuts = self.autocuts\n\n        image = self.get_image()\n        if image is None:\n            return\n\n        loval, hival = autocuts.calc_cut_levels(image)\n\n        # this will invoke cut_levels_cb()\n        self.t_.set(cuts=(loval, hival))\n\n        # If user specified \"once\" for auto levels, then turn off\n        # auto levels now that we have cut levels established\n        if self.t_['autocuts'] == 'once':\n            self.t_.set(autocuts='off')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles auto - cut levels changes in auto - cut levels.", "response": "def auto_levels_cb(self, setting, value):\n        \"\"\"Handle callback related to changes in auto-cut levels.\"\"\"\n        # Did we change the method?\n        method = self.t_['autocut_method']\n        params = self.t_.get('autocut_params', [])\n        params = dict(params)\n\n        if method != str(self.autocuts):\n            ac_class = AutoCuts.get_autocuts(method)\n            self.autocuts = ac_class(self.logger, **params)\n        else:\n            self.autocuts.update_params(**params)\n\n        # Redo the auto levels\n        #if self.t_['autocuts'] != 'off':\n        # NOTE: users seems to expect that when the auto cuts parameters\n        # are changed that the cuts should be immediately recalculated\n        self.auto_levels()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nenables automatic cuts for the current locale.", "response": "def enable_autocuts(self, option):\n        \"\"\"Set ``autocuts`` behavior.\n\n        Parameters\n        ----------\n        option : {'on', 'override', 'once', 'off'}\n            Option for auto-cut behavior. A list of acceptable options can\n            also be obtained by :meth:`get_autocuts_options`.\n\n        Raises\n        ------\n        ginga.ImageView.ImageViewError\n            Invalid option.\n\n        \"\"\"\n        option = option.lower()\n        assert(option in self.autocuts_options), \\\n            ImageViewError(\"Bad autocuts option '%s': must be one of %s\" % (\n                str(self.autocuts_options)))\n        self.t_.set(autocuts=option)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset auto-cut parameters. Parameters ---------- method : str Auto-cut algorithm. A list of acceptable options can be obtained by :meth:`get_autocut_methods`. params : dict Algorithm-specific keywords and values.", "response": "def set_autocut_params(self, method, **params):\n        \"\"\"Set auto-cut parameters.\n\n        Parameters\n        ----------\n        method : str\n            Auto-cut algorithm.  A list of acceptable options can\n            be obtained by :meth:`get_autocut_methods`.\n\n        params : dict\n            Algorithm-specific keywords and values.\n\n        \"\"\"\n        self.logger.debug(\"Setting autocut params method=%s params=%s\" % (\n            method, str(params)))\n        params = list(params.items())\n        self.t_.set(autocut_method=method, autocut_params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef transform(self, flip_x, flip_y, swap_xy):\n        self.logger.debug(\"flip_x=%s flip_y=%s swap_xy=%s\" % (\n            flip_x, flip_y, swap_xy))\n\n        with self.suppress_redraw:\n            self.t_.set(flip_x=flip_x, flip_y=flip_y, swap_xy=swap_xy)", "response": "Transform view of the image."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling callback related to changes in transformations.", "response": "def transform_cb(self, setting, value):\n        \"\"\"Handle callback related to changes in transformations.\"\"\"\n        self.make_callback('transform')\n\n        # whence=0 because need to calculate new extents for proper\n        # cutout for rotation (TODO: always make extents consider\n        #  room for rotation)\n        whence = 0\n        self.redraw(whence=whence)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copy_attributes(self, dst_fi, attrlist, share=False):\n        # TODO: change API to just go with settings names?\n        keylist = []\n        if 'transforms' in attrlist:\n            keylist.extend(['flip_x', 'flip_y', 'swap_xy'])\n\n        if 'rotation' in attrlist:\n            keylist.extend(['rot_deg'])\n\n        if 'autocuts' in attrlist:\n            keylist.extend(['autocut_method', 'autocut_params'])\n\n        if 'cutlevels' in attrlist:\n            keylist.extend(['cuts'])\n\n        if 'rgbmap' in attrlist:\n            keylist.extend(['color_algorithm', 'color_hashsize',\n                            'color_map', 'intensity_map',\n                            'color_array', 'shift_array'])\n\n        if 'zoom' in attrlist:\n            keylist.extend(['scale'])\n\n        if 'pan' in attrlist:\n            keylist.extend(['pan'])\n\n        with dst_fi.suppress_redraw:\n            if share:\n                self.t_.share_settings(dst_fi.get_settings(),\n                                       keylist=keylist)\n            else:\n                self.t_.copy_settings(dst_fi.get_settings(),\n                                      keylist=keylist)\n            dst_fi.redraw(whence=0)", "response": "Copy interesting attributes of our configuration to another image view."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef auto_orient(self):\n        image = self.get_image()\n        if image is None:\n            return\n        invert_y = not isinstance(image, AstroImage.AstroImage)\n\n        # Check for various things to set based on metadata\n        header = image.get_header()\n        if header:\n            # Auto-orientation\n            orient = header.get('Orientation', None)\n            if orient is None:\n                orient = header.get('Image Orientation', None)\n            if orient is not None:\n                self.logger.debug(\"orientation [%s]\" % orient)\n                try:\n                    orient = int(str(orient))\n                    self.logger.info(\n                        \"setting orientation from metadata [%d]\" % (orient))\n                    flip_x, flip_y, swap_xy = self.orient_map[orient]\n\n                    self.transform(flip_x, flip_y, swap_xy)\n                    invert_y = False\n\n                except Exception as e:\n                    # problems figuring out orientation--let it be\n                    self.logger.error(\"orientation error: %s\" % str(e))\n\n        if invert_y:\n            flip_x, flip_y, swap_xy = self.get_transforms()\n            #flip_y = not flip_y\n            flip_y = True\n            self.transform(flip_x, flip_y, swap_xy)", "response": "Set the orientation for the image to a reasonable default."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntake a catalog of transforms (`trcat`) and builds the chain of default transforms necessary to do rendering with most backends.", "response": "def recalc_transforms(self, trcat=None):\n        \"\"\"Takes a catalog of transforms (`trcat`) and builds the chain\n        of default transforms necessary to do rendering with most backends.\n\n        \"\"\"\n        if trcat is None:\n            trcat = self.trcat\n\n        self.tform = {\n            'window_to_native': trcat.WindowNativeTransform(self),\n            'cartesian_to_window': trcat.CartesianWindowTransform(self),\n            'cartesian_to_native': (trcat.RotationTransform(self) +\n                                    trcat.CartesianNativeTransform(self)),\n            'data_to_cartesian': (trcat.DataCartesianTransform(self) +\n                                  trcat.ScaleTransform(self)),\n            'data_to_scrollbar': (trcat.DataCartesianTransform(self) +\n                                  trcat.RotationTransform(self)),\n            'data_to_window': (trcat.DataCartesianTransform(self) +\n                               trcat.ScaleTransform(self) +\n                               trcat.RotationTransform(self) +\n                               trcat.CartesianWindowTransform(self)),\n            'data_to_percentage': (trcat.DataCartesianTransform(self) +\n                                   trcat.ScaleTransform(self) +\n                                   trcat.RotationTransform(self) +\n                                   trcat.CartesianWindowTransform(self) +\n                                   trcat.WindowPercentageTransform(self)),\n            'data_to_native': (trcat.DataCartesianTransform(self) +\n                               trcat.ScaleTransform(self) +\n                               trcat.RotationTransform(self) +\n                               trcat.CartesianNativeTransform(self)),\n            'wcs_to_data': trcat.WCSDataTransform(self),\n            'wcs_to_native': (trcat.WCSDataTransform(self) +\n                              trcat.DataCartesianTransform(self) +\n                              trcat.ScaleTransform(self) +\n                              trcat.RotationTransform(self) +\n                              trcat.CartesianNativeTransform(self)),\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_bg(self, r, g, b):\n        self.img_bg = (r, g, b)\n        self.redraw(whence=0)", "response": "Set the background color."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_fg(self, r, g, b):\n        self.img_fg = (r, g, b)\n        self.redraw(whence=3)", "response": "Set the foreground color."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the current image shown in the viewer as a BytesIO object.", "response": "def get_image_as_buffer(self, output=None):\n        \"\"\"Get the current image shown in the viewer, with any overlaid\n        graphics, in a IO buffer with channels as needed and ordered\n        by the back end widget.\n\n        This can be overridden by subclasses.\n\n        Parameters\n        ----------\n        output : a file IO-like object or None\n            open python IO descriptor or None to have one created\n\n        Returns\n        -------\n        buffer : file IO-like object\n            This will be the one passed in, unless `output` is None\n            in which case a BytesIO obejct is returned\n\n        \"\"\"\n        obuf = output\n        if obuf is None:\n            obuf = BytesIO()\n\n        arr8 = self.get_image_as_array()\n        if not hasattr(arr8, 'tobytes'):\n            # older versions of numpy\n            obuf.write(arr8.tostring(order='C'))\n        else:\n            obuf.write(arr8.tobytes(order='C'))\n\n        ## if output is not None:\n        ##     return None\n        return obuf"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the current image shown in the viewer with any overlaid graphics in the form of bytes.", "response": "def get_rgb_image_as_bytes(self, format='png', quality=90):\n        \"\"\"Get the current image shown in the viewer, with any overlaid\n        graphics, in the form of a buffer in the form of bytes.\n\n        Parameters\n        ----------\n        format : str\n            See :meth:`get_rgb_image_as_buffer`.\n\n        quality: int\n            See :meth:`get_rgb_image_as_buffer`.\n\n        Returns\n        -------\n        buffer : bytes\n            The window contents as a buffer in the form of bytes.\n\n        \"\"\"\n        obuf = self.get_rgb_image_as_buffer(format=format, quality=quality)\n        return bytes(obuf.getvalue())"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves the current image shown in the viewer with any overlaid graphics in a file with the specified format and quality.", "response": "def save_rgb_image_as_file(self, filepath, format='png', quality=90):\n        \"\"\"Save the current image shown in the viewer, with any overlaid\n        graphics, in a file with the specified format and quality.\n        This can be overridden by subclasses.\n\n        Parameters\n        ----------\n        filepath : str\n            path of the file to write\n\n        format : str\n            See :meth:`get_rgb_image_as_buffer`.\n\n        quality: int\n            See :meth:`get_rgb_image_as_buffer`.\n\n        \"\"\"\n        with open(filepath, 'wb') as out_f:\n            self.get_rgb_image_as_buffer(output=out_f, format=format,\n                                         quality=quality)\n        self.logger.debug(\"wrote %s file '%s'\" % (format, filepath))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the text to show in the display.", "response": "def set_onscreen_message(self, text, redraw=True):\n        \"\"\"Called by a subclass to update the onscreen message.\n\n        Parameters\n        ----------\n        text : str\n            The text to show in the display.\n\n        \"\"\"\n        width, height = self.get_window_size()\n\n        font = self.t_.get('onscreen_font', 'sans serif')\n        font_size = self.t_.get('onscreen_font_size', None)\n        if font_size is None:\n            font_size = self._calc_font_size(width)\n\n        # TODO: need some way to accurately estimate text extents\n        # without actually putting text on the canvas\n        ht, wd = font_size, font_size\n        if text is not None:\n            wd = len(text) * font_size * 1.1\n\n        x = (width // 2) - (wd // 2)\n        y = ((height // 3) * 2) - (ht // 2)\n\n        tag = '_$onscreen_msg'\n\n        canvas = self.get_private_canvas()\n        try:\n            message = canvas.get_object_by_tag(tag)\n            if text is None:\n                message.text = ''\n            else:\n                message.x = x\n                message.y = y\n                message.text = text\n                message.fontsize = font_size\n\n        except KeyError:\n            if text is None:\n                text = ''\n            Text = canvas.get_draw_class('text')\n            canvas.add(Text(x, y, text=text,\n                            font=font, fontsize=font_size,\n                            color=self.img_fg, coord='window'),\n                       tag=tag, redraw=False)\n\n        if redraw:\n            canvas.update_canvas(whence=3)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _calc_font_size(self, win_wd):\n        font_size = 4\n        if win_wd >= 1600:\n            font_size = 24\n        elif win_wd >= 1000:\n            font_size = 18\n        elif win_wd >= 800:\n            font_size = 16\n        elif win_wd >= 600:\n            font_size = 14\n        elif win_wd >= 500:\n            font_size = 12\n        elif win_wd >= 400:\n            font_size = 11\n        elif win_wd >= 300:\n            font_size = 10\n        elif win_wd >= 250:\n            font_size = 8\n        elif win_wd >= 200:\n            font_size = 6\n\n        return font_size", "response": "Calculates an appropriate font size based on the width of the viewer window."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_scroll_info(event):\n    direction = None\n    if event.direction == gtk.gdk.SCROLL_UP:\n        direction = 0.0\n    elif event.direction == gtk.gdk.SCROLL_DOWN:\n        direction = 180.0\n    elif event.direction == gtk.gdk.SCROLL_LEFT:\n        direction = 270.0\n    elif event.direction == gtk.gdk.SCROLL_RIGHT:\n        direction = 90.0\n\n    # TODO: does Gtk encode the amount of scroll?\n    # 15 deg is standard 1-click turn for a wheel mouse\n    degrees = 15.0\n\n    return (degrees, direction)", "response": "Returns the degrees and direction of a scroll motion Gtk event."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef popup(self, title, callfn, initialdir=None, filename=None):\n        self.cb = callfn\n        self.filew.set_title(title)\n        if initialdir:\n            self.filew.set_current_folder(initialdir)\n\n        if filename:\n            #self.filew.set_filename(filename)\n            self.filew.set_current_name(filename)\n\n        self.filew.show()", "response": "Let user select and load file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_data(filespec, idx=None, logger=None, **kwargs):\n    global loader_registry\n\n    info = iohelper.get_fileinfo(filespec)\n    filepath = info.filepath\n\n    if idx is None:\n        idx = info.numhdu\n\n    # Assume type to be a FITS image unless the MIME association says\n    # it is something different.\n    try:\n        typ, subtyp = iohelper.guess_filetype(filepath)\n\n    except Exception as e:\n        if logger is not None:\n            logger.warning(\"error determining file type: %s; \"\n                           \"assuming 'image/fits'\" % (str(e)))\n        # Can't determine file type: assume and attempt FITS\n        typ, subtyp = 'image', 'fits'\n\n    if logger is not None:\n        logger.debug(\"assuming file type: %s/%s'\" % (typ, subtyp))\n    try:\n        loader_info = loader_registry['%s/%s' % (typ, subtyp)]\n        data_loader = loader_info.loader\n\n    except KeyError:\n        # for now, assume that this is an unrecognized FITS file\n        data_loader = load_fits\n\n    data_obj = data_loader(filepath, idx=idx, logger=logger,\n                           **kwargs)\n    return data_obj", "response": "Load data from a file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_fileinfo(self, filespec, dldir=None):\n    if dldir is None:\n        dldir = self.tmpdir\n\n    # Get information about this file/URL\n    info = iohelper.get_fileinfo(filespec, cache_dir=dldir)", "response": "Break down a file specification into its components."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_amount_cb(self, widget, val):\n        self.zoom_amount = val\n        zoomlevel = self.fitsimage_focus.get_zoom()\n        self._zoomset(self.fitsimage_focus, zoomlevel)", "response": "This method is called when the Zoom Amount control is changed."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the data for the current object.", "response": "def set_data(self, data_ap, metadata=None):\n        \"\"\"Use this method to SHARE (not copy) the incoming table.\n        \"\"\"\n        self._data = data_ap\n\n        if metadata:\n            self.update_metadata(metadata)\n\n        self.make_callback('modified')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _slice(self, view):\n        if self._data is not None:\n            return self._data[view]\n        return self._proxy.get_view(self.id, view)", "response": "Return the view from the remote server and do slicing there."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall from the reference viewer shell when a new image has been added to a channel.", "response": "def redo(self, channel, image):\n        \"\"\"\n        Called from the reference viewer shell when a new image has\n        been added to a channel.\n        \"\"\"\n        chname = channel.name\n\n        # Only update our GUI if the activity is in the focused\n        # channel\n        if self.active == chname:\n            imname = image.get('name', 'NONAME')\n            self.set_info(\"A new image '%s' has been added to channel %s\" % (\n                imname, chname))\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning from command line.", "response": "def _main():\n    \"\"\"Run from command line.\"\"\"\n    usage = \"usage: %prog [options] cmd [arg] ...\"\n    optprs = OptionParser(usage=usage, version=version)\n\n    optprs.add_option(\"--debug\", dest=\"debug\", default=False,\n                      action=\"store_true\",\n                      help=\"Enter the pdb debugger on main()\")\n    optprs.add_option(\"--host\", dest=\"host\", metavar=\"HOST\",\n                      default=\"localhost\", help=\"Connect to server at HOST\")\n    optprs.add_option(\"--port\", dest=\"port\", type=\"int\",\n                      default=9000, metavar=\"PORT\",\n                      help=\"Connect to server at PORT\")\n    optprs.add_option(\"--profile\", dest=\"profile\", action=\"store_true\",\n                      default=False,\n                      help=\"Run the profiler on main()\")\n\n    (options, args) = optprs.parse_args(sys.argv[1:])\n\n    # Are we debugging this?\n    if options.debug:\n        import pdb\n\n        pdb.run('main(options, args)')\n\n    # Are we profiling this?\n    elif options.profile:\n        import profile\n\n        print(\"%s profile:\" % sys.argv[0])\n        profile.run('main(options, args)')\n\n    else:\n        main(options, args)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resize(self, dims):\n        width, height = dims[:2]\n        self.gl_resize(width, height)", "response": "Resize our drawing area to encompass a space defined by the\n        given dimensions."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef render_image(self, rgbobj, dst_x, dst_y):\n        pos = (0, 0)\n        arr = self.viewer.getwin_array(order=self.rgb_order, alpha=1.0,\n                                       dtype=np.uint8)\n        #pos = (dst_x, dst_y)\n        #print('dst', pos)\n        #pos = self.tform['window_to_native'].to_(pos)\n        #print('dst(c)', pos)\n        self.gl_set_image(arr, pos)", "response": "Render the image represented by rgbobj at dst_x dst_y in the pixel space."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pix2canvas(self, pt):\n        x, y = pt[:2]\n        #print('p2c in', x, y)\n        mm = gl.glGetDoublev(gl.GL_MODELVIEW_MATRIX)\n        pm = gl.glGetDoublev(gl.GL_PROJECTION_MATRIX)\n        vp = gl.glGetIntegerv(gl.GL_VIEWPORT)\n\n        win_x, win_y = float(x), float(vp[3] - y)\n        win_z = gl.glReadPixels(int(win_x), int(win_y), 1, 1,\n                                gl.GL_DEPTH_COMPONENT, gl.GL_FLOAT)\n        pos = glu.gluUnProject(win_x, win_y, win_z, mm, pm, vp)\n        #print('out', pos)\n        return pos", "response": "Takes a 2 - tuple of x y and gives\n        the x y z coordinates on the canvas."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntakes a 3 - tuple of x y z coordinates and gives the x y z coordinates in the canvas.", "response": "def canvas2pix(self, pos):\n        \"\"\"Takes a 3-tuple of (cx, cy, cz) in canvas coordinates and gives\n        the (x, y, z) pixel coordinates in the window.\n        \"\"\"\n        x, y, z = pos\n        #print('c2p in', x, y, z)\n        mm = gl.glGetDoublev(gl.GL_MODELVIEW_MATRIX)\n        pm = gl.glGetDoublev(gl.GL_PROJECTION_MATRIX)\n        vp = gl.glGetIntegerv(gl.GL_VIEWPORT)\n\n        pt = glu.gluProject(x, y, z, mm, pm, vp)\n        #print('c2p out', pt)\n        return pt"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef resize(self, dims):\n        width, height = dims[:2]\n        self.dims = (width, height)\n        self.logger.debug(\"renderer reconfigured to %dx%d\" % (\n            width, height))\n        # create agg surface the size of the window\n        self.surface = agg.Draw(self.rgb_order, self.dims, 'black')", "response": "Resize our drawing area to encompass a space defined by the\n            given dimensions."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef render_image(self, rgbobj, dst_x, dst_y):\n        if self.surface is None:\n            return\n        self.logger.debug(\"redraw surface\")\n\n        # get window contents as a buffer and load it into the AGG surface\n        rgb_buf = self.viewer.getwin_buffer(order=self.rgb_order,\n                                            dtype=np.uint8)\n        self.surface.frombytes(rgb_buf)", "response": "Render the image represented by rgbobj at dst_x dst_y in the pixel space."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads an image file and return a numpy array containing an RGB image.", "response": "def _imload(self, filepath, kwds):\n        \"\"\"Load an image file, guessing the format, and return a numpy\n        array containing an RGB image.  If EXIF keywords can be read\n        they are returned in the dict _kwds_.\n        \"\"\"\n        start_time = time.time()\n        typ, enc = mimetypes.guess_type(filepath)\n        if not typ:\n            typ = 'image/jpeg'\n        typ, subtyp = typ.split('/')\n        self.logger.debug(\"MIME type is %s/%s\" % (typ, subtyp))\n\n        data_loaded = False\n        if have_opencv and subtyp not in ['gif']:\n            # First choice is OpenCv, because it supports high-bit depth\n            # multiband images\n            means = 'opencv'\n            data_np = cv2.imread(filepath,\n                                 cv2.IMREAD_ANYDEPTH + cv2.IMREAD_ANYCOLOR)\n            if data_np is not None:\n                data_loaded = True\n                # funky indexing because opencv returns BGR images,\n                # whereas PIL and others return RGB\n                if len(data_np.shape) >= 3 and data_np.shape[2] >= 3:\n                    data_np = data_np[..., :: -1]\n\n                # OpenCv doesn't \"do\" image metadata, so we punt to piexif\n                # library (if installed)\n                self.piexif_getexif(filepath, kwds)\n\n                # OpenCv added a feature to do auto-orientation when loading\n                # (see https://github.com/opencv/opencv/issues/4344)\n                # So reset these values to prevent auto-orientation from\n                # happening later\n                kwds['Orientation'] = 1\n                kwds['Image Orientation'] = 1\n\n                # convert to working color profile, if can\n                if self.clr_mgr.can_profile():\n                    data_np = self.clr_mgr.profile_to_working_numpy(data_np, kwds)\n\n        if not data_loaded and have_pil:\n            means = 'PIL'\n            image = PILimage.open(filepath)\n\n            try:\n                if hasattr(image, '_getexif'):\n                    info = image._getexif()\n                    if info is not None:\n                        for tag, value in info.items():\n                            kwd = TAGS.get(tag, tag)\n                            kwds[kwd] = value\n\n                elif have_exif:\n                    self.piexif_getexif(image.info[\"exif\"], kwds)\n\n                else:\n                    self.logger.warning(\"Please install 'piexif' module to get image metadata\")\n\n            except Exception as e:\n                self.logger.warning(\"Failed to get image metadata: %s\" % (str(e)))\n\n            # convert to working color profile, if can\n            if self.clr_mgr.can_profile():\n                image = self.clr_mgr.profile_to_working_pil(image, kwds)\n\n            # convert from PIL to numpy\n            data_np = np.array(image)\n            if data_np is not None:\n                data_loaded = True\n\n        if (not data_loaded and (typ == 'image') and\n            (subtyp in ('x-portable-pixmap', 'x-portable-greymap'))):\n            # Special opener for PPM files, preserves high bit depth\n            means = 'built-in'\n            data_np = open_ppm(filepath)\n            if data_np is not None:\n                data_loaded = True\n\n        if not data_loaded:\n            raise ImageError(\"No way to load image format '%s/%s'\" % (\n                typ, subtyp))\n\n        end_time = time.time()\n        self.logger.debug(\"loading (%s) time %.4f sec\" % (\n            means, end_time - start_time))\n        return data_np"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_buffer(self, data_np, header, format, output=None):\n        if not have_pil:\n            raise Exception(\"Install PIL to use this method\")\n        image = PILimage.fromarray(data_np)\n        buf = output\n        if buf is None:\n            buf = BytesIO()\n        image.save(buf, format)\n        return buf", "response": "Get image as a buffer in format."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef imresize(self, data, new_wd, new_ht, method='bilinear'):\n        old_ht, old_wd = data.shape[:2]\n        start_time = time.time()\n\n        if have_pilutil:\n            means = 'PIL'\n            zoom_x = float(new_wd) / float(old_wd)\n            zoom_y = float(new_ht) / float(old_ht)\n            if (old_wd >= new_wd) or (old_ht >= new_ht):\n                # data size is bigger, skip pixels\n                zoom = max(zoom_x, zoom_y)\n            else:\n                zoom = min(zoom_x, zoom_y)\n\n            newdata = imresize(data, zoom, interp=method)\n\n        else:\n            raise ImageError(\"No way to scale image smoothly\")\n\n        end_time = time.time()\n        self.logger.debug(\"scaling (%s) time %.4f sec\" % (\n            means, end_time - start_time))\n\n        return newdata", "response": "Scale an image in numpy array _data_ to the specified width and height."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_array(self, order, dtype=None):\n        if dtype is None:\n            dtype = self.rgbarr.dtype\n        order = order.upper()\n        if order == self.order:\n            return self.rgbarr.astype(dtype, copy=False)\n\n        res = trcalc.reorder_image(order, self.rgbarr, self.order)\n        res = res.astype(dtype, copy=False, casting='unsafe')\n        return res", "response": "Get Numpy array that represents the RGB color layers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the bit depth for the output.", "response": "def set_bpp(self, bpp):\n        \"\"\"\n        Set the bit depth (per band) for the output.\n        A typical \"32-bit RGBA\" image would be 8; a 48-bit image would\n        be 16, etc.\n        \"\"\"\n        self.bpp = bpp\n        self.maxc = 2 ** self.bpp - 1\n        self._set_dtype()\n        self.calc_cmap()\n        self.recalc(callback=False)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_cmap(self, cmap, callback=True):\n        self.cmap = cmap\n        with self.suppress_changed:\n            self.calc_cmap()\n            # TEMP: ignore passed callback parameter\n            # callback=False in the following because we don't want to\n            # recursively invoke set_cmap()\n            self.t_.set(color_map=cmap.name, callback=False)", "response": "Set the color map used by this RGBMapper."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_rgbval(self, index):\n        assert (index >= 0) and (index <= self.maxc), \\\n            RGBMapError(\"Index must be in range 0-%d !\" % (self.maxc))\n        index = self.sarr[index].clip(0, self.maxc)\n        return (self.arr[0][index],\n                self.arr[1][index],\n                self.arr[2][index])", "response": "Return a tuple of R G B values in the 0 - maxc range associated\n        mapped by the value of index."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the intensity map used by this RGBMapper.", "response": "def set_imap(self, imap, callback=True):\n        \"\"\"\n        Set the intensity map used by this RGBMapper.\n\n        `imap` specifies an IntensityMap object.  If `callback` is True, then\n        any callbacks associated with this change will be invoked.\n        \"\"\"\n        self.imap = imap\n        self.calc_imap()\n        with self.suppress_changed:\n            # TEMP: ignore passed callback parameter\n            self.recalc()\n            # callback=False in the following because we don't want to\n            # recursively invoke set_imap()\n            self.t_.set(intensity_map=imap.name, callback=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_rgbarray(self, idx, out=None, order='RGB', image_order=''):\n        # prepare output array\n        shape = idx.shape\n        depth = len(order)\n\n        if (image_order is not None) and (len(image_order) > 1):\n            # indexes contain RGB axis, so omit this\n            res_shape = shape[:-1] + (depth, )\n        else:\n            res_shape = shape + (depth, )\n\n        if out is None:\n            out = np.empty(res_shape, dtype=self.dtype, order='C')\n        else:\n            # TODO: assertion check on shape of out\n            assert res_shape == out.shape, \\\n                RGBMapError(\"Output array shape %s doesn't match result \"\n                            \"shape %s\" % (str(out.shape), str(res_shape)))\n\n        res = RGBPlanes(out, order)\n\n        # set alpha channel\n        if res.hasAlpha:\n            aa = res.get_slice('A')\n            aa.fill(self.maxc)\n\n        idx = self.get_hasharray(idx)\n\n        self._get_rgbarray(idx, res, image_order=image_order)\n\n        return res", "response": "Get the RGB array for the given index."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nscales and shifts the color map according to the scale_pct and shift_pct.", "response": "def scale_and_shift(self, scale_pct, shift_pct, callback=True):\n        \"\"\"Stretch and/or shrink the color map via altering the shift map.\n        \"\"\"\n        maxlen = self.maxc + 1\n        self.sarr = np.arange(maxlen)\n\n        # limit shrinkage to 5% of original size\n        scale = max(scale_pct, 0.050)\n        self.scale_pct = scale\n\n        work = self._stretch(self.sarr, scale)\n        n = len(work)\n        if n < maxlen:\n            # pad on the lowest and highest values of the shift map\n            m = (maxlen - n) // 2 + 1\n            barr = np.array([0] * m)\n            tarr = np.array([self.maxc] * m)\n            work = np.concatenate([barr, work, tarr])\n            work = work[:maxlen]\n\n        # we are mimicing ds9's stretch and shift algorithm here.\n        # ds9 seems to cut the center out of the stretched array\n        # BEFORE shifting\n        n = len(work) // 2\n        halflen = maxlen // 2\n        work = work[n - halflen:n + halflen].astype(np.uint, copy=False)\n        assert len(work) == maxlen, \\\n            RGBMapError(\"scaled shift map is != %d\" % maxlen)\n\n        # shift map according to the shift_pct\n        work = self._shift(work, shift_pct)\n        assert len(work) == maxlen, \\\n            RGBMapError(\"shifted shift map is != %d\" % maxlen)\n\n        self.t_.set(shift_array=work)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadjusts the color map by altering the shift map.", "response": "def stretch(self, scale_factor, callback=True):\n        \"\"\"Stretch the color map via altering the shift map.\n        \"\"\"\n        self.scale_pct *= scale_factor\n        self.scale_and_shift(self.scale_pct, 0.0, callback=callback)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the RA and DEC coordinates for the image.", "response": "def get_wcs(self, data_x, data_y):\n        \"\"\"Return (re_deg, dec_deg) for the (data_x, data_y) position\n        based on any WCS associated with the loaded image.\n        \"\"\"\n        img = self.fitsimage.get_image()\n        ra, dec = img.pixtoradec(data_x, data_y)\n        return ra, dec"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_reference_channel(self, chname):\n        # change the GUI control to match\n        idx = self.chnames.index(str(chname))\n        self.w.ref_channel.set_index(idx)\n        return self._set_reference_channel(chname)", "response": "This is the API call to set the reference channel."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef zoomset_cb(self, setting, value, chviewer, info):\n        return self.zoomset(chviewer, info.chinfo)", "response": "This callback is called when a channel window is zoomed."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreset the X and Y scaling factors to equal in each channel.", "response": "def reset_scale_skew(self):\n        \"\"\"Set the X/Y scaling factors to be equal in each channel.\n        \"\"\"\n        chnames = self.fv.get_channel_names()\n        for chname in chnames:\n            chinfo = self.fv.get_channel(chname)\n\n            scales = chinfo.fitsimage.get_scale_xy()\n            fac = min(*scales)\n            chinfo.fitsimage.scale_to(fac, fac)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rotset_cb(self, setting, value, chviewer, info):\n        return self.rotset(chviewer, info.chinfo)", "response": "This callback is called when a channel window is rotated."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall when a new image appears in the channel.", "response": "def redo(self, channel, image):\n        \"\"\"Called when a new image appears in the channel.\"\"\"\n        if not self.gui_up:\n            return\n        # check if this is an image we received from IRAF or\n        # one that was loaded locally.\n        ct = image.get('ct', None)\n        if ct is not None:\n            # This image was sent by IRAF--we don't need to\n            # construct extra fb information for it\n            return\n\n        n = self.channel_to_frame(channel.name)\n        if n is None:\n            return\n        self.logger.debug(\"new image, frame is %d\" % (n))\n        fb = self.get_frame(n)\n        newpath = image.get('path', 'NO_PATH')\n        host = socket.getfqdn()\n        newhost = image.get('host', host)\n        # protocol has a bizarre 16-char limit on hostname\n        newhost = newhost[:16]\n\n        # this is just a placeholder so that IIS_RequestHandler will\n        # report something in this buffer\n        fb.buffer = array.array('B', ' ')\n\n        # Update IRAF \"wcs\" info so that IRAF can load this image\n\n        #print \"filling wcs info\"\n        fb.ct = iis.coord_tran()\n        image.set(ct=ct)\n\n        # iis version 1 data\n        fb.ct.valid = 1\n        fb.ct.a = 1\n        fb.ct.b = 0\n        fb.ct.c = 0\n        fb.ct.d = 1\n        fb.ct.tx = 0\n        fb.ct.ty = 0\n        fb.ct.z1 = 0\n        fb.ct.z2 = 1\n        fb.ct.zt = iis.W_UNITARY\n        fb.ct.format = ''\n        fb.ct.imtitle = ''\n\n        # iis version 1+ data\n        fb.ct.region = 'image'\n        #x1, y1, x2, y2 = fitsimage.get_datarect()\n        #wd, ht = x2-x1, y2-y1\n        #x1, y1, x2, y2 = x1+1, y1+1, x2+1, y2+1\n        #fb.ct.sx, fb.ct.sy = float(x1), float(y1)\n        wd, ht = image.get_size()\n        fb.ct.sx, fb.ct.sy = float(1), float(1)\n        fb.ct.snx, fb.ct.sny = wd, ht\n        fb.ct.dx, fb.ct.dy = 1, 1\n        fb.ct.dnx, fb.ct.dny = wd, ht\n\n        # ref\n        newref = \"!\".join([newhost, newpath])\n        fb.ct.ref = newref\n\n        # TODO: we shouldn't have to know about this here...\n        if (fb and fb.ct.a is not None):\n            wcs = \"%s\\n%f %f %f %f %f %f %f %f %d\\n\" % (\n                fb.ct.imtitle, fb.ct.a, fb.ct.b, fb.ct.c, fb.ct.d,\n                fb.ct.tx, fb.ct.ty, fb.ct.z1, fb.ct.z2, fb.ct.zt)\n        else:\n            wcs = \"[NOSUCHWCS]\\n\"\n        if (fb and fb.ct.sx is not None):\n            mapping = \"%s %f %f %d %d %d %d %d %d\\n%s\\n\" % (\n                fb.ct.region, fb.ct.sx, fb.ct.sy, fb.ct.snx, fb.ct.sny,\n                fb.ct.dx, fb.ct.dy, fb.ct.dnx, fb.ct.dny, fb.ct.ref)\n        else:\n            mapping = \"\"\n        fb.wcs = wcs + mapping\n        self.logger.debug(\"filled wcs info\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef init_frame(self, n):\n        self.logger.debug(\"initializing frame %d\" % (n))\n        # create the frame, if needed\n        try:\n            fb = self.get_frame(n)\n        except KeyError:\n            fb = iis.framebuffer()\n            self.fb[n] = fb\n\n        fb.width = None\n        fb.height = None\n        fb.wcs = ''\n        fb.image = None\n        fb.bitmap = None\n        fb.zoom = 1.0\n        fb.buffer = array.array('B')\n        fb.ct = iis.coord_tran()\n        #fb.chname = None\n        return fb", "response": "initialize the framebuffer with the specified number"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef display(self, frame, width, height, reverse=False):\n\n        fb = self.get_frame(frame)\n        self.current_frame = frame\n\n        if reverse:\n            fb.buffer.reverse()\n\n        # frames are indexed from 1 in IRAF\n        chname = fb.chname\n        if chname is None:\n            chname = 'Frame%d' % (frame + 1)\n            fb.chname = chname\n\n        self.logger.debug(\"display to %s\" % (chname))\n\n        try:\n            data = fb.buffer\n            byteswap = False  # noqa\n            dims = (fb.height, fb.width)\n            dtype = np.uint8\n            metadata = {}\n\n            image = IRAF_AstroImage(logger=self.logger)\n            #image.load_buffer(fb.buffer, dims, dtype, byteswap=byteswap,\n            #                  metadata=metadata)\n            data = np.fromstring(fb.buffer, dtype=dtype)\n            data = data.reshape(dims)\n            # Image comes in from IRAF flipped for screen display\n            data = np.flipud(data)\n            image.set_data(data, metadata=metadata)\n            # Save coordinate transform info\n            image.set(ct=fb.ct)\n\n            # make up a name (is there a protocol slot for the name?)\n            fitsname = str(time.time())\n\n            # extract path from ref\n            oldref = fb.ct.ref\n            items = oldref.split('!')\n            host = items[0]\n            path = '!'.join(items[1:])\n\n            image.set(name=fitsname, path=path, host=host)\n            #image.update_keywords(header)\n\n        except Exception as e:\n            # Some kind of error unpacking the data\n            errmsg = \"Error creating image data for '%s': %s\" % (\n                chname, str(e))\n            self.logger.error(errmsg)\n            raise GingaPlugin.PluginError(errmsg)\n\n        # Do the GUI bits as the GUI thread\n        self.fv.gui_do(self._gui_display_image, fitsname, image, chname)", "response": "display the current frame in IRAF"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall when the user clicks on the color bar viewer.", "response": "def select_cb(self, viewer, event, data_x, data_y):\n        \"\"\"Called when the user clicks on the color bar viewer.\n        Calculate the index of the color bar they clicked on and\n        set that color map in the current channel viewer.\n        \"\"\"\n        if not (self._cmxoff <= data_x < self._cmwd):\n            # need to click within the width of the bar\n            return\n\n        i = int(data_y / (self._cmht + self._cmsep))\n        if 0 <= i < len(self.cm_names):\n            name = self.cm_names[i]\n            msg = \"cmap => '%s'\" % (name)\n            self.logger.info(msg)\n\n            channel = self.fv.get_channel_info()\n            if channel is not None:\n                viewer = channel.fitsimage\n                #viewer.onscreen_message(msg, delay=0.5)\n                viewer.set_color_map(name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall when the user scrolls in the color bar viewer. Pan up or down to show additional bars.", "response": "def scroll_cb(self, viewer, direction, amt, data_x, data_y):\n        \"\"\"Called when the user scrolls in the color bar viewer.\n        Pan up or down to show additional bars.\n        \"\"\"\n        bd = viewer.get_bindings()\n        direction = bd.get_direction(direction)\n        pan_x, pan_y = viewer.get_pan()[:2]\n        qty = self._cmsep * amt * self.settings.get('cbar_pan_accel', 1.0)\n        if direction == 'up':\n            pan_y -= qty\n        else:\n            pan_y += qty\n\n        pan_y = min(max(pan_y, 0), self._max_y)\n\n        viewer.set_pan(pan_x, pan_y)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rebuild_cmaps(self):\n        self.logger.info(\"building color maps image\")\n        ht, wd, sep = self._cmht, self._cmwd, self._cmsep\n        viewer = self.p_view\n\n        # put the canvas into pick mode\n        canvas = viewer.get_canvas()\n        canvas.delete_all_objects()\n\n        # get the list of color maps\n        cm_names = self.cm_names\n        num_cmaps = len(cm_names)\n        viewer.configure_surface(500, (ht + sep) * num_cmaps)\n\n        # create a bunch of color bars and make one large compound object\n        # with callbacks for clicking on individual color bars\n        l2 = []\n        ColorBar = canvas.get_draw_class('drawablecolorbar')\n        Text = canvas.get_draw_class('text')\n        #ch_rgbmap = chviewer.get_rgbmap()\n        #dist = ch_rgbmap.get_dist()\n        dist = None\n        #imap = ch_rgbmap.get_imap()\n        logger = viewer.get_logger()\n\n        for i, name in enumerate(cm_names):\n            rgbmap = RGBMap.RGBMapper(logger, dist=dist)\n            rgbmap.set_cmap(cmap.get_cmap(name))\n            #rgbmap.set_imap(imap)\n            x1, y1 = self._cmxoff, i * (ht + sep)\n            x2, y2 = x1 + wd, y1 + ht\n            cbar = ColorBar(x1, y1, x2, y2, cm_name=name, showrange=False,\n                            rgbmap=rgbmap, coord='window')\n            l2.append(cbar)\n            l2.append(Text(x2 + sep, y2, name, color='white', fontsize=16,\n                           coord='window'))\n\n        Compound = canvas.get_draw_class('compoundobject')\n        obj = Compound(*l2)\n        canvas.add(obj)\n\n        self._max_y = y2\n\n        rgb_img = self.p_view.get_image_as_array()\n        self.r_image.set_data(rgb_img)", "response": "Builds a color RGB image containing color bars of all possible color maps and their labels."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef record_sizes(self):\n        for rec in self.node.values():\n            w = rec.widget\n            wd, ht = w.get_size()\n\n            rec.params.update(dict(name=rec.name, width=wd, height=ht))\n\n            if rec.kind in ('hpanel', 'vpanel'):\n                sizes = w.get_sizes()\n                rec.params.update(dict(sizes=sizes))\n\n            if rec.kind in ('ws',):\n                # record ws type\n                # TODO: record positions of subwindows\n                rec.params.update(dict(wstype=rec.ws.wstype))\n\n            if rec.kind == 'top':\n                # record position for top-level widgets as well\n                x, y = w.get_pos()\n                if x is not None and y is not None:\n                    # we don't always get reliable information about position\n                    rec.params.update(dict(xpos=x, ypos=y))", "response": "Record sizes of all container widgets in the layout."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef help(self, *args):\n        if len(args) == 0:\n            return help_msg\n\n        which = args[0].lower()\n\n        if which == 'ginga':\n            method = args[1]\n            _method = getattr(self.fv, method)\n            return _method.__doc__\n\n        elif which == 'channel':\n            chname = args[1]\n            method = args[2]\n            chinfo = self.fv.get_channel(chname)\n            _method = getattr(chinfo.viewer, method)\n            return _method.__doc__\n\n        else:\n            return (\"Please use 'help ginga <method>' or \"\n                    \"'help channel <chname> <method>'\")", "response": "Get help for a remote interface method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndisplay a FITS image buffer.", "response": "def load_buffer(self, imname, chname, img_buf, dims, dtype,\n                    header, metadata, compressed):\n        \"\"\"Display a FITS image buffer.\n\n        Parameters\n        ----------\n        imname : string\n            a name to use for the image in Ginga\n        chname : string\n            channel in which to load the image\n        img_buf : string\n            the image data, as a bytes object\n        dims : tuple\n            image dimensions in pixels (usually (height, width))\n        dtype : string\n            numpy data type of encoding (e.g. 'float32')\n        header : dict\n            fits file header as a dictionary\n        metadata : dict\n            other metadata about image to attach to image\n        compressed : bool\n            decompress buffer using \"bz2\"\n\n        Returns\n        -------\n        0\n\n        Notes\n        -----\n\n        * Get array dims: data.shape\n        * Get array dtype: str(data.dtype)\n        * Make a string from a numpy array: buf = data.tostring()\n        * Compress the buffer: buf = bz2.compress(buf)\n\n        \"\"\"\n        self.logger.info(\"received image data len=%d\" % (len(img_buf)))\n\n        # Unpack the data\n        try:\n            # Uncompress data if necessary\n            decompress = metadata.get('decompress', None)\n            if compressed or (decompress == 'bz2'):\n                img_buf = bz2.decompress(img_buf)\n\n            # dtype string works for most instances\n            if dtype == '':\n                dtype = numpy.float32\n\n            byteswap = metadata.get('byteswap', False)\n\n            # Create image container\n            image = AstroImage.AstroImage(logger=self.logger)\n            image.load_buffer(img_buf, dims, dtype, byteswap=byteswap,\n                              metadata=metadata)\n            image.update_keywords(header)\n            image.set(name=imname, path=None)\n\n        except Exception as e:\n            # Some kind of error unpacking the data\n            errmsg = \"Error creating image data for '%s': %s\" % (\n                imname, str(e))\n            self.logger.error(errmsg)\n            raise GingaPlugin.PluginError(errmsg)\n\n        # Display the image\n        channel = self.fv.gui_call(self.fv.get_channel_on_demand, chname)\n\n        # Note: this little hack needed to let window resize in time for\n        # file to auto-size properly\n        self.fv.gui_do(self.fv.change_channel, channel.name)\n\n        self.fv.gui_do(self.fv.add_image, imname, image,\n                       chname=channel.name)\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef resize(self, dims):\n        width, height = dims[:2]\n        self.dims = (width, height)\n        self.logger.debug(\"renderer reconfigured to %dx%d\" % (\n            width, height))\n\n        # create cv surface the size of the window\n        # (cv just uses numpy arrays!)\n        depth = len(self.rgb_order)\n        self.surface = np.zeros((height, width, depth), dtype=np.uint8)", "response": "Resize our drawing area to encompass a space defined by the\n            given dimensions."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef render_image(self, rgbobj, dst_x, dst_y):\n        if self.surface is None:\n            return\n        self.logger.debug(\"redraw surface\")\n\n        # get window contents as an array and store it into the CV surface\n        rgb_arr = self.viewer.getwin_array(order=self.rgb_order, dtype=np.uint8)\n        # TODO: is there a faster way to copy this array in?\n        self.surface[:, :, :] = rgb_arr", "response": "Render the image represented by rgbobj at dst_x dst_y in the pixel space."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef use(name):\n    global toolkit, family\n\n    name = name.lower()\n\n    if name.startswith('choose'):\n        pass\n\n    elif name.startswith('qt') or name.startswith('pyside'):\n        family = 'qt'\n        if name == 'qt':\n            name = 'qt4'\n        assert name in ('qt4', 'pyside', 'qt5'), \\\n            ToolKitError(\"ToolKit '%s' not supported!\" % (name))\n\n    elif name.startswith('gtk'):\n        # default for \"gtk\" is gtk3\n        if name in ('gtk', 'gtk3'):\n            name = 'gtk3'\n            family = 'gtk3'\n        elif name in ('gtk2',):\n            family = 'gtk'\n        assert name in ('gtk2', 'gtk3'), \\\n            ToolKitError(\"ToolKit '%s' not supported!\" % (name))\n\n    elif name.startswith('tk'):\n        family = 'tk'\n        assert name in ('tk', ), \\\n            ToolKitError(\"ToolKit '%s' not supported!\" % (name))\n\n    elif name.startswith('pg'):\n        family = 'pg'\n        assert name in ('pg', ), \\\n            ToolKitError(\"ToolKit '%s' not supported!\" % (name))\n\n    else:\n        ToolKitError(\"ToolKit '%s' not supported!\" % (name))\n\n    toolkit = name", "response": "Set the name of the GUI toolkit we should use."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nshare settings with other", "response": "def share_settings(self, other, keylist=None, include_callbacks=True,\n                       callback=True):\n        \"\"\"Sharing settings with `other`\n        \"\"\"\n        if keylist is None:\n            keylist = self.group.keys()\n        if include_callbacks:\n            for key in keylist:\n                oset, mset = other.group[key], self.group[key]\n                other.group[key] = mset\n                oset.merge_callbacks_to(mset)\n        if callback:\n            # make callbacks only after all items are set in the group\n            # TODO: only make callbacks for values that changed?\n            for key in keylist:\n                other.group[key].make_callback('set', other.group[key].value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall when one of the Move Draw or Edit radio buttons is selected.", "response": "def set_mode_cb(self, mode, tf):\n        \"\"\"Called when one of the Move/Draw/Edit radio buttons is selected.\"\"\"\n        if tf:\n            self.canvas.set_draw_mode(mode)\n            if mode == 'edit':\n                self.edit_select_marks()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npopulate combobox with given list.", "response": "def _set_combobox(self, attrname, vals, default=0):\n        \"\"\"Populate combobox with given list.\"\"\"\n        combobox = getattr(self.w, attrname)\n        for val in vals:\n            combobox.append_text(val)\n        if default > len(vals):\n            default = 0\n        val = vals[default]\n        combobox.show_text(val)\n        return val"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nclears comboboxes and columns.", "response": "def clear_data(self):\n        \"\"\"Clear comboboxes and columns.\"\"\"\n        self.tab = None\n        self.cols = []\n        self._idx = []\n        self.x_col = ''\n        self.y_col = ''\n        self.w.xcombo.clear()\n        self.w.ycombo.clear()\n        self.w.x_lo.set_text('')\n        self.w.x_hi.set_text('')\n        self.w.y_lo.set_text('')\n        self.w.y_hi.set_text('')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef plot_two_columns(self, reset_xlimits=False, reset_ylimits=False):\n        self.clear_plot()\n\n        if self.tab is None:  # No table data to plot\n            return\n\n        plt_kw = {\n            'lw': self.settings.get('linewidth', 1),\n            'ls': self.settings.get('linestyle', '-'),\n            'color': self.settings.get('linecolor', 'blue'),\n            'ms': self.settings.get('markersize', 6),\n            'mew': self.settings.get('markerwidth', 0.5),\n            'mfc': self.settings.get('markercolor', 'red')}\n        plt_kw['mec'] = plt_kw['mfc']\n\n        try:\n            x_data, y_data, marker = self._get_plot_data()\n\n            self.tab_plot.plot(\n                x_data, y_data,\n                xtitle=self._get_label('x'), ytitle=self._get_label('y'),\n                marker=marker, **plt_kw)\n\n            if reset_xlimits:\n                self.set_ylim_cb()\n                self.set_xlimits_widgets()\n            if reset_ylimits:\n                self.set_xlim_cb()\n                self.set_ylimits_widgets()\n            if not (reset_xlimits or reset_ylimits):\n                self.set_xlim_cb(redraw=False)\n                self.set_ylim_cb()\n\n        except Exception as e:\n            self.logger.error(str(e))\n        else:\n            self.save_plot.set_enabled(True)", "response": "Simple line plot for two selected columns."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_xlimits_widgets(self, set_min=True, set_max=True):\n        xmin, xmax = self.tab_plot.ax.get_xlim()\n        if set_min:\n            self.w.x_lo.set_text('{0}'.format(xmin))\n        if set_max:\n            self.w.x_hi.set_text('{0}'.format(xmax))", "response": "Populate axis limits GUI with current plot values."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npopulate axis limits GUI with current plot values.", "response": "def set_ylimits_widgets(self, set_min=True, set_max=True):\n        \"\"\"Populate axis limits GUI with current plot values.\"\"\"\n        ymin, ymax = self.tab_plot.ax.get_ylim()\n        if set_min:\n            self.w.y_lo.set_text('{0}'.format(ymin))\n        if set_max:\n            self.w.y_hi.set_text('{0}'.format(ymax))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_plot_data(self):\n        _marker_type = self.settings.get('markerstyle', 'o')\n\n        if self.x_col == self._idxname:\n            x_data = self._idx\n        else:\n            x_data = self.tab[self.x_col].data\n\n        if self.y_col == self._idxname:\n            y_data = self._idx\n        else:\n            y_data = self.tab[self.y_col].data\n\n        if self.tab.masked:\n            if self.x_col == self._idxname:\n                x_mask = np.ones_like(self._idx, dtype=np.bool)\n            else:\n                x_mask = ~self.tab[self.x_col].mask\n\n            if self.y_col == self._idxname:\n                y_mask = np.ones_like(self._idx, dtype=np.bool)\n            else:\n                y_mask = ~self.tab[self.y_col].mask\n\n            mask = x_mask & y_mask\n            x_data = x_data[mask]\n            y_data = y_data[mask]\n\n        if len(x_data) > 1:\n            i = np.argsort(x_data)  # Sort X-axis to avoid messy line plot\n            x_data = x_data[i]\n            y_data = y_data[i]\n\n            if not self.w.show_marker.get_state():\n                _marker_type = None\n\n        return x_data, y_data, _marker_type", "response": "Extract only good data point for plotting."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns plot label for the given axis.", "response": "def _get_label(self, axis):\n        \"\"\"Return plot label for column for the given axis.\"\"\"\n\n        if axis == 'x':\n            colname = self.x_col\n        else:  # y\n            colname = self.y_col\n\n        if colname == self._idxname:\n            label = 'Index'\n        else:\n            col = self.tab[colname]\n            if col.unit:\n                label = '{0} ({1})'.format(col.name, col.unit)\n            else:\n                label = col.name\n\n        return label"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef x_select_cb(self, w, index):\n        try:\n            self.x_col = self.cols[index]\n        except IndexError as e:\n            self.logger.error(str(e))\n        else:\n            self.plot_two_columns(reset_xlimits=True)", "response": "Callback to set X - axis column."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef y_select_cb(self, w, index):\n        try:\n            self.y_col = self.cols[index]\n        except IndexError as e:\n            self.logger.error(str(e))\n        else:\n            self.plot_two_columns(reset_ylimits=True)", "response": "Callback to set Y - axis column."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef log_x_cb(self, w, val):\n        self.tab_plot.logx = val\n        self.plot_two_columns()", "response": "This callback is invoked when the user clicks the log - scale for the current log - level."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef log_y_cb(self, w, val):\n        self.tab_plot.logy = val\n        self.plot_two_columns()", "response": "This callback is invoked when the user clicks the log y - axis."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_xlim_cb(self, redraw=True):\n        try:\n            xmin = float(self.w.x_lo.get_text())\n        except Exception:\n            set_min = True\n        else:\n            set_min = False\n\n        try:\n            xmax = float(self.w.x_hi.get_text())\n        except Exception:\n            set_max = True\n        else:\n            set_max = False\n\n        if set_min or set_max:\n            self.tab_plot.draw()\n            self.set_xlimits_widgets(set_min=set_min, set_max=set_max)\n\n        if not (set_min and set_max):\n            self.tab_plot.ax.set_xlim(xmin, xmax)\n            if redraw:\n                self.tab_plot.draw()", "response": "Set plot limits based on user values."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets plot limits based on user values.", "response": "def set_ylim_cb(self, redraw=True):\n        \"\"\"Set plot limit based on user values.\"\"\"\n        try:\n            ymin = float(self.w.y_lo.get_text())\n        except Exception:\n            set_min = True\n        else:\n            set_min = False\n\n        try:\n            ymax = float(self.w.y_hi.get_text())\n        except Exception:\n            set_max = True\n        else:\n            set_max = False\n\n        if set_min or set_max:\n            self.tab_plot.draw()\n            self.set_ylimits_widgets(set_min=set_min, set_max=set_max)\n\n        if not (set_min and set_max):\n            self.tab_plot.ax.set_ylim(ymin, ymax)\n            if redraw:\n                self.tab_plot.draw()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save_cb(self):\n\n        # This just defines the basename.\n        # Extension has to be explicitly defined or things can get messy.\n        w = Widgets.SaveDialog(title='Save plot')\n        target = w.get_path()\n        if target is None:\n            # Save canceled\n            return\n\n        plot_ext = self.settings.get('file_suffix', '.png')\n\n        if not target.endswith(plot_ext):\n            target += plot_ext\n\n        # TODO: This can be a user preference?\n        fig_dpi = 100\n\n        try:\n            fig = self.tab_plot.get_figure()\n            fig.savefig(target, dpi=fig_dpi)\n\n        except Exception as e:\n            self.logger.error(str(e))\n        else:\n            self.logger.info('Table plot saved as {0}'.format(target))", "response": "Save plot to file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting FITS image to PDF.", "response": "def convert(filepath, outfilepath):\n    \"\"\"Convert FITS image to PDF.\"\"\"\n\n    logger = logging.getLogger(\"example1\")\n    logger.setLevel(logging.INFO)\n    fmt = logging.Formatter(STD_FORMAT)\n    stderrHdlr = logging.StreamHandler()\n    stderrHdlr.setFormatter(fmt)\n    logger.addHandler(stderrHdlr)\n\n    fi = ImageViewCairo(logger)\n    fi.configure(500, 1000)\n\n    # Load fits file\n    image = load_data(filepath, logger=logger)\n\n    # Make any adjustments to the image that we want\n    fi.set_bg(1.0, 1.0, 1.0)\n    fi.set_image(image)\n    fi.auto_levels()\n    fi.zoom_fit()\n    fi.center_image()\n\n    ht_pts = 11.0 / point_in\n    wd_pts = 8.5 / point_in\n    off_x, off_y = 0, 0\n\n    out_f = open(outfilepath, 'w')\n    surface = cairo.PDFSurface(out_f, wd_pts, ht_pts)\n    # set pixels per inch\n    surface.set_fallback_resolution(300, 300)\n    surface.set_device_offset(off_x, off_y)\n    try:\n        fi.save_image_as_surface(surface)\n        surface.show_page()\n        surface.flush()\n        surface.finish()\n    finally:\n        out_f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nimage or masks have changed. Clear and redraw.", "response": "def redo(self):\n        \"\"\"Image or masks have changed. Clear and redraw.\"\"\"\n        if not self.gui_up:\n            return\n\n        self.clear_mask()\n\n        image = self.fitsimage.get_image()\n        if image is None:\n            return\n\n        n_obj = len(self._maskobjs)\n        self.logger.debug('Displaying {0} masks'.format(n_obj))\n        if n_obj == 0:\n            return\n\n        # Display info table\n        self.recreate_toc()\n\n        # Draw on canvas\n        self.masktag = self.canvas.add(self.dc.CompoundObject(*self._maskobjs))\n        self.fitsimage.redraw()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clear_mask(self):\n        if self.masktag:\n            try:\n                self.canvas.delete_object_by_tag(self.masktag, redraw=False)\n            except Exception:\n                pass\n\n        if self.maskhltag:\n            try:\n                self.canvas.delete_object_by_tag(self.maskhltag, redraw=False)\n            except Exception:\n                pass\n\n        self.treeview.clear()  # Clear table too\n        self.fitsimage.redraw()", "response": "Clear mask from image.\n        This does not clear loaded masks from memory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nforget all loaded coordinates.", "response": "def forget_masks(self):\n        \"\"\"Forget all loaded coordinates.\"\"\"\n        self._seqno = 1\n        self._maskobjs = []\n        self._treepaths = []\n        self.tree_dict = Bunch.caselessDict()\n        self.redo()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading mask image from file.", "response": "def load_file(self, filename):\n        \"\"\"Load mask image.\n\n        Results are appended to previously loaded masks.\n        This can be used to load mask per color.\n\n        \"\"\"\n        if not os.path.isfile(filename):\n            return\n\n        self.logger.info('Loading mask image from {0}'.format(filename))\n\n        try:\n            # 0=False, everything else True\n            dat = fits.getdata(filename).astype(np.bool)\n        except Exception as e:\n            self.logger.error('{0}: {1}'.format(e.__class__.__name__, str(e)))\n            return\n\n        key = '{0},{1}'.format(self.maskcolor, self.maskalpha)\n\n        if key in self.tree_dict:\n            sub_dict = self.tree_dict[key]\n        else:\n            sub_dict = {}\n            self.tree_dict[key] = sub_dict\n\n        # Add to listing\n        seqstr = '{0:04d}'.format(self._seqno)  # Prepend 0s for proper sort\n        sub_dict[seqstr] = Bunch.Bunch(ID=seqstr,\n                                       MASKFILE=os.path.basename(filename))\n        self._treepaths.append((key, seqstr))\n        self._seqno += 1\n\n        # Create mask layer\n        obj = self.dc.Image(0, 0, masktorgb(\n            dat, color=self.maskcolor, alpha=self.maskalpha))\n        self._maskobjs.append(obj)\n\n        self.redo()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting RGB arrays from mask canvas object back to boolean mask.", "response": "def _rgbtomask(self, obj):\n        \"\"\"Convert RGB arrays from mask canvas object back to boolean mask.\"\"\"\n        dat = obj.get_image().get_data()  # RGB arrays\n        return dat.sum(axis=2).astype(np.bool)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhighlight mask on canvas when user click on table.", "response": "def hl_table2canvas(self, w, res_dict):\n        \"\"\"Highlight mask on canvas when user click on table.\"\"\"\n        objlist = []\n\n        # Remove existing highlight\n        if self.maskhltag:\n            try:\n                self.canvas.delete_object_by_tag(self.maskhltag, redraw=False)\n            except Exception:\n                pass\n\n        for sub_dict in res_dict.values():\n            for seqno in sub_dict:\n                mobj = self._maskobjs[int(seqno) - 1]\n                dat = self._rgbtomask(mobj)\n                obj = self.dc.Image(0, 0, masktorgb(\n                    dat, color=self.hlcolor, alpha=self.hlalpha))\n                objlist.append(obj)\n\n        # Draw on canvas\n        if len(objlist) > 0:\n            self.maskhltag = self.canvas.add(self.dc.CompoundObject(*objlist))\n\n        self.fitsimage.redraw()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhighlights all masks inside user drawn box on table.", "response": "def hl_canvas2table_box(self, canvas, tag):\n        \"\"\"Highlight all masks inside user drawn box on table.\"\"\"\n        self.treeview.clear_selection()\n\n        # Remove existing box\n        cobj = canvas.get_object_by_tag(tag)\n        if cobj.kind != 'rectangle':\n            return\n        canvas.delete_object_by_tag(tag, redraw=False)\n\n        # Remove existing highlight\n        if self.maskhltag:\n            try:\n                canvas.delete_object_by_tag(self.maskhltag, redraw=True)\n            except Exception:\n                pass\n\n        # Nothing to do if no masks are displayed\n        try:\n            obj = canvas.get_object_by_tag(self.masktag)\n        except Exception:\n            return\n\n        if obj.kind != 'compound':\n            return\n\n        # Nothing to do if table has no data\n        if len(self._maskobjs) == 0:\n            return\n\n        # Find masks that intersect the rectangle\n        for i, mobj in enumerate(self._maskobjs):\n            # The actual mask\n            mask1 = self._rgbtomask(mobj)\n\n            # The selected area\n            rgbimage = mobj.get_image()\n            mask2 = rgbimage.get_shape_mask(cobj)\n\n            # Highlight mask with intersect\n            if np.any(mask1 & mask2):\n                self._highlight_path(self._treepaths[i])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhighlights mask on table when user click on canvas.", "response": "def hl_canvas2table(self, canvas, button, data_x, data_y):\n        \"\"\"Highlight mask on table when user click on canvas.\"\"\"\n        self.treeview.clear_selection()\n\n        # Remove existing highlight\n        if self.maskhltag:\n            try:\n                canvas.delete_object_by_tag(self.maskhltag, redraw=True)\n            except Exception:\n                pass\n\n        # Nothing to do if no masks are displayed\n        try:\n            obj = canvas.get_object_by_tag(self.masktag)\n        except Exception:\n            return\n\n        if obj.kind != 'compound':\n            return\n\n        # Nothing to do if table has no data\n        if len(self._maskobjs) == 0:\n            return\n\n        for i, mobj in enumerate(self._maskobjs):\n            mask1 = self._rgbtomask(mobj)\n\n            # Highlight mask covering selected cursor position\n            if mask1[int(data_y), int(data_x)]:\n                self._highlight_path(self._treepaths[i])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_maskalpha(self):\n        try:\n            a = float(self.w.mask_alpha.get_text())\n        except ValueError:\n            self.logger.error('Cannot set mask alpha')\n            self.w.mask_alpha.set_text(str(self.maskalpha))\n            return\n\n        if a < 0 or a > 1:\n            self.logger.error('Alpha must be between 0 and 1, inclusive')\n            self.w.mask_alpha.set_text(str(self.maskalpha))\n            return\n\n        self.maskalpha = a", "response": "Set alpha of mask."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sync_state(self):\n        oradius = self.radius + self.width\n        if oradius < self.radius:\n            raise ValueError('Outer boundary < inner boundary')\n\n        d = dict(points=self.points, radius=self.radius, color=self.color,\n                 linewidth=self.linewidth, linestyle=self.linestyle,\n                 alpha=self.alpha)\n\n        # update inner object\n        self.objects[0].__dict__.update(d)\n\n        # update outer object\n        d['radius'] = oradius\n        self.objects[1].__dict__.update(d)", "response": "Synchronizes state of the inner and outer objects with the current state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nregister a custom WCS wrapper.", "response": "def register_wcs(name, wrapper_class, coord_types):\n    \"\"\"\n    Register a custom WCS wrapper.\n\n    Parameters\n    ----------\n    name : str\n        The name of the custom WCS wrapper\n\n    wrapper_class : subclass of `~ginga.util.wcsmod.BaseWCS`\n        The class implementing the WCS wrapper\n\n    coord_types : list of str\n        List of names of coordinate types supported by the WCS\n    \"\"\"\n    global custom_wcs\n    custom_wcs[name] = Bunch.Bunch(name=name,\n                                   wrapper_class=wrapper_class,\n                                   coord_types=coord_types)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the appropriate key code for the units value for the axes by examining the FITS header.", "response": "def choose_coord_units(header):\n    \"\"\"Return the appropriate key code for the units value for the axes by\n    examining the FITS header.\n    \"\"\"\n    cunit = header['CUNIT1']\n    match = re.match(r'^deg\\s*$', cunit)\n    if match:\n        return 'degree'\n\n    # raise WCSError(\"Don't understand units '%s'\" % (cunit))\n    return 'degree'"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_coord_system_name(header):\n    try:\n        ctype = header['CTYPE1'].strip().upper()\n    except KeyError:\n        try:\n            # see if we have an \"RA\" header\n            ra = header['RA']  # noqa\n            try:\n                equinox = float(header['EQUINOX'])\n                if equinox < 1984.0:\n                    radecsys = 'FK4'\n                else:\n                    radecsys = 'FK5'\n            except KeyError:\n                radecsys = 'ICRS'\n            return radecsys.lower()\n\n        except KeyError:\n            return 'raw'\n\n    match = re.match(r'^GLON\\-.*$', ctype)\n    if match:\n        return 'galactic'\n\n    match = re.match(r'^ELON\\-.*$', ctype)\n    if match:\n        return 'ecliptic'\n\n    match = re.match(r'^RA\\-\\-\\-.*$', ctype)\n    if match:\n        hdkey = 'RADECSYS'\n        try:\n            radecsys = header[hdkey]\n\n        except KeyError:\n            try:\n                hdkey = 'RADESYS'\n                radecsys = header[hdkey]\n            except KeyError:\n                # missing keyword\n                # RADESYS defaults to IRCS unless EQUINOX is given\n                # alone, in which case it defaults to FK4 prior to 1984\n                # and FK5 after 1984.\n                try:\n                    equinox = float(header['EQUINOX'])\n                    if equinox < 1984.0:\n                        radecsys = 'FK4'\n                    else:\n                        radecsys = 'FK5'\n                except KeyError:\n                    radecsys = 'ICRS'\n\n        radecsys = radecsys.strip()\n\n        return radecsys.lower()\n\n    match = re.match(r'^HPLN\\-.*$', ctype)\n    if match:\n        return 'helioprojective'\n\n    match = re.match(r'^HGLT\\-.*$', ctype)\n    if match:\n        return 'heliographicstonyhurst'\n\n    match = re.match(r'^PIXEL$', ctype)\n    if match:\n        return 'pixel'\n\n    match = re.match(r'^LINEAR$', ctype)\n    if match:\n        return 'pixel'\n\n    #raise WCSError(\"Cannot determine appropriate coordinate system from FITS header\")  # noqa\n    return 'icrs'", "response": "Return an appropriate coordinate system name by examining the FITS header."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef datapt_to_wcspt(self, datapt, coords='data', naxispath=None):\n        # We provide a list comprehension version for WCS packages that\n        # don't support array operations.\n        if naxispath:\n            raise NotImplementedError\n\n        return np.asarray([self.pixtoradec((pt[0], pt[1]), coords=coords)\n                           for pt in datapt])", "response": "Convert multiple data points to WCS coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wcspt_to_datapt(self, wcspt, coords='data', naxispath=None):\n        # We provide a list comprehension version for WCS packages that\n        # don't support array operations.\n        if naxispath:\n            raise NotImplementedError\n\n        return np.asarray([self.radectopix(pt[0], pt[1], coords=coords)\n                           for pt in wcspt])", "response": "Convert multiple WCS coordinates to data points."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a 2D array - like pixel coordinate system to a specific coordinate system.", "response": "def datapt_to_system(self, datapt, system=None, coords='data',\n                         naxispath=None):\n        \"\"\"\n        Map points to given coordinate system.\n\n        Parameters\n        ----------\n        datapt : array-like\n            Pixel coordinates in the format of\n            ``[[x0, y0, ...], [x1, y1, ...], ..., [xn, yn, ...]]``.\n\n        system : str or None, optional, default to 'icrs'\n            Coordinate system name.\n\n        coords : 'data' or None, optional, default to 'data'\n            Expresses whether the data coordinate is indexed from zero\n\n        naxispath : list-like or None, optional, defaults to None\n            A sequence defining the pixel indexes > 2D, if any\n\n        Returns\n        -------\n        wcspt : array-like\n            WCS coordinates in the format of\n            ``[[ra0, dec0], [ra1, dec1], ..., [ran, decn]]``.\n\n        \"\"\"\n        if self.coordsys == 'raw':\n            raise WCSError(\"No usable WCS\")\n\n        raise NotImplementedError"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfixing up bad headers that cause problems for the wrapped WCS module.", "response": "def fix_bad_headers(self):\n        \"\"\"\n        Fix up bad headers that cause problems for the wrapped WCS\n        module.\n\n        Subclass can override this method to fix up issues with the\n        header for problem FITS files.\n        \"\"\"\n        # WCSLIB doesn't like \"nonstandard\" units\n        unit = self.header.get('CUNIT1', 'deg')\n        if unit.upper() == 'DEGREE':\n            # self.header.update('CUNIT1', 'deg')\n            self.header['CUNIT1'] = 'deg'\n        unit = self.header.get('CUNIT2', 'deg')\n        if unit.upper() == 'DEGREE':\n            # self.header.update('CUNIT2', 'deg')\n            self.header['CUNIT2'] = 'deg'"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef frustum_height_at_distance(vfov_deg, distance):\n    height = 2.0 * distance * np.tan(np.radians(vfov_deg * 0.5))\n    return height", "response": "Calculate the frustum height at a given distance from the camera."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fov_for_height_and_distance(height, distance):\n    vfov_deg = np.degrees(2.0 * np.arctan(height * 0.5 / distance))\n    return vfov_deg", "response": "Calculate the FOV needed to get a given height at a given distance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_gl_transform(self):\n        tangent = np.tan(self.fov_deg / 2.0 / 180.0 * np.pi)\n        vport_radius = self.near_plane * tangent\n        # calculate aspect of the viewport\n        if self.vport_wd_px < self.vport_ht_px:\n            vport_wd = 2.0 * vport_radius\n            vport_ht = vport_wd * self.vport_ht_px / float(self.vport_wd_px)\n\n        else:\n            vport_ht = 2.0 * vport_radius\n            vport_wd = vport_ht * self.vport_wd_px / float(self.vport_ht_px)\n\n        gl.glFrustum(\n            -0.5 * vport_wd, 0.5 * vport_wd,    # left, right\n            -0.5 * vport_ht, 0.5 * vport_ht,    # bottom, top\n            self.near_plane, self.far_plane\n        )\n\n        M = Matrix4x4.look_at(self.position, self.target, self.up, False)\n        gl.glMultMatrixf(M.get())", "response": "This side effects the OpenGL context to set the view to match the camera."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the translation speed for distance_from_target in units per radius.", "response": "def get_translation_speed(self, distance_from_target):\n        \"\"\"Returns the translation speed for ``distance_from_target``\n        in units per radius.\n        \"\"\"\n        return (distance_from_target *\n                np.tan(self.fov_deg / 2.0 / 180.0 * np.pi))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\norbits the camera around the target point.", "response": "def orbit(self, x1_px, y1_px, x2_px, y2_px):\n        \"\"\"\n        Causes the camera to \"orbit\" around the target point.\n        This is also called \"tumbling\" in some software packages.\n        \"\"\"\n        px_per_deg = self.vport_radius_px / float(self.orbit_speed)\n        radians_per_px = 1.0 / px_per_deg * np.pi / 180.0\n\n        t2p = self.position - self.target\n\n        M = Matrix4x4.rotation_around_origin((x1_px - x2_px) * radians_per_px,\n                                             self.ground)\n        t2p = M * t2p\n        self.up = M * self.up\n\n        right = (self.up ^ t2p).normalized()\n        M = Matrix4x4.rotation_around_origin((y1_px - y2_px) * radians_per_px,\n                                             right)\n        t2p = M * t2p\n        self.up = M * self.up\n\n        self.position = self.target + t2p"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pan_delta(self, dx_px, dy_px):\n        direction = self.target - self.position\n        distance_from_target = direction.length()\n        direction = direction.normalized()\n\n        speed_per_radius = self.get_translation_speed(distance_from_target)\n        px_per_unit = self.vport_radius_px / speed_per_radius\n\n        right = direction ^ self.up\n\n        translation = (right * (-dx_px / px_per_unit) +\n                       self.up * (-dy_px / px_per_unit))\n\n        self.position = self.position + translation\n        self.target = self.target + translation", "response": "Pan the camera by the given delta in px."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef track(self, delta_pixels, push_target=False, adj_fov=False):\n        direction = self.target - self.position\n        distance_from_target = direction.length()\n        direction = direction.normalized()\n\n        initial_ht = frustum_height_at_distance(self.fov_deg,\n                                                distance_from_target)\n        ## print(\"frustum height at distance %.4f is %.4f\" % (\n        ##     distance_from_target, initial_ht))\n\n        speed_per_radius = self.get_translation_speed(distance_from_target)\n        px_per_unit = self.vport_radius_px / speed_per_radius\n\n        dolly_distance = delta_pixels / px_per_unit\n\n        if not push_target:\n            distance_from_target -= dolly_distance\n            if distance_from_target < self.push_threshold * self.near_plane:\n                distance_from_target = self.push_threshold * self.near_plane\n\n        self.position += direction * dolly_distance\n        self.target = self.position + direction * distance_from_target\n\n        if adj_fov:\n            # adjust FOV to match the size of the target before the dolly\n            direction = self.target - self.position\n            distance_from_target = direction.length()\n            fov_deg = fov_for_height_and_distance(initial_ht,\n                                                  distance_from_target)\n            #print(\"fov is now %.4f\" % fov_deg)\n            self.fov_deg = fov_deg", "response": "Track the camera in the frustum."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nproduce a compound object of paths implementing a wireframe.", "response": "def get_wireframe(viewer, x, y, z, **kwargs):\n    \"\"\"Produce a compound object of paths implementing a wireframe.\n    x, y, z are expected to be 2D arrays of points making up the mesh.\n    \"\"\"\n    # TODO: something like this would make a great utility function\n    # for ginga\n    n, m = x.shape\n    objs = []\n    for i in range(n):\n        pts = np.asarray([(x[i][j], y[i][j], z[i][j])\n                          for j in range(m)])\n        objs.append(viewer.dc.Path(pts, **kwargs))\n\n    for j in range(m):\n        pts = np.asarray([(x[i][j], y[i][j], z[i][j])\n                          for i in range(n)])\n        objs.append(viewer.dc.Path(pts, **kwargs))\n\n    return viewer.dc.CompoundObject(*objs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nguessing the type of a file.", "response": "def guess_filetype(filepath):\n    \"\"\"Guess the type of a file.\"\"\"\n    # If we have python-magic, use it to determine file type\n    typ = None\n\n    # Some specific checks for known file suffixes\n    _fn = filepath.lower()\n    _name, _ext = os.path.splitext(_fn)\n    if _ext in known_types:\n        typ = known_types[_ext]\n\n    if typ is None and have_magic:\n        try:\n            # it seems there are conflicting versions of a 'magic'\n            # module for python floating around...*sigh*\n            if hasattr(magic, 'from_file'):\n                typ = magic.from_file(filepath, mime=True)\n\n            elif magic_tester is not None:\n                descrip = magic_tester.file(filepath)\n                if descrip.startswith(\"FITS image data\"):\n                    return ('image', 'fits')\n\n        except Exception as e:\n            pass\n\n    if typ is None:\n        # if no magic, or magic fails, fall back to mimetypes\n        try:\n            typ, enc = mimetypes.guess_type(filepath)\n\n        except Exception as e:\n            # fail\n            pass\n\n    if typ:\n        typ, subtyp = typ.split('/')\n        return (typ, subtyp)\n\n    raise ValueError(\"Can't determine file type of '%s'\" % (filepath))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_fileinfo(filespec, cache_dir=None):\n    if cache_dir is None:\n        cache_dir = tempfile.gettempdir()\n\n    # Loads first science extension by default.\n    # This prevents [None] to be loaded instead.\n    idx = None\n    name_ext = ''\n\n    # User specified an index using bracket notation at end of path?\n    match = re.match(r'^(.+)\\[(.+)\\]$', filespec)\n    if match:\n        filespec = match.group(1)\n        idx = match.group(2)\n        if ',' in idx:\n            hduname, extver = idx.split(',')\n            hduname = hduname.strip()\n            if re.match(r'^\\d+$', extver):\n                extver = int(extver)\n                idx = (hduname, extver)\n                name_ext = \"[%s,%d]\" % idx\n            else:\n                idx = idx.strip()\n                name_ext = \"[%s]\" % idx\n        else:\n            if re.match(r'^\\d+$', idx):\n                idx = int(idx)\n                name_ext = \"[%d]\" % idx\n            else:\n                idx = idx.strip()\n                name_ext = \"[%s]\" % idx\n    else:\n        filespec = filespec\n\n    url = filespec\n    filepath = None\n\n    # Does this look like a URL?\n    match = re.match(r\"^(\\w+)://(.+)$\", filespec)\n    if match:\n        urlinfo = urllib.parse.urlparse(filespec)\n        if urlinfo.scheme == 'file':\n            # local file\n            filepath = str(pathlib.Path(urlinfo.path))\n\n        else:\n            path, filename = os.path.split(urlinfo.path)\n            filepath = get_download_path(url, filename, cache_dir)\n\n    else:\n        # Not a URL\n        filepath = filespec\n        url = pathlib.Path(os.path.abspath(filepath)).as_uri()\n\n    ondisk = os.path.exists(filepath)\n\n    dirname, fname = os.path.split(filepath)\n    fname_pfx, fname_sfx = os.path.splitext(fname)\n    name = fname_pfx + name_ext\n\n    res = Bunch.Bunch(filepath=filepath, url=url, numhdu=idx,\n                      name=name, idx=name_ext, ondisk=ondisk)\n    return res", "response": "Parse a file specification and return information about it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nshorten a name if it is longer than char_limit.", "response": "def shorten_name(name, char_limit, side='right'):\n    \"\"\"Shorten `name` if it is longer than `char_limit`.\n    If `side` == \"right\" then the right side of the name is shortened;\n    if \"left\" then the left side is shortened.\n    In either case, the suffix of the name is preserved.\n    \"\"\"\n    # TODO: A more elegant way to do this?\n    if char_limit is not None and len(name) > char_limit:\n        info = get_fileinfo(name)\n        if info.numhdu is not None:\n            i = name.rindex('[')\n            s = (name[:i], name[i:])\n            len_sfx = len(s[1])\n            len_pfx = char_limit - len_sfx - 4 + 1\n            if len_pfx > 0:\n                if side == 'right':\n                    name = '{0}...{1}'.format(s[0][:len_pfx], s[1])\n                elif side == 'left':\n                    name = '...{0}{1}'.format(s[0][-len_pfx:], s[1])\n            else:\n                name = '...{0}'.format(s[1])\n        else:\n            len1 = char_limit - 3 + 1\n            if side == 'right':\n                name = '{0}...'.format(name[:len1])\n            elif side == 'left':\n                name = '...{0}'.format(name[-len1:])\n\n    return name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_params(self, param_d):\n        for param in self.paramlst:\n            if param.name in param_d:\n                value = param_d[param.name]\n                setattr(self.obj, param.name, value)", "response": "Update the attributes in self. obj that match the keys in\n            param_d."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlike update but for retrieving values.", "response": "def fetch(self, keyDict):\n        \"\"\"Like update(), but for retrieving values.\n        \"\"\"\n        for key in keyDict:\n            keyDict[key] = self.dict[key]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nliking update but for retrieving values.", "response": "def fetch(self, keyDict):\n        \"\"\"Like update(), but for retrieving values.\n        \"\"\"\n        for key in keyDict.keys():\n            keyDict[key] = self.tbl[key]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmapping dictionary keys to values for assignment.", "response": "def setitem(self, key, value):\n        \"\"\"Maps dictionary keys to values for assignment.  Called for\n        dictionary style access with assignment.\n        \"\"\"\n        with self.lock:\n            self.tbl[key] = value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self, updict):\n\n        with self.lock:\n            for (key, value) in updict.items():\n                self.setitem(key, value)", "response": "Updates the dictionary with the keys and values from updict."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, key, alt=None):\n        with self.lock:\n            if key in self:\n                return self.getitem(key)\n\n            else:\n                return alt", "response": "Get the associated value for a key."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getsetitem(self, key, klass, args=None, kwdargs=None):\n\n        with self.lock:\n            if key in self:\n                return self.getitem(key)\n\n            # Instantiate value.\n            if not args:\n                args = []\n            if not kwdargs:\n                kwdargs = {}\n            value = klass(*args, **kwdargs)\n\n            self.setitem(key, value)\n            return value", "response": "This is similar to setdefault except that the new value is created by instantiating klass with the given args and kwdargs."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndisplaying help for the plugin.", "response": "def help(self):\n        \"\"\"Display help for the plugin.\"\"\"\n        if not self.fv.gpmon.has_plugin('WBrowser'):\n            self._help_docstring()\n            return\n\n        self.fv.start_global_plugin('WBrowser')\n\n        # need to let GUI finish processing, it seems\n        self.fv.update_pending()\n\n        obj = self.fv.gpmon.get_plugin('WBrowser')\n        obj.show_help(plugin=self, no_url_callback=self._help_docstring)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef modes_off(self):\n        bm = self.fitsimage.get_bindmap()\n        bm.reset_mode(self.fitsimage)", "response": "Turn off any mode user may be in."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexecutes the external command and get its exitcode stdout and stderr.", "response": "def get_exitcode_stdout_stderr(cmd):\n    \"\"\"\n    Execute the external command and get its exitcode, stdout and stderr.\n    \"\"\"\n    from subprocess import Popen, PIPE\n    import shlex\n    args = shlex.split(cmd)\n\n    proc = Popen(args, stdout=PIPE, stderr=PIPE)\n    out, err = proc.communicate()\n    exitcode = proc.returncode\n\n    return exitcode, out, err"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndisplays a numpy image buffer in a remote Ginga reference viewer.", "response": "def load_np(self, imname, data_np, imtype, header):\n        \"\"\"Display a numpy image buffer in a remote Ginga reference viewer.\n\n        Parameters\n        ----------\n        imname : str\n            A name to use for the image in the reference viewer.\n\n        data_np : ndarray\n            This should be at least a 2D Numpy array.\n\n        imtype : str\n            Image type--currently ignored.\n\n        header : dict\n            Fits header as a dictionary, or other keyword metadata.\n\n        Returns\n        -------\n        0\n\n        Notes\n        -----\n        * The \"RC\" plugin needs to be started in the viewer for this to work.\n        \"\"\"\n        # future: handle imtype\n\n        load_buffer = self._client.lookup_attr('load_buffer')\n\n        return load_buffer(imname, self._chname,\n                           Blob(data_np.tobytes()),\n                           data_np.shape, str(data_np.dtype),\n                           header, {}, False)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_hdu(self, imname, hdulist, num_hdu):\n        buf_io = BytesIO()\n        hdulist.writeto(buf_io)\n\n        load_fits_buffer = self._client.lookup_attr('load_fits_buffer')\n\n        return load_fits_buffer(imname, self._chname,\n                                Blob(buf_io.getvalue()),\n                                num_hdu, {})", "response": "Display an astropy. io. fits HDU in a remote Ginga reference viewer."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndisplays a FITS file buffer in a remote Ginga reference viewer.", "response": "def load_fitsbuf(self, imname, fitsbuf, num_hdu):\n        \"\"\"Display a FITS file buffer in a remote Ginga reference viewer.\n\n        Parameters\n        ----------\n        imname : str\n            A name to use for the image in the reference viewer.\n\n        chname : str\n            Name of a channel in which to load the image.\n\n        fitsbuf : str\n            This should be a valid FITS file, read in as a complete buffer.\n\n        num_hdu : int or 2-tuple\n            Number or key of the HDU to open from the buffer.\n\n        Returns\n        -------\n        0\n\n        Notes\n        -----\n        * The \"RC\" plugin needs to be started in the viewer for this to work.\n        \"\"\"\n        load_fits_buffer = self._client_.lookup_attr('load_fits_buffer')\n\n        return load_fits_buffer(imname, self._chname,\n                                Blob(fitsbuf),\n                                num_hdu, {})"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef render_image(self, rgbobj, dst_x, dst_y):\n        self.logger.debug(\"redraw surface=%s\" % (self.surface))\n        if self.surface is None:\n            return\n        self.logger.debug(\"drawing to surface\")\n\n        # Prepare array for rendering\n        # TODO: what are options for high bit depth under Qt?\n        data = rgbobj.get_array(self.rgb_order, dtype=np.uint8)\n        (height, width) = data.shape[:2]\n\n        daht, dawd, depth = data.shape\n        self.logger.debug(\"data shape is %dx%dx%d\" % (dawd, daht, depth))\n\n        # Get qimage for copying pixel data\n        qimage = self._get_qimage(data)\n        drawable = self.surface\n\n        painter = QPainter(drawable)\n        #painter.setWorldMatrixEnabled(True)\n\n        # fill surface with background color\n        #imgwin_wd, imgwin_ht = self.viewer.get_window_size()\n        size = drawable.size()\n        sf_wd, sf_ht = size.width(), size.height()\n        bg = self.viewer.img_bg\n        bgclr = self._get_color(*bg)\n        painter.fillRect(QtCore.QRect(0, 0, sf_wd, sf_ht), bgclr)\n\n        # draw image data from buffer to offscreen pixmap\n        painter.drawImage(QtCore.QRect(dst_x, dst_y, width, height),\n                          qimage,\n                          QtCore.QRect(0, 0, width, height))", "response": "Render the image represented by rgbobj at dst_x dst_y in the pixel space."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_mode_cb(self, mode, tf):\n        if tf:\n            self.canvas.set_draw_mode(mode)\n            if mode == 'edit':\n                self.edit_select_box()\n        return True", "response": "Called when one of the Move Draw or Edit radio buttons is selected."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_widget(self, canvas):\n        self.tkcanvas = canvas\n\n        canvas.bind(\"<Configure>\", self._resize_cb)\n        width = canvas.winfo_width()\n        height = canvas.winfo_height()\n\n        # see reschedule_redraw() method\n        self._defer_task = TkHelp.Timer(tkcanvas=canvas)\n        self._defer_task.add_callback('expired',\n                                      lambda timer: self.delayed_redraw())\n        self.msgtask = TkHelp.Timer(tkcanvas=canvas)\n        self.msgtask.add_callback('expired',\n                                  lambda timer: self.onscreen_message(None))\n\n        self.configure_window(width, height)", "response": "Call this method with the Tkinter canvas that will be used\n        for the display."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls when a pan operation has started.", "response": "def start_pan(self, x, y, button):\n        \"\"\"\n        Called when a pan operation has started.\n\n        *x*, *y* are the mouse coordinates in display coords.\n        button is the mouse button number:\n\n        * 1: LEFT\n        * 2: MIDDLE\n        * 3: RIGHT\n\n        .. note::\n\n            Intended to be overridden by new projection types.\n\n        \"\"\"\n        bd = self.viewer.get_bindings()\n        data_x, data_y = self.viewer.get_data_xy(x, y)\n        event = PointEvent(button=button, state='down',\n                           data_x=data_x, data_y=data_y,\n                           viewer=self.viewer)\n        if button == 1:\n            bd.ms_pan(self.viewer, event, data_x, data_y)\n        elif button == 3:\n            bd.ms_zoom(self.viewer, event, data_x, data_y)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading the data object that corresponds to the specified index expression.", "response": "def load_idx_cont(self, idx_spec, loader_cont_fn, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        idx_spec : str\n            A string in the form of a pair of brackets enclosing some\n            index expression matching HDUs in the file\n\n        loader_cont_fn : func (data_obj) -> None\n            A loader continuation function that takes a data object\n            generated from loading an HDU and does something with it\n\n        kwargs : optional keyword arguments\n            Any optional keyword arguments are passed to the code that\n            loads the data from the file\n        \"\"\"\n        if len(self) == 0:\n            raise ValueError(\"Please call open_file() first!\")\n\n        idx_lst = self.get_matching_indexes(idx_spec)\n        if len(self) == 0:\n            raise ValueError(\"Please call open_file() first!\")\n\n        for i in idx_lst:\n            try:\n                dst_obj = self.get_hdu(i, **kwargs)\n\n                loader_cont_fn(dst_obj)\n\n            except Exception as e:\n                self.logger.error(\"Error loading index '%s': %s\" % (i, str(e)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_matching_indexes(self, idx_spec):\n        # if index is missing, assume to open the first HDU we know how\n        # to do something with\n        if idx_spec is None or idx_spec == '':\n            idx, hdu = self.find_first_good_hdu()\n            return [idx]\n\n        match = re.match(r'^\\[(.+)\\]$', idx_spec)\n        if not match:\n            return []\n\n        idx_spec = match.group(1).strip()\n        if ',' in idx_spec:\n            name, extver = idx_spec.split(',')\n            name, extver = name.strip(), extver.strip()\n        else:\n            name, extver = idx_spec.strip(), None\n\n        name = name.upper()\n\n        if extver is None:\n            if re.match(r'^\\d+$', name):\n                # index just names a single HDU by number\n                return [int(name)]\n\n            # <-- assume name is an HDU name and extver is 1\n            extver = '1'\n\n        # find all HDU's matching the name and extver\n        idx_lst = []\n        idx = 0\n        for info in self.hdu_info:\n            if name == '*' or name == info.name:\n                if extver == '*' or extver == str(info.extver):\n                    idx_lst.append(info.index)\n\n        return idx_lst", "response": "Returns a list of indexes that can be used to access each HDU in the file that matches the given some\n            index expression."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_surface_as_bytes(self, order=None):\n        arr8 = self.get_surface_as_array(order=order)\n        return arr8.tobytes(order='C')", "response": "Returns the surface area as a bytes encoded RGB image buffer."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreordering the output array to match that needed by the viewer.", "response": "def reorder(self, dst_order, arr, src_order=None):\n        \"\"\"Reorder the output array to match that needed by the viewer.\"\"\"\n        if dst_order is None:\n            dst_order = self.viewer.rgb_order\n        if src_order is None:\n            src_order = self.rgb_order\n        if src_order != dst_order:\n            arr = trcalc.reorder_image(dst_order, arr, src_order)\n\n        return arr"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_cmap(name, clst):\n    global cmaps\n    assert len(clst) == min_cmap_len, \\\n        ValueError(\"color map '%s' length mismatch %d != %d (needed)\" % (\n            name, len(clst), min_cmap_len))\n    cmaps[name] = ColorMap(name, clst)", "response": "Add a color map."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert matplotlib colormap to Ginga s.", "response": "def matplotlib_to_ginga_cmap(cm, name=None):\n    \"\"\"Convert matplotlib colormap to Ginga's.\"\"\"\n    if name is None:\n        name = cm.name\n    arr = cm(np.arange(0, min_cmap_len) / np.float(min_cmap_len - 1))\n    clst = arr[:, 0:3]\n    return ColorMap(name, clst)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ginga_to_matplotlib_cmap(cm, name=None):\n    if name is None:\n        name = cm.name\n    from matplotlib.colors import ListedColormap\n    carr = np.asarray(cm.clst)\n    mpl_cm = ListedColormap(carr, name=name, N=len(carr))\n    return mpl_cm", "response": "Convert Ginga colormap to matplotlib s."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_matplotlib_cmap(cm, name=None):\n    global cmaps\n    cmap = matplotlib_to_ginga_cmap(cm, name=name)\n    cmaps[cmap.name] = cmap", "response": "Add a matplotlib colormap to the list of available matplotlib colors."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_matplotlib_cmaps(fail_on_import_error=True):\n    try:\n        from matplotlib import cm as _cm\n        from matplotlib.cbook import mplDeprecation\n    except ImportError:\n        if fail_on_import_error:\n            raise\n        # silently fail\n        return\n\n    for name in _cm.cmap_d:\n        if not isinstance(name, str):\n            continue\n        try:\n            # Do not load deprecated colormaps\n            with warnings.catch_warnings():\n                warnings.simplefilter('error', mplDeprecation)\n                cm = _cm.get_cmap(name)\n                add_matplotlib_cmap(cm, name=name)\n        except Exception as e:\n            if fail_on_import_error:\n                print(\"Error adding colormap '%s': %s\" % (name, str(e)))", "response": "Add all matplotlib colormaps."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef redo(self):\n        if self.use_slit:\n            image = self.fitsimage.get_image()\n            if image != self.cuts_image:\n                self.cuts_image = image\n                self.build_axes()\n\n        self.replot_all()", "response": "This is called when a new image arrives or the data in the\n            existing image changes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_legend(self):\n        cuts = [tag for tag in self.tags if tag is not self._new_cut]\n        self.cuts_plot.ax.legend(cuts, loc='best',\n                                 shadow=True, fancybox=True,\n                                 prop={'size': 8}, labelspacing=0.2)", "response": "Add or update Cuts plot legend."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cut_at(self, cuttype):\n        data_x, data_y = self.fitsimage.get_last_data_xy()\n        image = self.fitsimage.get_image()\n        wd, ht = image.get_size()\n\n        coords = []\n        if cuttype == 'horizontal':\n            coords.append((0, data_y, wd, data_y))\n        elif cuttype == 'vertical':\n            coords.append((data_x, 0, data_x, ht))\n\n        count = self._get_cut_index()\n        tag = \"cuts%d\" % (count)\n        cuts = []\n        for (x1, y1, x2, y2) in coords:\n            # calculate center of line\n            wd = x2 - x1\n            dw = wd // 2\n            ht = y2 - y1\n            dh = ht // 2\n            x, y = x1 + dw + 4, y1 + dh + 4\n\n            cut = self._create_cut(x, y, count, x1, y1, x2, y2, color='cyan')\n            self._update_tines(cut)\n            cuts.append(cut)\n\n        if len(cuts) == 1:\n            cut = cuts[0]\n        else:\n            cut = self._combine_cuts(*cuts)\n\n        cut.set_data(count=count)\n\n        self.canvas.delete_object_by_tag(tag)\n        self.canvas.add(cut, tag=tag)\n        self.add_cuts_tag(tag)\n\n        self.logger.debug(\"redoing cut plots\")\n        return self.replot_all()", "response": "Perform a cut at the last mouse position in the image."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_mode_cb(self, mode, tf):\n        if tf:\n            self.canvas.set_draw_mode(mode)\n            if mode == 'edit':\n                self.edit_select_cuts()\n        return True", "response": "Called when one of the Move Draw or Edit radio buttons is selected."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef redraw_cuts(self):\n        self.logger.debug(\"redrawing cuts\")\n        for cutstag in self.tags:\n            if cutstag == self._new_cut:\n                continue\n            obj = self.canvas.get_object_by_tag(cutstag)\n            if obj.kind != 'compound':\n                continue\n            self._update_tines(obj)\n        self.canvas.redraw(whence=3)", "response": "Redraws cuts with tines ( for cuts with a width"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save_cb(self, mode):\n\n        # This just defines the basename.\n        # Extension has to be explicitly defined or things can get messy.\n        w = Widgets.SaveDialog(title='Save {0} data'.format(mode))\n        filename = w.get_path()\n\n        if filename is None:\n            # user canceled dialog\n            return\n\n        # TODO: This can be a user preference?\n        fig_dpi = 100\n\n        if mode == 'cuts':\n            fig, xarr, yarr = self.cuts_plot.get_data()\n\n        elif mode == 'slit':\n            fig, xarr, yarr = self.slit_plot.get_data()\n\n        figname = filename + '.png'\n        self.logger.info(\"saving figure as: %s\" % (figname))\n        fig.savefig(figname, dpi=fig_dpi)\n\n        dataname = filename + '.npz'\n        self.logger.info(\"saving data as: %s\" % (dataname))\n        np.savez_compressed(dataname, x=xarr, y=yarr)", "response": "Save image figure and plot data arrays."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef zoom_cb(self, fitsimage, event):\n        chviewer = self.fv.getfocus_viewer()\n        bd = chviewer.get_bindings()\n\n        if hasattr(bd, 'sc_zoom'):\n            return bd.sc_zoom(chviewer, event)\n\n        return False", "response": "Zoom event in the pan window. Just zoom the channel viewer."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npinches event in the pan window. Just zoom the channel viewer.", "response": "def zoom_pinch_cb(self, fitsimage, event):\n        \"\"\"Pinch event in the pan window.  Just zoom the channel viewer.\n        \"\"\"\n        chviewer = self.fv.getfocus_viewer()\n        bd = chviewer.get_bindings()\n\n        if hasattr(bd, 'pi_zoom'):\n            return bd.pi_zoom(chviewer, event)\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pan_pan_cb(self, fitsimage, event):\n        chviewer = self.fv.getfocus_viewer()\n        bd = chviewer.get_bindings()\n\n        if hasattr(bd, 'pa_pan'):\n            return bd.pa_pan(chviewer, event)\n\n        return False", "response": "Pan event in the pan window. Just pan the channel viewer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the widget that will be used for the display.", "response": "def set_widget(self, canvas_w):\n        \"\"\"Call this method with the widget that will be used\n        for the display.\n        \"\"\"\n        self.logger.debug(\"set widget canvas_w=%s\" % canvas_w)\n        self.pgcanvas = canvas_w"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef resize(self, width, height):\n        # this shouldn't be needed\n        self.configure_window(width, height)\n\n        self.pgcanvas.resize(width, height)\n\n        # hack to force a browser reload\n        app = self.pgcanvas.get_app()\n        app.do_operation('reload_page', id=self.pgcanvas.id)", "response": "Resize our window to width x height."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(self):\n        os.system(\"cp python-bugzilla.spec /tmp\")\n        try:\n            os.system(\"rm -rf python-bugzilla-%s\" % get_version())\n            self.run_command('sdist')\n            os.system('rpmbuild -ta --clean dist/python-bugzilla-%s.tar.gz' %\n                      get_version())\n        finally:\n            os.system(\"mv /tmp/python-bugzilla.spec .\")", "response": "Run sdist then rpmbuild the tar. gz"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing XMLRPC response and return a dict of the result.", "response": "def parse_response(self, response):\n        \"\"\"\n        Parse XMLRPC response\n        \"\"\"\n        parser, unmarshaller = self.getparser()\n        parser.feed(response.text.encode('utf-8'))\n        parser.close()\n        return unmarshaller.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _request_helper(self, url, request_body):\n        response = None\n        # pylint: disable=try-except-raise\n        try:\n            response = self.session.post(\n                url, data=request_body, **self.request_defaults)\n\n            # We expect utf-8 from the server\n            response.encoding = 'UTF-8'\n\n            # update/set any cookies\n            if self._cookiejar is not None:\n                for cookie in response.cookies:\n                    self._cookiejar.set_cookie(cookie)\n\n                if self._cookiejar.filename is not None:\n                    # Save is required only if we have a filename\n                    self._cookiejar.save()\n\n            response.raise_for_status()\n            return self.parse_response(response)\n        except requests.RequestException as e:\n            if not response:\n                raise\n            raise ProtocolError(\n                url, response.status_code, str(e), response.headers)\n        except Fault:\n            raise\n        except Exception:\n            e = BugzillaError(str(sys.exc_info()[1]))\n            # pylint: disable=attribute-defined-outside-init\n            e.__traceback__ = sys.exc_info()[2]\n            # pylint: enable=attribute-defined-outside-init\n            raise e", "response": "A helper method to assist in making a request and provide a parsed\n            response."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nopens a file with the given mode.", "response": "def open_without_clobber(name, *args):\n    \"\"\"\n    Try to open the given file with the given mode; if that filename exists,\n    try \"name.1\", \"name.2\", etc. until we find an unused filename.\n    \"\"\"\n    fd = None\n    count = 1\n    orig_name = name\n    while fd is None:\n        try:\n            fd = os.open(name, os.O_CREAT | os.O_EXCL, 0o666)\n        except OSError as err:\n            if err.errno == errno.EEXIST:\n                name = \"%s.%i\" % (orig_name, count)\n                count += 1\n            else:\n                raise IOError(err.errno, err.strerror, err.filename)\n    fobj = open(name, *args)\n    if fd != fobj.fileno():\n        os.close(fd)\n    return fobj"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a default URL from bugzillarc", "response": "def get_default_url():\n    \"\"\"\n    Grab a default URL from bugzillarc [DEFAULT] url=X\n    \"\"\"\n    from bugzilla.base import _open_bugzillarc\n    cfg = _open_bugzillarc()\n    if cfg:\n        cfgurl = cfg.defaults().get(\"url\", None)\n        if cfgurl is not None:\n            log.debug(\"bugzillarc: found cli url=%s\", cfgurl)\n            return cfgurl\n    return DEFAULT_BZ"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _do_info(bz, opt):\n    # All these commands call getproducts internally, so do it up front\n    # with minimal include_fields for speed\n    def _filter_components(compdetails):\n        ret = {}\n        for k, v in compdetails.items():\n            if v.get(\"is_active\", True):\n                ret[k] = v\n        return ret\n\n    productname = (opt.components or opt.component_owners or opt.versions)\n    include_fields = [\"name\", \"id\"]\n    fastcomponents = (opt.components and not opt.active_components)\n    if opt.versions:\n        include_fields += [\"versions\"]\n    if opt.component_owners:\n        include_fields += [\n            \"components.default_assigned_to\",\n            \"components.name\",\n        ]\n    if (opt.active_components and\n        any([\"components\" in i for i in include_fields])):\n        include_fields += [\"components.is_active\"]\n\n    bz.refresh_products(names=productname and [productname] or None,\n            include_fields=include_fields)\n\n    if opt.products:\n        for name in sorted([p[\"name\"] for p in bz.getproducts()]):\n            print(name)\n\n    elif fastcomponents:\n        for name in sorted(bz.getcomponents(productname)):\n            print(name)\n\n    elif opt.components:\n        details = bz.getcomponentsdetails(productname)\n        for name in sorted(_filter_components(details)):\n            print(name)\n\n    elif opt.versions:\n        proddict = bz.getproducts()[0]\n        for v in proddict['versions']:\n            print(to_encoding(v[\"name\"]))\n\n    elif opt.component_owners:\n        details = bz.getcomponentsdetails(productname)\n        for c in sorted(_filter_components(details)):\n            print(to_encoding(u\"%s: %s\" % (c,\n                details[c]['default_assigned_to'])))", "response": "Handle the info subcommand"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _make_bz_instance(opt):\n    if opt.bztype != 'auto':\n        log.info(\"Explicit --bztype is no longer supported, ignoring\")\n\n    cookiefile = None\n    tokenfile = None\n    use_creds = False\n    if opt.cache_credentials:\n        cookiefile = opt.cookiefile or -1\n        tokenfile = opt.tokenfile or -1\n        use_creds = True\n\n    bz = bugzilla.Bugzilla(\n        url=opt.bugzilla,\n        cookiefile=cookiefile,\n        tokenfile=tokenfile,\n        sslverify=opt.sslverify,\n        use_creds=use_creds,\n        cert=opt.cert)\n    return bz", "response": "Build the Bugzilla instance we will use"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _handle_login(opt, action, bz):\n    is_login_command = (action == 'login')\n\n    do_interactive_login = (is_login_command or\n        opt.login or opt.username or opt.password)\n    username = getattr(opt, \"pos_username\", None) or opt.username\n    password = getattr(opt, \"pos_password\", None) or opt.password\n\n    try:\n        if do_interactive_login:\n            if bz.url:\n                print(\"Logging into %s\" % urlparse(bz.url)[1])\n            bz.interactive_login(username, password,\n                    restrict_login=opt.restrict_login)\n    except bugzilla.BugzillaError as e:\n        print(str(e))\n        sys.exit(1)\n\n    if opt.ensure_logged_in and not bz.logged_in:\n        print(\"--ensure-logged-in passed but you aren't logged in to %s\" %\n            bz.url)\n        sys.exit(1)\n\n    if is_login_command:\n        msg = \"Login successful.\"\n        if bz.cookiefile or bz.tokenfile:\n            msg = \"Login successful, token cache updated.\"\n\n        print(msg)\n        sys.exit(0)", "response": "Handle all login related bits"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndetermining auth location for filename.", "response": "def _default_auth_location(filename):\n    \"\"\"\n    Determine auth location for filename, like 'bugzillacookies'. If\n    old style ~/.bugzillacookies exists, we use that, otherwise we\n    use ~/.cache/python-bugzilla/bugzillacookies. Same for bugzillatoken\n    \"\"\"\n    homepath = os.path.expanduser(\"~/.%s\" % filename)\n    xdgpath = os.path.expanduser(\"~/.cache/python-bugzilla/%s\" % filename)\n    if os.path.exists(xdgpath):\n        return xdgpath\n    if os.path.exists(homepath):\n        return homepath\n\n    if not os.path.exists(os.path.dirname(xdgpath)):\n        os.makedirs(os.path.dirname(xdgpath), 0o700)\n    return xdgpath"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngiving a big huge bugzilla query URL returns a query dict that can be passed along to the Bugzilla. query method.", "response": "def url_to_query(url):\n        \"\"\"\n        Given a big huge bugzilla query URL, returns a query dict that can\n        be passed along to the Bugzilla.query() method.\n        \"\"\"\n        q = {}\n\n        # pylint: disable=unpacking-non-sequence\n        (ignore, ignore, path,\n         ignore, query, ignore) = urlparse(url)\n\n        base = os.path.basename(path)\n        if base not in ('buglist.cgi', 'query.cgi'):\n            return {}\n\n        for (k, v) in parse_qsl(query):\n            if k not in q:\n                q[k] = v\n            elif isinstance(q[k], list):\n                q[k].append(v)\n            else:\n                oldv = q[k]\n                q[k] = [oldv, v]\n\n        # Handle saved searches\n        if base == \"buglist.cgi\" and \"namedcmd\" in q and \"sharer_id\" in q:\n            q = {\n                \"sharer_id\": q[\"sharer_id\"],\n                \"savedsearch\": q[\"namedcmd\"],\n            }\n\n        return q"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fix_url(url):\n        if '://' not in url:\n            log.debug('No scheme given for url, assuming https')\n            url = 'https://' + url\n        if url.count('/') < 3:\n            log.debug('No path given for url, assuming /xmlrpc.cgi')\n            url = url + '/xmlrpc.cgi'\n        return url", "response": "Convert a bugzilla XMLRPC web url into a bugzilla XMLRPC web url"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _init_class_from_url(self):\n        from bugzilla import RHBugzilla\n        if isinstance(self, RHBugzilla):\n            return\n\n        c = None\n        if \"bugzilla.redhat.com\" in self.url:\n            log.info(\"Using RHBugzilla for URL containing bugzilla.redhat.com\")\n            c = RHBugzilla\n        else:\n            try:\n                extensions = self._proxy.Bugzilla.extensions()\n                if \"RedHat\" in extensions.get('extensions', {}):\n                    log.info(\"Found RedHat bugzilla extension, \"\n                        \"using RHBugzilla\")\n                    c = RHBugzilla\n            except Fault:\n                log.debug(\"Failed to fetch bugzilla extensions\", exc_info=True)\n\n        if not c:\n            return\n\n        self.__class__ = c", "response": "Detect if we should use RHBugzilla class and if so set it otherwise return None."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the detected bugzilla version is < passed major and minor pair.", "response": "def _check_version(self, major, minor):\n        \"\"\"\n        Check if the detected bugzilla version is >= passed major/minor pair.\n        \"\"\"\n        if major < self.bz_ver_major:\n            return True\n        if (major == self.bz_ver_major and minor <= self.bz_ver_minor):\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readconfig(self, configpath=None):\n        cfg = _open_bugzillarc(configpath or self.configpath)\n        if not cfg:\n            return\n\n        section = \"\"\n        log.debug(\"bugzillarc: Searching for config section matching %s\",\n            self.url)\n\n        def _parse_hostname(_u):\n            # If http://example.com is passed, netloc=example.com path=\"\"\n            # If just example.com is passed, netloc=\"\" path=example.com\n            parsedbits = urlparse(self.url)\n            return parsedbits.netloc or parsedbits.path\n\n        urlhost = _parse_hostname(self.url)\n        for sectionhost in sorted(cfg.sections()):\n            # If the section is just a hostname, make it match\n            # If the section has a / in it, do a substring match\n            if \"/\" not in sectionhost:\n                if sectionhost == urlhost:\n                    section = sectionhost\n            elif sectionhost in self.url:\n                section = sectionhost\n            if section:\n                log.debug(\"bugzillarc: Found matching section: %s\", section)\n                break\n\n        if not section:\n            log.debug(\"bugzillarc: No section found\")\n            return\n\n        for key, val in cfg.items(section):\n            if key == \"api_key\":\n                log.debug(\"bugzillarc: setting api_key\")\n                self.api_key = val\n            elif key == \"user\":\n                log.debug(\"bugzillarc: setting user=%s\", val)\n                self.user = val\n            elif key == \"password\":\n                log.debug(\"bugzillarc: setting password\")\n                self.password = val\n            elif key == \"cert\":\n                log.debug(\"bugzillarc: setting cert\")\n                self.cert = val\n            else:\n                log.debug(\"bugzillarc: unknown key=%s\", key)", "response": "Reads the bugzillarc file and returns a dictionary of bugzillarc names and values."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef connect(self, url=None):\n        if self._transport:\n            self.disconnect()\n\n        if url is None and self.url:\n            url = self.url\n        url = self.fix_url(url)\n\n        self._transport = _RequestsTransport(\n            url, self._cookiejar, sslverify=self._sslverify, cert=self.cert)\n        self._transport.user_agent = self.user_agent\n        self._proxy = _BugzillaServerProxy(url, self.tokenfile,\n            self._transport)\n\n        self.url = url\n        # we've changed URLs - reload config\n        self.readconfig()\n\n        if (self.user and self.password):\n            log.info(\"user and password present - doing login()\")\n            self.login()\n\n        if self.api_key:\n            log.debug(\"using API key\")\n            self._proxy.use_api_key(self.api_key)\n\n        version = self._proxy.Bugzilla.version()[\"version\"]\n        log.debug(\"Bugzilla version string: %s\", version)\n        self._set_bz_version(version)", "response": "Connect to the bugzilla instance with the given URL."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _login(self, user, password, restrict_login=None):\n        payload = {'login': user, 'password': password}\n        if restrict_login:\n            payload['restrict_login'] = True\n\n        return self._proxy.User.login(payload)", "response": "Backend login method for Bugzilla3"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef login(self, user=None, password=None, restrict_login=None):\n        if self.api_key:\n            raise ValueError(\"cannot login when using an API key\")\n\n        if user:\n            self.user = user\n        if password:\n            self.password = password\n\n        if not self.user:\n            raise ValueError(\"missing username\")\n        if not self.password:\n            raise ValueError(\"missing password\")\n\n        if restrict_login:\n            log.info(\"logging in with restrict_login=True\")\n\n        try:\n            ret = self._login(self.user, self.password, restrict_login)\n            self.password = ''\n            log.info(\"login successful for user=%s\", self.user)\n            return ret\n        except Fault as e:\n            raise BugzillaError(\"Login failed: %s\" % str(e.faultString))", "response": "Login to Bugzilla API key."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef interactive_login(self, user=None, password=None, force=False,\n                          restrict_login=None):\n        \"\"\"\n        Helper method to handle login for this bugzilla instance.\n\n        :param user: bugzilla username. If not specified, prompt for it.\n        :param password: bugzilla password. If not specified, prompt for it.\n        :param force: Unused\n        :param restrict_login: restricts session to IP address\n        \"\"\"\n        ignore = force\n        log.debug('Calling interactive_login')\n\n        if not user:\n            sys.stdout.write('Bugzilla Username: ')\n            sys.stdout.flush()\n            user = sys.stdin.readline().strip()\n        if not password:\n            password = getpass.getpass('Bugzilla Password: ')\n\n        log.info('Logging in... ')\n        self.login(user, password, restrict_login)\n        log.info('Authorization cookie received.')", "response": "This method is used to handle interactive login for bugzilla instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef logout(self):\n        self._logout()\n        self.disconnect()\n        self.user = ''\n        self.password = ''", "response": "Log out of bugzilla."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if this instance is logged in False otherwise.", "response": "def logged_in(self):\n        \"\"\"\n        This is True if this instance is logged in else False.\n\n        We test if this session is authenticated by calling the User.get()\n        XMLRPC method with ids set. Logged-out users cannot pass the 'ids'\n        parameter and will result in a 505 error. If we tried to login with a\n        token, but the token was incorrect or expired, the server returns a\n        32000 error.\n\n        For Bugzilla 5 and later, a new method, User.valid_login is available\n        to test the validity of the token. However, this will require that the\n        username be cached along with the token in order to work effectively in\n        all scenarios and is not currently used. For more information, refer to\n        the following url.\n\n        http://bugzilla.readthedocs.org/en/latest/api/core/v1/user.html#valid-login\n        \"\"\"\n        try:\n            self._proxy.User.get({'ids': []})\n            return True\n        except Fault as e:\n            if e.faultCode == 505 or e.faultCode == 32000:\n                return False\n            raise e"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _getbugfields(self):\n        r = self._proxy.Bug.fields({'include_fields': ['name']})\n        return [f['name'] for f in r['fields']]", "response": "Get the list of valid fields for Bug objects\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of fields in each bugzilla instance.", "response": "def getbugfields(self, force_refresh=False):\n        \"\"\"\n        Calls getBugFields, which returns a list of fields in each bug\n        for this bugzilla instance. This can be used to set the list of attrs\n        on the Bug object.\n        \"\"\"\n        if force_refresh or not self._cache.bugfields:\n            log.debug(\"Refreshing bugfields\")\n            self._cache.bugfields = self._getbugfields()\n            self._cache.bugfields.sort()\n            log.debug(\"bugfields = %s\", self._cache.bugfields)\n\n        return self._cache.bugfields"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef product_get(self, ids=None, names=None,\n                    include_fields=None, exclude_fields=None,\n                    ptype=None):\n        \"\"\"\n        Raw wrapper around Product.get\n        https://bugzilla.readthedocs.io/en/latest/api/core/v1/product.html#get-product\n\n        This does not perform any caching like other product API calls.\n        If ids, names, or ptype is not specified, we default to\n        ptype=accessible for historical reasons\n\n        @ids: List of product IDs to lookup\n        @names: List of product names to lookup\n        @ptype: Either 'accessible', 'selectable', or 'enterable'. If\n            specified, we return data for all those\n        @include_fields: Only include these fields in the output\n        @exclude_fields: Do not include these fields in the output\n        \"\"\"\n        if ids is None and names is None and ptype is None:\n            ptype = \"accessible\"\n\n        if ptype:\n            raw = None\n            if ptype == \"accessible\":\n                raw = self._proxy.Product.get_accessible_products()\n            elif ptype == \"selectable\":\n                raw = self._proxy.Product.get_selectable_products()\n            elif ptype == \"enterable\":\n                raw = self._proxy.Product.get_enterable_products()\n\n            if raw is None:\n                raise RuntimeError(\"Unknown ptype=%s\" % ptype)\n            ids = raw['ids']\n            log.debug(\"For ptype=%s found ids=%s\", ptype, ids)\n\n        kwargs = {}\n        if ids:\n            kwargs[\"ids\"] = self._listify(ids)\n        if names:\n            kwargs[\"names\"] = self._listify(names)\n        if include_fields:\n            kwargs[\"include_fields\"] = include_fields\n        if exclude_fields:\n            kwargs[\"exclude_fields\"] = exclude_fields\n\n        ret = self._proxy.Product.get(kwargs)\n        return ret['products']", "response": "Get a list of product objects from the API."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrefreshes a product s cached info.", "response": "def refresh_products(self, **kwargs):\n        \"\"\"\n        Refresh a product's cached info. Basically calls product_get\n        with the passed arguments, and tries to intelligently update\n        our product cache.\n\n        For example, if we already have cached info for product=foo,\n        and you pass in names=[\"bar\", \"baz\"], the new cache will have\n        info for products foo, bar, baz. Individual product fields are\n        also updated.\n        \"\"\"\n        for product in self.product_get(**kwargs):\n            updated = False\n            for current in self._cache.products[:]:\n                if (current.get(\"id\", -1) != product.get(\"id\", -2) and\n                    current.get(\"name\", -1) != product.get(\"name\", -2)):\n                    continue\n\n                _nested_update(current, product)\n                updated = True\n                break\n            if not updated:\n                self._cache.products.append(product)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nquery all the products and return the raw dict info.", "response": "def getproducts(self, force_refresh=False, **kwargs):\n        \"\"\"\n        Query all products and return the raw dict info. Takes all the\n        same arguments as product_get.\n\n        On first invocation this will contact bugzilla and internally\n        cache the results. Subsequent getproducts calls or accesses to\n        self.products will return this cached data only.\n\n        :param force_refresh: force refreshing via refresh_products()\n        \"\"\"\n        if force_refresh or not self._cache.products:\n            self.refresh_products(**kwargs)\n        return self._cache.products"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getcomponentsdetails(self, product, force_refresh=False):\n        proddict = self._lookup_product_in_cache(product)\n\n        if (force_refresh or not proddict or \"components\" not in proddict):\n            self.refresh_products(names=[product],\n                                  include_fields=[\"name\", \"id\", \"components\"])\n            proddict = self._lookup_product_in_cache(product)\n\n        ret = {}\n        for compdict in proddict[\"components\"]:\n            ret[compdict[\"name\"]] = compdict\n        return ret", "response": "Wrapper around Product. get and return only the components data for the requested product."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getcomponentdetails(self, product, component, force_refresh=False):\n        d = self.getcomponentsdetails(product, force_refresh)\n        return d[component]", "response": "Get information about a single component."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getcomponents(self, product, force_refresh=False):\n        proddict = self._lookup_product_in_cache(product)\n        product_id = proddict.get(\"id\", None)\n\n        if (force_refresh or\n            product_id is None or\n            product_id not in self._cache.component_names):\n            self.refresh_products(names=[product],\n                                  include_fields=[\"name\", \"id\"])\n            proddict = self._lookup_product_in_cache(product)\n            if \"id\" not in proddict:\n                raise BugzillaError(\"Product '%s' not found\" % product)\n            product_id = proddict[\"id\"]\n\n            opts = {'product_id': product_id, 'field': 'component'}\n            names = self._proxy.Bug.legal_values(opts)[\"values\"]\n            self._cache.component_names[product_id] = names\n\n        return self._cache.component_names[product_id]", "response": "Get a list of component names for the passed product."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _process_include_fields(self, include_fields, exclude_fields,\n                                extra_fields):\n        \"\"\"\n        Internal helper to process include_fields lists\n        \"\"\"\n        def _convert_fields(_in):\n            if not _in:\n                return _in\n\n            for newname, oldname in self._get_api_aliases():\n                if oldname in _in:\n                    _in.remove(oldname)\n                    if newname not in _in:\n                        _in.append(newname)\n            return _in\n\n        ret = {}\n        if self._check_version(4, 0):\n            if include_fields:\n                include_fields = _convert_fields(include_fields)\n                if \"id\" not in include_fields:\n                    include_fields.append(\"id\")\n                ret[\"include_fields\"] = include_fields\n            if exclude_fields:\n                exclude_fields = _convert_fields(exclude_fields)\n                ret[\"exclude_fields\"] = exclude_fields\n        if self._supports_getbug_extra_fields:\n            if extra_fields:\n                ret[\"extra_fields\"] = _convert_fields(extra_fields)\n        return ret", "response": "Internal helper to process include_fields lists\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a list of full bug info for each given bug id.", "response": "def _getbugs(self, idlist, permissive,\n            include_fields=None, exclude_fields=None, extra_fields=None):\n        \"\"\"\n        Return a list of dicts of full bug info for each given bug id.\n        bug ids that couldn't be found will return None instead of a dict.\n        \"\"\"\n        oldidlist = idlist\n        idlist = []\n        for i in oldidlist:\n            try:\n                idlist.append(int(i))\n            except ValueError:\n                # String aliases can be passed as well\n                idlist.append(i)\n\n        extra_fields = self._listify(extra_fields or [])\n        extra_fields += self._getbug_extra_fields\n\n        getbugdata = {\"ids\": idlist}\n        if permissive:\n            getbugdata[\"permissive\"] = 1\n\n        getbugdata.update(self._process_include_fields(\n            include_fields, exclude_fields, extra_fields))\n\n        r = self._proxy.Bug.get(getbugdata)\n\n        if self._check_version(4, 0):\n            bugdict = dict([(b['id'], b) for b in r['bugs']])\n        else:\n            bugdict = dict([(b['id'], b['internals']) for b in r['bugs']])\n\n        ret = []\n        for i in idlist:\n            found = None\n            if i in bugdict:\n                found = bugdict[i]\n            else:\n                # Need to map an alias\n                for valdict in bugdict.values():\n                    if i in self._listify(valdict.get(\"alias\", None)):\n                        found = valdict\n                        break\n\n            ret.append(found)\n\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrap around _getbugs to handle the special tweaks argument", "response": "def _getbug(self, objid, **kwargs):\n        \"\"\"\n        Thin wrapper around _getbugs to handle the slight argument tweaks\n        for fetching a single bug. The main bit is permissive=False, which\n        will tell bugzilla to raise an explicit error if we can't fetch\n        that bug.\n\n        This logic is called from Bug() too\n        \"\"\"\n        return self._getbugs([objid], permissive=False, **kwargs)[0]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a Bug object from the full complement of the bug data.", "response": "def getbug(self, objid,\n               include_fields=None, exclude_fields=None, extra_fields=None):\n        \"\"\"\n        Return a Bug object with the full complement of bug data\n        already loaded.\n        \"\"\"\n        data = self._getbug(objid,\n            include_fields=include_fields, exclude_fields=exclude_fields,\n            extra_fields=extra_fields)\n        return Bug(self, dict=data, autorefresh=self.bug_autorefresh)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a list of Bug objects with the full complement of bug data for a given id.", "response": "def getbugs(self, idlist,\n                include_fields=None, exclude_fields=None, extra_fields=None,\n                permissive=True):\n        \"\"\"\n        Return a list of Bug objects with the full complement of bug data\n        already loaded. If there's a problem getting the data for a given id,\n        the corresponding item in the returned list will be None.\n        \"\"\"\n        data = self._getbugs(idlist, include_fields=include_fields,\n            exclude_fields=exclude_fields, extra_fields=extra_fields,\n            permissive=permissive)\n        return [(b and Bug(self, dict=b,\n                           autorefresh=self.bug_autorefresh)) or None\n                for b in data]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding a query string from passed arguments.", "response": "def build_query(self,\n                    product=None,\n                    component=None,\n                    version=None,\n                    long_desc=None,\n                    bug_id=None,\n                    short_desc=None,\n                    cc=None,\n                    assigned_to=None,\n                    reporter=None,\n                    qa_contact=None,\n                    status=None,\n                    blocked=None,\n                    dependson=None,\n                    keywords=None,\n                    keywords_type=None,\n                    url=None,\n                    url_type=None,\n                    status_whiteboard=None,\n                    status_whiteboard_type=None,\n                    fixed_in=None,\n                    fixed_in_type=None,\n                    flag=None,\n                    alias=None,\n                    qa_whiteboard=None,\n                    devel_whiteboard=None,\n                    boolean_query=None,\n                    bug_severity=None,\n                    priority=None,\n                    target_release=None,\n                    target_milestone=None,\n                    emailtype=None,\n                    booleantype=None,\n                    include_fields=None,\n                    quicksearch=None,\n                    savedsearch=None,\n                    savedsearch_sharer_id=None,\n                    sub_component=None,\n                    tags=None,\n                    exclude_fields=None,\n                    extra_fields=None):\n        \"\"\"\n        Build a query string from passed arguments. Will handle\n        query parameter differences between various bugzilla versions.\n\n        Most of the parameters should be self-explanatory. However,\n        if you want to perform a complex query, and easy way is to\n        create it with the bugzilla web UI, copy the entire URL it\n        generates, and pass it to the static method\n\n        Bugzilla.url_to_query\n\n        Then pass the output to Bugzilla.query()\n\n        For details about the specific argument formats, see the bugzilla docs:\n        https://bugzilla.readthedocs.io/en/latest/api/core/v1/bug.html#search-bugs\n        \"\"\"\n        if boolean_query or booleantype:\n            raise RuntimeError(\"boolean_query format is no longer supported. \"\n                \"If you need complicated URL queries, look into \"\n                \"query --from-url/url_to_query().\")\n\n        query = {\n            \"alias\": alias,\n            \"product\": self._listify(product),\n            \"component\": self._listify(component),\n            \"version\": version,\n            \"id\": bug_id,\n            \"short_desc\": short_desc,\n            \"bug_status\": status,\n            \"bug_severity\": bug_severity,\n            \"priority\": priority,\n            \"target_release\": target_release,\n            \"target_milestone\": target_milestone,\n            \"tag\": self._listify(tags),\n            \"quicksearch\": quicksearch,\n            \"savedsearch\": savedsearch,\n            \"sharer_id\": savedsearch_sharer_id,\n\n            # RH extensions... don't add any more. See comment below\n            \"sub_components\": self._listify(sub_component),\n        }\n\n        def add_bool(bzkey, value, bool_id, booltype=None):\n            value = self._listify(value)\n            if value is None:\n                return bool_id\n\n            query[\"query_format\"] = \"advanced\"\n            for boolval in value:\n                def make_bool_str(prefix):\n                    # pylint: disable=cell-var-from-loop\n                    return \"%s%i-0-0\" % (prefix, bool_id)\n\n                query[make_bool_str(\"field\")] = bzkey\n                query[make_bool_str(\"value\")] = boolval\n                query[make_bool_str(\"type\")] = booltype or \"substring\"\n\n                bool_id += 1\n            return bool_id\n\n        # RH extensions that we have to maintain here for back compat,\n        # but all future custom fields should be specified via\n        # cli --field option, or via extending the query dict() manually.\n        # No more supporting custom fields in this API\n        bool_id = 0\n        bool_id = add_bool(\"keywords\", keywords, bool_id, keywords_type)\n        bool_id = add_bool(\"blocked\", blocked, bool_id)\n        bool_id = add_bool(\"dependson\", dependson, bool_id)\n        bool_id = add_bool(\"bug_file_loc\", url, bool_id, url_type)\n        bool_id = add_bool(\"cf_fixed_in\", fixed_in, bool_id, fixed_in_type)\n        bool_id = add_bool(\"flagtypes.name\", flag, bool_id)\n        bool_id = add_bool(\"status_whiteboard\",\n                           status_whiteboard, bool_id, status_whiteboard_type)\n        bool_id = add_bool(\"cf_qa_whiteboard\", qa_whiteboard, bool_id)\n        bool_id = add_bool(\"cf_devel_whiteboard\", devel_whiteboard, bool_id)\n\n        def add_email(key, value, count):\n            if value is None:\n                return count\n            if not emailtype:\n                query[key] = value\n                return count\n\n            query[\"query_format\"] = \"advanced\"\n            query['email%i' % count] = value\n            query['email%s%i' % (key, count)] = True\n            query['emailtype%i' % count] = emailtype\n            return count + 1\n\n        email_count = 1\n        email_count = add_email(\"cc\", cc, email_count)\n        email_count = add_email(\"assigned_to\", assigned_to, email_count)\n        email_count = add_email(\"reporter\", reporter, email_count)\n        email_count = add_email(\"qa_contact\", qa_contact, email_count)\n\n        if long_desc is not None:\n            query[\"query_format\"] = \"advanced\"\n            query[\"longdesc\"] = long_desc\n            query[\"longdesc_type\"] = \"allwordssubstr\"\n\n        # 'include_fields' only available for Bugzilla4+\n        # 'extra_fields' is an RHBZ extension\n        query.update(self._process_include_fields(\n            include_fields, exclude_fields, extra_fields))\n\n        # Strip out None elements in the dict\n        for k, v in query.copy().items():\n            if v is None:\n                del(query[k])\n\n        self.pre_translation(query)\n        return query"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nquery bugzilla and return a list of matching bugs.", "response": "def query(self, query):\n        \"\"\"\n        Query bugzilla and return a list of matching bugs.\n        query must be a dict with fields like those in in querydata['fields'].\n        Returns a list of Bug objects.\n        Also see the _query() method for details about the underlying\n        implementation.\n        \"\"\"\n        try:\n            r = self._proxy.Bug.search(query)\n        except Fault as e:\n\n            # Try to give a hint in the error message if url_to_query\n            # isn't supported by this bugzilla instance\n            if (\"query_format\" not in str(e) or\n                \"RHBugzilla\" in str(e.__class__) or\n                self._check_version(5, 0)):\n                raise\n            raise BugzillaError(\"%s\\nYour bugzilla instance does not \"\n                \"appear to support API queries derived from bugzilla \"\n                \"web URL queries.\" % e)\n\n        log.debug(\"Query returned %s bugs\", len(r['bugs']))\n        return [Bug(self, dict=b,\n                autorefresh=self.bug_autorefresh) for b in r['bugs']]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the bug reports with the given IDs.", "response": "def update_bugs(self, ids, updates):\n        \"\"\"\n        A thin wrapper around bugzilla Bug.update(). Used to update all\n        values of an existing bug report, as well as add comments.\n\n        The dictionary passed to this function should be generated with\n        build_update(), otherwise we cannot guarantee back compatibility.\n        \"\"\"\n        tmp = updates.copy()\n        tmp[\"ids\"] = self._listify(ids)\n\n        return self._proxy.Bug.update(tmp)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_tags(self, idlist, tags_add=None, tags_remove=None):\n        tags = {}\n        if tags_add:\n            tags[\"add\"] = self._listify(tags_add)\n        if tags_remove:\n            tags[\"remove\"] = self._listify(tags_remove)\n\n        d = {\n            \"ids\": self._listify(idlist),\n            \"tags\": tags,\n        }\n\n        return self._proxy.Bug.update_tags(d)", "response": "Updates the tags field for a bug."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_flags(self, idlist, flags):\n        return self.update_bugs(idlist, self.build_update(flags=flags))", "response": "Update the flags of the bugs in the given idlist."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef build_update(self,\n                     alias=None,\n                     assigned_to=None,\n                     blocks_add=None,\n                     blocks_remove=None,\n                     blocks_set=None,\n                     depends_on_add=None,\n                     depends_on_remove=None,\n                     depends_on_set=None,\n                     cc_add=None,\n                     cc_remove=None,\n                     is_cc_accessible=None,\n                     comment=None,\n                     comment_private=None,\n                     component=None,\n                     deadline=None,\n                     dupe_of=None,\n                     estimated_time=None,\n                     groups_add=None,\n                     groups_remove=None,\n                     keywords_add=None,\n                     keywords_remove=None,\n                     keywords_set=None,\n                     op_sys=None,\n                     platform=None,\n                     priority=None,\n                     product=None,\n                     qa_contact=None,\n                     is_creator_accessible=None,\n                     remaining_time=None,\n                     reset_assigned_to=None,\n                     reset_qa_contact=None,\n                     resolution=None,\n                     see_also_add=None,\n                     see_also_remove=None,\n                     severity=None,\n                     status=None,\n                     summary=None,\n                     target_milestone=None,\n                     target_release=None,\n                     url=None,\n                     version=None,\n                     whiteboard=None,\n                     work_time=None,\n                     fixed_in=None,\n                     qa_whiteboard=None,\n                     devel_whiteboard=None,\n                     internal_whiteboard=None,\n                     sub_component=None,\n                     flags=None,\n                     comment_tags=None):\n        \"\"\"\n        Returns a python dict() with properly formatted parameters to\n        pass to update_bugs(). See bugzilla documentation for the format\n        of the individual fields:\n\n        https://bugzilla.readthedocs.io/en/latest/api/core/v1/bug.html#create-bug\n        \"\"\"\n        ret = {}\n\n        # These are only supported for rhbugzilla\n        for key, val in [\n            (\"fixed_in\", fixed_in),\n            (\"devel_whiteboard\", devel_whiteboard),\n            (\"qa_whiteboard\", qa_whiteboard),\n            (\"internal_whiteboard\", internal_whiteboard),\n            (\"sub_component\", sub_component),\n        ]:\n            if val is not None:\n                raise ValueError(\"bugzilla instance does not support \"\n                                 \"updating '%s'\" % key)\n\n        def s(key, val, convert=None):\n            if val is None:\n                return\n            if convert:\n                val = convert(val)\n            ret[key] = val\n\n        def add_dict(key, add, remove, _set=None, convert=None):\n            if add is remove is _set is None:\n                return\n\n            def c(val):\n                val = self._listify(val)\n                if convert:\n                    val = [convert(v) for v in val]\n                return val\n\n            newdict = {}\n            if add is not None:\n                newdict[\"add\"] = c(add)\n            if remove is not None:\n                newdict[\"remove\"] = c(remove)\n            if _set is not None:\n                newdict[\"set\"] = c(_set)\n            ret[key] = newdict\n\n\n        s(\"alias\", alias)\n        s(\"assigned_to\", assigned_to)\n        s(\"is_cc_accessible\", is_cc_accessible, bool)\n        s(\"component\", component)\n        s(\"deadline\", deadline)\n        s(\"dupe_of\", dupe_of, int)\n        s(\"estimated_time\", estimated_time, int)\n        s(\"op_sys\", op_sys)\n        s(\"platform\", platform)\n        s(\"priority\", priority)\n        s(\"product\", product)\n        s(\"qa_contact\", qa_contact)\n        s(\"is_creator_accessible\", is_creator_accessible, bool)\n        s(\"remaining_time\", remaining_time, float)\n        s(\"reset_assigned_to\", reset_assigned_to, bool)\n        s(\"reset_qa_contact\", reset_qa_contact, bool)\n        s(\"resolution\", resolution)\n        s(\"severity\", severity)\n        s(\"status\", status)\n        s(\"summary\", summary)\n        s(\"target_milestone\", target_milestone)\n        s(\"target_release\", target_release)\n        s(\"url\", url)\n        s(\"version\", version)\n        s(\"whiteboard\", whiteboard)\n        s(\"work_time\", work_time, float)\n        s(\"flags\", flags)\n        s(\"comment_tags\", comment_tags, self._listify)\n\n        add_dict(\"blocks\", blocks_add, blocks_remove, blocks_set,\n                 convert=int)\n        add_dict(\"depends_on\", depends_on_add, depends_on_remove,\n                 depends_on_set, convert=int)\n        add_dict(\"cc\", cc_add, cc_remove)\n        add_dict(\"groups\", groups_add, groups_remove)\n        add_dict(\"keywords\", keywords_add, keywords_remove, keywords_set)\n        add_dict(\"see_also\", see_also_add, see_also_remove)\n\n        if comment is not None:\n            ret[\"comment\"] = {\"comment\": comment}\n            if comment_private:\n                ret[\"comment\"][\"is_private\"] = comment_private\n\n        return ret", "response": "Build a dictionary of parameters to be used in update_bugs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _attachment_uri(self, attachid):\n        att_uri = self.url.replace('xmlrpc.cgi', 'attachment.cgi')\n        att_uri = att_uri + '?id=%s' % attachid\n        return att_uri", "response": "Returns the URI for the given attachment ID."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nattaching a file to a list of bug IDs.", "response": "def attachfile(self, idlist, attachfile, description, **kwargs):\n        \"\"\"\n        Attach a file to the given bug IDs. Returns the ID of the attachment\n        or raises XMLRPC Fault if something goes wrong.\n\n        attachfile may be a filename (which will be opened) or a file-like\n        object, which must provide a 'read' method. If it's not one of these,\n        this method will raise a TypeError.\n        description is the short description of this attachment.\n\n        Optional keyword args are as follows:\n            file_name:  this will be used as the filename for the attachment.\n                       REQUIRED if attachfile is a file-like object with no\n                       'name' attribute, otherwise the filename or .name\n                       attribute will be used.\n            comment:   An optional comment about this attachment.\n            is_private: Set to True if the attachment should be marked private.\n            is_patch:   Set to True if the attachment is a patch.\n            content_type: The mime-type of the attached file. Defaults to\n                          application/octet-stream if not set. NOTE that text\n                          files will *not* be viewable in bugzilla unless you\n                          remember to set this to text/plain. So remember that!\n\n        Returns the list of attachment ids that were added. If only one\n        attachment was added, we return the single int ID for back compat\n        \"\"\"\n        if isinstance(attachfile, str):\n            f = open(attachfile, \"rb\")\n        elif hasattr(attachfile, 'read'):\n            f = attachfile\n        else:\n            raise TypeError(\"attachfile must be filename or file-like object\")\n\n        # Back compat\n        if \"contenttype\" in kwargs:\n            kwargs[\"content_type\"] = kwargs.pop(\"contenttype\")\n        if \"ispatch\" in kwargs:\n            kwargs[\"is_patch\"] = kwargs.pop(\"ispatch\")\n        if \"isprivate\" in kwargs:\n            kwargs[\"is_private\"] = kwargs.pop(\"isprivate\")\n        if \"filename\" in kwargs:\n            kwargs[\"file_name\"] = kwargs.pop(\"filename\")\n\n        kwargs['summary'] = description\n\n        data = f.read()\n        if not isinstance(data, bytes):\n            data = data.encode(locale.getpreferredencoding())\n        kwargs['data'] = Binary(data)\n\n        kwargs['ids'] = self._listify(idlist)\n\n        if 'file_name' not in kwargs and hasattr(f, \"name\"):\n            kwargs['file_name'] = os.path.basename(f.name)\n        if 'content_type' not in kwargs:\n            ctype = None\n            if kwargs['file_name']:\n                ctype = mimetypes.guess_type(\n                    kwargs['file_name'], strict=False)[0]\n            kwargs['content_type'] = ctype or 'application/octet-stream'\n\n        ret = self._proxy.Bug.add_attachment(kwargs)\n\n        if \"attachments\" in ret:\n            # Up to BZ 4.2\n            ret = [int(k) for k in ret[\"attachments\"].keys()]\n        elif \"ids\" in ret:\n            # BZ 4.4+\n            ret = ret[\"ids\"]\n\n        if isinstance(ret, list) and len(ret) == 1:\n            ret = ret[0]\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef openattachment(self, attachid):\n        attachments = self.get_attachments(None, attachid)\n        data = attachments[\"attachments\"][str(attachid)]\n        xmlrpcbinary = data[\"data\"]\n\n        ret = BytesIO()\n        ret.write(xmlrpcbinary.data)\n        ret.name = data[\"file_name\"]\n        ret.seek(0)\n        return ret", "response": "Open the contents of the attachment with the given attachment ID."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef updateattachmentflags(self, bugid, attachid, flagname, **kwargs):\n        # Bug ID was used for the original custom redhat API, no longer\n        # needed though\n        ignore = bugid\n\n        flags = {\"name\": flagname}\n        flags.update(kwargs)\n        update = {'ids': [int(attachid)], 'flags': [flags]}\n\n        return self._proxy.Bug.update_attachment(update)", "response": "Updates a flag for the given attachment ID."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_attachments(self, ids, attachment_ids,\n                        include_fields=None, exclude_fields=None):\n        \"\"\"\n        Wrapper for Bug.attachments. One of ids or attachment_ids is required\n\n        :param ids: Get attachments for this bug ID\n        :param attachment_ids: Specific attachment ID to get\n\n        https://bugzilla.readthedocs.io/en/latest/api/core/v1/attachment.html#get-attachment\n        \"\"\"\n        params = {\n            \"ids\": self._listify(ids) or [],\n            \"attachment_ids\": self._listify(attachment_ids) or [],\n        }\n        if include_fields:\n            params[\"include_fields\"] = self._listify(include_fields)\n        if exclude_fields:\n            params[\"exclude_fields\"] = self._listify(exclude_fields)\n\n        return self._proxy.Bug.attachments(params)", "response": "Wrapper for Bug. attachments. One of ids or attachment_ids is required\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds a dictionary of parameters to be passed to createbug.", "response": "def build_createbug(self,\n        product=None,\n        component=None,\n        version=None,\n        summary=None,\n        description=None,\n        comment_private=None,\n        blocks=None,\n        cc=None,\n        assigned_to=None,\n        keywords=None,\n        depends_on=None,\n        groups=None,\n        op_sys=None,\n        platform=None,\n        priority=None,\n        qa_contact=None,\n        resolution=None,\n        severity=None,\n        status=None,\n        target_milestone=None,\n        target_release=None,\n        url=None,\n        sub_component=None,\n        alias=None,\n        comment_tags=None):\n        \"\"\"\n        Returns a python dict() with properly formatted parameters to\n        pass to createbug(). See bugzilla documentation for the format\n        of the individual fields:\n\n        https://bugzilla.readthedocs.io/en/latest/api/core/v1/bug.html#update-bug\n        \"\"\"\n\n        localdict = {}\n        if blocks:\n            localdict[\"blocks\"] = self._listify(blocks)\n        if cc:\n            localdict[\"cc\"] = self._listify(cc)\n        if depends_on:\n            localdict[\"depends_on\"] = self._listify(depends_on)\n        if groups:\n            localdict[\"groups\"] = self._listify(groups)\n        if keywords:\n            localdict[\"keywords\"] = self._listify(keywords)\n        if description:\n            localdict[\"description\"] = description\n            if comment_private:\n                localdict[\"comment_is_private\"] = True\n\n        # Most of the machinery and formatting here is the same as\n        # build_update, so reuse that as much as possible\n        ret = self.build_update(product=product, component=component,\n                version=version, summary=summary, op_sys=op_sys,\n                platform=platform, priority=priority, qa_contact=qa_contact,\n                resolution=resolution, severity=severity, status=status,\n                target_milestone=target_milestone,\n                target_release=target_release, url=url,\n                assigned_to=assigned_to, sub_component=sub_component,\n                alias=alias, comment_tags=comment_tags)\n\n        ret.update(localdict)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef createbug(self, *args, **kwargs):\n        data = self._validate_createbug(*args, **kwargs)\n        rawbug = self._proxy.Bug.create(data)\n        return Bug(self, bug_id=rawbug[\"id\"],\n                   autorefresh=self.bug_autorefresh)", "response": "Create a new bug with the given info. Returns a new Bug object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _getusers(self, ids=None, names=None, match=None):\n        params = {}\n        if ids:\n            params['ids'] = self._listify(ids)\n        if names:\n            params['names'] = self._listify(names)\n        if match:\n            params['match'] = self._listify(match)\n        if not params:\n            raise BugzillaError('_get() needs one of ids, '\n                                ' names, or match kwarg.')\n\n        return self._proxy.User.get(params)", "response": "Internal method to retrieve a list of users that match criteria."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getusers(self, userlist):\n        userobjs = [User(self, **rawuser) for rawuser in\n                    self._getusers(names=userlist).get('users', [])]\n\n        # Return users in same order they were passed in\n        ret = []\n        for u in userlist:\n            for uobj in userobjs[:]:\n                if uobj.email == u:\n                    userobjs.remove(uobj)\n                    ret.append(uobj)\n                    break\n        ret += userobjs\n        return ret", "response": "Returns a list of Users from."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef searchusers(self, pattern):\n        return [User(self, **rawuser) for rawuser in\n                self._getusers(match=pattern).get('users', [])]", "response": "Search bugzilla users for the given list of patterns."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a bugzilla User record for the given email address and return a User record for the given username.", "response": "def createuser(self, email, name='', password=''):\n        \"\"\"\n        Return a bugzilla User for the given username\n\n        :arg email: The email address to use in bugzilla\n        :kwarg name: Real name to associate with the account\n        :kwarg password: Password to set for the bugzilla account\n        :raises XMLRPC Fault: Code 501 if the username already exists\n            Code 500 if the email address isn't valid\n            Code 502 if the password is too short\n            Code 503 if the password is too long\n        :return: User record for the username\n        \"\"\"\n        self._proxy.User.create(email, name, password)\n        return self.getuser(email)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef updateperms(self, user, action, groups):\n        groups = self._listify(groups)\n        if action == \"rem\":\n            action = \"remove\"\n        if action not in [\"add\", \"remove\", \"set\"]:\n            raise BugzillaError(\"Unknown user permission action '%s'\" % action)\n\n        update = {\n            \"names\": self._listify(user),\n            \"groups\": {\n                action: groups,\n            }\n        }\n\n        return self._proxy.User.update(update)", "response": "Update the permissions of a bugzilla user."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrefreshes the bug with the latest data from bugzilla", "response": "def refresh(self, include_fields=None, exclude_fields=None,\n        extra_fields=None):\n        \"\"\"\n        Refresh the bug with the latest data from bugzilla\n        \"\"\"\n        # pylint: disable=protected-access\n        r = self.bugzilla._getbug(self.bug_id,\n            include_fields=include_fields, exclude_fields=exclude_fields,\n            extra_fields=self._bug_fields + (extra_fields or []))\n        # pylint: enable=protected-access\n        self._update_dict(r)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates internal dictionary with newdict.", "response": "def _update_dict(self, newdict):\n        \"\"\"\n        Update internal dictionary, in a way that ensures no duplicate\n        entries are stored WRT field aliases\n        \"\"\"\n        if self.bugzilla:\n            self.bugzilla.post_translation({}, newdict)\n\n            # pylint: disable=protected-access\n            aliases = self.bugzilla._get_bug_aliases()\n            # pylint: enable=protected-access\n\n            for newname, oldname in aliases:\n                if oldname not in newdict:\n                    continue\n\n                if newname not in newdict:\n                    newdict[newname] = newdict[oldname]\n                elif newdict[newname] != newdict[oldname]:\n                    log.debug(\"Update dict contained differing alias values \"\n                              \"d[%s]=%s and d[%s]=%s , dropping the value \"\n                              \"d[%s]\", newname, newdict[newname], oldname,\n                            newdict[oldname], oldname)\n                del(newdict[oldname])\n\n        for key in newdict.keys():\n            if key not in self._bug_fields:\n                self._bug_fields.append(key)\n        self.__dict__.update(newdict)\n\n        if 'id' not in self.__dict__ and 'bug_id' not in self.__dict__:\n            raise TypeError(\"Bug object needs a bug_id\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef close(self, resolution, dupeid=None, fixedin=None,\n              comment=None, isprivate=False):\n        \"\"\"\n        Close this bug.\n        Valid values for resolution are in bz.querydefaults['resolution_list']\n        For bugzilla.redhat.com that's:\n        ['NOTABUG', 'WONTFIX', 'DEFERRED', 'WORKSFORME', 'CURRENTRELEASE',\n         'RAWHIDE', 'ERRATA', 'DUPLICATE', 'UPSTREAM', 'NEXTRELEASE',\n         'CANTFIX', 'INSUFFICIENT_DATA']\n        If using DUPLICATE, you need to set dupeid to the ID of the other bug.\n        If using WORKSFORME/CURRENTRELEASE/RAWHIDE/ERRATA/UPSTREAM/NEXTRELEASE\n          you can (and should) set 'new_fixed_in' to a string representing the\n          version that fixes the bug.\n        You can optionally add a comment while closing the bug. Set 'isprivate'\n          to True if you want that comment to be private.\n        \"\"\"\n        # Note: fedora bodhi uses this function\n        vals = self.bugzilla.build_update(comment=comment,\n                                          comment_private=isprivate,\n                                          resolution=resolution,\n                                          dupe_of=dupeid,\n                                          fixed_in=fixedin,\n                                          status=\"CLOSED\")\n        log.debug(\"close: update=%s\", vals)\n\n        return self.bugzilla.update_bugs(self.bug_id, vals)", "response": "Close this bug.\n        Valid values for resolution are in bz.querydefaults['resolution_list']\n        For bugzilla.redhat.com that's:\n        ['NOTABUG', 'WONTFIX', 'DEFERRED', 'WORKSFORME', 'CURRENTRELEASE',\n         'RAWHIDE', 'ERRATA', 'DUPLICATE', 'UPSTREAM', 'NEXTRELEASE',\n         'CANTFIX', 'INSUFFICIENT_DATA']\n        If using DUPLICATE, you need to set dupeid to the ID of the other bug.\n        If using WORKSFORME/CURRENTRELEASE/RAWHIDE/ERRATA/UPSTREAM/NEXTRELEASE\n          you can (and should) set 'new_fixed_in' to a string representing the\n          version that fixes the bug.\n        You can optionally add a comment while closing the bug. Set 'isprivate'\n          to True if you want that comment to be private."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset any of the assigned_to or qa_contact fields to a new bugzilla account.", "response": "def setassignee(self, assigned_to=None,\n                    qa_contact=None, comment=None):\n        \"\"\"\n        Set any of the assigned_to or qa_contact fields to a new\n        bugzilla account, with an optional comment, e.g.\n        setassignee(assigned_to='wwoods@redhat.com')\n        setassignee(qa_contact='wwoods@redhat.com', comment='wwoods QA ftw')\n\n        You must set at least one of the two assignee fields, or this method\n        will throw a ValueError.\n\n        Returns [bug_id, mailresults].\n        \"\"\"\n        if not (assigned_to or qa_contact):\n            raise ValueError(\"You must set one of assigned_to \"\n                             \" or qa_contact\")\n\n        vals = self.bugzilla.build_update(assigned_to=assigned_to,\n                                          qa_contact=qa_contact,\n                                          comment=comment)\n        log.debug(\"setassignee: update=%s\", vals)\n\n        return self.bugzilla.update_bugs(self.bug_id, vals)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addcc(self, cclist, comment=None):\n        vals = self.bugzilla.build_update(comment=comment,\n                                          cc_add=cclist)\n        log.debug(\"addcc: update=%s\", vals)\n\n        return self.bugzilla.update_bugs(self.bug_id, vals)", "response": "Adds the given email addresses to the CC list for this bug."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef deletecc(self, cclist, comment=None):\n        vals = self.bugzilla.build_update(comment=comment,\n                                          cc_remove=cclist)\n        log.debug(\"deletecc: update=%s\", vals)\n\n        return self.bugzilla.update_bugs(self.bug_id, vals)", "response": "Removes the given email addresses from the CC list for this bug."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addcomment(self, comment, private=False):\n        # Note: fedora bodhi uses this function\n        vals = self.bugzilla.build_update(comment=comment,\n                                          comment_private=private)\n        log.debug(\"addcomment: update=%s\", vals)\n\n        return self.bugzilla.update_bugs(self.bug_id, vals)", "response": "Add a comment to the current bug."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn an array of comment dictionaries for this bugistion", "response": "def getcomments(self):\n        \"\"\"\n        Returns an array of comment dictionaries for this bug\n        \"\"\"\n        comment_list = self.bugzilla.get_comments([self.bug_id])\n        return comment_list['bugs'][str(self.bug_id)]['comments']"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a flag status for the given flag name.", "response": "def get_flag_status(self, name):\n        \"\"\"\n        Return a flag 'status' field\n\n        This method works only for simple flags that have only a 'status' field\n        with no \"requestee\" info, and no multiple values. For more complex\n        flags, use get_flags() to get extended flag value information.\n        \"\"\"\n        f = self.get_flags(name)\n        if not f:\n            return None\n\n        # This method works only for simple flags that have only one\n        # value set.\n        assert len(f) <= 1\n\n        return f[0]['status']"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef updateflags(self, flags):\n        flaglist = []\n        for key, value in flags.items():\n            flaglist.append({\"name\": key, \"status\": value})\n        return self.bugzilla.update_bugs([self.bug_id],\n            self.bugzilla.build_update(flags=flaglist))", "response": "Wrapper around build_update to updatebugs with flags = X."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the attachments for this bug.", "response": "def get_attachments(self, include_fields=None, exclude_fields=None):\n        \"\"\"\n        Helper call to Bugzilla.get_attachments. If you want to fetch\n        specific attachment IDs, use that function instead\n        \"\"\"\n        if \"attachments\" in self.__dict__:\n            return self.attachments\n\n        data = self.bugzilla.get_attachments([self.bug_id], None,\n                include_fields, exclude_fields)\n        return data[\"bugs\"][str(self.bug_id)]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef refresh(self):\n        newuser = self.bugzilla.getuser(self.email)\n        self.__dict__.update(newuser.__dict__)", "response": "Update the User object with latest info from Bugzilla"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwrapping method to allow adding of external tracking bugs using the ExternalBugs::WebService::add_external_bug method. This is documented at https://bugzilla.redhat.com/docs/en/html/api/extensions/ExternalBugs/lib/WebService.html#add_external_bug bug_ids: A single bug id or list of bug ids to have external trackers added. ext_bz_bug_id: The external bug id (ie: the bug number in the external tracker). ext_type_id: The external tracker id as used by Bugzilla. ext_type_description: The external tracker description as used by Bugzilla. ext_type_url: The external tracker url as used by Bugzilla. ext_status: The status of the external bug. ext_description: The description of the external bug. ext_priority: The priority of the external bug.", "response": "def add_external_tracker(self, bug_ids, ext_bz_bug_id, ext_type_id=None,\n                             ext_type_description=None, ext_type_url=None,\n                             ext_status=None, ext_description=None,\n                             ext_priority=None):\n        \"\"\"\n        Wrapper method to allow adding of external tracking bugs using the\n        ExternalBugs::WebService::add_external_bug method.\n\n        This is documented at\n        https://bugzilla.redhat.com/docs/en/html/api/extensions/ExternalBugs/lib/WebService.html#add_external_bug\n\n        bug_ids: A single bug id or list of bug ids to have external trackers\n            added.\n        ext_bz_bug_id: The external bug id (ie: the bug number in the\n            external tracker).\n        ext_type_id: The external tracker id as used by Bugzilla.\n        ext_type_description: The external tracker description as used by\n            Bugzilla.\n        ext_type_url: The external tracker url as used by Bugzilla.\n        ext_status: The status of the external bug.\n        ext_description: The description of the external bug.\n        ext_priority: The priority of the external bug.\n        \"\"\"\n        param_dict = {'ext_bz_bug_id': ext_bz_bug_id}\n        if ext_type_id is not None:\n            param_dict['ext_type_id'] = ext_type_id\n        if ext_type_description is not None:\n            param_dict['ext_type_description'] = ext_type_description\n        if ext_type_url is not None:\n            param_dict['ext_type_url'] = ext_type_url\n        if ext_status is not None:\n            param_dict['ext_status'] = ext_status\n        if ext_description is not None:\n            param_dict['ext_description'] = ext_description\n        if ext_priority is not None:\n            param_dict['ext_priority'] = ext_priority\n        params = {\n            'bug_ids': self._listify(bug_ids),\n            'external_bugs': [param_dict],\n        }\n\n        log.debug(\"Calling ExternalBugs.add_external_bug(%s)\", params)\n        return self._proxy.ExternalBugs.add_external_bug(params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_external_tracker(self, ids=None, ext_type_id=None,\n                                ext_type_description=None, ext_type_url=None,\n                                ext_bz_bug_id=None, bug_ids=None,\n                                ext_status=None, ext_description=None,\n                                ext_priority=None):\n        \"\"\"\n        Wrapper method to allow adding of external tracking bugs using the\n        ExternalBugs::WebService::update_external_bug method.\n\n        This is documented at\n        https://bugzilla.redhat.com/docs/en/html/api/extensions/ExternalBugs/lib/WebService.html#update_external_bug\n\n        ids: A single external tracker bug id or list of external tracker bug\n            ids.\n        ext_type_id: The external tracker id as used by Bugzilla.\n        ext_type_description: The external tracker description as used by\n            Bugzilla.\n        ext_type_url: The external tracker url as used by Bugzilla.\n        ext_bz_bug_id: A single external bug id or list of external bug ids\n            (ie: the bug number in the external tracker).\n        bug_ids: A single bug id or list of bug ids to have external tracker\n            info updated.\n        ext_status: The status of the external bug.\n        ext_description: The description of the external bug.\n        ext_priority: The priority of the external bug.\n        \"\"\"\n        params = {}\n        if ids is not None:\n            params['ids'] = self._listify(ids)\n        if ext_type_id is not None:\n            params['ext_type_id'] = ext_type_id\n        if ext_type_description is not None:\n            params['ext_type_description'] = ext_type_description\n        if ext_type_url is not None:\n            params['ext_type_url'] = ext_type_url\n        if ext_bz_bug_id is not None:\n            params['ext_bz_bug_id'] = self._listify(ext_bz_bug_id)\n        if bug_ids is not None:\n            params['bug_ids'] = self._listify(bug_ids)\n        if ext_status is not None:\n            params['ext_status'] = ext_status\n        if ext_description is not None:\n            params['ext_description'] = ext_description\n        if ext_priority is not None:\n            params['ext_priority'] = ext_priority\n\n        log.debug(\"Calling ExternalBugs.update_external_bug(%s)\", params)\n        return self._proxy.ExternalBugs.update_external_bug(params)", "response": "This method is used to update the internal tracker information for a specific external tracker bug."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_external_tracker(self, ids=None, ext_type_id=None,\n                                ext_type_description=None, ext_type_url=None,\n                                ext_bz_bug_id=None, bug_ids=None):\n        \"\"\"\n        Wrapper method to allow removal of external tracking bugs using the\n        ExternalBugs::WebService::remove_external_bug method.\n\n        This is documented at\n        https://bugzilla.redhat.com/docs/en/html/api/extensions/ExternalBugs/lib/WebService.html#remove_external_bug\n\n        ids: A single external tracker bug id or list of external tracker bug\n            ids.\n        ext_type_id: The external tracker id as used by Bugzilla.\n        ext_type_description: The external tracker description as used by\n            Bugzilla.\n        ext_type_url: The external tracker url as used by Bugzilla.\n        ext_bz_bug_id: A single external bug id or list of external bug ids\n            (ie: the bug number in the external tracker).\n        bug_ids: A single bug id or list of bug ids to have external tracker\n            info updated.\n        \"\"\"\n        params = {}\n        if ids is not None:\n            params['ids'] = self._listify(ids)\n        if ext_type_id is not None:\n            params['ext_type_id'] = ext_type_id\n        if ext_type_description is not None:\n            params['ext_type_description'] = ext_type_description\n        if ext_type_url is not None:\n            params['ext_type_url'] = ext_type_url\n        if ext_bz_bug_id is not None:\n            params['ext_bz_bug_id'] = self._listify(ext_bz_bug_id)\n        if bug_ids is not None:\n            params['bug_ids'] = self._listify(bug_ids)\n\n        log.debug(\"Calling ExternalBugs.remove_external_bug(%s)\", params)\n        return self._proxy.ExternalBugs.remove_external_bug(params)", "response": "This method is used to remove an external tracker from the Bugzilla server."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntranslates the query for possible aliases", "response": "def pre_translation(self, query):\n        \"\"\"\n        Translates the query for possible aliases\n        \"\"\"\n        old = query.copy()\n\n        if 'bug_id' in query:\n            if not isinstance(query['bug_id'], list):\n                query['id'] = query['bug_id'].split(',')\n            else:\n                query['id'] = query['bug_id']\n            del query['bug_id']\n\n        if 'component' in query:\n            if not isinstance(query['component'], list):\n                query['component'] = query['component'].split(',')\n\n        if 'include_fields' not in query and 'column_list' not in query:\n            return\n\n        if 'include_fields' not in query:\n            query['include_fields'] = []\n            if 'column_list' in query:\n                query['include_fields'] = query['column_list']\n                del query['column_list']\n\n        # We need to do this for users here for users that\n        # don't call build_query\n        query.update(self._process_include_fields(query[\"include_fields\"],\n            None, None))\n\n        if old != query:\n            log.debug(\"RHBugzilla pretranslated query to: %s\", query)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert the results of getbug back to the ancient RHBZ value and formats the bug.", "response": "def post_translation(self, query, bug):\n        \"\"\"\n        Convert the results of getbug back to the ancient RHBZ value\n        formats\n        \"\"\"\n        ignore = query\n\n        # RHBZ _still_ returns component and version as lists, which\n        # deviates from upstream. Copy the list values to components\n        # and versions respectively.\n        if 'component' in bug and \"components\" not in bug:\n            val = bug['component']\n            bug['components'] = isinstance(val, list) and val or [val]\n            bug['component'] = bug['components'][0]\n\n        if 'version' in bug and \"versions\" not in bug:\n            val = bug['version']\n            bug['versions'] = isinstance(val, list) and val or [val]\n            bug['version'] = bug['versions'][0]\n\n        # sub_components isn't too friendly of a format, add a simpler\n        # sub_component value\n        if 'sub_components' in bug and 'sub_component' not in bug:\n            val = bug['sub_components']\n            bug['sub_component'] = \"\"\n            if isinstance(val, dict):\n                values = []\n                for vallist in val.values():\n                    values += vallist\n                bug['sub_component'] = \" \".join(values)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting a single mail from the filesystem.", "response": "def delete(self, mail):\n        \"\"\" Delete a mail from the filesystem. \"\"\"\n        self.stats['mail_deleted'] += 1\n        if self.conf.dry_run:\n            logger.info(\"Skip deletion of {!r}.\".format(mail))\n            return\n\n        logger.debug(\"Deleting {!r}...\".format(mail))\n        # XXX Investigate the use of maildir's .remove instead. See: https:\n        # //github.com/python/cpython/blob/origin/2.7/Lib/mailbox.py#L329-L331\n        os.unlink(mail.path)\n        logger.info(\"{} deleted.\".format(mail.path))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_differences(self):\n        logger.info(\"Check that mail differences are within the limits.\")\n        if self.conf.size_threshold < 0:\n            logger.info(\"Skip checking for size differences.\")\n        if self.conf.content_threshold < 0:\n            logger.info(\"Skip checking for content differences.\")\n        if self.conf.size_threshold < 0 and self.conf.content_threshold < 0:\n            return\n\n        # Compute differences of mail against one another.\n        for mail_a, mail_b in combinations(self.pool, 2):\n\n            # Compare mails on size.\n            if self.conf.size_threshold > -1:\n                size_difference = abs(mail_a.size - mail_b.size)\n                logger.debug(\"{} and {} differs by {} bytes in size.\".format(\n                    mail_a, mail_b, size_difference))\n                if size_difference > self.conf.size_threshold:\n                    raise SizeDiffAboveThreshold\n\n            # Compare mails on content.\n            if self.conf.content_threshold > -1:\n                content_difference = self.diff(mail_a, mail_b)\n                logger.debug(\n                    \"{} and {} differs by {} bytes in content.\".format(\n                        mail_a, mail_b, content_difference))\n                if content_difference > self.conf.content_threshold:\n                    if self.conf.show_diff:\n                        logger.info(self.pretty_diff(mail_a, mail_b))\n                    raise ContentDiffAboveThreshold", "response": "Check the differences between two duplicate sets."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef diff(self, mail_a, mail_b):\n        return len(''.join(unified_diff(\n            mail_a.body_lines, mail_b.body_lines,\n            # Ignore difference in filename lenghts and timestamps.\n            fromfile='a', tofile='b',\n            fromfiledate='', tofiledate='',\n            n=0, lineterm='\\n')))", "response": "Return the difference in bytes between two mails normalized body."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pretty_diff(self, mail_a, mail_b):\n        return ''.join(unified_diff(\n            mail_a.body_lines, mail_b.body_lines,\n            fromfile='Normalized body of {}'.format(mail_a.path),\n            tofile='Normalized body of {}'.format(mail_b.path),\n            fromfiledate='{:0.2f}'.format(mail_a.timestamp),\n            tofiledate='{:0.2f}'.format(mail_b.timestamp),\n            n=0, lineterm='\\n'))", "response": "Returns a verbose unified diff between two mails normalized body."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef apply_strategy(self):\n        method_id = self.conf.strategy.replace('-', '_')\n        if not hasattr(DuplicateSet, method_id):\n            raise NotImplementedError(\n                \"DuplicateSet.{}() method.\".format(method_id))\n        return getattr(self, method_id)()", "response": "Apply deduplication with the configured strategy."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nperforms the deduplication and its preliminary checks.", "response": "def dedupe(self):\n        \"\"\" Performs the deduplication and its preliminary checks. \"\"\"\n        if len(self.pool) == 1:\n            logger.debug(\"Ignore set: only one message found.\")\n            self.stats['mail_unique'] += 1\n            self.stats['set_ignored'] += 1\n            return\n\n        try:\n            # Fine-grained checks on mail differences.\n            self.check_differences()\n            # Call the deduplication strategy.\n            self.apply_strategy()\n        except UnicodeDecodeError as expt:\n            self.stats['set_rejected_encoding'] += 1\n            logger.warning(\n                \"Reject set: unparseable mails due to bad encoding.\")\n            logger.debug(str(expt))\n        except SizeDiffAboveThreshold:\n            self.stats['set_rejected_size'] += 1\n            logger.warning(\"Reject set: mails are too dissimilar in size.\")\n        except ContentDiffAboveThreshold:\n            self.stats['set_rejected_content'] += 1\n            logger.warning(\"Reject set: mails are too dissimilar in content.\")\n        else:\n            # Count duplicate sets without deletion as skipped.\n            if not self.stats['mail_deleted']:\n                logger.info(\"Skip set: no deletion happened.\")\n                self.stats['set_skipped'] += 1\n            else:\n                self.stats['set_deduplicated'] += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes all older duplicates.", "response": "def delete_older(self):\n        \"\"\" Delete all older duplicates.\n\n        Only keeps the subset sharing the most recent timestamp.\n        \"\"\"\n        logger.info(\n            \"Deleting all mails strictly older than the {} timestamp...\"\n            \"\".format(self.newest_timestamp))\n        # Select candidates for deletion.\n        candidates = [\n            mail for mail in self.pool\n            if mail.timestamp < self.newest_timestamp]\n        if len(candidates) == self.size:\n            logger.warning(\n                \"Skip deletion: all {} mails share the same timestamp.\"\n                \"\".format(self.size))\n        logger.info(\n            \"{} candidates found for deletion.\".format(len(candidates)))\n        for mail in candidates:\n            self.delete(mail)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_oldest(self):\n        logger.info(\n            \"Deleting all mails sharing the oldest {} timestamp...\".format(\n                self.oldest_timestamp))\n        # Select candidates for deletion.\n        candidates = [\n            mail for mail in self.pool\n            if mail.timestamp == self.oldest_timestamp]\n        if len(candidates) == self.size:\n            logger.warning(\n                \"Skip deletion: all {} mails share the same timestamp.\"\n                \"\".format(self.size))\n            return\n        logger.info(\n            \"{} candidates found for deletion.\".format(len(candidates)))\n        for mail in candidates:\n            self.delete(mail)", "response": "Delete all the oldest duplicates."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete all bigger duplicates.", "response": "def delete_bigger(self):\n        \"\"\" Delete all bigger duplicates.\n\n        Only keeps the subset sharing the smallest size.\n        \"\"\"\n        logger.info(\n            \"Deleting all mails strictly bigger than {} bytes...\".format(\n                self.smallest_size))\n        # Select candidates for deletion.\n        candidates = [\n            mail for mail in self.pool\n            if mail.size > self.smallest_size]\n        if len(candidates) == self.size:\n            logger.warning(\n                \"Skip deletion: all {} mails share the same size.\"\n                \"\".format(self.size))\n        logger.info(\n            \"{} candidates found for deletion.\".format(len(candidates)))\n        for mail in candidates:\n            self.delete(mail)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_biggest(self):\n        logger.info(\n            \"Deleting all mails sharing the biggest size of {} bytes...\"\n            \"\".format(self.biggest_size))\n        # Select candidates for deletion.\n        candidates = [\n            mail for mail in self.pool\n            if mail.size == self.biggest_size]\n        if len(candidates) == self.size:\n            logger.warning(\n                \"Skip deletion: all {} mails share the same size.\"\n                \"\".format(self.size))\n            return\n        logger.info(\n            \"{} candidates found for deletion.\".format(len(candidates)))\n        for mail in candidates:\n            self.delete(mail)", "response": "Delete all the biggest duplicates."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_matching_path(self):\n        logger.info(\n            \"Deleting all mails with file path matching the {} regexp...\"\n            \"\".format(self.conf.regexp.pattern))\n        # Select candidates for deletion.\n        candidates = [\n            mail for mail in self.pool\n            if re.search(self.conf.regexp, mail.path)]\n        if len(candidates) == self.size:\n            logger.warning(\n                \"Skip deletion: all {} mails matches the rexexp.\".format(\n                    self.size))\n            return\n        logger.info(\n            \"{} candidates found for deletion.\".format(len(candidates)))\n        for mail in candidates:\n            self.delete(mail)", "response": "Delete all duplicates whose file path matches the regexp."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef canonical_path(path):\n        return os.path.normcase(os.path.realpath(os.path.abspath(\n            os.path.expanduser(path))))", "response": "Return a normalized canonical path to a file or folder."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_maildir(self, maildir_path):\n        maildir_path = self.canonical_path(maildir_path)\n        logger.info(\"Opening maildir at {} ...\".format(maildir_path))\n        # Maildir parser requires a string, not a unicode, as path.\n        maildir = Maildir(str(maildir_path), factory=None, create=False)\n\n        # Group folders by hash.\n        logger.info(\"{} mails found.\".format(len(maildir)))\n        if self.conf.progress:\n            bar = ProgressBar(widgets=[Percentage(), Bar()],\n                              max_value=len(maildir), redirect_stderr=True,\n                              redirect_stdout=True)\n        else:\n            def bar(x):\n                return x\n\n        for mail_id in bar(maildir.iterkeys()):\n            self.stats['mail_found'] += 1\n\n            mail_path = self.canonical_path(os.path.join(\n                maildir._path, maildir._lookup(mail_id)))\n            mail = Mail(mail_path, self.conf)\n\n            try:\n                mail_hash = mail.hash_key\n            except (InsufficientHeadersError, MissingMessageID) as expt:\n                logger.warning(\n                    \"Rejecting {}: {}\".format(mail_path, expt.args[0]))\n                self.stats['mail_rejected'] += 1\n            else:\n                logger.debug(\n                    \"Hash is {} for mail {!r}.\".format(mail_hash, mail_id))\n                # Use a set to deduplicate entries pointing to the same file.\n                self.mails.setdefault(mail_hash, set()).add(mail_path)\n                self.stats['mail_kept'] += 1", "response": "Load up a maildir and compute hash for each mail found."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self):\n        logger.info(\n            \"The {} strategy will be applied on each duplicate set.\".format(\n                self.conf.strategy))\n\n        self.stats['set_total'] = len(self.mails)\n\n        for hash_key, mail_path_set in self.mails.items():\n            # Print visual clue to separate duplicate sets.\n            logger.info('---')\n\n            duplicates = DuplicateSet(hash_key, mail_path_set, self.conf)\n\n            # Perfom the deduplication.\n            duplicates.dedupe()\n\n            # Merge stats resulting of actions on duplicate sets.\n            self.stats += duplicates.stats", "response": "Run the deduplication process."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef report(self):\n        table = [[\"Mails\", \"Metric\"]]\n        table.append([\"Found\", self.stats['mail_found']])\n        table.append([\"Skipped\", self.stats['mail_skipped']])\n        table.append([\"Rejected\", self.stats['mail_rejected']])\n        table.append([\"Kept\", self.stats['mail_kept']])\n        table.append([\"Unique\", self.stats['mail_unique']])\n        table.append([\"Duplicates\", self.stats['mail_duplicates']])\n        table.append([\"Deleted\", self.stats['mail_deleted']])\n        logger.info(tabulate(table, tablefmt='fancy_grid', headers='firstrow'))\n\n        table = [[\"Duplicate sets\", \"Metric\"]]\n        table.append([\"Total\", self.stats['set_total']])\n        table.append([\"Ignored\", self.stats['set_ignored']])\n        table.append([\"Skipped\", self.stats['set_skipped']])\n        table.append([\n            \"Rejected (bad encoding)\",\n            self.stats['set_rejected_encoding']])\n        table.append([\n            \"Rejected (too dissimilar in size)\",\n            self.stats['set_rejected_size']])\n        table.append([\n            \"Rejected (too dissimilar in content)\",\n            self.stats['set_rejected_content']])\n        table.append([\"Deduplicated\", self.stats['set_deduplicated']])\n        logger.info(tabulate(table, tablefmt='fancy_grid', headers='firstrow'))\n\n        # Perform some high-level consistency checks on metrics.\n        assert self.stats['mail_found'] == (\n            self.stats['mail_skipped'] +\n            self.stats['mail_rejected'] +\n            self.stats['mail_kept'])\n        assert self.stats['mail_kept'] >= self.stats['mail_unique']\n        assert self.stats['mail_kept'] >= self.stats['mail_duplicates']\n        assert self.stats['mail_kept'] >= self.stats['mail_deleted']\n        assert self.stats['mail_kept'] == (\n            self.stats['mail_unique'] +\n            self.stats['mail_duplicates'])\n        assert self.stats['mail_duplicates'] > self.stats['mail_deleted']\n\n        assert self.stats['set_ignored'] == self.stats['mail_unique']\n\n        assert self.stats['set_total'] == (\n            self.stats['set_ignored'] +\n            self.stats['set_skipped'] +\n            self.stats['set_rejected_encoding'] +\n            self.stats['set_rejected_size'] +\n            self.stats['set_rejected_content'] +\n            self.stats['set_deduplicated'])", "response": "Print user - friendly statistics and metrics."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cli(ctx):\n    level = logger.level\n    try:\n        level_to_name = logging._levelToName\n    # Fallback to pre-Python 3.4 internals.\n    except AttributeError:\n        level_to_name = logging._levelNames\n    level_name = level_to_name.get(level, level)\n    logger.debug('Verbosity set to {}.'.format(level_name))\n\n    # Print help screen and exit if no sub-commands provided.\n    if ctx.invoked_subcommand is None:\n        click.echo(ctx.get_help())\n        ctx.exit()\n\n    # Load up global options to the context.\n    ctx.obj = {}", "response": "A maildirs content analysis and deletion command line interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef validate_regexp(ctx, param, value):\n    if value:\n        try:\n            value = re.compile(value)\n        except ValueError:\n            raise click.BadParameter('invalid regular expression.')\n    return value", "response": "Validate and compile regular expression."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate_maildirs(ctx, param, value):\n    for path in value:\n        for subdir in MD_SUBDIRS:\n            if not os.path.isdir(os.path.join(path, subdir)):\n                raise click.BadParameter(\n                    '{} is not a maildir (missing {!r} sub-directory).'.format(\n                        path, subdir))\n    return value", "response": "Check that folders are maildirs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef deduplicate(\n        ctx, strategy, time_source, regexp, dry_run, message_id,\n        size_threshold, content_threshold, show_diff, maildirs):\n    \"\"\" Deduplicate mails from a set of maildir folders.\n\n    Run a first pass computing the canonical hash of each encountered mail from\n    their headers, then a second pass to apply the deletion strategy on each\n    subset of duplicate mails.\n\n    \\b\n    Removal strategies for each subsets of duplicate mails:\n      - delete-older:    Deletes the olders,    keeps the newests.\n      - delete-oldest:   Deletes the oldests,   keeps the newers.\n      - delete-newer:    Deletes the newers,    keeps the oldests.\n      - delete-newest:   Deletes the newests,   keeps the olders.\n      - delete-smaller:  Deletes the smallers,  keeps the biggests.\n      - delete-smallest: Deletes the smallests, keeps the biggers.\n      - delete-bigger:   Deletes the biggers,   keeps the smallests.\n      - delete-biggest:  Deletes the biggests,  keeps the smallers.\n      - delete-matching-path: Deletes all duplicates whose file path match the\n      regular expression provided via the --regexp parameter.\n      - delete-non-matching-path: Deletes all duplicates whose file path\n      doesn't match the regular expression provided via the --regexp parameter.\n\n    Deletion strategy on a duplicate set only applies if no major differences\n    between mails are uncovered during a fine-grained check differences during\n    the second pass. Limits can be set via the threshold options.\n    \"\"\"\n    # Print help screen and exit if no maildir folder provided.\n    if not maildirs:\n        click.echo(ctx.get_help())\n        ctx.exit()\n\n    # Validate exclusive options requirement depending on strategy.\n    requirements = [\n        (time_source, '-t/--time-source', [\n            DELETE_OLDER, DELETE_OLDEST, DELETE_NEWER, DELETE_NEWEST]),\n        (regexp, '-r/--regexp', [\n            DELETE_MATCHING_PATH, DELETE_NON_MATCHING_PATH])]\n    for param_value, param_name, required_strategies in requirements:\n        if strategy in required_strategies:\n            if not param_value:\n                raise click.BadParameter(\n                    '{} strategy requires the {} parameter.'.format(\n                        strategy, param_name))\n        elif param_value:\n            raise click.BadParameter(\n                '{} parameter not allowed in {} strategy.'.format(\n                    param_name, strategy))\n\n    conf = Config(\n        strategy=strategy,\n        time_source=time_source,\n        regexp=regexp,\n        dry_run=dry_run,\n        show_diff=show_diff,\n        message_id=message_id,\n        size_threshold=size_threshold,\n        content_threshold=content_threshold,\n        # progress=progress,\n    )\n\n    dedup = Deduplicate(conf)\n\n    logger.info('=== Start phase #1: load mails and compute hashes.')\n    for maildir in maildirs:\n        dedup.add_maildir(maildir)\n\n    logger.info('=== Start phase #2: deduplicate mails.')\n    dedup.run()\n\n    dedup.report()", "response": "This function will take a set of maildir folders and deduplicate them into a single tree structure."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nshow the canonicalised form of a single mail message.", "response": "def hash(ctx, message_id, message):\n    \"\"\" Take a single mail message and show its canonicalised form and hash.\n\n    Mainly used to debug message hashing.\n    \"\"\"\n    conf = Config(message_id=message_id)\n\n    mail = Mail(message, conf)\n\n    logger.info(mail.header_text)\n    logger.info('-' * 70)\n    logger.info('Hash: {}'.format(mail.hash_key))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning content of a file relative to this setup. py.", "response": "def read_file(*relative_path_elements):\n    \"\"\" Return content of a file relative to this ``setup.py``. \"\"\"\n    file_path = path.join(path.dirname(__file__), *relative_path_elements)\n    return io.open(file_path, encoding='utf8').read().strip()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract version from the __init__. py file at the module s root.", "response": "def version():\n    \"\"\" Extracts version from the ``__init__.py`` file at the module's root.\n\n    Inspired by: https://packaging.python.org/single_source_version/\n    \"\"\"\n    global _version\n    if _version:\n        return _version\n    init_file = read_file(MODULE_NAME, '__init__.py')\n    matches = re.search(\n        r'^__version__\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]', init_file, re.M)\n    if not matches:\n        raise RuntimeError(\"Unable to find version string in __init__.py .\")\n    _version = matches.group(1)  # noqa\n    return _version"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef long_description():\n    changes = latest_changes()\n    changes[0] = \"`Changes for v{}\".format(changes[0][1:])\n    changes[1] = '-' * len(changes[0])\n    return \"\\n\\n\\n\".join([\n        read_file('README.rst'),\n        '\\n'.join(changes),\n        \"`Full changelog <https://{}.readthedocs.io/en/develop/changelog.html\"\n        \"#changelog>`_.\".format(PACKAGE_NAME),\n    ])", "response": "Generates a long description of the current project."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread the mail file and return a Message instance.", "response": "def message(self):\n        \"\"\" Read mail, parse it and return a Message instance. \"\"\"\n        logger.debug(\"Parsing mail at {} ...\".format(self.path))\n        with open(self.path, 'rb') as mail_file:\n            if PY2:\n                message = email.message_from_file(mail_file)\n            else:\n                message = email.message_from_binary_file(mail_file)\n        return message"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncomputing the normalized canonical timestamp of the mail.", "response": "def timestamp(self):\n        \"\"\" Compute the normalized canonical timestamp of the mail. \"\"\"\n        # XXX ctime does not refer to creation time on POSIX systems, but\n        # rather the last time the inode data changed. Source:\n        # https://userprimary.net/posts/2007/11/18\n        # /ctime-in-unix-means-last-change-time-not-create-time/\n        if self.conf.time_source == CTIME:\n            return os.path.getctime(self.path)\n\n        # Fetch from the date header.\n        return email.utils.mktime_tz(email.utils.parsedate_tz(\n            self.message.get('Date')))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef body_lines(self):\n        if not self.message.is_multipart():\n            body = self.message.get_payload(None, decode=True)\n        else:\n            _, _, body = self.message.as_string().partition(\"\\n\\n\")\n        if isinstance(body, bytes):\n            for enc in ['ascii', 'utf-8']:\n                try:\n                    body = body.decode(enc)\n                    break\n                except UnicodeDecodeError:\n                    continue\n            else:\n                body = self.message.get_payload(None, decode=False)\n        return body.splitlines(True)", "response": "Return a list of lines from the message s body."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef subject(self):\n        # Fetch subject from first message.\n        subject = self.message.get('Subject', '')\n        subject, _ = re.subn(r'\\s+', ' ', subject)\n        return subject", "response": "Normalized subject.\n\n        Only used for debugging and human-friendly logging."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hash_key(self):\n        if self.conf.message_id:\n            message_id = self.message.get('Message-Id')\n            if message_id:\n                return message_id.strip()\n            logger.error(\n                \"No Message-ID in {}: {}\".format(self.path, self.header_text))\n            raise MissingMessageID\n\n        return hashlib.sha224(self.canonical_headers).hexdigest()", "response": "Returns the canonical hash of a mail."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a string containing the canonical headers of the message.", "response": "def canonical_headers(self):\n        \"\"\" Copy selected headers into a new string. \"\"\"\n        canonical_headers = ''\n\n        for header in HEADERS:\n            if header not in self.message:\n                continue\n\n            for value in self.message.get_all(header):\n                canonical_value = self.canonical_header_value(header, value)\n                if re.search(r'\\S', canonical_value):\n                    canonical_headers += '{}: {}\\n'.format(\n                        header, canonical_value)\n\n        canonical_headers = canonical_headers.encode('utf-8')\n        if len(canonical_headers) > 50:\n            return canonical_headers\n\n        # At this point we should have at absolute minimum 3 or 4 headers, e.g.\n        # From/To/Date/Subject; if not, something went badly wrong.\n\n        if len(canonical_headers) == 0:\n            raise InsufficientHeadersError(\"No canonical headers found\")\n\n        err = textwrap.dedent(\"\"\"\\\n            Not enough data from canonical headers to compute reliable hash!\n            Headers:\n            --------- 8< --------- 8< --------- 8< --------- 8< ---------\n            {}\n            --------- 8< --------- 8< --------- 8< --------- 8< ---------\"\"\")\n        raise InsufficientHeadersError(err.format(canonical_headers))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef enumerate(cls):\n        devices = {}\n        for d in hid.enumerate(0, 0):\n            vendor_id = d['vendor_id']\n            product_id = d['product_id']\n            serial_number = d['serial_number']\n            interface_number = d['interface_number']\n            path = d['path']\n\n            # HIDAPI on Mac cannot detect correct HID interfaces, so device with\n            # DebugLink doesn't work on Mac...\n            if devices.get(serial_number) != None and devices[serial_number][0] == path:\n                raise Exception(\"Two devices with the same path and S/N found. This is Mac, right? :-/\")\n\n            if (vendor_id, product_id) in DEVICE_IDS:\n                devices.setdefault(serial_number, [None, None, None])\n                if is_normal_link(d):\n                    devices[serial_number][0] = path\n                elif is_debug_link(d):\n                    devices[serial_number][1] = path\n                else:\n                    raise Exception(\"Unknown USB interface number: %d\" % interface_number)\n\n        # List of two-tuples (path_normal, path_debuglink)\n        return list(devices.values())", "response": "Enumerate all KeepKey devices."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if the device is still connected.", "response": "def is_connected(self):\n        \"\"\"\n        Check if the device is still connected.\n        \"\"\"\n        for d in hid.enumerate(0, 0):\n            if d['path'] == self.device:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sec_to_public_pair(pubkey):\n    x = string_to_number(pubkey[1:33])\n    sec0 = pubkey[:1]\n    if sec0 not in (b'\\2', b'\\3'):\n        raise Exception(\"Compressed pubkey expected\")\n\n    def public_pair_for_x(generator, x, is_even):\n        curve = generator.curve()\n        p = curve.p()\n        alpha = (pow(x, 3, p) + curve.a() * x + curve.b()) % p\n        beta = ecdsa.numbertheory.square_root_mod_prime(alpha, p)\n        if is_even == bool(beta & 1):\n            return (x, p - beta)\n        return (x, beta)\n\n    return public_pair_for_x(ecdsa.ecdsa.generator_secp256k1, x, is_even=(sec0 == b'\\2'))", "response": "Convert a public key in sec binary format to a public pair."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef b58decode(v, length):\n    long_value = 0\n    for (i, c) in enumerate(v[::-1]):\n        long_value += __b58chars.find(c) * (__b58base ** i)\n\n    result = b''\n    while long_value >= 256:\n        div, mod = divmod(long_value, 256)\n        result = struct.pack('B', mod) + result\n        long_value = div\n    result = struct.pack('B', long_value) + result\n\n    nPad = 0\n    for c in v:\n        if c == __b58chars[0]:\n            nPad += 1\n        else:\n            break\n\n    result = b'\\x00' * nPad + result\n    if length is not None and len(result) != length:\n        return None\n\n    return result", "response": "decode v into a string of len bytes. length is optional and returns None if v is not a string of length bytes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a BIP32 path string to list of uint32 integers with hardened flags.", "response": "def parse_path(nstr):\n    \"\"\"\n    Convert BIP32 path string to list of uint32 integers with hardened flags.\n    Several conventions are supported to set the hardened flag: -1, 1', 1h\n    e.g.: \"0/1h/1\" -> [0, 0x80000001, 1]\n    :param nstr: path string\n    :return: list of integers\n    \"\"\"\n    if not nstr:\n        return []\n\n    n = nstr.split('/')\n\n    # m/a/b/c => a/b/c\n    if n[0] == 'm':\n        n = n[1:]\n\n    # coin_name/a/b/c => 44'/SLIP44_constant'/a/b/c\n    #if n[0] in slip44:\n    #    coin_id = slip44[n[0]]\n    #    n[0:1] = ['44h', '{}h'.format(coin_id)]\n\n    def str_to_harden(x):\n        if x.startswith('-'):\n            return H_(abs(int(x)))\n        elif x.endswith(('h', \"'\")):\n            return H_(int(x[:-1]))\n        else:\n            return int(x)\n\n    try:\n        return list(str_to_harden(x) for x in n)\n    except Exception:\n        raise ValueError('Invalid BIP32 path', nstr)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nend a session. Se session_begin for an in depth description of TREZOR sessions.", "response": "def session_end(self):\n        \"\"\"\n        End a session.  Se session_begin for an in depth description of TREZOR sessions.\n        \"\"\"\n        self.session_depth -= 1\n        self.session_depth = max(0, self.session_depth)\n        if self.session_depth == 0:\n            self._session_end()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write(self, msg):\n        ser = msg.SerializeToString()\n        header = struct.pack(\">HL\", mapping.get_type(msg), len(ser))\n        self._write(b\"##\" + header + ser, msg)", "response": "Writes a message to tansport."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread the data from the transport and parses it as a protobuf message.", "response": "def read(self):\n        \"\"\"\n        If there is data available to be read from the transport, reads the data and tries to parse it as a protobuf message.  If the parsing succeeds, return a protobuf object.\n        Otherwise, returns None.\n        \"\"\"\n        if not self.ready_to_read():\n            return None\n\n        data = self._read()\n        if data is None:\n            return None\n\n        return self._parse_message(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_blocking(self):\n        while True:\n            data = self._read()\n            if data != None:\n                break\n\n        return self._parse_message(data)", "response": "Reads a message from the server blocking until the message is available."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a name for the module s cache db.", "response": "def _get_cache_name(function):\n    \"\"\"\n    returns a name for the module's cache db.\n    \"\"\"\n    module_name = _inspect.getfile(function)\n    module_name = _os.path.abspath(module_name)\n    cache_name = module_name\n\n    # fix for '<string>' or '<stdin>' in exec or interpreter usage.\n    cache_name = cache_name.replace('<', '_lt_')\n    cache_name = cache_name.replace('>', '_gt_')\n\n    tmpdir = _os.getenv('TMPDIR') or _os.getenv('TEMP') or _os.getenv('TMP')\n    if tmpdir:\n        cache_name = tmpdir + '/filecache_' + cache_name.replace(_os.sep, '@')\n\n    cache_name += '.cache'\n    return cache_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef filecache(seconds_of_validity=None, fail_silently=False):\n    '''\n    filecache is called and the decorator should be returned.\n    '''\n    def filecache_decorator(function):\n        @_functools.wraps(function)\n        def function_with_cache(*args, **kwargs):\n            try:\n                key = _args_key(function, args, kwargs)\n\n                if key in function._db:\n                    rv = function._db[key]\n                    if seconds_of_validity is None or _time.time() - rv.timesig < seconds_of_validity:\n                        return rv.data\n            except Exception:\n                # in any case of failure, don't let filecache break the program\n                error_str = _traceback.format_exc()\n                _log_error(error_str)\n                if not fail_silently:\n                    raise\n\n            retval = function(*args, **kwargs)\n\n            # store in cache\n            # NOTE: no need to _db.sync() because there was no mutation\n            # NOTE: it's importatnt to do _db.sync() because otherwise the cache doesn't survive Ctrl-Break!\n            try:\n                function._db[key] = _retval(_time.time(), retval)\n                function._db.sync()\n            except Exception:\n                # in any case of failure, don't let filecache break the program\n                error_str = _traceback.format_exc()\n                _log_error(error_str)\n                if not fail_silently:\n                    raise\n\n            return retval\n\n        # make sure cache is loaded\n        if not hasattr(function, '_db'):\n            cache_name = _get_cache_name(function)\n            if cache_name in OPEN_DBS:\n                function._db = OPEN_DBS[cache_name]\n            else:\n                function._db = _shelve.open(cache_name)\n                OPEN_DBS[cache_name] = function._db\n                atexit.register(function._db.close)\n\n            function_with_cache._db = function._db\n\n        return function_with_cache\n\n    if type(seconds_of_validity) == types.FunctionType:\n        # support for when people use '@filecache.filecache' instead of '@filecache.filecache()'\n        func = seconds_of_validity\n        seconds_of_validity = None\n        return filecache_decorator(func)\n\n    return filecache_decorator", "response": "Decorator for filecache functions."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating the entropy of the internal and external HRNGs.", "response": "def generate_entropy(strength, internal_entropy, external_entropy):\n    '''\n    strength - length of produced seed. One of 128, 192, 256\n    random - binary stream of random data from external HRNG\n    '''\n    if strength not in (128, 192, 256):\n        raise Exception(\"Invalid strength\")\n\n    if not internal_entropy:\n        raise Exception(\"Internal entropy is not provided\")\n\n    if len(internal_entropy) < 32:\n        raise Exception(\"Internal entropy too short\")\n\n    if not external_entropy:\n        raise Exception(\"External entropy is not provided\")\n\n    if len(external_entropy) < 32:\n        raise Exception(\"External entropy too short\")\n\n    entropy = hashlib.sha256(internal_entropy + external_entropy).digest()\n    entropy_stripped = entropy[:strength // 8]\n\n    if len(entropy_stripped) * 8 != strength:\n        raise Exception(\"Entropy length mismatch\")\n\n    return entropy_stripped"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert google. protobuf. descriptor instance to JSON string", "response": "def pb2json(pb):\n    ''' convert google.protobuf.descriptor instance to JSON string '''\n    js = {}\n    # fields = pb.DESCRIPTOR.fields #all fields\n    fields = pb.ListFields()    #only filled (including extensions)\n    for field,value in fields:\n        if field.type == FD.TYPE_MESSAGE:\n            ftype = pb2json\n        elif field.type == FD.TYPE_ENUM:\n            ftype = lambda x: field.enum_type.values[x].name\n        elif field.type in _ftype2js:\n            ftype = _ftype2js[field.type]\n        else:\n            raise ParseError(\"Field %s.%s of type '%d' is not supported\" % (pb.__class__.__name__, field.name, field.type, ))\n        if field.label == FD.LABEL_REPEATED:\n            js_value = []\n            for v in value:\n                js_value.append(ftype(v))\n        else:\n            js_value = ftype(value)\n        js[field.name] = js_value\n    return js"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pprint(msg):\n    msg_class = msg.__class__.__name__\n    msg_size = msg.ByteSize()\n    \"\"\"\n    msg_ser = msg.SerializeToString()\n    msg_id = mapping.get_type(msg)\n    msg_json = json.dumps(protobuf_json.pb2json(msg))\n    \"\"\"\n    if isinstance(msg, proto.FirmwareUpload):\n        return \"<%s> (%d bytes):\\n\" % (msg_class, msg_size)\n    else:\n        return \"<%s> (%d bytes):\\n%s\" % (msg_class, msg_size, msg)", "response": "Pretty print a message."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_charm_series(path):\n    md = Path(path) / \"metadata.yaml\"\n    if not md.exists():\n        return None\n    data = yaml.load(md.open())\n    series = data.get('series')\n    return series[0] if series else None", "response": "Inspects the charm directory at path and returns a default\n    series from its metadata. yaml. Returns None if no series can be determined."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cares_about(self, delta):\n        if (self.entity_id and delta.get_id() and\n                not re.match(self.entity_id, str(delta.get_id()))):\n            return False\n\n        if self.entity_type and self.entity_type != delta.entity:\n            return False\n\n        if self.action and self.action != delta.type:\n            return False\n\n        if self.predicate and not self.predicate(delta):\n            return False\n\n        return True", "response": "Return True if this observer wants to be cares about for a given delta."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an id : Entity map of all the living entities of the given type.", "response": "def _live_entity_map(self, entity_type):\n        \"\"\"Return an id:Entity map of all the living entities of\n        type ``entity_type``.\n\n        \"\"\"\n        return {\n            entity_id: self.get_entity(entity_type, entity_id)\n            for entity_id, history in self.state.get(entity_type, {}).items()\n            if history[-1] is not None\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef entity_data(self, entity_type, entity_id, history_index):\n        return self.entity_history(entity_type, entity_id)[history_index]", "response": "Return the data dict for an entity at a specific index of its\n        history."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef apply_delta(self, delta):\n        history = (\n            self.state\n            .setdefault(delta.entity, {})\n            .setdefault(delta.get_id(), collections.deque())\n        )\n\n        history.append(delta.data)\n        if delta.type == 'remove':\n            history.append(None)\n\n        entity = self.get_entity(delta.entity, delta.get_id())\n        return entity.previous(), entity", "response": "Apply a delta to our state and return a copy of the object affected by the update."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_entity(\n            self, entity_type, entity_id, history_index=-1, connected=True):\n        \"\"\"Return an object instance for the given entity_type and id.\n\n        By default the object state matches the most recent state from\n        Juju. To get an instance of the object in an older state, pass\n        history_index, an index into the history deque for the entity.\n\n        \"\"\"\n\n        if history_index < 0 and history_index != -1:\n            history_index += len(self.entity_history(entity_type, entity_id))\n            if history_index < 0:\n                return None\n\n        try:\n            self.entity_data(entity_type, entity_id, history_index)\n        except IndexError:\n            return None\n\n        entity_class = get_entity_class(entity_type)\n        return entity_class(\n            entity_id, self.model, history_index=history_index,\n            connected=connected)", "response": "Return an object instance for the given entity_type and id."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a change observer to this entity.", "response": "def on_change(self, callable_):\n        \"\"\"Add a change observer to this entity.\n\n        \"\"\"\n        self.model.add_observer(\n            callable_, self.entity_type, 'change', self.entity_id)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef on_remove(self, callable_):\n        self.model.add_observer(\n            callable_, self.entity_type, 'remove', self.entity_id)", "response": "Add a remove observer to this entity."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dead(self):\n        return (\n            self.data is None or\n            self.model.state.entity_data(\n                self.entity_type, self.entity_id, -1) is None\n        )", "response": "Returns True if this entity is no longer in the underlying\n        model."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef data(self):\n        return self.model.state.entity_data(\n            self.entity_type, self.entity_id, self._history_index)", "response": "The data dictionary for this entity."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef safe_data(self):\n        if self.data is None:\n            raise DeadEntityException(\n                \"Entity {}:{} is dead - its attributes can no longer be \"\n                \"accessed. Use the .previous() method on this object to get \"\n                \"a copy of the object at its previous state.\".format(\n                    self.entity_type, self.entity_id))\n        return self.data", "response": "The data dictionary for this entity."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef previous(self):\n        return self.model.state.get_entity(\n            self.entity_type, self.entity_id, self._history_index - 1,\n            connected=False)", "response": "Return a copy of this object as was at its previous state in\n        history."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a copy of this object at its next state in history.", "response": "def next(self):\n        \"\"\"Return a copy of this object at its next state in\n        history.\n\n        Returns None if this object is already the latest.\n\n        The returned object is \"disconnected\", i.e. does not receive\n        live updates, unless it is current (latest).\n\n        \"\"\"\n        if self._history_index == -1:\n            return None\n\n        new_index = self._history_index + 1\n        connected = (\n            new_index == len(self.model.state.entity_history(\n                self.entity_type, self.entity_id)) - 1\n        )\n        return self.model.state.get_entity(\n            self.entity_type, self.entity_id, self._history_index - 1,\n            connected=connected)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def get_controller(self):\n        from juju.controller import Controller\n        controller = Controller(jujudata=self._connector.jujudata)\n        kwargs = self.connection().connect_params()\n        kwargs.pop('uuid')\n        await controller._connect_direct(**kwargs)\n        return controller", "response": "Return a Controller instance for the currently connected model."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def connect(self, *args, **kwargs):\n        await self.disconnect()\n        if 'endpoint' not in kwargs and len(args) < 2:\n            if args and 'model_name' in kwargs:\n                raise TypeError('connect() got multiple values for model_name')\n            elif args:\n                model_name = args[0]\n            else:\n                model_name = kwargs.pop('model_name', None)\n            await self._connector.connect_model(model_name, **kwargs)\n        else:\n            if 'model_name' in kwargs:\n                raise TypeError('connect() got values for both '\n                                'model_name and endpoint')\n            if args and 'endpoint' in kwargs:\n                raise TypeError('connect() got multiple values for endpoint')\n            if len(args) < 2 and 'uuid' not in kwargs:\n                raise TypeError('connect() missing value for uuid')\n            has_userpass = (len(args) >= 4 or\n                            {'username', 'password'}.issubset(kwargs))\n            has_macaroons = (len(args) >= 6 or not\n                             {'bakery_client', 'macaroons'}.isdisjoint(kwargs))\n            if not (has_userpass or has_macaroons):\n                raise TypeError('connect() missing auth params')\n            arg_names = [\n                'endpoint',\n                'uuid',\n                'username',\n                'password',\n                'cacert',\n                'bakery_client',\n                'macaroons',\n                'loop',\n                'max_frame_size',\n            ]\n            for i, arg in enumerate(args):\n                kwargs[arg_names[i]] = arg\n            if not {'endpoint', 'uuid'}.issubset(kwargs):\n                raise ValueError('endpoint and uuid are required '\n                                 'if model_name not given')\n            if not ({'username', 'password'}.issubset(kwargs) or\n                    {'bakery_client', 'macaroons'}.intersection(kwargs)):\n                raise ValueError('Authentication parameters are required '\n                                 'if model_name not given')\n            await self._connector.connect(**kwargs)\n        await self._after_connect()", "response": "Connect to a juju model."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndisconnects from the model and closes the websockets.", "response": "async def disconnect(self):\n        \"\"\"Shut down the watcher task and close websockets.\n\n        \"\"\"\n        if not self._watch_stopped.is_set():\n            log.debug('Stopping watcher task')\n            self._watch_stopping.set()\n            await self._watch_stopped.wait()\n            self._watch_stopping.clear()\n\n        if self.is_connected():\n            log.debug('Closing model connection')\n            await self._connector.disconnect()\n            self._info = None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupload a local charm to the model.", "response": "async def add_local_charm_dir(self, charm_dir, series):\n        \"\"\"Upload a local charm to the model.\n\n        This will automatically generate an archive from\n        the charm dir.\n\n        :param charm_dir: Path to the charm directory\n        :param series: Charm series\n\n        \"\"\"\n        fh = tempfile.NamedTemporaryFile()\n        CharmArchiveGenerator(charm_dir).make_archive(fh.name)\n        with fh:\n            func = partial(\n                self.add_local_charm, fh, series, os.stat(fh.name).st_size)\n            charm_url = await self._connector.loop.run_in_executor(None, func)\n\n        log.debug('Uploaded local charm: %s -> %s', charm_dir, charm_url)\n        return charm_url"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupload a local charm archive to the model.", "response": "def add_local_charm(self, charm_file, series, size=None):\n        \"\"\"Upload a local charm archive to the model.\n\n        Returns the 'local:...' url that should be used to deploy the charm.\n\n        :param charm_file: Path to charm zip archive\n        :param series: Charm series\n        :param size: Size of the archive, in bytes\n        :return str: 'local:...' url for deploying the charm\n        :raises: :class:`JujuError` if the upload fails\n\n        Uses an https endpoint at the same host:port as the wss.\n        Supports large file uploads.\n\n        .. warning::\n\n           This method will block. Consider using :meth:`add_local_charm_dir`\n           instead.\n\n        \"\"\"\n        conn, headers, path_prefix = self.connection().https_connection()\n        path = \"%s/charms?series=%s\" % (path_prefix, series)\n        headers['Content-Type'] = 'application/zip'\n        if size:\n            headers['Content-Length'] = size\n        conn.request(\"POST\", path, charm_file, headers)\n        response = conn.getresponse()\n        result = response.read().decode()\n        if not response.status == 200:\n            raise JujuError(result)\n        result = json.loads(result)\n        return result['charm-url']"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef all_units_idle(self):\n        for unit in self.units.values():\n            unit_status = unit.data['agent-status']['current']\n            if unit_status != 'idle':\n                return False\n        return True", "response": "Return True if all units are idle."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def reset(self, force=False):\n        log.debug('Resetting model')\n        for app in self.applications.values():\n            await app.destroy()\n        for machine in self.machines.values():\n            await machine.destroy(force=force)\n        await self.block_until(\n            lambda: len(self.machines) == 0\n        )", "response": "Reset the model to a clean state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nblocking until all conditions are true.", "response": "async def block_until(self, *conditions, timeout=None, wait_period=0.5):\n        \"\"\"Return only after all conditions are true.\n\n        Raises `websockets.ConnectionClosed` if disconnected.\n        \"\"\"\n        def _disconnected():\n            return not (self.is_connected() and self.connection().is_open)\n\n        def done():\n            return _disconnected() or all(c() for c in conditions)\n\n        await utils.block_until(done,\n                                timeout=timeout,\n                                wait_period=wait_period,\n                                loop=self.loop)\n        if _disconnected():\n            raise websockets.ConnectionClosed(1006, 'no reason')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a client. ModelInfo object for this Model.", "response": "async def get_info(self):\n        \"\"\"Return a client.ModelInfo object for this Model.\n\n        Retrieves latest info for this Model from the api server. The\n        return value is cached on the Model.info attribute so that the\n        valued may be accessed again without another api call, if\n        desired.\n\n        This method is called automatically when the Model is connected,\n        resulting in Model.info being initialized without requiring an\n        explicit call to this method.\n\n        \"\"\"\n        facade = client.ClientFacade.from_connection(self.connection())\n\n        self._info = await facade.ModelInfo()\n        log.debug('Got ModelInfo: %s', vars(self.info))\n\n        return self.info"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_observer(\n            self, callable_, entity_type=None, action=None, entity_id=None,\n            predicate=None):\n        \"\"\"Register an \"on-model-change\" callback\n\n        Once the model is connected, ``callable_``\n        will be called each time the model changes. ``callable_`` should\n        be Awaitable and accept the following positional arguments:\n\n            delta - An instance of :class:`juju.delta.EntityDelta`\n                containing the raw delta data recv'd from the Juju\n                websocket.\n\n            old_obj - If the delta modifies an existing object in the model,\n                old_obj will be a copy of that object, as it was before the\n                delta was applied. Will be None if the delta creates a new\n                entity in the model.\n\n            new_obj - A copy of the new or updated object, after the delta\n                is applied. Will be None if the delta removes an entity\n                from the model.\n\n            model - The :class:`Model` itself.\n\n        Events for which ``callable_`` is called can be specified by passing\n        entity_type, action, and/or entitiy_id filter criteria, e.g.::\n\n            add_observer(\n                myfunc,\n                entity_type='application', action='add', entity_id='ubuntu')\n\n        For more complex filtering conditions, pass a predicate function. It\n        will be called with a delta as its only argument. If the predicate\n        function returns True, the ``callable_`` will be called.\n\n        \"\"\"\n        observer = _Observer(\n            callable_, entity_type, action, entity_id, predicate)\n        self._observers[observer] = callable_", "response": "Register an on - model - change callback that will be called every time the model changes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstarts an asynchronous watch against this model.", "response": "def _watch(self):\n        \"\"\"Start an asynchronous watch against this model.\n\n        See :meth:`add_observer` to register an onchange callback.\n\n        \"\"\"\n        async def _all_watcher():\n            try:\n                allwatcher = client.AllWatcherFacade.from_connection(\n                    self.connection())\n                while not self._watch_stopping.is_set():\n                    try:\n                        results = await utils.run_with_interrupt(\n                            allwatcher.Next(),\n                            self._watch_stopping,\n                            loop=self._connector.loop)\n                    except JujuAPIError as e:\n                        if 'watcher was stopped' not in str(e):\n                            raise\n                        if self._watch_stopping.is_set():\n                            # this shouldn't ever actually happen, because\n                            # the event should trigger before the controller\n                            # has a chance to tell us the watcher is stopped\n                            # but handle it gracefully, just in case\n                            break\n                        # controller stopped our watcher for some reason\n                        # but we're not actually stopping, so just restart it\n                        log.warning(\n                            'Watcher: watcher stopped, restarting')\n                        del allwatcher.Id\n                        continue\n                    except websockets.ConnectionClosed:\n                        monitor = self.connection().monitor\n                        if monitor.status == monitor.ERROR:\n                            # closed unexpectedly, try to reopen\n                            log.warning(\n                                'Watcher: connection closed, reopening')\n                            await self.connection().reconnect()\n                            if monitor.status != monitor.CONNECTED:\n                                # reconnect failed; abort and shutdown\n                                log.error('Watcher: automatic reconnect '\n                                          'failed; stopping watcher')\n                                break\n                            del allwatcher.Id\n                            continue\n                        else:\n                            # closed on request, go ahead and shutdown\n                            break\n                    if self._watch_stopping.is_set():\n                        try:\n                            await allwatcher.Stop()\n                        except websockets.ConnectionClosed:\n                            pass  # can't stop on a closed conn\n                        break\n                    for delta in results.deltas:\n                        try:\n                            delta = get_entity_delta(delta)\n                            old_obj, new_obj = self.state.apply_delta(delta)\n                            await self._notify_observers(delta, old_obj, new_obj)\n                        except KeyError as e:\n                            log.debug(\"unknown delta type: %s\", e.args[0])\n                    self._watch_received.set()\n            except CancelledError:\n                pass\n            except Exception:\n                log.exception('Error in watcher')\n                raise\n            finally:\n                self._watch_stopped.set()\n\n        log.debug('Starting watcher task')\n        self._watch_received.clear()\n        self._watch_stopping.clear()\n        self._watch_stopped.clear()\n        self._connector.loop.create_task(_all_watcher())"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nnotify observers of a change in the state of the object in the model.", "response": "async def _notify_observers(self, delta, old_obj, new_obj):\n        \"\"\"Call observing callbacks, notifying them of a change in model state\n\n        :param delta: The raw change from the watcher\n            (:class:`juju.client.overrides.Delta`)\n        :param old_obj: The object in the model that this delta updates.\n            May be None.\n        :param new_obj: The object in the model that is created or updated\n            by applying this delta.\n\n        \"\"\"\n        if new_obj and not old_obj:\n            delta.type = 'add'\n\n        log.debug(\n            'Model changed: %s %s %s',\n            delta.entity, delta.type, delta.get_id())\n\n        for o in self._observers:\n            if o.cares_about(delta):\n                asyncio.ensure_future(o(delta, old_obj, new_obj, self),\n                                      loop=self._connector.loop)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def _wait(self, entity_type, entity_id, action, predicate=None):\n        q = asyncio.Queue(loop=self._connector.loop)\n\n        async def callback(delta, old, new, model):\n            await q.put(delta.get_id())\n\n        self.add_observer(callback, entity_type, action, entity_id, predicate)\n        entity_id = await q.get()\n        # object might not be in the entity_map if we were waiting for a\n        # 'remove' action\n        return self.state._live_entity_map(entity_type).get(entity_id)", "response": "Block the calling routine until a given action has happened to the entity_id given."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwait for a new object to appear in the Model and return it.", "response": "async def _wait_for_new(self, entity_type, entity_id):\n        \"\"\"Wait for a new object to appear in the Model and return it.\n\n        Waits for an object of type ``entity_type`` with id ``entity_id``\n        to appear in the model.  This is similar to watching for the\n        object using ``block_until``, but uses the watcher rather than\n        polling.\n\n        \"\"\"\n        # if the entity is already in the model, just return it\n        if entity_id in self.state._live_entity_map(entity_type):\n            return self.state._live_entity_map(entity_type)[entity_id]\n        return await self._wait(entity_type, entity_id, None)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwaiting for an action to complete.", "response": "async def wait_for_action(self, action_id):\n        \"\"\"Given an action, wait for it to complete.\"\"\"\n\n        if action_id.startswith(\"action-\"):\n            # if we've been passed action.tag, transform it into the\n            # id that the api deltas will use.\n            action_id = action_id[7:]\n\n        def predicate(delta):\n            return delta.data['status'] in ('completed', 'failed')\n\n        return await self._wait('action', action_id, None, predicate)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def add_machine(\n            self, spec=None, constraints=None, disks=None, series=None):\n        \"\"\"Start a new, empty machine and optionally a container, or add a\n        container to a machine.\n\n        :param str spec: Machine specification\n            Examples::\n\n                (None) - starts a new machine\n                'lxd' - starts a new machine with one lxd container\n                'lxd:4' - starts a new lxd container on machine 4\n                'ssh:user@10.10.0.3:/path/to/private/key' - manually provision\n                a machine with ssh and the private key used for authentication\n                'zone=us-east-1a' - starts a machine in zone us-east-1s on AWS\n                'maas2.name' - acquire machine maas2.name on MAAS\n\n        :param dict constraints: Machine constraints, which can contain the\n            the following keys::\n\n                arch : str\n                container : str\n                cores : int\n                cpu_power : int\n                instance_type : str\n                mem : int\n                root_disk : int\n                spaces : list(str)\n                tags : list(str)\n                virt_type : str\n\n            Example::\n\n                constraints={\n                    'mem': 256 * MB,\n                    'tags': ['virtual'],\n                }\n\n        :param list disks: List of disk constraint dictionaries, which can\n            contain the following keys::\n\n                count : int\n                pool : str\n                size : int\n\n            Example::\n\n                disks=[{\n                    'pool': 'rootfs',\n                    'size': 10 * GB,\n                    'count': 1,\n                }]\n\n        :param str series: Series, e.g. 'xenial'\n\n        Supported container types are: lxd, kvm\n\n        When deploying a container to an existing machine, constraints cannot\n        be used.\n\n        \"\"\"\n        params = client.AddMachineParams()\n\n        if spec:\n            if spec.startswith(\"ssh:\"):\n                placement, target, private_key_path = spec.split(\":\")\n                user, host = target.split(\"@\")\n\n                sshProvisioner = provisioner.SSHProvisioner(\n                    host=host,\n                    user=user,\n                    private_key_path=private_key_path,\n                )\n\n                params = sshProvisioner.provision_machine()\n            else:\n                placement = parse_placement(spec)\n                if placement:\n                    params.placement = placement[0]\n\n        params.jobs = ['JobHostUnits']\n\n        if constraints:\n            params.constraints = client.Value.from_json(constraints)\n\n        if disks:\n            params.disks = [\n                client.Constraints.from_json(o) for o in disks]\n\n        if series:\n            params.series = series\n\n        # Submit the request.\n        client_facade = client.ClientFacade.from_connection(self.connection())\n        results = await client_facade.AddMachines([params])\n        error = results.machines[0].error\n        if error:\n            raise ValueError(\"Error adding machine: %s\" % error.message)\n        machine_id = results.machines[0].machine\n\n        if spec:\n            if spec.startswith(\"ssh:\"):\n                # Need to run this after AddMachines has been called,\n                # as we need the machine_id\n                await sshProvisioner.install_agent(\n                    self.connection(),\n                    params.nonce,\n                    machine_id,\n                )\n\n        log.debug('Added new machine %s', machine_id)\n        return await self._wait_for_new('machine', machine_id)", "response": "Start a new machine and optionally a container or add a container to a machine."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a relation between two applications.", "response": "async def add_relation(self, relation1, relation2):\n        \"\"\"Add a relation between two applications.\n\n        :param str relation1: '<application>[:<relation_name>]'\n        :param str relation2: '<application>[:<relation_name>]'\n\n        \"\"\"\n        connection = self.connection()\n        app_facade = client.ApplicationFacade.from_connection(connection)\n\n        log.debug(\n            'Adding relation %s <-> %s', relation1, relation2)\n\n        def _find_relation(*specs):\n            for rel in self.relations:\n                if rel.matches(*specs):\n                    return rel\n            return None\n\n        try:\n            result = await app_facade.AddRelation([relation1, relation2])\n        except JujuAPIError as e:\n            if 'relation already exists' not in e.message:\n                raise\n            rel = _find_relation(relation1, relation2)\n            if rel:\n                return rel\n            raise JujuError('Relation {} {} exists but not in model'.format(\n                relation1, relation2))\n\n        specs = ['{}:{}'.format(app, data['name'])\n                 for app, data in result.endpoints.items()]\n\n        await self.block_until(lambda: _find_relation(*specs) is not None)\n        return _find_relation(*specs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a public SSH key to this model.", "response": "async def add_ssh_key(self, user, key):\n        \"\"\"Add a public SSH key to this model.\n\n        :param str user: The username of the user\n        :param str key: The public ssh key\n\n        \"\"\"\n        key_facade = client.KeyManagerFacade.from_connection(self.connection())\n        return await key_facade.AddKeys([key], user)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets log messages for this model.", "response": "def debug_log(\n            self, no_tail=False, exclude_module=None, include_module=None,\n            include=None, level=None, limit=0, lines=10, replay=False,\n            exclude=None):\n        \"\"\"Get log messages for this model.\n\n        :param bool no_tail: Stop after returning existing log messages\n        :param list exclude_module: Do not show log messages for these logging\n            modules\n        :param list include_module: Only show log messages for these logging\n            modules\n        :param list include: Only show log messages for these entities\n        :param str level: Log level to show, valid options are 'TRACE',\n            'DEBUG', 'INFO', 'WARNING', 'ERROR,\n        :param int limit: Return this many of the most recent (possibly\n            filtered) lines are shown\n        :param int lines: Yield this many of the most recent lines, and keep\n            yielding\n        :param bool replay: Yield the entire log, and keep yielding\n        :param list exclude: Do not show log messages for these entities\n\n        \"\"\"\n        raise NotImplementedError()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def deploy(\n            self, entity_url, application_name=None, bind=None, budget=None,\n            channel=None, config=None, constraints=None, force=False,\n            num_units=1, plan=None, resources=None, series=None, storage=None,\n            to=None, devices=None):\n        \"\"\"Deploy a new service or bundle.\n\n        :param str entity_url: Charm or bundle url\n        :param str application_name: Name to give the service\n        :param dict bind: <charm endpoint>:<network space> pairs\n        :param dict budget: <budget name>:<limit> pairs\n        :param str channel: Charm store channel from which to retrieve\n            the charm or bundle, e.g. 'edge'\n        :param dict config: Charm configuration dictionary\n        :param constraints: Service constraints\n        :type constraints: :class:`juju.Constraints`\n        :param bool force: Allow charm to be deployed to a machine running\n            an unsupported series\n        :param int num_units: Number of units to deploy\n        :param str plan: Plan under which to deploy charm\n        :param dict resources: <resource name>:<file path> pairs\n        :param str series: Series on which to deploy\n        :param dict storage: Storage constraints TODO how do these look?\n        :param to: Placement directive as a string. For example:\n\n            '23' - place on machine 23\n            'lxd:7' - place in new lxd container on machine 7\n            '24/lxd/3' - place in container 3 on machine 24\n\n            If None, a new machine is provisioned.\n\n\n        TODO::\n\n            - support local resources\n\n        \"\"\"\n        if storage:\n            storage = {\n                k: client.Constraints(**v)\n                for k, v in storage.items()\n            }\n\n        entity_path = Path(entity_url.replace('local:', ''))\n        bundle_path = entity_path / 'bundle.yaml'\n        metadata_path = entity_path / 'metadata.yaml'\n\n        is_local = (\n            entity_url.startswith('local:') or\n            entity_path.is_dir() or\n            entity_path.is_file()\n        )\n        if is_local:\n            entity_id = entity_url.replace('local:', '')\n        else:\n            entity = await self.charmstore.entity(entity_url, channel=channel,\n                                                  include_stats=False)\n            entity_id = entity['Id']\n\n        client_facade = client.ClientFacade.from_connection(self.connection())\n\n        is_bundle = ((is_local and\n                      (entity_id.endswith('.yaml') and entity_path.exists()) or\n                      bundle_path.exists()) or\n                     (not is_local and 'bundle/' in entity_id))\n\n        if is_bundle:\n            handler = BundleHandler(self)\n            await handler.fetch_plan(entity_id)\n            await handler.execute_plan()\n            extant_apps = {app for app in self.applications}\n            pending_apps = set(handler.applications) - extant_apps\n            if pending_apps:\n                # new apps will usually be in the model by now, but if some\n                # haven't made it yet we'll need to wait on them to be added\n                await asyncio.gather(*[\n                    asyncio.ensure_future(\n                        self._wait_for_new('application', app_name),\n                        loop=self._connector.loop)\n                    for app_name in pending_apps\n                ], loop=self._connector.loop)\n            return [app for name, app in self.applications.items()\n                    if name in handler.applications]\n        else:\n            if not is_local:\n                if not application_name:\n                    application_name = entity['Meta']['charm-metadata']['Name']\n                if not series:\n                    series = self._get_series(entity_url, entity)\n                await client_facade.AddCharm(channel, entity_id)\n                # XXX: we're dropping local resources here, but we don't\n                # actually support them yet anyway\n                resources = await self._add_store_resources(application_name,\n                                                            entity_id,\n                                                            entity=entity)\n            else:\n                if not application_name:\n                    metadata = yaml.load(metadata_path.read_text())\n                    application_name = metadata['name']\n                # We have a local charm dir that needs to be uploaded\n                charm_dir = os.path.abspath(\n                    os.path.expanduser(entity_id))\n                series = series or get_charm_series(charm_dir)\n                if not series:\n                    raise JujuError(\n                        \"Couldn't determine series for charm at {}. \"\n                        \"Pass a 'series' kwarg to Model.deploy().\".format(\n                            charm_dir))\n                entity_id = await self.add_local_charm_dir(charm_dir, series)\n            return await self._deploy(\n                charm_url=entity_id,\n                application=application_name,\n                series=series,\n                config=config or {},\n                constraints=constraints,\n                endpoint_bindings=bind,\n                resources=resources,\n                storage=storage,\n                channel=channel,\n                num_units=num_units,\n                placement=parse_placement(to),\n                devices=devices,\n            )", "response": "Deploy a new charm or bundle to a new service or bundle."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeploys the specified charm.", "response": "async def _deploy(self, charm_url, application, series, config,\n                      constraints, endpoint_bindings, resources, storage,\n                      channel=None, num_units=None, placement=None,\n                      devices=None):\n        \"\"\"Logic shared between `Model.deploy` and `BundleHandler.deploy`.\n        \"\"\"\n        log.info('Deploying %s', charm_url)\n\n        # stringify all config values for API, and convert to YAML\n        config = {k: str(v) for k, v in config.items()}\n        config = yaml.dump({application: config},\n                           default_flow_style=False)\n\n        app_facade = client.ApplicationFacade.from_connection(\n            self.connection())\n\n        app = client.ApplicationDeploy(\n            charm_url=charm_url,\n            application=application,\n            series=series,\n            channel=channel,\n            config_yaml=config,\n            constraints=parse_constraints(constraints),\n            endpoint_bindings=endpoint_bindings,\n            num_units=num_units,\n            resources=resources,\n            storage=storage,\n            placement=placement,\n            devices=devices,\n        )\n        result = await app_facade.Deploy([app])\n        errors = [r.error.message for r in result.results if r.error]\n        if errors:\n            raise JujuError('\\n'.join(errors))\n        return await self._wait_for_new('application', application)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndestroy one or more units.", "response": "async def destroy_unit(self, *unit_names):\n        \"\"\"Destroy units by name.\n\n        \"\"\"\n        connection = self.connection()\n        app_facade = client.ApplicationFacade.from_connection(connection)\n\n        log.debug(\n            'Destroying unit%s %s',\n            's' if len(unit_names) == 1 else '',\n            ' '.join(unit_names))\n\n        return await app_facade.DestroyUnits(list(unit_names))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the configuration settings for this model.", "response": "async def get_config(self):\n        \"\"\"Return the configuration settings for this model.\n\n        :returns: A ``dict`` mapping keys to `ConfigValue` instances,\n            which have `source` and `value` attributes.\n        \"\"\"\n        config_facade = client.ModelConfigFacade.from_connection(\n            self.connection()\n        )\n        result = await config_facade.ModelGet()\n        config = result.config\n        for key, value in config.items():\n            config[key] = ConfigValue.from_json(value)\n        return config"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the machine constraints for this model.", "response": "async def get_constraints(self):\n        \"\"\"Return the machine constraints for this model.\n\n        :returns: A ``dict`` of constraints.\n        \"\"\"\n        constraints = {}\n        client_facade = client.ClientFacade.from_connection(self.connection())\n        result = await client_facade.GetModelConstraints()\n\n        # GetModelConstraints returns GetConstraintsResults which has a\n        # 'constraints' attribute. If no constraints have been set\n        # GetConstraintsResults.constraints is None. Otherwise\n        # GetConstraintsResults.constraints has an attribute for each possible\n        # constraint, each of these in turn will be None if they have not been\n        # set.\n        if result.constraints:\n            constraint_types = [a for a in dir(result.constraints)\n                                if a in Value._toSchema.keys()]\n            for constraint in constraint_types:\n                value = getattr(result.constraints, constraint)\n                if value is not None:\n                    constraints[constraint] = getattr(result.constraints,\n                                                      constraint)\n        return constraints"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def get_ssh_key(self, raw_ssh=False):\n        key_facade = client.KeyManagerFacade.from_connection(self.connection())\n        entity = {'tag': tag.model(self.info.uuid)}\n        entities = client.Entities([entity])\n        return await key_facade.ListKeys(entities, raw_ssh)", "response": "Return the known SSH keys for this model."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def remove_ssh_key(self, user, key):\n        key_facade = client.KeyManagerFacade.from_connection(self.connection())\n        key = base64.b64decode(bytes(key.strip().split()[1].encode('ascii')))\n        key = hashlib.md5(key).hexdigest()\n        key = ':'.join(a + b for a, b in zip(key[::2], key[1::2]))\n        await key_facade.DeleteKeys([key], user)", "response": "Remove a public SSH key from this model."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef restore_backup(\n            self, bootstrap=False, constraints=None, archive=None,\n            backup_id=None, upload_tools=False):\n        \"\"\"Restore a backup archive to a new controller.\n\n        :param bool bootstrap: Bootstrap a new state machine\n        :param constraints: Model constraints\n        :type constraints: :class:`juju.Constraints`\n        :param str archive: Path to backup archive to restore\n        :param str backup_id: Id of backup to restore\n        :param bool upload_tools: Upload tools if bootstrapping a new machine\n\n        \"\"\"\n        raise NotImplementedError()", "response": "Restore a backup archive to a new controller."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def set_config(self, config):\n        config_facade = client.ModelConfigFacade.from_connection(\n            self.connection()\n        )\n        for key, value in config.items():\n            if isinstance(value, ConfigValue):\n                config[key] = value.value\n        await config_facade.ModelSet(config)", "response": "Set the configuration keys on this model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting machine constraints on this model.", "response": "async def set_constraints(self, constraints):\n        \"\"\"Set machine constraints on this model.\n\n        :param dict config: Mapping of model constraints\n        \"\"\"\n        client_facade = client.ClientFacade.from_connection(self.connection())\n        await client_facade.SetModelConstraints(\n            application='',\n            constraints=constraints)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the output of an action by ID.", "response": "async def get_action_output(self, action_uuid, wait=None):\n        \"\"\"Get the results of an action by ID.\n\n        :param str action_uuid: Id of the action\n        :param int wait: Time in seconds to wait for action to complete.\n        :return dict: Output from action\n        :raises: :class:`JujuError` if invalid action_uuid\n        \"\"\"\n        action_facade = client.ActionFacade.from_connection(\n            self.connection()\n        )\n        entity = [{'tag': tag.action(action_uuid)}]\n        # Cannot use self.wait_for_action as the action event has probably\n        # already happened and self.wait_for_action works by processing\n        # model deltas and checking if they match our type. If the action\n        # has already occured then the delta has gone.\n\n        async def _wait_for_action_status():\n            while True:\n                action_output = await action_facade.Actions(entity)\n                if action_output.results[0].status in ('completed', 'failed'):\n                    return\n                else:\n                    await asyncio.sleep(1)\n        await asyncio.wait_for(\n            _wait_for_action_status(),\n            timeout=wait)\n        action_output = await action_facade.Actions(entity)\n        # ActionResult.output is None if the action produced no output\n        if action_output.results[0].output is None:\n            output = {}\n        else:\n            output = action_output.results[0].output\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def get_action_status(self, uuid_or_prefix=None, name=None):\n        results = {}\n        action_results = []\n        action_facade = client.ActionFacade.from_connection(\n            self.connection()\n        )\n        if name:\n            name_results = await action_facade.FindActionsByNames([name])\n            action_results.extend(name_results.actions[0].actions)\n        if uuid_or_prefix:\n            # Collect list of actions matching uuid or prefix\n            matching_actions = await action_facade.FindActionTagsByPrefix(\n                [uuid_or_prefix])\n            entities = []\n            for actions in matching_actions.matches.values():\n                entities = [{'tag': a.tag} for a in actions]\n            # Get action results matching action tags\n            uuid_results = await action_facade.Actions(entities)\n            action_results.extend(uuid_results.results)\n        for a in action_results:\n            results[tag.untag('action-', a.action.tag)] = a.status\n        return results", "response": "Get the status of all actions filtered by UUID or prefix or name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the status of the current model.", "response": "async def get_status(self, filters=None, utc=False):\n        \"\"\"Return the status of the model.\n\n        :param str filters: Optional list of applications, units, or machines\n            to include, which can use wildcards ('*').\n        :param bool utc: Display time as UTC in RFC3339 format\n\n        \"\"\"\n        client_facade = client.ClientFacade.from_connection(self.connection())\n        return await client_facade.FullStatus(filters)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncopying Juju tools into this model.", "response": "def sync_tools(\n            self, all_=False, destination=None, dry_run=False, public=False,\n            source=None, stream=None, version=None):\n        \"\"\"Copy Juju tools into this model.\n\n        :param bool all_: Copy all versions, not just the latest\n        :param str destination: Path to local destination directory\n        :param bool dry_run: Don't do the actual copy\n        :param bool public: Tools are for a public cloud, so generate mirrors\n            information\n        :param str source: Path to local source directory\n        :param str stream: Simplestreams stream for which to sync metadata\n        :param str version: Copy a specific major.minor version\n\n        \"\"\"\n        raise NotImplementedError()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef upgrade_juju(\n            self, dry_run=False, reset_previous_upgrade=False,\n            upload_tools=False, version=None):\n        \"\"\"Upgrade Juju on all machines in a model.\n\n        :param bool dry_run: Don't do the actual upgrade\n        :param bool reset_previous_upgrade: Clear the previous (incomplete)\n            upgrade status\n        :param bool upload_tools: Upload local version of tools\n        :param str version: Upgrade to a specific version\n\n        \"\"\"\n        raise NotImplementedError()", "response": "Upgrade Juju on all machines in a model."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nretrieve metrics for the specified tags.", "response": "async def get_metrics(self, *tags):\n        \"\"\"Retrieve metrics.\n\n        :param str *tags: Tags of entities from which to retrieve metrics.\n            No tags retrieves the metrics of all units in the model.\n        :return: Dictionary of unit_name:metrics\n\n        \"\"\"\n        log.debug(\"Retrieving metrics for %s\",\n                  ', '.join(tags) if tags else \"all units\")\n\n        metrics_facade = client.MetricsDebugFacade.from_connection(\n            self.connection())\n\n        entities = [client.Entity(tag) for tag in tags]\n        metrics_result = await metrics_facade.GetMetrics(entities)\n\n        metrics = collections.defaultdict(list)\n\n        for entity_metrics in metrics_result.results:\n            error = entity_metrics.error\n            if error:\n                if \"is not a valid tag\" in error:\n                    raise ValueError(error.message)\n                else:\n                    raise Exception(error.message)\n\n            for metric in entity_metrics.metrics:\n                metrics[metric.unit].append(vars(metric))\n\n        return metrics"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupload local charms to the model and replace them with appropriate local paths in the bundle.", "response": "async def _handle_local_charms(self, bundle):\n        \"\"\"Search for references to local charms (i.e. filesystem paths)\n        in the bundle. Upload the local charms to the model, and replace\n        the filesystem paths with appropriate 'local:' paths in the bundle.\n\n        Return the modified bundle.\n\n        :param dict bundle: Bundle dictionary\n        :return: Modified bundle dictionary\n\n        \"\"\"\n        apps, args = [], []\n\n        default_series = bundle.get('series')\n        apps_dict = bundle.get('applications', bundle.get('services', {}))\n        for app_name in self.applications:\n            app_dict = apps_dict[app_name]\n            charm_dir = os.path.abspath(os.path.expanduser(app_dict['charm']))\n            if not os.path.isdir(charm_dir):\n                continue\n            series = (\n                app_dict.get('series') or\n                default_series or\n                get_charm_series(charm_dir)\n            )\n            if not series:\n                raise JujuError(\n                    \"Couldn't determine series for charm at {}. \"\n                    \"Add a 'series' key to the bundle.\".format(charm_dir))\n\n            # Keep track of what we need to update. We keep a list of apps\n            # that need to be updated, and a corresponding list of args\n            # needed to update those apps.\n            apps.append(app_name)\n            args.append((charm_dir, series))\n\n        if apps:\n            # If we have apps to update, spawn all the coroutines concurrently\n            # and wait for them to finish.\n            charm_urls = await asyncio.gather(*[\n                self.model.add_local_charm_dir(*params)\n                for params in args\n            ], loop=self.model.loop)\n            # Update the 'charm:' entry for each app with the new 'local:' url.\n            for app_name, charm_url in zip(apps, charm_urls):\n                apps_dict[app_name]['charm'] = charm_url\n\n        return bundle"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a charm to the charmstore.", "response": "async def addCharm(self, charm, series):\n        \"\"\"\n        :param charm string:\n            Charm holds the URL of the charm to be added.\n\n        :param series string:\n            Series holds the series of the charm to be added\n            if the charm default is not sufficient.\n        \"\"\"\n        # We don't add local charms because they've already been added\n        # by self._handle_local_charms\n        if charm.startswith('local:'):\n            return charm\n\n        entity_id = await self.charmstore.entityId(charm)\n        log.debug('Adding %s', entity_id)\n        await self.client_facade.AddCharm(None, entity_id)\n        return entity_id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd machines to the specified set of machines.", "response": "async def addMachines(self, params=None):\n        \"\"\"\n        :param params dict:\n            Dictionary specifying the machine to add. All keys are optional.\n            Keys include:\n\n            series: string specifying the machine OS series.\n\n            constraints: string holding machine constraints, if any. We'll\n                parse this into the json friendly dict that the juju api\n                expects.\n\n            container_type: string holding the type of the container (for\n                instance \"\"lxd\" or kvm\"). It is not specified for top level\n                machines.\n\n            parent_id: string holding a placeholder pointing to another\n                machine change or to a unit change. This value is only\n                specified in the case this machine is a container, in\n                which case also ContainerType is set.\n\n        \"\"\"\n        params = params or {}\n\n        # Normalize keys\n        params = {normalize_key(k): params[k] for k in params.keys()}\n\n        # Fix up values, as necessary.\n        if 'parent_id' in params:\n            if params['parent_id'].startswith('$addUnit'):\n                unit = self.resolve(params['parent_id'])[0]\n                params['parent_id'] = unit.machine.entity_id\n            else:\n                params['parent_id'] = self.resolve(params['parent_id'])\n\n        params['constraints'] = parse_constraints(\n            params.get('constraints'))\n        params['jobs'] = params.get('jobs', ['JobHostUnits'])\n\n        if params.get('container_type') == 'lxc':\n            log.warning('Juju 2.0 does not support lxc containers. '\n                        'Converting containers to lxd.')\n            params['container_type'] = 'lxd'\n\n        # Submit the request.\n        params = client.AddMachineParams(**params)\n        results = await self.client_facade.AddMachines([params])\n        error = results.machines[0].error\n        if error:\n            raise ValueError(\"Error adding machine: %s\" % error.message)\n        machine = results.machines[0].machine\n        log.debug('Added new machine %s', machine)\n        return machine"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a relation between two endpoints.", "response": "async def addRelation(self, endpoint1, endpoint2):\n        \"\"\"\n        :param endpoint1 string:\n        :param endpoint2 string:\n            Endpoint1 and Endpoint2 hold relation endpoints in the\n            \"application:interface\" form, where the application is always a\n            placeholder pointing to an application change, and the interface is\n            optional. Examples are \"$deploy-42:web\" or just \"$deploy-42\".\n        \"\"\"\n        endpoints = [endpoint1, endpoint2]\n        # resolve indirect references\n        for i in range(len(endpoints)):\n            parts = endpoints[i].split(':')\n            parts[0] = self.resolve(parts[0])\n            endpoints[i] = ':'.join(parts)\n\n        log.info('Relating %s <-> %s', *endpoints)\n        return await self.model.add_relation(*endpoints)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def deploy(self, charm, series, application, options, constraints,\n                     storage, endpoint_bindings, *args):\n        \"\"\"\n        :param charm string:\n            Charm holds the URL of the charm to be used to deploy this\n            application.\n\n        :param series string:\n            Series holds the series of the application to be deployed\n            if the charm default is not sufficient.\n\n        :param application string:\n            Application holds the application name.\n\n        :param options map[string]interface{}:\n            Options holds application options.\n\n        :param constraints string:\n            Constraints holds the optional application constraints.\n\n        :param storage map[string]string:\n            Storage holds the optional storage constraints.\n\n        :param endpoint_bindings map[string]string:\n            EndpointBindings holds the optional endpoint bindings\n\n        :param devices map[string]string:\n            Devices holds the optional devices constraints.\n            (Only given on Juju 2.5+)\n\n        :param resources map[string]int:\n            Resources identifies the revision to use for each resource\n            of the application's charm.\n\n        :param num_units int:\n            NumUnits holds the number of units required.  For IAAS models, this\n            will be 0 and separate AddUnitChanges will be used.  For Kubernetes\n            models, this will be used to scale the application.\n            (Only given on Juju 2.5+)\n        \"\"\"\n        # resolve indirect references\n        charm = self.resolve(charm)\n\n        if len(args) == 1:\n            # Juju 2.4 and below only sends the resources\n            resources = args[0]\n            devices, num_units = None, None\n        else:\n            # Juju 2.5+ sends devices before resources, as well as num_units\n            # There might be placement but we need to ignore that.\n            devices, resources, num_units = args[:3]\n\n        if not charm.startswith('local:'):\n            resources = await self.model._add_store_resources(\n                application, charm, overrides=resources)\n        await self.model._deploy(\n            charm_url=charm,\n            application=application,\n            series=series,\n            config=options,\n            constraints=constraints,\n            endpoint_bindings=endpoint_bindings,\n            resources=resources,\n            storage=storage,\n            devices=devices,\n            num_units=num_units,\n        )\n        return application", "response": "Deploy the specified charm to the specified application."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def addUnit(self, application, to):\n        application = self.resolve(application)\n        placement = self.resolve(to)\n        if self._units_by_app.get(application):\n            # enough units for this application already exist;\n            # claim one, and carry on\n            # NB: this should probably honor placement, but the juju client\n            # doesn't, so we're not bothering, either\n            unit_name = self._units_by_app[application].pop()\n            log.debug('Reusing unit %s for %s', unit_name, application)\n            return self.model.units[unit_name]\n\n        log.debug('Adding new unit for %s%s', application,\n                  ' to %s' % placement if placement else '')\n        return await self.model.applications[application].add_unit(\n            count=1,\n            to=placement,\n        )", "response": "Add a new unit to the specified application."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling a change of scale to a k8s application.", "response": "async def scale(self, application, scale):\n        \"\"\"\n        Handle a change of scale to a k8s application.\n\n        :param string application:\n            Application holds the application placeholder name for which a unit\n            is added.\n\n        :param int scale:\n            New scale value to use.\n        \"\"\"\n        application = self.resolve(application)\n        return await self.model.applications[application].scale(scale=scale)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def expose(self, application):\n        application = self.resolve(application)\n        log.info('Exposing %s', application)\n        return await self.model.applications[application].expose()", "response": "Exposes the specified application."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the annotations of an entity.", "response": "async def setAnnotations(self, id_, entity_type, annotations):\n        \"\"\"\n        :param id_ string:\n            Id is the placeholder for the application or machine change\n            corresponding to the entity to be annotated.\n\n        :param entity_type EntityType:\n            EntityType holds the type of the entity, \"application\" or\n            \"machine\".\n\n        :param annotations map[string]string:\n            Annotations holds the annotations as key/value pairs.\n        \"\"\"\n        entity_id = self.resolve(id_)\n        try:\n            entity = self.model.state.get_entity(entity_type, entity_id)\n        except KeyError:\n            entity = await self.model._wait_for_new(entity_type, entity_id)\n        return await entity.set_annotations(annotations)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a zip archive of the current charm and write it to path.", "response": "def make_archive(self, path):\n        \"\"\"Create archive of directory and write to ``path``.\n\n        :param path: Path to archive\n\n        Ignored::\n\n            * build/* - This is used for packing the charm itself and any\n                          similar tasks.\n            * */.*    - Hidden files are all ignored for now.  This will most\n                          likely be changed into a specific ignore list\n                          (.bzr, etc)\n\n        \"\"\"\n        zf = zipfile.ZipFile(path, 'w', zipfile.ZIP_DEFLATED)\n        for dirpath, dirnames, filenames in os.walk(self.path):\n            relative_path = dirpath[len(self.path) + 1:]\n            if relative_path and not self._ignore(relative_path):\n                zf.write(dirpath, relative_path)\n            for name in filenames:\n                archive_name = os.path.join(relative_path, name)\n                if not self._ignore(archive_name):\n                    real_path = os.path.join(dirpath, name)\n                    self._check_type(real_path)\n                    if os.path.islink(real_path):\n                        self._check_link(real_path)\n                        self._write_symlink(\n                            zf, os.readlink(real_path), archive_name)\n                    else:\n                        zf.write(real_path, archive_name)\n        zf.close()\n        return path"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _check_type(self, path):\n        s = os.stat(path)\n        if stat.S_ISDIR(s.st_mode) or stat.S_ISREG(s.st_mode):\n            return path\n        raise ValueError(\"Invalid Charm at % %s\" % (\n            path, \"Invalid file type for a charm\"))", "response": "Check the path for the type of the charm"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites a symlink to the zipfile.", "response": "def _write_symlink(self, zf, link_target, link_path):\n        \"\"\"Package symlinks with appropriate zipfile metadata.\"\"\"\n        info = zipfile.ZipInfo()\n        info.filename = link_path\n        info.create_system = 3\n        # Magic code for symlinks / py2/3 compat\n        # 27166663808 = (stat.S_IFLNK | 0755) << 16\n        info.external_attr = 2716663808\n        zf.writestr(info, link_target)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def set_password(self, password):\n        await self.controller.change_user_password(self.username, password)\n        self._user_info.password = password", "response": "Update this user s password."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngranting this user to the controller.", "response": "async def grant(self, acl='login'):\n        \"\"\"Set access level of this user on the controller.\n\n        :param str acl: Access control ('login', 'add-model', or 'superuser')\n        \"\"\"\n        if await self.controller.grant(self.username, acl):\n            self._user_info.access = acl"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def revoke(self):\n        await self.controller.revoke(self.username)\n        self._user_info.access = ''", "response": "Removes all access rights for this user from the controller."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def Enqueue(self, actions):\n        '''\n        actions : typing.Sequence[~Action]\n        Returns -> typing.Sequence[~ActionResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Action',\n                   request='Enqueue',\n                   version=3,\n                   params=_params)\n        _params['actions'] = actions\n        reply = await self.rpc(msg)\n        return reply", "response": "Enqueue the given set of actions."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def FindActionTagsByPrefix(self, prefixes):\n        '''\n        prefixes : typing.Sequence[str]\n        Returns -> typing.Sequence[~Entity]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Action',\n                   request='FindActionTagsByPrefix',\n                   version=3,\n                   params=_params)\n        _params['prefixes'] = prefixes\n        reply = await self.rpc(msg)\n        return reply", "response": "Find action tags by prefix."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a relation to a set of endpoints.", "response": "async def AddRelation(self, endpoints):\n        '''\n        endpoints : typing.Sequence[str]\n        Returns -> typing.Mapping[str, ~CharmRelation]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Application',\n                   request='AddRelation',\n                   version=3,\n                   params=_params)\n        _params['endpoints'] = endpoints\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def DestroyUnits(self, unit_names):\n        '''\n        unit_names : typing.Sequence[str]\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Application',\n                   request='DestroyUnits',\n                   version=3,\n                   params=_params)\n        _params['unit-names'] = unit_names\n        reply = await self.rpc(msg)\n        return reply", "response": "Destroy the specified set of units."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def AddCloud(self, cloud, name):\n        '''\n        cloud : Cloud\n        name : str\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Cloud',\n                   request='AddCloud',\n                   version=3,\n                   params=_params)\n        _params['cloud'] = cloud\n        _params['name'] = name\n        reply = await self.rpc(msg)\n        return reply", "response": "Add a cloud to a specific resource."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def CredentialContents(self, credentials, include_secrets):\n        '''\n        credentials : typing.Sequence[~CloudCredentialArg]\n        include_secrets : bool\n        Returns -> typing.Sequence[~CredentialContentResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Cloud',\n                   request='CredentialContents',\n                   version=3,\n                   params=_params)\n        _params['credentials'] = credentials\n        _params['include-secrets'] = include_secrets\n        reply = await self.rpc(msg)\n        return reply", "response": "Get the contents of the specified credentials."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrevoke credentials from the specified set of credentials.", "response": "async def RevokeCredentialsCheckModels(self, credentials):\n        '''\n        credentials : typing.Sequence[~RevokeCredentialArg]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Cloud',\n                   request='RevokeCredentialsCheckModels',\n                   version=3,\n                   params=_params)\n        _params['credentials'] = credentials\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def UpdateCredentialsCheckModels(self, credentials, force):\n        '''\n        credentials : typing.Sequence[~TaggedCredential]\n        force : bool\n        Returns -> typing.Sequence[~UpdateCredentialResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Cloud',\n                   request='UpdateCredentialsCheckModels',\n                   version=3,\n                   params=_params)\n        _params['credentials'] = credentials\n        _params['force'] = force\n        reply = await self.rpc(msg)\n        return reply", "response": "Updates the set of credentials for the current session."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget user credentials for a set of user clouds.", "response": "async def UserCredentials(self, user_clouds):\n        '''\n        user_clouds : typing.Sequence[~UserCloud]\n        Returns -> typing.Sequence[~StringsResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Cloud',\n                   request='UserCredentials',\n                   version=3,\n                   params=_params)\n        _params['user-clouds'] = user_clouds\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the current configuration of the container manager.", "response": "async def ContainerManagerConfig(self, type_):\n        '''\n        type_ : str\n        Returns -> typing.Mapping[str, str]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Provisioner',\n                   request='ContainerManagerConfig',\n                   version=3,\n                   params=_params)\n        _params['type'] = type_\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new pool.", "response": "async def CreatePool(self, attrs, name, provider):\n        '''\n        attrs : typing.Mapping[str, typing.Any]\n        name : str\n        provider : str\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Storage',\n                   request='CreatePool',\n                   version=3,\n                   params=_params)\n        _params['attrs'] = attrs\n        _params['name'] = name\n        _params['provider'] = provider\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset filesystem attachments info.", "response": "async def SetFilesystemAttachmentInfo(self, filesystem_attachments):\n        '''\n        filesystem_attachments : typing.Sequence[~FilesystemAttachment]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='StorageProvisioner',\n                   request='SetFilesystemAttachmentInfo',\n                   version=3,\n                   params=_params)\n        _params['filesystem-attachments'] = filesystem_attachments\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def SetFilesystemInfo(self, filesystems):\n        '''\n        filesystems : typing.Sequence[~Filesystem]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='StorageProvisioner',\n                   request='SetFilesystemInfo',\n                   version=3,\n                   params=_params)\n        _params['filesystems'] = filesystems\n        reply = await self.rpc(msg)\n        return reply", "response": "Set filesystems to the specified filesystems."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def _workaround_1695335(self, delta, old, new, model):\n        if delta.data.get('synthetic', False):\n            # prevent infinite loops re-processing already processed deltas\n            return\n\n        full_status = await utils.run_with_interrupt(model.get_status(),\n                                                     model._watch_stopping,\n                                                     loop=model.loop)\n        if model._watch_stopping.is_set():\n            return\n\n        if self.id not in full_status.machines:\n            return\n\n        if not full_status.machines[self.id]['instance-status']['since']:\n            return\n\n        machine = full_status.machines[self.id]\n\n        change_log = []\n        key_map = {\n            'status': 'current',\n            'info': 'message',\n            'since': 'since',\n        }\n\n        # handle agent version specially, because it's never set in\n        # deltas, and we don't want even a newer delta to clear it\n        agent_version = machine['agent-status']['version']\n        if agent_version:\n            delta.data['agent-status']['version'] = agent_version\n            change_log.append(('agent-version', '', agent_version))\n\n        # only update (other) delta fields if status data is newer\n        status_since = pyrfc3339.parse(machine['instance-status']['since'])\n        delta_since = pyrfc3339.parse(delta.data['instance-status']['since'])\n        if status_since > delta_since:\n            for status_key in ('status', 'info', 'since'):\n                delta_key = key_map[status_key]\n                status_value = machine['instance-status'][status_key]\n                delta_value = delta.data['instance-status'][delta_key]\n                change_log.append((delta_key, delta_value, status_value))\n                delta.data['instance-status'][delta_key] = status_value\n\n        if change_log:\n            log.debug('Overriding machine delta with FullStatus data')\n            for log_item in change_log:\n                log.debug('    {}: {} -> {}'.format(*log_item))\n            delta.data['synthetic'] = True\n            old_obj, new_obj = self.model.state.apply_delta(delta)\n            await model._notify_observers(delta, old_obj, new_obj)", "response": "Workaround for a bug in Juju where the instance status and agent version fields don t get updated properly."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove this machine from the model.", "response": "async def destroy(self, force=False):\n        \"\"\"Remove this machine from the model.\n\n        Blocks until the machine is actually removed.\n\n        \"\"\"\n        facade = client.ClientFacade.from_connection(self.connection)\n\n        log.debug(\n            'Destroying machine %s', self.id)\n\n        await facade.DestroyMachines(force, [self.id])\n        return await self.model._wait(\n            'machine', self.id, 'remove')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntransferring files from local path to remote path.", "response": "async def scp_to(self, source, destination, user='ubuntu', proxy=False,\n                     scp_opts=''):\n        \"\"\"Transfer files to this machine.\n\n        :param str source: Local path of file(s) to transfer\n        :param str destination: Remote destination of transferred files\n        :param str user: Remote username\n        :param bool proxy: Proxy through the Juju API server\n        :param scp_opts: Additional options to the `scp` command\n        :type scp_opts: str or list\n        \"\"\"\n        if proxy:\n            raise NotImplementedError('proxy option is not implemented')\n\n        address = self.dns_name\n        destination = '%s@%s:%s' % (user, address, destination)\n        await self._scp(source, destination, scp_opts)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexecuting an scp command. Requires a fully qualified source and destination.", "response": "async def _scp(self, source, destination, scp_opts):\n        \"\"\" Execute an scp command. Requires a fully qualified source and\n        destination.\n        \"\"\"\n        cmd = [\n            'scp',\n            '-i', os.path.expanduser('~/.local/share/juju/ssh/juju_id_rsa'),\n            '-o', 'StrictHostKeyChecking=no',\n            '-q',\n            '-B'\n        ]\n        cmd.extend(scp_opts.split() if isinstance(scp_opts, str) else scp_opts)\n        cmd.extend([source, destination])\n        loop = self.model.loop\n        process = await asyncio.create_subprocess_exec(*cmd, loop=loop)\n        await process.wait()\n        if process.returncode != 0:\n            raise JujuError(\"command failed: %s\" % cmd)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef agent_version(self):\n        version = self.safe_data['agent-status']['version']\n        if version:\n            return client.Number.from_json(version)\n        else:\n            return None", "response": "Get the version of the Juju machine agent."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the DNS name for this machine.", "response": "def dns_name(self):\n        \"\"\"Get the DNS name for this machine. This is a best guess based on the\n        addresses available in current data.\n\n        May return None if no suitable address is found.\n        \"\"\"\n        for scope in ['public', 'local-cloud']:\n            addresses = self.safe_data['addresses'] or []\n            addresses = [address for address in addresses\n                         if address['scope'] == scope]\n            if addresses:\n                return addresses[0]['value']\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef lookup_facade(name, version):\n    for _version in range(int(version), 0, -1):\n        try:\n            facade = getattr(CLIENTS[str(_version)], name)\n            return facade\n        except (KeyError, AttributeError):\n            continue\n    else:\n        raise ImportError(\"No supported version for facade: \"\n                          \"{}\".format(name))", "response": "Given a facade name and version attempt to pull that facade out of the correct client<version. py file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngives a connected Connection object return an initialized and connected instance of the class.", "response": "def from_connection(cls, connection):\n        \"\"\"\n        Given a connected Connection object, return an initialized and\n        connected instance of an API Interface matching the name of\n        this class.\n\n        @param connection: initialized Connection object.\n\n        \"\"\"\n        facade_name = cls.__name__\n        if not facade_name.endswith('Facade'):\n           raise TypeError('Unexpected class name: {}'.format(facade_name))\n        facade_name = facade_name[:-len('Facade')]\n        version = connection.facades.get(facade_name)\n        if version is None:\n            raise Exception('No facade {} in facades {}'.format(facade_name,\n                                                                connection.facades))\n\n        c = lookup_facade(cls.__name__, version)\n        c = c()\n        c.connect(connection)\n\n        return c"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npruning the current set of entries for the current session.", "response": "async def Prune(self, max_history_mb, max_history_time):\n        '''\n        max_history_mb : int\n        max_history_time : int\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='ActionPruner',\n                   request='Prune',\n                   version=1,\n                   params=_params)\n        _params['max-history-mb'] = max_history_mb\n        _params['max-history-time'] = max_history_time\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def Restore(self, backup_id):\n        '''\n        backup_id : str\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Backups',\n                   request='Restore',\n                   version=1,\n                   params=_params)\n        _params['backup-id'] = backup_id\n        reply = await self.rpc(msg)\n        return reply", "response": "Restores a backup of the specified resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the changes for the given locale.", "response": "async def GetChanges(self, yaml):\n        '''\n        yaml : str\n        Returns -> typing.Union[typing.Sequence[~BundleChange], typing.Sequence[str]]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Bundle',\n                   request='GetChanges',\n                   version=1,\n                   params=_params)\n        _params['yaml'] = yaml\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def AddCharm(self, channel, url):\n        '''\n        channel : str\n        url : str\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Client',\n                   request='AddCharm',\n                   version=1,\n                   params=_params)\n        _params['channel'] = channel\n        _params['url'] = url\n        reply = await self.rpc(msg)\n        return reply", "response": "Add a charm to the cache."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def DestroyMachines(self, force, machine_names):\n        '''\n        force : bool\n        machine_names : typing.Sequence[str]\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Client',\n                   request='DestroyMachines',\n                   version=1,\n                   params=_params)\n        _params['force'] = force\n        _params['machine-names'] = machine_names\n        reply = await self.rpc(msg)\n        return reply", "response": "Destroy the specified set of machines."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind tools in a specific language.", "response": "async def FindTools(self, arch, major, minor, number, series):\n        '''\n        arch : str\n        major : int\n        minor : int\n        number : Number\n        series : str\n        Returns -> typing.Union[_ForwardRef('Error'), typing.Sequence[~Tools]]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Client',\n                   request='FindTools',\n                   version=1,\n                   params=_params)\n        _params['arch'] = arch\n        _params['major'] = major\n        _params['minor'] = minor\n        _params['number'] = number\n        _params['series'] = series\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def ProvisioningScript(self, data_dir, disable_package_commands, machine_id, nonce):\n        '''\n        data_dir : str\n        disable_package_commands : bool\n        machine_id : str\n        nonce : str\n        Returns -> str\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Client',\n                   request='ProvisioningScript',\n                   version=1,\n                   params=_params)\n        _params['data-dir'] = data_dir\n        _params['disable-package-commands'] = disable_package_commands\n        _params['machine-id'] = machine_id\n        _params['nonce'] = nonce\n        reply = await self.rpc(msg)\n        return reply", "response": "This method is used to get the provisioning script for a specific resource."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def Resolved(self, retry, unit_name):\n        '''\n        retry : bool\n        unit_name : str\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Client',\n                   request='Resolved',\n                   version=1,\n                   params=_params)\n        _params['retry'] = retry\n        _params['unit-name'] = unit_name\n        reply = await self.rpc(msg)\n        return reply", "response": "Get the resolved set of cookies."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def InstanceTypes(self, constraints):\n        '''\n        constraints : typing.Sequence[~CloudInstanceTypesConstraint]\n        Returns -> typing.Sequence[~InstanceTypesResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Cloud',\n                   request='InstanceTypes',\n                   version=1,\n                   params=_params)\n        _params['constraints'] = constraints\n        reply = await self.rpc(msg)\n        return reply", "response": "Get the list of instance types for the specified set of keys."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def InvalidateModelCredential(self, reason):\n        '''\n        reason : str\n        Returns -> Error\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='CredentialManager',\n                   request='InvalidateModelCredential',\n                   version=1,\n                   params=_params)\n        _params['reason'] = reason\n        reply = await self.rpc(msg)\n        return reply", "response": "Invalidate the model credential."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def RegisterRemoteRelations(self, relations):\n        '''\n        relations : typing.Sequence[~RegisterRemoteRelationArg]\n        Returns -> typing.Sequence[~RegisterRemoteRelationResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='CrossModelRelations',\n                   request='RegisterRemoteRelations',\n                   version=1,\n                   params=_params)\n        _params['relations'] = relations\n        reply = await self.rpc(msg)\n        return reply", "response": "relations : typing.Sequence[~RegisterRemoteRelationArg]\n        Returns -> typing.Sequence[~RegisterRemoteRelationResult]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def SetExternalControllerInfo(self, controllers):\n        '''\n        controllers : typing.Sequence[~SetExternalControllerInfoParams]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='ExternalControllerUpdater',\n                   request='SetExternalControllerInfo',\n                   version=1,\n                   params=_params)\n        _params['controllers'] = controllers\n        reply = await self.rpc(msg)\n        return reply", "response": "Set the external controller info for the specified controllers."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreport the keys for the specified entity.", "response": "async def ReportKeys(self, entity_keys):\n        '''\n        entity_keys : typing.Sequence[~SSHHostKeys]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='HostKeyReporter',\n                   request='ReportKeys',\n                   version=1,\n                   params=_params)\n        _params['entity-keys'] = entity_keys\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nimporting SSH keys into a new set of keys.", "response": "async def ImportKeys(self, ssh_keys, user):\n        '''\n        ssh_keys : typing.Sequence[str]\n        user : str\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='KeyManager',\n                   request='ImportKeys',\n                   version=1,\n                   params=_params)\n        _params['ssh-keys'] = ssh_keys\n        _params['user'] = user\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def ListKeys(self, entities, mode):\n        '''\n        entities : Entities\n        mode : bool\n        Returns -> typing.Sequence[~StringsResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='KeyManager',\n                   request='ListKeys',\n                   version=1,\n                   params=_params)\n        _params['entities'] = entities\n        _params['mode'] = mode\n        reply = await self.rpc(msg)\n        return reply", "response": "List the keys in the specified set of entities."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def SetMachineAddresses(self, machine_addresses):\n        '''\n        machine_addresses : typing.Sequence[~MachineAddresses]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Machiner',\n                   request='SetMachineAddresses',\n                   version=1,\n                   params=_params)\n        _params['machine-addresses'] = machine_addresses\n        reply = await self.rpc(msg)\n        return reply", "response": "Set the machine addresses for the current session."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def SetPhase(self, phase):\n        '''\n        phase : str\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='MigrationMaster',\n                   request='SetPhase',\n                   version=1,\n                   params=_params)\n        _params['phase'] = phase\n        reply = await self.rpc(msg)\n        return reply", "response": "Set the current phase of the migration master."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the status of the current migration master.", "response": "async def SetStatusMessage(self, message):\n        '''\n        message : str\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='MigrationMaster',\n                   request='SetStatusMessage',\n                   version=1,\n                   params=_params)\n        _params['message'] = message\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreporting the migration - id phase and success.", "response": "async def Report(self, migration_id, phase, success):\n        '''\n        migration_id : str\n        phase : str\n        success : bool\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='MigrationMinion',\n                   request='Report',\n                   version=1,\n                   params=_params)\n        _params['migration-id'] = migration_id\n        _params['phase'] = phase\n        _params['success'] = success\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadopting the resources for a specific model.", "response": "async def AdoptResources(self, model_tag, source_controller_version):\n        '''\n        model_tag : str\n        source_controller_version : Number\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='MigrationTarget',\n                   request='AdoptResources',\n                   version=1,\n                   params=_params)\n        _params['model-tag'] = model_tag\n        _params['source-controller-version'] = source_controller_version\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck the names of all machines in the specified model.", "response": "async def CheckMachines(self, model_tag):\n        '''\n        model_tag : str\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='MigrationTarget',\n                   request='CheckMachines',\n                   version=1,\n                   params=_params)\n        _params['model-tag'] = model_tag\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def Import(self, bytes_, charms, tools):\n        '''\n        bytes_ : typing.Sequence[int]\n        charms : typing.Sequence[str]\n        tools : typing.Sequence[~SerializedModelTools]\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='MigrationTarget',\n                   request='Import',\n                   version=1,\n                   params=_params)\n        _params['bytes'] = bytes_\n        _params['charms'] = charms\n        _params['tools'] = tools\n        reply = await self.rpc(msg)\n        return reply", "response": "This method imports the specified set of modules from the specified bytes and returns the list of modules that have been imported."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def SetSLALevel(self, creds, level):\n        '''\n        creds : typing.Sequence[int]\n        level : str\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='ModelConfig',\n                   request='SetSLALevel',\n                   version=1,\n                   params=_params)\n        _params['creds'] = creds\n        _params['level'] = level\n        reply = await self.rpc(msg)\n        return reply", "response": "Set the SLALevel of the current session."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a Track request to the server.", "response": "async def Track(self, payloads):\n        '''\n        payloads : typing.Sequence[~Payload]\n        Returns -> typing.Sequence[~PayloadResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='PayloadsHookContext',\n                   request='Track',\n                   version=1,\n                   params=_params)\n        _params['payloads'] = payloads\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def AddPendingResources(self, addcharmwithauthorization, entity, resources):\n        '''\n        addcharmwithauthorization : AddCharmWithAuthorization\n        entity : Entity\n        resources : typing.Sequence[~CharmResource]\n        Returns -> typing.Union[_ForwardRef('ErrorResult'), typing.Sequence[str]]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Resources',\n                   request='AddPendingResources',\n                   version=1,\n                   params=_params)\n        _params['AddCharmWithAuthorization'] = addcharmwithauthorization\n        _params['Entity'] = entity\n        _params['Resources'] = resources\n        reply = await self.rpc(msg)\n        return reply", "response": "Add pending resources to the set of charm resources."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def GetResourceInfo(self, resource_names):\n        '''\n        resource_names : typing.Sequence[str]\n        Returns -> typing.Union[_ForwardRef('ErrorResult'), typing.Sequence[~UnitResourceResult]]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='ResourcesHookContext',\n                   request='GetResourceInfo',\n                   version=1,\n                   params=_params)\n        _params['resource-names'] = resource_names\n        reply = await self.rpc(msg)\n        return reply", "response": "Get resource info for a set of resource names."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def SetTools(self, agent_tools):\n        '''\n        agent_tools : typing.Sequence[~EntityVersion]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Upgrader',\n                   request='SetTools',\n                   version=1,\n                   params=_params)\n        _params['agent-tools'] = agent_tools\n        reply = await self.rpc(msg)\n        return reply", "response": "Set the tools for the current set of active modules."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the password of the current user.", "response": "async def SetPassword(self, changes):\n        '''\n        changes : typing.Sequence[~EntityPassword]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='UserManager',\n                   request='SetPassword',\n                   version=1,\n                   params=_params)\n        _params['changes'] = changes\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting information about the specified entities.", "response": "async def UserInfo(self, entities, include_disabled):\n        '''\n        entities : typing.Sequence[~Entity]\n        include_disabled : bool\n        Returns -> typing.Sequence[~UserInfoResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='UserManager',\n                   request='UserInfo',\n                   version=1,\n                   params=_params)\n        _params['entities'] = entities\n        _params['include-disabled'] = include_disabled\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def execute_process(*cmd, log=None, loop=None):\n    '''\n    Wrapper around asyncio.create_subprocess_exec.\n\n    '''\n    p = await asyncio.create_subprocess_exec(\n        *cmd,\n        stdin=asyncio.subprocess.PIPE,\n        stdout=asyncio.subprocess.PIPE,\n        stderr=asyncio.subprocess.PIPE,\n        loop=loop)\n    stdout, stderr = await p.communicate()\n    if log:\n        log.debug(\"Exec %s -> %d\", cmd, p.returncode)\n        if stdout:\n            log.debug(stdout.decode('utf-8'))\n        if stderr:\n            log.debug(stderr.decode('utf-8'))\n    return p.returncode == 0", "response": "Wrapper around asyncio. create_subprocess_exec."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def block_until(*conditions, timeout=None, wait_period=0.5, loop=None):\n    async def _block():\n        while not all(c() for c in conditions):\n            await asyncio.sleep(wait_period, loop=loop)\n    await asyncio.wait_for(_block(), timeout, loop=loop)", "response": "Block until all conditions are true."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def run_with_interrupt(task, *events, loop=None):\n    loop = loop or asyncio.get_event_loop()\n    task = asyncio.ensure_future(task, loop=loop)\n    event_tasks = [loop.create_task(event.wait()) for event in events]\n    done, pending = await asyncio.wait([task] + event_tasks,\n                                       loop=loop,\n                                       return_when=asyncio.FIRST_COMPLETED)\n    for f in pending:\n        f.cancel()  # cancel unfinished tasks\n    for f in done:\n        f.exception()  # prevent \"exception was not retrieved\" errors\n    if task in done:\n        return task.result()  # may raise exception\n    else:\n        return None", "response": "Await a task while allowing it to be interrupted by one or more asynchronous Event s."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_user_controller_access_token(username, controller_endpoints, secret_key, controller_name):\n\n    # Secret key is returned as base64 encoded string in:\n    # https://websockets.readthedocs.io/en/stable/_modules/websockets/protocol.html#WebSocketCommonProtocol.recv\n    # Deconding it before marshalling into the ASN.1 message\n    secret_key = base64.b64decode(secret_key)\n    addr = Addrs()\n    for endpoint in controller_endpoints:\n        addr.append(endpoint)\n\n    registration_string = RegistrationInfo()\n    registration_string.setComponentByPosition(0, char.PrintableString(username))\n    registration_string.setComponentByPosition(1, addr)\n    registration_string.setComponentByPosition(2, univ.OctetString(secret_key))\n    registration_string.setComponentByPosition(3, char.PrintableString(controller_name))\n    registration_string = encode(registration_string)\n    remainder = len(registration_string) % 3\n    registration_string += b\"\\0\" * (3 - remainder)\n    return base64.urlsafe_b64encode(registration_string)", "response": "Generate a user controller access token."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef go_to_py_cookie(go_cookie):\n    '''Convert a Go-style JSON-unmarshaled cookie into a Python cookie'''\n    expires = None\n    if go_cookie.get('Expires') is not None:\n        t = pyrfc3339.parse(go_cookie['Expires'])\n        expires = t.timestamp()\n    return cookiejar.Cookie(\n        version=0,\n        name=go_cookie['Name'],\n        value=go_cookie['Value'],\n        port=None,\n        port_specified=False,\n        # Unfortunately Python cookies don't record the original\n        # host that the cookie came from, so we'll just use Domain\n        # for that purpose, and record that the domain was specified,\n        # even though it probably was not. This means that\n        # we won't correctly record the CanonicalHost entry\n        # when writing the cookie file after reading it.\n        domain=go_cookie['Domain'],\n        domain_specified=not go_cookie['HostOnly'],\n        domain_initial_dot=False,\n        path=go_cookie['Path'],\n        path_specified=True,\n        secure=go_cookie['Secure'],\n        expires=expires,\n        discard=False,\n        comment=None,\n        comment_url=None,\n        rest=None,\n        rfc2109=False,\n    )", "response": "Convert a Go - style JSON - marshaled cookie into a Python cookie."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a python cookie to the JSON - marshalable Go - style cookie form.", "response": "def py_to_go_cookie(py_cookie):\n    '''Convert a python cookie to the JSON-marshalable Go-style cookie form.'''\n    # TODO (perhaps):\n    #   HttpOnly\n    #   Creation\n    #   LastAccess\n    #   Updated\n    # not done properly: CanonicalHost.\n    go_cookie = {\n        'Name': py_cookie.name,\n        'Value': py_cookie.value,\n        'Domain': py_cookie.domain,\n        'HostOnly': not py_cookie.domain_specified,\n        'Persistent': not py_cookie.discard,\n        'Secure': py_cookie.secure,\n        'CanonicalHost': py_cookie.domain,\n    }\n    if py_cookie.path_specified:\n        go_cookie['Path'] = py_cookie.path\n    if py_cookie.expires is not None:\n        unix_time = datetime.datetime.fromtimestamp(py_cookie.expires)\n        # Note: fromtimestamp bizarrely produces a time without\n        # a time zone, so we need to use accept_naive.\n        go_cookie['Expires'] = pyrfc3339.generate(unix_time, accept_naive=True)\n    return go_cookie"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nimplement the _really_load method called by FileCookieJar to implement the actual cookie loading", "response": "def _really_load(self, f, filename, ignore_discard, ignore_expires):\n        '''Implement the _really_load method called by FileCookieJar\n        to implement the actual cookie loading'''\n        data = json.load(f) or []\n        now = time.time()\n        for cookie in map(go_to_py_cookie, data):\n            if not ignore_expires and cookie.is_expired(now):\n                continue\n            self.set_cookie(cookie)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nimplement the FileCookieJar abstract method.", "response": "def save(self, filename=None, ignore_discard=False, ignore_expires=False):\n        '''Implement the FileCookieJar abstract method.'''\n        if filename is None:\n            if self.filename is not None:\n                filename = self.filename\n            else:\n                raise ValueError(cookiejar.MISSING_FILENAME_TEXT)\n\n        # TODO: obtain file lock, read contents of file, and merge with\n        # current content.\n        go_cookies = []\n        now = time.time()\n        for cookie in self:\n            if not ignore_discard and cookie.discard:\n                continue\n            if not ignore_expires and cookie.is_expired(now):\n                continue\n            go_cookies.append(py_to_go_cookie(cookie))\n        with open(filename, \"w\") as f:\n            f.write(json.dumps(go_cookies))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def connect(self, *args, **kwargs):\n        await self.disconnect()\n        if 'endpoint' not in kwargs and len(args) < 2:\n            if args and 'model_name' in kwargs:\n                raise TypeError('connect() got multiple values for '\n                                'controller_name')\n            elif args:\n                controller_name = args[0]\n            else:\n                controller_name = kwargs.pop('controller_name', None)\n            await self._connector.connect_controller(controller_name, **kwargs)\n        else:\n            if 'controller_name' in kwargs:\n                raise TypeError('connect() got values for both '\n                                'controller_name and endpoint')\n            if args and 'endpoint' in kwargs:\n                raise TypeError('connect() got multiple values for endpoint')\n            has_userpass = (len(args) >= 3 or\n                            {'username', 'password'}.issubset(kwargs))\n            has_macaroons = (len(args) >= 5 or not\n                             {'bakery_client', 'macaroons'}.isdisjoint(kwargs))\n            if not (has_userpass or has_macaroons):\n                raise TypeError('connect() missing auth params')\n            arg_names = [\n                'endpoint',\n                'username',\n                'password',\n                'cacert',\n                'bakery_client',\n                'macaroons',\n                'loop',\n                'max_frame_size',\n            ]\n            for i, arg in enumerate(args):\n                kwargs[arg_names[i]] = arg\n            if 'endpoint' not in kwargs:\n                raise ValueError('endpoint is required '\n                                 'if controller_name not given')\n            if not ({'username', 'password'}.issubset(kwargs) or\n                    {'bakery_client', 'macaroons'}.intersection(kwargs)):\n                raise ValueError('Authentication parameters are required '\n                                 'if controller_name not given')\n            await self._connector.connect(**kwargs)", "response": "Connect to a Juju controller."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def add_credential(self, name=None, credential=None, cloud=None,\n                             owner=None, force=False):\n        \"\"\"Add or update a credential to the controller.\n\n        :param str name: Name of new credential. If None, the default\n            local credential is used.  Name must be provided if a credential\n            is given.\n        :param CloudCredential credential: Credential to add. If not given,\n            it will attempt to read from local data, if available.\n        :param str cloud: Name of cloud to associate the credential with.\n            Defaults to the same cloud as the controller.\n        :param str owner: Username that will own the credential. Defaults to\n            the current user.\n        :param bool force: Force indicates whether the update should be forced.\n            It's only supported for facade v3 or later.\n            Defaults to false.\n        :returns: Name of credential that was uploaded.\n        \"\"\"\n        if not cloud:\n            cloud = await self.get_cloud()\n\n        if not owner:\n            owner = self.connection().info['user-info']['identity']\n\n        if credential and not name:\n            raise errors.JujuError('Name must be provided for credential')\n\n        if not credential:\n            name, credential = self._connector.jujudata.load_credential(cloud,\n                                                                        name)\n            if credential is None:\n                raise errors.JujuError(\n                    'Unable to find credential: {}'.format(name))\n\n        if credential.auth_type == 'jsonfile' and 'file' in credential.attrs:\n            # file creds have to be loaded before being sent to the controller\n            try:\n                # it might already be JSON\n                json.loads(credential.attrs['file'])\n            except json.JSONDecodeError:\n                # not valid JSON, so maybe it's a file\n                cred_path = Path(credential.attrs['file'])\n                if cred_path.exists():\n                    # make a copy\n                    cred_json = credential.to_json()\n                    credential = client.CloudCredential.from_json(cred_json)\n                    # inline the cred\n                    credential.attrs['file'] = cred_path.read_text()\n\n        log.debug('Uploading credential %s', name)\n        cloud_facade = client.CloudFacade.from_connection(self.connection())\n        tagged_credentials = [\n            client.UpdateCloudCredential(\n                tag=tag.credential(cloud, tag.untag('user-', owner), name),\n                credential=credential,\n            )]\n        if cloud_facade.version >= 3:\n            # UpdateCredentials was renamed to UpdateCredentialsCheckModels\n            # in facade version 3.\n            await cloud_facade.UpdateCredentialsCheckModels(\n                credentials=tagged_credentials, force=force,\n            )\n        else:\n            await cloud_facade.UpdateCredentials(tagged_credentials)\n        return name", "response": "Add or update a cloud credential to the controller."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a new model to this controller.", "response": "async def add_model(\n            self, model_name, cloud_name=None, credential_name=None,\n            owner=None, config=None, region=None):\n        \"\"\"Add a model to this controller.\n\n        :param str model_name: Name to give the new model.\n        :param str cloud_name: Name of the cloud in which to create the\n            model, e.g. 'aws'. Defaults to same cloud as controller.\n        :param str credential_name: Name of the credential to use when\n            creating the model. If not given, it will attempt to find a\n            default credential.\n        :param str owner: Username that will own the model. Defaults to\n            the current user.\n        :param dict config: Model configuration.\n        :param str region: Region in which to create the model.\n        :return Model: A connection to the newly created model.\n        \"\"\"\n        model_facade = client.ModelManagerFacade.from_connection(\n            self.connection())\n\n        owner = owner or self.connection().info['user-info']['identity']\n        cloud_name = cloud_name or await self.get_cloud()\n\n        try:\n            # attempt to add/update the credential from local data if available\n            credential_name = await self.add_credential(\n                name=credential_name,\n                cloud=cloud_name,\n                owner=owner)\n        except errors.JujuError:\n            # if it's not available locally, assume it's on the controller\n            pass\n\n        if credential_name:\n            credential = tag.credential(\n                cloud_name,\n                tag.untag('user-', owner),\n                credential_name\n            )\n        else:\n            credential = None\n\n        log.debug('Creating model %s', model_name)\n\n        if not config or 'authorized-keys' not in config:\n            config = config or {}\n            config['authorized-keys'] = await utils.read_ssh_key(\n                loop=self._connector.loop)\n\n        model_info = await model_facade.CreateModel(\n            tag.cloud(cloud_name),\n            config,\n            credential,\n            model_name,\n            owner,\n            region\n        )\n        from juju.model import Model\n        model = Model(jujudata=self._connector.jujudata)\n        kwargs = self.connection().connect_params()\n        kwargs['uuid'] = model_info.uuid\n        await model._connect_direct(**kwargs)\n\n        return model"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndestroying one or more models.", "response": "async def destroy_models(self, *models, destroy_storage=False):\n        \"\"\"Destroy one or more models.\n\n        :param str *models: Names or UUIDs of models to destroy\n        :param bool destroy_storage: Whether or not to destroy storage when\n            destroying the models. Defaults to false.\n\n        \"\"\"\n        uuids = await self.model_uuids()\n        models = [uuids[model] if model in uuids else model\n                  for model in models]\n\n        model_facade = client.ModelManagerFacade.from_connection(\n            self.connection())\n\n        log.debug(\n            'Destroying model%s %s',\n            '' if len(models) == 1 else 's',\n            ', '.join(models)\n        )\n\n        if model_facade.version >= 5:\n            params = [\n                client.DestroyModelParams(model_tag=tag.model(model),\n                                          destroy_storage=destroy_storage)\n                for model in models]\n        else:\n            params = [client.Entity(tag.model(model)) for model in models]\n\n        await model_facade.DestroyModels(params)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a user to this controller.", "response": "async def add_user(self, username, password=None, display_name=None):\n        \"\"\"Add a user to this controller.\n\n        :param str username: Username\n        :param str password: Password\n        :param str display_name: Display name\n        :returns: A :class:`~juju.user.User` instance\n        \"\"\"\n        if not display_name:\n            display_name = username\n        user_facade = client.UserManagerFacade.from_connection(\n            self.connection())\n        users = [client.AddUser(display_name=display_name,\n                                username=username,\n                                password=password)]\n        results = await user_facade.AddUser(users)\n        secret_key = results.results[0].secret_key\n        return await self.get_user(username, secret_key=secret_key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves a user from this controller.", "response": "async def remove_user(self, username):\n        \"\"\"Remove a user from this controller.\n        \"\"\"\n        client_facade = client.UserManagerFacade.from_connection(\n            self.connection())\n        user = tag.user(username)\n        await client_facade.RemoveUser([client.Entity(user)])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def change_user_password(self, username, password):\n        user_facade = client.UserManagerFacade.from_connection(\n            self.connection())\n        entity = client.EntityPassword(password, tag.user(username))\n        return await user_facade.SetPassword([entity])", "response": "Change the password for a user in this controller."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def reset_user_password(self, username):\n        user_facade = client.UserManagerFacade.from_connection(\n            self.connection())\n        entity = client.Entity(tag.user(username))\n        results = await user_facade.ResetPassword([entity])\n        secret_key = results.results[0].secret_key\n        return await self.get_user(username, secret_key=secret_key)", "response": "Reset the password of a user."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def destroy(self, destroy_all_models=False):\n        controller_facade = client.ControllerFacade.from_connection(\n            self.connection())\n        return await controller_facade.DestroyController(destroy_all_models)", "response": "Destroy this controller.\n\n        :param bool destroy_all_models: Destroy all hosted models in the\n            controller."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisable a user. :param str username: Username", "response": "async def disable_user(self, username):\n        \"\"\"Disable a user.\n\n        :param str username: Username\n\n        \"\"\"\n        user_facade = client.UserManagerFacade.from_connection(\n            self.connection())\n        entity = client.Entity(tag.user(username))\n        return await user_facade.DisableUser([entity])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nenable a previously disabled user.", "response": "async def enable_user(self, username):\n        \"\"\"Re-enable a previously disabled user.\n\n        \"\"\"\n        user_facade = client.UserManagerFacade.from_connection(\n            self.connection())\n        entity = client.Entity(tag.user(username))\n        return await user_facade.EnableUser([entity])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def get_cloud(self):\n        cloud_facade = client.CloudFacade.from_connection(self.connection())\n\n        result = await cloud_facade.Clouds()\n        cloud = list(result.clouds.keys())[0]  # only lives on one cloud\n        return tag.untag('cloud-', cloud)", "response": "Get the name of the cloud that this controller lives on."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def get_models(self, all_=False, username=None):\n        controller_facade = client.ControllerFacade.from_connection(\n            self.connection())\n        for attempt in (1, 2, 3):\n            try:\n                return await controller_facade.AllModels()\n            except errors.JujuAPIError as e:\n                # retry concurrency error until resolved in Juju\n                # see: https://bugs.launchpad.net/juju/+bug/1721786\n                if 'has been removed' not in e.message or attempt == 3:\n                    raise", "response": "Get the list of models in this instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def model_uuids(self):\n        controller_facade = client.ControllerFacade.from_connection(\n            self.connection())\n        for attempt in (1, 2, 3):\n            try:\n                response = await controller_facade.AllModels()\n                return {um.model.name: um.model.uuid\n                        for um in response.user_models}\n            except errors.JujuAPIError as e:\n                # retry concurrency error until resolved in Juju\n                # see: https://bugs.launchpad.net/juju/+bug/1721786\n                if 'has been removed' not in e.message or attempt == 3:\n                    raise\n                await asyncio.sleep(attempt, loop=self._connector.loop)", "response": "Return a mapping of model names to UUIDs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def get_model(self, model):\n        uuids = await self.model_uuids()\n        if model in uuids:\n            uuid = uuids[model]\n        else:\n            uuid = model\n\n        from juju.model import Model\n        model = Model()\n        kwargs = self.connection().connect_params()\n        kwargs['uuid'] = uuid\n        await model._connect_direct(**kwargs)\n        return model", "response": "Get a model by name or UUID."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def get_user(self, username, secret_key=None):\n        client_facade = client.UserManagerFacade.from_connection(\n            self.connection())\n        user = tag.user(username)\n        args = [client.Entity(user)]\n        try:\n            response = await client_facade.UserInfo(args, True)\n        except errors.JujuError as e:\n            if 'permission denied' in e.errors:\n                # apparently, trying to get info for a nonexistent user returns\n                # a \"permission denied\" error rather than an empty result set\n                return None\n            raise\n        if response.results and response.results[0].result:\n            return User(self, response.results[0].result, secret_key=secret_key)\n        return None", "response": "Get a user by name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn list of users that can connect to this controller.", "response": "async def get_users(self, include_disabled=False):\n        \"\"\"Return list of users that can connect to this controller.\n\n        :param bool include_disabled: Include disabled users\n        :returns: A list of :class:`~juju.user.User` instances\n        \"\"\"\n        client_facade = client.UserManagerFacade.from_connection(\n            self.connection())\n        response = await client_facade.UserInfo(None, include_disabled)\n        return [User(self, r.result) for r in response.results]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def grant(self, username, acl='login'):\n        controller_facade = client.ControllerFacade.from_connection(\n            self.connection())\n        user = tag.user(username)\n        changes = client.ModifyControllerAccess(acl, 'grant', user)\n        try:\n            await controller_facade.ModifyControllerAccess([changes])\n            return True\n        except errors.JujuError as e:\n            if 'user already has' in str(e):\n                return False\n            else:\n                raise", "response": "Grant access to the given user on the controller."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def revoke(self, username, acl='login'):\n        controller_facade = client.ControllerFacade.from_connection(\n            self.connection())\n        user = tag.user(username)\n        changes = client.ModifyControllerAccess('login', 'revoke', user)\n        return await controller_facade.ModifyControllerAccess([changes])", "response": "Removes some or all access of a user from a controller."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngrants a user access to a model.", "response": "async def grant_model(self, username, model_uuid, acl='read'):\n        \"\"\"Grant a user access to a model. Note that if the user\n        already has higher permissions than the provided ACL,\n        this will do nothing (see revoke_model for a way to remove\n        permissions).\n\n        :param str username: Username\n        :param str model_uuid: The UUID of the model to change.\n        :param str acl: Access control ('read, 'write' or 'admin')\n        \"\"\"\n        model_facade = client.ModelManagerFacade.from_connection(\n            self.connection())\n        user = tag.user(username)\n        model = tag.model(model_uuid)\n        changes = client.ModifyModelAccess(acl, 'grant', model, user)\n        return await model_facade.ModifyModelAccess([changes])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the given model name into controller and model names.", "response": "def parse_model(self, model):\n        \"\"\"Split the given model_name into controller and model parts.\n        If the controller part is empty, the current controller will be used.\n        If the model part is empty, the current model will be used for\n        the controller.\n        The returned model name will always be qualified with a username.\n        :param model str: The model name to parse.\n        :return (str, str): The controller and model names.\n        \"\"\"\n        # TODO if model is empty, use $JUJU_MODEL environment variable.\n        if model and ':' in model:\n            # explicit controller given\n            controller_name, model_name = model.split(':')\n        else:\n            # use the current controller if one isn't explicitly given\n            controller_name = self.current_controller()\n            model_name = model\n        if not controller_name:\n            controller_name = self.current_controller()\n        if not model_name:\n            model_name = self.current_model(controller_name, model_only=True)\n            if not model_name:\n                raise NoModelException('no current model')\n\n        if '/' not in model_name:\n            # model name doesn't include a user prefix, so add one\n            # by using the current user for the controller.\n            accounts = self.accounts().get(controller_name)\n            if accounts is None:\n                raise JujuError('No account found for controller {} '.format(controller_name))\n            username = accounts.get('user')\n            if username is None:\n                raise JujuError('No username found for controller {}'.format(controller_name))\n            model_name = username + \"/\" + model_name\n\n        return controller_name, model_name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef current_model(self, controller_name=None, model_only=False):\n        '''Return the current model, qualified by its controller name.\n        If controller_name is specified, the current model for\n        that controller will be returned.\n\n        If model_only is true, only the model name, not qualified by\n        its controller name, will be returned.\n        '''\n        # TODO respect JUJU_MODEL environment variable.\n        if not controller_name:\n            controller_name = self.current_controller()\n        if not controller_name:\n            raise JujuError('No current controller')\n        models = self.models()[controller_name]\n        if 'current-model' not in models:\n            return None\n        if model_only:\n            return models['current-model']\n        return controller_name + ':' + models['current-model']", "response": "Return the current model for the specified controller name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads a local credential from the database.", "response": "def load_credential(self, cloud, name=None):\n        \"\"\"Load a local credential.\n\n        :param str cloud: Name of cloud to load credentials from.\n        :param str name: Name of credential. If None, the default credential\n            will be used, if available.\n        :return: A CloudCredential instance, or None.\n        \"\"\"\n        try:\n            cloud = tag.untag('cloud-', cloud)\n            creds_data = self.credentials()[cloud]\n            if not name:\n                default_credential = creds_data.pop('default-credential', None)\n                default_region = creds_data.pop('default-region', None)  # noqa\n                if default_credential:\n                    name = creds_data['default-credential']\n                elif len(creds_data) == 1:\n                    name = list(creds_data)[0]\n                else:\n                    return None, None\n            cred_data = creds_data[name]\n            auth_type = cred_data.pop('auth-type')\n            return name, jujuclient.CloudCredential(\n                auth_type=auth_type,\n                attrs=cred_data,\n            )\n        except (KeyError, FileNotFoundError):\n            return None, None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _macaroons_for_domain(cookies, domain):\n    '''Return any macaroons from the given cookie jar that\n    apply to the given domain name.'''\n    req = urllib.request.Request('https://' + domain + '/')\n    cookies.add_cookie_header(req)\n    return httpbakery.extract_macaroons(req)", "response": "Return any macaroons from the given cookie jar that apply to the given domain name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef status(self):\n        connection = self.connection()\n\n        # the connection instance was destroyed but someone kept\n        # a separate reference to the monitor for some reason\n        if not connection:\n            return self.DISCONNECTED\n\n        # connection cleanly disconnected or not yet opened\n        if not connection.ws:\n            return self.DISCONNECTED\n\n        # close called but not yet complete\n        if self.close_called.is_set():\n            return self.DISCONNECTING\n\n        # connection closed uncleanly (we didn't call connection.close)\n        stopped = connection._receiver_task.stopped.is_set()\n        if stopped or not connection.ws.open:\n            return self.ERROR\n\n        # everything is fine!\n        return self.CONNECTED", "response": "Returns the status of the current state of the current state of the current receiver."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconnect to the controller.", "response": "async def connect(\n            cls,\n            endpoint=None,\n            uuid=None,\n            username=None,\n            password=None,\n            cacert=None,\n            bakery_client=None,\n            loop=None,\n            max_frame_size=None,\n            retries=3,\n            retry_backoff=10,\n    ):\n        \"\"\"Connect to the websocket.\n\n        If uuid is None, the connection will be to the controller. Otherwise it\n        will be to the model.\n\n        :param str endpoint: The hostname:port of the controller to connect to.\n        :param str uuid: The model UUID to connect to (None for a\n            controller-only connection).\n        :param str username: The username for controller-local users (or None\n            to use macaroon-based login.)\n        :param str password: The password for controller-local users.\n        :param str cacert: The CA certificate of the controller\n            (PEM formatted).\n        :param httpbakery.Client bakery_client: The macaroon bakery client to\n            to use when performing macaroon-based login. Macaroon tokens\n            acquired when logging will be saved to bakery_client.cookies.\n            If this is None, a default bakery_client will be used.\n        :param asyncio.BaseEventLoop loop: The event loop to use for async\n            operations.\n        :param int max_frame_size: The maximum websocket frame size to allow.\n        :param int retries: When connecting or reconnecting, and all endpoints\n            fail, how many times to retry the connection before giving up.\n        :param int retry_backoff: Number of seconds to increase the wait\n            between connection retry attempts (a backoff of 10 with 3 retries\n            would wait 10s, 20s, and 30s).\n        \"\"\"\n        self = cls()\n        if endpoint is None:\n            raise ValueError('no endpoint provided')\n        self.uuid = uuid\n        if bakery_client is None:\n            bakery_client = httpbakery.Client()\n        self.bakery_client = bakery_client\n        if username and '@' in username and not username.endswith('@local'):\n            # We're trying to log in as an external user - we need to use\n            # macaroon authentication with no username or password.\n            if password is not None:\n                raise errors.JujuAuthError('cannot log in as external '\n                                           'user with a password')\n            username = None\n        self.usertag = tag.user(username)\n        self.password = password\n        self.loop = loop or asyncio.get_event_loop()\n\n        self.__request_id__ = 0\n\n        # The following instance variables are initialized by the\n        # _connect_with_redirect method, but create them here\n        # as a reminder that they will exist.\n        self.addr = None\n        self.ws = None\n        self.endpoint = None\n        self.cacert = None\n        self.info = None\n\n        # Create that _Task objects but don't start the tasks yet.\n        self._pinger_task = _Task(self._pinger, self.loop)\n        self._receiver_task = _Task(self._receiver, self.loop)\n\n        self._retries = retries\n        self._retry_backoff = retry_backoff\n\n        self.facades = {}\n        self.messages = IdQueue(loop=self.loop)\n        self.monitor = Monitor(connection=self)\n        if max_frame_size is None:\n            max_frame_size = self.MAX_FRAME_SIZE\n        self.max_frame_size = max_frame_size\n        await self._connect_with_redirect([(endpoint, cacert)])\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npings the A Controller and wait for it to finish.", "response": "async def _pinger(self):\n        '''\n        A Controller can time us out if we are silent for too long. This\n        is especially true in JaaS, which has a fairly strict timeout.\n\n        To prevent timing out, we send a ping every ten seconds.\n\n        '''\n        async def _do_ping():\n            try:\n                await pinger_facade.Ping()\n                await asyncio.sleep(10, loop=self.loop)\n            except CancelledError:\n                pass\n\n        pinger_facade = client.PingerFacade.from_connection(self)\n        try:\n            while True:\n                await utils.run_with_interrupt(\n                    _do_ping(),\n                    self.monitor.close_called,\n                    loop=self.loop)\n                if self.monitor.close_called.is_set():\n                    break\n        except websockets.exceptions.ConnectionClosed:\n            # The connection has closed - we can't do anything\n            # more until the connection is restarted.\n            log.debug('ping failed because of closed connection')\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake an RPC to the API.", "response": "async def rpc(self, msg, encoder=None):\n        '''Make an RPC to the API. The message is encoded as JSON\n        using the given encoder if any.\n        :param msg: Parameters for the call (will be encoded as JSON).\n        :param encoder: Encoder to be used when encoding the message.\n        :return: The result of the call.\n        :raises JujuAPIError: When there's an error returned.\n        :raises JujuError:\n        '''\n        self.__request_id__ += 1\n        msg['request-id'] = self.__request_id__\n        if'params' not in msg:\n            msg['params'] = {}\n        if \"version\" not in msg:\n            msg['version'] = self.facades[msg['type']]\n        outgoing = json.dumps(msg, indent=2, cls=encoder)\n        log.debug('connection {} -> {}'.format(id(self), outgoing))\n        for attempt in range(3):\n            if self.monitor.status == Monitor.DISCONNECTED:\n                # closed cleanly; shouldn't try to reconnect\n                raise websockets.exceptions.ConnectionClosed(\n                    0, 'websocket closed')\n            try:\n                await self.ws.send(outgoing)\n                break\n            except websockets.ConnectionClosed:\n                if attempt == 2:\n                    raise\n                log.warning('RPC: Connection closed, reconnecting')\n                # the reconnect has to be done in a separate task because,\n                # if it is triggered by the pinger, then this RPC call will\n                # be cancelled when the pinger is cancelled by the reconnect,\n                # and we don't want the reconnect to be aborted halfway through\n                await asyncio.wait([self.reconnect()], loop=self.loop)\n                if self.monitor.status != Monitor.CONNECTED:\n                    # reconnect failed; abort and shutdown\n                    log.error('RPC: Automatic reconnect failed')\n                    raise\n        result = await self._recv(msg['request-id'])\n        log.debug('connection {} <- {}'.format(id(self), result))\n\n        if not result:\n            return result\n\n        if 'error' in result:\n            # API Error Response\n            raise errors.JujuAPIError(result)\n\n        if 'response' not in result:\n            # This may never happen\n            return result\n\n        if 'results' in result['response']:\n            # Check for errors in a result list.\n            # TODO This loses the results that might have succeeded.\n            # Perhaps JujuError should return all the results including\n            # errors, or perhaps a keyword parameter to the rpc method\n            # could be added to trigger this behaviour.\n            err_results = []\n            for res in result['response']['results']:\n                if res.get('error', {}).get('message'):\n                    err_results.append(res['error']['message'])\n            if err_results:\n                raise errors.JujuError(err_results)\n\n        elif result['response'].get('error', {}).get('message'):\n            raise errors.JujuError(result['response']['error']['message'])\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a dictionary of http headers necessary for making an http connection to the endpoint of this Connection.", "response": "def _http_headers(self):\n        \"\"\"Return dictionary of http headers necessary for making an http\n        connection to the endpoint of this Connection.\n\n        :return: Dictionary of headers\n\n        \"\"\"\n        if not self.usertag:\n            return {}\n\n        creds = u'{}:{}'.format(\n            self.usertag,\n            self.password or ''\n        )\n        token = base64.b64encode(creds.encode())\n        return {\n            'Authorization': 'Basic {}'.format(token.decode())\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef https_connection(self):\n        endpoint = self.endpoint\n        host, remainder = endpoint.split(':', 1)\n        port = remainder\n        if '/' in remainder:\n            port, _ = remainder.split('/', 1)\n\n        conn = HTTPSConnection(\n            host, int(port),\n            context=self._get_ssl(self.cacert),\n        )\n\n        path = (\n            \"/model/{}\".format(self.uuid)\n            if self.uuid else \"\"\n        )\n        return conn, self._http_headers(), path", "response": "Return an https connection to this Connection s endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef connect_params(self):\n        return {\n            'endpoint': self.endpoint,\n            'uuid': self.uuid,\n            'username': self.username,\n            'password': self.password,\n            'cacert': self.cacert,\n            'bakery_client': self.bakery_client,\n            'loop': self.loop,\n            'max_frame_size': self.max_frame_size,\n        }", "response": "Return a tuple of parameters suitable for passing to\n            Connection. connect that can be used to make a new connection to the same controller and model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a Connection to the controller at self. endpoint", "response": "async def controller(self):\n        \"\"\"Return a Connection to the controller at self.endpoint\n        \"\"\"\n        return await Connection.connect(\n            self.endpoint,\n            username=self.username,\n            password=self.password,\n            cacert=self.cacert,\n            bakery_client=self.bakery_client,\n            loop=self.loop,\n            max_frame_size=self.max_frame_size,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def _connect_with_login(self, endpoints):\n        success = False\n        try:\n            await self._connect(endpoints)\n            # It's possible that we may get several discharge-required errors,\n            # corresponding to different levels of authentication, so retry\n            # a few times.\n            for i in range(0, 2):\n                result = (await self.login())['response']\n                macaroonJSON = result.get('discharge-required')\n                if macaroonJSON is None:\n                    self.info = result\n                    success = True\n                    return result\n                macaroon = bakery.Macaroon.from_dict(macaroonJSON)\n                self.bakery_client.handle_error(\n                    httpbakery.Error(\n                        code=httpbakery.ERR_DISCHARGE_REQUIRED,\n                        message=result.get('discharge-required-error'),\n                        version=macaroon.version,\n                        info=httpbakery.ErrorInfo(\n                            macaroon=macaroon,\n                            macaroon_path=result.get('macaroon-path'),\n                        ),\n                    ),\n                    # note: remove the port number.\n                    'https://' + self.endpoint + '/',\n                )\n            raise errors.JujuAuthError('failed to authenticate '\n                                       'after several attempts')\n        finally:\n            if not success:\n                await self.close()", "response": "Connect to the websocket and login the user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconnecting to an arbitrary Juju model.", "response": "async def connect(self, **kwargs):\n        \"\"\"Connect to an arbitrary Juju model.\n\n        kwargs are passed through to Connection.connect()\n        \"\"\"\n        kwargs.setdefault('loop', self.loop)\n        kwargs.setdefault('max_frame_size', self.max_frame_size)\n        kwargs.setdefault('bakery_client', self.bakery_client)\n        if 'macaroons' in kwargs:\n            if not kwargs['bakery_client']:\n                kwargs['bakery_client'] = httpbakery.Client()\n            if not kwargs['bakery_client'].cookies:\n                kwargs['bakery_client'].cookies = GoCookieJar()\n            jar = kwargs['bakery_client'].cookies\n            for macaroon in kwargs.pop('macaroons'):\n                jar.set_cookie(go_to_py_cookie(macaroon))\n        self._connection = await Connection.connect(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndisconnects from the watcher task and closes the websockets.", "response": "async def disconnect(self):\n        \"\"\"Shut down the watcher task and close websockets.\n        \"\"\"\n        if self._connection:\n            log.debug('Closing model connection')\n            await self._connection.close()\n            self._connection = None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconnecting to a controller by name.", "response": "async def connect_controller(self, controller_name=None):\n        \"\"\"Connect to a controller by name. If the name is empty, it\n        connect to the current controller.\n        \"\"\"\n        if not controller_name:\n            controller_name = self.jujudata.current_controller()\n        if not controller_name:\n            raise JujuConnectionError('No current controller')\n\n        controller = self.jujudata.controllers()[controller_name]\n        # TODO change Connection so we can pass all the endpoints\n        # instead of just the first.\n        endpoint = controller['api-endpoints'][0]\n        accounts = self.jujudata.accounts().get(controller_name, {})\n\n        await self.connect(\n            endpoint=endpoint,\n            uuid=None,\n            username=accounts.get('user'),\n            password=accounts.get('password'),\n            cacert=controller.get('ca-cert'),\n            bakery_client=self.bakery_client_for_controller(controller_name),\n        )\n        self.controller_name = controller_name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def connect_model(self, model_name=None):\n\n        try:\n            controller_name, model_name = self.jujudata.parse_model(model_name)\n            controller = self.jujudata.controllers().get(controller_name)\n        except JujuError as e:\n            raise JujuConnectionError(e.message) from e\n        if controller is None:\n            raise JujuConnectionError('Controller {} not found'.format(\n                controller_name))\n        # TODO change Connection so we can pass all the endpoints\n        # instead of just the first one.\n        endpoint = controller['api-endpoints'][0]\n        account = self.jujudata.accounts().get(controller_name, {})\n        models = self.jujudata.models().get(controller_name, {}).get('models',\n                                                                     {})\n        if model_name not in models:\n            raise JujuConnectionError('Model not found: {}'.format(model_name))\n\n        # TODO if there's no record for the required model name, connect\n        # to the controller to find out the model's uuid, then connect\n        # to that. This will let connect_model work with models that\n        # haven't necessarily synced with the local juju data,\n        # and also remove the need for base.CleanModel to\n        # subclass JujuData.\n        await self.connect(\n            endpoint=endpoint,\n            uuid=models[model_name]['uuid'],\n            username=account.get('user'),\n            password=account.get('password'),\n            cacert=controller.get('ca-cert'),\n            bakery_client=self.bakery_client_for_controller(controller_name),\n        )\n        self.controller_name = controller_name\n        self.model_name = controller_name + ':' + model_name", "response": "Connect to a controller or model by name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmake a copy of the bakery client with a the appropriate controller s cookiejar in it.", "response": "def bakery_client_for_controller(self, controller_name):\n        '''Make a copy of the bakery client with a the appropriate controller's\n        cookiejar in it.\n        '''\n        bakery_client = self.bakery_client\n        if bakery_client:\n            bakery_client = copy.copy(bakery_client)\n        else:\n            bakery_client = httpbakery.Client()\n        bakery_client.cookies = self.jujudata.cookies_for_controller(\n            controller_name)\n        return bakery_client"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(directive):\n    if not directive:\n        # Handle null case\n        return None\n\n    if isinstance(directive, (list, tuple)):\n        results = []\n        for d in directive:\n            results.extend(parse(d))\n        return results\n\n    if isinstance(directive, (dict, client.Placement)):\n        # We've been handed something that we can simply hand back to\n        # the api. (Forwards compatibility)\n        return [directive]\n\n    # Juju 2.0 can't handle lxc containers.\n    directive = directive.replace('lxc', 'lxd')\n\n    if \":\" in directive:\n        # Planner has given us a scope and directive in string form\n        scope, directive = directive.split(\":\")\n        return [client.Placement(scope=scope, directive=directive)]\n\n    if directive.isdigit():\n        # Planner has given us a machine id (we rely on juju core to\n        # verify its validity.)\n        return [client.Placement(scope=MACHINE_SCOPE, directive=directive)]\n\n    if \"/\" in directive:\n        # e.g. \"0/lxd/0\"\n        # https://github.com/juju/juju/blob/master/instance/placement_test.go#L29\n        return [\n            client.Placement(scope=MACHINE_SCOPE, directive=directive),\n        ]\n\n    # Planner has probably given us a container type. Leave it up to\n    # juju core to verify that it is valid.\n    return [client.Placement(scope=directive)]", "response": "Parses a string in the format scope : directive or simply scope\n    or simply scope\n    or simply scope\n    or simply directive."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run(*steps):\n    if not steps:\n        return\n\n    task = None\n    run._sigint = False  # function attr to allow setting from closure\n    loop = asyncio.get_event_loop()\n\n    def abort():\n        task.cancel()\n        run._sigint = True\n\n    added = False\n    try:\n        loop.add_signal_handler(signal.SIGINT, abort)\n        added = True\n    except (ValueError, OSError, RuntimeError) as e:\n        # add_signal_handler doesn't work in a thread\n        if 'main thread' not in str(e):\n            raise\n    try:\n        for step in steps:\n            task = loop.create_task(step)\n            loop.run_until_complete(asyncio.wait([task], loop=loop))\n            if run._sigint:\n                raise KeyboardInterrupt()\n            if task.exception():\n                raise task.exception()\n        return task.result()\n    finally:\n        if added:\n            loop.remove_signal_handler(signal.SIGINT)", "response": "Helper to run one or more async functions synchronously with graceful\n    handling of SIGINT / Ctrl - C."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the list of actions for the given set of entities.", "response": "async def Actions(self, entities):\n        '''\n        entities : typing.Sequence[~Entity]\n        Returns -> typing.Sequence[~ActionResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Action',\n                   request='Actions',\n                   version=2,\n                   params=_params)\n        _params['entities'] = entities\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the set of annotations for the current session.", "response": "async def Set(self, annotations):\n        '''\n        annotations : typing.Sequence[~EntityAnnotations]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Annotations',\n                   request='Set',\n                   version=2,\n                   params=_params)\n        _params['annotations'] = annotations\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def DestroyOffers(self, force, offer_urls):\n        '''\n        force : bool\n        offer_urls : typing.Sequence[str]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='ApplicationOffers',\n                   request='DestroyOffers',\n                   version=2,\n                   params=_params)\n        _params['force'] = force\n        _params['offer-urls'] = offer_urls\n        reply = await self.rpc(msg)\n        return reply", "response": "Destroy the specified set of offers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding an application offer to the cache.", "response": "async def Offer(self, offers):\n        '''\n        offers : typing.Sequence[~AddApplicationOffer]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='ApplicationOffers',\n                   request='Offer',\n                   version=2,\n                   params=_params)\n        _params['Offers'] = offers\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def RemoteApplicationInfo(self, offer_urls):\n        '''\n        offer_urls : typing.Sequence[str]\n        Returns -> typing.Sequence[~RemoteApplicationInfoResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='ApplicationOffers',\n                   request='RemoteApplicationInfo',\n                   version=2,\n                   params=_params)\n        _params['offer-urls'] = offer_urls\n        reply = await self.rpc(msg)\n        return reply", "response": "Get information about the specified application."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a backup record for the given notes.", "response": "async def Create(self, notes):\n        '''\n        notes : str\n        Returns -> typing.Union[str, int, _ForwardRef('Number')]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Backups',\n                   request='Create',\n                   version=2,\n                   params=_params)\n        _params['notes'] = notes\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nswitching the block of the log entries.", "response": "async def SwitchBlockOff(self, message, type_):\n        '''\n        message : str\n        type_ : str\n        Returns -> Error\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Block',\n                   request='SwitchBlockOff',\n                   version=2,\n                   params=_params)\n        _params['message'] = message\n        _params['type'] = type_\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets info about the charm store.", "response": "async def CharmInfo(self, url):\n        '''\n        url : str\n        Returns -> typing.Union[_ForwardRef('CharmActions'), typing.Mapping[str, ~CharmOption], _ForwardRef('CharmMeta'), _ForwardRef('CharmMetrics'), int, str]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Charms',\n                   request='CharmInfo',\n                   version=2,\n                   params=_params)\n        _params['url'] = url\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def ModelSet(self, config):\n        '''\n        config : typing.Mapping[str, typing.Any]\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Client',\n                   request='ModelSet',\n                   version=2,\n                   params=_params)\n        _params['config'] = config\n        reply = await self.rpc(msg)\n        return reply", "response": "This method is used to set the current model for the current session."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nresolving the charm names in the specified set of references.", "response": "async def ResolveCharms(self, references):\n        '''\n        references : typing.Sequence[str]\n        Returns -> typing.Sequence[~ResolveCharmResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Client',\n                   request='ResolveCharms',\n                   version=2,\n                   params=_params)\n        _params['references'] = references\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the status history for the given set of requests.", "response": "async def StatusHistory(self, requests):\n        '''\n        requests : typing.Sequence[~StatusHistoryRequest]\n        Returns -> typing.Sequence[~StatusHistoryResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Client',\n                   request='StatusHistory',\n                   version=2,\n                   params=_params)\n        _params['requests'] = requests\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nspace : typing.Sequence[~CreateSpaceParams] Returns -> typing.Sequence[~ErrorResult]", "response": "async def CreateSpaces(self, spaces):\n        '''\n        spaces : typing.Sequence[~CreateSpaceParams]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='DiscoverSpaces',\n                   request='CreateSpaces',\n                   version=2,\n                   params=_params)\n        _params['spaces'] = spaces\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def ListSubnets(self, space_tag, zone):\n        '''\n        space_tag : str\n        zone : str\n        Returns -> typing.Sequence[~Subnet]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='DiscoverSpaces',\n                   request='ListSubnets',\n                   version=2,\n                   params=_params)\n        _params['space-tag'] = space_tag\n        _params['zone'] = zone\n        reply = await self.rpc(msg)\n        return reply", "response": "List the subnets in a space."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the block devices for the specified set of disk entries.", "response": "async def SetMachineBlockDevices(self, machine_block_devices):\n        '''\n        machine_block_devices : typing.Sequence[~MachineBlockDevices]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='DiskManager',\n                   request='SetMachineBlockDevices',\n                   version=2,\n                   params=_params)\n        _params['machine-block-devices'] = machine_block_devices\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def EnableHA(self, specs):\n        '''\n        specs : typing.Sequence[~ControllersSpec]\n        Returns -> typing.Sequence[~ControllersChangeResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='HighAvailability',\n                   request='EnableHA',\n                   version=2,\n                   params=_params)\n        _params['specs'] = specs\n        reply = await self.rpc(msg)\n        return reply", "response": "Enables high availability for the specified controllers."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def ResumeHAReplicationAfterUpgrade(self, members):\n        '''\n        members : typing.Sequence[~Member]\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='HighAvailability',\n                   request='ResumeHAReplicationAfterUpgrade',\n                   version=2,\n                   params=_params)\n        _params['members'] = members\n        reply = await self.rpc(msg)\n        return reply", "response": "Resume HA replication after upgrade."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def DeleteImages(self, images):\n        '''\n        images : typing.Sequence[~ImageSpec]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='ImageManager',\n                   request='DeleteImages',\n                   version=2,\n                   params=_params)\n        _params['images'] = images\n        reply = await self.rpc(msg)\n        return reply", "response": "Delete images from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def Delete(self, image_ids):\n        '''\n        image_ids : typing.Sequence[str]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='ImageMetadata',\n                   request='Delete',\n                   version=2,\n                   params=_params)\n        _params['image-ids'] = image_ids\n        reply = await self.rpc(msg)\n        return reply", "response": "Delete the set of images with the given ids."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def List(self, arches, region, root_storage_type, series, stream, virt_type):\n        '''\n        arches : typing.Sequence[str]\n        region : str\n        root_storage_type : str\n        series : typing.Sequence[str]\n        stream : str\n        virt_type : str\n        Returns -> typing.Sequence[~CloudImageMetadata]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='ImageMetadata',\n                   request='List',\n                   version=2,\n                   params=_params)\n        _params['arches'] = arches\n        _params['region'] = region\n        _params['root-storage-type'] = root_storage_type\n        _params['series'] = series\n        _params['stream'] = stream\n        _params['virt-type'] = virt_type\n        reply = await self.rpc(msg)\n        return reply", "response": "List all the cloud image metadata for a given root storage type series and stream."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def Save(self, metadata):\n        '''\n        metadata : typing.Sequence[~CloudImageMetadataList]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='ImageMetadata',\n                   request='Save',\n                   version=2,\n                   params=_params)\n        _params['metadata'] = metadata\n        reply = await self.rpc(msg)\n        return reply", "response": "Save the metadata for the current image."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nblock until leadership is released.", "response": "async def BlockUntilLeadershipReleased(self, name):\n        '''\n        name : str\n        Returns -> Error\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='LeadershipService',\n                   request='BlockUntilLeadershipReleased',\n                   version=2,\n                   params=_params)\n        _params['Name'] = name\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a set of metric batches to the current set of metrics.", "response": "async def AddMetricBatches(self, batches):\n        '''\n        batches : typing.Sequence[~MetricBatchParam]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='MetricsAdder',\n                   request='AddMetricBatches',\n                   version=2,\n                   params=_params)\n        _params['batches'] = batches\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def SetMeterStatus(self, statues):\n        '''\n        statues : typing.Sequence[~MeterStatusParam]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='MetricsDebug',\n                   request='SetMeterStatus',\n                   version=2,\n                   params=_params)\n        _params['statues'] = statues\n        reply = await self.rpc(msg)\n        return reply", "response": "Send the specified statues to the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def UnsetModelDefaults(self, keys):\n        '''\n        keys : typing.Sequence[~ModelUnsetKeys]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='ModelManager',\n                   request='UnsetModelDefaults',\n                   version=2,\n                   params=_params)\n        _params['keys'] = keys\n        reply = await self.rpc(msg)\n        return reply", "response": "Unset the specified set of model defaults."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclaim : typing.Sequence[~SingularClaim] Returns -> typing.Sequence[~ErrorResult]", "response": "async def Claim(self, claims):\n        '''\n        claims : typing.Sequence[~SingularClaim]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Singular',\n                   request='Claim',\n                   version=2,\n                   params=_params)\n        _params['claims'] = claims\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a list of subnets to the current set of active domains.", "response": "async def AddSubnets(self, subnets):\n        '''\n        subnets : typing.Sequence[~AddSubnetParams]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Subnets',\n                   request='AddSubnets',\n                   version=2,\n                   params=_params)\n        _params['subnets'] = subnets\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds users to the set of users.", "response": "async def AddUser(self, users):\n        '''\n        users : typing.Sequence[~AddUser]\n        Returns -> typing.Sequence[~AddUserResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='UserManager',\n                   request='AddUser',\n                   version=2,\n                   params=_params)\n        _params['users'] = users\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_ssh_client(self, host, user, key):\n\n        ssh = paramiko.SSHClient()\n        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\n        pkey = None\n\n        # Read the private key into a paramiko.RSAKey\n        if os.path.exists(key):\n            with open(key, 'r') as f:\n                pkey = paramiko.RSAKey.from_private_key(f)\n\n        #######################################################################\n        # There is a bug in some versions of OpenSSH 4.3 (CentOS/RHEL5) where #\n        # the server may not send the SSH_MSG_USERAUTH_BANNER message except  #\n        # when responding to an auth_none request. For example, paramiko will #\n        # attempt to use password authentication when a password is set, but  #\n        # the server could deny that, instead requesting keyboard-interactive.#\n        # The hack to workaround this is to attempt a reconnect, which will   #\n        # receive the right banner, and authentication can proceed. See the   #\n        # following for more info:                                            #\n        # https://github.com/paramiko/paramiko/issues/432                     #\n        # https://github.com/paramiko/paramiko/pull/438                       #\n        #######################################################################\n\n        try:\n            ssh.connect(host, port=22, username=user, pkey=pkey)\n        except paramiko.ssh_exception.SSHException as e:\n            if 'Error reading SSH protocol banner' == str(e):\n                # Once more, with feeling\n                ssh.connect(host, port=22, username=user, pkey=pkey)\n            else:\n                # Reraise the original exception\n                raise e\n\n        return ssh", "response": "Return a connected SSH client object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _run_command(self, ssh, cmd, pty=True):\n\n        if isinstance(cmd, str):\n            cmd = shlex.split(cmd)\n\n        if type(cmd) is not list:\n            cmd = [cmd]\n\n        cmds = ' '.join(cmd)\n        stdin, stdout, stderr = ssh.exec_command(cmds, get_pty=pty)\n        retcode = stdout.channel.recv_exit_status()\n\n        if retcode > 0:\n            output = stderr.read().strip()\n            raise CalledProcessError(returncode=retcode, cmd=cmd,\n                                     output=output)\n        return (\n            stdout.read().decode('utf-8').strip(),\n            stderr.read().decode('utf-8').strip()\n        )", "response": "Run a command remotely via SSH."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _init_ubuntu_user(self):\n\n        # TODO: Test this on an image without the ubuntu user setup.\n\n        auth_user = self.user\n        ssh = None\n        try:\n            # Run w/o allocating a pty, so we fail if sudo prompts for a passwd\n            ssh = self._get_ssh_client(\n                self.host,\n                \"ubuntu\",\n                self.private_key_path,\n            )\n\n            stdout, stderr = self._run_command(ssh, \"sudo -n true\", pty=False)\n        except paramiko.ssh_exception.AuthenticationException as e:\n            raise e\n        else:\n            auth_user = \"ubuntu\"\n        finally:\n            if ssh:\n                ssh.close()\n\n        # if the above fails, run the init script as the authenticated user\n\n        # Infer the public key\n        public_key = None\n        public_key_path = \"{}.pub\".format(self.private_key_path)\n\n        if not os.path.exists(public_key_path):\n            raise FileNotFoundError(\n                \"Public key '{}' doesn't exist.\".format(public_key_path)\n            )\n\n        with open(public_key_path, \"r\") as f:\n            public_key = f.readline()\n\n        script = INITIALIZE_UBUNTU_SCRIPT.format(public_key)\n\n        try:\n            ssh = self._get_ssh_client(\n                self.host,\n                auth_user,\n                self.private_key_path,\n            )\n\n            self._run_command(\n                ssh,\n                [\"sudo\", \"/bin/bash -c \" + shlex.quote(script)],\n                pty=True\n            )\n        except paramiko.ssh_exception.AuthenticationException as e:\n            raise e\n        finally:\n            ssh.close()\n\n        return True", "response": "Initialize the ubuntu user."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _detect_hardware_and_os(self, ssh):\n\n        info = {\n            'series': '',\n            'arch': '',\n            'cpu-cores': '',\n            'mem': '',\n        }\n\n        stdout, stderr = self._run_command(\n            ssh,\n            [\"sudo\", \"/bin/bash -c \" + shlex.quote(DETECTION_SCRIPT)],\n            pty=True,\n        )\n\n        lines = stdout.split(\"\\n\")\n        info['series'] = lines[0].strip()\n        info['arch'] = normalize_arch(lines[1].strip())\n\n        memKb = re.split(r'\\s+', lines[2])[1]\n\n        # Convert megabytes -> kilobytes\n        info['mem'] = round(int(memKb) / 1024)\n\n        # Detect available CPUs\n        recorded = {}\n        for line in lines[3:]:\n            physical_id = \"\"\n            print(line)\n\n            if line.find(\"physical id\") == 0:\n                physical_id = line.split(\":\")[1].strip()\n            elif line.find(\"cpu cores\") == 0:\n                cores = line.split(\":\")[1].strip()\n\n                if physical_id not in recorded.keys():\n                    info['cpu-cores'] += cores\n                    recorded[physical_id] = True\n\n        return info", "response": "Detect the target hardware capabilities and OS series and OS series."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef provision_machine(self):\n        params = client.AddMachineParams()\n\n        if self._init_ubuntu_user():\n            try:\n\n                ssh = self._get_ssh_client(\n                    self.host,\n                    self.user,\n                    self.private_key_path\n                )\n\n                hw = self._detect_hardware_and_os(ssh)\n                params.series = hw['series']\n                params.instance_id = \"manual:{}\".format(self.host)\n                params.nonce = \"manual:{}:{}\".format(\n                    self.host,\n                    str(uuid.uuid4()),  # a nop for Juju w/manual machines\n                )\n                params.hardware_characteristics = {\n                    'arch': hw['arch'],\n                    'mem': int(hw['mem']),\n                    'cpu-cores': int(hw['cpu-cores']),\n                }\n                params.addresses = [{\n                    'value': self.host,\n                    'type': 'ipv4',\n                    'scope': 'public',\n                }]\n\n            except paramiko.ssh_exception.AuthenticationException as e:\n                raise e\n            finally:\n                ssh.close()\n\n        return params", "response": "Perform the initial provisioning of the target machine."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninstall the Juju agent.", "response": "async def install_agent(self, connection, nonce, machine_id):\n        \"\"\"\n        :param object connection: Connection to Juju API\n        :param str nonce: The nonce machine specification\n        :param str machine_id: The id assigned to the machine\n\n        :return: bool: If the initialization was successful\n        \"\"\"\n\n        # The path where the Juju agent should be installed.\n        data_dir = \"/var/lib/juju\"\n\n        # Disabling this prevents `apt-get update` from running initially, so\n        # charms will fail to deploy\n        disable_package_commands = False\n\n        client_facade = client.ClientFacade.from_connection(connection)\n        results = await client_facade.ProvisioningScript(\n            data_dir,\n            disable_package_commands,\n            machine_id,\n            nonce,\n        )\n\n        self._run_configure_script(results.script)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _run_configure_script(self, script):\n\n        _, tmpFile = tempfile.mkstemp()\n        with open(tmpFile, 'w') as f:\n            f.write(script)\n\n        try:\n            # get ssh client\n            ssh = self._get_ssh_client(\n                self.host,\n                \"ubuntu\",\n                self.private_key_path,\n            )\n\n            # copy the local copy of the script to the remote machine\n            sftp = paramiko.SFTPClient.from_transport(ssh.get_transport())\n            sftp.put(\n                tmpFile,\n                tmpFile,\n            )\n\n            # run the provisioning script\n            stdout, stderr = self._run_command(\n                ssh,\n                \"sudo /bin/bash {}\".format(tmpFile),\n            )\n\n        except paramiko.ssh_exception.AuthenticationException as e:\n            raise e\n        finally:\n            os.remove(tmpFile)\n            ssh.close()", "response": "Run the script to install the Juju agent on the target machine."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the annotations for the specified entity.", "response": "async def _get_annotations(entity_tag, connection):\n    \"\"\"Get annotations for the specified entity\n\n    :return dict: The annotations for the entity\n    \"\"\"\n    facade = client.AnnotationsFacade.from_connection(connection)\n    result = (await facade.Get([{\"tag\": entity_tag}])).results[0]\n    if result.error is not None:\n        raise JujuError(result.error)\n    return result.annotations"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the annotations on the specified entity.", "response": "async def _set_annotations(entity_tag, annotations, connection):\n    \"\"\"Set annotations on the specified entity.\n\n    :param annotations map[string]string: the annotations as key/value\n        pairs.\n    \"\"\"\n    # TODO: ensure annotations is dict with only string keys\n    # and values.\n    log.debug('Updating annotations on %s', entity_tag)\n    facade = client.AnnotationsFacade.from_connection(connection)\n    args = client.EntityAnnotations(\n        entity=entity_tag,\n        annotations=annotations,\n    )\n    return await facade.Set([args])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget LXD profile upgrade messages.", "response": "async def GetLXDProfileUpgradeMessages(self, application, watcher_id):\n        '''\n        application : Entity\n        watcher_id : str\n        Returns -> typing.Sequence[~LXDProfileUpgradeMessagesResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Application',\n                   request='GetLXDProfileUpgradeMessages',\n                   version=8,\n                   params=_params)\n        _params['application'] = application\n        _params['watcher-id'] = watcher_id\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def ResolveUnitErrors(self, all_, retry, tags):\n        '''\n        all_ : bool\n        retry : bool\n        tags : Entities\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Application',\n                   request='ResolveUnitErrors',\n                   version=8,\n                   params=_params)\n        _params['all'] = all_\n        _params['retry'] = retry\n        _params['tags'] = tags\n        reply = await self.rpc(msg)\n        return reply", "response": "all_ : bool\n        retry : bool\n        tags : Entities\n        Returns -> typing.Sequence[~ErrorResult]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def Set(self, application, options):\n        '''\n        application : str\n        options : typing.Mapping[str, str]\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Application',\n                   request='Set',\n                   version=8,\n                   params=_params)\n        _params['application'] = application\n        _params['options'] = options\n        reply = await self.rpc(msg)\n        return reply", "response": "Set the application s cache entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def SetCharm(self, application, channel, charm_url, config_settings, config_settings_yaml, force_series, force_units, resource_ids, storage_constraints):\n        '''\n        application : str\n        channel : str\n        charm_url : str\n        config_settings : typing.Mapping[str, str]\n        config_settings_yaml : str\n        force_series : bool\n        force_units : bool\n        resource_ids : typing.Mapping[str, str]\n        storage_constraints : typing.Mapping[str, ~StorageConstraints]\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Application',\n                   request='SetCharm',\n                   version=8,\n                   params=_params)\n        _params['application'] = application\n        _params['channel'] = channel\n        _params['charm-url'] = charm_url\n        _params['config-settings'] = config_settings\n        _params['config-settings-yaml'] = config_settings_yaml\n        _params['force-series'] = force_series\n        _params['force-units'] = force_units\n        _params['resource-ids'] = resource_ids\n        _params['storage-constraints'] = storage_constraints\n        reply = await self.rpc(msg)\n        return reply", "response": "Set the charm for the specified application."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the charm profile for the specified application.", "response": "async def SetCharmProfile(self, application, charm_url):\n        '''\n        application : str\n        charm_url : str\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Application',\n                   request='SetCharmProfile',\n                   version=8,\n                   params=_params)\n        _params['application'] = application\n        _params['charm-url'] = charm_url\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the constraints for the specified application.", "response": "async def SetConstraints(self, application, constraints):\n        '''\n        application : str\n        constraints : Value\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Application',\n                   request='SetConstraints',\n                   version=8,\n                   params=_params)\n        _params['application'] = application\n        _params['constraints'] = constraints\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if this relation matches the given set of specs.", "response": "def matches(self, *specs):\n        \"\"\"\n        Check if this relation matches relationship specs.\n\n        Relation specs are strings that would be given to Juju to establish a\n        relation, and should be in the form ``<application>[:<endpoint_name>]``\n        where the ``:<endpoint_name>`` suffix is optional.  If the suffix is\n        omitted, this relation will match on any endpoint as long as the given\n        application is involved.\n\n        In other words, this relation will match a spec if that spec could have\n        created this relation.\n\n        :return: True if all specs match.\n        \"\"\"\n        for spec in specs:\n            if ':' in spec:\n                app_name, endpoint_name = spec.split(':')\n            else:\n                app_name, endpoint_name = spec, None\n            for endpoint in self.endpoints:\n                if app_name == endpoint.application.name and \\\n                   endpoint_name in (endpoint.name, None):\n                    # found a match for this spec, so move to next one\n                    break\n            else:\n                # no match for this spec\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def AddUnits(self, application, num_units, placement):\n        '''\n        application : str\n        num_units : int\n        placement : typing.Sequence[~Placement]\n        Returns -> typing.Sequence[str]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Application',\n                   request='AddUnits',\n                   version=5,\n                   params=_params)\n        _params['application'] = application\n        _params['num-units'] = num_units\n        _params['placement'] = placement\n        reply = await self.rpc(msg)\n        return reply", "response": "Add units to the specified application."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def DestroyController(self, destroy_models):\n        '''\n        destroy_models : bool\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Controller',\n                   request='DestroyController',\n                   version=5,\n                   params=_params)\n        _params['destroy-models'] = destroy_models\n        reply = await self.rpc(msg)\n        return reply", "response": "destroy_models : bool\n        Returns -> None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove blocks from the cache.", "response": "async def RemoveBlocks(self, all_):\n        '''\n        all_ : bool\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Controller',\n                   request='RemoveBlocks',\n                   version=5,\n                   params=_params)\n        _params['all'] = all_\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a list of firewall rules for a given set of known services.", "response": "async def FirewallRules(self, known_services):\n        '''\n        known_services : typing.Sequence[str]\n        Returns -> typing.Sequence[~FirewallRule]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Firewaller',\n                   request='FirewallRules',\n                   version=5,\n                   params=_params)\n        _params['known-services'] = known_services\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def DestroyMachineWithParams(self, force, keep, machine_tags):\n        '''\n        force : bool\n        keep : bool\n        machine_tags : typing.Sequence[str]\n        Returns -> typing.Sequence[~DestroyMachineResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='MachineManager',\n                   request='DestroyMachineWithParams',\n                   version=5,\n                   params=_params)\n        _params['force'] = force\n        _params['keep'] = keep\n        _params['machine-tags'] = machine_tags\n        reply = await self.rpc(msg)\n        return reply", "response": "Destroy a set of machines with the specified parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def UpgradeSeriesComplete(self, force, series, tag):\n        '''\n        force : bool\n        series : str\n        tag : Entity\n        Returns -> Error\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='MachineManager',\n                   request='UpgradeSeriesComplete',\n                   version=5,\n                   params=_params)\n        _params['force'] = force\n        _params['series'] = series\n        _params['tag'] = tag\n        reply = await self.rpc(msg)\n        return reply", "response": "This method is used to complete the upgrade of a series."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nchange the model credential for the current session.", "response": "async def ChangeModelCredential(self, model_credentials):\n        '''\n        model_credentials : typing.Sequence[~ChangeModelCredentialParams]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='ModelManager',\n                   request='ChangeModelCredential',\n                   version=5,\n                   params=_params)\n        _params['model-credentials'] = model_credentials\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def CreateModel(self, cloud_tag, config, credential, name, owner_tag, region):\n        '''\n        cloud_tag : str\n        config : typing.Mapping[str, typing.Any]\n        credential : str\n        name : str\n        owner_tag : str\n        region : str\n        Returns -> typing.Union[_ForwardRef('Number'), str, typing.Sequence[~ModelMachineInfo], _ForwardRef('ModelMigrationStatus'), _ForwardRef('ModelSLAInfo'), _ForwardRef('EntityStatus'), typing.Sequence[~ModelUserInfo]]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='ModelManager',\n                   request='CreateModel',\n                   version=5,\n                   params=_params)\n        _params['cloud-tag'] = cloud_tag\n        _params['config'] = config\n        _params['credential'] = credential\n        _params['name'] = name\n        _params['owner-tag'] = owner_tag\n        _params['region'] = region\n        reply = await self.rpc(msg)\n        return reply", "response": "Create a new model in the specified cloud."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlisting all model summaries for a user.", "response": "async def ListModelSummaries(self, all_, user_tag):\n        '''\n        all_ : bool\n        user_tag : str\n        Returns -> typing.Sequence[~ModelSummaryResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='ModelManager',\n                   request='ListModelSummaries',\n                   version=5,\n                   params=_params)\n        _params['all'] = all_\n        _params['user-tag'] = user_tag\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlist all models for a specific tag.", "response": "async def ListModels(self, tag):\n        '''\n        tag : str\n        Returns -> typing.Sequence[~UserModel]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='ModelManager',\n                   request='ListModels',\n                   version=5,\n                   params=_params)\n        _params['tag'] = tag\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def CharmArchiveSha256(self, urls):\n        '''\n        urls : typing.Sequence[~CharmURL]\n        Returns -> typing.Sequence[~StringResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Uniter',\n                   request='CharmArchiveSha256',\n                   version=5,\n                   params=_params)\n        _params['urls'] = urls\n        reply = await self.rpc(msg)\n        return reply", "response": "Get the SHA256 hash of a set of charm archive."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinishes the actions for the specified set of results.", "response": "async def FinishActions(self, results):\n        '''\n        results : typing.Sequence[~ActionExecutionResult]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Uniter',\n                   request='FinishActions',\n                   version=5,\n                   params=_params)\n        _params['results'] = results\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def NetworkInfo(self, bindings, unit):\n        '''\n        bindings : typing.Sequence[str]\n        unit : str\n        Returns -> typing.Mapping[str, ~NetworkInfoResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Uniter',\n                   request='NetworkInfo',\n                   version=5,\n                   params=_params)\n        _params['bindings'] = bindings\n        _params['unit'] = unit\n        reply = await self.rpc(msg)\n        return reply", "response": "Get network info for a set of keys."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads remote settings for the specified relation_unit_pairs.", "response": "async def ReadRemoteSettings(self, relation_unit_pairs):\n        '''\n        relation_unit_pairs : typing.Sequence[~RelationUnitPair]\n        Returns -> typing.Sequence[~SettingsResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Uniter',\n                   request='ReadRemoteSettings',\n                   version=5,\n                   params=_params)\n        _params['relation-unit-pairs'] = relation_unit_pairs\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def RelationById(self, relation_ids):\n        '''\n        relation_ids : typing.Sequence[int]\n        Returns -> typing.Sequence[~RelationResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Uniter',\n                   request='RelationById',\n                   version=5,\n                   params=_params)\n        _params['relation-ids'] = relation_ids\n        reply = await self.rpc(msg)\n        return reply", "response": "Get a list of relation entries by their ids."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the life of the specified storage attachments.", "response": "async def StorageAttachmentLife(self, ids):\n        '''\n        ids : typing.Sequence[~StorageAttachmentId]\n        Returns -> typing.Sequence[~LifeResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Uniter',\n                   request='StorageAttachmentLife',\n                   version=5,\n                   params=_params)\n        _params['ids'] = ids\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def AddPendingResources(self, application_tag, charm_url, resources):\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Resources',\n                   request='AddPendingResources',\n                   version=1,\n                   params=_params)\n        _params['tag'] = application_tag\n        _params['url'] = charm_url\n        _params['resources'] = resources\n        reply = await self.rpc(msg)\n        return reply", "response": "Add pending resources to the specified set of resources."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the metric credentials for the current application.", "response": "async def SetMetricCredentials(self, creds):\n        '''\n        creds : typing.Sequence[~ApplicationMetricCredential]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Application',\n                   request='SetMetricCredentials',\n                   version=4,\n                   params=_params)\n        _params['creds'] = creds\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the state of a set of keys.", "response": "async def Update(self, application, charm_url, constraints, force_charm_url, force_series, min_units, settings, settings_yaml):\n        '''\n        application : str\n        charm_url : str\n        constraints : Value\n        force_charm_url : bool\n        force_series : bool\n        min_units : int\n        settings : typing.Mapping[str, str]\n        settings_yaml : str\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Application',\n                   request='Update',\n                   version=4,\n                   params=_params)\n        _params['application'] = application\n        _params['charm-url'] = charm_url\n        _params['constraints'] = constraints\n        _params['force-charm-url'] = force_charm_url\n        _params['force-series'] = force_series\n        _params['min-units'] = min_units\n        _params['settings'] = settings\n        _params['settings-yaml'] = settings_yaml\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds the given storages to the unit.", "response": "async def AddToUnit(self, storages):\n        '''\n        storages : typing.Sequence[~StorageAddParams]\n        Returns -> typing.Sequence[~AddStorageResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Storage',\n                   request='AddToUnit',\n                   version=4,\n                   params=_params)\n        _params['storages'] = storages\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def ListFilesystems(self, filters):\n        '''\n        filters : typing.Sequence[~FilesystemFilter]\n        Returns -> typing.Sequence[~FilesystemDetailsListResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Storage',\n                   request='ListFilesystems',\n                   version=4,\n                   params=_params)\n        _params['filters'] = filters\n        reply = await self.rpc(msg)\n        return reply", "response": "List the filesystems for the specified resource."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating volume attachments for a set of volumes.", "response": "async def CreateVolumeAttachmentPlans(self, volume_plans):\n        '''\n        volume_plans : typing.Sequence[~VolumeAttachmentPlan]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='StorageProvisioner',\n                   request='CreateVolumeAttachmentPlans',\n                   version=4,\n                   params=_params)\n        _params['volume-plans'] = volume_plans\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the volume attachments info for the current node.", "response": "async def SetVolumeAttachmentInfo(self, volume_attachments):\n        '''\n        volume_attachments : typing.Sequence[~VolumeAttachment]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='StorageProvisioner',\n                   request='SetVolumeAttachmentInfo',\n                   version=4,\n                   params=_params)\n        _params['volume-attachments'] = volume_attachments\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the volumes of the current session.", "response": "async def SetVolumeInfo(self, volumes):\n        '''\n        volumes : typing.Sequence[~Volume]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='StorageProvisioner',\n                   request='SetVolumeInfo',\n                   version=4,\n                   params=_params)\n        _params['volumes'] = volumes\n        reply = await self.rpc(msg)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def SetHostMachineNetworkConfig(self, config, tag):\n        '''\n        config : typing.Sequence[~NetworkConfig]\n        tag : str\n        Returns -> None\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Provisioner',\n                   request='SetHostMachineNetworkConfig',\n                   version=7,\n                   params=_params)\n        _params['config'] = config\n        _params['tag'] = tag\n        reply = await self.rpc(msg)\n        return reply", "response": "Set the network configuration for the host machine."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def SetInstanceInfo(self, machines):\n        '''\n        machines : typing.Sequence[~InstanceInfo]\n        Returns -> typing.Sequence[~ErrorResult]\n        '''\n        # map input types to rpc msg\n        _params = dict()\n        msg = dict(type='Provisioner',\n                   request='SetInstanceInfo',\n                   version=7,\n                   params=_params)\n        _params['machines'] = machines\n        reply = await self.rpc(msg)\n        return reply", "response": "machines : typing.Sequence[~InstanceInfo]\n        Returns -> typing.Sequence[~ErrorResult]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing a cloud environment.", "response": "def bootstrap(\n            self, controller_name, region=None, agent_version=None,\n            auto_upgrade=False, bootstrap_constraints=None,\n            bootstrap_series=None, config=None, constraints=None,\n            credential=None, default_model=None, keep_broken=False,\n            metadata_source=None, no_gui=False, to=None,\n            upload_tools=False):\n\n        \"\"\"Initialize a cloud environment.\n\n        :param str controller_name: Name of controller to create\n        :param str region: Cloud region in which to bootstrap\n        :param str agent_version: Version of tools to use for Juju agents\n        :param bool auto_upgrade: Upgrade to latest path release tools on first\n            bootstrap\n        :param bootstrap_constraints: Constraints for the bootstrap machine\n        :type bootstrap_constraints: :class:`juju.Constraints`\n        :param str bootstrap_series: Series of the bootstrap machine\n        :param dict config: Controller configuration\n        :param constraints: Default constraints for all future workload\n            machines\n        :type constraints: :class:`juju.Constraints`\n        :param credential: Credential to use when bootstrapping\n        :type credential: :class:`juju.Credential`\n        :param str default_model: Name to give the default model\n        :param bool keep_broken: Don't destroy model if bootstrap fails\n        :param str metadata_source: Local path to use as tools and/or metadata\n            source\n        :param bool no_gui: Don't install the Juju GUI in the controller when\n            bootstrapping\n        :param str to: Placement directive for bootstrap node (typically used\n            with MAAS)\n        :param bool upload_tools: Upload local version of tools before\n            bootstrapping\n\n        \"\"\"\n        raise NotImplementedError()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the machine object for this unit.", "response": "def machine(self):\n        \"\"\"Get the machine object for this unit.\n\n        \"\"\"\n        machine_id = self.safe_data['machine-id']\n        if machine_id:\n            return self.model.machines.get(machine_id, None)\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning command on this unit.", "response": "async def run(self, command, timeout=None):\n        \"\"\"Run command on this unit.\n\n        :param str command: The command to run\n        :param int timeout: Time, in seconds, to wait before command is\n        considered failed\n        :returns: A :class:`juju.action.Action` instance.\n\n        \"\"\"\n        action = client.ActionFacade.from_connection(self.connection)\n\n        log.debug(\n            'Running `%s` on %s', command, self.name)\n\n        if timeout:\n            # Convert seconds to nanoseconds\n            timeout = int(timeout * 1000000000)\n\n        res = await action.Run(\n            [],\n            command,\n            [],\n            timeout,\n            [self.name],\n        )\n        return await self.model.wait_for_action(res.results[0].action.tag)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def run_action(self, action_name, **params):\n        action_facade = client.ActionFacade.from_connection(self.connection)\n\n        log.debug('Starting action `%s` on %s', action_name, self.name)\n\n        res = await action_facade.Enqueue([client.Action(\n            name=action_name,\n            parameters=params,\n            receiver=self.tag,\n        )])\n        action = res.results[0].action\n        error = res.results[0].error\n        if error and error.code == 'not found':\n            raise ValueError('Action `%s` not found on %s' % (action_name,\n                                                              self.name))\n        elif error:\n            raise Exception('Unknown action error: %s' % error.serialize())\n        action_id = action.tag[len('action-'):]\n        log.debug('Action started as %s', action_id)\n        # we mustn't use wait_for_action because that blocks until the\n        # action is complete, rather than just being in the model\n        return await self.model._wait_for_new('action', action_id)", "response": "Run an action on this unit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def scp_to(self, source, destination, user='ubuntu', proxy=False,\n                     scp_opts=''):\n        \"\"\"Transfer files to this unit.\n\n        :param str source: Local path of file(s) to transfer\n        :param str destination: Remote destination of transferred files\n        :param str user: Remote username\n        :param bool proxy: Proxy through the Juju API server\n        :param scp_opts: Additional options to the `scp` command\n        :type scp_opts: str or list\n        \"\"\"\n        await self.machine.scp_to(source, destination, user=user, proxy=proxy,\n                                  scp_opts=scp_opts)", "response": "Transfer files from the local path to the remote path."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks to see if this unit is the leader. Returns True if so False if not.", "response": "async def is_leader_from_status(self):\n        \"\"\"\n        Check to see if this unit is the leader. Returns True if so, and\n        False if it is not, or if leadership does not make sense\n        (e.g., there is no leader in this application.)\n\n        This method is a kluge that calls FullStatus in the\n        ClientFacade to get its information. Once\n        https://bugs.launchpad.net/juju/+bug/1643691 is resolved, we\n        should add a simple .is_leader property, and deprecate this\n        method.\n\n        \"\"\"\n        app = self.name.split(\"/\")[0]\n\n        c = client.ClientFacade.from_connection(self.connection)\n\n        status = await c.FullStatus(None)\n\n        # FullStatus may be more up to date than our model, and the\n        # unit may have gone away, or we may be doing something silly,\n        # like trying to fetch leadership for a subordinate, which\n        # will not be filed where we expect in the model. In those\n        # cases, we may simply return False, as a nonexistent or\n        # subordinate unit is not a leader.\n        if not status.applications.get(app):\n            return False\n\n        if not status.applications[app].get('units'):\n            return False\n\n        if not status.applications[app]['units'].get(self.name):\n            return False\n\n        return status.applications[app]['units'][self.name].get('leader',\n                                                                False)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def get_metrics(self):\n        metrics = await self.model.get_metrics(self.tag)\n        return metrics[self.name]", "response": "Get the metrics for this unit."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the given constraints into a dictionary of key = value pairs.", "response": "def parse(constraints):\n    \"\"\"\n    Constraints must be expressed as a string containing only spaces\n    and key value pairs joined by an '='.\n\n    \"\"\"\n    if not constraints:\n        return None\n\n    if type(constraints) is dict:\n        # Fowards compatibilty: already parsed\n        return constraints\n\n    constraints = {\n        normalize_key(k): (\n            normalize_list_value(v) if k in LIST_KEYS else\n            normalize_value(v)\n        ) for k, v in [s.split(\"=\") for s in constraints.split(\" \")]}\n\n    return constraints"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a relation to another application.", "response": "async def add_relation(self, local_relation, remote_relation):\n        \"\"\"Add a relation to another application.\n\n        :param str local_relation: Name of relation on this application\n        :param str remote_relation: Name of relation on the other\n            application in the form '<application>[:<relation_name>]'\n\n        \"\"\"\n        if ':' not in local_relation:\n            local_relation = '{}:{}'.format(self.name, local_relation)\n\n        return await self.model.add_relation(local_relation, remote_relation)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def add_unit(self, count=1, to=None):\n        app_facade = client.ApplicationFacade.from_connection(self.connection)\n\n        log.debug(\n            'Adding %s unit%s to %s',\n            count, '' if count == 1 else 's', self.name)\n\n        result = await app_facade.AddUnits(\n            application=self.name,\n            placement=parse_placement(to) if to else None,\n            num_units=count,\n        )\n\n        return await asyncio.gather(*[\n            asyncio.ensure_future(self.model._wait_for_new('unit', unit_id))\n            for unit_id in result.units\n        ])", "response": "Add one or more units to this application."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def scale(self, scale=None, scale_change=None):\n        app_facade = client.ApplicationFacade.from_connection(self.connection)\n\n        if (scale, scale_change) == (None, None):\n            raise ValueError('Must provide either scale or scale_change')\n\n        log.debug(\n            'Scaling application %s %s %s',\n            self.name, 'to' if scale else 'by', scale or scale_change)\n\n        await app_facade.ScaleApplications([\n            client.ScaleApplicationParam(application_tag=self.tag,\n                                         scale=scale,\n                                         scale_change=scale_change)\n        ])", "response": "Scale this application to a new scale."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def destroy_relation(self, local_relation, remote_relation):\n        if ':' not in local_relation:\n            local_relation = '{}:{}'.format(self.name, local_relation)\n\n        app_facade = client.ApplicationFacade.from_connection(self.connection)\n\n        log.debug(\n            'Destroying relation %s <-> %s', local_relation, remote_relation)\n\n        return await app_facade.DestroyRelation([\n            local_relation, remote_relation])", "response": "Remove a relation to another application."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove this application from the model.", "response": "async def destroy(self):\n        \"\"\"Remove this application from the model.\n\n        \"\"\"\n        app_facade = client.ApplicationFacade.from_connection(self.connection)\n\n        log.debug(\n            'Destroying %s', self.name)\n\n        return await app_facade.Destroy(self.name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexposes this application to the network.", "response": "async def expose(self):\n        \"\"\"Make this application publicly available over the network.\n\n        \"\"\"\n        app_facade = client.ApplicationFacade.from_connection(self.connection)\n\n        log.debug(\n            'Exposing %s', self.name)\n\n        return await app_facade.Expose(self.name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def get_config(self):\n        app_facade = client.ApplicationFacade.from_connection(self.connection)\n\n        log.debug(\n            'Getting config for %s', self.name)\n\n        return (await app_facade.Get(self.name)).config", "response": "Get the configuration settings dict for this application."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def get_constraints(self):\n        app_facade = client.ApplicationFacade.from_connection(self.connection)\n\n        log.debug(\n            'Getting constraints for %s', self.name)\n\n        result = (await app_facade.Get(self.name)).constraints\n        return vars(result) if result else result", "response": "Return the constraints dict for this application."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def get_actions(self, schema=False):\n        actions = {}\n        entity = [{\"tag\": self.tag}]\n        action_facade = client.ActionFacade.from_connection(self.connection)\n        results = (\n            await action_facade.ApplicationsCharmsActions(entity)).results\n        for result in results:\n            if result.application_tag == self.tag and result.actions:\n                actions = result.actions\n                break\n        if not schema:\n            actions = {k: v['description'] for k, v in actions.items()}\n        return actions", "response": "Get the charms actions defined for this application."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def get_resources(self):\n        facade = client.ResourcesFacade.from_connection(self.connection)\n        response = await facade.ListResources([client.Entity(self.tag)])\n\n        resources = dict()\n        for result in response.results:\n            for resource in result.charm_store_resources or []:\n                resources[resource.name] = resource\n            for resource in result.resources or []:\n                if resource.charmresource:\n                    resource = resource.charmresource\n                    resources[resource.name] = resource\n        return resources", "response": "Return resources for this application."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns command on all units of this application.", "response": "async def run(self, command, timeout=None):\n        \"\"\"Run command on all units for this application.\n\n        :param str command: The command to run\n        :param int timeout: Time to wait before command is considered failed\n\n        \"\"\"\n        action = client.ActionFacade.from_connection(self.connection)\n\n        log.debug(\n            'Running `%s` on all units of %s', command, self.name)\n\n        # TODO this should return a list of Actions\n        return await action.Run(\n            [self.name],\n            command,\n            [],\n            timeout,\n            [],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def set_config(self, config):\n        app_facade = client.ApplicationFacade.from_connection(self.connection)\n\n        log.debug(\n            'Setting config for %s: %s', self.name, config)\n\n        return await app_facade.Set(self.name, config)", "response": "Set the configuration options for this application."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nresets the application config to default values.", "response": "async def reset_config(self, to_default):\n        \"\"\"\n        Restore application config to default values.\n\n        :param list to_default: A list of config options to be reset to their\n        default value.\n        \"\"\"\n        app_facade = client.ApplicationFacade.from_connection(self.connection)\n\n        log.debug(\n            'Restoring default config for %s: %s', self.name, to_default)\n\n        return await app_facade.Unset(self.name, to_default)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the constraints for this application.", "response": "async def set_constraints(self, constraints):\n        \"\"\"Set machine constraints for this application.\n\n        :param dict constraints: Dict of machine constraints\n\n        \"\"\"\n        app_facade = client.ApplicationFacade.from_connection(self.connection)\n\n        log.debug(\n            'Setting constraints for %s: %s', self.name, constraints)\n\n        return await app_facade.SetConstraints(self.name, constraints)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def unexpose(self):\n        app_facade = client.ApplicationFacade.from_connection(self.connection)\n\n        log.debug(\n            'Unexposing %s', self.name)\n\n        return await app_facade.Unexpose(self.name)", "response": "Remove public availability over the network for this application."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupgrading the charm for this application.", "response": "async def upgrade_charm(\n            self, channel=None, force_series=False, force_units=False,\n            path=None, resources=None, revision=None, switch=None):\n        \"\"\"Upgrade the charm for this application.\n\n        :param str channel: Channel to use when getting the charm from the\n            charm store, e.g. 'development'\n        :param bool force_series: Upgrade even if series of deployed\n            application is not supported by the new charm\n        :param bool force_units: Upgrade all units immediately, even if in\n            error state\n        :param str path: Uprade to a charm located at path\n        :param dict resources: Dictionary of resource name/filepath pairs\n        :param int revision: Explicit upgrade revision\n        :param str switch: Crossgrade charm url\n\n        \"\"\"\n        # TODO: Support local upgrades\n        if path is not None:\n            raise NotImplementedError(\"path option is not implemented\")\n        if resources is not None:\n            raise NotImplementedError(\"resources option is not implemented\")\n\n        if switch is not None and revision is not None:\n            raise ValueError(\"switch and revision are mutually exclusive\")\n\n        client_facade = client.ClientFacade.from_connection(self.connection)\n        resources_facade = client.ResourcesFacade.from_connection(\n            self.connection)\n        app_facade = client.ApplicationFacade.from_connection(self.connection)\n\n        charmstore = self.model.charmstore\n        charmstore_entity = None\n\n        if switch is not None:\n            charm_url = switch\n            if not charm_url.startswith('cs:'):\n                charm_url = 'cs:' + charm_url\n        else:\n            charm_url = self.data['charm-url']\n            charm_url = charm_url.rpartition('-')[0]\n            if revision is not None:\n                charm_url = \"%s-%d\" % (charm_url, revision)\n            else:\n                charmstore_entity = await charmstore.entity(charm_url,\n                                                            channel=channel)\n                charm_url = charmstore_entity['Id']\n\n        if charm_url == self.data['charm-url']:\n            raise JujuError('already running charm \"%s\"' % charm_url)\n\n        # Update charm\n        await client_facade.AddCharm(\n            url=charm_url,\n            channel=channel\n        )\n\n        # Update resources\n        if not charmstore_entity:\n            charmstore_entity = await charmstore.entity(charm_url,\n                                                        channel=channel)\n        store_resources = charmstore_entity['Meta']['resources']\n\n        request_data = [client.Entity(self.tag)]\n        response = await resources_facade.ListResources(request_data)\n        existing_resources = {\n            resource.name: resource\n            for resource in response.results[0].resources\n        }\n\n        resources_to_update = [\n            resource for resource in store_resources\n            if resource['Name'] not in existing_resources or\n            existing_resources[resource['Name']].origin != 'upload'\n        ]\n\n        if resources_to_update:\n            request_data = [\n                client.CharmResource(\n                    description=resource.get('Description'),\n                    fingerprint=resource['Fingerprint'],\n                    name=resource['Name'],\n                    path=resource['Path'],\n                    revision=resource['Revision'],\n                    size=resource['Size'],\n                    type_=resource['Type'],\n                    origin='store',\n                ) for resource in resources_to_update\n            ]\n            response = await resources_facade.AddPendingResources(\n                self.tag,\n                charm_url,\n                request_data\n            )\n            pending_ids = response.pending_ids\n            resource_ids = {\n                resource['Name']: id\n                for resource, id in zip(resources_to_update, pending_ids)\n            }\n        else:\n            resource_ids = None\n\n        # Update application\n        await app_facade.SetCharm(\n            application=self.entity_id,\n            channel=channel,\n            charm_url=charm_url,\n            config_settings=None,\n            config_settings_yaml=None,\n            force_series=force_series,\n            force_units=force_units,\n            resource_ids=resource_ids,\n            storage_constraints=None\n        )\n\n        await self.model.block_until(\n            lambda: self.data['charm-url'] == charm_url\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_facades(captures, options):\n    for version in sorted(captures.keys()):\n        filename = \"{}/_client{}.py\".format(options.output_dir, version)\n        with open(filename, \"w\") as f:\n            f.write(HEADER)\n            f.write(\"from juju.client.facade import Type, ReturnMapping\\n\")\n            f.write(\"from juju.client._definitions import *\\n\\n\")\n            for key in sorted(\n                    [k for k in captures[version].keys() if \"Facade\" in k]):\n                print(captures[version][key], file=f)\n\n    # Return the last (most recent) version for use in other routines.\n    return version", "response": "Write the Facades to the appropriate _client<version >. py file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_client(captures, options):\n    with open(\"{}/_client.py\".format(options.output_dir), \"w\") as f:\n        f.write(HEADER)\n        f.write(\"from juju.client._definitions import *\\n\\n\")\n        clients = \", \".join(\"_client{}\".format(v) for v in captures)\n        f.write(\"from juju.client import \" + clients + \"\\n\\n\")\n        f.write(CLIENT_TABLE.format(clients=\",\\n    \".join(\n            ['\"{}\": _client{}'.format(v, v) for v in captures])))\n        f.write(LOOKUP_FACADE)\n        f.write(TYPE_FACTORY)\n        for key in sorted([k for k in factories.keys() if \"Facade\" in k]):\n            print(factories[key], file=f)", "response": "Write the client classes to _client. py along with some\n    imports and tables so that we can look up versioned Facades."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lookup(self, name, version=None):\n        versions = self.get(name)\n        if not versions:\n            return None\n        if version:\n            return versions[version]\n        return versions[max(versions)]", "response": "Lookup a specific version of a user s infrastructure."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _run(cmd, suppress_errors=False, suppress_output=False):\n    if is_verbose():\n        logger.debug('Executing: \"%s\"', format(cmd))\n    process = subprocess.Popen(\n        cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n    stderr_log_level = logging.NOTSET if suppress_errors else logging.ERROR\n    stdout_log_level = logging.NOTSET if suppress_output else logging.DEBUG\n\n    stdout_thread = PipeReader(\n        process.stdout, process, logger, stdout_log_level)\n    stderr_thread = PipeReader(\n        process.stderr, process, logger, stderr_log_level)\n\n    stdout_thread.start()\n    stderr_thread.start()\n\n    while process.poll() is None:\n        time.sleep(PROCESS_POLLING_INTERVAL)\n\n    stdout_thread.join()\n    stderr_thread.join()\n\n    process.aggr_stdout = stdout_thread.aggr\n    process.aggr_stderr = stderr_thread.aggr\n\n    return process", "response": "Execute a command in a new process and return the process object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef install_package(package,\n                    wheels_path,\n                    venv=None,\n                    requirement_files=None,\n                    upgrade=False,\n                    install_args=None):\n    \"\"\"Install a Python package.\n\n    Can specify a specific version.\n    Can specify a prerelease.\n    Can specify a venv to install in.\n    Can specify a list of paths or urls to requirement txt files.\n    Can specify a local wheels_path to use for offline installation.\n    Can request an upgrade.\n    \"\"\"\n    requirement_files = requirement_files or []\n\n    logger.info('Installing %s...', package)\n    if venv and not os.path.isdir(venv):\n        raise WagonError('virtualenv {0} does not exist'.format(venv))\n\n    pip_command = _construct_pip_command(\n        package,\n        wheels_path,\n        venv,\n        requirement_files,\n        upgrade,\n        install_args)\n\n    if IS_VIRTUALENV and not venv:\n        logger.info('Installing within current virtualenv')\n\n    result = _run(pip_command)\n    if not result.returncode == 0:\n        raise WagonError('Could not install package: {0} ({1})'.format(\n            package, result.aggr_stderr))", "response": "Install a Python package."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_platform_for_set_of_wheels(wheels_path):\n    real_platform = ''\n\n    for wheel in _get_downloaded_wheels(wheels_path):\n        platform = _get_platform_from_wheel_name(\n            os.path.join(wheels_path, wheel))\n        if 'linux' in platform and 'manylinux' not in platform:\n            # Means either linux_x64_86 or linux_i686 on all wheels\n            # If, at any point, a wheel matches this, it will be\n            # returned so it'll only match that platform.\n            return platform\n        elif platform != ALL_PLATFORMS_TAG:\n            # Means it can be either Windows, OSX or manylinux1 on all wheels\n            real_platform = platform\n\n    return real_platform or ALL_PLATFORMS_TAG", "response": "Given a set of wheels in a directory extracts a single platform."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nretrieve distribution properties. **Note that platform.linux_distribution and platform.dist are deprecated and will be removed in Python 3.7. By that time, distro will become mandatory.", "response": "def _get_os_properties():\n    \"\"\"Retrieve distribution properties.\n\n    **Note that platform.linux_distribution and platform.dist are deprecated\n    and will be removed in Python 3.7. By that time, distro will become\n    mandatory.\n    \"\"\"\n    if IS_DISTRO_INSTALLED:\n        return distro.linux_distribution(full_distribution_name=False)\n    return platform.linux_distribution(full_distribution_name=False)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_env_bin_path(env_path):\n    if IS_VIRTUALENV_INSTALLED:\n        path = virtualenv.path_locations(env_path)[3]\n    else:\n        path = os.path.join(env_path, 'Scripts' if IS_WIN else 'bin')\n    return r'{0}'.format(path)", "response": "Return the bin path for a virtualenv"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _generate_metadata_file(workdir,\n                            archive_name,\n                            platform,\n                            python_versions,\n                            package_name,\n                            package_version,\n                            build_tag,\n                            package_source,\n                            wheels):\n    \"\"\"Generate a metadata file for the package.\n    \"\"\"\n    logger.debug('Generating Metadata...')\n    metadata = {\n        'created_by_wagon_version': _get_wagon_version(),\n        'archive_name': archive_name,\n        'supported_platform': platform,\n        'supported_python_versions': python_versions,\n        'build_server_os_properties': {\n            'distribution': None,\n            'distribution_version': None,\n            'distribution_release': None,\n        },\n        'package_name': package_name,\n        'package_version': package_version,\n        'package_build_tag': build_tag,\n        'package_source': package_source,\n        'wheels': wheels,\n    }\n    if IS_LINUX and platform != ALL_PLATFORMS_TAG:\n        distribution, version, release = _get_os_properties()\n        metadata.update(\n            {'build_server_os_properties': {\n                'distribution': distribution.lower(),\n                'distribution_version': version.lower(),\n                'distribution_release': release.lower()\n            }})\n\n    formatted_metadata = json.dumps(metadata, indent=4, sort_keys=True)\n    if is_verbose():\n        logger.debug('Metadata is: %s', formatted_metadata)\n    output_path = os.path.join(workdir, METADATA_FILE_NAME)\n    with open(output_path, 'w') as f:\n        logger.debug('Writing metadata to file: %s', output_path)\n        f.write(formatted_metadata)", "response": "Generate a metadata file for the package."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _set_archive_name(package_name,\n                      package_version,\n                      python_versions,\n                      platform,\n                      build_tag=''):\n    \"\"\"Set the format of the output archive file.\n\n    We should aspire for the name of the archive to be\n    as compatible as possible with the wheel naming convention\n    described here:\n    https://www.python.org/dev/peps/pep-0491/#file-name-convention,\n    as we're basically providing a \"wheel\" of our package.\n    \"\"\"\n    package_name = package_name.replace('-', '_')\n    python_versions = '.'.join(python_versions)\n\n    archive_name_tags = [\n        package_name,\n        package_version,\n        python_versions,\n        'none',\n        platform,\n    ]\n\n    if build_tag:\n        archive_name_tags.insert(2, build_tag)\n\n    archive_name = '{0}.wgn'.format('-'.join(archive_name_tags))\n    return archive_name", "response": "Set the name of the archive file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_source_name_and_version(source):\n    if os.path.isfile(os.path.join(source, 'setup.py')):\n        package_name, package_version = \\\n            _get_name_and_version_from_setup(source)\n    # TODO: maybe we don't want to be that explicit and allow using >=\n    # elif any(symbol in source for symbol in ['==', '>=', '<=']):\n    elif '==' in source:\n        base_name, package_version = source.split('==')\n        package_name = _get_package_info_from_pypi(base_name)['name']\n    else:\n        package_info = _get_package_info_from_pypi(source)\n        package_name = package_info['name']\n        package_version = package_info['version']\n    return package_name, package_version", "response": "Retrieve the source package s name and version."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_source(source):\n    def extract_source(source, destination):\n        if tarfile.is_tarfile(source):\n            _untar(source, destination)\n        elif zipfile.is_zipfile(source):\n            _unzip(source, destination)\n        else:\n            raise WagonError(\n                'Failed to extract {0}. Please verify that the '\n                'provided file is a valid zip or tar.gz '\n                'archive'.format(source))\n\n        source = os.path.join(\n            destination, [d for d in next(os.walk(destination))[1]][0])\n        return source\n\n    logger.debug('Retrieving source...')\n    if '://' in source:\n        split = source.split('://')\n        schema = split[0]\n        if schema in ['file', 'http', 'https']:\n            tmpdir = tempfile.mkdtemp()\n            fd, tmpfile = tempfile.mkstemp()\n            os.close(fd)\n            try:\n                _download_file(source, tmpfile)\n                source = extract_source(tmpfile, tmpdir)\n            finally:\n                os.remove(tmpfile)\n        else:\n            raise WagonError('Source URL type {0} is not supported'.format(\n                schema))\n    elif os.path.isfile(source):\n        tmpdir = tempfile.mkdtemp()\n        source = extract_source(source, tmpdir)\n    elif os.path.isdir(os.path.expanduser(source)):\n        source = os.path.expanduser(source)\n    elif '==' in source:\n        base_name, version = source.split('==')\n        source = _get_package_info_from_pypi(base_name)['name']\n        source = '{0}=={1}'.format(source, version)\n    else:\n        source = _get_package_info_from_pypi(source)['name']\n    logger.debug('Source is: %s', source)\n    return source", "response": "Returns a pip - installable source string for the source of a single package."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a Wagon archive from a source directory.", "response": "def create(source,\n           requirement_files=None,\n           force=False,\n           keep_wheels=False,\n           archive_destination_dir='.',\n           python_versions=None,\n           validate_archive=False,\n           wheel_args='',\n           archive_format='zip',\n           build_tag=''):\n    \"\"\"Create a Wagon archive and returns its path.\n\n    Package name and version are extracted from the setup.py file\n    of the `source` or from the PACKAGE_NAME==PACKAGE_VERSION if the source\n    is a PyPI package.\n\n    Supported `python_versions` must be in the format e.g [33, 27, 2, 3]..\n\n    `force` will remove any excess dirs or archives before creation.\n\n    `requirement_files` can be either a link/local path to a\n    requirements.txt file or just `.`, in which case requirement files\n    will be automatically extracted from either the GitHub archive URL\n    or the local path provided provided in `source`.\n    \"\"\"\n    if validate_archive:\n        _assert_virtualenv_is_installed()\n\n    logger.info('Creating archive for %s...', source)\n    processed_source = get_source(source)\n    if os.path.isdir(processed_source) and not \\\n            os.path.isfile(os.path.join(processed_source, 'setup.py')):\n        raise WagonError(\n            'Source directory must contain a setup.py file')\n    package_name, package_version = get_source_name_and_version(\n        processed_source)\n\n    tempdir = tempfile.mkdtemp()\n    workdir = os.path.join(tempdir, package_name)\n    wheels_path = os.path.join(workdir, DEFAULT_WHEELS_PATH)\n\n    try:\n        wheels = wheel(\n            processed_source,\n            requirement_files,\n            wheels_path,\n            wheel_args)\n    finally:\n        if processed_source != source:\n            shutil.rmtree(processed_source, ignore_errors=True)\n\n    platform = _get_platform_for_set_of_wheels(wheels_path)\n    if is_verbose():\n        logger.debug('Platform is: %s', platform)\n    python_versions = _set_python_versions(python_versions)\n\n    if not os.path.isdir(archive_destination_dir):\n        os.makedirs(archive_destination_dir)\n    archive_name = _set_archive_name(\n        package_name, package_version, python_versions, platform, build_tag)\n    archive_path = os.path.join(archive_destination_dir, archive_name)\n\n    _handle_output_file(archive_path, force)\n    _generate_metadata_file(\n        workdir,\n        archive_name,\n        platform,\n        python_versions,\n        package_name,\n        package_version,\n        build_tag,\n        source,\n        wheels)\n\n    _create_wagon_archive(workdir, archive_path, archive_format)\n    if not keep_wheels:\n        logger.debug('Removing work directory...')\n        shutil.rmtree(tempdir, ignore_errors=True)\n\n    if validate_archive:\n        validate(archive_path)\n    logger.info('Wagon created successfully at: %s', archive_path)\n    return archive_path"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninstalls a Wagon archive.", "response": "def install(source,\n            venv=None,\n            requirement_files=None,\n            upgrade=False,\n            ignore_platform=False,\n            install_args=''):\n    \"\"\"Install a Wagon archive.\n\n    This can install in a provided `venv` or in the current\n    virtualenv in case one is currently active.\n\n    `upgrade` is merely pip's upgrade.\n\n    `ignore_platform` will allow to ignore the platform check, meaning\n    that if an archive was created for a specific platform (e.g. win32),\n    and the current platform is different, it will still attempt to\n    install it.\n\n    Platform check will fail on the following:\n\n    If not linux and no platform match (e.g. win32 vs. darwin)\n    If linux and:\n        architecture doesn't match (e.g. manylinux1_x86_64 vs. linux_i686)\n        wheel not manylinux and no platform match (linux_x86_64 vs. linux_i686)\n    \"\"\"\n    requirement_files = requirement_files or []\n\n    logger.info('Installing %s', source)\n    processed_source = get_source(source)\n    metadata = _get_metadata(processed_source)\n\n    def raise_unsupported_platform(machine_platform):\n        # TODO: Print which platform is supported?\n        raise WagonError(\n            'Platform unsupported for wagon ({0})'.format(\n                machine_platform))\n\n    try:\n        supported_platform = metadata['supported_platform']\n        if not ignore_platform and supported_platform != ALL_PLATFORMS_TAG:\n            logger.debug(\n                'Validating Platform %s is supported...', supported_platform)\n            machine_platform = get_platform()\n            if not _is_platform_supported(\n                    supported_platform, machine_platform):\n                raise_unsupported_platform(machine_platform)\n\n        wheels_path = os.path.join(processed_source, DEFAULT_WHEELS_PATH)\n        install_package(\n            metadata['package_name'],\n            wheels_path,\n            venv,\n            requirement_files,\n            upgrade,\n            install_args)\n    finally:\n        # Install can only be done on local or remote archives.\n        # This means that a temporary directory is always created\n        # with the sources to install within it. This is why we can allow\n        # ourselves to delete the parent dir without worrying.\n        # TODO: Make this even less dangerous by changing `get_source`\n        # to return the directory to delete instead. Much safer.\n        if processed_source != source:\n            shutil.rmtree(os.path.dirname(\n                processed_source), ignore_errors=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate(source):\n    _assert_virtualenv_is_installed()\n\n    logger.info('Validating %s', source)\n    processed_source = get_source(source)\n    metadata = _get_metadata(processed_source)\n\n    wheels_path = os.path.join(processed_source, DEFAULT_WHEELS_PATH)\n    validation_errors = []\n\n    logger.debug('Verifying that all required files exist...')\n    for wheel in metadata['wheels']:\n        if not os.path.isfile(os.path.join(wheels_path, wheel)):\n            validation_errors.append(\n                '{0} is missing from the archive'.format(wheel))\n\n    logger.debug('Testing package installation...')\n    tmpenv = _make_virtualenv()\n    try:\n        install(source=processed_source, venv=tmpenv)\n        if not _check_installed(metadata['package_name'], tmpenv):\n            validation_errors.append(\n                '{0} failed to install (Reason unknown)'.format(\n                    metadata['package_name']))\n    finally:\n        shutil.rmtree(tmpenv)\n\n    if validation_errors:\n        logger.info('Validation failed!')\n        for error in validation_errors:\n            logger.info(error)\n        logger.info('Source can be found at: %s', processed_source)\n    else:\n        logger.info('Validation Passed!')\n        if processed_source != source:\n            shutil.rmtree(processed_source)\n    return validation_errors", "response": "Validate a Wagon archive. Return True if succeeds False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the metadata for the provided archive.", "response": "def show(source):\n    \"\"\"Merely returns the metadata for the provided archive.\n    \"\"\"\n    if is_verbose():\n        logger.info('Retrieving Metadata for: %s', source)\n    processed_source = get_source(source)\n    metadata = _get_metadata(processed_source)\n    shutil.rmtree(processed_source)\n    return metadata"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrepairs all wheels in a single wagon archive.", "response": "def repair(source, validate_archive=False):\n    \"\"\"Use auditwheel (https://github.com/pypa/auditwheel)\n    to attempt and repair all wheels in a wagon.\n\n    The repair process will:\n\n    1. Extract the wagon and its metadata\n    2. Repair all wheels\n    3. Update the metadata with the new wheel names and platform\n    4. Repack the wagon\n    \"\"\"\n    _assert_auditwheel_exists()\n\n    logger.info('Repairing: %s', source)\n    processed_source = get_source(source)\n    metadata = _get_metadata(processed_source)\n    new_metadata = _repair_wheels(processed_source, metadata)\n\n    archive_name = _set_archive_name(\n        new_metadata['package_name'],\n        new_metadata['package_version'],\n        new_metadata['supported_python_versions'],\n        new_metadata['supported_platform'],\n        new_metadata['build_tag'])\n\n    _generate_metadata_file(\n        processed_source,\n        archive_name,\n        new_metadata['supported_platform'],\n        new_metadata['supported_python_versions'],\n        new_metadata['package_name'],\n        new_metadata['package_version'],\n        new_metadata['build_tag'],\n        new_metadata['package_source'],\n        new_metadata['wheels'])\n    archive_path = os.path.join(os.getcwd(), archive_name)\n    _create_wagon_archive(processed_source, archive_path)\n\n    if validate_archive:\n        validate(archive_path)\n    logger.info('Wagon created successfully at: %s', archive_path)\n    return archive_path"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nplaces a new order.", "response": "def place_order(self, amount, price, side, ord_type, symbol='btcusd', exchange='bitfinex'):\n        \"\"\"\n        Submit a new order.\n        :param amount:\n        :param price:\n        :param side:\n        :param ord_type:\n        :param symbol:\n        :param exchange:\n        :return:\n        \"\"\"\n        payload = {\n\n            \"request\": \"/v1/order/new\",\n            \"nonce\": self._nonce,\n            \"symbol\": symbol,\n            \"amount\": amount,\n            \"price\": price,\n            \"exchange\": exchange,\n            \"side\": side,\n            \"type\": ord_type\n\n        }\n\n        signed_payload = self._sign_payload(payload)\n        r = requests.post(self.URL + \"/order/new\", headers=signed_payload, verify=True)\n        json_resp = r.json()\n\n        try:\n            json_resp['order_id']\n        except:\n            return json_resp['message']\n\n        return json_resp"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_order(self, order_id):\n        payload = {\n            \"request\": \"/v1/order/cancel\",\n            \"nonce\": self._nonce,\n            \"order_id\": order_id\n        }\n\n        signed_payload = self._sign_payload(payload)\n        r = requests.post(self.URL + \"/order/cancel\", headers=signed_payload, verify=True)\n        json_resp = r.json()\n\n        try:\n            json_resp['avg_execution_price']\n        except:\n            return json_resp['message']\n\n        return json_resp", "response": "Cancel an order.\n        :param order_id:\n        :return:"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfetching past trades :param timestamp: :param symbol: :return:", "response": "def past_trades(self, timestamp=0, symbol='btcusd'):\n        \"\"\"\n        Fetch past trades\n        :param timestamp:\n        :param symbol:\n        :return:\n        \"\"\"\n        payload = {\n            \"request\": \"/v1/mytrades\",\n            \"nonce\": self._nonce,\n            \"symbol\": symbol,\n            \"timestamp\": timestamp\n        }\n\n        signed_payload = self._sign_payload(payload)\n        r = requests.post(self.URL + \"/mytrades\", headers=signed_payload, verify=True)\n        json_resp = r.json()\n\n        return json_resp"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef history(self, currency, since=0, until=9999999999, limit=500, wallet='exchange'):\n        payload = {\n            \"request\": \"/v1/history\",\n            \"nonce\": self._nonce,\n            \"currency\": currency,\n            \"since\": since,\n            \"until\": until,\n            \"limit\": limit,\n            \"wallet\": wallet\n        }\n        signed_payload = self._sign_payload(payload)\n        r = requests.post(self.URL + \"/history\", headers=signed_payload, verify=True)\n        json_resp = r.json()\n\n        return json_resp", "response": "View you balance ledger entries"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the ticker for a given symbol", "response": "def ticker(self, symbol):\n        \"\"\"\n        GET /ticker/:symbol\n\n        curl https://api.bitfinex.com/v1/ticker/btcusd\n        {\n            'ask': '562.9999',\n            'timestamp': '1395552290.70933607',\n            'bid': '562.25',\n            'last_price': u'562.25',\n            'mid': u'562.62495'}\n        \"\"\"\n        data = self._get(self.url_for(PATH_TICKER, (symbol)))\n\n        # convert all values to floats\n        return self._convert_to_floats(data)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef today(self, symbol):\n\n        data = self._get(self.url_for(PATH_TODAY, (symbol)))\n\n        # convert all values to floats\n        return self._convert_to_floats(data)", "response": "Get the today data for a symbol"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stats(self, symbol):\n        data = self._get(self.url_for(PATH_STATS, (symbol)))\n\n        for period in data:\n\n            for key, value in period.items():\n                if key == 'period':\n                    new_value = int(value)\n                elif key == 'volume':\n                    new_value = float(value)\n\n                period[key] = new_value\n\n        return data", "response": "get stats for a single symbol"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the lendbook for a given currency", "response": "def lendbook(self, currency, parameters=None):\n        \"\"\"\n        curl \"https://api.bitfinex.com/v1/lendbook/btc\"\n\n        {\"bids\":[{\"rate\":\"5.475\",\"amount\":\"15.03894663\",\"period\":30,\"timestamp\":\"1395112149.0\",\"frr\":\"No\"},{\"rate\":\"2.409\",\"amount\":\"14.5121868\",\"period\":7,\"timestamp\":\"1395497599.0\",\"frr\":\"No\"}],\"asks\":[{\"rate\":\"6.351\",\"amount\":\"15.5180735\",\"period\":5,\"timestamp\":\"1395549996.0\",\"frr\":\"No\"},{\"rate\":\"6.3588\",\"amount\":\"626.94808249\",\"period\":30,\"timestamp\":\"1395400654.0\",\"frr\":\"Yes\"}]}\n\n        Optional parameters\n\n        limit_bids (int): Optional. Limit the number of bids (loan demands) returned. May be 0 in which case the array of bids is empty. Default is 50.\n        limit_asks (int): Optional. Limit the number of asks (loan offers) returned. May be 0 in which case the array of asks is empty. Default is 50.\n        \"\"\"\n        data = self._get(self.url_for(PATH_LENDBOOK, path_arg=currency, parameters=parameters))\n\n        for lend_type in data.keys():\n\n            for lend in data[lend_type]:\n\n                for key, value in lend.items():\n                    if key in ['rate', 'amount', 'timestamp']:\n                        new_value = float(value)\n                    elif key == 'period':\n                        new_value = int(value)\n                    elif key == 'frr':\n                        new_value = value == 'Yes'\n\n                    lend[key] = new_value\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the orderbook for a given symbol", "response": "def order_book(self, symbol, parameters=None):\n        \"\"\"\n        curl \"https://api.bitfinex.com/v1/book/btcusd\"\n\n        {\"bids\":[{\"price\":\"561.1101\",\"amount\":\"0.985\",\"timestamp\":\"1395557729.0\"}],\"asks\":[{\"price\":\"562.9999\",\"amount\":\"0.985\",\"timestamp\":\"1395557711.0\"}]}\n\n        The 'bids' and 'asks' arrays will have multiple bid and ask dicts.\n\n        Optional parameters\n\n        limit_bids (int): Optional. Limit the number of bids returned. May be 0 in which case the array of bids is empty. Default is 50.\n        limit_asks (int): Optional. Limit the number of asks returned. May be 0 in which case the array of asks is empty. Default is 50.\n\n        eg.\n        curl \"https://api.bitfinex.com/v1/book/btcusd?limit_bids=1&limit_asks=0\"\n        {\"bids\":[{\"price\":\"561.1101\",\"amount\":\"0.985\",\"timestamp\":\"1395557729.0\"}],\"asks\":[]}\n\n        \"\"\"\n        data = self._get(self.url_for(PATH_ORDERBOOK, path_arg=symbol, parameters=parameters))\n\n        for type_ in data.keys():\n            for list_ in data[type_]:\n                for key, value in list_.items():\n                    list_[key] = float(value)\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert all values in a dict to floats", "response": "def _convert_to_floats(self, data):\n        \"\"\"\n        Convert all values in a dict to floats\n        \"\"\"\n        for key, value in data.items():\n            data[key] = float(value)\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, portfolio, date, perfs=None):\n        '''\n        Actualizes the portfolio universe with the alog state\n        '''\n        # Make the manager aware of current simulation\n        self.portfolio = portfolio\n        self.perfs = perfs\n        self.date = date", "response": "Updates the current state of the Alog object with the given portfolio and date."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprocessing buy and sell signals from the simulation", "response": "def trade_signals_handler(self, signals):\n        '''\n        Process buy and sell signals from the simulation\n        '''\n        alloc = {}\n\n        if signals['buy'] or signals['sell']:\n            # Compute the optimal portfolio allocation,\n            # Using user defined function\n            try:\n                alloc, e_ret, e_risk = self.optimize(\n                    self.date, signals['buy'], signals['sell'],\n                    self._optimizer_parameters)\n            except Exception, error:\n                raise PortfolioOptimizationFailed(\n                    reason=error, date=self.date, data=signals)\n        return _remove_useless_orders(alloc)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadvancing the optimizer parameters.", "response": "def advise(self, **kwargs):\n        '''\n        General parameters or user settings\n        (maw_weigth, max_assets, max_frequency, commission cost)\n        '''\n        for name, value in kwargs.iteritems():\n            self._optimizer_parameters[name] = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading historical data from yahoo! finance historical quotes", "response": "def historical_pandas_yahoo(symbol, source='yahoo', start=None, end=None):\n    '''\n    Fetch from yahoo! finance historical quotes\n    '''\n    #NOTE Panel for multiple symbols ?\n    #NOTE Adj Close column name not cool (a space)\n    return DataReader(symbol, source, start=start, end=end)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a dataframe with the data from yahoo", "response": "def snapshot_yahoo_pandas(symbols):\n    '''\n    Get a simple snapshot from yahoo, return dataframe\n    __________________________________________________\n    Return\n        pandas.DataFrame with symbols as index\n        and columns = [change_pct, time, last, short_ratio, PE]\n    '''\n    if isinstance(symbols, str):\n        symbols = [symbols]\n    # TODO lower() columns\n    data = get_quote_yahoo(symbols)\n    data.columns = map(str.lower, data.columns)\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfetches company info >>> lookup_symbol(\"Apple Inc.\") {u'exch': u'NMS', u'market': u'NASDAQ', u'name': u'Apple Inc.', u'symbol': u'AAPL', u'type': u'Equity'}", "response": "def lookup_symbol(company):\n    ''' Fetch company info\n    >>> lookup_symbol(\"Apple Inc.\")\n          {u'exch': u'NMS',\n           u'market': u'NASDAQ',\n           u'name': u'Apple Inc.',\n           u'symbol': u'AAPL',\n           u'type': u'Equity'}\n    '''\n    request = requests.get(FINANCE_URLS['info_lookup'].format(company))\n    return json.loads(request.text[39:-1])[\"ResultSet\"][\"Result\"] \\\n        if request.ok else {'error': request.reason}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompute a period moving average.", "response": "def moving_average(data, periods, type='simple'):\n    \"\"\"\n    compute a <periods> period moving average.\n    type is 'simple' | 'exponential'\n    \"\"\"\n    data = np.asarray(data)\n    if type == 'simple':\n        weights = np.ones(periods)\n    else:\n        weights = np.exp(np.linspace(-1., 0., periods))\n\n    weights /= weights.sum()\n\n    mavg = np.convolve(data, weights, mode='full')[:len(data)]\n    mavg[:periods] = mavg[periods]\n    return mavg"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef relative_strength(prices, periods=14):\n    deltas = np.diff(prices)\n    seed = deltas[:periods + 1]\n    up = seed[seed >= 0].sum() / periods\n    down = -seed[seed < 0].sum() / periods\n    ratio = up / down\n    rsi = np.zeros_like(prices)\n    rsi[:periods] = 100. - 100. / (1. + ratio)\n\n    for i in range(periods, len(prices)):\n        delta = deltas[i - 1]  # Cause the diff is 1 shorter\n\n        if delta > 0:\n            upval = delta\n            downval = 0.\n        else:\n            upval = 0.\n            downval = -delta\n\n        up = (up * (periods - 1) + upval) / periods\n        down = (down * (periods - 1) + downval) / periods\n\n        ratio = up / down\n        rsi[i] = 100. - 100. / (1. + ratio)\n\n    return rsi", "response": "compute the relative strength indicator for a list of prices"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute the MACD of the Moving Average Convergence", "response": "def moving_average_convergence(data, nslow=26, nfast=12):\n    \"\"\"\n    compute the MACD (Moving Average Convergence/Divergence)\n    using a fast and slow exponential moving avg\n    return value is emaslow, emafast, macd which are len(data) arrays\n    \"\"\"\n    emaslow = moving_average(data, nslow, type='exponential')\n    emafast = moving_average(data, nfast, type='exponential')\n    return emaslow, emafast, emafast - emaslow"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef average_returns(ts, **kwargs):\n    ''' Compute geometric average returns from a returns time serie'''\n    average_type = kwargs.get('type', 'net')\n    if average_type == 'net':\n        relative = 0\n    else:\n        relative = -1  # gross\n    #start = kwargs.get('start', ts.index[0])\n    #end = kwargs.get('end', ts.index[len(ts.index) - 1])\n    #delta = kwargs.get('delta', ts.index[1] - ts.index[0])\n    period = kwargs.get('period', None)\n    if isinstance(period, int):\n        pass\n    #else:\n        #ts = reIndexDF(ts, start=start, end=end, delta=delta)\n        #period = 1\n    avg_ret = 1\n    for idx in range(len(ts.index)):\n        if idx % period == 0:\n            avg_ret *= (1 + ts[idx] + relative)\n    return avg_ret - 1", "response": "Compute geometric average returns from a returns time serie"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing returns on the given time serie", "response": "def returns(ts, **kwargs):\n    '''\n    Compute returns on the given period\n\n    @param ts : time serie to process\n    @param kwargs.type: gross or simple returns\n    @param delta : period betweend two computed returns\n    @param start : with end, will return the return betweend this elapsed time\n    @param period : delta is the number of lines/periods provided\n    @param end : so said\n    @param cumulative: compute cumulative returns\n    '''\n    returns_type = kwargs.get('type', 'net')\n    cumulative = kwargs.get('cumulative', False)\n    if returns_type == 'net':\n        relative = 0\n    else:\n        relative = 1  # gross\n    start = kwargs.get('start', None)\n    end = kwargs.get('end', dt.datetime.today())\n    #delta = kwargs.get('delta', None)\n    period = kwargs.get('period', 1)\n    if isinstance(start, dt.datetime):\n        log.debug('{} / {} -1'.format(ts[end], ts[start]))\n        return ts[end] / ts[start] - 1 + relative\n    #elif isinstance(delta, pd.DateOffset) or isinstance(delta, dt.timedelta):\n        #FIXME timezone problem\n        #FIXME reIndexDF is deprecated\n        #ts = reIndexDF(ts, delta=delta)\n        #period = 1\n    rets_df = ts / ts.shift(period) - 1 + relative\n    if cumulative:\n        return rets_df.cumprod()\n    return rets_df[1:]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef daily_returns(ts, **kwargs):\n    ''' re-compute ts on a daily basis '''\n    relative = kwargs.get('relative', 0)\n    return returns(ts, delta=BDay(), relative=relative)", "response": "re - compute ts on a daily basis"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_files(path, extension=\".cpp\", exclude=\"S.cpp\"):\n    return [\"%s/%s\" % (path, f) for f in listdir(path) if f.endswith(extension) and (not f.endswith(exclude))]", "response": "List all files that ends with a given extension"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef intuition(args):\n    '''\n    Main simulation wrapper\n    Load the configuration, run the engine and return the analyze.\n    '''\n\n    # Use the provided context builder to fill:\n    #   - config: General behavior\n    #   - strategy: Modules properties\n    #   - market: The universe we will trade on\n    with setup.Context(args['context']) as context:\n\n        # Backtest or live engine.\n        # Registers configuration and setups data client\n        simulation = Simulation()\n\n        # Intuition building blocks\n        modules = context['config']['modules']\n\n        # Prepare benchmark, timezone, trading calendar\n        simulation.configure_environment(\n            context['config']['index'][-1],\n            context['market'].benchmark,\n            context['market'].timezone)\n\n        # Wire togetether modules and initialize them\n        simulation.build(args['session'],\n                         modules,\n                         context['strategy'])\n\n        # Build data generator\n        # NOTE How can I use several sources ?\n        data = {'universe': context['market'],\n                'index': context['config']['index']}\n        # Add user settings\n        data.update(context['strategy']['data'])\n        # Load backtest and / or live module(s)\n        if 'backtest' in modules:\n            data['backtest'] = utils.intuition_module(modules['backtest'])\n        if 'live' in modules:\n            data['live'] = utils.intuition_module(modules['live'])\n\n        # Run the simulation and return an intuition.core.analyzes object\n        return simulation(datafeed.HybridDataFactory(**data), args['bot'])", "response": "Main simulation wrapper for Intuition."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprevents middlewares and orders to work outside live mode", "response": "def _is_interactive(self):\n        ''' Prevent middlewares and orders to work outside live mode '''\n        return not (\n            self.realworld and (dt.date.today() > self.datetime.date()))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef use(self, func, when='whenever'):\n        ''' Append a middleware to the algorithm '''\n        #NOTE A middleware Object ?\n        # self.use() is usually called from initialize(), so no logger yet\n        print('registering middleware {}'.format(func.__name__))\n        self.middlewares.append({\n            'call': func,\n            'name': func.__name__,\n            'args': func.func_code.co_varnames,\n            'when': when\n        })", "response": "Add a middleware to the algorithm"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handle_data(self, data):\n        ''' Method called for each event by zipline. In intuition this is the\n        place to factorize algorithms and then call event() '''\n        self.days += 1\n        signals = {}\n        self.orderbook = {}\n\n        # Everytime but the first tick\n        if self.initialized and self.manager:\n            # Keep the portfolio aware of the situation\n            self.manager.update(\n                self.portfolio,\n                self.datetime,\n                self.perf_tracker.cumulative_risk_metrics.to_dict())\n        else:\n            # Perf_tracker needs at least a turn to have an index\n            self.sids = data.keys()\n            self.warm(data)\n            self.initialized = True\n            return\n\n        try:\n            signals = self.event(data)\n        except Exception, error:\n            # NOTE Temporary debug. Will probably notify the error and go on\n            # with signals={}\n            raise AlgorithmEventFailed(\n                reason=error, date=self.datetime, data=data)\n\n        # One can process orders within the alogrithm and don't return anything\n        if signals and self.manager:\n            if (signals.get('buy') or signals.get('sell')):\n                self.orderbook = self.manager.trade_signals_handler(signals)\n                if self.auto and self._is_interactive():\n                    self.process_orders(self.orderbook)\n\n        # Some middlewares send stuff over the wires. This little security\n        # prevent us from performing a DDOS\n        if self._is_interactive():\n            self._call_middlewares()", "response": "Method called for each event by zipline."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef process_orders(self, orderbook):\n        ''' Default and costant orders processor. Overwrite it for more\n        sophisticated strategies '''\n        for stock, alloc in orderbook.iteritems():\n            self.logger.info('{}: Ordered {} {} stocks'.format(\n                self.datetime, stock, alloc))\n            if isinstance(alloc, int):\n                self.order(stock, alloc)\n            elif isinstance(alloc, float) and \\\n                    alloc >= -1 and alloc <= 1:\n                self.order_percent(stock, alloc)\n            else:\n                self.logger.warning(\n                    '{}: invalid order for {}: {})'\n                    .format(self.datetime, stock, alloc))", "response": "Default and costant orders processor. Overwrite it for more\n        sophisticated strategies."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nevaluating arguments and execute the middleware function", "response": "def _call_one_middleware(self, middleware):\n        ''' Evaluate arguments and execute the middleware function '''\n        args = {}\n        for arg in middleware['args']:\n            if hasattr(self, arg):\n                # same as eval() but safer for arbitrary code execution\n                args[arg] = reduce(getattr, arg.split('.'), self)\n        self.logger.debug('calling middleware event {}'\n                          .format(middleware['name']))\n        middleware['call'](**args)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting the middlewares stack", "response": "def _call_middlewares(self):\n        ''' Execute the middleware stack '''\n        for middleware in self.middlewares:\n            if self._check_condition(middleware['when']):\n                self._call_one_middleware(middleware)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef normalize_date(self, test_date):\n        ''' Same function as zipline.finance.trading.py'''\n        test_date = pd.Timestamp(test_date, tz='UTC')\n        return pd.tseries.tools.normalize_date(test_date)", "response": "Same function as zipline. finance. trading. py"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _load_market_scheme(self):\n        ''' Load market yaml description '''\n        try:\n            self.scheme = yaml.load(open(self.scheme_path, 'r'))\n        except Exception, error:\n            raise LoadMarketSchemeFailed(reason=error)", "response": "Load market yaml description"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the universe description and store the attributes in self. raw_description.", "response": "def parse_universe_description(self, description):\n        ''' Semantic\n\n           - 'sid1,sid2,sid2,...'\n           - 'exchange' : every sids of the exchange\n           - 'exchange,n' : n random sids of the exchange\n\n        where exchange is a combination of 'type:index:submarket'\n        '''\n        self.raw_description = description\n        description = description.split(',')\n        self.exchange = description[0]\n\n        n = int(description[1]) if len(description) == 2 else -1\n        self.sids = self._lookup_sids(description[0], n)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fetch(self, code, **kwargs):\n        '''\n        Quandl entry point in datafeed object\n        '''\n        log.debug('fetching QuanDL data (%s)' % code)\n        # This way you can use your credentials even if\n        # you didn't provide them to the constructor\n        if 'authtoken' in kwargs:\n            self.quandl_key = kwargs.pop('authtoken')\n\n        # Harmonization: Quandl call start trim_start\n        if 'start' in kwargs:\n            kwargs['trim_start'] = kwargs.pop('start')\n        if 'end' in kwargs:\n            kwargs['trim_end'] = kwargs.pop('end')\n\n        try:\n            data = Quandl.get(code, authtoken=self.quandl_key, **kwargs)\n            # FIXME With a symbol not found, insert a not_found column\n            data.index = data.index.tz_localize(pytz.utc)\n        except Exception, error:\n            log.error('unable to fetch {}: {}'.format(code, error))\n            data = pd.DataFrame()\n        return data", "response": "Fetch a Quandl entry point in datafeed object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfiltering self. perfs and returns a dataframe of performance data for the current object.", "response": "def rolling_performances(self, timestamp='one_month'):\n        ''' Filters self.perfs '''\n        # TODO Study the impact of month choice\n        # TODO Check timestamp in an enumeration\n        # TODO Implement other benchmarks for perf computation\n        # (zipline issue, maybe expected)\n\n        if self.metrics:\n            perfs = {}\n            length = range(len(self.metrics[timestamp]))\n            index = self._get_index(self.metrics[timestamp])\n            perf_keys = self.metrics[timestamp][0].keys()\n            perf_keys.pop(perf_keys.index('period_label'))\n\n            perfs['period'] = np.array(\n                [pd.datetime.date(date) for date in index])\n            for key in perf_keys:\n                perfs[key] = self._to_perf_array(timestamp, key, length)\n        else:\n            # TODO Get it from DB if it exists\n            raise NotImplementedError()\n\n        return pd.DataFrame(perfs, index=index)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute the overall performance indicators for the current time period.", "response": "def overall_metrics(self, timestamp='one_month', metrics=None):\n        '''\n        Use zipline results to compute some performance indicators\n        '''\n        perfs = dict()\n\n        # If no rolling perfs provided, computes it\n        if metrics is None:\n            metrics = self.rolling_performances(timestamp=timestamp)\n        riskfree = np.mean(metrics['treasury_period_return'])\n\n        perfs['sharpe'] = qstk_get_sharpe_ratio(\n            metrics['algorithm_period_return'].values, risk_free=riskfree)\n        perfs['algorithm_period_return'] = (\n            ((metrics['algorithm_period_return'] + 1).cumprod()) - 1)[-1]\n        perfs['max_drawdown'] = max(metrics['max_drawdown'])\n        perfs['algo_volatility'] = np.mean(metrics['algo_volatility'])\n        perfs['beta'] = np.mean(metrics['beta'])\n        perfs['alpha'] = np.mean(metrics['alpha'])\n        perfs['benchmark_period_return'] = (\n            ((metrics['benchmark_period_return'] + 1).cumprod()) - 1)[-1]\n\n        return perfs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nnormalize dates in the context and updates the index and live fields.", "response": "def _normalize_dates(self, context):\n        '''\n        Build a timeline from given (or not) start and end dates\n        '''\n        if 'start' in context:\n            if isinstance(context['start'], dt.date):\n                context['start'] = dt.date.strftime(\n                    context['start'], format='%Y-%m-%d')\n        if 'end' in context:\n            if isinstance(context['end'], dt.date):\n                context['end'] = dt.date.strftime(\n                    context['end'], format='%Y-%m-%d')\n\n        trading_dates = intuition.utils.build_trading_timeline(\n            context.pop('start', None), context.pop('end', None))\n\n        context['index'] = trading_dates\n        context['live'] = (dt.datetime.now(tz=pytz.utc) < trading_dates[-1])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _normalize_data_types(self, strategy):\n        ''' some contexts only retrieves strings, giving back right type '''\n        for k, v in strategy.iteritems():\n            if not isinstance(v, str):\n                # There is probably nothing to do\n                continue\n            if v == 'true':\n                strategy[k] = True\n            elif v == 'false' or v is None:\n                strategy[k] = False\n            else:\n                try:\n                    if v.find('.') > 0:\n                        strategy[k] = float(v)\n                    else:\n                        strategy[k] = int(v)\n                except ValueError:\n                    pass", "response": "some contexts only retrieves strings giving back right type"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconfiguring the benchmark loader and trading context", "response": "def configure_environment(self, last_trade, benchmark, timezone):\n        ''' Prepare benchmark loader and trading context '''\n\n        if last_trade.tzinfo is None:\n            last_trade = pytz.utc.localize(last_trade)\n\n        # Setup the trading calendar from market informations\n        self.benchmark = benchmark\n        self.context = TradingEnvironment(\n            bm_symbol=benchmark,\n            exchange_tz=timezone,\n            load=self._get_benchmark_handler(last_trade))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwraps of zipline run method. Builds the trading environment.", "response": "def build(self, identity, modules, strategy=constants.DEFAULT_CONFIG):\n        '''\n        Wrapper of zipline run() method. Use the configuration set so far\n        to build up the trading environment\n        '''\n        # TODO Catch a problem here\n        self.engine = TradingEngine(identity, modules, strategy)\n        self.initial_cash = strategy['manager'].get('cash', None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef apply_mapping(raw_row, mapping):\n    '''\n    Override this to hand craft conversion of row.\n    '''\n    row = {target: mapping_func(raw_row[source_key])\n           for target, (mapping_func, source_key)\n           in mapping.fget().items()}\n    return row", "response": "Override this to hand craft conversion of row.\n    Override this to hand craft conversion of row.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninverts dataframe index column names and vice et versa", "response": "def invert_dataframe_axis(fct):\n    '''\n    Make dataframe index column names,\n    and vice et versa\n    '''\n    def inner(*args, **kwargs):\n        df_to_invert = fct(*args, **kwargs)\n        return pd.DataFrame(df_to_invert.to_dict().values(),\n                            index=df_to_invert.to_dict().keys())\n    return inner"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef use_google_symbol(fct):\n    '''\n    Removes \".PA\" or other market indicator from yahoo symbol\n    convention to suit google convention\n    '''\n    def decorator(symbols):\n        google_symbols = []\n\n        # If one symbol string\n        if isinstance(symbols, str):\n            symbols = [symbols]\n\n        symbols = sorted(symbols)\n        for symbol in symbols:\n            dot_pos = symbol.find('.')\n            google_symbols.append(\n                symbol[:dot_pos] if (dot_pos > 0) else symbol)\n\n        data = fct(google_symbols)\n        #NOTE Not very elegant\n        data.columns = [s for s in symbols if s.split('.')[0] in data.columns]\n        return data\n    return decorator", "response": "Decorator to use google symbol"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting all available quote data for the given ticker symbol.", "response": "def get_all(symbol):\n    \"\"\"\n    Get all available quote data for the given ticker symbol.\n\n    Returns a dictionary.\n    \"\"\"\n    ids = \\\n        'ydb2r1b3qpoc1d1cd2c6t1k2p2c8m5c3m6gm7hm8k1m3lm4l1t8w1g1w4g3p' \\\n        '1g4mg5m2g6kvjj1j5j3k4f6j6nk5n4ws1xj2va5b6k3t7a2t615l2el3e7v1' \\\n        'e8v7e9s6b4j4p5p6rr2r5r6r7s7'\n    values = _request(symbol, ids).split(',')\n    return dict(\n        dividend_yield=values[0],\n        dividend_per_share=values[1],\n        ask_realtime=values[2],\n        dividend_pay_date=values[3],\n        bid_realtime=values[4],\n        ex_dividend_date=values[5],\n        previous_close=values[6],\n        today_open=values[7],\n        change=values[8],\n        last_trade_date=values[9],\n        change_percent_change=values[10],\n        trade_date=values[11],\n        change_realtime=values[12],\n        last_trade_time=values[13],\n        change_percent_realtime=values[14],\n        change_percent=values[15],\n        after_hours_change_realtime=values[16],\n        change_200_sma=values[17],\n        todays_low=values[18],\n        change_50_sma=values[19],\n        todays_high=values[20],\n        percent_change_50_sma=values[21],\n        last_trade_realtime_time=values[22],\n        fifty_sma=values[23],\n        last_trade_time_plus=values[24],\n        twohundred_sma=values[25],\n        last_trade_price=values[26],\n        one_year_target=values[27],\n        todays_value_change=values[28],\n        holdings_gain_percent=values[29],\n        todays_value_change_realtime=values[30],\n        annualized_gain=values[31],\n        price_paid=values[32],\n        holdings_gain=values[33],\n        todays_range=values[34],\n        holdings_gain_percent_realtime=values[35],\n        todays_range_realtime=values[36],\n        holdings_gain_realtime=values[37],\n        fiftytwo_week_high=values[38],\n        more_info=values[39],\n        fiftytwo_week_low=values[40],\n        market_cap=values[41],\n        change_from_52_week_low=values[42],\n        market_cap_realtime=values[43],\n        change_from_52_week_high=values[44],\n        float_shares=values[45],\n        percent_change_from_52_week_low=values[46],\n        company_name=values[47],\n        percent_change_from_52_week_high=values[48],\n        notes=values[49],\n        fiftytwo_week_range=values[50],\n        shares_owned=values[51],\n        stock_exchange=values[52],\n        shares_outstanding=values[53],\n        volume=values[54],\n        ask_size=values[55],\n        bid_size=values[56],\n        last_trade_size=values[57],\n        ticker_trend=values[58],\n        average_daily_volume=values[59],\n        trade_links=values[60],\n        order_book_realtime=values[61],\n        high_limit=values[62],\n        eps=values[63],\n        low_limit=values[64],\n        eps_estimate_current_year=values[65],\n        holdings_value=values[66],\n        eps_estimate_next_year=values[67],\n        holdings_value_realtime=values[68],\n        eps_estimate_next_quarter=values[69],\n        revenue=values[70],\n        book_value=values[71],\n        ebitda=values[72],\n        price_sales=values[73],\n        price_book=values[74],\n        pe=values[75],\n        pe_realtime=values[76],\n        peg=values[77],\n        price_eps_estimate_current_year=values[78],\n        price_eps_estimate_next_year=values[79],\n        short_ratio=values[80],\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget stock sector from Yahoo! Finance website", "response": "def get_sector(symbol):\n    '''\n    Uses BeautifulSoup to scrape stock sector from Yahoo! Finance website\n    '''\n    url = 'http://finance.yahoo.com/q/pr?s=%s+Profile' % symbol\n    soup = BeautifulSoup(urlopen(url).read())\n    try:\n        sector = soup.find('td', text='Sector:').\\\n            find_next_sibling().string.encode('utf-8')\n    except:\n        sector = ''\n    return sector"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_industry(symbol):\n    '''\n    Uses BeautifulSoup to scrape stock industry from Yahoo! Finance website\n    '''\n    url = 'http://finance.yahoo.com/q/pr?s=%s+Profile' % symbol\n    soup = BeautifulSoup(urlopen(url).read())\n    try:\n        industry = soup.find('td', text='Industry:').\\\n            find_next_sibling().string.encode('utf-8')\n    except:\n        industry = ''\n    return industry", "response": "Returns stock industry from Yahoo! Finance website"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the asset type of a symbol", "response": "def get_type(symbol):\n    '''\n    Uses BeautifulSoup to scrape symbol category from Yahoo! Finance website\n    '''\n    url = 'http://finance.yahoo.com/q/pr?s=%s+Profile' % symbol\n    soup = BeautifulSoup(urlopen(url).read())\n    if soup.find('span', text='Business Summary'):\n        return 'Stock'\n    elif soup.find('span', text='Fund Summary'):\n        asset_type = 'Fund'\n    elif symbol.find('^') == 0:\n        asset_type = 'Index'\n    else:\n        pass\n    return asset_type"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets historical prices for the given ticker symbol.", "response": "def get_historical_prices(symbol, start_date, end_date):\n    \"\"\"\n    Get historical prices for the given ticker symbol.\n    Date format is 'YYYY-MM-DD'\n\n    Returns a nested dictionary (dict of dicts).\n    outer dict keys are dates ('YYYY-MM-DD')\n    \"\"\"\n    params = urlencode({\n        's': symbol,\n        'a': int(start_date[5:7]) - 1,\n        'b': int(start_date[8:10]),\n        'c': int(start_date[0:4]),\n        'd': int(end_date[5:7]) - 1,\n        'e': int(end_date[8:10]),\n        'f': int(end_date[0:4]),\n        'g': 'd',\n        'ignore': '.csv',\n    })\n    url = 'http://ichart.yahoo.com/table.csv?%s' % params\n    req = Request(url)\n    resp = urlopen(req)\n    content = str(resp.read().decode('utf-8').strip())\n    daily_data = content.splitlines()\n    hist_dict = dict()\n    keys = daily_data[0].split(',')\n    for day in daily_data[1:]:\n        day_data = day.split(',')\n        date = day_data[0]\n        hist_dict[date] = \\\n            {keys[1]: day_data[1],\n             keys[2]: day_data[2],\n             keys[3]: day_data[3],\n             keys[4]: day_data[4],\n             keys[5]: day_data[5],\n             keys[6]: day_data[6]}\n    return hist_dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmap raw output to clearer labels", "response": "def _fx_mapping(raw_rates):\n    ''' Map raw output to clearer labels '''\n    return {pair[0].lower(): {\n        'timeStamp': pair[1],\n        'bid': float(pair[2] + pair[3]),\n        'ask': float(pair[4] + pair[5]),\n        'high': float(pair[6]),\n        'low': float(pair[7])\n    } for pair in map(lambda x: x.split(','), raw_rates)}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef query_rates(self, pairs=[]):\n        ''' Perform a request against truefx data '''\n        # If no pairs, TrueFx will use the ones given the last time\n        payload = {'id': self._session}\n        if pairs:\n            payload['c'] = _clean_pairs(pairs)\n        response = requests.get(self._api_url, params=payload)\n\n        mapped_data = _fx_mapping(response.content.split('\\n')[:-2])\n        return Series(mapped_data) if len(mapped_data) == 1 \\\n            else DataFrame(mapped_data)", "response": "Perform a request against truefx data"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if we reach a given date.", "response": "def next_tick(date, interval=15):\n    '''\n    Only return when we reach given datetime\n    '''\n    # Intuition works with utc dates, conversion are made for I/O\n    now = dt.datetime.now(pytz.utc)\n    live = False\n    # Sleep until we reach the given date\n    while now < date:\n        time.sleep(interval)\n        # Update current time\n        now = dt.datetime.now(pytz.utc)\n        # Since we're here, we waited a future date, so this is live trading\n        live = True\n    return live"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding the module path and import it", "response": "def intuition_module(location):\n    ''' Build the module path and import it '''\n    path = location.split('.')\n    # Get the last field, i.e. the object name in the file\n    obj = path.pop(-1)\n    return dna.utils.dynamic_import('.'.join(path), obj)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build_trading_timeline(start, end):\n    ''' Build the daily-based index we will trade on '''\n    EMPTY_DATES = pd.date_range('2000/01/01', periods=0, tz=pytz.utc)\n    now = dt.datetime.now(tz=pytz.utc)\n\n    if not start:\n        if not end:\n            # Live trading until the end of the day\n            bt_dates = EMPTY_DATES\n            live_dates = pd.date_range(\n                start=now,\n                end=normalize_date_format('23h59'))\n        else:\n            end = normalize_date_format(end)\n            if end < now:\n                # Backtesting since a year before end\n                bt_dates = pd.date_range(\n                    start=end - 360 * pd.datetools.day,\n                    end=end)\n                live_dates = EMPTY_DATES\n            elif end > now:\n                # Live trading from now to end\n                bt_dates = EMPTY_DATES\n                live_dates = pd.date_range(start=now, end=end)\n    else:\n        start = normalize_date_format(start)\n        if start < now:\n            if not end:\n                # Backtest for a year or until now\n                end = start + 360 * pd.datetools.day\n                if end > now:\n                    end = now - pd.datetools.day\n                live_dates = EMPTY_DATES\n                bt_dates = pd.date_range(\n                    start=start, end=end)\n            else:\n                end = normalize_date_format(end)\n                if end < now:\n                    # Nothing to do, backtest from start to end\n                    live_dates = EMPTY_DATES\n                    bt_dates = pd.date_range(start=start, end=end)\n                elif end > now:\n                    # Hybrid timeline, backtest from start to end, live\n                    # trade from now to end\n                    bt_dates = pd.date_range(\n                        start=start, end=now - pd.datetools.day)\n\n                    live_dates = pd.date_range(start=now, end=end)\n        elif start > now:\n            if not end:\n                # Live trading from start to the end of the day\n                bt_dates = EMPTY_DATES\n                live_dates = pd.date_range(\n                    start=start,\n                    end=normalize_date_format('23h59'))\n            else:\n                # Live trading from start to end\n                end = normalize_date_format(end)\n                bt_dates = EMPTY_DATES\n                live_dates = pd.date_range(start=start, end=end)\n\n    return bt_dates + live_dates", "response": "Build the daily - based index we will trade on."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(filepath):\n    height = -1\n    width = -1\n\n    with open(filepath, 'rb') as fhandle:\n        head = fhandle.read(24)\n        size = len(head)\n        # handle GIFs\n        if size >= 10 and head[:6] in (b'GIF87a', b'GIF89a'):\n            # Check to see if content_type is correct\n            try:\n                width, height = struct.unpack(\"<hh\", head[6:10])\n            except struct.error:\n                raise ValueError(\"Invalid GIF file\")\n        # see png edition spec bytes are below chunk length then and finally the\n        elif size >= 24 and head.startswith(b'\\211PNG\\r\\n\\032\\n') and head[12:16] == b'IHDR':\n            try:\n                width, height = struct.unpack(\">LL\", head[16:24])\n            except struct.error:\n                raise ValueError(\"Invalid PNG file\")\n        # Maybe this is for an older PNG version.\n        elif size >= 16 and head.startswith(b'\\211PNG\\r\\n\\032\\n'):\n            # Check to see if we have the right content type\n            try:\n                width, height = struct.unpack(\">LL\", head[8:16])\n            except struct.error:\n                raise ValueError(\"Invalid PNG file\")\n        # handle JPEGs\n        elif size >= 2 and head.startswith(b'\\377\\330'):\n            try:\n                fhandle.seek(0)  # Read 0xff next\n                size = 2\n                ftype = 0\n                while not 0xc0 <= ftype <= 0xcf or ftype in [0xc4, 0xc8, 0xcc]:\n                    fhandle.seek(size, 1)\n                    byte = fhandle.read(1)\n                    while ord(byte) == 0xff:\n                        byte = fhandle.read(1)\n                    ftype = ord(byte)\n                    size = struct.unpack('>H', fhandle.read(2))[0] - 2\n                # We are at a SOFn block\n                fhandle.seek(1, 1)  # Skip `precision' byte.\n                height, width = struct.unpack('>HH', fhandle.read(4))\n            except struct.error:\n                raise ValueError(\"Invalid JPEG file\")\n        # handle JPEG2000s\n        elif size >= 12 and head.startswith(b'\\x00\\x00\\x00\\x0cjP  \\r\\n\\x87\\n'):\n            fhandle.seek(48)\n            try:\n                height, width = struct.unpack('>LL', fhandle.read(8))\n            except struct.error:\n                raise ValueError(\"Invalid JPEG2000 file\")\n        # handle big endian TIFF\n        elif size >= 8 and head.startswith(b\"\\x4d\\x4d\\x00\\x2a\"):\n            offset = struct.unpack('>L', head[4:8])[0]\n            fhandle.seek(offset)\n            ifdsize = struct.unpack(\">H\", fhandle.read(2))[0]\n            for i in range(ifdsize):\n                tag, datatype, count, data = struct.unpack(\">HHLL\", fhandle.read(12))\n                if tag == 256:\n                    if datatype == 3:\n                        width = int(data / 65536)\n                    elif datatype == 4:\n                        width = data\n                    else:\n                        raise ValueError(\"Invalid TIFF file: width column data type should be SHORT/LONG.\")\n                elif tag == 257:\n                    if datatype == 3:\n                        height = int(data / 65536)\n                    elif datatype == 4:\n                        height = data\n                    else:\n                        raise ValueError(\"Invalid TIFF file: height column data type should be SHORT/LONG.\")\n                if width != -1 and height != -1:\n                    break\n            if width == -1 or height == -1:\n                raise ValueError(\"Invalid TIFF file: width and/or height IDS entries are missing.\")\n        elif size >= 8 and head.startswith(b\"\\x49\\x49\\x2a\\x00\"):\n            offset = struct.unpack('<L', head[4:8])[0]\n            fhandle.seek(offset)\n            ifdsize = struct.unpack(\"<H\", fhandle.read(2))[0]\n            for i in range(ifdsize):\n                tag, datatype, count, data = struct.unpack(\"<HHLL\", fhandle.read(12))\n                if tag == 256:\n                    width = data\n                elif tag == 257:\n                    height = data\n                if width != -1 and height != -1:\n                    break\n            if width == -1 or height == -1:\n                raise ValueError(\"Invalid TIFF file: width and/or height IDS entries are missing.\")\n\n    return width, height", "response": "Return width height for a given img file content\n    No requirements\n    Return width height"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the width height of a given img file content and density of a given img file.", "response": "def getDPI(filepath):\n    \"\"\"\n    Return (width, height) for a given img file content\n    no requirements\n    \"\"\"\n    xDPI = -1\n    yDPI = -1\n    with open(filepath, 'rb') as fhandle:\n        head = fhandle.read(24)\n        size = len(head)\n        # handle GIFs\n        # GIFs doesn't have density\n        if size >= 10 and head[:6] in (b'GIF87a', b'GIF89a'):\n            pass\n        # see png edition spec bytes are below chunk length then and finally the\n        elif size >= 24 and head.startswith(b'\\211PNG\\r\\n\\032\\n'):\n            chunkOffset = 8\n            chunk = head[8:]\n            while True:\n                chunkType = chunk[4:8]\n                if chunkType == b'pHYs':\n                    try:\n                        xDensity, yDensity, unit = struct.unpack(\">LLB\", chunk[8:])\n                    except struct.error:\n                        raise ValueError(\"Invalid PNG file\")\n                    if unit:\n                        xDPI = _convertToDPI(xDensity, _UNIT_1M)\n                        yDPI = _convertToDPI(yDensity, _UNIT_1M)\n                    else:  # no unit\n                        xDPI = xDensity\n                        yDPI = yDensity\n                    break\n                elif chunkType == b'IDAT':\n                    break\n                else:\n                    try:\n                        dataSize, = struct.unpack(\">L\", chunk[0:4])\n                    except struct.error:\n                        raise ValueError(\"Invalid PNG file\")\n                    chunkOffset += dataSize + 12\n                    fhandle.seek(chunkOffset)\n                    chunk = fhandle.read(17)\n        # handle JPEGs\n        elif size >= 2 and head.startswith(b'\\377\\330'):\n            try:\n                fhandle.seek(0)  # Read 0xff next\n                size = 2\n                ftype = 0\n                while not 0xc0 <= ftype <= 0xcf:\n                    if ftype == 0xe0:  # APP0 marker\n                        fhandle.seek(7, 1)\n                        unit, xDensity, yDensity = struct.unpack(\">BHH\", fhandle.read(5))\n                        if unit == 1 or unit == 0:\n                            xDPI = xDensity\n                            yDPI = yDensity\n                        elif unit == 2:\n                            xDPI = _convertToDPI(xDensity, _UNIT_CM)\n                            yDPI = _convertToDPI(yDensity, _UNIT_CM)\n                        break\n                    fhandle.seek(size, 1)\n                    byte = fhandle.read(1)\n                    while ord(byte) == 0xff:\n                        byte = fhandle.read(1)\n                    ftype = ord(byte)\n                    size = struct.unpack('>H', fhandle.read(2))[0] - 2\n            except struct.error:\n                raise ValueError(\"Invalid JPEG file\")\n        # handle JPEG2000s\n        elif size >= 12 and head.startswith(b'\\x00\\x00\\x00\\x0cjP  \\r\\n\\x87\\n'):\n            fhandle.seek(32)\n            # skip JP2 image header box\n            headerSize = struct.unpack('>L', fhandle.read(4))[0] - 8\n            fhandle.seek(4, 1)\n            foundResBox = False\n            try:\n                while headerSize > 0:\n                    print(\"headerSize\", headerSize)\n                    boxHeader = fhandle.read(8)\n                    boxType = boxHeader[4:]\n                    print(boxType)\n                    if boxType == 'res ':  # find resolution super box\n                        foundResBox = True\n                        headerSize -= 8\n                        print(\"found res super box\")\n                        break\n                    print(\"@1\", boxHeader)\n                    boxSize, = struct.unpack('>L', boxHeader[:4])\n                    print(\"boxSize\", boxSize)\n                    fhandle.seek(boxSize - 8, 1)\n                    headerSize -= boxSize\n                if foundResBox:\n                    while headerSize > 0:\n                        boxHeader = fhandle.read(8)\n                        boxType = boxHeader[4:]\n                        print(boxType)\n                        if boxType == 'resd':  # Display resolution box\n                            print(\"@2\")\n                            yDensity, xDensity, yUnit, xUnit = struct.unpack(\">HHBB\", fhandle.read(10))\n                            xDPI = _convertToDPI(xDensity, xUnit)\n                            yDPI = _convertToDPI(yDensity, yUnit)\n                            break\n                        boxSize, = struct.unpack('>L', boxHeader[:4])\n                        print(\"boxSize\", boxSize)\n                        fhandle.seek(boxSize - 8, 1)\n                        headerSize -= boxSize\n            except struct.error as e:\n                print(e)\n                raise ValueError(\"Invalid JPEG2000 file\")\n    return xDPI, yDPI"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_leap(year):\n    x = math.fmod(year, 4)\n    y = math.fmod(year, 100)\n    z = math.fmod(year, 400)\n\n    # Divisible by 4 and,\n    # either not divisible by 100 or divisible by 400.\n    return not x and (y or not z)", "response": "Returns True if the year is leap."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gcal2jd(year, month, day):\n    year = int(year)\n    month = int(month)\n    day = int(day)\n\n    a = ipart((month - 14) / 12.0)\n    jd = ipart((1461 * (year + 4800 + a)) / 4.0)\n    jd += ipart((367 * (month - 2 - 12 * a)) / 12.0)\n    x = ipart((year + 4900 + a) / 100.0)\n    jd -= ipart((3 * x) / 4.0)\n    jd += day - 2432075.5  # was 32075; add 2400000.5\n\n    jd -= 0.5  # 0 hours; above JD is for midday, switch to midnight.\n\n    return MJD_0, jd", "response": "Returns a new base date for the given Gregorian calendar date."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef jd2gcal(jd1, jd2):\n    from math import modf\n\n    jd1_f, jd1_i = modf(jd1)\n    jd2_f, jd2_i = modf(jd2)\n\n    jd_i = jd1_i + jd2_i\n\n    f = jd1_f + jd2_f\n\n    # Set JD to noon of the current date. Fractional part is the\n    # fraction from midnight of the current date.\n    if -0.5 < f < 0.5:\n        f += 0.5\n    elif f >= 0.5:\n        jd_i += 1\n        f -= 0.5\n    elif f <= -0.5:\n        jd_i -= 1\n        f += 1.5\n\n    l = jd_i + 68569\n    n = ipart((4 * l) / 146097.0)\n    l -= ipart(((146097 * n) + 3) / 4.0)\n    i = ipart((4000 * (l + 1)) / 1461001)\n    l -= ipart((1461 * i) / 4.0) - 31\n    j = ipart((80 * l) / 2447.0)\n    day = l - ipart((2447 * j) / 80.0)\n    l = ipart(j / 11.0)\n    month = j + 2 - (12 * l)\n    year = 100 * (n - 49) + i + l\n\n    return int(year), int(month), int(day), f", "response": "Returns a new base date for the given Julian date and time of day."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef jcal2jd(year, month, day):\n    year = int(year)\n    month = int(month)\n    day = int(day)\n\n    jd = 367 * year\n    x = ipart((month - 9) / 7.0)\n    jd -= ipart((7 * (year + 5001 + x)) / 4.0)\n    jd += ipart((275 * month) / 9.0)\n    jd += day\n    jd += 1729777 - 2400000.5  # Return 240000.5 as first part of JD.\n\n    jd -= 0.5  # Convert midday to midnight.\n\n    return MJD_0, jd", "response": "Returns a new base for the given Julian calendar date."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding Args and Kwargs to", "response": "def add_args_kwargs(func):\n    \"\"\"Add Args and Kwargs\n\n    This wrapper adds support for additional arguments and keyword arguments to\n    any callable function\n\n    Parameters\n    ----------\n    func : function\n        Callable function\n\n    Returns\n    -------\n    function wrapper\n\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n\n        props = argspec(func)\n\n        # if 'args' not in props:\n        if isinstance(props[1], type(None)):\n\n            args = args[:len(props[0])]\n\n        if ((not isinstance(props[2], type(None))) or\n                (not isinstance(props[3], type(None)))):\n\n            return func(*args, **kwargs)\n\n        else:\n\n            return func(*args)\n\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_up_log(filename, verbose=True):\n\n    # Add file extension.\n    filename += '.log'\n\n    if verbose:\n        print('Preparing log file:', filename)\n\n    # Capture warnings.\n    logging.captureWarnings(True)\n\n    # Set output format.\n    formatter = logging.Formatter(fmt='%(asctime)s %(message)s',\n                                  datefmt='%d/%m/%Y %H:%M:%S')\n\n    # Create file handler.\n    fh = logging.FileHandler(filename=filename, mode='w')\n    fh.setLevel(logging.DEBUG)\n    fh.setFormatter(formatter)\n\n    # Create log.\n    log = logging.getLogger(filename)\n    log.setLevel(logging.DEBUG)\n    log.addHandler(fh)\n\n    # Send opening message.\n    log.info('The log file has been set-up.')\n\n    return log", "response": "Set up a basic log file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncloses the log file and all its handlers.", "response": "def close_log(log, verbose=True):\n    \"\"\"Close log\n\n    This method closes and active logging.Logger instance.\n\n    Parameters\n    ----------\n    log : logging.Logger\n        Logging instance\n\n    \"\"\"\n\n    if verbose:\n        print('Closing log file:', log.name)\n\n    # Send closing message.\n    log.info('The log file has been closed.')\n\n    # Remove all handlers from log.\n    [log.removeHandler(handler) for handler in log.handlers]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_observer(self, signal, observer):\n\n        self._is_allowed_signal(signal)\n        self._add_observer(signal, observer)", "response": "Add an observer to the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving an observer from the object.", "response": "def remove_observer(self, signal, observer):\n        \"\"\"Remove an observer from the object.\n\n        Raise an eception if the signal is not allowed.\n\n        Parameters\n        ----------\n        signal : str\n            a valid signal.\n        observer : @func\n            an obervation function to be removed.\n\n        \"\"\"\n\n        self._is_allowed_event(signal)\n        self._remove_observer(signal, observer)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef notify_observers(self, signal, **kwargs):\n\n        # Check if a notification if in progress\n        if self._locked:\n            return False\n        # Set the lock\n        self._locked = True\n\n        # Create a signal object\n        signal_to_be_notified = SignalObject()\n        setattr(signal_to_be_notified, \"object\", self)\n        setattr(signal_to_be_notified, \"signal\", signal)\n        for name, value in kwargs.items():\n            setattr(signal_to_be_notified, name, value)\n        # Notify all the observers\n        for observer in self._observers[signal]:\n            observer(signal_to_be_notified)\n        # Unlock the notification process\n        self._locked = False", "response": "Notify observers of a given signal."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _is_allowed_signal(self, signal):\n\n        if signal not in self._allowed_signals:\n            raise Exception(\"Signal '{0}' is not allowed for '{1}'.\".format(\n                signal, type(self)))", "response": "Check if a signal is allowed."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nassociates an observer to a valid signal.", "response": "def _add_observer(self, signal, observer):\n        \"\"\"Associate an observer to a valid signal.\n\n        Parameters\n        ----------\n        signal : str\n            a valid signal.\n        observer : @func\n            an obervation function.\n\n        \"\"\"\n\n        if observer not in self._observers[signal]:\n            self._observers[signal].append(observer)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _remove_observer(self, signal, observer):\n\n        if observer in self._observers[signal]:\n            self._observers[signal].remove(observer)", "response": "Removes an observer to a valid signal."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if the convergence criteria is matched.", "response": "def is_converge(self):\n        \"\"\"Return True if the convergence criteria is matched.\n\n        \"\"\"\n\n        if len(self.list_cv_values) < self.wind:\n            return\n        start_idx = -self.wind\n        mid_idx = -(self.wind // 2)\n        old_mean = np.array(self.list_cv_values[start_idx:mid_idx]).mean()\n        current_mean = np.array(self.list_cv_values[mid_idx:]).mean()\n        normalize_residual_metrics = (np.abs(old_mean - current_mean) /\n                                      np.abs(old_mean))\n        self.converge_flag = normalize_residual_metrics < self.eps"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef retrieve_metrics(self):\n\n        time = np.array(self.list_dates)\n        if len(time) >= 1:\n            time -= time[0]\n        return {'time': time, 'index': self.list_iters,\n                'values': self.list_cv_values}", "response": "Return the convergence metrics saved with the corresponding\n        iterations."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if the input operators have a cost method.", "response": "def _check_operators(self):\n        \"\"\"Check Operators\n\n        This method checks if the input operators have a \"cost\" method\n\n        Raises\n        ------\n        ValueError\n            For invalid operators type\n        ValueError\n            For operators without \"cost\" method\n\n        \"\"\"\n\n        if not isinstance(self._operators, (list, tuple, np.ndarray)):\n            raise TypeError(('Input operators must be provided as a list, '\n                             'not {}').format(type(self._operators)))\n\n        for op in self._operators:\n            if not hasattr(op, 'cost'):\n                raise ValueError('Operators must contain \"cost\" method.')\n            op.cost = check_callable(op.cost)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _check_cost(self):\n\n        # Add current cost value to the test list\n        self._test_list.append(self.cost)\n\n        # Check if enough cost values have been collected\n        if len(self._test_list) == self._test_range:\n\n            # The mean of the first half of the test list\n            t1 = np.mean(self._test_list[len(self._test_list) // 2:], axis=0)\n            # The mean of the second half of the test list\n            t2 = np.mean(self._test_list[:len(self._test_list) // 2], axis=0)\n            # Calculate the change across the test list\n            if not np.around(t1, decimals=16):\n                cost_diff = 0.0\n            else:\n                cost_diff = (np.linalg.norm(t1 - t2) / np.linalg.norm(t1))\n            # Reset the test list\n            self._test_list = []\n\n            if self._verbose:\n                print(' - CONVERGENCE TEST - ')\n                print(' - CHANGE IN COST:', cost_diff)\n                print('')\n\n            # Check for convergence\n            return cost_diff <= self._tolerance\n\n        else:\n\n            return False", "response": "This method tests the cost function for convergence in the specified time interval of iterations using the last n cost values in test_range."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate the cost of the input operators", "response": "def _calc_cost(self, *args, **kwargs):\n        \"\"\"Calculate the cost\n\n        This method calculates the cost from each of the input operators\n\n        Returns\n        -------\n        float cost\n\n        \"\"\"\n\n        return np.sum([op.cost(*args, **kwargs) for op in self._operators])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget cost function This method calculates the current cost and tests for convergence Returns ------- bool result of the convergence test", "response": "def get_cost(self, *args, **kwargs):\n        \"\"\"Get cost function\n\n        This method calculates the current cost and tests for convergence\n\n        Returns\n        -------\n        bool result of the convergence test\n\n        \"\"\"\n\n        # Check if the cost should be calculated\n        if self._iteration % self._cost_interval:\n\n            test_result = False\n\n        else:\n\n            if self._verbose:\n                print(' - ITERATION:', self._iteration)\n\n            # Calculate the current cost\n            self.cost = self._calc_cost(verbose=self._verbose, *args, **kwargs)\n            self._cost_list.append(self.cost)\n\n            if self._verbose:\n                print(' - COST:', self.cost)\n                print('')\n\n            # Test for convergence\n            test_result = self._check_cost()\n\n        # Update the current iteration number\n        self._iteration += 1\n\n        return test_result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_noise(data, sigma=1.0, noise_type='gauss'):\n\n    data = np.array(data)\n\n    if noise_type not in ('gauss', 'poisson'):\n        raise ValueError('Invalid noise type. Options are \"gauss\" or'\n                         '\"poisson\"')\n\n    if isinstance(sigma, (list, tuple, np.ndarray)):\n        if len(sigma) != data.shape[0]:\n            raise ValueError('Number of sigma values must match first '\n                             'dimension of input data')\n\n    if noise_type is 'gauss':\n        random = np.random.randn(*data.shape)\n\n    elif noise_type is 'poisson':\n        random = np.random.poisson(np.abs(data))\n\n    if isinstance(sigma, (int, float)):\n        return data + sigma * random\n\n    else:\n        return data + np.array([s * r for s, r in zip(sigma, random)])", "response": "r Add noise to the base of the base of the base of the base of the base of the base of the noise to the base of the base of the noise."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the gradient method that calculates the gradient step from the input data", "response": "def _get_grad_method(self, data):\n        r\"\"\"Get the gradient\n\n        This method calculates the gradient step from the input data\n\n        Parameters\n        ----------\n        data : np.ndarray\n            Input data array\n\n        Notes\n        -----\n        Implements the following equation:\n\n        .. math::\n            \\nabla F(x) = \\mathbf{H}^T(\\mathbf{H}\\mathbf{x} - \\mathbf{y})\n\n        \"\"\"\n\n        self.grad = self.trans_op(self.op(data) - self.obs_data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate the gradient component of the cost of the current state of the cluster", "response": "def _cost_method(self, *args, **kwargs):\n        \"\"\"Calculate gradient component of the cost\n\n        This method returns the l2 norm error of the difference between the\n        original data and the data obtained after optimisation\n\n        Returns\n        -------\n        float gradient cost component\n\n        \"\"\"\n\n        cost_val = 0.5 * np.linalg.norm(self.obs_data - self.op(args[0])) ** 2\n\n        if 'verbose' in kwargs and kwargs['verbose']:\n            print(' - DATA FIDELITY (X):', cost_val)\n\n        return cost_val"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _cost_method(self, *args, **kwargs):\n\n        if 'verbose' in kwargs and kwargs['verbose']:\n            print(' - Min (X):', np.min(args[0]))\n\n        return 0.0", "response": "This method calculates the positivity component of the cost."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _op_method(self, data, extra_factor=1.0):\n\n        threshold = self.weights * extra_factor\n\n        return thresh(data, threshold, self._thresh_type)", "response": "This method returns the input data thresholded by the weights"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates sparsity component of the weighted wavelet coefficients Returns ------- float sparsity component of the weighted wavelet Returns ------- float sparsity component of the cost Returns ------- float sparsity component of the cost", "response": "def _cost_method(self, *args, **kwargs):\n        \"\"\"Calculate sparsity component of the cost\n\n        This method returns the l1 norm error of the weighted wavelet\n        coefficients\n\n        Returns\n        -------\n        float sparsity cost component\n\n        \"\"\"\n\n        cost_val = np.sum(np.abs(self.weights * self._linear.op(args[0])))\n\n        if 'verbose' in kwargs and kwargs['verbose']:\n            print(' - L1 NORM (X):', cost_val)\n\n        return cost_val"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _op_method(self, data, extra_factor=1.0):\n\n        # Update threshold with extra factor.\n        threshold = self.thresh * extra_factor\n\n        if self.lowr_type == 'standard':\n            data_matrix = svd_thresh(cube2matrix(data), threshold,\n                                     thresh_type=self.thresh_type)\n\n        elif self.lowr_type == 'ngole':\n            data_matrix = svd_thresh_coef(cube2matrix(data), self.operator,\n                                          threshold,\n                                          thresh_type=self.thresh_type)\n\n        new_data = matrix2cube(data_matrix, data.shape[1:])\n\n        # Return updated data.\n        return new_data", "response": "This method returns the input data after the singular values have been added to the array."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the low - rank cost of the data in the innermost level of the cost", "response": "def _cost_method(self, *args, **kwargs):\n        \"\"\"Calculate low-rank component of the cost\n\n        This method returns the nuclear norm error of the deconvolved data in\n        matrix form\n\n        Returns\n        -------\n        float low-rank cost component\n\n        \"\"\"\n\n        cost_val = self.thresh * nuclear_norm(cube2matrix(args[0]))\n\n        if 'verbose' in kwargs and kwargs['verbose']:\n            print(' - NUCLEAR NORM (X):', cost_val)\n\n        return cost_val"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates the cost function associated to the composed function Returns ------- float the cost function associated to the composed function Returns ------- float the cost function associated to the composed function", "response": "def _cost_method(self, *args, **kwargs):\n        \"\"\"Calculate the cost function associated to the composed function\n\n        Returns\n        -------\n        float the cost of the associated composed function\n        \"\"\"\n        return self.prox_op.cost(self.linear_op.op(args[0]), **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _check_operators(self, operators):\n\n        if not isinstance(operators, (list, tuple, np.ndarray)):\n            raise TypeError('Invalid input type, operators must be a list, '\n                            'tuple or numpy array.')\n\n        operators = np.array(operators)\n\n        if not operators.size:\n            raise ValueError('Operator list is empty.')\n\n        for operator in operators:\n            if not hasattr(operator, 'op'):\n                raise ValueError('Operators must contain \"op\" method.')\n            if not hasattr(operator, 'cost'):\n                raise ValueError('Operators must contain \"cost\" method.')\n            operator.op = check_callable(operator.op)\n            operator.cost = check_callable(operator.cost)\n\n        return operators", "response": "Check that the input operators and weights are correctly formatted for the log file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates combined proximity operator components of the cost", "response": "def _cost_method(self, *args, **kwargs):\n        \"\"\"Calculate combined proximity operator components of the cost\n\n        This method returns the sum of the cost components from each of the\n        proximity operators\n\n        Returns\n        -------\n        float combinded cost components\n\n        \"\"\"\n\n        return np.sum([operator.cost(data) for operator, data in\n                       zip(self.operators, args[0])])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef min_max_normalize(img):\n\n    min_img = img.min()\n    max_img = img.max()\n\n    return (img - min_img) / (max_img - min_img)", "response": "Centre and normalize a given array."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrap to the metric", "response": "def _preprocess_input(test, ref, mask=None):\n    \"\"\"Wrapper to the metric\n\n    Parameters\n    ----------\n    ref : np.ndarray\n        the reference image\n    test : np.ndarray\n        the tested image\n    mask : np.ndarray, optional\n        the mask for the ROI\n\n    Notes\n    -----\n    Compute the metric only on magnetude.\n\n    Returns\n    -------\n    ssim: float, the snr\n\n    \"\"\"\n\n    test = np.abs(np.copy(test)).astype('float64')\n    ref = np.abs(np.copy(ref)).astype('float64')\n    test = min_max_normalize(test)\n    ref = min_max_normalize(ref)\n\n    if (not isinstance(mask, np.ndarray)) and (mask is not None):\n        raise ValueError(\"mask should be None, or a np.ndarray,\"\n                         \" got '{0}' instead.\".format(mask))\n\n    if mask is None:\n        return test, ref, None\n\n    return test, ref, mask"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsignaling - to - Noise Ratio ( SNR ) between two images.", "response": "def snr(test, ref, mask=None):\n    \"\"\"Signal-to-Noise Ratio (SNR)\n\n    Calculate the SNR between a test image and a reference image.\n\n    Parameters\n    ----------\n    ref: np.ndarray\n        the reference image\n    test: np.ndarray\n        the tested image\n    mask: np.ndarray, optional\n        the mask for the ROI\n\n    Notes\n    -----\n    Compute the metric only on magnetude.\n\n    Returns\n    -------\n    snr: float, the snr\n\n    \"\"\"\n\n    test, ref, mask = _preprocess_input(test, ref, mask)\n\n    if mask is not None:\n        test = mask * test\n\n    num = np.mean(np.square(test))\n    deno = mse(test, ref)\n\n    return 10.0 * np.log10(num / deno)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npeaking Signal - to - Noise Ratio ( PSNR ) between two images.", "response": "def psnr(test, ref, mask=None):\n    \"\"\"Peak Signal-to-Noise Ratio (PSNR)\n\n    Calculate the PSNR between a test image and a reference image.\n\n    Parameters\n    ----------\n    ref : np.ndarray\n        the reference image\n    test : np.ndarray\n        the tested image\n    mask : np.ndarray, optional\n        the mask for the ROI\n\n    Notes\n    -----\n    Compute the metric only on magnetude.\n\n    Returns\n    -------\n    psnr: float, the psnr\n\n    \"\"\"\n\n    test, ref, mask = _preprocess_input(test, ref, mask)\n\n    if mask is not None:\n        test = mask * test\n        ref = mask * ref\n\n    num = np.max(np.abs(test))\n    deno = mse(test, ref)\n\n    return 10.0 * np.log10(num / deno)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmean Squared Error MSE between two images.", "response": "def mse(test, ref, mask=None):\n    \"\"\"Mean Squared Error (MSE)\n\n    Calculate the MSE between a test image and a reference image.\n\n    Parameters\n    ----------\n    ref : np.ndarray\n        the reference image\n    test : np.ndarray\n        the tested image\n    mask : np.ndarray, optional\n        the mask for the ROI\n\n    Notes\n    -----\n    Compute the metric only on magnetude.\n\n    1/N * |ref - test|_2\n\n    Returns\n    -------\n    mse: float, the mse\n\n    \"\"\"\n\n    test, ref, mask = _preprocess_input(test, ref, mask)\n\n    if mask is not None:\n        test = mask * test\n        ref = mask * ref\n\n    return np.mean(np.square(test - ref))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef nrmse(test, ref, mask=None):\n\n    test, ref, mask = _preprocess_input(test, ref, mask)\n\n    if mask is not None:\n        test = mask * test\n        ref = mask * ref\n\n    num = np.sqrt(mse(test, ref))\n    deno = np.sqrt(np.mean((np.square(test))))\n\n    return num / deno", "response": "Compute the NRMSE of a single image in a single resource."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef warn(warn_string, log=None):\n\n    if import_fail:\n        warn_txt = 'WARNING'\n    else:\n        warn_txt = colored('WARNING', 'yellow')\n\n    # Print warning to stdout.\n    sys.stderr.write(warn_txt + ': ' + warn_string + '\\n')\n\n    # Check if a logging structure is provided.\n    if not isinstance(log, type(None)):\n        warnings.warn(warn_string)", "response": "This method creates a custom warning message."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef catch_error(exception, log=None):\n\n    if import_fail:\n        err_txt = 'ERROR'\n    else:\n        err_txt = colored('ERROR', 'red')\n\n    # Print exception to stdout.\n    stream_txt = err_txt + ': ' + str(exception) + '\\n'\n    sys.stderr.write(stream_txt)\n\n    # Check if a logging structure is provided.\n    if not isinstance(log, type(None)):\n        log_txt = 'ERROR: ' + str(exception) + '\\n'\n        log.exception(log_txt)", "response": "Catches errors and prints them to stderr if provided."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfiling name error This method checks if the input file name is valid. Parameters ---------- file_name : str File name string Raises ------ IOError If file name not specified or file not found", "response": "def file_name_error(file_name):\n    \"\"\"File name error\n\n    This method checks if the input file name is valid.\n\n    Parameters\n    ----------\n    file_name : str\n        File name string\n\n    Raises\n    ------\n    IOError\n        If file name not specified or file not found\n\n    \"\"\"\n\n    if file_name == '' or file_name[0][0] == '-':\n        raise IOError('Input file name not specified.')\n\n    elif not os.path.isfile(file_name):\n        raise IOError('Input file name [%s] not found!' % file_name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if input executable exists.", "response": "def is_executable(exe_name):\n    \"\"\"Check if Input is Executable\n\n    This methid checks if the input executable exists.\n\n    Parameters\n    ----------\n    exe_name : str\n        Executable name\n\n    Returns\n    -------\n    Bool result of test\n\n    Raises\n    ------\n    TypeError\n        For invalid input type\n\n    \"\"\"\n\n    if not isinstance(exe_name, str):\n\n        raise TypeError('Executable name must be a string.')\n\n    def is_exe(fpath):\n\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(exe_name)\n\n    if not fpath:\n\n        res = any([is_exe(os.path.join(path, exe_name)) for path in\n                   os.environ[\"PATH\"].split(os.pathsep)])\n\n    else:\n\n        res = is_exe(exe_name)\n\n    if not res:\n        raise IOError('{} does not appear to be a valid executable on this '\n                      'system.'.format(exe_name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _check_operator(self, operator):\n\n        if not isinstance(operator, type(None)):\n            tree = [obj.__name__ for obj in getmro(operator.__class__)]\n\n            if not any([parent in tree for parent in self._op_parents]):\n                warn('{0} does not inherit an operator '\n                     'parent.'.format(str(operator.__class__)))", "response": "Check if an algorithm operator is set up against the expected parent\n                     classes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nruns the algorithm in the main loop.", "response": "def _run_alg(self, max_iter):\n        \"\"\" Run Algorithm\n\n        Run the update step of a given algorithm up to the maximum number of\n        iterations.\n\n        Parameters\n        ----------\n        max_iter : int\n            Maximum number of iterations\n\n        \"\"\"\n\n        if self.progress:\n            with ProgressBar(redirect_stdout=True, max_value=max_iter) as bar:\n                self._iterations(max_iter, bar=bar)\n        else:\n            self._iterations(max_iter)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _check_restart_params(self, restart_strategy, min_beta, s_greedy,\n                              xi_restart):\n        r\"\"\" Check restarting parameters\n\n        This method checks that the restarting parameters are set and satisfy\n        the correct assumptions. It also checks that the current mode is\n        regular (as opposed to CD for now).\n\n        Parameters\n        ----------\n        restart_strategy: str or None\n            name of the restarting strategy. If None, there is no restarting.\n            Defaults to None.\n        min_beta: float or None\n            the minimum beta when using the greedy restarting strategy.\n            Defaults to None.\n        s_greedy: float or None.\n            parameter for the safeguard comparison in the greedy restarting\n            strategy. It has to be > 1.\n            Defaults to None.\n        xi_restart: float or None.\n            mutlitplicative parameter for the update of beta in the greedy\n            restarting strategy and for the update of r_lazy in the adaptive\n            restarting strategies. It has to be > 1.\n            Defaults to None.\n\n        Returns\n        -------\n        bool: True\n\n        Raises\n        ------\n        ValueError\n            When a parameter that should be set isn't or doesn't verify the\n            correct assumptions.\n        \"\"\"\n\n        if restart_strategy is None:\n            return True\n\n        if self.mode != 'regular':\n            raise ValueError('Restarting strategies can only be used with '\n                             'regular mode.')\n\n        greedy_params_check = (min_beta is None or s_greedy is None or\n                               s_greedy <= 1)\n\n        if restart_strategy == 'greedy' and greedy_params_check:\n            raise ValueError('You need a min_beta and an s_greedy > 1 for '\n                             'greedy restart.')\n\n        if xi_restart is None or xi_restart >= 1:\n            raise ValueError('You need a xi_restart < 1 for restart.')\n\n        return True", "response": "r Check restarting parameters for the current state of the current entry."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_beta(self, beta):\n\n        if self._safeguard:\n            beta *= self.xi_restart\n            beta = max(beta, self.min_beta)\n\n        return beta", "response": "r\"\"\"Update beta\n\n        This method updates beta only in the case of safeguarding (should only\n        be done in the greedy restarting strategy).\n\n        Parameters\n        ----------\n        beta: float\n            The beta parameter\n\n        Returns\n        -------\n        float: the new value for the beta parameter"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _update_param(self):\n\n        # Update the gamma parameter.\n        if not isinstance(self._beta_update, type(None)):\n            self._beta = self._beta_update(self._beta)\n\n        # Update lambda parameter.\n        if not isinstance(self._lambda_update, type(None)):\n            self._lambda = self._lambda_update(self._lambda)", "response": "r Update the parameters of the algorthm parameters with the methods provided\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef iterate(self, max_iter=150):\n\n        self._run_alg(max_iter)\n\n        # retrieve metrics results\n        self.retrieve_outputs()\n        # rename outputs as attributes\n        self.x_final = self._z_new", "response": "r This method calls retrieve_outputs and rename outputs as attributes\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the kwargs for the notify observers function.", "response": "def get_notify_observers_kwargs(self):\n        \"\"\" Return the mapping between the metrics call and the iterated\n        variables.\n\n        Return\n        ----------\n        notify_observers_kwargs: dict,\n           the mapping between the iterated variables.\n        \"\"\"\n        return {'x_new': self._linear.adj_op(self._x_new),\n                'z_new': self._z_new, 'idx': self.idx}"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef retrieve_outputs(self):\n\n        metrics = {}\n        for obs in self._observers['cv_metrics']:\n            metrics[obs.name] = obs.retrieve_metrics()\n        self.metrics = metrics", "response": "Retrieve the outputs of the algorithms as attributes x_final y_final metrics."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _set_weights(self, weights):\n\n        if isinstance(weights, type(None)):\n            weights = np.repeat(1.0 / self._prox_list.size,\n                                self._prox_list.size)\n        elif not isinstance(weights, (list, tuple, np.ndarray)):\n            raise TypeError('Weights must be provided as a list.')\n\n        weights = np.array(weights)\n\n        if not np.issubdtype(weights.dtype, np.floating):\n            raise ValueError('Weights must be list of float values.')\n\n        if weights.size != self._prox_list.size:\n            raise ValueError('The number of weights must match the number of '\n                             'proximity operators.')\n\n        if np.sum(weights) != 1.0:\n            raise ValueError('Proximity operator weights must sum to 1.0.'\n                             'Current sum of weights = ' +\n                             str(np.sum(weights)))\n\n        self._weights = weights", "response": "Set the weights of the related object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _update(self):\n\n        # Calculate gradient for current iteration.\n        self._grad.get_grad(self._x_old)\n\n        # Update z values.\n        for i in range(self._prox_list.size):\n            z_temp = (2 * self._x_old - self._z[i] - self._gamma *\n                      self._grad.grad)\n            z_prox = self._prox_list[i].op(z_temp, extra_factor=self._gamma /\n                                           self._weights[i])\n            self._z[i] += self._lambda_param * (z_prox - self._x_old)\n\n        # Update current reconstruction.\n        self._x_new = np.sum([z_i * w_i for z_i, w_i in\n                              zip(self._z, self._weights)], axis=0)\n\n        # Update old values for next iteration.\n        np.copyto(self._x_old, self._x_new)\n\n        # Update parameter values for next iteration.\n        self._update_param()\n\n        # Test cost function for convergence.\n        if self._cost_func:\n            self.converge = self._cost_func.get_cost(self._x_new)", "response": "r Updates the current reconstruction and the parameter values for the next iteration."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iterate(self, max_iter=150):\n        self._run_alg(max_iter)\n\n        # retrieve metrics results\n        self.retrieve_outputs()\n\n        self.x_final = self._x_new", "response": "r This method calls update until convergence criteria is met or the maximum number of iterations is reached."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the kwargs for the notify observers function.", "response": "def get_notify_observers_kwargs(self):\n        \"\"\" Return the mapping between the metrics call and the iterated\n        variables.\n\n        Return\n        ----------\n        notify_observers_kwargs: dict,\n           the mapping between the iterated variables.\n        \"\"\"\n        return {'x_new': self._linear.adj_op(self._x_new),\n                'z_new': self._z, 'idx': self.idx}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _update_param(self):\n\n        # Update relaxation parameter.\n        if not isinstance(self._rho_update, type(None)):\n            self._rho = self._rho_update(self._rho)\n\n        # Update proximal dual parameter.\n        if not isinstance(self._sigma_update, type(None)):\n            self._sigma = self._sigma_update(self._sigma)\n\n        # Update proximal primal parameter.\n        if not isinstance(self._tau_update, type(None)):\n            self._tau = self._tau_update(self._tau)", "response": "r Updates the values of the algorthm parameters with the methods provided\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _update(self):\n        # Step 1 from eq.9.\n        self._grad.get_grad(self._x_old)\n\n        x_prox = self._prox.op(self._x_old - self._tau * self._grad.grad -\n                               self._tau * self._linear.adj_op(self._y_old))\n\n        # Step 2 from eq.9.\n        y_temp = (self._y_old + self._sigma *\n                  self._linear.op(2 * x_prox - self._x_old))\n\n        y_prox = (y_temp - self._sigma * self._prox_dual.op(y_temp /\n                  self._sigma, extra_factor=(1.0 / self._sigma)))\n\n        # Step 3 from eq.9.\n        self._x_new = self._rho * x_prox + (1 - self._rho) * self._x_old\n        self._y_new = self._rho * y_prox + (1 - self._rho) * self._y_old\n\n        del x_prox, y_prox, y_temp\n\n        # Update old values for next iteration.\n        np.copyto(self._x_old, self._x_new)\n        np.copyto(self._y_old, self._y_new)\n\n        # Update parameter values for next iteration.\n        self._update_param()\n\n        # Test cost function for convergence.\n        if self._cost_func:\n            self.converge = self.any_convergence_flag() or\\\n                            self._cost_func.get_cost(self._x_new, self._y_new)", "response": "r Updates the current reconstruction of the current logarithmic state."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef iterate(self, max_iter=150, n_rewightings=1):\n\n        self._run_alg(max_iter)\n\n        if not isinstance(self._reweight, type(None)):\n            for k in range(n_rewightings):\n                self._reweight.reweight(self._linear.op(self._x_new))\n                self._run_alg(max_iter)\n\n        # retrieve metrics results\n        self.retrieve_outputs()\n        # rename outputs as attributes\n        self.x_final = self._x_new\n        self.y_final = self._y_new", "response": "r This method calls update until convergence criteria is met or the maximum number of iterations is reached."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _update(self):\n        # Step 4 from alg. 3\n        self._grad.get_grad(self._x_old)\n        self._u_new = self._x_old - self._beta * self._grad.grad\n\n        # Step 5 from alg. 3\n        self._t_new = 0.5 * (1 + np.sqrt(1 + 4 * self._t_old**2))\n\n        # Step 6 from alg. 3\n        t_shifted_ratio = (self._t_old - 1) / self._t_new\n        sigma_t_ratio = self._sigma * self._t_old / self._t_new\n        beta_xi_t_shifted_ratio = t_shifted_ratio * self._beta / self._xi\n        self._z = - beta_xi_t_shifted_ratio * (self._x_old - self._z)\n        self._z += self._u_new\n        self._z += t_shifted_ratio * (self._u_new - self._u_old)\n        self._z += sigma_t_ratio * (self._u_new - self._x_old)\n\n        # Step 7 from alg. 3\n        self._xi = self._beta * (1 + t_shifted_ratio + sigma_t_ratio)\n\n        # Step 8 from alg. 3\n        self._x_new = self._prox.op(self._z, extra_factor=self._xi)\n\n        # Restarting and gamma-Decreasing\n        # Step 9 from alg. 3\n        self._g_new = self._grad.grad - (self._x_new - self._z) / self._xi\n\n        # Step 10 from alg 3.\n        self._y_new = self._x_old - self._beta * self._g_new\n\n        # Step 11 from alg. 3\n        restart_crit = np.vdot(- self._g_new, self._y_new - self._y_old) < 0\n        if restart_crit:\n            self._t_new = 1\n            self._sigma = 1\n\n        # Step 13 from alg. 3\n        elif np.vdot(self._g_new, self._g_old) < 0:\n            self._sigma *= self._sigma_bar\n\n        # updating variables\n        self._t_old = self._t_new\n        np.copyto(self._u_old, self._u_new)\n        np.copyto(self._x_old, self._x_new)\n        np.copyto(self._g_old, self._g_new)\n        np.copyto(self._y_old, self._y_new)\n\n        # Test cost function for convergence.\n        if self._cost_func:\n            self.converge = self.any_convergence_flag() or \\\n                            self._cost_func.get_cost(self._x_new)", "response": "r Updates the current reconstruction of the current logarithmic state of the current logarithmic state."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the kwargs for the notify observers method.", "response": "def get_notify_observers_kwargs(self):\n        \"\"\" Return the mapping between the metrics call and the iterated\n        variables.\n\n        Return\n        ----------\n        notify_observers_kwargs: dict,\n           the mapping between the iterated variables.\n        \"\"\"\n        return {\n            'u_new': self._u_new,\n            'x_new': self._x_new,\n            'y_new': self._y_new,\n            'z_new': self._z,\n            'xi': self._xi,\n            'sigma': self._sigma,\n            't': self._t_new,\n            'idx': self.idx,\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef call_mr_transform(data, opt='', path='./',\n                      remove_files=True):  # pragma: no cover\n    r\"\"\"Call mr_transform\n\n    This method calls the iSAP module mr_transform\n\n    Parameters\n    ----------\n    data : np.ndarray\n        Input data, 2D array\n    opt : list or str, optional\n        Options to be passed to mr_transform\n    path : str, optional\n        Path for output files (default is './')\n    remove_files : bool, optional\n        Option to remove output files (default is 'True')\n\n    Returns\n    -------\n    np.ndarray results of mr_transform\n\n    Raises\n    ------\n    ValueError\n        If the input data is not a 2D numpy array\n\n    Examples\n    --------\n    >>> from modopt.signal.wavelet import *\n    >>> a = np.arange(9).reshape(3, 3).astype(float)\n    >>> call_mr_transform(a)\n    array([[[-1.5       , -1.125     , -0.75      ],\n            [-0.375     ,  0.        ,  0.375     ],\n            [ 0.75      ,  1.125     ,  1.5       ]],\n\n           [[-1.5625    , -1.171875  , -0.78125   ],\n            [-0.390625  ,  0.        ,  0.390625  ],\n            [ 0.78125   ,  1.171875  ,  1.5625    ]],\n\n           [[-0.5859375 , -0.43945312, -0.29296875],\n            [-0.14648438,  0.        ,  0.14648438],\n            [ 0.29296875,  0.43945312,  0.5859375 ]],\n\n           [[ 3.6484375 ,  3.73632812,  3.82421875],\n            [ 3.91210938,  4.        ,  4.08789062],\n            [ 4.17578125,  4.26367188,  4.3515625 ]]], dtype=float32)\n\n    \"\"\"\n\n    if not import_astropy:\n        raise ImportError('Astropy package not found.')\n\n    if (not isinstance(data, np.ndarray)) or (data.ndim != 2):\n        raise ValueError('Input data must be a 2D numpy array.')\n\n    executable = 'mr_transform'\n\n    # Make sure mr_transform is installed.\n    is_executable(executable)\n\n    # Create a unique string using the current date and time.\n    unique_string = datetime.now().strftime('%Y.%m.%d_%H.%M.%S')\n\n    # Set the ouput file names.\n    file_name = path + 'mr_temp_' + unique_string\n    file_fits = file_name + '.fits'\n    file_mr = file_name + '.mr'\n\n    # Write the input data to a fits file.\n    fits.writeto(file_fits, data)\n\n    if isinstance(opt, str):\n        opt = opt.split()\n\n    # Call mr_transform.\n    try:\n\n        check_call([executable] + opt + [file_fits, file_mr])\n\n    except Exception:\n\n        warn('{} failed to run with the options provided.'.format(executable))\n        remove(file_fits)\n\n    else:\n\n        # Retrieve wavelet transformed data.\n        result = fits.getdata(file_mr)\n\n        # Remove the temporary files.\n        if remove_files:\n            remove(file_fits)\n            remove(file_mr)\n\n        # Return the mr_transform results.\n        return result", "response": "This method calls the iSAP module mr_transform\n    and returns the result of mr_transform\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_mr_filters(data_shape, opt='', coarse=False):  # pragma: no cover\n\n    # Adjust the shape of the input data.\n    data_shape = np.array(data_shape)\n    data_shape += data_shape % 2 - 1\n\n    # Create fake data.\n    fake_data = np.zeros(data_shape)\n    fake_data[tuple(zip(data_shape // 2))] = 1\n\n    # Call mr_transform.\n    mr_filters = call_mr_transform(fake_data, opt=opt)\n\n    # Return filters\n    if coarse:\n        return mr_filters\n    else:\n        return mr_filters[:-1]", "response": "Get the wavelet filters by calling mr_transform\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef filter_convolve(data, filters, filter_rot=False, method='scipy'):\n\n    if filter_rot:\n        return np.sum([convolve(coef, f, method=method) for coef, f in\n                       zip(data, rotate_stack(filters))], axis=0)\n\n    else:\n        return np.array([convolve(data, f, method=method) for f in filters])", "response": "This method convolves the input image with the wavelet filters and returns the resulting array."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfiltering convolves the input data with the wavelet filters and returns the convolved data cube.", "response": "def filter_convolve_stack(data, filters, filter_rot=False, method='scipy'):\n    r\"\"\"Filter convolve\n\n    This method convolves the a stack of input images with the wavelet filters\n\n    Parameters\n    ----------\n    data : np.ndarray\n        Input data, 3D array\n    filters : np.ndarray\n        Wavelet filters, 3D array\n    filter_rot : bool, optional\n        Option to rotate wavelet filters (default is 'False')\n    method : str {'astropy', 'scipy'}, optional\n        Convolution method (default is 'scipy')\n\n    Returns\n    -------\n    np.ndarray convolved data\n\n    Examples\n    --------\n    >>> from modopt.signal.wavelet import filter_convolve_stack\n    >>> x = np.arange(9).reshape(3, 3).astype(float)\n    >>> filter_convolve(x, x)\n    array([[[   4.,    1.,    4.],\n            [  13.,   10.,   13.],\n            [  22.,   19.,   22.]],\n\n           [[  13.,   10.,   13.],\n            [  49.,   46.,   49.],\n            [  85.,   82.,   85.]],\n\n           [[  22.,   19.,   22.],\n            [  85.,   82.,   85.],\n            [ 148.,  145.,  148.]]])\n\n    \"\"\"\n\n    # Return the convolved data cube.\n    return np.array([filter_convolve(x, filters, filter_rot=filter_rot,\n                    method=method) for x in data])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef gram_schmidt(matrix, return_opt='orthonormal'):\n\n    if return_opt not in ('orthonormal', 'orthogonal', 'both'):\n        raise ValueError('Invalid return_opt, options are: \"orthonormal\", '\n                         '\"orthogonal\" or \"both\"')\n\n    u = []\n    e = []\n\n    for vector in matrix:\n\n        if len(u) == 0:\n            u_now = vector\n        else:\n            u_now = vector - sum([project(u_i, vector) for u_i in u])\n\n        u.append(u_now)\n        e.append(u_now / np.linalg.norm(u_now, 2))\n\n    u = np.array(u)\n    e = np.array(e)\n\n    if return_opt == 'orthonormal':\n        return e\n    elif return_opt == 'orthogonal':\n        return u\n    elif return_opt == 'both':\n        return u, e", "response": "r Gram - Schmit\n    This method orthonormalizes the row vectors of the input matrix."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nproject vector u onto vector v.", "response": "def project(u, v):\n    r\"\"\"Project vector\n\n    This method projects vector v onto vector u.\n\n    Parameters\n    ----------\n    u : np.ndarray\n        Input vector\n    v : np.ndarray\n        Input vector\n\n    Returns\n    -------\n    np.ndarray projection\n\n    Examples\n    --------\n    >>> from modopt.math.matrix import project\n    >>> a = np.arange(3)\n    >>> b = a + 3\n    >>> project(a, b)\n    array([ 0. ,  2.8,  5.6])\n\n    Notes\n    -----\n    Implements the following equation:\n\n    .. math::\n        \\textrm{proj}_\\mathbf{u}(\\mathbf{v}) = \\frac{\\langle\\mathbf{u},\n        \\mathbf{v}\\rangle}{\\langle\\mathbf{u}, \\mathbf{u}\\rangle}\\mathbf{u}\n\n    (see https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process)\n\n    \"\"\"\n\n    return np.inner(v, u) / np.inner(u, u) * u"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rotate(matrix, angle):\n\n    shape = np.array(matrix.shape)\n\n    if shape[0] != shape[1]:\n        raise ValueError('Input matrix must be square.')\n\n    shift = (shape - 1) // 2\n\n    index = np.array(list(product(*np.array([np.arange(val) for val in\n                     shape])))) - shift\n\n    new_index = np.array(np.dot(index, rot_matrix(angle)), dtype='int') + shift\n    new_index[new_index >= shape[0]] -= shape[0]\n\n    return matrix[tuple(zip(new_index.T))].reshape(shape.T)", "response": "r Rotate an input matrix about the input angle."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _set_initial_x(self):\n\n        return np.random.random(self._data_shape).astype(self._data_type)", "response": "Set initial value of x"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting spectral radius This method calculates the spectral radius Parameters ---------- tolerance : float, optional Tolerance threshold for convergence (default is \"1e-6\") max_iter : int, optional Maximum number of iterations (default is 20) extra_factor : float, optional Extra multiplicative factor for calculating the spectral radius (default is 1.0)", "response": "def get_spec_rad(self, tolerance=1e-6, max_iter=20, extra_factor=1.0):\n        \"\"\"Get spectral radius\n\n        This method calculates the spectral radius\n\n        Parameters\n        ----------\n        tolerance : float, optional\n            Tolerance threshold for convergence (default is \"1e-6\")\n        max_iter : int, optional\n            Maximum number of iterations (default is 20)\n        extra_factor : float, optional\n            Extra multiplicative factor for calculating the spectral radius\n            (default is 1.0)\n\n        \"\"\"\n\n        # Set (or reset) values of x.\n        x_old = self._set_initial_x()\n\n        # Iterate until the L2 norm of x converges.\n        for i in range(max_iter):\n\n            x_old_norm = np.linalg.norm(x_old)\n\n            x_new = self._operator(x_old) / x_old_norm\n\n            x_new_norm = np.linalg.norm(x_new)\n\n            if(np.abs(x_new_norm - x_old_norm) < tolerance):\n                if self._verbose:\n                    print(' - Power Method converged after %d iterations!' %\n                          (i + 1))\n                break\n\n            elif i == max_iter - 1 and self._verbose:\n                print(' - Power Method did not converge after %d '\n                      'iterations!' % max_iter)\n\n            np.copyto(x_old, x_new)\n\n        self.spec_rad = x_new_norm * extra_factor\n        self.inv_spec_rad = 1.0 / self.spec_rad"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _check_type(self, input_val):\n\n        if not isinstance(input_val, (list, tuple, np.ndarray)):\n            raise TypeError('Invalid input type, input must be a list, tuple '\n                            'or numpy array.')\n\n        input_val = np.array(input_val)\n\n        if not input_val.size:\n            raise ValueError('Input list is empty.')\n\n        return input_val", "response": "Checks if the input is a list tuple or numpy array and converts the input to a numpy array."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _check_inputs(self, operators, weights):\n\n        operators = self._check_type(operators)\n\n        for operator in operators:\n            if not hasattr(operator, 'op'):\n                raise ValueError('Operators must contain \"op\" method.')\n            if not hasattr(operator, 'adj_op'):\n                raise ValueError('Operators must contain \"adj_op\" method.')\n            operator.op = check_callable(operator.op)\n            operator.cost = check_callable(operator.adj_op)\n\n        if not isinstance(weights, type(None)):\n\n            weights = self._check_type(weights)\n\n            if weights.size != operators.size:\n                raise ValueError('The number of weights must match the '\n                                 'number of operators.')\n\n            if not np.issubdtype(weights.dtype, np.floating):\n                raise TypeError('The weights must be a list of float values.')\n\n        return operators, weights", "response": "Check the input operators and weights for correctness."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _op_method(self, data):\n\n        res = np.empty(len(self.operators), dtype=np.ndarray)\n\n        for i in range(len(self.operators)):\n            res[i] = self.operators[i].op(data)\n\n        return res", "response": "This method operates on all of the operators and returns the input data operated on by all of the operators."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds the minimum number of principal components required by testing the auto correlation of the left singular vector of the original data.", "response": "def find_n_pc(u, factor=0.5):\n    \"\"\"Find number of principal components\n\n    This method finds the minimum number of principal components required\n\n    Parameters\n    ----------\n    u : np.ndarray\n        Left singular vector of the original data\n    factor : float, optional\n        Factor for testing the auto correlation (default is '0.5')\n\n    Returns\n    -------\n    int number of principal components\n\n    Examples\n    --------\n    >>> from scipy.linalg import svd\n    >>> from modopt.signal.svd import find_n_pc\n    >>> x = np.arange(18).reshape(9, 2).astype(float)\n    >>> find_n_pc(svd(x)[0])\n    array([3])\n\n    \"\"\"\n\n    if np.sqrt(u.shape[0]) % 1:\n        raise ValueError('Invalid left singular value. The size of the first '\n                         'dimenion of u must be perfect square.')\n\n    # Get the shape of the array\n    array_shape = np.repeat(np.int(np.sqrt(u.shape[0])), 2)\n\n    # Find the auto correlation of the left singular vector.\n    u_auto = [convolve(a.reshape(array_shape),\n              np.rot90(a.reshape(array_shape), 2)) for a in u.T]\n\n    # Return the required number of principal components.\n    return np.sum([(a[tuple(zip(array_shape // 2))] ** 2 <= factor *\n                   np.sum(a ** 2)) for a in u_auto])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the Singular Value Decomposition of the input data using SciPy s svd function.", "response": "def calculate_svd(data):\n    \"\"\"Calculate Singular Value Decomposition\n\n    This method calculates the Singular Value Decomposition (SVD) of the input\n    data using SciPy.\n\n    Parameters\n    ----------\n    data : np.ndarray\n        Input data array, 2D matrix\n\n    Returns\n    -------\n    tuple of left singular vector, singular values and right singular vector\n\n    Raises\n    ------\n    TypeError\n        For invalid data type\n\n    \"\"\"\n\n    if (not isinstance(data, np.ndarray)) or (data.ndim != 2):\n        raise TypeError('Input data must be a 2D np.ndarray.')\n\n    return svd(data, check_finite=False, lapack_driver='gesvd',\n               full_matrices=False)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef svd_thresh(data, threshold=None, n_pc=None, thresh_type='hard'):\n\n    if ((not isinstance(n_pc, (int, str, type(None)))) or\n            (isinstance(n_pc, int) and n_pc <= 0) or\n            (isinstance(n_pc, str) and n_pc != 'all')):\n        raise ValueError('Invalid value for \"n_pc\", specify a positive '\n                         'integer value or \"all\"')\n\n    # Get SVD of input data.\n    u, s, v = calculate_svd(data)\n\n    # Find the threshold if not provided.\n    if isinstance(threshold, type(None)):\n\n        # Find the required number of principal components if not specified.\n        if isinstance(n_pc, type(None)):\n            n_pc = find_n_pc(u, factor=0.1)\n\n        # If the number of PCs is too large use all of the singular values.\n        if ((isinstance(n_pc, int) and n_pc >= s.size) or\n                (isinstance(n_pc, str) and n_pc == 'all')):\n            n_pc = s.size\n            warn('Using all singular values.')\n\n        threshold = s[n_pc - 1]\n\n    # Threshold the singular values.\n    s_new = thresh(s, threshold, thresh_type)\n\n    if np.all(s_new == s):\n        warn('No change to singular values.')\n\n    # Diagonalize the svd\n    s_new = np.diag(s_new)\n\n    # Return the thresholded data.\n    return np.dot(u, np.dot(s_new, v))", "response": "r Thresholds the input data using singular value decomposition"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef svd_thresh_coef(data, operator, threshold, thresh_type='hard'):\n\n    if not callable(operator):\n        raise TypeError('Operator must be a callable function.')\n\n    # Get SVD of data matrix\n    u, s, v = calculate_svd(data)\n\n    # Diagnalise s\n    s = np.diag(s)\n\n    # Compute coefficients\n    a = np.dot(s, v)\n\n    # Get the shape of the array\n    array_shape = np.repeat(np.int(np.sqrt(u.shape[0])), 2)\n\n    # Compute threshold matrix.\n    ti = np.array([np.linalg.norm(x) for x in\n                   operator(matrix2cube(u, array_shape))])\n    threshold *= np.repeat(ti, a.shape[1]).reshape(a.shape)\n\n    # Threshold coefficients.\n    a_new = thresh(a, threshold, thresh_type)\n\n    # Return the thresholded image.\n    return np.dot(u, a_new)", "response": "This method thresholds the singular values coefficients of the input data using the singular value decomposition of the data matrix."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mad(data):\n\n    return np.median(np.abs(data - np.median(data)))", "response": "r Median absolute deviation of the input data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncubing to Map This method transforms the input data from a 3D cube to a 2D map with a specified layout.", "response": "def cube2map(data_cube, layout):\n    r\"\"\"Cube to Map\n\n    This method transforms the input data from a 3D cube to a 2D map with a\n    specified layout\n\n    Parameters\n    ----------\n    data_cube : np.ndarray\n        Input data cube, 3D array of 2D images\n    Layout : tuple\n        2D layout of 2D images\n\n    Returns\n    -------\n    np.ndarray 2D map\n\n    Raises\n    ------\n    ValueError\n        For invalid data dimensions\n    ValueError\n        For invalid layout\n\n    Examples\n    --------\n    >>> from modopt.base.transform import cube2map\n    >>> a = np.arange(16).reshape((4, 2, 2))\n    >>> cube2map(a, (2, 2))\n    array([[ 0,  1,  4,  5],\n           [ 2,  3,  6,  7],\n           [ 8,  9, 12, 13],\n           [10, 11, 14, 15]])\n\n    \"\"\"\n\n    if data_cube.ndim != 3:\n        raise ValueError('The input data must have 3 dimensions.')\n\n    if data_cube.shape[0] != np.prod(layout):\n        raise ValueError('The desired layout must match the number of input '\n                         'data layers.')\n\n    return np.vstack([np.hstack(data_cube[slice(layout[1] * i, layout[1] *\n                      (i + 1))]) for i in range(layout[0])])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef map2matrix(data_map, layout):\n\n    layout = np.array(layout)\n\n    # Select n objects\n    n_obj = np.prod(layout)\n\n    # Get the shape of the images\n    image_shape = (np.array(data_map.shape) // layout)[0]\n\n    # Stack objects from map\n    data_matrix = []\n\n    for i in range(n_obj):\n        lower = (image_shape * (i // layout[1]),\n                 image_shape * (i % layout[1]))\n        upper = (image_shape * (i // layout[1] + 1),\n                 image_shape * (i % layout[1] + 1))\n        data_matrix.append((data_map[lower[0]:upper[0],\n                            lower[1]:upper[1]]).reshape(image_shape ** 2))\n\n    return np.array(data_matrix).T", "response": "Map to Matrix\n    This method transforms a 2D map to a 2D matrix\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cube2matrix(data_cube):\n\n    return data_cube.reshape([data_cube.shape[0]] +\n                             [np.prod(data_cube.shape[1:])]).T", "response": "Cube to Matrix\n    This method transforms a 3D cube to a 2D matrix\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nplots the final cost function of the current iteration", "response": "def plotCost(cost_list, output=None):\n    \"\"\"Plot cost function\n\n    Plot the final cost function\n\n    Parameters\n    ----------\n    cost_list : list\n        List of cost function values\n    output : str, optional\n        Output file name\n\n    \"\"\"\n\n    if not import_fail:\n\n        if isinstance(output, type(None)):\n            file_name = 'cost_function.png'\n        else:\n            file_name = output + '_cost_function.png'\n\n        plt.figure()\n        plt.plot(np.log10(cost_list), 'r-')\n        plt.title('Cost Function')\n        plt.xlabel('Iteration')\n        plt.ylabel(r'$\\log_{10}$ Cost')\n        plt.savefig(file_name)\n        plt.close()\n\n        print(' - Saving cost function data to:', file_name)\n\n    else:\n\n        warn('Matplotlib not installed.')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mex_hat(x, sigma):\n\n    x = check_float(x)\n    sigma = check_float(sigma)\n\n    xs = (x / sigma) ** 2\n    val = 2 * (3 * sigma) ** -0.5 * np.pi ** -0.25\n\n    return val * (1 - xs) * np.exp(-0.5 * xs)", "response": "r Mexican hat filter"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convolve(data, kernel, method='scipy'):\n\n    if data.ndim != kernel.ndim:\n        raise ValueError('Data and kernel must have the same dimensions.')\n\n    if method not in ('astropy', 'scipy'):\n        raise ValueError('Invalid method. Options are \"astropy\" or \"scipy\".')\n\n    if not import_astropy:  # pragma: no cover\n        method = 'scipy'\n\n    if method == 'astropy':\n        return convolve_fft(data, kernel, boundary='wrap', crop=False,\n                            nan_treatment='fill', normalize_kernel=False)\n\n    elif method == 'scipy':\n        return scipy.signal.fftconvolve(data, kernel, mode='same')", "response": "r Convolves data with kernel using FFT"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_float(val):\n\n    if not isinstance(val, (int, float, list, tuple, np.ndarray)):\n        raise TypeError('Invalid input type.')\n    if isinstance(val, int):\n        val = float(val)\n    elif isinstance(val, (list, tuple)):\n        val = np.array(val, dtype=float)\n    elif isinstance(val, np.ndarray) and (not np.issubdtype(val.dtype,\n                                                            np.floating)):\n        val = val.astype(float)\n\n    return val", "response": "r Check if input value is a float or np. ndarray of floats if not\n    convert."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_int(val):\n\n    if not isinstance(val, (int, float, list, tuple, np.ndarray)):\n        raise TypeError('Invalid input type.')\n    if isinstance(val, float):\n        val = int(val)\n    elif isinstance(val, (list, tuple)):\n        val = np.array(val, dtype=int)\n    elif isinstance(val, np.ndarray) and (not np.issubdtype(val.dtype,\n                                                            np.integer)):\n        val = val.astype(int)\n\n    return val", "response": "r Check if input value is an int or a np. ndarray of ints."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_npndarray(val, dtype=None, writeable=True, verbose=True):\n\n    if not isinstance(val, np.ndarray):\n        raise TypeError('Input is not a numpy array.')\n\n    if ((not isinstance(dtype, type(None))) and\n            (not np.issubdtype(val.dtype, dtype))):\n        raise TypeError('The numpy array elements are not of type: {}'\n                        ''.format(dtype))\n\n    if not writeable and verbose and val.flags.writeable:\n        warn('Making input data immutable.')\n\n    val.flags.writeable = writeable", "response": "Checks if input object is a numpy array."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef positive(data):\n\n    if not isinstance(data, (int, float, list, tuple, np.ndarray)):\n        raise TypeError('Invalid data type, input must be `int`, `float`, '\n                        '`list`, `tuple` or `np.ndarray`.')\n\n    def pos_thresh(data):\n\n        return data * (data > 0)\n\n    def pos_recursive(data):\n\n        data = np.array(data)\n\n        if not data.dtype == 'O':\n\n            result = list(pos_thresh(data))\n\n        else:\n\n            result = [pos_recursive(x) for x in data]\n\n        return result\n\n    if isinstance(data, (int, float)):\n\n        return pos_thresh(data)\n\n    else:\n\n        return np.array(pos_recursive(data))", "response": "r Positivity operator for the modopt. signal. positive module."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pad2d(data, padding):\n\n    data = np.array(data)\n\n    if isinstance(padding, int):\n        padding = np.array([padding])\n    elif isinstance(padding, (tuple, list)):\n        padding = np.array(padding)\n    elif isinstance(padding, np.ndarray):\n        pass\n    else:\n        raise ValueError('Padding must be an integer or a tuple (or list, '\n                         'np.ndarray) of itegers')\n\n    if padding.size == 1:\n        padding = np.repeat(padding, 2)\n\n    return np.pad(data, ((padding[0], padding[0]), (padding[1], padding[1])),\n                  'constant')", "response": "Pad array to be at least 2D."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fancy_transpose(data, roll=1):\n\n    axis_roll = np.roll(np.arange(data.ndim), roll)\n\n    return np.transpose(data, axes=axis_roll)", "response": "Fancy transpose a multidimensional matrix."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute a total score for each model over all the tests.", "response": "def mean(self):\n        \"\"\"Compute a total score for each model over all the tests.\n\n        Uses the `norm_score` attribute, since otherwise direct comparison\n        across different kinds of scores would not be possible.\n        \"\"\"\n\n        return np.dot(np.array(self.norm_scores), self.weights)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef T(self):\n        return ScoreMatrix(self.tests, self.models, scores=self.values,\n                           weights=self.weights, transpose=True)", "response": "Get transpose of this ScoreMatrix."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_html(self, show_mean=None, sortable=None, colorize=True, *args,\n                **kwargs):\n        \"\"\"Extend Pandas built in `to_html` method for rendering a DataFrame\n        and use it to render a ScoreMatrix.\"\"\"\n        if show_mean is None:\n            show_mean = self.show_mean\n        if sortable is None:\n            sortable = self.sortable\n        df = self.copy()\n        if show_mean:\n            df.insert(0, 'Mean', None)\n            df.loc[:, 'Mean'] = ['%.3f' % self[m].mean() for m in self.models]\n        html = df.to_html(*args, **kwargs)  # Pandas method\n        html, table_id = self.annotate(df, html, show_mean, colorize)\n        if sortable:\n            self.dynamify(table_id)\n        return html", "response": "Extend Pandas built in to_html method for rendering a DataFrame\n            and use it to render a ScoreMatrix."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\napplying function to n levels of the tree tree.", "response": "def rec_apply(func, n):\n    \"\"\"\n    Used to determine parent directory n levels up\n    by repeatedly applying os.path.dirname\n    \"\"\"\n    if n > 1:\n        rec_func = rec_apply(func, n - 1)\n        return lambda x: func(rec_func(x))\n    return func"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprint if PRINT_DEBUG_STATE is True", "response": "def printd(*args, **kwargs):\n    \"\"\"Print if PRINT_DEBUG_STATE is True\"\"\"\n\n    global settings\n    if settings['PRINT_DEBUG_STATE']:\n        print(*args, **kwargs)\n        return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntest for dimensionlessness of input.", "response": "def assert_dimensionless(value):\n    \"\"\"\n    Tests for dimensionlessness of input.\n    If input is dimensionless but expressed as a Quantity, it returns the\n    bare value.  If it not, it raised an error.\n    \"\"\"\n\n    if isinstance(value, Quantity):\n        value = value.simplified\n        if value.dimensionality == Dimensionality({}):\n            value = value.base.item()\n        else:\n            raise TypeError(\"Score value %s must be dimensionless\" % value)\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef import_all_modules(package, skip=None, verbose=False, prefix=\"\", depth=0):\n\n    skip = [] if skip is None else skip\n\n    for ff, modname, ispkg in pkgutil.walk_packages(path=package.__path__,\n                                                prefix=prefix,\n                                                onerror=lambda x: None):\n        if ff.path not in package.__path__[0]: # Solves weird bug\n            continue\n        if verbose:\n            print('\\t'*depth,modname)\n        if modname in skip:\n            if verbose:\n                print('\\t'*depth,'*Skipping*')\n            continue\n        module = '%s.%s' % (package.__name__,modname)\n        subpackage = importlib.import_module(module)\n        if ispkg:\n            import_all_modules(subpackage, skip=skip,\n                               verbose=verbose,depth=depth+1)", "response": "Recursively imports all modules and submodules of a\n    given package."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef method_cache(by='value',method='run'):\n\n    def decorate_(func):\n        def decorate(*args, **kwargs):\n            model = args[0] # Assumed to be self.\n            assert hasattr(model,method), \"Model must have a '%s' method.\"%method\n            if func.__name__ == method: # Run itself.\n                method_args = kwargs\n            else: # Any other method.\n                method_args = kwargs[method] if method in kwargs else {}\n            if not hasattr(model.__class__,'cached_runs'): # If there is no run cache.\n                model.__class__.cached_runs = {} # Create the method cache.\n            cache = model.__class__.cached_runs\n            if by == 'value':\n                model_dict = {key:value for key,value in list(model.__dict__.items()) \\\n                              if key[0]!='_'}\n                method_signature = SciUnit.dict_hash({'attrs':model_dict,'args':method_args}) # Hash key.\n            elif by == 'instance':\n                method_signature = SciUnit.dict_hash({'id':id(model),'args':method_args}) # Hash key.\n            else:\n                raise ValueError(\"Cache type must be 'value' or 'instance'\")\n            if method_signature not in cache:\n                print(\"Method with this signature not found in the cache. Running...\")\n                f = getattr(model,method)\n                f(**method_args)\n                cache[method_signature] = (datetime.now(),model.__dict__.copy())\n            else:\n                print(\"Method with this signature found in the cache. Restoring...\")\n                _,attrs = cache[method_signature]\n                model.__dict__.update(attrs)\n            return func(*args, **kwargs)\n        return decorate\n    return decorate_", "response": "A decorator that creates a method cache for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck to see if an extended path is given and convert appropriately", "response": "def convert_path(cls, file):\n        \"\"\"\n        Check to see if an extended path is given and convert appropriately\n        \"\"\"\n\n        if isinstance(file,str):\n            return file\n        elif isinstance(file, list) and all([isinstance(x, str) for x in file]):\n            return \"/\".join(file)\n        else:\n            print(\"Incorrect path specified\")\n            return -1"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the full path of the notebook found in the directory specified by self. path.", "response": "def get_path(self, file):\n        \"\"\"Get the full path of the notebook found in the directory\n        specified by self.path.\n        \"\"\"\n\n        class_path = inspect.getfile(self.__class__)\n        parent_path = os.path.dirname(class_path)\n        path = os.path.join(parent_path,self.path,file)\n        return os.path.realpath(path)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fix_display(self):\n\n        try:\n            tkinter.Tk()\n        except (tkinter.TclError, NameError): # If there is no display.\n            try:\n                import matplotlib as mpl\n            except ImportError:\n                pass\n            else:\n                print(\"Setting matplotlib backend to Agg\")\n                mpl.use('Agg')", "response": "Fixes the display backend to Agg if needed."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads a notebook file into memory.", "response": "def load_notebook(self, name):\n        \"\"\"Loads a notebook file into memory.\"\"\"\n\n        with open(self.get_path('%s.ipynb'%name)) as f:\n            nb = nbformat.read(f, as_version=4)\n        return nb,f"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run_notebook(self, nb, f):\n\n        if PYTHON_MAJOR_VERSION == 3:\n            kernel_name = 'python3'\n        elif PYTHON_MAJOR_VERSION == 2:\n            kernel_name = 'python2'\n        else:\n            raise Exception('Only Python 2 and 3 are supported')\n        ep = ExecutePreprocessor(timeout=600, kernel_name=kernel_name)\n        try:\n            ep.preprocess(nb, {'metadata': {'path': '.'}})\n        except CellExecutionError:\n            msg = 'Error executing the notebook \"%s\".\\n\\n' % f.name\n            msg += 'See notebook \"%s\" for the traceback.' % f.name\n            print(msg)\n            raise\n        finally:\n            nbformat.write(nb, f)", "response": "Runs a loaded notebook file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef execute_notebook(self, name):\n\n        warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n        nb,f = self.load_notebook(name)\n        self.run_notebook(nb,f)\n        self.assertTrue(True)", "response": "Loads and runs a notebook file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a notebook into a python file.", "response": "def convert_notebook(self, name):\n        \"\"\"Converts a notebook into a python file.\"\"\"\n\n        #subprocess.call([\"jupyter\",\"nbconvert\",\"--to\",\"python\",\n        #                self.get_path(\"%s.ipynb\"%name)])\n        exporter = nbconvert.exporters.python.PythonExporter()\n        relative_path = self.convert_path(name)\n        file_path = self.get_path(\"%s.ipynb\"%relative_path)\n        code = exporter.from_filename(file_path)[0]\n        self.write_code(name, code)\n        self.clean_code(name, [])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef convert_and_execute_notebook(self, name):\n\n        self.convert_notebook(name)\n        code = self.read_code(name)#clean_code(name,'get_ipython')\n        exec(code,globals())", "response": "Converts a notebook into a python file and then runs it."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn full path to generated files. Creates a new directory if needed.", "response": "def gen_file_path(self, name):\n        \"\"\"\n        Returns full path to generated files.  Checks to see if directory\n        exists where generated files are stored and creates one otherwise.\n        \"\"\"\n        relative_path = self.convert_path(name)\n        file_path = self.get_path(\"%s.ipynb\"%relative_path)\n        parent_path =  rec_apply(os.path.dirname, self.gen_file_level)(file_path)\n        gen_file_name = name if isinstance(name,str) else name[1] #Name of generated file\n        gen_dir_path = self.get_path(os.path.join(parent_path, self.gen_dir_name))\n        if not os.path.exists(gen_dir_path): # Create folder for generated files if needed\n            os.makedirs(gen_dir_path)\n        new_file_path = self.get_path('%s.py'%os.path.join(gen_dir_path, gen_file_name))\n        return new_file_path"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads code from a python file called name", "response": "def read_code(self, name):\n        \"\"\"Reads code from a python file called 'name'\"\"\"\n\n        file_path = self.gen_file_path(name)\n        with open(file_path) as f:\n            code = f.read()\n        return code"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_code(self, name, code):\n        file_path = self.gen_file_path(name)\n        with open(file_path,'w') as f:\n            f.write(code)", "response": "Writes code to a python file called name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clean_code(self, name, forbidden):\n\n        code = self.read_code(name)\n        code = code.split('\\n')\n        new_code = []\n        for line in code:\n            if [bad for bad in forbidden if bad in line]:\n                pass\n            else:\n                allowed = ['time','timeit'] # Magics where we want to keep the command\n                line = self.strip_line_magic(line, allowed)\n                if isinstance(line,list):\n                    line = ' '.join(line)\n                new_code.append(line)\n        new_code = '\\n'.join(new_code)\n        self.write_code(name, new_code)\n        return new_code", "response": "Remove lines containing items in forbidden from the code."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef strip_line_magic(cls, line, magics_allowed):\n        if PYTHON_MAJOR_VERSION == 2: # Python 2\n            stripped,magic_kind = cls.strip_line_magic_v2(line)\n        else: # Python 3+\n            stripped,magic_kind = cls.strip_line_magic_v3(line)\n        if line == stripped:\n            printd(\"No line magic pattern match in '%s'\" % line)\n        if magic_kind and magic_kind not in magics_allowed:\n            stripped = \"\" # If the part after the magic won't work,\n                          # just get rid of it\n        return stripped", "response": "Handles lines that contain get_ipython. run_line_magic"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns a notebook file after optionally converting it to a python file.", "response": "def do_notebook(self, name):\n        \"\"\"Run a notebook file after optionally\n        converting it to a python file.\"\"\"\n        CONVERT_NOTEBOOKS = int(os.getenv('CONVERT_NOTEBOOKS', True))\n        s = StringIO()\n        if mock:\n            out = unittest.mock.patch('sys.stdout', new=MockDevice(s))\n            err = unittest.mock.patch('sys.stderr', new=MockDevice(s))\n            self._do_notebook(name, CONVERT_NOTEBOOKS)\n            out.close()\n            err.close()\n        else:\n            self._do_notebook(name, CONVERT_NOTEBOOKS)\n        self.assertTrue(True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _do_notebook(self, name, convert_notebooks=False):\n        if convert_notebooks:\n            self.convert_and_execute_notebook(name)\n        else:\n            self.execute_notebook(name)", "response": "Called by do_notebook to actually run the notebook."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_capabilities(cls):\n        capabilities = []\n        for _cls in cls.mro():\n            if issubclass(_cls, Capability) and _cls is not Capability \\\n              and not issubclass(_cls, Model):\n                capabilities.append(_cls)\n        return capabilities", "response": "List the model s capabilities."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck to see if the instance passes its extra_capability_checks.", "response": "def failed_extra_capabilities(self):\n        \"\"\"Check to see if instance passes its `extra_capability_checks`.\"\"\"\n        failed = []\n        for capability, f_name in self.extra_capability_checks.items():\n            f = getattr(self, f_name)\n            instance_capable = f()\n            if not instance_capable:\n                failed.append(capability)\n        return failed"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_match(self, match):\n        result = False\n        if self == match:\n            result = True\n        elif isinstance(match, str) and fnmatchcase(self.name, match):\n            result = True  # Found by instance or name\n        return result", "response": "Return whether this model is the same as or has the same name as match."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlaunch the main routine.", "response": "def main(*args):\n    \"\"\"Launch the main routine.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"action\",\n                        help=\"create, check, run, make-nb, or run-nb\")\n    parser.add_argument(\"--directory\", \"-dir\", default=os.getcwd(),\n                        help=\"path to directory with a .sciunit file\")\n    parser.add_argument(\"--stop\", \"-s\", default=True,\n                        help=\"stop and raise errors, halting the program\")\n    parser.add_argument(\"--tests\", \"-t\", default=False,\n                        help=\"runs tests instead of suites\")\n    if args:\n        args = parser.parse_args(args)\n    else:\n        args = parser.parse_args()\n    file_path = os.path.join(args.directory, '.sciunit')\n    config = None\n    if args.action == 'create':\n        create(file_path)\n    elif args.action == 'check':\n        config = parse(file_path, show=True)\n        print(\"\\nNo configuration errors reported.\")\n    elif args.action == 'run':\n        config = parse(file_path)\n        run(config, path=args.directory,\n            stop_on_error=args.stop, just_tests=args.tests)\n    elif args.action == 'make-nb':\n        config = parse(file_path)\n        make_nb(config, path=args.directory,\n                stop_on_error=args.stop, just_tests=args.tests)\n    elif args.action == 'run-nb':\n        config = parse(file_path)\n        run_nb(config, path=args.directory)\n    else:\n        raise NameError('No such action %s' % args.action)\n    if config:\n        cleanup(config, path=args.directory)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create(file_path):\n    if os.path.exists(file_path):\n        raise IOError(\"There is already a configuration file at %s\" %\n                      file_path)\n    with open(file_path, 'w') as f:\n        config = configparser.ConfigParser()\n        config.add_section('misc')\n        config.set('misc', 'config-version', '1.0')\n        default_nb_name = os.path.split(os.path.dirname(file_path))[1]\n        config.set('misc', 'nb-name', default_nb_name)\n        config.add_section('root')\n        config.set('root', 'path', '.')\n        config.add_section('models')\n        config.set('models', 'module', 'models')\n        config.add_section('tests')\n        config.set('tests', 'module', 'tests')\n        config.add_section('suites')\n        config.set('suites', 'module', 'suites')\n        config.write(f)", "response": "Create a default. sciunit config file if one does not already exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses a. sciunit config file.", "response": "def parse(file_path=None, show=False):\n    \"\"\"Parse a .sciunit config file.\"\"\"\n    if file_path is None:\n        file_path = os.path.join(os.getcwd(), '.sciunit')\n    if not os.path.exists(file_path):\n        raise IOError('No .sciunit file was found at %s' % file_path)\n\n    # Load the configuration file\n    config = configparser.RawConfigParser(allow_no_value=True)\n    config.read(file_path)\n\n    # List all contents\n    for section in config.sections():\n        if show:\n            print(section)\n        for options in config.options(section):\n            if show:\n                print(\"\\t%s: %s\" % (options, config.get(section, options)))\n    return config"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprepare to read the configuration information.", "response": "def prep(config=None, path=None):\n    \"\"\"Prepare to read the configuration information.\"\"\"\n    if config is None:\n        config = parse()\n    if path is None:\n        path = os.getcwd()\n    root = config.get('root', 'path')\n    root = os.path.join(path, root)\n    root = os.path.realpath(root)\n    os.environ['SCIDASH_HOME'] = root\n    if sys.path[0] != root:\n        sys.path.insert(0, root)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(config, path=None, stop_on_error=True, just_tests=False):\n    if path is None:\n        path = os.getcwd()\n    prep(config, path=path)\n\n    models = __import__('models')\n    tests = __import__('tests')\n    suites = __import__('suites')\n\n    print('\\n')\n    for x in ['models', 'tests', 'suites']:\n        module = __import__(x)\n        assert hasattr(module, x), \"'%s' module requires attribute '%s'\" %\\\n                                   (x, x)\n\n    if just_tests:\n        for test in tests.tests:\n            _run(test, models, stop_on_error)\n\n    else:\n        for suite in suites.suites:\n            _run(suite, models, stop_on_error)", "response": "Run sciunit tests for the given configuration."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a notebook name from a path to a notebook", "response": "def nb_name_from_path(config, path):\n    \"\"\"Get a notebook name from a path to a notebook\"\"\"\n    if path is None:\n        path = os.getcwd()\n    root = config.get('root', 'path')\n    root = os.path.join(path, root)\n    root = os.path.realpath(root)\n    default_nb_name = os.path.split(os.path.realpath(root))[1]\n    nb_name = config.get('misc', 'nb-name', fallback=default_nb_name)\n    return root, nb_name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_nb(config, path=None, stop_on_error=True, just_tests=False):\n    root, nb_name = nb_name_from_path(config, path)\n    clean = lambda varStr: re.sub('\\W|^(?=\\d)', '_', varStr)\n    name = clean(nb_name)\n\n    mpl_style = config.get('misc', 'matplotlib', fallback='inline')\n    cells = [new_markdown_cell('## Sciunit Testing Notebook for %s' % nb_name)]\n    add_code_cell(cells, (\n        \"%%matplotlib %s\\n\"\n        \"from IPython.display import display\\n\"\n        \"from importlib.machinery import SourceFileLoader\\n\"\n        \"%s = SourceFileLoader('scidash', '%s/__init__.py').load_module()\") %\n        (mpl_style, name, root))\n    if just_tests:\n        add_code_cell(cells, (\n            \"for test in %s.tests.tests:\\n\"\n            \"  score_array = test.judge(%s.models.models, stop_on_error=%r)\\n\"\n            \"  display(score_array)\") % (name, name, stop_on_error))\n    else:\n        add_code_cell(cells, (\n            \"for suite in %s.suites.suites:\\n\"\n            \"  score_matrix = suite.judge(\"\n            \"%s.models.models, stop_on_error=%r)\\n\"\n            \"  display(score_matrix)\") % (name, name, stop_on_error))\n    write_nb(root, nb_name, cells)", "response": "Create a Jupyter notebook with the given configuration."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite a jupyter notebook to disk.", "response": "def write_nb(root, nb_name, cells):\n    \"\"\"Write a jupyter notebook to disk.\n\n    Takes a given a root directory, a notebook name, and a list of cells.\n    \"\"\"\n    nb = new_notebook(cells=cells,\n                      metadata={\n                        'language': 'python',\n                        })\n    nb_path = os.path.join(root, '%s.ipynb' % nb_name)\n    with codecs.open(nb_path, encoding='utf-8', mode='w') as nb_file:\n        nbformat.write(nb, nb_file, NB_VERSION)\n    print(\"Created Jupyter notebook at:\\n%s\" % nb_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run_nb(config, path=None):\n    if path is None:\n        path = os.getcwd()\n    root = config.get('root', 'path')\n    root = os.path.join(path, root)\n    nb_name = config.get('misc', 'nb-name')\n    nb_path = os.path.join(root, '%s.ipynb' % nb_name)\n    if not os.path.exists(nb_path):\n        print((\"No notebook found at %s. \"\n               \"Create the notebook first with make-nb?\") % path)\n        sys.exit(0)\n\n    with codecs.open(nb_path, encoding='utf-8', mode='r') as nb_file:\n        nb = nbformat.read(nb_file, as_version=NB_VERSION)\n    ep = ExecutePreprocessor(timeout=600)\n    ep.preprocess(nb, {'metadata': {'path': root}})\n    with codecs.open(nb_path, encoding='utf-8', mode='w') as nb_file:\n        nbformat.write(nb, nb_file, NB_VERSION)", "response": "Runs a notebook file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_code_cell(cells, source):\n    from nbformat.v4.nbbase import new_code_cell\n    n_code_cells = len([c for c in cells if c['cell_type'] == 'code'])\n    cells.append(new_code_cell(source=source, execution_count=n_code_cells+1))", "response": "Add a code cell containing source to the notebook."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cleanup(config=None, path=None):\n    if config is None:\n        config = parse()\n    if path is None:\n        path = os.getcwd()\n    root = config.get('root', 'path')\n    root = os.path.join(path, root)\n    if sys.path[0] == root:\n        sys.path.remove(root)", "response": "Cleanup by removing paths added during earlier in configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_repo(self, cached=True):\n        module = sys.modules[self.__module__]\n        # We use module.__file__ instead of module.__path__[0]\n        # to include modules without a __path__ attribute.\n        if hasattr(self.__class__, '_repo') and cached:\n            repo = self.__class__._repo\n        elif hasattr(module, '__file__'):\n            path = os.path.realpath(module.__file__)\n            try:\n                repo = git.Repo(path, search_parent_directories=True)\n            except InvalidGitRepositoryError:\n                repo = None\n        else:\n            repo = None\n        self.__class__._repo = repo\n        return repo", "response": "Get a git repository object for this instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a git version for this instance.", "response": "def get_version(self, cached=True):\n        \"\"\"Get a git version (i.e. a git commit hash) for this instance.\"\"\"\n        if hasattr(self.__class__, '_version') and cached:\n            version = self.__class__._version\n        else:\n            repo = self.get_repo()\n            if repo is not None:\n                head = repo.head\n                version = head.commit.hexsha\n                if repo.is_dirty():\n                    version += \"*\"\n            else:\n                version = None\n        self.__class__._version = version\n        return version"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a git remote object for this instance.", "response": "def get_remote(self, remote='origin'):\n        \"\"\"Get a git remote object for this instance.\"\"\"\n        repo = self.get_repo()\n        if repo is not None:\n            remotes = {r.name: r for r in repo.remotes}\n            r = repo.remotes[0] if remote not in remotes else remotes[remote]\n        else:\n            r = None\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a git remote URL for this instance.", "response": "def get_remote_url(self, remote='origin', cached=True):\n        \"\"\"Get a git remote URL for this instance.\"\"\"\n        if hasattr(self.__class__, '_remote_url') and cached:\n            url = self.__class__._remote_url\n        else:\n            r = self.get_remote(remote)\n            try:\n                url = list(r.urls)[0]\n            except GitCommandError as ex:\n                if 'correct access rights' in str(ex):\n                    # If ssh is not setup to access this repository\n                    cmd = ['git', 'config', '--get', 'remote.%s.url' % r.name]\n                    url = Git().execute(cmd)\n                else:\n                    raise ex\n            except AttributeError:\n                url = None\n            if url is not None and url.startswith('git@'):\n                domain = url.split('@')[1].split(':')[0]\n                path = url.split(':')[1]\n                url = \"http://%s/%s\" % (domain, path)\n        self.__class__._remote_url = url\n        return url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering name as a type to validate as an instance of class cls.", "response": "def register_type(cls, name):\n    \"\"\"Register `name` as a type to validate as an instance of class `cls`.\"\"\"\n    x = TypeDefinition(name, (cls,), ())\n    Validator.types_mapping[name] = x"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_quantity(quantity, name):\n    x = TypeDefinition(name, (quantity.__class__,), ())\n    Validator.types_mapping[name] = x", "response": "Register name as a type to validate as an instance of class cls."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _validate_iterable(self, is_iterable, key, value):\n        if is_iterable:\n            try:\n                iter(value)\n            except TypeError:\n                self._error(key, \"Must be iterable (e.g. a list or array)\")", "response": "Validate that the value is iterable."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates that the fields with units key in schema set to True.", "response": "def _validate_units(self, has_units, key, value):\n        \"\"\"Validate fields with `units` key in schema set to True.\n\n        The rule's arguments are validated against this schema:\n        {'type': 'boolean'}\n        \"\"\"\n        if has_units:\n            if isinstance(self.test.units, dict):\n                required_units = self.test.units[key]\n            else:\n                required_units = self.test.units\n            if not isinstance(value, pq.quantity.Quantity):\n                self._error(key, \"Must be a python quantity\")\n            if not isinstance(value, pq.quantity.Quantity):\n                self._error(key, \"Must be a python quantity\")\n            provided_units = value.simplified.units\n            if not isinstance(required_units, pq.Dimensionless):\n                required_units = required_units.simplified.units\n            if not required_units == provided_units:\n                self._error(key,\n                            \"Must have units of '%s'\" % self.test.units.name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef validate_quantity(self, value):\n        if not isinstance(value, pq.quantity.Quantity):\n            self._error('%s' % value, \"Must be a Python quantity.\")", "response": "Validate that the value is of the Quantity type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nvalidating units, assuming that it was called by _validate_type_*.", "response": "def validate_units(self, value):\n        \"\"\"Validate units, assuming that it was called by _validate_type_*.\"\"\"\n        self.validate_quantity(value)\n        self.units_type = inspect.stack()[1][3].split('_')[-1]\n        assert self.units_type, (\"`validate_units` should not be called \"\n                                 \"directly. It should be called by a \"\n                                 \"_validate_type_* methods that sets \"\n                                 \"`units_type`\")\n        units = getattr(pq, self.units_map[self.units_type])\n        if not value.simplified.units == units:\n            self._error('%s' % value,\n                        \"Must have dimensions of %s.\" % self.units_type)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute a z - score from an observation and a prediction.", "response": "def compute(cls, observation, prediction):\n        \"\"\"Compute a z-score from an observation and a prediction.\"\"\"\n        assert isinstance(observation, dict)\n        try:\n            p_value = prediction['mean']  # Use the prediction's mean.\n        except (TypeError, KeyError, IndexError):  # If there isn't one...\n            try:\n                p_value = prediction['value']  # Use the prediction's value.\n            except (TypeError, IndexError):  # If there isn't one...\n                p_value = prediction  # Use the prediction (assume numeric).\n        o_mean = observation['mean']\n        o_std = observation['std']\n        value = (p_value - o_mean)/o_std\n        value = utils.assert_dimensionless(value)\n        if np.isnan(value):\n            score = InsufficientDataScore('One of the input values was NaN')\n        else:\n            score = ZScore(value)\n        return score"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef norm_score(self):\n        cdf = (1.0 + math.erf(self.score / math.sqrt(2.0))) / 2.0\n        return 1 - 2*math.fabs(0.5 - cdf)", "response": "Return the normalized score."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef compute(cls, observation, prediction):\n        assert isinstance(observation, dict)\n        assert isinstance(prediction, dict)\n        p_mean = prediction['mean']  # Use the prediction's mean.\n        p_std = prediction['std']\n        o_mean = observation['mean']\n        o_std = observation['std']\n        try:  # Try to pool taking samples sizes into account.\n            p_n = prediction['n']\n            o_n = observation['n']\n            s = (((p_n-1)*(p_std**2) + (o_n-1)*(o_std**2))/(p_n+o_n-2))**0.5\n        except KeyError:  # If sample sizes are not available.\n            s = (p_std**2 + o_std**2)**0.5\n        value = (p_mean - o_mean)/s\n        value = utils.assert_dimensionless(value)\n        return CohenDScore(value)", "response": "Compute a Cohen s D from an observation and a prediction."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing a ratio from an observation and a prediction.", "response": "def compute(cls, observation, prediction, key=None):\n        \"\"\"Compute a ratio from an observation and a prediction.\"\"\"\n        assert isinstance(observation, (dict, float, int, pq.Quantity))\n        assert isinstance(prediction, (dict, float, int, pq.Quantity))\n\n        obs, pred = cls.extract_means_or_values(observation, prediction,\n                                                key=key)\n        value = pred / obs\n        value = utils.assert_dimensionless(value)\n        return RatioScore(value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing sum - squared diff between observation and prediction.", "response": "def compute_ssd(cls, observation, prediction):\n        \"\"\"Compute sum-squared diff between observation and prediction.\"\"\"\n        # The sum of the squared differences.\n        value = ((observation - prediction)**2).sum()\n        score = FloatScore(value)\n        return score"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse requirements from requirements. txt", "response": "def read_requirements():\n    '''parses requirements from requirements.txt'''\n    reqs_path = os.path.join('.', 'requirements.txt')\n    install_reqs = parse_requirements(reqs_path, session=PipSession())\n    reqs = [str(ir.req) for ir in install_reqs]\n    return reqs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering backends for use with models.", "response": "def register_backends(vars):\n    \"\"\"Register backends for use with models.\n\n    `vars` should be a dictionary of variables obtained from e.g. `locals()`,\n    at least some of which are Backend classes, e.g. from imports.\n    \"\"\"\n    new_backends = {x.replace('Backend', ''): cls\n                    for x, cls in vars.items()\n                    if inspect.isclass(cls) and issubclass(cls, Backend)}\n    available_backends.update(new_backends)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init_disk_cache(self):\n        try:\n            # Cleanup old disk cache files\n            path = self.disk_cache_location\n            os.remove(path)\n        except Exception:\n            pass\n        self.disk_cache_location = os.path.join(tempfile.mkdtemp(), 'cache')", "response": "Initialize the on - disk version of the cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns result in memory cache for key or None.", "response": "def get_memory_cache(self, key=None):\n        \"\"\"Return result in memory cache for key 'key' or None if not found.\"\"\"\n        key = self.model.hash if key is None else key\n        self._results = self.memory_cache.get(key)\n        return self._results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn result in disk cache for key or None.", "response": "def get_disk_cache(self, key=None):\n        \"\"\"Return result in disk cache for key 'key' or None if not found.\"\"\"\n        key = self.model.hash if key is None else key\n        if not getattr(self, 'disk_cache_location', False):\n            self.init_disk_cache()\n        disk_cache = shelve.open(self.disk_cache_location)\n        self._results = disk_cache.get(key)\n        disk_cache.close()\n        return self._results"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_memory_cache(self, results, key=None):\n        key = self.model.hash if key is None else key\n        self.memory_cache[key] = results", "response": "Store result in memory cache with key matching model state."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstore result in disk cache with key matching model state.", "response": "def set_disk_cache(self, results, key=None):\n        \"\"\"Store result in disk cache with key matching model state.\"\"\"\n        if not getattr(self, 'disk_cache_location', False):\n            self.init_disk_cache()\n        disk_cache = shelve.open(self.disk_cache_location)\n        key = self.model.hash if key is None else key\n        disk_cache[key] = results\n        disk_cache.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef backend_run(self):\n        key = self.model.hash\n        if self.use_memory_cache and self.get_memory_cache(key):\n            return self._results\n        if self.use_disk_cache and self.get_disk_cache(key):\n            return self._results\n        results = self._backend_run()\n        if self.use_memory_cache:\n            self.set_memory_cache(results, key)\n        if self.use_disk_cache:\n            self.set_disk_cache(results, key)\n        return results", "response": "Check for cached results ; then run the model if needed."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsaving results on disk.", "response": "def save_results(self, path='.'):\n        \"\"\"Save results on disk.\"\"\"\n        with open(path, 'wb') as f:\n            pickle.dump(self.results, f)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck whether the provided model has this capability.", "response": "def check(cls, model, require_extra=False):\n        \"\"\"Check whether the provided model has this capability.\n\n        By default, uses isinstance.  If `require_extra`, also requires that an\n        instance check be present in `model.extra_capability_checks`.\n        \"\"\"\n        class_capable = isinstance(model, cls)\n\n        f_name = model.extra_capability_checks.get(cls, None) \\\n            if model.extra_capability_checks is not None \\\n            else False\n\n        if f_name:\n            f = getattr(model, f_name)\n            instance_capable = f()\n        elif not require_extra:\n            instance_capable = True\n        else:\n            instance_capable = False\n        return class_capable and instance_capable"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the simulation backend.", "response": "def set_backend(self, backend):\n        \"\"\"Set the simulation backend.\"\"\"\n        if isinstance(backend, str):\n            name = backend\n            args = []\n            kwargs = {}\n        elif isinstance(backend, (tuple, list)):\n            name = ''\n            args = []\n            kwargs = {}\n            for i in range(len(backend)):\n                if i == 0:\n                    name = backend[i]\n                else:\n                    if isinstance(backend[i], dict):\n                        kwargs.update(backend[i])\n                    else:\n                        args += backend[i]\n        else:\n            raise TypeError(\"Backend must be string, tuple, or list\")\n        if name in available_backends:\n            self.backend = name\n            self._backend = available_backends[name]()\n        elif name is None:\n            # The base class should not be called.\n            raise Exception((\"A backend (e.g. 'jNeuroML' or 'NEURON') \"\n                             \"must be selected\"))\n        else:\n            raise Exception(\"Backend %s not found in backends.py\"\n                            % name)\n        self._backend.model = self\n        self._backend.init_backend(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nruns the simulation (or lookup the results in the cache).", "response": "def run(self, **run_params):\n        \"\"\"Run the simulation (or lookup the results in the cache).\"\"\"\n        self.use_default_run_params()\n        self.set_run_params(**run_params)\n        if self.print_run_params:\n            print(\"Run Params:\", self.run_params)\n        self.results = self._backend.backend_run()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_attrs(self, **attrs):\n        self.attrs.update(attrs)\n        self._backend.set_attrs(**attrs)", "response": "Set model attributes e. g. input resistance of a cell."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_run_params(self, **run_params):\n        self.run_params.update(run_params)\n        self.check_run_params()\n        self._backend.set_run_params(**run_params)", "response": "Set run - time parameters e. g. the somatic current to inject."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nturn the score intp an RGB color tuple of three 8 - bit integers.", "response": "def color(self, value=None):\n        \"\"\"Turn the score intp an RGB color tuple of three 8-bit integers.\"\"\"\n        if value is None:\n            value = self.norm_score\n        rgb = Score.value_color(value)\n        return rgb"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract the mean value or user - provided key from the observation and prediction dictionaries.", "response": "def extract_means_or_values(cls, observation, prediction, key=None):\n        \"\"\"Extracts the mean, value, or user-provided key from the observation\n        and prediction dictionaries.\n        \"\"\"\n\n        obs_mv = cls.extract_mean_or_value(observation, key)\n        pred_mv = cls.extract_mean_or_value(prediction, key)\n        return obs_mv, pred_mv"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef extract_mean_or_value(cls, obs_or_pred, key=None):\n\n        result = None\n        if not isinstance(obs_or_pred, dict):\n            result = obs_or_pred\n        else:\n            keys = ([key] if key is not None else []) + ['mean', 'value']\n            for k in keys:\n                if k in obs_or_pred:\n                    result = obs_or_pred[k]\n                    break\n            if result is None:\n                raise KeyError((\"%s has neither a mean nor a single \"\n                                \"value\" % obs_or_pred))\n        return result", "response": "Extracts the mean value or user - provided key from an observation or prediction dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsummarizes the performance of a model on a test.", "response": "def summary(self):\n        \"\"\"Summarize the performance of a model on a test.\"\"\"\n        return \"== Model %s did not complete test %s due to error '%s'. ==\" %\\\n               (str(self.model), str(self.test), str(self.score))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load(self, draw_bbox = False, **kwargs):\n        ''' Makes the canvas.\n            This could be far speedier if it copied raw pixels, but that would\n            take far too much time to write vs using Image inbuilts '''\n        im = Image.new('RGBA', self.img_size)\n        draw = None\n        if draw_bbox:\n            draw = ImageDraw.Draw(im)\n\n        for sprite in self.images:\n            data = sprite.load()\n            sprite_im = Image.open(BytesIO(data))\n\n            size = sprite.imgrect\n            im.paste(sprite_im, (size[0], size[2]))\n            if draw_bbox:\n                draw.rectangle((size[0], size[2], size[1], size[3]), outline='red')\n\n        del draw\n        b = BytesIO()\n        im.save(b, format = 'PNG')\n        return b.getvalue()", "response": "Makes the canvas.\n            This could be far speedier if it copied raw pixels vs using Image inbuilts"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef extract(self, progress = True, recurse = True, tex_only = False,\n            extract_manifest = False, path = None, **kwargs):\n        if path is None:\n            path = self.folder_out\n        if tex_only:\n            kwargs['use_cache'] = False\n        utils.mkdir_silent(path)\n        utime(path, (self.time, self.time))\n\n        if extract_manifest and self.manifest and not tex_only:\n            with open(join(path, 'ifs_manifest.xml'), 'wb') as f:\n                f.write(self.manifest.to_text().encode('utf8'))\n\n        # build the tree\n        for folder in self.tree.all_folders:\n            if tex_only and folder.name == 'tex':\n                self.tree = folder\n                # make it root to discourage repacking\n                folder.name = ''\n                for f in folder.all_files:\n                    f.path = ''\n                break\n            elif tex_only:\n                continue\n            f_path = join(path, folder.full_path)\n            utils.mkdir_silent(f_path)\n            utime(f_path, (self.time, self.time))\n\n        # extract the files\n        for f in tqdm(self.tree.all_files, disable = not progress):\n            # allow recurse + tex_only to extract ifs files\n            if tex_only and not isinstance(f, ImageFile) and not isinstance(f, ImageCanvas) and not (recurse and f.name.endswith('.ifs')):\n                continue\n            f.extract(path, **kwargs)\n            if progress:\n                tqdm.write(f.full_path)\n            if recurse and f.name.endswith('.ifs'):\n                rpath = join(path, f.full_path)\n                i = IFS(rpath)\n                i.extract(progress=progress, recurse=recurse, tex_only=tex_only,\n                    extract_manifest=extract_manifest, path=rpath.replace('.ifs','_ifs'), **kwargs)\n\n\n        # you can't pickle open files, so this won't work. Perhaps there is a way around it?\n        '''to_extract = (f for f in self.tree.all_files if not(tex_only and not isinstance(f, ImageFile) and not isinstance(f, ImageCanvas)))\n\n        p = Pool()\n        args = zip(to_extract, itertools.cycle((path,)), itertools.cycle((kwargs,)))\n\n        to_recurse = []\n        for f in tqdm(p.imap_unordered(_extract, args)):\n            if progress:\n                tqdm.write(f)\n            if recurse and f.name.endswith('.ifs'):\n                to_recurse.append(join(path, f.full_path))\n\n        for rpath in recurse:\n            i = IFS(rpath)\n            i.extract(progress=progress, recurse=recurse, tex_only=tex_only,\n                extract_manifest=extract_manifest, path=rpath.replace('.ifs','_ifs'), **kwargs)'''", "response": "Extract the contents of the tree and the files in the folder."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind the longest match for the string starting at offset in the preceeding data Taxonomy", "response": "def match_window(in_data, offset):\n    '''Find the longest match for the string starting at offset in the preceeding data\n    '''\n    window_start = max(offset - WINDOW_MASK, 0)\n\n    for n in range(MAX_LEN, THRESHOLD-1, -1):\n        window_end = min(offset + n, len(in_data))\n        # we've not got enough data left for a meaningful result\n        if window_end - offset < THRESHOLD:\n            return None\n        str_to_find = in_data[offset:window_end]\n        idx = in_data.rfind(str_to_find, window_start, window_end-n)\n        if idx != -1:\n            code_offset = offset - idx # - 1\n            code_len = len(str_to_find)\n            return (code_offset, code_len)\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmerges options with their corresponding arguments.", "response": "def _merge_args_opts(args_opts_dict, **kwargs):\n    \"\"\"Merge options with their corresponding arguments.\n\n    Iterates over the dictionary holding arguments (keys) and options (values). Merges each\n    options string with its corresponding argument.\n\n    :param dict args_opts_dict: a dictionary of arguments and options\n    :param dict kwargs: *input_option* - if specified prepends ``-i`` to input argument\n    :return: merged list of strings with arguments and their corresponding options\n    :rtype: list\n    \"\"\"\n    merged = []\n\n    if not args_opts_dict:\n        return merged\n\n    for arg, opt in args_opts_dict.items():\n        if not _is_sequence(opt):\n            opt = shlex.split(opt or '')\n        merged += opt\n\n        if not arg:\n            continue\n\n        if 'add_input_option' in kwargs:\n            merged.append('-i')\n\n        merged.append(arg)\n\n    return merged"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexecute the command line and return the output of the process.", "response": "def run(self, input_data=None, stdout=None, stderr=None):\n        \"\"\"Execute FFmpeg command line.\n\n        ``input_data`` can contain input for FFmpeg in case ``pipe`` protocol is used for input.\n        ``stdout`` and ``stderr`` specify where to redirect the ``stdout`` and ``stderr`` of the\n        process. By default no redirection is done, which means all output goes to running shell\n        (this mode should normally only be used for debugging purposes). If FFmpeg ``pipe`` protocol\n        is used for output, ``stdout`` must be redirected to a pipe by passing `subprocess.PIPE` as\n        ``stdout`` argument.\n\n        Returns a 2-tuple containing ``stdout`` and ``stderr`` of the process. If there was no\n        redirection or if the output was redirected to e.g. `os.devnull`, the value returned will\n        be a tuple of two `None` values, otherwise it will contain the actual ``stdout`` and\n        ``stderr`` data returned by ffmpeg process.\n\n        More info about ``pipe`` protocol `here <https://ffmpeg.org/ffmpeg-protocols.html#pipe>`_.\n\n        :param str input_data: input data for FFmpeg to deal with (audio, video etc.) as bytes (e.g.\n            the result of reading a file in binary mode)\n        :param stdout: redirect FFmpeg ``stdout`` there (default is `None` which means no\n            redirection)\n        :param stderr: redirect FFmpeg ``stderr`` there (default is `None` which means no\n            redirection)\n        :return: a 2-tuple containing ``stdout`` and ``stderr`` of the process\n        :rtype: tuple\n        :raise: `FFRuntimeError` in case FFmpeg command exits with a non-zero code;\n            `FFExecutableNotFoundError` in case the executable path passed was not valid\n        \"\"\"\n        try:\n            self.process = subprocess.Popen(\n                self._cmd,\n                stdin=subprocess.PIPE,\n                stdout=stdout,\n                stderr=stderr\n            )\n        except OSError as e:\n            if e.errno == errno.ENOENT:\n                raise FFExecutableNotFoundError(\"Executable '{0}' not found\".format(self.executable))\n            else:\n                raise\n\n        out = self.process.communicate(input=input_data)\n        if self.process.returncode != 0:\n            raise FFRuntimeError(self.cmd, self.process.returncode, out[0], out[1])\n\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nformatting the description for a given click. Command.", "response": "def _format_description(ctx):\n    \"\"\"Format the description for a given `click.Command`.\n\n    We parse this as reStructuredText, allowing users to embed rich\n    information in their help messages if they so choose.\n    \"\"\"\n    help_string = ctx.command.help or ctx.command.short_help\n    if not help_string:\n        return\n\n    bar_enabled = False\n    for line in statemachine.string2lines(\n            help_string, tab_width=4, convert_whitespace=True):\n        if line == '\\b':\n            bar_enabled = True\n            continue\n        if line == '':\n            bar_enabled = False\n        line = '| ' + line if bar_enabled else line\n        yield line\n    yield ''"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nformatting the output for a click. Option.", "response": "def _format_option(opt):\n    \"\"\"Format the output for a `click.Option`.\"\"\"\n    opt = _get_help_record(opt)\n\n    yield '.. option:: {}'.format(opt[0])\n    if opt[1]:\n        yield ''\n        for line in statemachine.string2lines(\n                opt[1], tab_width=4, convert_whitespace=True):\n            yield _indent(line)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nformat all click. Option for a click. Command.", "response": "def _format_options(ctx):\n    \"\"\"Format all `click.Option` for a `click.Command`.\"\"\"\n    # the hidden attribute is part of click 7.x only hence use of getattr\n    params = [\n        x for x in ctx.command.params\n        if isinstance(x, click.Option) and not getattr(x, 'hidden', False)\n    ]\n\n    for param in params:\n        for line in _format_option(param):\n            yield line\n        yield ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _format_argument(arg):\n    yield '.. option:: {}'.format(arg.human_readable_name)\n    yield ''\n    yield _indent('{} argument{}'.format(\n        'Required' if arg.required else 'Optional',\n        '(s)' if arg.nargs != 1 else ''))", "response": "Format the output of a click. Argument."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _format_arguments(ctx):\n    params = [x for x in ctx.command.params if isinstance(x, click.Argument)]\n\n    for param in params:\n        for line in _format_argument(param):\n            yield line\n        yield ''", "response": "Format all click. Argument for a click. Command."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nformats the envvars of a click. Option or click. Argument.", "response": "def _format_envvar(param):\n    \"\"\"Format the envvars of a `click.Option` or `click.Argument`.\"\"\"\n    yield '.. envvar:: {}'.format(param.envvar)\n    yield '   :noindex:'\n    yield ''\n    if isinstance(param, click.Argument):\n        param_ref = param.human_readable_name\n    else:\n        # if a user has defined an opt with multiple \"aliases\", always use the\n        # first. For example, if '--foo' or '-f' are possible, use '--foo'.\n        param_ref = param.opts[0]\n\n    yield _indent('Provide a default for :option:`{}`'.format(param_ref))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nformats all envvars for a click. Command.", "response": "def _format_envvars(ctx):\n    \"\"\"Format all envvars for a `click.Command`.\"\"\"\n    params = [x for x in ctx.command.params if getattr(x, 'envvar')]\n\n    for param in params:\n        yield '.. _{command_name}-{param_name}-{envvar}:'.format(\n            command_name=ctx.command_path.replace(' ', '-'),\n            param_name=param.name,\n            envvar=param.envvar,\n        )\n        yield ''\n        for line in _format_envvar(param):\n            yield line\n        yield ''"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _format_subcommand(command):\n    yield '.. object:: {}'.format(command.name)\n\n    # click 7.0 stopped setting short_help by default\n    if CLICK_VERSION < (7, 0):\n        short_help = command.short_help\n    else:\n        short_help = command.get_short_help_str()\n\n    if short_help:\n        yield ''\n        for line in statemachine.string2lines(\n                short_help, tab_width=4, convert_whitespace=True):\n            yield _indent(line)", "response": "Format a sub - command of a click. Command or click. Group."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn list of used commands.", "response": "def _filter_commands(ctx, commands=None):\n    \"\"\"Return list of used commands.\"\"\"\n    lookup = getattr(ctx.command, 'commands', {})\n    if not lookup and isinstance(ctx.command, click.MultiCommand):\n        lookup = _get_lazyload_commands(ctx.command)\n\n    if commands is None:\n        return sorted(lookup.values(), key=lambda item: item.name)\n\n    names = [name.strip() for name in commands.split(',')]\n    return [lookup[name] for name in names if name in lookup]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _format_command(ctx, show_nested, commands=None):\n    # the hidden attribute is part of click 7.x only hence use of getattr\n    if getattr(ctx.command, 'hidden', False):\n        return\n\n    # description\n\n    for line in _format_description(ctx):\n        yield line\n\n    yield '.. program:: {}'.format(ctx.command_path)\n\n    # usage\n\n    for line in _format_usage(ctx):\n        yield line\n\n    # options\n\n    lines = list(_format_options(ctx))\n    if lines:\n        # we use rubric to provide some separation without exploding the table\n        # of contents\n        yield '.. rubric:: Options'\n        yield ''\n\n    for line in lines:\n        yield line\n\n    # arguments\n\n    lines = list(_format_arguments(ctx))\n    if lines:\n        yield '.. rubric:: Arguments'\n        yield ''\n\n    for line in lines:\n        yield line\n\n    # environment variables\n\n    lines = list(_format_envvars(ctx))\n    if lines:\n        yield '.. rubric:: Environment variables'\n        yield ''\n\n    for line in lines:\n        yield line\n\n    # if we're nesting commands, we need to do this slightly differently\n    if show_nested:\n        return\n\n    commands = _filter_commands(ctx, commands)\n\n    if commands:\n        yield '.. rubric:: Commands'\n        yield ''\n\n    for command in commands:\n        # Don't show hidden subcommands\n        if CLICK_VERSION >= (7, 0):\n            if command.hidden:\n                continue\n\n        for line in _format_subcommand(command):\n            yield line\n        yield ''", "response": "Format the output of click. Command."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _generate_nodes(self,\n                        name,\n                        command,\n                        parent=None,\n                        show_nested=False,\n                        commands=None):\n        \"\"\"Generate the relevant Sphinx nodes.\n\n        Format a `click.Group` or `click.Command`.\n\n        :param name: Name of command, as used on the command line\n        :param command: Instance of `click.Group` or `click.Command`\n        :param parent: Instance of `click.Context`, or None\n        :param show_nested: Whether subcommands should be included in output\n        :param commands: Display only listed commands or skip the section if\n            empty\n        :returns: A list of nested docutil nodes\n        \"\"\"\n        ctx = click.Context(command, info_name=name, parent=parent)\n\n        # Title\n\n        section = nodes.section(\n            '',\n            nodes.title(text=name),\n            ids=[nodes.make_id(ctx.command_path)],\n            names=[nodes.fully_normalize_name(ctx.command_path)])\n\n        # Summary\n\n        source_name = ctx.command_path\n        result = statemachine.ViewList()\n\n        lines = _format_command(ctx, show_nested, commands)\n        for line in lines:\n            LOG.debug(line)\n            result.append(line, source_name)\n\n        self.state.nested_parse(result, 0, section)\n\n        # Subcommands\n\n        if show_nested:\n            commands = _filter_commands(ctx, commands)\n            for command in commands:\n                section.extend(\n                    self._generate_nodes(command.name, command, ctx,\n                                         show_nested))\n\n        return [section]", "response": "Generate the relevant Sphinx nodes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _event_ignored(self, event):\n        # Ignore if another action (zoom, pan) is active\n        if event.canvas.widgetlock.locked():\n            return True\n\n        # Ignore non-hiding pick events for the annotation box itself\n        # (otherwise, draggable annotation boxes won't work) and pick\n        # events not for the artists that this data cursor manages.\n        if event.artist not in self.artists:\n            return True\n\n        if not self.hover:\n            # Ignore pick events from other mouse buttons\n            if event.mouseevent.button != self.display_button:\n                return True\n\n        return False", "response": "Decide whether or not to ignore a click or hover event."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _show_annotation_box(self, event):\n        ax = event.artist.axes\n        # Get the pre-created annotation box for the axes or create a new one.\n        if self.display != 'multiple':\n            annotation = self.annotations[ax]\n        elif event.mouseevent in self.annotations:\n            # Avoid creating multiple datacursors for the same click event\n            # when several artists are selected.\n            annotation = self.annotations[event.mouseevent]\n        else:\n            annotation = self.annotate(ax, **self._annotation_kwargs)\n            self.annotations[event.mouseevent] = annotation\n\n        if self.display == 'single':\n            # Hide any other annotation boxes...\n            for ann in self.annotations.values():\n                ann.set_visible(False)\n\n        self.update(event, annotation)", "response": "Update an existing annotation box or create a new one."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef event_info(self, event):\n        def default_func(event):\n            return {}\n        registry = {\n                AxesImage : [pick_info.image_props],\n                PathCollection : [pick_info.scatter_props, self._contour_info,\n                                  pick_info.collection_props],\n                Line2D : [pick_info.line_props, pick_info.errorbar_props],\n                LineCollection : [pick_info.collection_props,\n                                  self._contour_info,\n                                  pick_info.errorbar_props],\n                PatchCollection : [pick_info.collection_props,\n                                   self._contour_info],\n                PolyCollection : [pick_info.collection_props,\n                                  pick_info.scatter_props],\n                QuadMesh : [pick_info.collection_props],\n                Rectangle : [pick_info.rectangle_props],\n                }\n        x, y = event.mouseevent.xdata, event.mouseevent.ydata\n        props = dict(x=x, y=y, label=event.artist.get_label(), event=event)\n        props['ind'] = getattr(event, 'ind', None)\n        props['point_label'] = self._point_label(event)\n\n        funcs = registry.get(type(event.artist), [default_func])\n\n        # 3D artist don't share inheritance. Fall back to naming convention.\n        if '3D' in type(event.artist).__name__:\n            funcs += [pick_info.three_dim_props]\n\n        for func in funcs:\n            props.update(func(event))\n\n        return props", "response": "Get a dict of info for the artist selected by event."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndefaulting formatter function, if no `formatter` kwarg is specified. Takes information about the pick event as a series of kwargs and returns the string to be displayed.", "response": "def _formatter(self, x=None, y=None, z=None, s=None, label=None, **kwargs):\n        \"\"\"\n        Default formatter function, if no `formatter` kwarg is specified. Takes\n        information about the pick event as a series of kwargs and returns the\n        string to be displayed.\n        \"\"\"\n        def is_date(axis):\n            fmt = axis.get_major_formatter()\n            return (isinstance(fmt, mdates.DateFormatter)\n                 or isinstance(fmt, mdates.AutoDateFormatter))\n        def format_date(num):\n            if num is not None:\n                return mdates.num2date(num).strftime(self.date_format)\n\n        ax = kwargs['event'].artist.axes\n\n        # Display x and y with range-specific formatting\n        if is_date(ax.xaxis):\n            x = format_date(x)\n        else:\n            limits = ax.get_xlim()\n            x = self._format_coord(x, limits)\n            kwargs['xerror'] = self._format_coord(kwargs.get('xerror'), limits)\n\n        if is_date(ax.yaxis):\n            y = format_date(y)\n        else:\n            limits = ax.get_ylim()\n            y = self._format_coord(y, limits)\n            kwargs['yerror'] = self._format_coord(kwargs.get('yerror'), limits)\n\n        output = []\n        for key, val in zip(['x', 'y', 'z', 's'], [x, y, z, s]):\n            if val is not None:\n                try:\n                    output.append(u'{key}: {val:0.3g}'.format(key=key, val=val))\n                except ValueError:\n                    # X & Y will be strings at this point.\n                    # For masked arrays, etc, \"z\" and s values may be a string\n                    output.append(u'{key}: {val}'.format(key=key, val=val))\n\n        # label may be None or an empty string (for an un-labeled AxesImage)...\n        # Un-labeled Line2D's will have labels that start with an underscore\n        if label and not label.startswith('_'):\n            output.append(u'Label: {}'.format(label))\n\n        if kwargs.get(u'point_label', None) is not None:\n            output.append(u'Point: ' + u', '.join(kwargs['point_label']))\n\n        for arg in ['xerror', 'yerror']:\n            val = kwargs.get(arg, None)\n            if val is not None:\n                output.append(u'{}: {}'.format(arg, val))\n\n        return u'\\n'.join(output)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _format_coord(self, x, limits):\n        if x is None:\n            return None\n\n        formatter = self._mplformatter\n        # Trick the formatter into thinking we have an axes\n        # The 7 tick locations is arbitrary but gives a reasonable detail level\n        formatter.locs = np.linspace(limits[0], limits[1], 7)\n        formatter._set_format(*limits)\n        formatter._set_orderOfMagnitude(abs(np.diff(limits)))\n        return formatter.pprint_val(x)", "response": "Formats the x and y coordinates for the current display."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndraw the annotation box for the given axis.", "response": "def annotate(self, ax, **kwargs):\n        \"\"\"\n        Draws the annotation box for the given axis *ax*. Additional kwargs\n        are passed on to ``annotate``.\n        \"\"\"\n        def update_from_defaults(key, kwargs):\n            if kwargs.get(key, None) is not None:\n                new = copy.deepcopy(self.default_annotation_kwargs[key])\n                new.update(kwargs[key])\n                kwargs[key] = new\n            return kwargs\n\n\n        # Ensure bbox and arrowstyle params passed in use the defaults for\n        # DataCursor. This allows things like ``bbox=dict(alpha=1)`` to show a\n        # yellow, rounded box, instead of the mpl default blue, square box.)\n        kwargs = update_from_defaults('bbox', kwargs)\n        kwargs = update_from_defaults('arrowstyle', kwargs)\n\n        # Set defaults where approriate.\n        for key in self.default_annotation_kwargs:\n            if key not in kwargs:\n                kwargs[key] = self.default_annotation_kwargs[key]\n\n        annotation = ax.annotate('This text will be reset', **kwargs)\n        annotation._has_been_shown = False\n\n        # Place the annotation in the figure instead of the axes so that it\n        # doesn't get hidden behind other subplots (zorder won't fix that).\n        ax.figure.texts.append(ax.texts.pop())\n\n        # Create a draggable annotation box, if required.\n        if self.draggable:\n            offsetbox.DraggableAnnotation(annotation)\n\n        # Save whether or not alignment is user-specified. If not, adjust to\n        # match text offset (and update when display moves out of figure).\n        self._user_set_ha = 'ha' in kwargs or 'horizontalalignment' in kwargs\n        self._user_set_va = 'va' in kwargs or 'verticalalignment' in kwargs\n        self._adjust_alignment(annotation)\n\n        return annotation"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadjusting the alignment of the text box based on the specified offsets.", "response": "def _adjust_alignment(self, annotation):\n        \"\"\"\n        Make text alignment match the specified offsets (this allows easier\n        changing of relative position of text box...)\n        \"\"\"\n        try:\n            # annotation.xytext is depreciated in recent versions\n            dx, dy = annotation.xyann\n        except AttributeError:\n            # but xyann doesn't exist in older versions...\n            dx, dy = annotation.xytext\n\n        horizontal = {1:'left', 0:'center', -1:'right'}[np.sign(dx)]\n        vertical = {1:'bottom', 0:'center', -1:'top'}[np.sign(dy)]\n        if not self._user_set_ha:\n            annotation.set_horizontalalignment(horizontal)\n        if not self._user_set_va:\n            annotation.set_verticalalignment(vertical)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhides all annotation artists associated with the DataCursor. Returns self to allow changing.", "response": "def hide(self):\n        \"\"\"Hides all annotation artists associated with the DataCursor. Returns\n        self to allow \"chaining\". (e.g. ``datacursor.hide().disable()``)\"\"\"\n        self._hidden = True\n        for artist in self.annotations.values():\n            artist.set_visible(False)\n        for fig in self.figures:\n            fig.canvas.draw()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove a specific annotation box.", "response": "def _hide_box(self, annotation):\n        \"\"\"Remove a specific annotation box.\"\"\"\n        annotation.set_visible(False)\n\n        if self.display == 'multiple':\n            annotation.axes.figure.texts.remove(annotation)\n            # Remove the annotation from self.annotations.\n            lookup = dict((self.annotations[k], k) for k in self.annotations)\n            del self.annotations[lookup[annotation]]\n\n        annotation.figure.canvas.draw()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndisabling interactivity for all callbacks and disables interactivity.", "response": "def disable(self):\n        \"\"\"\n        Disconnects all callbacks and disables interactivity. Any existing\n        annotations will continue to be visible (and draggable, if applicable).\n        This has no effect if the datacursor has not been enabled. Returns self\n        to allow \"chaining\". (e.g. ``datacursor.hide().disable()``)\n        \"\"\"\n        if self._enabled:\n            for fig, cids in self._cids:\n                for cid in cids:\n                    fig.canvas.mpl_disconnect(cid)\n            self._enabled = False\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconnect callbacks and makes artists pickable.", "response": "def enable(self):\n        \"\"\"Connects callbacks and makes artists pickable. If the datacursor has\n        already been enabled, this function has no effect.\"\"\"\n        def connect(fig):\n            if self.hover:\n                event = 'motion_notify_event'\n            else:\n                event = 'button_press_event'\n            cids = [fig.canvas.mpl_connect(event, self._select)]\n\n            # None of this should be necessary. Workaround for a bug in some\n            # mpl versions\n            try:\n                proxy = fig.canvas.callbacks.BoundMethodProxy(self)\n                fig.canvas.callbacks.callbacks[event][cids[-1]] = proxy\n            except AttributeError:\n                # In some versions of mpl, BoundMethodProxy doesn't exist...\n                # See: https://github.com/joferkington/mpldatacursor/issues/2\n                pass\n            return cids\n\n        if not getattr(self, '_enabled', False):\n            self._cids = [(fig, connect(fig)) for fig in self.figures]\n            self._enabled = True\n            try:\n                # Newer versions of MPL use set_pickradius\n                for artist in self.artists:\n                    artist.set_pickradius(self.tolerance)\n            except AttributeError:\n                # Older versions of MPL control pick radius through set_picker\n                for artist in self.artists:\n                    artist.set_picker(self.tolerance)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, event, annotation):\n        # Get artist-specific information about the pick event\n        info = self.event_info(event)\n\n        if self.props_override is not None:\n            info = self.props_override(**info)\n\n        # Update the xy position and text using the formatter function\n        annotation.set_text(self.formatter(**info))\n        annotation.xy = info['x'], info['y']\n\n        # Unfortnately, 3D artists are a bit more complex...\n        # Also, 3D artists don't share inheritance. Use naming instead.\n        if '3D' in type(event.artist).__name__:\n            annotation.xy = event.mouseevent.xdata, event.mouseevent.ydata\n\n        # In case it's been hidden earlier...\n        annotation.set_visible(True)\n\n        if self.keep_inside:\n            self._keep_annotation_inside(annotation)\n\n        annotation._has_been_shown = True\n        self._last_event = event\n        self._last_annotation = annotation\n\n        event.canvas.draw()", "response": "Update the specified annotation."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nincrements the index of the most recently displayed annotation.", "response": "def _increment_index(self, di=1):\n        \"\"\"\n        Move the most recently displayed annotation to the next item in the\n        series, if possible. If ``di`` is -1, move it to the previous item.\n        \"\"\"\n        if self._last_event is None:\n            return\n\n        if not hasattr(self._last_event, 'ind'):\n            return\n\n        event = self._last_event\n        xy = pick_info.get_xy(event.artist)\n\n        if xy is not None:\n            x, y = xy\n            i = (event.ind[0] + di) % len(x)\n            event.ind = [i]\n            event.mouseevent.xdata = x[i]\n            event.mouseevent.ydata = y[i]\n\n            self.update(event, self._last_annotation)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _select(self, event):\n        def event_axes_data(event, ax):\n            \"\"\"Creates a new event will have xdata and ydata based on *ax*.\"\"\"\n            # We need to redefine event.xdata and event.ydata for twinned axes\n            # to work correctly\n            point = event.x, event.y\n            x, y = ax.transData.inverted().transform_point(point)\n            event = copy.copy(event)\n            event.xdata, event.ydata = x, y\n            return event\n\n        def contains(artist, event):\n            \"\"\"Need to ensure we don't trigger a pick event for axes in a\n            different figure. Otherwise, picking on one figure will trigger a\n            datacursor in another figure.\"\"\"\n            if event.canvas is artist.figure.canvas:\n                return artist.contains(event)\n            else:\n                return False, {}\n\n        # If we're on top of an annotation box, hide it if right-clicked or\n        # do nothing if we're in draggable mode\n        for anno in list(self.annotations.values()):\n            fixed_event = event_axes_data(event, anno.axes)\n            if contains(anno, fixed_event)[0]:\n                if event.button == self.hide_button:\n                    self._hide_box(anno)\n                elif self.draggable:\n                    return\n\n        for artist in self.artists:\n            fixed_event = event_axes_data(event, artist.axes)\n            inside, info = contains(artist, fixed_event)\n            if inside:\n                fig = artist.figure\n                new_event = PickEvent('pick_event', fig.canvas, fixed_event,\n                                     artist, **info)\n                self(new_event)\n\n                # Only fire a single pick event for one mouseevent. Otherwise\n                # we'll need timers, etc to avoid multiple calls\n                break\n\n        # Not hovering over anything...\n        if self.hover:\n            artists = itertools.chain(self.artists, self.annotations.values())\n            over_something = [contains(artist, event)[0] for artist in artists]\n            if not any(over_something):\n                self.hide()", "response": "This function is basically a proxy to trigger a pick event."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, event, annotation):\n        # Decide whether or not to hide previous highlights...\n        for artist in self.highlights.values():\n            if self.display == 'multiple':\n                continue\n            if self.display == 'one-per-axes':\n                if event.artist.axes is not artist.axes:\n                    continue\n            artist.set_visible(False)\n        self.show_highlight(event.artist)\n        DataCursor.update(self, event, annotation)", "response": "Update the specified annotation."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_highlight(self, artist):\n        # This is a separate method to make subclassing easier.\n        if artist in self.highlights:\n            self.highlights[artist].set_visible(True)\n        else:\n            self.highlights[artist] = self.create_highlight(artist)\n        return self.highlights[artist]", "response": "Show or create a highlight for a givent artist."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new highlight for the given artist.", "response": "def create_highlight(self, artist):\n        \"\"\"Create a new highlight for the given artist.\"\"\"\n        highlight = copy.copy(artist)\n        highlight.set(color=self.highlight_color, mec=self.highlight_color,\n                      lw=self.highlight_width, mew=self.highlight_width)\n        artist.axes.add_artist(highlight)\n        return highlight"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _coords2index(im, x, y, inverted=False):\n    xmin, xmax, ymin, ymax = im.get_extent()\n    if im.origin == 'upper':\n        ymin, ymax = ymax, ymin\n    data_extent = mtransforms.Bbox([[ymin, xmin], [ymax, xmax]])\n    array_extent = mtransforms.Bbox([[0, 0], im.get_array().shape[:2]])\n    trans = mtransforms.BboxTransformFrom(data_extent) +\\\n            mtransforms.BboxTransformTo(array_extent)\n\n    if inverted:\n        trans = trans.inverted()\n\n    return trans.transform_point([y,x]).astype(int)", "response": "Converts data coordinates to index coordinates of the array."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a dict with keys z i j where z is the index of the image at i j.", "response": "def image_props(event):\n    \"\"\"\n    Get information for a pick event on an ``AxesImage`` artist. Returns a dict\n    of \"i\" & \"j\" index values of the image for the point clicked, and \"z\": the\n    (uninterpolated) value of the image at i,j.\n\n    Parameters\n    -----------\n    event : PickEvent\n        The pick event to process\n\n    Returns\n    --------\n    props : dict\n        A dict with keys: z, i, j\n    \"\"\"\n    x, y = event.mouseevent.xdata, event.mouseevent.ydata\n    i, j = _coords2index(event.artist, x, y)\n    z = event.artist.get_array()[i,j]\n    if z.size > 1:\n        # Override default numpy formatting for this specific case. Bad idea?\n        z = ', '.join('{:0.3g}'.format(item) for item in z)\n    return dict(z=z, i=i, j=j)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a dict of x and y values that are interpolated between vertices and the nearest point of the mouse.", "response": "def line_props(event):\n    \"\"\"\n    Get information for a pick event on a Line2D artist (as created with\n    ``plot``.)\n\n    This will yield x and y values that are interpolated between vertices\n    (instead of just being the position of the mouse) or snapped to the nearest\n    vertex if only the vertices are drawn.\n\n    Parameters\n    -----------\n    event : PickEvent\n        The pick event to process\n\n    Returns\n    --------\n    props : dict\n        A dict with keys: x & y\n    \"\"\"\n    xclick, yclick = event.mouseevent.xdata, event.mouseevent.ydata\n    i = event.ind[0]\n    xorig, yorig = event.artist.get_xydata().T\n\n    # For points-only lines, snap to the nearest point.\n    linestyle = event.artist.get_linestyle()\n    if linestyle in ['none', ' ', '', None, 'None']:\n        return dict(x=xorig[i], y=yorig[i])\n\n    # ax.step is actually implemented as a Line2D with a different drawstyle...\n    xs_data = xorig[max(i - 1, 0) : i + 2]\n    ys_data = yorig[max(i - 1, 0) : i + 2]\n    drawstyle = event.artist.drawStyles[event.artist.get_drawstyle()]\n    if drawstyle == \"_draw_lines\":\n        pass\n    elif drawstyle == \"_draw_steps_pre\":\n        xs_data = _interleave(xs_data, xs_data[:-1])\n        ys_data = _interleave(ys_data, ys_data[1:])\n    elif drawstyle == \"_draw_steps_post\":\n        xs_data = _interleave(xs_data, xs_data[1:])\n        ys_data = _interleave(ys_data, ys_data[:-1])\n    elif drawstyle == \"_draw_steps_mid\":\n        mid_xs = (xs_data[:-1] + xs_data[1:]) / 2\n        xs_data = _interleave(xs_data, np.column_stack([mid_xs, mid_xs]))\n        ys_data = _interleave(\n            ys_data, np.column_stack([ys_data[:-1], ys_data[1:]]))\n    else:\n        raise ValueError(\n            \"Unknown drawstyle: {}\".format(event.artist.get_drawstyle()))\n    # The artist transform may be different from the axes transform (e.g.,\n    # axvline/axhline)\n    artist_transform = event.artist.get_transform()\n    axes_transform = event.artist.axes.transData\n    xs_screen, ys_screen = (\n        artist_transform.transform(\n            np.column_stack([xs_data, ys_data]))).T\n    xclick_screen, yclick_screen = (\n        axes_transform.transform([xclick, yclick]))\n    x_screen, y_screen = _interpolate_line(xs_screen, ys_screen,\n                                           xclick_screen, yclick_screen)\n    x, y = axes_transform.inverted().transform([x_screen, y_screen])\n\n    return dict(x=x, y=y)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninterleave arrays a and b into a column array.", "response": "def _interleave(a, b):\n    \"\"\"Interleave arrays a and b; b may have multiple columns and must be\n    shorter by 1.\n    \"\"\"\n    b = np.column_stack([b]) # Turn b into a column array.\n    nx, ny = b.shape\n    c = np.zeros((nx + 1, ny + 1))\n    c[:, 0] = a\n    c[:-1, 1:] = b\n    return c.ravel()[:-(c.shape[1] - 1)]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _interpolate_line(xorig, yorig, xclick, yclick):\n    candidates = []\n    # The closest point may be a vertex.\n    for x, y in zip(xorig, yorig):\n        candidates.append((np.hypot(xclick - x, yclick - y), (x, y)))\n    # Or it may be a projection on a segment.\n    for (x0, x1), (y0, y1) in zip(zip(xorig, xorig[1:]), zip(yorig, yorig[1:])):\n        vec1 = np.array([x1 - x0, y1 - y0])\n        vec1 /= np.linalg.norm(vec1)\n        vec2 = np.array([xclick - x0, yclick - y0])\n        dist_along = vec1.dot(vec2)\n        x, y = np.array([x0, y0]) + dist_along * vec1\n        # Drop if out of the segment.\n        if (x - x0) * (x - x1) > 0 or (y - y0) * (y - y1) > 0:\n            continue\n        candidates.append((np.hypot(xclick - x, yclick - y), (x, y)))\n    _, (x, y) = min(candidates)\n    return x, y", "response": "Interpolate a line to the point xclick yclick."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the properties of a pick event on an artist collection. This will return the color and z properties of the artist collection.", "response": "def collection_props(event):\n    \"\"\"\n    Get information for a pick event on an artist collection (e.g.\n    LineCollection, PathCollection, PatchCollection, etc).  This will\"\"\"\n    ind = event.ind[0]\n    arr = event.artist.get_array()\n    # If a constant color/c/z was specified, don't return it\n    if arr is None or len(arr) == 1:\n        z = None\n    else:\n        z = arr[ind]\n    return dict(z=z, c=z)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn information for a pick event on a PathCollection artist.", "response": "def scatter_props(event):\n    \"\"\"\n    Get information for a pick event on a PathCollection artist (usually\n    created with ``scatter``).\n\n    Parameters\n    -----------\n    event : PickEvent\n        The pick event to process\n\n    Returns\n    --------\n    A dict with keys:\n        `c`: The value of the color array at the point clicked.\n        `s`: The value of the size array at the point clicked.\n        `z`: Identical to `c`. Specified for convenience.\n\n    Notes\n    -----\n    If constant values were specified to ``c`` or ``s`` when calling\n    ``scatter``, `c` and/or `z` will be ``None``.\n    \"\"\"\n    # Use only the first item, if multiple items were selected\n    ind = event.ind[0]\n\n    try:\n        sizes = event.artist.get_sizes()\n    except AttributeError:\n        sizes = None\n    # If a constant size/s was specified, don't return it\n    if sizes is None or len(sizes) == 1:\n        s = None\n    else:\n        s = sizes[ind]\n\n    try:\n        # Snap to the x, y of the point... (assuming it's created by scatter)\n        xorig, yorig = event.artist.get_offsets().T\n        x, y = xorig[ind], yorig[ind]\n        return dict(x=x, y=y, s=s)\n    except IndexError:\n        # Not created by scatter...\n        return dict(s=s)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef three_dim_props(event):\n    ax = event.artist.axes\n    if ax.M is None:\n        return {}\n\n    xd, yd = event.mouseevent.xdata, event.mouseevent.ydata\n    p = (xd, yd)\n    edges = ax.tunit_edges()\n    ldists = [(mplot3d.proj3d.line2d_seg_dist(p0, p1, p), i) for \\\n                i, (p0, p1) in enumerate(edges)]\n    ldists.sort()\n\n    # nearest edge\n    edgei = ldists[0][1]\n\n    p0, p1 = edges[edgei]\n\n    # scale the z value to match\n    x0, y0, z0 = p0\n    x1, y1, z1 = p1\n    d0 = np.hypot(x0-xd, y0-yd)\n    d1 = np.hypot(x1-xd, y1-yd)\n    dt = d0+d1\n    z = d1/dt * z0 + d0/dt * z1\n\n    x, y, z = mplot3d.proj3d.inv_transform(xd, yd, z, ax.M)\n    return dict(x=x, y=y, z=z)", "response": "Get information for a pick event on a 3D artist."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the width height left and bottom of a rectangle artist.", "response": "def rectangle_props(event):\n    \"\"\"\n    Returns the width, height, left, and bottom of a rectangle artist.\n\n    Parameters\n    -----------\n    event : PickEvent\n        The pick event to process\n\n    Returns\n    --------\n    A dict with keys:\n        `width` : The width of the rectangle\n        `height` : The height of the rectangle\n        `left` : The minimum x-coordinate of the rectangle\n        `right` : The maximum x-coordinate of the rectangle\n        `bottom` : The minimum y-coordinate of the rectangle\n        `top` : The maximum y-coordinate of the rectangle\n        `xcenter` : The mean x-coordinate of the rectangle\n        `ycenter` : The mean y-coordinate of the rectangle\n        `label` : The label for the rectangle or None\n    \"\"\"\n    artist = event.artist\n    width, height = artist.get_width(), artist.get_height()\n    left, bottom = artist.xy\n    right, top = left + width, bottom + height\n    xcenter = left + 0.5 * width\n    ycenter = bottom + 0.5 * height\n\n    label = artist.get_label()\n    if label is None or label.startswith('_nolegend'):\n        try:\n            label = artist._mpldatacursor_label\n        except AttributeError:\n            label = None\n\n    return dict(width=width, height=height, left=left, bottom=bottom,\n                label=label, right=right, top=top,\n                xcenter=xcenter, ycenter=ycenter)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_xy(artist):\n    xy = None\n\n    if hasattr(artist, 'get_offsets'):\n        xy = artist.get_offsets().T\n    elif hasattr(artist, 'get_xydata'):\n        xy = artist.get_xydata().T\n\n    return xy", "response": "Attempts to get the x y data for individual items subitems of the artist."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates an interactive data cursor for the specified artists or axes.", "response": "def datacursor(artists=None, axes=None, **kwargs):\n    \"\"\"\n    Create an interactive data cursor for the specified artists or specified\n    axes. The data cursor displays information about a selected artist in a\n    \"popup\" annotation box.\n\n    If a specific sequence of artists is given, only the specified artists will\n    be interactively selectable.  Otherwise, all manually-plotted artists in\n    *axes* will be used (*axes* defaults to all axes in all figures).\n\n    Parameters\n    -----------\n    artists : a matplotlib artist or sequence of artists, optional\n        The artists to make selectable and display information for. If this is\n        not specified, then all manually plotted artists in `axes` will be\n        used.\n    axes : a matplotlib axes of sequence of axes, optional\n        The axes to selected artists from if a sequence of artists is not\n        specified.  If `axes` is not specified, then all available axes in all\n        figures will be used.\n    tolerance : number, optional\n        The radius (in points) that the mouse click must be within to select\n        the artist. Default: 5 points.\n    formatter : callable, optional\n        A function that accepts arbitrary kwargs and returns a string that will\n        be displayed with annotate. Often, it is convienent to pass in the\n        format method of a template string, e.g.\n        ``formatter=\"{label}\".format``.\n        Keyword arguments passed in to the `formatter` function:\n            `x`, `y` : floats\n                The x and y data coordinates of the clicked point\n            `event` : a matplotlib ``PickEvent``\n                The pick event that was fired (note that the selected\n                artist can be accessed through ``event.artist``).\n            `label` : string or None\n                The legend label of the selected artist.\n            `ind` : list of ints or None\n                If the artist has \"subitems\" (e.g. points in a scatter or\n                line plot), this will be a list of the item(s) that were\n                clicked on.  If the artist does not have \"subitems\", this\n                will be None. Note that this is always a list, even when\n                a single item is selected.\n        Some selected artists may supply additional keyword arguments that\n        are not always present, for example:\n            `z` : number\n                The \"z\" (usually color or array) value, if present. For an\n                ``AxesImage`` (as created by ``imshow``), this will be the\n                uninterpolated array value at the point clicked. For a\n                ``PathCollection`` (as created by ``scatter``) this will be the\n                \"c\" value if an array was passed to \"c\".\n            `i`, `j` : ints\n                The row, column indicies of the selected point for an\n                ``AxesImage`` (as created by ``imshow``)\n            `s` : number\n                The size of the selected item in a ``PathCollection`` if a size\n                array is specified.\n            `c` : number\n                The array value displayed as color for a ``PathCollection``\n                if a \"c\" array is specified (identical to \"z\").\n            `point_label` : list\n                If `point_labels` is given when the data cursor is initialized\n                and the artist has \"subitems\", this will be a list of the items\n                of `point_labels` that correspond to the selected artists.\n                Note that this is always a list, even when a single artist is\n                selected.\n            `width`, `height`, `top`, `bottom` : numbers\n                The parameters for ``Rectangle`` artists (e.g. bar plots).\n    point_labels : sequence or dict, optional\n        For artists with \"subitems\" (e.g. Line2D's), the item(s) of\n        `point_labels` corresponding to the selected \"subitems\" of the artist\n        will be passed into the formatter function as the \"point_label\" kwarg.\n        If a single sequence is given, it will be used for all artists with\n        \"subitems\". Alternatively, a dict of artist:sequence pairs may be given\n        to match an artist to the correct series of point labels.\n    display : {\"one-per-axes\", \"single\", \"multiple\"}, optional\n        Controls whether more than one annotation box will be shown.\n        Default: \"one-per-axes\"\n    draggable : boolean, optional\n        Controls whether or not the annotation box will be interactively\n        draggable to a new location after being displayed. Defaults to False.\n    hover : boolean, optional\n        If True, the datacursor will \"pop up\" when the mouse hovers over an\n        artist.  Defaults to False.  Enabling hover also sets\n        `display=\"single\"` and `draggable=False`.\n    props_override : function, optional\n        If specified, this function customizes the parameters passed into the\n        formatter function and the x, y location that the datacursor \"pop up\"\n        \"points\" to.  This is often useful to make the annotation \"point\" to a\n        specific side or corner of an artist, regardless of the position\n        clicked. The function is passed the same kwargs as the `formatter`\n        function and is expected to return a dict with at least the keys \"x\"\n        and \"y\" (and probably several others).\n        Expected call signature: `props_dict = props_override(**kwargs)`\n    keybindings : boolean or dict, optional\n        By default, the keys \"d\" and \"t\" will be bound to deleting/hiding all\n        annotation boxes and toggling interactivity for datacursors,\n        respectively.  If keybindings is False, the ability to hide/toggle\n        datacursors interactively will be disabled. Alternatively, a dict of\n        the form {'hide':'somekey', 'toggle':'somekey'} may specified to\n        customize the keyboard shortcuts.\n    date_format : string, optional\n        The strftime-style formatting string for dates. Used only if the x or y\n        axes have been set to display dates. Defaults to \"%x %X\".\n    display_button: int, optional\n        The mouse button that will triggers displaying an annotation box.\n        Defaults to 1, for left-clicking. (Common options are 1:left-click,\n        2:middle-click, 3:right-click)\n    hide_button: int or None, optional\n        The mouse button that triggers hiding the selected annotation box.\n        Defaults to 3, for right-clicking. (Common options are 1:left-click,\n        2:middle-click, 3:right-click, None:hiding disabled)\n    keep_inside : boolean, optional\n        Whether or not to adjust the x,y offset to keep the text box inside the\n        figure. This option has no effect on draggable datacursors. Defaults to\n        True. Note: Currently disabled on OSX and NbAgg/notebook backends.\n    **kwargs : additional keyword arguments, optional\n        Additional keyword arguments are passed on to annotate.\n\n    Returns\n    -------\n    dc : A ``mpldatacursor.DataCursor`` instance\n    \"\"\"\n    def plotted_artists(ax):\n        artists = (ax.lines + ax.patches + ax.collections\n                   + ax.images + ax.containers)\n        return artists\n\n    # If no axes are specified, get all axes.\n    if axes is None:\n        managers = pylab_helpers.Gcf.get_all_fig_managers()\n        figs = [manager.canvas.figure for manager in managers]\n        axes = [ax for fig in figs for ax in fig.axes]\n\n    if not cbook.iterable(axes):\n        axes = [axes]\n\n    # If no artists are specified, get all manually plotted artists in all of\n    # the specified axes.\n    if artists is None:\n        artists = [artist for ax in axes for artist in plotted_artists(ax)]\n\n    return DataCursor(artists, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef wrap_exception(func: Callable) -> Callable:\n    try:\n        # only do the wrapping if pygatt is installed.\n        # otherwise it's pointless anyway\n        from pygatt.backends.bgapi.exceptions import BGAPIError\n        from pygatt.exceptions import NotConnectedError\n    except ImportError:\n        return func\n\n    def _func_wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except BGAPIError as exception:\n            raise BluetoothBackendException() from exception\n        except NotConnectedError as exception:\n            raise BluetoothBackendException() from exception\n\n    return _func_wrapper", "response": "Decorator to wrap pygatt exceptions into BluetoothBackendException."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef connect(self, mac: str):\n        import pygatt\n\n        address_type = pygatt.BLEAddressType.public\n        if self._address_type == 'random':\n            address_type = pygatt.BLEAddressType.random\n        self._device = self._adapter.connect(mac, address_type=address_type)", "response": "Connect to a device."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_handle(self, handle: int) -> bytes:\n        if not self.is_connected():\n            raise BluetoothBackendException('Not connected to device!')\n        return self._device.char_read_handle(handle)", "response": "Read a handle from the device."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite a handle to the device.", "response": "def write_handle(self, handle: int, value: bytes):\n        \"\"\"Write a handle to the device.\"\"\"\n        if not self.is_connected():\n            raise BluetoothBackendException('Not connected to device!')\n        self._device.char_write_handle(handle, value, True)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wrap_exception(func: Callable) -> Callable:\n    try:\n        # only do the wrapping if bluepy is installed.\n        # otherwise it's pointless anyway\n        from bluepy.btle import BTLEException\n    except ImportError:\n        return func\n\n    def _func_wrapper(*args, **kwargs):\n        error_count = 0\n        last_error = None\n        while error_count < RETRY_LIMIT:\n            try:\n                return func(*args, **kwargs)\n            except BTLEException as exception:\n                error_count += 1\n                last_error = exception\n                time.sleep(RETRY_DELAY)\n                _LOGGER.debug('Call to %s failed, try %d of %d', func, error_count, RETRY_LIMIT)\n        raise BluetoothBackendException() from last_error\n\n    return _func_wrapper", "response": "Decorator to wrap BTLEExceptions into BluetoothBackendException."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconnecting to a device.", "response": "def connect(self, mac: str):\n        \"\"\"Connect to a device.\"\"\"\n        from bluepy.btle import Peripheral\n        match_result = re.search(r'hci([\\d]+)', self.adapter)\n        if match_result is None:\n            raise BluetoothBackendException(\n                'Invalid pattern \"{}\" for BLuetooth adpater. '\n                'Expetected something like \"hci0\".'.format(self.adapter))\n        iface = int(match_result.group(1))\n        self._peripheral = Peripheral(mac, iface=iface, addrType=self.address_type)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads a handle from the device.", "response": "def read_handle(self, handle: int) -> bytes:\n        \"\"\"Read a handle from the device.\n\n        You must be connected to do this.\n        \"\"\"\n        if self._peripheral is None:\n            raise BluetoothBackendException('not connected to backend')\n        return self._peripheral.readCharacteristic(handle)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write_handle(self, handle: int, value: bytes):\n        if self._peripheral is None:\n            raise BluetoothBackendException('not connected to backend')\n        return self._peripheral.writeCharacteristic(handle, value, True)", "response": "Write a handle from the device."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_backend() -> bool:\n        try:\n            import bluepy.btle  # noqa: F401 #pylint: disable=unused-import\n            return True\n        except ImportError as importerror:\n            _LOGGER.error('bluepy not found: %s', str(importerror))\n        return False", "response": "Check if the backend is available."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nscanning for bluetooth low energy devices.", "response": "def scan_for_devices(timeout: float) -> List[Tuple[str, str]]:\n        \"\"\"Scan for bluetooth low energy devices.\n\n        Note this must be run as root!\"\"\"\n        from bluepy.btle import Scanner\n\n        scanner = Scanner()\n        result = []\n        for device in scanner.scan(timeout):\n            result.append((device.addr, device.getValueText(9)))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwrapping all IOErrors to BluetoothBackendException", "response": "def wrap_exception(func: Callable) -> Callable:\n    \"\"\"Wrap all IOErrors to BluetoothBackendException\"\"\"\n\n    def _func_wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except IOError as exception:\n            raise BluetoothBackendException() from exception\n    return _func_wrapper"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite a value to a BLE characteristics handle.", "response": "def write_handle(self, handle: int, value: bytes):\n        # noqa: C901\n        # pylint: disable=arguments-differ\n\n        \"\"\"Read from a BLE address.\n\n        @param: mac - MAC address in format XX:XX:XX:XX:XX:XX\n        @param: handle - BLE characteristics handle in format 0xXX\n        @param: value - value to write to the given handle\n        \"\"\"\n\n        if not self.is_connected():\n            raise BluetoothBackendException('Not connected to any device.')\n\n        attempt = 0\n        delay = 10\n        _LOGGER.debug(\"Enter write_ble (%s)\", current_thread())\n\n        while attempt <= self.retries:\n            cmd = \"gatttool --device={} --addr-type={} --char-write-req -a {} -n {} --adapter={}\".format(\n                self._mac, self.address_type, self.byte_to_handle(handle), self.bytes_to_string(value), self.adapter)\n            _LOGGER.debug(\"Running gatttool with a timeout of %d: %s\",\n                          self.timeout, cmd)\n\n            with Popen(cmd,\n                       shell=True,\n                       stdout=PIPE,\n                       stderr=PIPE,\n                       preexec_fn=os.setsid) as process:\n                try:\n                    result = process.communicate(timeout=self.timeout)[0]\n                    _LOGGER.debug(\"Finished gatttool\")\n                except TimeoutExpired:\n                    # send signal to the process group\n                    os.killpg(process.pid, signal.SIGINT)\n                    result = process.communicate()[0]\n                    _LOGGER.debug(\"Killed hanging gatttool\")\n\n            result = result.decode(\"utf-8\").strip(' \\n\\t')\n            if \"Write Request failed\" in result:\n                raise BluetoothBackendException('Error writing handle to sensor: {}'.format(result))\n            _LOGGER.debug(\"Got %s from gatttool\", result)\n            # Parse the output\n            if \"successfully\" in result:\n                _LOGGER.debug(\n                    \"Exit write_ble with result (%s)\", current_thread())\n                return True\n\n            attempt += 1\n            _LOGGER.debug(\"Waiting for %s seconds before retrying\", delay)\n            if attempt < self.retries:\n                time.sleep(delay)\n                delay *= 2\n\n        raise BluetoothBackendException(\"Exit write_ble, no data ({})\".format(current_thread()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wait_for_notification(self, handle: int, delegate, notification_timeout: float):\n\n        if not self.is_connected():\n            raise BluetoothBackendException('Not connected to any device.')\n\n        attempt = 0\n        delay = 10\n        _LOGGER.debug(\"Enter write_ble (%s)\", current_thread())\n\n        while attempt <= self.retries:\n            cmd = \"gatttool --device={} --addr-type={} --char-write-req -a {} -n {} --adapter={} --listen\".format(\n                self._mac, self.address_type, self.byte_to_handle(handle), self.bytes_to_string(self._DATA_MODE_LISTEN),\n                self.adapter)\n            _LOGGER.debug(\"Running gatttool with a timeout of %d: %s\", notification_timeout, cmd)\n\n            with Popen(cmd,\n                       shell=True,\n                       stdout=PIPE,\n                       stderr=PIPE,\n                       preexec_fn=os.setsid) as process:\n                try:\n                    result = process.communicate(timeout=notification_timeout)[0]\n                    _LOGGER.debug(\"Finished gatttool\")\n                except TimeoutExpired:\n                    # send signal to the process group, because listening always hangs\n                    os.killpg(process.pid, signal.SIGINT)\n                    result = process.communicate()[0]\n                    _LOGGER.debug(\"Listening stopped forcefully after timeout.\")\n\n            result = result.decode(\"utf-8\").strip(' \\n\\t')\n            if \"Write Request failed\" in result:\n                raise BluetoothBackendException('Error writing handle to sensor: {}'.format(result))\n            _LOGGER.debug(\"Got %s from gatttool\", result)\n            # Parse the output to determine success\n            if \"successfully\" in result:\n                _LOGGER.debug(\"Exit write_ble with result (%s)\", current_thread())\n                # extract useful data.\n                for element in self.extract_notification_payload(result):\n                    delegate.handleNotification(handle, bytes([int(x, 16) for x in element.split()]))\n                return True\n\n            attempt += 1\n            _LOGGER.debug(\"Waiting for %s seconds before retrying\", delay)\n            if attempt < self.retries:\n                time.sleep(delay)\n                delay *= 2\n\n        raise BluetoothBackendException(\"Exit write_ble, no data ({})\".format(current_thread()))", "response": "Listen for characteristics changes from a BLE address."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extract_notification_payload(process_output):\n        data = []\n        for element in process_output.splitlines()[1:]:\n            parts = element.split(\": \")\n            if len(parts) == 2:\n                data.append(parts[1])\n        return data", "response": "Extracts the notification payload from Gatttool and returns it as a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if gatttool is available on the system.", "response": "def check_backend() -> bool:\n        \"\"\"Check if gatttool is available on the system.\"\"\"\n        try:\n            call('gatttool', stdout=PIPE, stderr=PIPE)\n            return True\n        except OSError as os_err:\n            msg = 'gatttool not found: {}'.format(str(os_err))\n            _LOGGER.error(msg)\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a byte array to a hex string.", "response": "def bytes_to_string(raw_data: bytes, prefix: bool = False) -> str:\n        \"\"\"Convert a byte array to a hex string.\"\"\"\n        prefix_string = ''\n        if prefix:\n            prefix_string = '0x'\n        suffix = ''.join([format(c, \"02x\") for c in raw_data])\n        return prefix_string + suffix.upper()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_field_references(ctx, field_names, simplify=False):\n    field_dict = {}\n    for field_name in field_names:\n        field = get_field(ctx, field_name)\n        if (\n            not simplify\n            or field is not None\n            and (not isinstance(field, list) or len(field) > 0)\n        ):\n            if isinstance(field, list):\n                value = [ctx.children.index(el) for el in field]\n            elif field is not None:\n                value = ctx.children.index(field)\n            else:\n                value = None\n            field_dict[field_name] = value\n    return field_dict", "response": "Create a mapping from fields to corresponding child indices"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreplace indices by actual elements in a reference mapping :param reference_dict: mapping str -> int | int[] :param source: list of elements :return: mapping str -> element | element[]", "response": "def materialize(reference_dict, source):\n    \"\"\"\n    Replace indices by actual elements in a reference mapping\n    :param reference_dict: mapping str -> int | int[]\n    :param source: list of elements\n    :return: mapping str -> element | element[]\n    \"\"\"\n    materialized_dict = {}\n    for field in reference_dict:\n        reference = reference_dict[field]\n        if isinstance(reference, list):\n            materialized_dict[field] = [source[index] for index in reference]\n        elif reference is not None:\n            materialized_dict[field] = source[reference]\n        else:\n            materialized_dict[field] = None\n    return materialized_dict"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_field_names(ctx):\n    # this does not include labels and literals, only rule names and token names\n    # TODO: check ANTLR parser template for full exclusion list\n    fields = [\n        field\n        for field in type(ctx).__dict__\n        if not field.startswith(\"__\")\n        and field not in [\"accept\", \"enterRule\", \"exitRule\", \"getRuleIndex\", \"copyFrom\"]\n    ]\n    return fields", "response": "Get the field names defined in an ANTLR context for a parser rule"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_label_names(ctx):\n    labels = [\n        label\n        for label in ctx.__dict__\n        if not label.startswith(\"_\")\n        and label\n        not in [\n            \"children\",\n            \"exception\",\n            \"invokingState\",\n            \"parentCtx\",\n            \"parser\",\n            \"start\",\n            \"stop\",\n        ]\n    ]\n    return labels", "response": "Get the names of the ANTLR labels defined in a parser rule."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_info(node_cfg):\n\n        node_cfg = node_cfg if isinstance(node_cfg, dict) else {\"name\": node_cfg}\n\n        return node_cfg.get(\"name\"), node_cfg.get(\"fields\", {})", "response": "Return a tuple with the verbal name of a node and a dict of field names."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef isinstance(self, instance, class_name):\n        if isinstance(instance, BaseNode):\n            klass = self.dynamic_node_classes.get(class_name, None)\n            if klass:\n                return isinstance(instance, klass)\n            # Not an instance of a class in the registry\n            return False\n        else:\n            raise TypeError(\"This function can only be used for BaseNode objects\")", "response": "Check if a BaseNode is an instance of a registered dynamic class"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nextending accumulator with Node ( s ) from new", "response": "def extend_node_list(acc, new):\n        \"\"\"Extend accumulator with Node(s) from new\"\"\"\n        if new is None:\n            new = []\n        elif not isinstance(new, list):\n            new = [new]\n        return acc + new"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget method to bind to visitor", "response": "def get_transformer(cls, method_name):\n        \"\"\"Get method to bind to visitor\"\"\"\n        transform_function = getattr(cls, method_name)\n        assert callable(transform_function)\n\n        def transformer_method(self, node):\n            kwargs = {}\n            if inspect.signature(transform_function).parameters.get(\"helper\"):\n                kwargs[\"helper\"] = self.helper\n            return transform_function(node, **kwargs)\n\n        return transformer_method"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef visitTerminal(self, ctx):\n        text = ctx.getText()\n        return Terminal.from_text(text, ctx)", "response": "Converts case insensitive keywords and identifiers to lowercase"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run(self, *args):\n        params = self.parser.parse_args(args)\n\n        entry = params.entry\n\n        if params.add:\n            code = self.add(entry)\n        elif params.delete:\n            code = self.delete(entry)\n        else:\n            term = entry\n            code = self.blacklist(term)\n\n        return code", "response": "List add or delete entries from the blacklist."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd entries to the blacklist.", "response": "def add(self, entry):\n        \"\"\"Add entries to the blacklist.\n\n        This method adds the given 'entry' to the blacklist.\n\n        :param entry: entry to add to the blacklist\n        \"\"\"\n        # Empty or None values for organizations are not allowed\n        if not entry:\n            return CMD_SUCCESS\n\n        try:\n            api.add_to_matching_blacklist(self.db, entry)\n        except InvalidValueError as e:\n            # If the code reaches here, something really wrong has happened\n            # because entry cannot be None or empty\n            raise RuntimeError(str(e))\n        except AlreadyExistsError as e:\n            msg = \"%s already exists in the registry\" % entry\n            self.error(msg)\n            return e.code\n\n        return CMD_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove entries from the blacklist.", "response": "def delete(self, entry):\n        \"\"\"Remove entries from the blacklist.\n\n        The method removes the given 'entry' from the blacklist.\n\n        :param entry: entry to remove from the blacklist\n        \"\"\"\n        if not entry:\n            return CMD_SUCCESS\n\n        try:\n            api.delete_from_matching_blacklist(self.db, entry)\n        except NotFoundError as e:\n            self.error(str(e))\n            return e.code\n\n        return CMD_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlisting blacklisted entries. When no term is given, the method will list the entries that exist in the blacklist. If 'term' is set, the method will list only those entries that match with that term. :param term: term to match", "response": "def blacklist(self, term=None):\n        \"\"\"List blacklisted entries.\n\n        When no term is given, the method will list the entries that\n        exist in the blacklist. If 'term' is set, the method will list\n        only those entries that match with that term.\n\n        :param term: term to match\n        \"\"\"\n        try:\n            bl = api.blacklist(self.db, term)\n            self.display('blacklist.tmpl', blacklist=bl)\n        except NotFoundError as e:\n            self.error(str(e))\n            return e.code\n\n        return CMD_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self, *args):\n        params = self.parser.parse_args(args)\n\n        config_file = os.path.expanduser('~/.sortinghat')\n\n        if params.action == 'get':\n            code = self.get(params.parameter, config_file)\n        elif params.action == 'set':\n            code = self.set(params.parameter, params.value, config_file)\n        else:\n            raise RuntimeError(\"Not get or set action given\")\n\n        return code", "response": "Get and set configuration parameters."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, key, filepath):\n        if not filepath:\n            raise RuntimeError(\"Configuration file not given\")\n\n        if not self.__check_config_key(key):\n            raise RuntimeError(\"%s parameter does not exists\" % key)\n\n        if not os.path.isfile(filepath):\n            raise RuntimeError(\"%s config file does not exist\" % filepath)\n\n        section, option = key.split('.')\n\n        config = configparser.SafeConfigParser()\n        config.read(filepath)\n\n        try:\n            option = config.get(section, option)\n            self.display('config.tmpl', key=key, option=option)\n        except (configparser.NoSectionError, configparser.NoOptionError):\n            pass\n\n        return CMD_SUCCESS", "response": "Get the configuration parameter."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite value on key in filepath to the configuration file given infilepath.", "response": "def set(self, key, value, filepath):\n        \"\"\"Set configuration parameter.\n\n        Writes 'value' on 'key' to the configuration file given in\n        'filepath'. Configuration parameter in 'key' must follow the schema\n        <section>.<option> .\n\n        :param key: key to set\n        :param value: value to set\n        :param filepath: configuration file\n        \"\"\"\n        if not filepath:\n            raise RuntimeError(\"Configuration file not given\")\n\n        if not self.__check_config_key(key):\n            raise RuntimeError(\"%s parameter does not exists or cannot be set\" % key)\n\n        config = configparser.SafeConfigParser()\n\n        if os.path.isfile(filepath):\n            config.read(filepath)\n\n        section, option = key.split('.')\n\n        if section not in config.sections():\n            config.add_section(section)\n\n        try:\n            config.set(section, option, value)\n        except TypeError as e:\n            raise RuntimeError(str(e))\n\n        try:\n            with open(filepath, 'w') as f:\n                config.write(f)\n        except IOError as e:\n            raise RuntimeError(str(e))\n\n        return CMD_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking whether the given key is valid.", "response": "def __check_config_key(self, key):\n        \"\"\"Check whether the key is valid.\n\n        A valid key has the schema <section>.<option>. Keys supported\n        are listed in CONFIG_OPTIONS dict.\n\n        :param key: <section>.<option> key\n        \"\"\"\n        try:\n            section, option = key.split('.')\n        except (AttributeError, ValueError):\n            return False\n\n        if not section or not option:\n            return False\n\n        return section in Config.CONFIG_OPTIONS and\\\n            option in Config.CONFIG_OPTIONS[section]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(self, *args):\n        params = self.parser.parse_args(args)\n\n        with params.outfile as outfile:\n            if params.identities:\n                code = self.export_identities(outfile, params.source)\n            elif params.orgs:\n                code = self.export_organizations(outfile)\n            else:\n                # The running proccess never should reach this section\n                raise RuntimeError(\"Unexpected export option\")\n\n        return code", "response": "Export data from the registry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexport unique identities information to a file.", "response": "def export_identities(self, outfile, source=None):\n        \"\"\"Export identities information to a file.\n\n        The method exports information related to unique identities, to\n        the given 'outfile' output file.\n\n        When 'source' parameter is given, only those unique identities which have\n        one or more identities from the given source will be exported.\n\n        :param outfile: destination file object\n        :param source: source of the identities to export\n        \"\"\"\n        exporter = SortingHatIdentitiesExporter(self.db)\n\n        dump = exporter.export(source)\n\n        try:\n            outfile.write(dump)\n            outfile.write('\\n')\n        except IOError as e:\n            raise RuntimeError(str(e))\n\n        return CMD_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef export_organizations(self, outfile):\n        exporter = SortingHatOrganizationsExporter(self.db)\n\n        dump = exporter.export()\n\n        try:\n            outfile.write(dump)\n            outfile.write('\\n')\n        except IOError as e:\n            raise RuntimeError(str(e))\n\n        return CMD_SUCCESS", "response": "This method exports organizations information related to the given object to a file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef export(self, source=None):\n        uidentities = {}\n\n        uids = api.unique_identities(self.db, source=source)\n\n        for uid in uids:\n            enrollments = [rol.to_dict()\n                           for rol in api.enrollments(self.db, uuid=uid.uuid)]\n\n            u = uid.to_dict()\n            u['identities'].sort(key=lambda x: x['id'])\n\n            uidentities[uid.uuid] = u\n            uidentities[uid.uuid]['enrollments'] = enrollments\n\n        blacklist = [mb.excluded for mb in api.blacklist(self.db)]\n\n        obj = {'time': str(datetime.datetime.now()),\n               'source': source,\n               'blacklist': blacklist,\n               'organizations': {},\n               'uidentities': uidentities}\n\n        return json.dumps(obj, default=self._json_encoder,\n                          indent=4, separators=(',', ': '),\n                          sort_keys=True)", "response": "Export a set of unique identities from the registry."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef export(self):\n        organizations = {}\n\n        orgs = api.registry(self.db)\n\n        for org in orgs:\n            domains = [{'domain': dom.domain,\n                        'is_top': dom.is_top_domain}\n                       for dom in org.domains]\n            domains.sort(key=lambda x: x['domain'])\n\n            organizations[org.name] = domains\n\n        obj = {'time': str(datetime.datetime.now()),\n               'blacklist': [],\n               'organizations': organizations,\n               'uidentities': {}}\n\n        return json.dumps(obj, default=self._json_encoder,\n                          indent=4, separators=(',', ': '),\n                          sort_keys=True)", "response": "Method to export a set of organizations."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef autocomplete(self, sources):\n        email_pattern = re.compile(EMAIL_ADDRESS_REGEX)\n\n        identities = self.__select_autocomplete_identities(sources)\n\n        for uuid, ids in identities.items():\n            # Among the identities (with the same priority) selected\n            # to complete the profile, it will choose the longest 'name'.\n            # If no name is available, it will use the field 'username'.\n            name = None\n            email = None\n\n            for identity in ids:\n                oldname = name\n\n                if not name:\n                    name = identity.name or identity.username\n                elif identity.name and len(identity.name) > len(name):\n                    name = identity.name\n\n                # Do not set email addresses on the name field\n                if name and email_pattern.match(name):\n                    name = oldname\n\n                if not email and identity.email:\n                    email = identity.email\n\n            kw = {\n                'name': name,\n                'email': email\n            }\n\n            try:\n                api.edit_profile(self.db, uuid, **kw)\n                self.display('autoprofile.tmpl', identity=identity)\n            except (NotFoundError, InvalidValueError) as e:\n                self.error(str(e))\n                return e.code\n\n        return CMD_SUCCESS", "response": "Autocomplete unique identities profiles using the information\n        field."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __select_autocomplete_identities(self, sources):\n\n        MIN_PRIORITY = 99999999\n\n        checked = {}\n\n        for source in sources:\n            uids = api.unique_identities(self.db, source=source)\n\n            for uid in uids:\n                if uid.uuid in checked:\n                    continue\n\n                max_priority = MIN_PRIORITY\n                selected = []\n\n                for identity in sorted(uid.identities, key=lambda x: x.id):\n                    try:\n                        priority = sources.index(identity.source)\n\n                        if priority < max_priority:\n                            selected = [identity]\n                            max_priority = priority\n                        elif priority == max_priority:\n                            selected.append(identity)\n                    except ValueError:\n                        continue\n\n                checked[uid.uuid] = selected\n\n        identities = collections.OrderedDict(sorted(checked.items(),\n                                             key=lambda t: t[0]))\n\n        return identities", "response": "Select the identities used for autocompleting"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nshowing information about unique identities.", "response": "def run(self, *args):\n        \"\"\"Show information about unique identities.\"\"\"\n\n        params = self.parser.parse_args(args)\n\n        code = self.show(params.uuid, params.term)\n\n        return code"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nshowing the information related to unique identities.", "response": "def show(self, uuid=None, term=None):\n        \"\"\"Show the information related to unique identities.\n\n        This method prints information related to unique identities such as\n        identities or enrollments.\n\n        When <uuid> is given, it will only show information about the unique\n        identity related to <uuid>.\n\n        When <term> is set, it will only show information about those unique\n        identities that have any attribute (name, email, username, source)\n        which match with the given term. This parameter does not have any\n        effect when <uuid> is set.\n\n        :param uuid: unique identifier\n        :param term: term to match with unique identities data\n        \"\"\"\n        try:\n            if uuid:\n                uidentities = api.unique_identities(self.db, uuid)\n            elif term:\n                uidentities = api.search_unique_identities(self.db, term)\n            else:\n                uidentities = api.unique_identities(self.db)\n\n            for uid in uidentities:\n                # Add enrollments to a new property 'roles'\n                enrollments = api.enrollments(self.db, uid.uuid)\n                uid.roles = enrollments\n\n            self.display('show.tmpl', uidentities=uidentities)\n        except NotFoundError as e:\n            self.error(str(e))\n            return e.code\n\n        return CMD_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __parse_organizations(self, json):\n        try:\n            for company in json['companies']:\n                name = self.__encode(company['company_name'])\n\n                org = self._organizations.get(name, None)\n\n                if not org:\n                    org = Organization(name=name)\n                    self._organizations[name] = org\n\n                for domain in company['domains']:\n                    if not domain:\n                        continue\n                    dom = Domain(domain=domain)\n                    org.domains.append(dom)\n        except KeyError as e:\n            msg = \"invalid json format. Attribute %s not found\" % e.args\n            raise InvalidFormatError(cause=msg)", "response": "Parse Stackalytics organizations.\n\n        The Stackalytics organizations format is a JSON document stored under the\n        \"companies\" key. The next JSON shows the structure of the\n        document:\n\n        {\n            \"companies\" : [\n                {\n                    \"domains\": [\"alcatel-lucent.com\"],\n                    \"company_name\": \"Alcatel-Lucent\",\n                    \"aliases\": [\"Alcatel Lucent\", \"Alcatel-Lcuent\"]\n                },\n                {\n                    \"domains\": [\"allegrogroup.com\", \"allegro.pl\"],\n                    \"company_name\": \"Allegro\",\n                    \"aliases\": [\"Allegro Group\", \"Grupa Allegro\", \"Grupa Allegro Sp. z o.o.\"]\n                },\n                {\n                    \"domains\": [\"altiscale.com\"],\n                    \"company_name\": \"Altiscale\"\n                },\n            ]\n        }\n\n        :param json: JSON object to parse\n\n        :raises InvalidFormatError: raised when the format of the JSON is\n            not valid."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __parse_identities(self, json):\n        try:\n            for user in json['users']:\n                name = self.__encode(user['user_name'])\n                uuid = name\n\n                uid = UniqueIdentity(uuid=uuid)\n                identity = Identity(name=name, email=None, username=None,\n                                    source=self.source, uuid=uuid)\n                uid.identities.append(identity)\n\n                for email_addr in user['emails']:\n                    email = self.__encode(email_addr)\n\n                    identity = Identity(name=name, email=email, username=None,\n                                        source=self.source, uuid=uuid)\n                    uid.identities.append(identity)\n\n                for site_id in ['gerrit_id', 'launchpad_id']:\n                    username = user.get(site_id, None)\n\n                    if not username:\n                        continue\n\n                    username = self.__encode(username)\n                    source = self.source + ':' + site_id.replace('_id', '')\n                    identity = Identity(name=name, email=None, username=username,\n                                        source=source, uuid=uuid)\n                    uid.identities.append(identity)\n\n                for rol in self.__parse_enrollments(user):\n                    uid.enrollments.append(rol)\n\n                self._identities[uuid] = uid\n        except KeyError as e:\n            msg = \"invalid json format. Attribute %s not found\" % e.args\n            raise InvalidFormatError(cause=msg)", "response": "Parse the identities in the Stackalytics format."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __load_json(self, stream):\n\n        import json\n\n        try:\n            return json.loads(stream)\n        except ValueError as e:\n            cause = \"invalid json format. %s\" % str(e)\n        raise InvalidFormatError(cause=cause)", "response": "Load a json stream into a dict object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __parse(self, stream, has_orgs):\n        if has_orgs:\n            self.__parse_organizations(stream)\n        else:\n            self.__parse_identities(stream)", "response": "Parse the contents of the mailmap stream into the internal data structures."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmerging two identities. When <from_uuid> or <to_uuid> are empty the command does not have any effect. The same happens when both <from_uuid> and <to_uuid> are the same unique identity.", "response": "def run(self, *args):\n        \"\"\"Merge two identities.\n\n        When <from_uuid> or <to_uuid> are empty the command does not have\n        any effect. The same happens when both <from_uuid> and <to_uuid>\n        are the same unique identity.\n        \"\"\"\n        params = self.parser.parse_args(args)\n\n        from_uuid = params.from_uuid\n        to_uuid = params.to_uuid\n\n        code = self.merge(from_uuid, to_uuid)\n\n        return code"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmerge one unique identity into another.", "response": "def merge(self, from_uuid, to_uuid):\n        \"\"\"Merge one unique identity into another.\n\n        Method that joins <from_uuid> unique identity into <to_uuid>.\n        Identities and enrollments related to <from_uuid> will be\n        assigned to <to_uuid>. In addition, <from_uuid> will be removed\n        from the registry. Duplicated enrollments will be also removed from the\n        registry.\n\n        Profile information will be updated with the values of <from_uuid> in the\n        case of <to_uuid> values were empty. If <from_uuid> was set as a bot,\n        <to_uuid> will be set too.\n\n        When <from_uuid> and <to_uuid> are equal, None or empty, the action does\n        not have any effect.\n\n        :param from_uuid: identifier of the unique identity set to merge\n        :param to_uuid: identifier of the unique identity where 'from_uuid'\n            will be merged\n        \"\"\"\n        if not from_uuid or not to_uuid:\n            return CMD_SUCCESS\n\n        try:\n            api.merge_unique_identities(self.db, from_uuid, to_uuid)\n            self.display('merge.tmpl',\n                         from_uuid=from_uuid, to_uuid=to_uuid)\n        except NotFoundError as e:\n            self.error(str(e))\n            return e.code\n\n        return CMD_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating an identity matcher object of the given type.", "response": "def create_identity_matcher(matcher='default', blacklist=None, sources=None,\n                            strict=True):\n    \"\"\"Create an identity matcher of the given type.\n\n    Factory function that creates an identity matcher object of the type\n    defined on 'matcher' parameter. A blacklist can also be added to\n    ignore those values while matching.\n\n    :param matcher: type of the matcher\n    :param blacklist: list of entries to ignore while matching\n    :param sources: only match the identities from these sources\n    :param strict: strict matching (i.e, well-formed email addresses)\n\n    :returns: a identity matcher object of the given type\n\n    :raises MatcherNotSupportedError: when the given matcher type is not\n        supported or available\n    \"\"\"\n    import sortinghat.matching as matching\n\n    if matcher not in matching.SORTINGHAT_IDENTITIES_MATCHERS:\n        raise MatcherNotSupportedError(matcher=str(matcher))\n\n    klass = matching.SORTINGHAT_IDENTITIES_MATCHERS[matcher]\n\n    return klass(blacklist=blacklist, sources=sources, strict=strict)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind matches in a set of unique identities.", "response": "def match(uidentities, matcher, fastmode=False):\n    \"\"\"Find matches in a set of unique identities.\n\n    This function looks for possible similar or equal identities from a set\n    of unique identities. The result will be a list of subsets where each\n    subset is a list of matching identities.\n\n    When `fastmode` is set a new and experimental matching algorithm\n    will be used. It consumes more resources (a big amount of memory)\n    but it is, at least, two orders of maginute faster than the\n    classic algorithm.\n\n    :param uidentities: list of unique identities to match\n    :param matcher: instance of the matcher\n    :param fastmode: use a faster algorithm\n\n    :returns: a list of subsets with the matched unique identities\n\n    :raises MatcherNotSupportedError: when matcher does not support fast\n        mode matching\n    :raises TypeError: when matcher is not an instance of\n        IdentityMatcher class\n    \"\"\"\n    if not isinstance(matcher, IdentityMatcher):\n        raise TypeError(\"matcher is not an instance of IdentityMatcher\")\n\n    if fastmode:\n        try:\n            matcher.matching_criteria()\n        except NotImplementedError:\n            name = \"'%s (fast mode)'\" % matcher.__class__.__name__.lower()\n            raise MatcherNotSupportedError(matcher=name)\n\n    filtered, no_filtered, uuids = \\\n        _filter_unique_identities(uidentities, matcher)\n\n    if not fastmode:\n        matched = _match(filtered, matcher)\n    else:\n        matched = _match_with_pandas(filtered, matcher)\n\n    matched = _build_matches(matched, uuids, no_filtered, fastmode)\n\n    return matched"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _match(filtered, matcher):\n\n    def match_filtered_identities(x, ids, matcher):\n        \"\"\"Check if an identity matches a set of identities\"\"\"\n\n        for y in ids:\n            if x.uuid == y.uuid:\n                return True\n            if matcher.match_filtered_identities(x, y):\n                return True\n        return False\n\n    # Find subsets of matches\n    matched = []\n\n    while filtered:\n        candidates = []\n        no_match = []\n\n        x = filtered.pop(0)\n\n        while matched:\n            ids = matched.pop(0)\n\n            if match_filtered_identities(x, ids, matcher):\n                candidates += ids\n            else:\n                no_match.append(ids)\n\n        candidates.append(x)\n\n        # Generate the new list of matched subsets\n        matched = [candidates] + no_match\n\n    return matched", "response": "Find matches in a set of filtered identities."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _match_with_pandas(filtered, matcher):\n\n    import pandas\n\n    data = [fl.to_dict() for fl in filtered]\n\n    if not data:\n        return []\n\n    df = pandas.DataFrame(data)\n    df = df.sort_values(['uuid'])\n\n    cdfs = []\n    criteria = matcher.matching_criteria()\n\n    for c in criteria:\n        cdf = df[['id', 'uuid', c]]\n        cdf = cdf.dropna(subset=[c])\n        cdf = pandas.merge(cdf, cdf, on=c, how='left')\n        cdf = cdf[['uuid_x', 'uuid_y']]\n        cdfs.append(cdf)\n\n    result = pandas.concat(cdfs)\n    result = result.drop_duplicates()\n    groups = result.groupby(by=['uuid_x'],\n                            as_index=True, sort=True)\n\n    matched = _calculate_matches_closures(groups)\n\n    return matched", "response": "Find matches in a set using Pandas library."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _filter_unique_identities(uidentities, matcher):\n    filtered = []\n    no_filtered = []\n    uuids = {}\n\n    for uidentity in uidentities:\n        n = len(filtered)\n        filtered += matcher.filter(uidentity)\n\n        if len(filtered) > n:\n            uuids[uidentity.uuid] = uidentity\n        else:\n            no_filtered.append([uidentity])\n\n    return filtered, no_filtered, uuids", "response": "Filter a set of unique identities."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild a list with matching subsets", "response": "def _build_matches(matches, uuids, no_filtered, fastmode=False):\n    \"\"\"Build a list with matching subsets\"\"\"\n\n    result = []\n\n    for m in matches:\n        mk = m[0].uuid if not fastmode else m[0]\n        subset = [uuids[mk]]\n\n        for id_ in m[1:]:\n            uk = id_.uuid if not fastmode else id_\n            u = uuids[uk]\n\n            if u not in subset:\n                subset.append(u)\n\n        result.append(subset)\n\n    result += no_filtered\n    result.sort(key=len, reverse=True)\n\n    sresult = []\n    for r in result:\n        r.sort(key=lambda id_: id_.uuid)\n        sresult.append(r)\n\n    return sresult"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding the transitive closure of each unique identity. This function uses a BFS algorithm to build set of matches. For instance, given a list of matched unique identities like A = {A, B}; B = {B,A,C}, C = {C,} and D = {D,} the output will be A = {A, B, C} and D = {D,}. :param groups: groups of unique identities", "response": "def _calculate_matches_closures(groups):\n    \"\"\"Find the transitive closure of each unique identity.\n\n    This function uses a BFS algorithm to build set of matches.\n    For instance, given a list of matched unique identities like\n    A = {A, B}; B = {B,A,C}, C = {C,} and D = {D,} the output\n    will be A = {A, B, C} and D = {D,}.\n\n    :param groups: groups of unique identities\n    \"\"\"\n    matches = []\n\n    ns = sorted(groups.groups.keys())\n\n    while ns:\n        n = ns.pop(0)\n        visited = [n]\n        vs = [v for v in groups.get_group(n)['uuid_y']]\n\n        while vs:\n            v = vs.pop(0)\n\n            if v in visited:\n                continue\n\n            nvs = [nv for nv in groups.get_group(v)['uuid_y']]\n            vs += nvs\n            visited.append(v)\n\n            try:\n                ns.remove(v)\n            except:\n                pass\n\n        matches.append(visited)\n\n    return matches"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndetermine if two unique identities are the same.", "response": "def match(self, a, b):\n        \"\"\"Determine if two unique identities are the same.\n\n        This method compares the email addresses or the names of each\n        identity to check if the given unique identities are the same.\n        When the given unique identities are the same object or share\n        the same UUID, this will also produce a positive match.\n\n        Identities which their email addresses or names are in the blacklist\n        will be ignored during the matching.\n\n        :param a: unique identity to match\n        :param b: unique identity to match\n\n        :returns: True when both unique identities are likely to be the same.\n            Otherwise, returns False.\n\n        :raises ValueError: when any of the given unique identities is not\n            an instance of UniqueIdentity class\n        \"\"\"\n        if not isinstance(a, UniqueIdentity):\n            raise ValueError(\"<a> is not an instance of UniqueIdentity\")\n        if not isinstance(b, UniqueIdentity):\n            raise ValueError(\"<b> is not an instance of UniqueIdentity\")\n\n        if a.uuid and b.uuid and a.uuid == b.uuid:\n            return True\n\n        filtered_a = self.filter(a)\n        filtered_b = self.filter(b)\n\n        for fa in filtered_a:\n            for fb in filtered_b:\n                if self.match_filtered_identities(fa, fb):\n                    return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if the given identities are the same.", "response": "def match_filtered_identities(self, fa, fb):\n        \"\"\"Determine if two filtered identities are the same.\n\n        The method compares the email addresses or the names of each\n        filtered identity to check if they are the same. When the given\n        filtered identities are the same object or share the same UUID,\n        this will also produce a positive match.\n\n        Identities which their email addresses or names are in the blacklist\n        will be ignored and the result of the comparison will be false.\n\n        :param fa: filtered identity to match\n        :param fb: filtered identity to match\n\n        :returns: True when both filtered identities are likely to be the same.\n            Otherwise, returns False.\n\n        :raises ValueError: when any of the given filtered identities is not\n            an instance of EmailNameIdentity class.\n        \"\"\"\n        if not isinstance(fa, EmailNameIdentity):\n            raise ValueError(\"<fa> is not an instance of UniqueIdentity\")\n        if not isinstance(fb, EmailNameIdentity):\n            raise ValueError(\"<fb> is not an instance of EmailNameIdentity\")\n\n        if fa.uuid and fb.uuid and fa.uuid == fb.uuid:\n            return True\n\n        if self._check_blacklist(fa):\n            return False\n\n        # Compare email addresses first\n        if fa.email and fa.email == fb.email:\n            return True\n\n        # No match yet, so compare names\n        if fa.name and fa.name == fb.name:\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef filter(self, u):\n        if not isinstance(u, UniqueIdentity):\n            raise ValueError(\"<u> is not an instance of UniqueIdentity\")\n\n        filtered = []\n\n        for id_ in u.identities:\n            email = None\n            name = None\n\n            if self.sources and id_.source.lower() not in self.sources:\n                continue\n\n            if self._check_blacklist(id_):\n                continue\n\n            if self.strict:\n                if self._check_pattern(self.email_pattern, id_.email):\n                    email = id_.email.lower()\n                if self._check_pattern(self.name_pattern, id_.name):\n                    name = id_.name.lower()\n            else:\n                email = id_.email.lower() if id_.email else None\n                name = id_.name.lower() if id_.name else None\n\n            if email or name:\n                fid = EmailNameIdentity(id_.id, id_.uuid,\n                                        email, name)\n                filtered.append(fid)\n\n        return filtered", "response": "Filter the valid identities for this matcher."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind a unique identity by its UUID using the given session.", "response": "def find_unique_identity(session, uuid):\n    \"\"\"Find a unique identity.\n\n    Find a unique identity by its UUID using the given `session`.\n    When the unique identity does not exist the function will\n    return `None`.\n\n    :param session: database session\n    :param uuid: id of the unique identity to find\n\n    :returns: a unique identity object; `None` when the unique\n        identity does not exist\n    \"\"\"\n    uidentity = session.query(UniqueIdentity). \\\n        filter(UniqueIdentity.uuid == uuid).first()\n\n    return uidentity"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_identity(session, id_):\n    identity = session.query(Identity). \\\n        filter(Identity.id == id_).first()\n\n    return identity", "response": "Find an identity by its ID using the given session."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_organization(session, name):\n    organization = session.query(Organization). \\\n        filter(Organization.name == name).first()\n\n    return organization", "response": "Find an organization by its name using the given session."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds a domain by its domain name using the given session.", "response": "def find_domain(session, name):\n    \"\"\"Find a domain.\n\n    Find a domain by its domain name using the given `session`.\n    When the domain does not exist the function will\n    return `None`.\n\n    :param session: database session\n    :param name: name of the domain to find\n\n    :returns: a domain object; `None` when the domain\n        does not exist\n    \"\"\"\n    domain = session.query(Domain). \\\n        filter(Domain.domain == name).first()\n\n    return domain"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_country(session, code):\n    country = session.query(Country).\\\n        filter(Country.code == code).first()\n\n    return country", "response": "Find a country by its ISO - 3166 code."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a unique identity to the database session.", "response": "def add_unique_identity(session, uuid):\n    \"\"\"Add a unique identity to the session.\n\n    This function adds a unique identity to the session with\n    `uuid` string as unique identifier. This identifier cannot\n    be empty or `None`.\n\n    When the unique identity is added, a new empty profile for\n    this object is created too.\n\n    As a result, the function returns a new `UniqueIdentity`\n    object.\n\n    :param session: database session\n    :param uuid: unique identifier for the unique identity\n\n    :return: a new unique identity\n\n    :raises ValueError: when `uuid` is `None` or an empty string\n    \"\"\"\n    if uuid is None:\n        raise ValueError(\"'uuid' cannot be None\")\n    if uuid == '':\n        raise ValueError(\"'uuid' cannot be an empty string\")\n\n    uidentity = UniqueIdentity(uuid=uuid)\n    uidentity.profile = Profile()\n    uidentity.last_modified = datetime.datetime.utcnow()\n\n    session.add(uidentity)\n\n    return uidentity"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_identity(session, uidentity, identity_id, source,\n                 name=None, email=None, username=None):\n    \"\"\"Add an identity to the session.\n\n    This function adds a new identity to the session using\n    `identity_id` as its identifier. The new identity will\n    also be linked to the unique identity object of `uidentity`.\n\n    Neither the values given to `identity_id` nor to `source` can\n    be `None` or empty. Moreover, `name`, `email` or `username`\n    parameters need a non empty value.\n\n    As a result, the function returns a new `Identity` object.\n\n    :param session: database session\n    :param uidentity: links the new identity to this unique identity object\n    :param identity_id: identifier for the new identity\n    :param source: data source where this identity was found\n    :param name: full name of the identity\n    :param email: email of the identity\n    :param username: user name used by the identity\n\n    :return: a new identity\n\n    :raises ValueError: when `identity_id` and `source` are `None` or empty;\n        when all of the data parameters are `None` or empty.\n    \"\"\"\n    if identity_id is None:\n        raise ValueError(\"'identity_id' cannot be None\")\n    if identity_id == '':\n        raise ValueError(\"'identity_id' cannot be an empty string\")\n    if source is None:\n        raise ValueError(\"'source' cannot be None\")\n    if source == '':\n        raise ValueError(\"'source' cannot be an empty string\")\n    if not (name or email or username):\n        raise ValueError(\"identity data cannot be None or empty\")\n\n    identity = Identity(id=identity_id, name=name, email=email,\n                        username=username, source=source)\n    identity.last_modified = datetime.datetime.utcnow()\n    identity.uidentity = uidentity\n    identity.uidentity.last_modified = identity.last_modified\n\n    session.add(identity)\n\n    return identity", "response": "Add an identity to the database using the given identity_id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_identity(session, identity):\n    uidentity = identity.uidentity\n    uidentity.last_modified = datetime.datetime.utcnow()\n\n    session.delete(identity)\n    session.flush()", "response": "Removes an identity from the session."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_organization(session, name):\n    if name is None:\n        raise ValueError(\"'name' cannot be None\")\n    if name == '':\n        raise ValueError(\"'name' cannot be an empty string\")\n\n    organization = Organization(name=name)\n\n    session.add(organization)\n\n    return organization", "response": "Add an organization to the session."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove an organization from the session.", "response": "def delete_organization(session, organization):\n    \"\"\"Remove an organization from the session.\n\n    Function that removes from the session the organization\n    given in `organization`. Data related such as domains\n    or enrollments are also removed.\n\n    :param session: database session\n    :param organization: organization to remove\n    \"\"\"\n    last_modified = datetime.datetime.utcnow()\n\n    for enrollment in organization.enrollments:\n        enrollment.uidentity.last_modified = last_modified\n\n    session.delete(organization)\n    session.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a domain to the database session using the specified organization and domain name.", "response": "def add_domain(session, organization, domain_name, is_top_domain=False):\n    \"\"\"Add a domain to the session.\n\n    This function adds a new domain to the session using\n    `domain_name` as its identifier. The new domain will\n    also be linked to the organization object of `organization`.\n\n    Values assigned to `domain_name` cannot be `None` or empty.\n    The parameter `is_top_domain` only accepts `bool` values.\n\n    As a result, the function returns a new `Domain` object.\n\n    :param session: database session\n    :param organization: links the new domain to this organization object\n    :param domain_name: name of the domain\n    :param is_top_domain: set this domain as a top domain\n\n    :return: a new domain\n\n    :raises ValueError: raised when `domain_name` is `None` or an empty;\n        when `is_top_domain` does not have a `bool` value.\n    \"\"\"\n    if domain_name is None:\n        raise ValueError(\"'domain_name' cannot be None\")\n    if domain_name == '':\n        raise ValueError(\"'domain_name' cannot be an empty string\")\n    if not isinstance(is_top_domain, bool):\n        raise ValueError(\"'is_top_domain' must have a boolean value\")\n\n    dom = Domain(domain=domain_name, is_top_domain=is_top_domain)\n    dom.organization = organization\n\n    session.add(dom)\n\n    return dom"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nenroll a unique identity to an organization.", "response": "def enroll(session, uidentity, organization,\n           from_date=MIN_PERIOD_DATE, to_date=MAX_PERIOD_DATE):\n    \"\"\"Enroll a unique identity to an organization.\n\n    The function adds a new relationship between the unique\n    identity in `uidentity` and the given `organization` for\n    the current session.\n\n    The period of the enrollment can be given with the parameters\n    `from_date` and `to_date`, where `from_date <= to_date`.\n    Default values for these dates are `MIN_PERIOD_DATE` and\n    `MAX_PERIOD_DATE`. These dates cannot be `None`.\n\n    This function returns as result a new `Enrollment` object.\n\n    :param session: database session\n    :param uidentity: unique identity to enroll\n    :param organization: organization where the unique identity is enrolled\n    :param from_date: date when the enrollment starts\n    :param to_date: date when the enrollment ends\n\n    :return: a new enrollment\n\n    :raises ValeError: when either `from_date` or `to_date` are `None`;\n        when `from_date < MIN_PERIOD_DATE`; or `to_date > MAX_PERIOD_DATE`\n        or `from_date > to_date`.\n    \"\"\"\n    if not from_date:\n        raise ValueError(\"'from_date' cannot be None\")\n    if not to_date:\n        raise ValueError(\"'to_date' cannot be None\")\n\n    if from_date < MIN_PERIOD_DATE or from_date > MAX_PERIOD_DATE:\n        raise ValueError(\"'from_date' %s is out of bounds\" % str(from_date))\n    if to_date < MIN_PERIOD_DATE or to_date > MAX_PERIOD_DATE:\n        raise ValueError(\"'to_date' %s is out of bounds\" % str(to_date))\n    if from_date > to_date:\n        raise ValueError(\"'from_date' %s cannot be greater than %s\"\n                         % (from_date, to_date))\n\n    enrollment = Enrollment(uidentity=uidentity,\n                            organization=organization,\n                            start=from_date, end=to_date)\n    uidentity.last_modified = datetime.datetime.utcnow()\n\n    session.add(enrollment)\n\n    return enrollment"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef withdraw(session, uidentity, organization,\n             from_date=MIN_PERIOD_DATE, to_date=MAX_PERIOD_DATE):\n    \"\"\"Withdraw a unique identity from an organization.\n\n    Removes all the enrollments between the unique identity in\n    `uidentity` and the given 'organization'.\n\n    When a period of time is given using `from_date` and `to_date`\n    parameters, the function will remove those periods on which\n    `from_date` <= enrollment <= `to_date`. Default values for\n    these dates are `MIN_PERIOD_DATE` and `MAX_PERIOD_DATE`.\n    These dates cannot be `None`.\n\n    :param session: database session\n    :param uidentity: unique identity to withdraw\n    :param organization: organization where the unique identity is withdrawn\n    :param from_date: date when the enrollment starts\n    :param to_date: date when the enrollment ends\n\n    :return: number of removed enrollments\n\n    :raises ValeError: when either `from_date` or `to_date` are `None`;\n        when `from_date < MIN_PERIOD_DATE`; or `to_date > MAX_PERIOD_DATE`\n        or `from_date > to_date`.\n    \"\"\"\n    if not from_date:\n        raise ValueError(\"'from_date' cannot be None\")\n    if not to_date:\n        raise ValueError(\"'to_date' cannot be None\")\n\n    if from_date < MIN_PERIOD_DATE or from_date > MAX_PERIOD_DATE:\n        raise ValueError(\"'from_date' %s is out of bounds\" % str(from_date))\n    if to_date < MIN_PERIOD_DATE or to_date > MAX_PERIOD_DATE:\n        raise ValueError(\"'to_date' %s is out of bounds\" % str(to_date))\n    if from_date > to_date:\n        raise ValueError(\"'from_date' %s cannot be greater than %s\"\n                         % (from_date, to_date))\n\n    enrollments = session.query(Enrollment).\\\n        filter(Enrollment.uidentity == uidentity,\n               Enrollment.organization == organization,\n               from_date <= Enrollment.start,\n               Enrollment.end <= to_date).all()\n\n    ndeleted = 0\n\n    for enrollment in enrollments:\n        session.delete(enrollment)\n        ndeleted += 1\n\n    if ndeleted > 0:\n        uidentity.last_modified = datetime.datetime.utcnow()\n        session.flush()\n\n    return ndeleted", "response": "Withdraw a unique identity from an organization."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_enrollment(session, enrollment):\n    uidentity = enrollment.uidentity\n    uidentity.last_modified = datetime.datetime.utcnow()\n\n    session.delete(enrollment)\n    session.flush()", "response": "Removes an enrollment from the session."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nedits unique identity profile.", "response": "def edit_profile(session, uidentity, **kwargs):\n    \"\"\"Edit unique identity profile.\n\n    This function allows to edit or update the profile information\n    of the given unique identity. The values to update are given\n    as keyword arguments. The allowed keys are listed below\n    (other keywords will be ignored):\n\n       - `name`: name of the unique identity\n       - `email`: email address of the unique identity\n       - `gender`: gender of the unique identity\n       - `gender_acc`: gender accuracy (range of 1 to 100; by default, set to 100)\n       - `is_bot`: boolean value to determine whether a unique identity is\n             a bot or not. By default, this value is initialized to\n             `False`.\n       - `country_code`: ISO-3166 country code\n\n    As a result, it will return a `Profile` object with the updated data.\n\n    :param session: database session\n    :param uidentity: unique identity whose profile will be edited\n    :param kwargs: parameters to edit the profile\n\n    :return: the edited profile\n\n    :raises ValueError: raised when `is_bot` does not have a boolean value;\n        `gender_acc` is not an `int` or is not in range.\n    \"\"\"\n    def to_none_if_empty(x):\n        return None if not x else x\n\n    profile = uidentity.profile\n\n    if 'name' in kwargs:\n        profile.name = to_none_if_empty(kwargs['name'])\n    if 'email' in kwargs:\n        profile.email = to_none_if_empty(kwargs['email'])\n\n    if 'is_bot' in kwargs:\n        is_bot = kwargs['is_bot']\n\n        if not isinstance(is_bot, bool):\n            raise ValueError(\"'is_bot' must have a boolean value\")\n\n        profile.is_bot = is_bot\n\n    if 'country_code' in kwargs:\n        code = to_none_if_empty(kwargs['country_code'])\n        country_code = None\n\n        if code:\n            country = find_country(session, code)\n\n            if not country:\n                raise ValueError(\"'country_code' (%s) does not match with a valid code\"\n                                 % str(code))\n\n            country_code = country.code\n\n        profile.country_code = country_code\n\n    if 'gender' in kwargs:\n        gender = to_none_if_empty(kwargs['gender'])\n        gender_acc = None\n\n        if gender:\n            gender_acc = kwargs.get('gender_acc', 100)\n\n            if not isinstance(gender_acc, int):\n                raise ValueError(\"'gender_acc' must have an integer value\")\n            elif not 1 <= gender_acc <= 100:\n                raise ValueError(\"'gender_acc' (%d) is not in range (1,100)\"\n                                 % gender_acc)\n\n        profile.gender = gender\n        profile.gender_acc = gender_acc\n    elif 'gender_acc' in kwargs:\n        raise ValueError(\"'gender_acc' can only be set when 'gender' is given\")\n\n    uidentity.last_modified = datetime.datetime.utcnow()\n\n    session.add(profile)\n\n    return profile"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef move_identity(session, identity, uidentity):\n    if identity.uuid == uidentity.uuid:\n        return False\n\n    old_uidentity = identity.uidentity\n    identity.uidentity = uidentity\n\n    last_modified = datetime.datetime.utcnow()\n\n    old_uidentity.last_modified = last_modified\n    uidentity.last_modified = last_modified\n    identity.last_modified = last_modified\n\n    session.add(uidentity)\n    session.add(old_uidentity)\n\n    return True", "response": "Move an identity to a unique identity."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef move_enrollment(session, enrollment, uidentity):\n    if enrollment.uuid == uidentity.uuid:\n        return False\n\n    old_uidentity = enrollment.uidentity\n    enrollment.uidentity = uidentity\n\n    last_modified = datetime.datetime.utcnow()\n\n    old_uidentity.last_modified = last_modified\n    uidentity.last_modified = last_modified\n\n    session.add(uidentity)\n    session.add(old_uidentity)\n\n    return True", "response": "Moves an enrollment to a unique identity."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a term to the matching blacklist.", "response": "def add_to_matching_blacklist(session, term):\n    \"\"\"Add term to the matching blacklist.\n\n    This function adds a `term` to the matching blacklist.\n    The term to add cannot have a `None` or empty value,\n    on this case an `ValueError` will be raised.\n\n    :param session: database session\n    :param term: term, word or value to blacklist\n\n    :return: a new entry in the blacklist\n\n    :raises ValueError: raised when `term` is `None` or an empty string\n    \"\"\"\n    if term is None:\n        raise ValueError(\"'term' to blacklist cannot be None\")\n    if term == '':\n        raise ValueError(\"'term' to blacklist cannot be an empty string\")\n\n    mb = MatchingBlacklist(excluded=term)\n    session.add(mb)\n\n    return mb"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef genderize(name, api_token=None):\n\n    GENDERIZE_API_URL = \"https://api.genderize.io/\"\n    TOTAL_RETRIES = 10\n    MAX_RETRIES = 5\n    SLEEP_TIME = 0.25\n    STATUS_FORCELIST = [502]\n\n    params = {\n        'name': name\n    }\n\n    if api_token:\n        params['apikey'] = api_token\n\n    session = requests.Session()\n\n    retries = urllib3.util.Retry(total=TOTAL_RETRIES,\n                                 connect=MAX_RETRIES,\n                                 status=MAX_RETRIES,\n                                 status_forcelist=STATUS_FORCELIST,\n                                 backoff_factor=SLEEP_TIME,\n                                 raise_on_status=True)\n\n    session.mount('http://', requests.adapters.HTTPAdapter(max_retries=retries))\n    session.mount('https://', requests.adapters.HTTPAdapter(max_retries=retries))\n\n    r = session.get(GENDERIZE_API_URL, params=params)\n    r.raise_for_status()\n    result = r.json()\n\n    gender = result['gender']\n    prob = result.get('probability', None)\n\n    acc = int(prob * 100) if prob else None\n\n    return gender, acc", "response": "Fetch gender from genderize. io"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __parse_identities(self, json):\n        try:\n            for mozillian in json['results']:\n                name = self.__encode(mozillian['full_name']['value'])\n                email = self.__encode(mozillian['email']['value'])\n                username = self.__encode(mozillian['username'])\n                uuid = username\n\n                uid = UniqueIdentity(uuid=uuid)\n                identity = Identity(name=name, email=email, username=username,\n                                    source=self.source, uuid=uuid)\n                uid.identities.append(identity)\n\n                # Alternate emails\n                for alt_email in mozillian['alternate_emails']:\n                    alt_email = self.__encode(alt_email['email'])\n\n                    if alt_email == email:\n                        continue\n\n                    identity = Identity(name=name, email=alt_email, username=username,\n                                        source=self.source, uuid=uuid)\n                    uid.identities.append(identity)\n\n                # IRC account\n                ircname = self.__encode(mozillian['ircname']['value'])\n\n                if ircname and ircname != username:\n                    identity = Identity(name=None, email=None, username=ircname,\n                                        source=self.source, uuid=uuid)\n                    uid.identities.append(identity)\n\n                # Mozilla affiliation\n                affiliation = mozillian['date_mozillian']\n                rol = self.__parse_mozillian_affiliation(affiliation)\n                uid.enrollments.append(rol)\n\n                self._identities[uuid] = uid\n        except KeyError as e:\n            msg = \"invalid json format. Attribute %s not found\" % e.args\n            raise InvalidFormatError(cause=msg)", "response": "Parse the identities in the JSON document using Mozillians format."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlist add or delete organizations and domains from the registry.", "response": "def run(self, *args):\n        \"\"\"List, add or delete organizations and domains from the registry.\n\n        By default, it prints the list of organizations available on\n        the registry.\n        \"\"\"\n        params = self.parser.parse_args(args)\n\n        organization = params.organization\n        domain = params.domain\n        is_top_domain = params.top_domain\n        overwrite = params.overwrite\n\n        if params.add:\n            code = self.add(organization, domain, is_top_domain, overwrite)\n        elif params.delete:\n            code = self.delete(organization, domain)\n        else:\n            term = organization\n            code = self.registry(term)\n\n        return code"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add(self, organization, domain=None, is_top_domain=False, overwrite=False):\n        # Empty or None values for organizations are not allowed\n        if not organization:\n            return CMD_SUCCESS\n\n        if not domain:\n            try:\n                api.add_organization(self.db, organization)\n            except InvalidValueError as e:\n                # If the code reaches here, something really wrong has happened\n                # because organization cannot be None or empty\n                raise RuntimeError(str(e))\n            except AlreadyExistsError as e:\n                msg = \"organization '%s' already exists in the registry\" % organization\n                self.error(msg)\n                return e.code\n        else:\n            try:\n                api.add_domain(self.db, organization, domain,\n                               is_top_domain=is_top_domain,\n                               overwrite=overwrite)\n            except InvalidValueError as e:\n                # Same as above, domains cannot be None or empty\n                raise RuntimeError(str(e))\n            except AlreadyExistsError as e:\n                msg = \"domain '%s' already exists in the registry\" % domain\n                self.error(msg)\n                return e.code\n            except NotFoundError as e:\n                self.error(str(e))\n                return e.code\n\n        return CMD_SUCCESS", "response": "Add organizations and domains to the registry."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves organizations and domains from the registry.", "response": "def delete(self, organization, domain=None):\n        \"\"\"Remove organizations and domains from the registry.\n\n        The method removes the given 'organization' or 'domain' from the registry,\n        but not both at the same time.\n\n        When 'organization' is the only parameter given, it will be removed from\n        the registry, including those domains related to it. When 'domain' parameter\n        is also given, only the domain will be deleted. 'organization' must exists in\n        the registry prior removing the domain.\n\n        :param organization: name of the organization to remove\n        :param domain: domain to remove from the registry\n        \"\"\"\n        if not organization:\n            return CMD_SUCCESS\n\n        if not domain:\n            try:\n                api.delete_organization(self.db, organization)\n            except NotFoundError as e:\n                self.error(str(e))\n                return e.code\n        else:\n            try:\n                api.delete_domain(self.db, organization, domain)\n            except NotFoundError as e:\n                self.error(str(e))\n                return e.code\n\n        return CMD_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef registry(self, term=None):\n        try:\n            orgs = api.registry(self.db, term)\n            self.display('organizations.tmpl', organizations=orgs)\n        except NotFoundError as e:\n            self.error(str(e))\n            return e.code\n\n        return CMD_SUCCESS", "response": "List organizations and domains."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef match_filtered_identities(self, fa, fb):\n        if not isinstance(fa, UsernameIdentity):\n            raise ValueError(\"<fa> is not an instance of UsernameIdentity\")\n        if not isinstance(fb, UsernameIdentity):\n            raise ValueError(\"<fb> is not an instance of UsernameIdentity\")\n\n        if fa.uuid and fb.uuid and fa.uuid == fb.uuid:\n            return True\n\n        if fa.username in self.blacklist:\n            return False\n\n        # Compare username first\n        if fa.username and fa.username == fb.username:\n            return True\n\n        return False", "response": "Returns True if two filtered identities are the same."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef filter(self, u):\n        if not isinstance(u, UniqueIdentity):\n            raise ValueError(\"<u> is not an instance of UniqueIdentity\")\n\n        filtered = []\n\n        for id_ in u.identities:\n            username = None\n\n            if self.sources and id_.source.lower() not in self.sources:\n                continue\n\n            if self._check_username(id_.username):\n                username = id_.username.lower()\n\n            if username:\n                fid = UsernameIdentity(id_.id, id_.uuid, username)\n                filtered.append(fid)\n\n        return filtered", "response": "Filter the valid identities for this matcher."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_organizations_parser(stream):\n    import sortinghat.parsing as parsing\n\n    # First, try with default parser\n    for p in parsing.SORTINGHAT_ORGS_PARSERS:\n        klass = parsing.SORTINGHAT_ORGS_PARSERS[p]\n\n        parser = klass()\n\n        if parser.check(stream):\n            return parser\n    raise InvalidFormatError(cause=INVALID_FORMAT_MSG)", "response": "Create an organizations parser for the given stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nenroll a unique identity in an organization.", "response": "def enroll(self, uuid, organization, from_date=MIN_PERIOD_DATE, to_date=MAX_PERIOD_DATE,\n               merge=False):\n        \"\"\"Enroll a unique identity in an organization.\n\n        This method adds a new relationship between the unique identity,\n        identified by <uuid>, and <organization>. Both entities must exist\n        on the registry before creating the new enrollment.\n\n        The period of the enrollment can be given with the parameters <from_date>\n        and <to_date>, where \"from_date <= to_date\". Default values for these\n        dates are '1900-01-01' and '2100-01-01'.\n\n        When \"merge\" parameter is set to True, those overlapped enrollments related\n        to <uuid> and <organization> found on the registry will be merged. The given\n        enrollment will be also merged.\n\n        :param uuid: unique identifier\n        :param organization: name of the organization\n        :param from_date: date when the enrollment starts\n        :param to_date: date when the enrollment ends\n        :param merge: merge overlapped enrollments; by default, it is set to False\n        \"\"\"\n        # Empty or None values for uuid and organizations are not allowed\n        if not uuid or not organization:\n            return CMD_SUCCESS\n\n        try:\n            api.add_enrollment(self.db, uuid, organization, from_date, to_date)\n            code = CMD_SUCCESS\n        except (NotFoundError, InvalidValueError) as e:\n            self.error(str(e))\n            code = e.code\n        except AlreadyExistsError as e:\n            if not merge:\n                msg_data = {\n                    'uuid': uuid,\n                    'org': organization,\n                    'from_dt': str(from_date),\n                    'to_dt': str(to_date)\n                }\n                msg = \"enrollment for '%(uuid)s' at '%(org)s' (from: %(from_dt)s, to: %(to_dt)s) already exists in the registry\"\n                msg = msg % msg_data\n                self.error(msg)\n                code = e.code\n\n        if not merge:\n            return code\n\n        try:\n            api.merge_enrollments(self.db, uuid, organization)\n        except (NotFoundError, InvalidValueError) as e:\n            # These exceptions were checked above. If any of these raises\n            # is due to something really wrong has happened\n            raise RuntimeError(str(e))\n\n        return CMD_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the JSON document of the Eclipse identities format.", "response": "def __parse_identities(self, json):\n        \"\"\"Parse identities using Eclipse format.\n\n        The Eclipse identities format is a JSON document under the \"commiters\"\n        key. The document should follow the next schema:\n\n        {\n          'committers' : {\n              'john': {\n                  'affiliations': {\n                      '1': {\n                          'active': '2001-01-01',\n                          'inactive': null,\n                          'name': 'Organization 1'\n                      }\n                  },\n                  'email': [\n                      'john@example.com'\n                  ],\n                  'first': 'John',\n                  'id': 'john',\n                  'last': 'Doe',\n                  'primary': 'john.doe@example.com'\n              }\n          }\n        }\n\n        :parse json: JSON object to parse\n\n        :raise InvalidFormatError: raised when the format of the JSON is\n            not valid.\n        \"\"\"\n        try:\n            for committer in json['committers'].values():\n                name = self.__encode(committer['first'] + ' ' + committer['last'])\n                email = self.__encode(committer['primary'])\n                username = self.__encode(committer['id'])\n                uuid = username\n\n                uid = UniqueIdentity(uuid=uuid)\n                identity = Identity(name=name, email=email, username=username,\n                                    source=self.source, uuid=uuid)\n                uid.identities.append(identity)\n\n                if 'email' in committer:\n                    for alt_email in committer['email']:\n                        alt_email = self.__encode(alt_email)\n\n                        if alt_email == email:\n                            continue\n\n                        identity = Identity(name=name, email=alt_email, username=username,\n                                            source=self.source, uuid=uuid)\n                        uid.identities.append(identity)\n\n                if 'affiliations' in committer:\n                    enrollments = self.__parse_affiliations_json(committer['affiliations'],\n                                                                 uuid)\n                    for rol in enrollments:\n                        uid.enrollments.append(rol)\n\n                self._identities[uuid] = uid\n        except KeyError as e:\n            msg = \"invalid json format. Attribute %s not found\" % e.args\n            raise InvalidFormatError(cause=msg)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __parse_organizations(self, json):\n        try:\n            for organization in json['organizations'].values():\n                name = self.__encode(organization['name'])\n\n                try:\n                    active = str_to_datetime(organization['active'])\n                    inactive = str_to_datetime(organization['inactive'])\n\n                    # Ignore organization\n                    if not active and not inactive:\n                        continue\n\n                    if not active:\n                        active = MIN_PERIOD_DATE\n                    if not inactive:\n                        inactive = MAX_PERIOD_DATE\n                except InvalidDateError as e:\n                    raise InvalidFormatError(cause=str(e))\n\n                org = self._organizations.get(name, None)\n\n                if not org:\n                    org = Organization(name=name)\n\n                    # Store metadata valid for identities parsing\n                    org.active = active\n                    org.inactive = inactive\n\n                    self._organizations[name] = org\n        except KeyError as e:\n            msg = \"invalid json format. Attribute %s not found\" % e.args\n            raise InvalidFormatError(cause=msg)", "response": "Parse the JSON object returned by the API call to create a new organization object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __parse_affiliations_json(self, affiliations, uuid):\n\n        enrollments = []\n\n        for affiliation in affiliations.values():\n            name = self.__encode(affiliation['name'])\n\n            try:\n                start_date = str_to_datetime(affiliation['active'])\n                end_date = str_to_datetime(affiliation['inactive'])\n            except InvalidDateError as e:\n                raise InvalidFormatError(cause=str(e))\n\n            # Ignore affiliation\n            if not start_date and not end_date:\n                continue\n\n            if not start_date:\n                start_date = MIN_PERIOD_DATE\n            if not end_date:\n                end_date = MAX_PERIOD_DATE\n\n            org = self._organizations.get(name, None)\n\n            # Set enrolllment period according to organization data\n            if org:\n                start_date = org.active if start_date < org.active else start_date\n                end_date = org.inactive if end_date > org.inactive else end_date\n\n            if not org:\n                org = Organization(name=name)\n                org.active = MIN_PERIOD_DATE\n                org.inactive = MAX_PERIOD_DATE\n\n            enrollment = Enrollment(start=start_date, end=end_date,\n                                    organization=org)\n            enrollments.append(enrollment)\n\n        return enrollments", "response": "Parse affiliations from a json dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a unique identity to the registry.", "response": "def add_unique_identity(db, uuid):\n    \"\"\"Add a unique identity to the registry.\n\n    This function adds a unique identity to the registry.\n    First, it checks if the unique identifier (uuid) used to create the\n    identity is already on the registry. When it is not found, a new unique\n    identity is created. Otherwise, it raises a 'AlreadyExistError' exception.\n\n    :param db: database manager\n    :param uuid: unique identifier for the identity\n\n    :raises InvalidValueError: when uuid is None or an empty string\n    :raises AlreadyExistsError: when the identifier already exists\n        in the registry.\n    \"\"\"\n    with db.connect() as session:\n        try:\n            add_unique_identity_db(session, uuid)\n        except ValueError as e:\n            raise InvalidValueError(e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_identity(db, source, email=None, name=None, username=None, uuid=None):\n    with db.connect() as session:\n        # Each identity needs a unique identifier\n        try:\n            identity_id = utils.uuid(source, email=email,\n                                     name=name, username=username)\n        except ValueError as e:\n            raise InvalidValueError(e)\n\n        if not uuid:\n            uidentity = add_unique_identity_db(session, identity_id)\n        else:\n            uidentity = find_unique_identity(session, uuid)\n\n        if not uidentity:\n            raise NotFoundError(entity=uuid)\n\n        try:\n            add_identity_db(session, uidentity, identity_id, source,\n                            name=name, email=email, username=username)\n        except ValueError as e:\n            raise InvalidValueError(e)\n\n        return identity_id", "response": "Adds an identity to the registry."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd an organization to the registry.", "response": "def add_organization(db, organization):\n    \"\"\"Add an organization to the registry.\n\n    This function adds an organization to the registry.\n    It checks first whether the organization is already on the registry.\n    When it is not found, the new organization is added. Otherwise,\n    it raises a 'AlreadyExistsError' exception to notify that the organization\n    already exists.\n\n    :param db: database manager\n    :param organization: name of the organization\n\n    :raises InvalidValueError: raised when organization is None or an empty string\n    :raises AlreadyExistsError: raised when the organization already exists\n        in the registry.\n    \"\"\"\n    with db.connect() as session:\n        try:\n            add_organization_db(session, organization)\n        except ValueError as e:\n            raise InvalidValueError(e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a domain to the registry.", "response": "def add_domain(db, organization, domain, is_top_domain=False, overwrite=False):\n    \"\"\"Add a domain to the registry.\n\n    This function adds a new domain to the given organization.\n    The organization must exists on the registry prior to insert the new\n    domain. Otherwise, it will raise a 'NotFoundError' exception. Moreover,\n    if the given domain is already in the registry an 'AlreadyExistsError'\n    exception will be raised.\n\n    The new domain can be also set as a top domain. That is useful to avoid\n    the insertion of sub-domains that belong to the same organization (i.e\n    eu.example.com, us.example.com).\n\n    Remember that a domain can only be assigned to one (and only one)\n    organization.\n\n    When the given domain already exist on the registry, you can use\n    'overwrite' parameter to update its information. For instance, shift\n    the domain to another organization or to update the top domain flag.\n    Take into account that both fields will be updated at the same time.\n\n    :param db: database manager\n    :param organization: name of the organization\n    :param domain: domain to add to the registry\n    :param is_top_domain: set this domain as a top domain\n    :param overwrite: force to reassign the domain to the given organization\n        and to update top domain field\n\n    :raises InvalidValueError: raised when domain is None or an empty string or\n        is_top_domain does not have a boolean value\n    :raises NotFoundError: raised when the given organization is not found\n        in the registry\n    :raises AlreadyExistsError: raised when the domain already exists\n        in the registry\n    \"\"\"\n    with db.connect() as session:\n        org = find_organization(session, organization)\n\n        if not org:\n            raise NotFoundError(entity=organization)\n\n        dom = find_domain(session, domain)\n\n        if dom and not overwrite:\n            raise AlreadyExistsError(entity='Domain', eid=dom.domain)\n        elif dom:\n            delete_domain_db(session, dom)\n\n        try:\n            add_domain_db(session, org, domain,\n                          is_top_domain=is_top_domain)\n        except ValueError as e:\n            raise InvalidValueError(e)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nenrolling a unique identity to an organization.", "response": "def add_enrollment(db, uuid, organization, from_date=None, to_date=None):\n    \"\"\"Enroll a unique identity to an organization.\n\n    The function adds a new relationship between the unique identity\n    identified by 'uuid' and the given 'organization'. The given\n    identity and organization must exist prior to add this enrollment\n    in the registry. Otherwise, a 'NotFoundError' exception will be raised.\n\n    The period of the enrollment can be given with the parameters 'from_date'\n    and 'to_date', where \"from_date <= to_date\". Default values for these\n    dates are '1900-01-01' and '2100-01-01'.\n\n    If the given enrollment data is already in the registry, the function\n    will raise a 'AlreadyExistsError' exception.\n\n    :param db: database manager\n    :param uuid: unique identifier\n    :param organization: name of the organization\n    :param from_date: date when the enrollment starts\n    :param to_date: date when the enrollment ends\n\n    :raises NotFoundError: when either 'uuid' or 'organization' are not\n        found in the registry.\n    :raises InvalidValeError: raised in three cases, when either identity or\n        organization are None or empty strings; when \"from_date\" < 1900-01-01 or\n        \"to_date\" > 2100-01-01; when \"from_date > to_date\"\n    :raises AlreadyExistsError: raised when given enrollment already exists\n        in the registry.\n    \"\"\"\n    if uuid is None:\n        raise InvalidValueError('uuid cannot be None')\n    if uuid == '':\n        raise InvalidValueError('uuid cannot be an empty string')\n    if organization is None:\n        raise InvalidValueError('organization cannot be None')\n    if organization == '':\n        raise InvalidValueError('organization cannot be an empty string')\n\n    if not from_date:\n        from_date = MIN_PERIOD_DATE\n    if not to_date:\n        to_date = MAX_PERIOD_DATE\n\n    with db.connect() as session:\n        uidentity = find_unique_identity(session, uuid)\n\n        if not uidentity:\n            raise NotFoundError(entity=uuid)\n\n        org = find_organization(session, organization)\n\n        if not org:\n            raise NotFoundError(entity=organization)\n\n        try:\n            enroll_db(session, uidentity, org,\n                      from_date=from_date, to_date=to_date)\n        except ValueError as e:\n            raise InvalidValueError(e)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding an entity to the matching blacklist.", "response": "def add_to_matching_blacklist(db, entity):\n    \"\"\"Add entity to the matching blacklist.\n\n    This function adds an 'entity' o term to the matching blacklist.\n    The term to add cannot have a None or empty value, in this case\n    a InvalidValueError will be raised. If the given 'entity' exists in the\n    registry, the function will raise an AlreadyExistsError exception.\n\n    :param db: database manager\n    :param entity: term, word or value to blacklist\n\n    :raises InvalidValueError: raised when entity is None or an empty string\n    :raises AlreadyExistsError: raised when the entity already exists\n        in the registry.\n    \"\"\"\n    with db.connect() as session:\n        try:\n            add_to_matching_blacklist_db(session, entity)\n        except ValueError as e:\n            raise InvalidValueError(e)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nediting the unique identity profile.", "response": "def edit_profile(db, uuid, **kwargs):\n    \"\"\"Edit unique identity profile.\n\n    This function allows to edit or update the profile information of the\n    unique identity identified by 'uuid'. When there is not a profile\n    for the given 'uuid', a new one will be created.\n\n    The values to update are given as keyword arguments. The allowed\n    keys are listed below (other keywords will be ignored):\n\n       - 'name' : name of the unique identity\n       - 'email' : email address of the unique identity\n       - 'gender' : gender of the unique identity\n       - 'gender_acc' : gender accuracy (range of 0 to 100; by default, set to 100)\n       - 'is_bot' : boolean value to determine whether a unique identity is\n             a bot or not. By default, this value is initialized to\n             False.\n       - 'country_code' : ISO-3166 country code\n\n    :raises NotFoundError: raised when either the unique identity\n        or the country code do not exist in the registry.\n    :raises InvalidValueError: raised when is_bot does not have a boolean\n        value.\n    \"\"\"\n    with db.connect() as session:\n        uidentity = find_unique_identity(session, uuid)\n\n        if not uidentity:\n            raise NotFoundError(entity=uuid)\n        if not uidentity.profile:\n            uidentity.profile = Profile()\n\n        try:\n            edit_profile_db(session, uidentity, **kwargs)\n        except ValueError as e:\n            raise InvalidValueError(e)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_unique_identity(db, uuid):\n    with db.connect() as session:\n        uidentity = find_unique_identity(session, uuid)\n\n        if not uidentity:\n            raise NotFoundError(entity=uuid)\n\n        delete_unique_identity_db(session, uidentity)", "response": "Removes a unique identity from the registry."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove an identity from the registry.", "response": "def delete_identity(db, identity_id):\n    \"\"\"Remove an identity from the registry.\n\n    This function removes from the registry, the identity which its identifier\n    matches with id. Take into account that this function does not remove\n    unique identities.\n\n    When the given identity is not found in the registry a 'NotFoundError'\n    exception is raised.\n\n    :param db: database manager\n    :param identity_id: identifier assigned to the identity that will\n        be removed\n\n    :raises NotFoundError: raised when the identity does not exist in the\n        registry.\n    \"\"\"\n    with db.connect() as session:\n        identity = find_identity(session, identity_id)\n\n        if not identity:\n            raise NotFoundError(entity=identity_id)\n\n        delete_identity_db(session, identity)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_organization(db, organization):\n    with db.connect() as session:\n        org = find_organization(session, organization)\n\n        if not org:\n            raise NotFoundError(entity=organization)\n\n        delete_organization_db(session, org)", "response": "Removes an organization from the registry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_domain(db, organization, domain):\n    with db.connect() as session:\n        org = find_organization(session, organization)\n\n        if not org:\n            raise NotFoundError(entity=organization)\n\n        dom = session.query(Domain).join(Organization).\\\n            filter(Organization.name == organization,\n                   Domain.domain == domain).first()\n\n        if not dom:\n            raise NotFoundError(entity=domain)\n\n        delete_domain_db(session, dom)", "response": "Removes an organization from the registry."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwithdraws a unique identity from an organization.", "response": "def delete_enrollment(db, uuid, organization, from_date=None, to_date=None):\n    \"\"\"Withdraw a unique identity from an organization.\n\n    This function removes all the enrollments between the unique identity\n    identified by 'uuid' and the given 'organization'. Both 'uuid' and\n    organization must exists before deleting. Otherwise, it will raise a\n    'NotFoundError' exception.\n\n    When a period of time is given using 'from_date' and 'to_date'\n    parameters, the function will remove those periods on which\n    'from_date' <= enrollment <= 'to_date'. Default values for these dates\n    are '1900-01-01' and '2100-01-01'.\n\n    :param db: database manager\n    :param uuid: unique identifier\n    :param organization: name of the organization\n    :param from_date: date when the enrollment starts\n    :param to_date: date when the enrollment ends\n\n    :raises NotFoundError: when either 'uuid' or 'organization' are not\n        found in the registry.\n    :raises InvalidValeError: raised in three cases, when either identity or\n        organization are None or empty strings; when \"from_date\" < 1900-01-01 or\n        \"to_date\" > 2100-01-01; when \"from_date > to_date\"\n    \"\"\"\n    if uuid is None:\n        raise InvalidValueError('uuid cannot be None')\n    if uuid == '':\n        raise InvalidValueError('uuid cannot be an empty string')\n    if organization is None:\n        raise InvalidValueError('organization cannot be None')\n    if organization == '':\n        raise InvalidValueError('organization cannot be an empty string')\n\n    if not from_date:\n        from_date = MIN_PERIOD_DATE\n    if not to_date:\n        to_date = MAX_PERIOD_DATE\n\n    with db.connect() as session:\n        uidentity = find_unique_identity(session, uuid)\n\n        if not uidentity:\n            raise NotFoundError(entity=uuid)\n\n        org = find_organization(session, organization)\n\n        if not org:\n            raise NotFoundError(entity=organization)\n\n        try:\n            deleted = withdraw_db(session, uidentity, org,\n                                  from_date=from_date,\n                                  to_date=to_date)\n        except ValueError as e:\n            raise InvalidValueError(e)\n\n        if deleted == 0:\n            entity = '-'.join((uuid, organization,\n                              str(from_date), str(to_date)))\n            raise NotFoundError(entity=entity)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving an excluded entity from the matching blacklist.", "response": "def delete_from_matching_blacklist(db, entity):\n    \"\"\"Remove an blacklisted entity from the registry.\n\n    This function removes the given blacklisted entity from the registry.\n    It checks first whether the excluded entity is already on the registry.\n    When it is found, the entity is removed. Otherwise, it will raise\n    a 'NotFoundError'.\n\n    :param db: database manager\n    :param entity: blacklisted entity to remove\n\n    :raises NotFoundError: raised when the blacklisted entity does not exist\n        in the registry.\n    \"\"\"\n    with db.connect() as session:\n        mb = session.query(MatchingBlacklist).\\\n            filter(MatchingBlacklist.excluded == entity).first()\n\n        if not mb:\n            raise NotFoundError(entity=entity)\n\n        delete_from_matching_blacklist_db(session, mb)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmerges one unique identity into another. Use this function to join 'from_uuid' unique identity into 'to_uuid'. Identities and enrollments related to 'from_uuid' will be assigned to 'to_uuid'. In addition, 'from_uuid' will be removed from the registry. Duplicated enrollments will be also removed from the registry while overlapped enrollments will be merged. This function also merges two profiles. When a field on 'to_uuid' profile is None or empty, it will be updated with the value on the profile of 'from_uuid'. If any of the two unique identities was set as a bot, the new profile will also be set as a bot. When 'from_uuid' and 'to_uuid' are equal, the action does not have any effect. The function raises a 'NotFoundError exception when either 'from_uuid' or 'to_uuid' do not exist in the registry. :param from_uuid: identifier of the unique identity set to merge :param to_uuid: identifier of the unique identity where 'from_uuid' will be merged :raises NotFoundError: raised when either 'from_uuid' or 'to_uuid' do not exist in the registry", "response": "def merge_unique_identities(db, from_uuid, to_uuid):\n    \"\"\"Merge one unique identity into another.\n\n    Use this function to join 'from_uuid' unique identity into\n    'to_uuid'. Identities and enrollments related to 'from_uuid' will be\n    assigned to 'to_uuid'. In addition, 'from_uuid' will be removed\n    from the registry. Duplicated enrollments will be also removed from\n    the registry while overlapped enrollments will be merged.\n\n    This function also merges two profiles. When a field on 'to_uuid'\n    profile is None or empty, it will be updated with the value on the\n    profile of 'from_uuid'. If any of the two unique identities was set\n    as a bot, the new profile will also be set as a bot.\n\n    When 'from_uuid' and 'to_uuid' are equal, the action does not have any\n    effect.\n\n    The function raises a 'NotFoundError exception when either 'from_uuid'\n    or 'to_uuid' do not exist in the registry.\n\n    :param from_uuid: identifier of the unique identity set to merge\n    :param to_uuid: identifier of the unique identity where 'from_uuid'\n        will be merged\n\n    :raises NotFoundError: raised when either 'from_uuid' or 'to_uuid'\n        do not exist in the registry\n    \"\"\"\n    with db.connect() as session:\n        fuid = find_unique_identity(session, from_uuid)\n        tuid = find_unique_identity(session, to_uuid)\n\n        if not fuid:\n            raise NotFoundError(entity=from_uuid)\n\n        if from_uuid == to_uuid:\n            return\n\n        if not tuid:\n            raise NotFoundError(entity=to_uuid)\n\n        # Update profile information\n        if tuid.profile and fuid.profile:\n            # Update data giving priority to 'to_uuid'.\n            # When 'is_bot' is set to True in any of the unique identities\n            # it will remain the same.\n\n            profile_data = {}\n\n            if not tuid.profile.name:\n                profile_data['name'] = fuid.profile.name\n            if not tuid.profile.email:\n                profile_data['email'] = fuid.profile.email\n            if not tuid.profile.country_code:\n                profile_data['country_code'] = fuid.profile.country_code\n            if not tuid.profile.gender:\n                profile_data['gender'] = fuid.profile.gender\n                profile_data['gender_acc'] = fuid.profile.gender_acc\n            if fuid.profile.is_bot:\n                profile_data['is_bot'] = True\n\n            edit_profile_db(session, tuid, **profile_data)\n\n        # Update identities\n        for identity in fuid.identities:\n            move_identity_db(session, identity, tuid)\n\n        # Move those enrollments that to_uid does not have.\n        # It is needed to copy the list in-place to avoid\n        # sync problems when enrollments are moved.\n        for rol in fuid.enrollments[:]:\n            enrollment = session.query(Enrollment).\\\n                filter(Enrollment.uidentity == tuid,\n                       Enrollment.organization == rol.organization,\n                       Enrollment.start == rol.start,\n                       Enrollment.end == rol.end).first()\n\n            if not enrollment:\n                move_enrollment_db(session, rol, tuid)\n\n        # For some reason, uuid are not updated until changes are\n        # committed (flush does nothing). Force to commit changes\n        # to avoid deletion of identities when removing 'fuid'\n        session.commit()\n\n        delete_unique_identity_db(session, fuid)\n\n        # Retrieve of organizations to merge the enrollments,\n        # before closing the session\n        query = session.query(Organization.name).\\\n            join(Enrollment).\\\n            filter(Enrollment.uidentity == tuid).distinct()\n\n        orgs = [org.name for org in query]\n\n    # Merge enrollments\n    for org in orgs:\n        merge_enrollments(db, to_uuid, org)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef merge_enrollments(db, uuid, organization):\n    # Merge enrollments\n    with db.connect() as session:\n        uidentity = find_unique_identity(session, uuid)\n\n        if not uidentity:\n            raise NotFoundError(entity=uuid)\n\n        org = find_organization(session, organization)\n\n        if not org:\n            raise NotFoundError(entity=organization)\n\n        disjoint = session.query(Enrollment).\\\n            filter(Enrollment.uidentity == uidentity,\n                   Enrollment.organization == org).all()\n\n        if not disjoint:\n            entity = '-'.join((uuid, organization))\n            raise NotFoundError(entity=entity)\n\n        dates = [(enr.start, enr.end) for enr in disjoint]\n\n        for st, en in utils.merge_date_ranges(dates):\n            # We prefer this method to find duplicates\n            # to avoid integrity exceptions when creating\n            # enrollments that are already in the database\n            is_dup = lambda x, st, en: x.start == st and x.end == en\n\n            filtered = [x for x in disjoint if not is_dup(x, st, en)]\n\n            if len(filtered) != len(disjoint):\n                disjoint = filtered\n                continue\n\n            # This means no dups where found so we need to add a\n            # new enrollment\n            try:\n                enroll_db(session, uidentity, org,\n                          from_date=st, to_date=en)\n            except ValueError as e:\n                raise InvalidValueError(e)\n\n        # Remove disjoint enrollments from the registry\n        for enr in disjoint:\n            delete_enrollment_db(session, enr)", "response": "This function merges overlapping enrollments."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmove an identity to a unique identity set.", "response": "def move_identity(db, from_id, to_uuid):\n    \"\"\"Move an identity to a unique identity.\n\n    This function shifts the identity identified by 'from_id' to\n    the unique identity 'to_uuid'.\n\n    When 'to_uuid' is the unique identity that is currently related\n    to 'from_id', the action does not have any effect.\n\n    In the case of 'from_id' and 'to_uuid' have equal values and the\n    unique identity does not exist, a new unique identity will be\n    created and the identity will be moved to it.\n\n    The function raises a 'NotFoundError exception when either 'from_id'\n    or 'to_uuid' do not exist in the registry.\n\n    :param from_id: identifier of the identity set to be moved\n    :param to_uuid: identifier of the unique identity where 'from_id'\n        will be moved\n\n    :raises NotFoundError: raised when either 'from_uuid' or 'to_uuid'\n        do not exist in the registry\n    \"\"\"\n    with db.connect() as session:\n        fid = find_identity(session, from_id)\n        tuid = find_unique_identity(session, to_uuid)\n\n        if not fid:\n            raise NotFoundError(entity=from_id)\n        if not tuid:\n            # Move identity to a new one\n            if from_id == to_uuid:\n                tuid = add_unique_identity_db(session, to_uuid)\n            else:\n                raise NotFoundError(entity=to_uuid)\n\n        move_identity_db(session, fid, tuid)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_identities(db, uuid, matcher):\n    uidentities = []\n\n    with db.connect() as session:\n        uidentity = find_unique_identity(session, uuid)\n\n        if not uidentity:\n            raise NotFoundError(entity=uuid)\n\n        # Get all identities expect of the one requested one query above (uid)\n        candidates = session.query(UniqueIdentity).\\\n            filter(UniqueIdentity.uuid != uuid).\\\n            order_by(UniqueIdentity.uuid)\n\n        for candidate in candidates:\n            if not matcher.match(uidentity, candidate):\n                continue\n            uidentities.append(candidate)\n\n        # Detach objects from the session\n        session.expunge_all()\n\n    return uidentities", "response": "Search for similar unique identities to uuid."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unique_identities(db, uuid=None, source=None):\n    uidentities = []\n\n    with db.connect() as session:\n        query = session.query(UniqueIdentity)\n\n        if source:\n            query = query.join(Identity).\\\n                filter(UniqueIdentity.uuid == Identity.uuid,\n                       Identity.source == source)\n\n        if uuid:\n            uidentity = query.\\\n                filter(UniqueIdentity.uuid == uuid).first()\n\n            if not uidentity:\n                raise NotFoundError(entity=uuid)\n\n            uidentities = [uidentity]\n        else:\n            uidentities = query.\\\n                order_by(UniqueIdentity.uuid).all()\n\n        # Detach objects from the session\n        session.expunge_all()\n\n    return uidentities", "response": "List the unique identities available in the registry."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef search_unique_identities(db, term, source=None):\n    uidentities = []\n    pattern = '%' + term + '%' if term else None\n\n    with db.connect() as session:\n        query = session.query(UniqueIdentity).\\\n            join(Identity).\\\n            filter(UniqueIdentity.uuid == Identity.uuid)\n\n        if source:\n            query = query.filter(Identity.source == source)\n\n        if pattern:\n            query = query.filter(Identity.name.like(pattern)\n                                 | Identity.email.like(pattern)\n                                 | Identity.username.like(pattern)\n                                 | Identity.source.like(pattern))\n        else:\n            query = query.filter((Identity.name == None)\n                                 | (Identity.email == None)\n                                 | (Identity.username == None)\n                                 | (Identity.source == None))\n\n        uidentities = query.order_by(UniqueIdentity.uuid).all()\n\n        if not uidentities:\n            raise NotFoundError(entity=term)\n\n        # Detach objects from the session\n        session.expunge_all()\n\n    return uidentities", "response": "Search for unique identities."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef search_unique_identities_slice(db, term, offset, limit):\n    uidentities = []\n    pattern = '%' + term + '%' if term else None\n\n    if offset < 0:\n        raise InvalidValueError('offset must be greater than 0 - %s given'\n                                % str(offset))\n    if limit < 0:\n        raise InvalidValueError('limit must be greater than 0 - %s given'\n                                % str(limit))\n\n    with db.connect() as session:\n        query = session.query(UniqueIdentity).\\\n            join(Identity).\\\n            filter(UniqueIdentity.uuid == Identity.uuid)\n\n        if pattern:\n            query = query.filter(Identity.name.like(pattern)\n                                 | Identity.email.like(pattern)\n                                 | Identity.username.like(pattern)\n                                 | Identity.source.like(pattern))\n\n        query = query.group_by(UniqueIdentity).\\\n            order_by(UniqueIdentity.uuid)\n\n        # Get the total number of unique identities for that search\n        nuids = query.count()\n\n        start = offset\n        end = offset + limit\n\n        uidentities = query.slice(start, end).all()\n\n        # Detach objects from the session\n        session.expunge_all()\n\n    return uidentities, nuids", "response": "Search the unique identities using slicing."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef search_last_modified_identities(db, after):\n    with db.connect() as session:\n        query = session.query(Identity.id).\\\n            filter(Identity.last_modified >= after)\n        ids = [id_.id for id_ in query.order_by(Identity.id).all()]\n\n    return ids", "response": "This function returns the uuids of identities modified on or after a given date."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlooks for the uuids of unique identities modified on or after a given date. This function returns the uuids of unique identities modified on the given date or after it. The result is a list of uuids unique identities. :param db: database manager :param after: look for identities modified on or after this date :returns: a list of uuids of unique identities modified", "response": "def search_last_modified_unique_identities(db, after):\n    \"\"\"Look for the uuids of unique identities modified on or\n    after a given date.\n\n    This function returns the uuids of unique identities\n    modified on the given date or after it. The result is a\n    list of uuids unique identities.\n\n    :param db: database manager\n    :param after: look for identities modified on or after this date\n\n    :returns: a list of uuids of unique identities modified\n    \"\"\"\n    with db.connect() as session:\n        query = session.query(UniqueIdentity.uuid).\\\n            filter(UniqueIdentity.last_modified >= after)\n        uids = [uid.uuid for uid in query.order_by(UniqueIdentity.uuid).all()]\n\n    return uids"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef search_profiles(db, no_gender=False):\n    profiles = []\n\n    with db.connect() as session:\n        query = session.query(Profile)\n\n        if no_gender:\n            query = query.filter(Profile.gender == None)\n\n        profiles = query.order_by(Profile.uuid).all()\n\n        # Detach objects from the session\n        session.expunge_all()\n\n    return profiles", "response": "List unique identities profiles."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlist the organizations available in the registry.", "response": "def registry(db, term=None):\n    \"\"\"List the organizations available in the registry.\n\n    The function will return the list of organizations. If term\n    parameter is set, it will only return the information about\n    the organizations which match that term. When the given term does\n    not match with any organization from the registry a 'NotFounError'\n    exception will be raised.\n\n    :param db: database manager\n    :param term: term to match with organizations names\n\n    :returns: a list of organizations sorted by their name\n\n    :raises NotFoundError: raised when the given term is not found on\n        any organization from the registry\n    \"\"\"\n    orgs = []\n\n    with db.connect() as session:\n        if term:\n            orgs = session.query(Organization).\\\n                filter(Organization.name.like('%' + term + '%')).\\\n                order_by(Organization.name).all()\n\n            if not orgs:\n                raise NotFoundError(entity=term)\n        else:\n            orgs = session.query(Organization).\\\n                order_by(Organization.name).all()\n\n        # Detach objects from the session\n        session.expunge_all()\n\n    return orgs"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef domains(db, domain=None, top=False):\n    doms = []\n\n    with db.connect() as session:\n        if domain:\n            dom = find_domain(session, domain)\n\n            if not dom:\n                if not top:\n                    raise NotFoundError(entity=domain)\n                else:\n                    # Adds a dot to the beggining of the domain.\n                    # Useful to compare domains like example.com and\n                    # myexample.com\n                    add_dot = lambda d: '.' + d if not d.startswith('.') else d\n\n                    d = add_dot(domain)\n\n                    tops = session.query(Domain).\\\n                        filter(Domain.is_top_domain).order_by(Domain.domain).all()\n\n                    doms = [t for t in tops\n                            if d.endswith(add_dot(t.domain))]\n\n                    if not doms:\n                        raise NotFoundError(entity=domain)\n            else:\n                doms = [dom]\n        else:\n            query = session.query(Domain)\n\n            if top:\n                query = query.filter(Domain.is_top_domain)\n\n            doms = query.order_by(Domain.domain).all()\n\n        # Detach objects from the session\n        session.expunge_all()\n\n    return doms", "response": "List the domains available in the registry."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlists the countries available in the registry.", "response": "def countries(db, code=None, term=None):\n    \"\"\"List the countries available in the registry.\n\n    The function will return the list of countries. When either 'code' or\n    'term' parameters are set, it will only return the information about\n    those countries that match them.\n\n    Take into account that 'code' is a country identifier composed by two\n    letters (i.e ES or US). A 'InvalidValueError' exception will be raised when\n    this identifier is not valid. If this value is valid, 'term' parameter\n    will be ignored.\n\n    When the given values do not match with any country from the registry\n    a 'NotFounError' exception will be raised.\n\n    :param db: database manager\n    :param code: country identifier composed by two letters\n    :param term: term to match with countries names\n\n    :returns: a list of countries sorted by their country id\n\n    :raises InvalidValueError: raised when 'code' is not a string composed by\n        two letters\n    :raises NotFoundError: raised when the given 'code' or 'term' is not\n        found for any country from the registry\n    \"\"\"\n\n    def _is_code_valid(code):\n        return type(code) == str \\\n            and len(code) == 2 \\\n            and code.isalpha()\n\n    if code is not None and not _is_code_valid(code):\n        raise InvalidValueError('country code must be a 2 length alpha string - %s given'\n                                % str(code))\n\n    cs = []\n\n    with db.connect() as session:\n        query = session.query(Country)\n\n        if code or term:\n            if code:\n                query = query.filter(Country.code == code.upper())\n            elif term:\n                query = query.filter(Country.name.like('%' + term + '%'))\n\n            cs = query.order_by(Country.code).all()\n\n            if not cs:\n                e = code if code else term\n                raise NotFoundError(entity=e)\n        else:\n            cs = session.query(Country).\\\n                order_by(Country.code).all()\n\n        # Detach objects from the session\n        session.expunge_all()\n\n    return cs"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist the enrollments available in the registry.", "response": "def enrollments(db, uuid=None, organization=None, from_date=None, to_date=None):\n    \"\"\"List the enrollment information available in the registry.\n\n    This function will return a list of enrollments. If 'uuid'\n    parameter is set, it will return the enrollments related to that\n    unique identity; if 'organization' parameter is given, it will\n    return the enrollments related to that organization; if both\n    parameters are set, the function will return the list of enrollments\n    of 'uuid' on the 'organization'.\n\n    Enrollments between a period can also be listed using 'from_date' and\n    'to_date' parameters. When these are set, the function will return\n    all those enrollments where Enrollment.start >= from_date AND\n    Enrollment.end <= to_date. Defaults values for these dates are\n    1900-01-01 and 2100-01-01.\n\n    When either 'uuid' or 'organization' are not in the registry a\n    'NotFoundError' exception will be raised.\n\n    :param db: database manager\n    :param uuid: unique identifier\n    :param organization: name of the organization\n    :param from_date: date when the enrollment starts\n    :param to_date: date when the enrollment ends\n\n    :returns: a list of enrollments sorted by uuid or by organization.\n\n    :raises NotFoundError: when either 'uuid' or 'organization' are not\n        found in the registry.\n    :raises InvalidValeError: it is raised in two cases, when \"from_date\" < 1900-01-01 or\n        \"to_date\" > 2100-01-01; when \"from_date > to_date\".\n    \"\"\"\n    if not from_date:\n        from_date = MIN_PERIOD_DATE\n    if not to_date:\n        to_date = MAX_PERIOD_DATE\n\n    if from_date < MIN_PERIOD_DATE or from_date > MAX_PERIOD_DATE:\n        raise InvalidValueError(\"'from_date' %s is out of bounds\" % str(from_date))\n    if to_date < MIN_PERIOD_DATE or to_date > MAX_PERIOD_DATE:\n        raise InvalidValueError(\"'to_date' %s is out of bounds\" % str(to_date))\n\n    if from_date and to_date and from_date > to_date:\n        raise InvalidValueError(\"'from_date' %s cannot be greater than %s\"\n                                % (from_date, to_date))\n\n    enrollments = []\n\n    with db.connect() as session:\n        query = session.query(Enrollment).\\\n            join(UniqueIdentity, Organization).\\\n            filter(Enrollment.start >= from_date,\n                   Enrollment.end <= to_date)\n\n        # Filter by uuid\n        if uuid:\n            uidentity = find_unique_identity(session, uuid)\n\n            if not uidentity:\n                raise NotFoundError(entity=uuid)\n\n            query = query.filter(Enrollment.uidentity == uidentity)\n\n        # Filter by organization\n        if organization:\n            org = find_organization(session, organization)\n\n            if not org:\n                raise NotFoundError(entity=organization)\n\n            query = query.filter(Enrollment.organization == org)\n\n        # Get the results\n        enrollments = query.order_by(UniqueIdentity.uuid,\n                                     Organization.name,\n                                     Enrollment.start,\n                                     Enrollment.end).all()\n\n        # Detach objects from the session\n        session.expunge_all()\n\n    return enrollments"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlist the blacklisted entries available in the registry.", "response": "def blacklist(db, term=None):\n    \"\"\"List the blacklisted entities available in the registry.\n\n    The function will return the list of blacklisted entities. If term\n    parameter is set, it will only return the information about the\n    entities which match that term. When the given term does not match\n    with any entry on the blacklist a 'NotFoundError' exception will\n    be raised.\n\n    :param db: database manager\n    :param term: term to match with blacklisted entries\n\n    :returns: a list of blacklisted entities sorted by their name\n\n    :raises NotFoundError: raised when the given term is not found on\n        any blacklisted entry from the registry\n    \"\"\"\n    mbs = []\n\n    with db.connect() as session:\n        if term:\n            mbs = session.query(MatchingBlacklist).\\\n                filter(MatchingBlacklist.excluded.like('%' + term + '%')).\\\n                order_by(MatchingBlacklist.excluded).all()\n\n            if not mbs:\n                raise NotFoundError(entity=term)\n        else:\n            mbs = session.query(MatchingBlacklist).\\\n                order_by(MatchingBlacklist.excluded).all()\n\n        # Detach objects from the session\n        session.expunge_all()\n\n    return mbs"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef edit_profile(self, uuid, **kwargs):\n        try:\n            api.edit_profile(self.db, uuid, **kwargs)\n            uid = api.unique_identities(self.db, uuid)[0]\n\n            self.display('profile.tmpl', uid=uid)\n        except (NotFoundError, InvalidValueError) as e:\n            self.error(str(e))\n            return e.code\n\n        return CMD_SUCCESS", "response": "Edit unique identity profile."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses command line arguments and return a dict of uuid and keyword arguments.", "response": "def __parse_arguments(self, *args):\n        \"\"\"Parse command line arguments\"\"\"\n\n        params = self.parser.parse_args(args)\n\n        uuid = params.uuid\n\n        kw = {}\n\n        if params.name:\n            kw['name'] = params.name\n        if params.email:\n            kw['email'] = params.email\n        if params.gender:\n            kw['gender'] = params.gender\n        if params.country:\n            kw['country_code'] = params.country\n\n        if params.is_bot:\n            kw['is_bot'] = True\n        elif params.no_bot:\n            kw['is_bot'] = False\n\n        return uuid, kw"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self, *args):\n\n        params = self.parser.parse_args(args)\n\n        code = self.add(params.source, params.email, params.name, params.username,\n                        params.uuid, params.matching, params.interactive)\n\n        return code", "response": "Add an identity to the registry."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add(self, source, email=None, name=None, username=None, uuid=None,\n            matching=None, interactive=False):\n        \"\"\"Add an identity to the registry.\n\n        This method adds a new identity to the registry. By default, a new\n        unique identity will be also added an associated to the new identity.\n        When <uuid> parameter is set, it only creates a new identity that will be\n        associated to a unique identity defined by <uuid>.\n\n        The method will print the uuids associated to the new registered identity.\n\n        Optionally, this method can look for possible identities that match with\n        the new one to insert. If a match is found, that means both identities are\n        likely the same. Therefore, both identities would be merged into one. The\n        algorithm used to search for matches will be defined by <matching> parameter.\n        Please take into account that both unique identities will be always merged\n        into the one from the registry, not into the new one.\n\n        When <interactive> parameter is set to True, the user will have to confirm\n        whether these to identities should be merged into one. By default, the method\n        is set to False.\n\n        :param source: data source\n        :param email: email of the identity\n        :param name: full name of the identity\n        :param username: user name used by the identity\n        :param uuid: associates the new identity to the unique identity\n            identified by this id\n        :param matching: type of matching used to merge existing identities\n        :param interactive: interactive mode for merging identities, only available\n            when <matching> parameter is set\n        \"\"\"\n        matcher = None\n\n        if matching:\n            try:\n                blacklist = api.blacklist(self.db)\n                matcher = create_identity_matcher(matching, blacklist)\n            except MatcherNotSupportedError as e:\n                self.error(str(e))\n                return e.code\n\n        try:\n            new_uuid = api.add_identity(self.db, source, email, name, username, uuid)\n            uuid = uuid or new_uuid\n            self.display('add.tmpl', id=new_uuid, uuid=uuid)\n            if matcher:\n                self.__merge_on_matching(uuid, matcher, interactive)\n        except AlreadyExistsError as e:\n            msg = \"unique identity '%s' already exists in the registry\" % e.eid\n            self.error(msg)\n            return e.code\n        except (NotFoundError, InvalidValueError) as e:\n            self.error(str(e))\n            return e.code\n\n        return CMD_SUCCESS", "response": "This method adds an identity to the registry."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef match_filtered_identities(self, fa, fb):\n        if not isinstance(fa, GitHubUsernameIdentity):\n            raise ValueError(\"<fa> is not an instance of GitHubUsernameIdentity\")\n        if not isinstance(fb, GitHubUsernameIdentity):\n            raise ValueError(\"<fb> is not an instance of GitHubUsernameIdentity\")\n\n        if fa.uuid and fb.uuid and fa.uuid == fb.uuid:\n            return True\n\n        if self._check_blacklist(fa):\n            return False\n\n        # Compare username\n        return fa.username and (fa.username == fb.username)", "response": "Returns True if two filtered identities are the same."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filter(self, u):\n        if not isinstance(u, UniqueIdentity):\n            raise ValueError(\"<u> is not an instance of UniqueIdentity\")\n\n        filtered = []\n\n        for id_ in u.identities:\n\n            if self.sources and id_.source.lower() not in self.sources:\n                continue\n\n            if self._check_blacklist(id_):\n                continue\n\n            source = id_.source.lower()\n\n            if source.startswith('github'):\n                fid = GitHubUsernameIdentity(id_.id, id_.uuid,\n                                             id_.username, id_.source)\n                filtered.append(fid)\n\n        return filtered", "response": "Filter the valid identities for this matcher."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmerge unique identities using a matching algorithm.", "response": "def run(self, *args):\n        \"\"\"Merge unique identities using a matching algorithm.\"\"\"\n\n        params = self.parser.parse_args(args)\n\n        code = self.unify(params.matching, params.sources,\n                          params.fast_matching, params.no_strict,\n                          params.interactive, params.recovery)\n\n        return code"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmerge unique identities using a matching algorithm. This method looks for sets of similar identities, merging those identities into one unique identity. To determine when two unique identities are likely the same, a matching algorithm will be given using the parameter <matching>. When this parameter is not given, the default algorithm will be used. Rigorous validation of mathching values (i.e, well formed email addresses) will be disabled when <no_strict_matching> is set to to `True`. When <fast_matching> is set, it runs a fast algorithm to find matches between identities. This mode will consume more resources (i.e, memory) but it is two orders of magnitude faster than the original. Not every matcher can support this mode. When this happens, an exception will be raised. When <interactive> parameter is set to True, the user will have to confirm whether these to identities should be merged into one. By default, the method is set to False. When a list of <sources> is given, only the unique identities from those sources will be unified. :param matching: type of matching used to merge existing identities :param sources: unify the unique identities from these sources only :param fast_matching: use the fast mode :param no_strict_matching: disable strict matching (i.e, well-formed email addresses) :param interactive: interactive mode for merging identities :param recovery: if enabled, the unify will read the matching identities stored in recovery file (RECOVERY_FILE_PATH) and process them", "response": "def unify(self, matching=None, sources=None,\n              fast_matching=False, no_strict_matching=False,\n              interactive=False, recovery=False):\n        \"\"\"Merge unique identities using a matching algorithm.\n\n        This method looks for sets of similar identities, merging those\n        identities into one unique identity. To determine when two unique\n        identities are likely the same, a matching algorithm will be given\n        using the parameter <matching>. When this parameter is not given,\n        the default algorithm will be used. Rigorous validation of mathching\n        values (i.e, well formed email addresses) will be disabled when\n        <no_strict_matching> is set to to `True`.\n\n        When <fast_matching> is set, it runs a fast algorithm to find matches\n        between identities. This mode will consume more resources (i.e,\n        memory) but it is two orders of magnitude faster than the original.\n        Not every matcher can support this mode. When this happens, an\n        exception will be raised.\n\n        When <interactive> parameter is set to True, the user will have to confirm\n        whether these to identities should be merged into one. By default, the method\n        is set to False.\n\n        When a list of <sources> is given, only the unique identities from\n        those sources will be unified.\n\n        :param matching: type of matching used to merge existing identities\n        :param sources: unify the unique identities from these sources only\n        :param fast_matching: use the fast mode\n        :param no_strict_matching: disable strict matching (i.e, well-formed email addresses)\n        :param interactive: interactive mode for merging identities\n        :param recovery: if enabled, the unify will read the matching identities stored in\n           recovery file (RECOVERY_FILE_PATH) and process them\n        \"\"\"\n        matcher = None\n\n        if not matching:\n            matching = 'default'\n\n        strict = not no_strict_matching\n        self.recovery = recovery\n\n        try:\n            blacklist = api.blacklist(self.db)\n            matcher = create_identity_matcher(matching, blacklist,\n                                              sources, strict)\n        except MatcherNotSupportedError as e:\n            self.error(str(e))\n            return e.code\n\n        uidentities = api.unique_identities(self.db)\n\n        try:\n            self.__unify_unique_identities(uidentities, matcher,\n                                           fast_matching, interactive)\n            self.__display_stats()\n        except MatcherNotSupportedError as e:\n            self.error(str(e))\n            return e.code\n        except Exception as e:\n            self.__display_stats()\n            raise RuntimeError(str(e))\n\n        return CMD_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __unify_unique_identities(self, uidentities, matcher,\n                                  fast_matching, interactive):\n        \"\"\"Unify unique identities looking for similar identities.\"\"\"\n\n        self.total = len(uidentities)\n        self.matched = 0\n\n        if self.recovery and self.recovery_file.exists():\n            print(\"Loading matches from recovery file: %s\" % self.recovery_file.location())\n            matched = self.recovery_file.load_matches()\n        else:\n            matched = match(uidentities, matcher, fastmode=fast_matching)\n            # convert the matched identities to a common JSON format to ease resuming operations\n            matched = self.__marshal_matches(matched)\n\n        self.__merge(matched, interactive)\n\n        if self.recovery:\n            self.recovery_file.delete()", "response": "Unify unique identities looking for similar identities."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmerges a list of matched unique identities", "response": "def __merge(self, matched, interactive):\n        \"\"\"Merge a lists of matched unique identities\"\"\"\n\n        for m in matched:\n            identities = m['identities']\n            uuid = identities[0]\n\n            try:\n                for c in identities[1:]:\n                    if self.__merge_unique_identities(c, uuid, interactive):\n                        self.matched += 1\n\n                        # Retrieve unique identity to show updated info\n                        if interactive:\n                            uuid = api.unique_identities(self.db, uuid=uuid)[0]\n            except Exception as e:\n                if self.recovery:\n                    self.recovery_file.save_matches(matched)\n                raise e\n\n            m['processed'] = True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndisplaying some stats regarding unify process", "response": "def __display_stats(self):\n        \"\"\"Display some stats regarding unify process\"\"\"\n\n        self.display('unify.tmpl', processed=self.total,\n                     matched=self.matched,\n                     unified=self.total - self.matched)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __marshal_matches(matched):\n        json_matches = []\n        for m in matched:\n            identities = [i.uuid for i in m]\n\n            if len(identities) == 1:\n                continue\n\n            json_match = {\n                'identities': identities,\n                'processed': False\n            }\n            json_matches.append(json_match)\n\n        return json_matches", "response": "Convert a list of matched identities\n\n            to JSON format."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading matches of the previous failed execution from the recovery file.", "response": "def load_matches(self):\n        \"\"\"Load matches of the previous failed execution from the recovery file.\n\n        :returns matches: a list of matches in JSON format\n        \"\"\"\n        if not self.exists():\n            return []\n\n        matches = []\n        with open(self.location(), 'r') as f:\n            for line in f.readlines():\n                match_obj = json.loads(line.strip(\"\\n\"))\n                if match_obj['processed']:\n                    continue\n\n                matches.append(match_obj)\n\n        return matches"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave matches of a failed execution to the log.", "response": "def save_matches(self, matches):\n        \"\"\"Save matches of a failed execution to the log.\n\n        :param matches: a list of matches in JSON format\n        \"\"\"\n        if not os.path.exists(os.path.dirname(self.location())):\n            os.makedirs(os.path.dirname(self.location()))\n\n        with open(self.location(), \"w+\") as f:\n            matches = [m for m in matches if not m['processed']]\n            for m in matches:\n                match_obj = json.dumps(m)\n                f.write(match_obj + \"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __uuid(*args):\n\n        s = '-'.join(args)\n\n        sha1 = hashlib.sha1(s.encode('utf-8', errors='surrogateescape'))\n        uuid_sha1 = sha1.hexdigest()\n\n        return uuid_sha1", "response": "Generate a UUID based on the given parameters."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the identities from the YAML file stream.", "response": "def __parse_identities(self, stream):\n        \"\"\"Parse identities using GrimoireLab format.\n\n        The GrimoireLab identities format is a YAML document following a\n        schema similar to the example below. More information available\n        at https://github.com/bitergia/identities\n\n        - profile:\n            name: Vivek K.\n            is_bot: false\n          github:\n            - vsekhark\n          email:\n            - vivek@****.com\n          enrollments:\n            - organization: Community\n              start: 1900-01-01\n              end: 2100-01-01\n\n        :parse json: YAML object to parse\n\n        :raise InvalidFormatError: raised when the format of the YAML is\n            not valid.\n        \"\"\"\n        def __create_sh_identities(name, emails, yaml_entry):\n            \"\"\"Create SH identities based on name, emails and backens data in yaml_entry\"\"\"\n\n            ids = []\n            ids.append(Identity(name=name, source=self.source))\n\n            # FIXME we should encourage our users to add email or usernames\n            # and if not returning at least a WARNING\n            if emails:\n                for m in emails:\n                    ids.append(Identity(email=m, source=self.source))\n\n            for pb in PERCEVAL_BACKENDS:\n                if pb not in yaml_entry:\n                    continue\n\n                for username in yaml_entry[pb]:\n                    identity = Identity(username=username, source=pb)\n                    ids.append(identity)\n\n            return ids\n\n        yaml_file = self.__load_yml(stream)\n        yid_counter = 0\n\n        try:\n            for yid in yaml_file:\n                profile = yid['profile']\n                if profile is None:\n                    raise AttributeError('profile')\n\n                # we want the KeyError if name is missing\n                name = yid['profile']['name']\n                is_bot = profile.get('is_bot', False)\n\n                emails = yid.get('email', None)\n\n                if emails and self.email_validation:\n                    self.__validate_email(emails[0])\n\n                enrollments = yid.get('enrollments', None)\n\n                uuid = str(yid_counter)\n                yid_counter += 1\n\n                uid = UniqueIdentity(uuid=uuid)\n\n                prf = Profile(name=name, is_bot=is_bot)\n                uid.profile = prf\n\n                # now it is time to add the identities for name, emails and backends\n                sh_identities = __create_sh_identities(name, emails, yid)\n                uid.identities += sh_identities\n\n                if enrollments:\n                    affiliations = self.__parse_affiliations_yml(enrollments)\n                    uid.enrollments += affiliations\n\n                self._identities[uuid] = uid\n        except KeyError as e:\n            error = \"Attribute %s not found\" % e.args\n            msg = self.GRIMOIRELAB_INVALID_FORMAT % {'error': error}\n            raise InvalidFormatError(cause=msg)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __parse_organizations(self, stream):\n        if not stream:\n            return\n\n        yaml_file = self.__load_yml(stream)\n\n        try:\n            for element in yaml_file:\n                name = self.__encode(element['organization'])\n\n                if not name:\n                    error = \"Empty organization name\"\n                    msg = self.GRIMOIRELAB_INVALID_FORMAT % {'error': error}\n                    raise InvalidFormatError(cause=msg)\n\n                o = Organization(name=name)\n\n                if 'domains' in element:\n                    if not isinstance(element['domains'], list):\n                        error = \"List of elements expected for organization %s\" % name\n                        msg = self.GRIMOIRELAB_INVALID_FORMAT % {'error': error}\n                        raise InvalidFormatError(cause=msg)\n                    for dom in element['domains']:\n                        if dom:\n                            d = Domain(domain=dom, is_top_domain=False)\n                            o.domains.append(d)\n                        else:\n                            error = \"Empty domain name for organization %s\" % name\n                            msg = self.GRIMOIRELAB_INVALID_FORMAT % {'error': error}\n                            raise InvalidFormatError(cause=msg)\n\n                self._organizations[name] = o\n        except KeyError as e:\n            error = \"Attribute %s not found\" % e.args\n            msg = self.GRIMOIRELAB_INVALID_FORMAT % {'error': error}\n            raise InvalidFormatError(cause=msg)\n        except TypeError as e:\n            error = \"%s\" % e.args\n            msg = self.GRIMOIRELAB_INVALID_FORMAT % {'error': error}\n            raise InvalidFormatError(cause=msg)", "response": "Parse GrimoireLab organizations.\n\n        The GrimoireLab organizations format is a YAML element stored\n        under the \"organizations\" key. The next example shows the\n        structure of the document:\n\n        - organizations:\n            Bitergia:\n                - bitergia.com\n                - support.bitergia.com\n                - biterg.io\n            LibreSoft:\n                - libresoft.es\n\n        :param json: YAML object to parse\n\n        :raises InvalidFormatError: raised when the format of the YAML is\n            not valid."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse identity s affiliations from a yaml dict.", "response": "def __parse_affiliations_yml(self, affiliations):\n        \"\"\"Parse identity's affiliations from a yaml dict.\"\"\"\n\n        enrollments = []\n\n        for aff in affiliations:\n            name = self.__encode(aff['organization'])\n            if not name:\n                error = \"Empty organization name\"\n                msg = self.GRIMOIRELAB_INVALID_FORMAT % {'error': error}\n                raise InvalidFormatError(cause=msg)\n            elif name.lower() == 'unknown':\n                continue\n\n            # we trust the Organization name included in the identities file\n            org = Organization(name=name)\n\n            if org is None:\n                continue\n\n            if 'start' in aff:\n                start_date = self.__force_datetime(aff['start'])\n            else:\n                start_date = MIN_PERIOD_DATE\n\n            if 'end' in aff:\n                end_date = self.__force_datetime(aff['end'])\n            else:\n                end_date = MAX_PERIOD_DATE\n\n            enrollment = Enrollment(start=start_date, end=end_date,\n                                    organization=org)\n            enrollments.append(enrollment)\n\n        self.__validate_enrollment_periods(enrollments)\n\n        return enrollments"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __load_yml(self, stream):\n\n        try:\n            return yaml.load(stream, Loader=yaml.SafeLoader)\n        except ValueError as e:\n            cause = \"invalid yml format. %s\" % str(e)\n            raise InvalidFormatError(cause=cause)", "response": "Load a yml stream into a dict object"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if a string looks like an email address and returns the object.", "response": "def __validate_email(self, email):\n        \"\"\"Checks if a string looks like an email address\"\"\"\n\n        e = re.match(self.EMAIL_ADDRESS_REGEX, email, re.UNICODE)\n        if e:\n            return email\n        else:\n            error = \"Invalid email address: \" + str(email)\n            msg = self.GRIMOIRELAB_INVALID_FORMAT % {'error': error}\n            raise InvalidFormatError(cause=msg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating that the enrollments are valid.", "response": "def __validate_enrollment_periods(self, enrollments):\n        \"\"\"Check for overlapped periods in the enrollments\"\"\"\n\n        for a, b in itertools.combinations(enrollments, 2):\n\n            max_start = max(a.start, b.start)\n            min_end = min(a.end, b.end)\n\n            if max_start < min_end:\n                msg = \"invalid GrimoireLab enrollment dates. \" \\\n                      \"Organization dates overlap.\"\n                raise InvalidFormatError(cause=msg)\n\n        return enrollments"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __parse(self, stream):\n\n        if not stream:\n            raise InvalidFormatError(cause=\"stream cannot be empty or None\")\n\n        json = self.__load_json(stream)\n\n        self.__parse_organizations(json)\n        self.__parse_identities(json)\n        self.__parse_blacklist(json)", "response": "Parse Sorting Hat stream"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __parse_blacklist(self, json):\n        try:\n            for entry in json['blacklist']:\n                if not entry:\n                    msg = \"invalid json format. Blacklist entries cannot be null or empty\"\n                    raise InvalidFormatError(cause=msg)\n\n                excluded = self.__encode(entry)\n\n                bl = self._blacklist.get(excluded, None)\n\n                if not bl:\n                    bl = MatchingBlacklist(excluded=excluded)\n                    self._blacklist[excluded] = bl\n        except KeyError as e:\n            msg = \"invalid json format. Attribute %s not found\" % e.args\n            raise InvalidFormatError(cause=msg)", "response": "Parse the blacklist entries using Sorting Hat format."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __parse_identities(self, json):\n        try:\n            for uidentity in json['uidentities'].values():\n                uuid = self.__encode(uidentity['uuid'])\n\n                uid = UniqueIdentity(uuid=uuid)\n\n                if uidentity['profile']:\n                    profile = uidentity['profile']\n\n                    if type(profile['is_bot']) != bool:\n                        msg = \"invalid json format. 'is_bot' must have a bool value\"\n                        raise InvalidFormatError(cause=msg)\n\n                    is_bot = profile['is_bot']\n\n                    gender = profile.get('gender', None)\n\n                    if gender is not None:\n                        gender = self.__encode(gender)\n\n                    gender_acc = profile.get('gender_acc', None)\n\n                    if gender_acc is not None:\n                        if type(gender_acc) != int:\n                            msg = \"invalid json format. 'gender_acc' must have an integer value\"\n                            raise InvalidFormatError(cause=msg)\n                        elif not 0 <= gender_acc <= 100:\n                            msg = \"invalid json format. 'gender_acc' is not in range (0,100)\"\n                            raise InvalidFormatError(cause=msg)\n\n                    name = self.__encode(profile['name'])\n                    email = self.__encode(profile['email'])\n\n                    prf = Profile(uuid=uuid, name=name, email=email,\n                                  gender=gender, gender_acc=gender_acc,\n                                  is_bot=is_bot)\n\n                    if profile['country']:\n                        alpha3 = self.__encode(profile['country']['alpha3'])\n                        code = self.__encode(profile['country']['code'])\n                        name = self.__encode(profile['country']['name'])\n\n                        c = Country(alpha3=alpha3, code=code, name=name)\n\n                        prf.country_code = code\n                        prf.country = c\n\n                    uid.profile = prf\n\n                for identity in uidentity['identities']:\n                    identity_id = self.__encode(identity['id'])\n                    name = self.__encode(identity['name'])\n                    email = self.__encode(identity['email'])\n                    username = self.__encode(identity['username'])\n                    source = self.__encode(identity['source'])\n\n                    sh_id = Identity(id=identity_id, name=name,\n                                     email=email, username=username,\n                                     source=source, uuid=uuid)\n\n                    uid.identities.append(sh_id)\n\n                for enrollment in uidentity['enrollments']:\n                    organization = self.__encode(enrollment['organization'])\n\n                    org = self._organizations.get(organization, None)\n\n                    if not org:\n                        org = Organization(name=organization)\n                        self._organizations[organization] = org\n\n                    try:\n                        start = str_to_datetime(enrollment['start'])\n                        end = str_to_datetime(enrollment['end'])\n                    except InvalidDateError as e:\n                        raise InvalidFormatError(cause=str(e))\n\n                    rol = Enrollment(start=start, end=end, organization=org)\n\n                    uid.enrollments.append(rol)\n\n                self._identities.append(uid)\n        except KeyError as e:\n            msg = \"invalid json format. Attribute %s not found\" % e.args\n            raise InvalidFormatError(cause=msg)", "response": "Parse the identities in Sorting Hat format."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the organizations using Sorting Hat format.", "response": "def __parse_organizations(self, json):\n        \"\"\"Parse organizations using Sorting Hat format.\n\n        The Sorting Hat organizations format is a JSON stream which\n        its keys are the name of the organizations. Each organization\n        object has a list of domains. For instance:\n\n        {\n            \"organizations\": {\n                \"Bitergia\": [\n                    {\n                        \"domain\": \"api.bitergia.com\",\n                        \"is_top\": false\n                    },\n                    {\n                        \"domain\": \"bitergia.com\",\n                        \"is_top\": true\n                    }\n                ],\n                \"Example\": []\n            },\n            \"time\": \"2015-01-20 20:10:56.133378\"\n        }\n\n        :param json: stream to parse\n\n        :raises InvalidFormatError: raised when the format of the stream is\n            not valid.\n        \"\"\"\n        try:\n            for organization in json['organizations']:\n                name = self.__encode(organization)\n\n                org = self._organizations.get(name, None)\n\n                if not org:\n                    org = Organization(name=name)\n                    self._organizations[name] = org\n\n                domains = json['organizations'][organization]\n\n                for domain in domains:\n                    if type(domain['is_top']) != bool:\n                        msg = \"invalid json format. 'is_top' must have a bool value\"\n                        raise InvalidFormatError(cause=msg)\n\n                    dom = Domain(domain=domain['domain'],\n                                 is_top_domain=domain['is_top'])\n                    org.domains.append(dom)\n        except KeyError as e:\n            msg = \"invalid json format. Attribute %s not found\" % e.args\n            raise InvalidFormatError(cause=msg)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if two filtered identities are the same.", "response": "def match_filtered_identities(self, fa, fb):\n        \"\"\"Determine if two filtered identities are the same.\n\n        The method compares the email addresses of each filtered identity\n        to check if they are the same. When the given filtered identities\n        are the same object or share the same UUID, this will also\n        produce a positive match.\n\n        Identities which their email addresses are in the blacklist will be\n        ignored and the result of the comparison will be false.\n\n        :param fa: filtered identity to match\n        :param fb: filtered identity to match\n\n        :returns: True when both filtered identities are likely to be the same.\n            Otherwise, returns False.\n\n        :raises ValueError: when any of the given filtered identities is not\n            an instance of EmailIdentity class.\n        \"\"\"\n        if not isinstance(fa, EmailIdentity):\n            raise ValueError(\"<fa> is not an instance of UniqueIdentity\")\n        if not isinstance(fb, EmailIdentity):\n            raise ValueError(\"<fb> is not an instance of EmailNameIdentity\")\n\n        if fa.uuid and fb.uuid and fa.uuid == fb.uuid:\n            return True\n\n        if fa.email in self.blacklist:\n            return False\n\n        # Compare email addresses first\n        if fa.email and fa.email == fb.email:\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef filter(self, u):\n        if not isinstance(u, UniqueIdentity):\n            raise ValueError(\"<u> is not an instance of UniqueIdentity\")\n\n        filtered = []\n\n        for id_ in u.identities:\n            email = None\n\n            if self.sources and id_.source.lower() not in self.sources:\n                continue\n\n            if self.strict:\n                if self._check_email(id_.email):\n                    email = id_.email.lower()\n            else:\n                email = id_.email.lower() if id_.email else None\n\n            if email:\n                fid = EmailIdentity(id_.id, id_.uuid, email)\n                filtered.append(fid)\n\n        return filtered", "response": "Filter the valid identities for this matcher."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nimport data on the registry. By default, it reads the data from the standard input. If a positional argument is given, it will read the data from there.", "response": "def run(self, *args):\n        \"\"\"Import data on the registry.\n\n        By default, it reads the data from the standard input. If a positional\n        argument is given, it will read the data from there.\n        \"\"\"\n        params = self.parser.parse_args(args)\n\n        with params.infile as infile:\n            try:\n                stream = self.__read_file(infile)\n                parser = SortingHatParser(stream)\n            except InvalidFormatError as e:\n                self.error(str(e))\n                return e.code\n            except (IOError, TypeError, AttributeError) as e:\n                raise RuntimeError(str(e))\n\n        if params.identities:\n            self.import_blacklist(parser)\n            code = self.import_identities(parser,\n                                          matching=params.matching,\n                                          match_new=params.match_new,\n                                          no_strict_matching=params.no_strict,\n                                          reset=params.reset,\n                                          verbose=params.verbose)\n        elif params.orgs:\n            self.import_organizations(parser, params.overwrite)\n            code = CMD_SUCCESS\n        else:\n            self.import_organizations(parser, params.overwrite)\n            self.import_blacklist(parser)\n            code = self.import_identities(parser, matching=params.matching,\n                                          match_new=params.match_new,\n                                          no_strict_matching=params.no_strict,\n                                          reset=params.reset,\n                                          verbose=params.verbose)\n\n        return code"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nimporting blacklist. New entries parsed by 'parser' will be added to the blacklist. :param parser: sorting hat parser", "response": "def import_blacklist(self, parser):\n        \"\"\"Import blacklist.\n\n        New entries parsed by 'parser' will be added to the blacklist.\n\n        :param parser: sorting hat parser\n        \"\"\"\n        blacklist = parser.blacklist\n\n        self.log(\"Loading blacklist...\")\n        n = 0\n\n        for entry in blacklist:\n            try:\n                api.add_to_matching_blacklist(self.db, entry.excluded)\n                self.display('load_blacklist.tmpl', entry=entry.excluded)\n                n += 1\n            except ValueError as e:\n                raise RuntimeError(str(e))\n            except AlreadyExistsError as e:\n                msg = \"%s. Not added.\" % str(e)\n                self.warning(msg)\n\n        self.log(\"%d/%d blacklist entries loaded\" % (n, len(blacklist)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef import_organizations(self, parser, overwrite=False):\n        orgs = parser.organizations\n\n        for org in orgs:\n            try:\n                api.add_organization(self.db, org.name)\n            except ValueError as e:\n                raise RuntimeError(str(e))\n            except AlreadyExistsError as e:\n                pass\n\n            for dom in org.domains:\n                try:\n                    api.add_domain(self.db, org.name, dom.domain,\n                                   is_top_domain=dom.is_top_domain,\n                                   overwrite=overwrite)\n                    self.display('load_domains.tmpl', domain=dom.domain,\n                                 organization=org.name)\n                except (ValueError, NotFoundError) as e:\n                    raise RuntimeError(str(e))\n                except AlreadyExistsError as e:\n                    msg = \"%s. Not updated.\" % str(e)\n                    self.warning(msg)", "response": "Import organizations.\n\n        New domains and organizations parsed by 'parser' will be added\n        to the registry. Remember that a domain can only be assigned to\n        one organization. If one of the given domains is already on the registry,\n        the new relationship will NOT be created unless 'overwrite' were set\n        to 'True'.\n\n        :param parser: sorting hat parser\n        :param overwrite: force to reassign domains"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nimporting unique identities information on the registry.", "response": "def import_identities(self, parser, matching=None, match_new=False,\n                          no_strict_matching=False,\n                          reset=False, verbose=False):\n        \"\"\"Import identities information on the registry.\n\n        New unique identities, organizations and enrollment data parsed\n        by 'parser' will be added to the registry.\n\n        Optionally, this method can look for possible identities that match with\n        the new one to insert using 'matching' method. If a match is found,\n        that means both identities are likely the same. Therefore, both identities\n        would be merged into one. The 'match_new' parameter can be set to match\n        and merge only new loaded identities. Rigorous validation of mathching\n        values (i.e, well formed email addresses) will be disabled when\n        <no_strict_matching> is set to to `True`.\n\n        When `reset` is set, relationships and enrollments will be removed\n        before loading any data.\n\n        :param parser: sorting hat parser\n        :param matching: type of matching used to merge existing identities\n        :param match_new: match and merge only the new loaded identities\n        :param no_strict_matching: disable strict matching (i.e, well-formed email addresses)\n        :param reset: remove relationships and enrollments before loading data\n        :param verbose: run in verbose mode when matching is set\n        \"\"\"\n        matcher = None\n\n        if matching:\n            strict = not no_strict_matching\n\n            try:\n                blacklist = api.blacklist(self.db)\n                matcher = create_identity_matcher(matching, blacklist, strict=strict)\n            except MatcherNotSupportedError as e:\n                self.error(str(e))\n                return e.code\n\n        uidentities = parser.identities\n\n        try:\n            self.__load_unique_identities(uidentities, matcher, match_new,\n                                          reset, verbose)\n        except LoadError as e:\n            self.error(str(e))\n            return e.code\n\n        return CMD_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __load_unique_identities(self, uidentities, matcher, match_new,\n                                 reset, verbose):\n        \"\"\"Load unique identities\"\"\"\n\n        self.new_uids.clear()\n\n        n = 0\n\n        if reset:\n            self.__reset_unique_identities()\n\n        self.log(\"Loading unique identities...\")\n\n        for uidentity in uidentities:\n            self.log(\"\\n=====\", verbose)\n            self.log(\"+ Processing %s\" % uidentity.uuid, verbose)\n\n            try:\n                stored_uuid = self.__load_unique_identity(uidentity, verbose)\n            except LoadError as e:\n                self.error(\"%s Skipping.\" % str(e))\n                self.log(\"=====\", verbose)\n                continue\n\n            stored_uuid = self.__load_identities(uidentity.identities, stored_uuid,\n                                                 verbose)\n\n            try:\n                self.__load_profile(uidentity.profile, stored_uuid, verbose)\n            except Exception as e:\n                self.error(\"%s. Loading %s profile. Skipping profile.\" %\n                           (str(e), stored_uuid))\n\n            self.__load_enrollments(uidentity.enrollments, stored_uuid,\n                                    verbose)\n\n            if matcher and (not match_new or stored_uuid in self.new_uids):\n                stored_uuid = self._merge_on_matching(stored_uuid, matcher,\n                                                      verbose)\n\n            self.log(\"+ %s (old %s) loaded\" % (stored_uuid, uidentity.uuid),\n                     verbose)\n            self.log(\"=====\", verbose)\n            n += 1\n\n        self.log(\"%d/%d unique identities loaded\" % (n, len(uidentities)))", "response": "Load unique identities from uidentities."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __reset_unique_identities(self):\n\n        self.log(\"Reseting unique identities...\")\n\n        self.log(\"Clearing identities relationships\")\n\n        nids = 0\n        uidentities = api.unique_identities(self.db)\n\n        for uidentity in uidentities:\n            for identity in uidentity.identities:\n                api.move_identity(self.db, identity.id, identity.id)\n                nids += 1\n\n        self.log(\"Relationships cleared for %s identities\" % nids)\n\n        self.log(\"Clearing enrollments\")\n\n        with self.db.connect() as session:\n            enrollments = session.query(Enrollment).all()\n\n            for enr in enrollments:\n                session.delete(enr)\n\n        self.log(\"Enrollments cleared\")", "response": "Clear unique identities relationships and enrollments data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __load_unique_identity(self, uidentity, verbose):\n\n        uuid = uidentity.uuid\n\n        if uuid:\n            try:\n                api.unique_identities(self.db, uuid)\n                self.log(\"-- %s already exists.\" % uuid, verbose)\n                return uuid\n            except NotFoundError as e:\n                self.log(\"-- %s not found. Generating a new UUID.\" % uuid,\n                         debug=verbose)\n\n        # We don't have a unique identity, so we have to create\n        # a new one.\n        if len(uidentity.identities) == 0:\n            msg = \"not enough info to load %s unique identity.\" % uidentity.uuid\n            raise LoadError(cause=msg)\n\n        identity = uidentity.identities.pop(0)\n\n        try:\n            stored_uuid = api.add_identity(self.db, identity.source,\n                                           identity.email,\n                                           identity.name,\n                                           identity.username)\n            self.new_uids.add(stored_uuid)\n        except AlreadyExistsError as e:\n            with self.db.connect() as session:\n                stored_identity = find_identity(session, e.eid)\n                stored_uuid = stored_identity.uuid\n            self.warning(\"-- \" + str(e), debug=verbose)\n        except ValueError as e:\n            raise LoadError(cause=str(e))\n\n        self.log(\"-- using %s for %s unique identity.\" % (stored_uuid, uuid), verbose)\n\n        return stored_uuid", "response": "Seek or store unique identity"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload identities from database", "response": "def __load_identities(self, identities, uuid, verbose):\n        \"\"\"Store identities\"\"\"\n\n        self.log(\"-- loading identities\", verbose)\n\n        for identity in identities:\n            try:\n                api.add_identity(self.db, identity.source, identity.email,\n                                 identity.name, identity.username, uuid)\n                self.new_uids.add(uuid)\n            except AlreadyExistsError as e:\n                self.warning(str(e), verbose)\n\n                with self.db.connect() as session:\n                    stored_identity = find_identity(session, e.eid)\n                    stored_uuid = stored_identity.uuid\n\n                if uuid != stored_uuid:\n                    msg = \"%s is already assigned to %s. Merging.\" % (uuid, stored_uuid)\n                    self.warning(msg, verbose)\n\n                    api.merge_unique_identities(self.db, uuid, stored_uuid)\n\n                    if uuid in self.new_uids:\n                        self.new_uids.remove(uuid)\n\n                    self.new_uids.add(stored_uuid)\n                    uuid = stored_uuid\n\n        self.log(\"-- identities loaded\", verbose)\n\n        return uuid"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new profile when the unique identity does not have any.", "response": "def __load_profile(self, profile, uuid, verbose):\n        \"\"\"Create a new profile when the unique identity does not have any.\"\"\"\n\n        def is_empty_profile(prf):\n            return not (prf.name or prf.email or\n                        prf.gender or prf.gender_acc or\n                        prf.is_bot or prf.country_code)\n\n        uid = api.unique_identities(self.db, uuid)[0]\n\n        if profile:\n            self.__create_profile(profile, uuid, verbose)\n        elif is_empty_profile(uid.profile):\n            self.__create_profile_from_identities(uid.identities, uuid, verbose)\n        else:\n            self.log(\"-- empty profile given for %s. Not updated\" % uuid, verbose)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a profile from a profile object", "response": "def __create_profile(self, profile, uuid, verbose):\n        \"\"\"Create profile information from a profile object\"\"\"\n\n        # Set parameters to edit\n        kw = profile.to_dict()\n        kw['country_code'] = profile.country_code\n\n        # Remove unused keywords\n        kw.pop('uuid')\n        kw.pop('country')\n\n        api.edit_profile(self.db, uuid, **kw)\n\n        self.log(\"-- profile %s updated\" % uuid, verbose)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a profile using the data from the identities", "response": "def __create_profile_from_identities(self, identities, uuid, verbose):\n        \"\"\"Create a profile using the data from the identities\"\"\"\n\n        import re\n\n        EMAIL_ADDRESS_REGEX = r\"^(?P<email>[^\\s@]+@[^\\s@.]+\\.[^\\s@]+)$\"\n        NAME_REGEX = r\"^\\w+\\s\\w+\"\n\n        name = None\n        email = None\n        username = None\n\n        for identity in identities:\n            if not name and identity.name:\n                m = re.match(NAME_REGEX, identity.name)\n\n                if m:\n                    name = identity.name\n\n            if not email and identity.email:\n                m = re.match(EMAIL_ADDRESS_REGEX, identity.email)\n\n                if m:\n                    email = identity.email\n\n            if not username:\n                if identity.username and identity.username != 'None':\n                    username = identity.username\n\n        # We need a name for each profile, so if no one was defined,\n        # use email or username to complete it.\n        if not name:\n            if email:\n                name = email.split('@')[0]\n            elif username:\n                # filter email addresses on username fields\n                name = username.split('@')[0]\n            else:\n                name = None\n\n        kw = {'name': name,\n              'email': email}\n\n        api.edit_profile(self.db, uuid, **kw)\n\n        self.log(\"-- profile %s updated\" % uuid, verbose)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __load_enrollments(self, enrollments, uuid, verbose):\n\n        self.log(\"-- loading enrollments\", verbose)\n\n        organizations = []\n\n        for enrollment in enrollments:\n            organization = enrollment.organization.name\n\n            try:\n                api.add_organization(self.db, organization)\n            except AlreadyExistsError as e:\n                msg = \"%s. Organization not updated.\" % str(e)\n                self.warning(msg, verbose)\n\n            if organization not in organizations:\n                organizations.append(organization)\n\n            from_date = max(MIN_PERIOD_DATE, enrollment.start)\n            to_date = min(MAX_PERIOD_DATE, enrollment.end)\n\n            if from_date != enrollment.start or to_date != enrollment.end:\n                msg = \"Dates out of bound. Set to %s and %s.\" % (str(from_date), str(to_date))\n                self.warning(msg, verbose)\n\n            try:\n                api.add_enrollment(self.db, uuid, enrollment.organization.name,\n                                   from_date, to_date)\n            except AlreadyExistsError as e:\n                msg = \"%s. Enrollment not updated.\" % str(e)\n                self.warning(msg, verbose)\n            except (ValueError, NotFoundError) as e:\n                raise LoadError(cause=str(e))\n\n        for organization in organizations:\n            api.merge_enrollments(self.db, uuid, organization)\n\n        self.log(\"-- enrollments loaded\", verbose)", "response": "Load the enrollments and store them in the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmerging unique identity with uuid when a match is found", "response": "def _merge_on_matching(self, uuid, matcher, verbose):\n        \"\"\"Merge unique identity with uuid when a match is found\"\"\"\n\n        matches = api.match_identities(self.db, uuid, matcher)\n\n        new_uuid = uuid\n\n        u = api.unique_identities(self.db, uuid)[0]\n\n        for m in matches:\n            if m.uuid == uuid:\n                continue\n\n            self._merge(u, m, verbose)\n\n            new_uuid = m.uuid\n\n            # Swap uids to merge with those that could\n            # remain on the list with updated info\n            u = api.unique_identities(self.db, m.uuid)[0]\n\n        return new_uuid"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _merge(self, from_uid, to_uid, verbose):\n\n        if verbose:\n            self.display('match.tmpl', uid=from_uid, match=to_uid)\n\n        api.merge_unique_identities(self.db, from_uid.uuid, to_uid.uuid)\n\n        if verbose:\n            self.display('merge.tmpl', from_uuid=from_uid.uuid, to_uuid=to_uid.uuid)", "response": "Merge unique identity uid on match"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __parse_identities(self, aliases, email_to_employer):\n\n        # Parse streams\n        self.__parse_aliases_stream(aliases)\n        self.__parse_email_to_employer_stream(email_to_employer)\n\n        # Create unique identities from aliases list\n        for alias, email in self.__raw_aliases.items():\n            uid = self._identities.get(email, None)\n\n            if not uid:\n                uid = UniqueIdentity(uuid=email)\n\n                e = re.match(self.EMAIL_ADDRESS_REGEX, email, re.UNICODE)\n                if e:\n                    identity = Identity(email=email, source=self.source)\n                else:\n                    identity = Identity(username=email, source=self.source)\n\n                uid.identities.append(identity)\n\n                self._identities[email] = uid\n\n            e = re.match(self.EMAIL_ADDRESS_REGEX, alias, re.UNICODE)\n            if e:\n                identity = Identity(email=alias, source=self.source)\n            else:\n                identity = Identity(username=alias, source=self.source)\n\n            uid.identities.append(identity)\n\n        # Create unique identities from enrollments list\n        for email in self.__raw_identities:\n\n            # Do we have it from aliases?\n            if email in self._identities:\n                uid = self._identities[email]\n            elif email in self.__raw_aliases:\n                canonical = self.__raw_aliases[email]\n                uid = self._identities[canonical]\n            else:\n                uid = UniqueIdentity(uuid=email)\n\n                identity = Identity(email=email, source=self.source)\n                uid.identities.append(identity)\n\n                self._identities[email] = uid\n\n            # Assign enrollments\n            enrs = self.__raw_identities[email]\n            enrs.sort(key=lambda r: r[1])\n\n            start_date = MIN_PERIOD_DATE\n\n            for rol in enrs:\n                name = rol[0]\n                org = self._organizations.get(name, None)\n\n                if not org:\n                    org = Organization(name=name)\n                    self._organizations[name] = org\n\n                end_date = rol[1]\n\n                enrollment = Enrollment(start=start_date, end=end_date,\n                                        organization=org)\n                uid.enrollments.append(enrollment)\n\n                if end_date != MAX_PERIOD_DATE:\n                    start_date = end_date", "response": "Parse Gitdm identities and assign them to the internal list of unique identities."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __parse_aliases_stream(self, stream):\n        if not stream:\n            return\n\n        f = self.__parse_aliases_line\n\n        for alias_entries in self.__parse_stream(stream, f):\n            alias = alias_entries[0]\n            username = alias_entries[1]\n\n            self.__raw_aliases[alias] = username", "response": "Parse the aliases stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing an email to employer stream.", "response": "def __parse_email_to_employer_stream(self, stream):\n        \"\"\"Parse email to employer stream.\n\n        The stream contains a list of email addresses and their employers.\n        Each line has an email address and a organization name separated by\n        tabs. Optionally, the date when the identity withdrew from the\n        organization can be included followed by a '<' character. Comment\n        lines start with the hash character (#).\n\n        Example:\n\n        # List of enrollments\n        jsmith@example.com    Example Company # John Smith\n        jdoe@example.com    Example Company   # John Doe\n        jsmith@example.com    Bitergia < 2015-01-01  # John Smith - Bitergia\n        \"\"\"\n        if not stream:\n            return\n\n        f = self.__parse_email_to_employer_line\n\n        for rol in self.__parse_stream(stream, f):\n            email = rol[0]\n            org = rol[1]\n            rol_date = rol[2]\n\n            if org not in self.__raw_orgs:\n                self.__raw_orgs[org] = []\n\n            if email not in self.__raw_identities:\n                self.__raw_identities[email] = [(org, rol_date)]\n            else:\n                self.__raw_identities[email].append((org, rol_date))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing domain to employer stream.", "response": "def __parse_domain_to_employer_stream(self, stream):\n        \"\"\"Parse domain to employer stream.\n\n        Each line of the stream has to contain a domain and a organization,\n        or employer, separated by tabs. Comment lines start with the hash\n        character (#)\n\n        Example:\n\n        # Domains from domains.txt\n        example.org        Example\n        example.com        Example\n        bitergia.com       Bitergia\n        libresoft.es       LibreSoft\n        example.org        LibreSoft\n        \"\"\"\n        if not stream:\n            return\n\n        f = self.__parse_domain_to_employer_line\n\n        for o in self.__parse_stream(stream, f):\n            org = o[0]\n            dom = o[1]\n\n            if org not in self.__raw_orgs:\n                self.__raw_orgs[org] = []\n\n            self.__raw_orgs[org].append(dom)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __parse_stream(self, stream, parse_line):\n\n        if not stream:\n            raise InvalidFormatError(cause='stream cannot be empty or None')\n\n        nline = 0\n        lines = stream.split('\\n')\n\n        for line in lines:\n            nline += 1\n\n            # Ignore blank lines and comments\n            m = re.match(self.LINES_TO_IGNORE_REGEX, line, re.UNICODE)\n            if m:\n                continue\n\n            m = re.match(self.VALID_LINE_REGEX, line, re.UNICODE)\n            if not m:\n                cause = \"line %s: invalid format\" % str(nline)\n                raise InvalidFormatError(cause=cause)\n\n            try:\n                result = parse_line(m.group(1), m.group(2))\n                yield result\n            except InvalidFormatError as e:\n                cause = \"line %s: %s\" % (str(nline), e)\n                raise InvalidFormatError(cause=cause)", "response": "Generic method to parse gitdm streams"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse email to employer lines", "response": "def __parse_email_to_employer_line(self, raw_email, raw_enrollment):\n        \"\"\"Parse email to employer lines\"\"\"\n\n        e = re.match(self.EMAIL_ADDRESS_REGEX, raw_email, re.UNICODE)\n        if not e and self.email_validation:\n            cause = \"invalid email format: '%s'\" % raw_email\n            raise InvalidFormatError(cause=cause)\n\n        if self.email_validation:\n            email = e.group('email').strip()\n        else:\n            email = raw_email\n\n        r = re.match(self.ENROLLMENT_REGEX, raw_enrollment, re.UNICODE)\n        if not r:\n            cause = \"invalid enrollment format: '%s'\" % raw_enrollment\n            raise InvalidFormatError(cause=cause)\n\n        org = r.group('organization').strip()\n        date = r.group('date')\n\n        if date:\n            try:\n                dt = dateutil.parser.parse(r.group('date'))\n            except Exception as e:\n                cause = \"invalid date: '%s'\" % date\n        else:\n            dt = MAX_PERIOD_DATE\n\n        email = self.__encode(email)\n        org = self.__encode(org)\n\n        return email, org, dt"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse domain to employer lines", "response": "def __parse_domain_to_employer_line(self, raw_domain, raw_org):\n        \"\"\"Parse domain to employer lines\"\"\"\n\n        d = re.match(self.DOMAIN_REGEX, raw_domain, re.UNICODE)\n        if not d:\n            cause = \"invalid domain format: '%s'\" % raw_domain\n            raise InvalidFormatError(cause=cause)\n\n        dom = d.group('domain').strip()\n\n        o = re.match(self.ORGANIZATION_REGEX, raw_org, re.UNICODE)\n        if not o:\n            cause = \"invalid organization format: '%s'\" % raw_org\n            raise InvalidFormatError(cause=cause)\n\n        org = o.group('organization').strip()\n\n        org = self.__encode(org)\n        dom = self.__encode(dom)\n\n        return org, dom"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef log(self, uuid=None, organization=None, from_date=None, to_date=None):\n        try:\n            enrollments = api.enrollments(self.db, uuid, organization,\n                                          from_date, to_date)\n            self.display('log.tmpl', enrollments=enrollments)\n        except (NotFoundError, InvalidValueError) as e:\n            self.error(str(e))\n            return e.code\n\n        return CMD_SUCCESS", "response": "List enrollment information available in the registry."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run(self, *args):\n        params = self.parser.parse_args(args)\n\n        code = self.initialize(name=params.name, reuse=params.reuse)\n\n        return code", "response": "Initialize a registry.\n\n        Create and initialize an empty registry which its name is defined by\n        <name> parameter. Required tables will be also created."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef initialize(self, name, reuse=False):\n        user = self._kwargs['user']\n        password = self._kwargs['password']\n        host = self._kwargs['host']\n        port = self._kwargs['port']\n\n        if '-' in name:\n            self.error(\"dabase name '%s' cannot contain '-' characters\" % name)\n            return CODE_VALUE_ERROR\n\n        try:\n            Database.create(user, password, name, host, port)\n            # Try to access and create schema\n            db = Database(user, password, name, host, port)\n            # Load countries list\n            self.__load_countries(db)\n        except DatabaseExists as e:\n            if not reuse:\n                self.error(str(e))\n                return CODE_DATABASE_EXISTS\n        except DatabaseError as e:\n            self.error(str(e))\n            return CODE_DATABASE_ERROR\n        except LoadError as e:\n            Database.drop(user, password, name, host, port)\n            self.error(str(e))\n            return CODE_LOAD_ERROR\n\n        return CMD_SUCCESS", "response": "Create an empty Sorting Hat registry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __load_countries(self, db):\n\n        try:\n            countries = self.__read_countries_file()\n        except IOError as e:\n            raise LoadError(str(e))\n\n        try:\n            with db.connect() as session:\n                for country in countries:\n                    session.add(country)\n        except Exception as e:\n            raise LoadError(str(e))", "response": "Load the list of countries from the file"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __read_countries_file(self):\n        import csv\n        import pkg_resources\n\n        filename = pkg_resources.resource_filename('sortinghat', 'data/countries.csv')\n\n        with open(filename, 'r') as f:\n            reader = csv.DictReader(f, fieldnames=['name', 'code', 'alpha3'])\n            countries = [Country(**c) for c in reader]\n\n        return countries", "response": "Read countries from a CSV file"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves unique identities or identities from the registry.", "response": "def run(self, *args):\n        \"\"\"Remove unique identities or identities from the registry.\n\n        By default, it removes the unique identity identified by <identifier>.\n        To remove an identity, set <identity> parameter.\n        \"\"\"\n        params = self.parser.parse_args(args)\n\n        identifier = params.identifier\n        identity = params.identity\n\n        code = self.remove(identifier, identity)\n\n        return code"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove an identity from the registry.", "response": "def remove(self, uuid_or_id, identity=False):\n        \"\"\"Remove an identity from the registry.\n\n        This method removes the unique identity associated to the given\n        uuid and its related information, such as identities or enrollments.\n        When <identity> is set to True, it will remove the identity (not the\n        unique identity) which its id is <uuid_or_id>.\n\n        :param uuid_or_id: identifier of the unique identity or\n            identity to remove\n        :param identity: when it is set to True, it will remove an identity,\n            not a unique identity.  By default it is set to False.\n        \"\"\"\n        if not uuid_or_id:\n            return CMD_SUCCESS\n\n        try:\n            if not identity:\n                api.delete_unique_identity(self.db, uuid_or_id)\n            else:\n                api.delete_identity(self.db, uuid_or_id)\n\n            self.display('remove.tmpl',\n                         uuid_or_id=uuid_or_id, identity=identity)\n        except NotFoundError as e:\n            self.error(str(e))\n            return e.code\n\n        return CMD_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge_date_ranges(dates):\n    if not dates:\n        return\n\n    sorted_dates = sorted([sorted(t) for t in dates])\n    saved = list(sorted_dates[0])\n\n    for st, en in sorted_dates:\n        if st < MIN_PERIOD_DATE or st > MAX_PERIOD_DATE:\n            raise ValueError(\"start date %s is out of bounds\" % str(st))\n        if en < MIN_PERIOD_DATE or en > MAX_PERIOD_DATE:\n            raise ValueError(\"end date %s is out of bounds\" % str(en))\n\n        if st <= saved[1]:\n            if saved[0] == MIN_PERIOD_DATE:\n                saved[0] = st\n\n            if MAX_PERIOD_DATE in (en, saved[1]):\n                saved[1] = min(saved[1], en)\n            else:\n                saved[1] = max(saved[1], en)\n        else:\n            yield tuple(saved)\n            saved[0] = st\n            saved[1] = en\n    yield tuple(saved)", "response": "Merge date ranges.\n\n    Generator that merges ovelaped data ranges.\n\n    Default init and end dates (1900-01-01 and 2100-01-01) are considered range\n    limits and will be removed when a set of ranges overlap. For example:\n\n     * [(1900-01-01, 2010-01-01), (2008-01-01, 2100-01-01)]\n           --> (2008-01-01, 2010-01-01)\n     * [(1900-01-01, 2010-01-01), (2008-01-01, 2010-01-01), (2010-01-02, 2100-01-01)]\n           --> (2008-01-01, 2010-01-01),(2010-01-02, 2100-01-01)\n     * [(1900-01-01, 2010-01-01), (2010-01-02, 2100-01-01)]\n           --> (1900-01-01, 2010-01-01), (2010-01-02, 2100-01-01)\n\n    The condition MIN_PERIOD_DATE <= dt <= MAX_PERIOD_DATE must be true for each\n    date. Otherwise, the generator will raise a ValueError exception.\n\n    This code is based on samplebias' answer to StackOverflow's question\n    \"Merging a list of time-range tuples that have overlapping time-ranges\"\n    (http://stackoverflow.com/questions/5679638).\n\n    :param dates: sequence of date ranges where each range is a\n        (st_date, en_date) tuple\n\n    :raises ValueError: when a value of the data range is out of bounds"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef str_to_datetime(ts):\n    if not ts:\n        return None\n\n    try:\n        return dateutil.parser.parse(ts).replace(tzinfo=None)\n    except Exception:\n        raise InvalidDateError(date=str(ts))", "response": "Format a string to a datetime object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_unicode(x, unaccent=False):\n    s = str(x)\n\n    if unaccent:\n        cs = [c for c in unicodedata.normalize('NFD', s)\n              if unicodedata.category(c) != 'Mn']\n        s = ''.join(cs)\n\n    return s", "response": "Convert a string to unicode"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef uuid(source, email=None, name=None, username=None):\n    if source is None:\n        raise ValueError(\"source cannot be None\")\n    if source == '':\n        raise ValueError(\"source cannot be an empty string\")\n    if not (email or name or username):\n        raise ValueError(\"identity data cannot be None or empty\")\n\n    s = ':'.join((to_unicode(source),\n                  to_unicode(email),\n                  to_unicode(name, unaccent=True),\n                  to_unicode(username))).lower()\n\n    sha1 = hashlib.sha1(s.encode('UTF-8', errors=\"surrogateescape\"))\n    uuid_ = sha1.hexdigest()\n\n    return uuid_", "response": "Returns the UUID associated with the identity data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a database engine", "response": "def create_database_engine(user, password, database, host, port):\n    \"\"\"Create a database engine\"\"\"\n\n    driver = 'mysql+pymysql'\n    url = URL(driver, user, password, host, port, database,\n              query={'charset': 'utf8mb4'})\n    return create_engine(url, poolclass=QueuePool,\n                         pool_size=25, pool_pre_ping=True,\n                         echo=False)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_database_session(engine):\n\n    try:\n        Session = sessionmaker(bind=engine)\n        return Session()\n    except OperationalError as e:\n        raise DatabaseError(error=e.orig.args[1], code=e.orig.args[0])", "response": "Connect to the database"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncloses connection with the database session", "response": "def close_database_session(session):\n    \"\"\"Close connection with the database\"\"\"\n\n    try:\n        session.close()\n    except OperationalError as e:\n        raise DatabaseError(error=e.orig.args[1], code=e.orig.args[0])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reflect_table(engine, klass):\n\n    try:\n        meta = MetaData()\n        meta.reflect(bind=engine)\n    except OperationalError as e:\n        raise DatabaseError(error=e.orig.args[1], code=e.orig.args[0])\n\n    # Try to reflect from any of the supported tables\n    table = None\n\n    for tb in klass.tables():\n        if tb in meta.tables:\n            table = meta.tables[tb]\n            break\n\n    if table is None:\n        raise DatabaseError(error=\"Invalid schema. Table not found\",\n                            code=\"-1\")\n\n    # Map table schema into klass\n    mapper(klass, table,\n           column_prefix=klass.column_prefix())\n\n    return table", "response": "Inspect and reflect objects from any of the supported tables."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding a model by its table name", "response": "def find_model_by_table_name(name):\n    \"\"\"Find a model reference by its table name\"\"\"\n\n    for model in ModelBase._decl_class_registry.values():\n        if hasattr(model, '__table__') and model.__table__.fullname == name:\n            return model\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef handle_database_error(cls, session, exception):\n\n        session.rollback()\n\n        if isinstance(exception, IntegrityError):\n            cls.handle_integrity_error(exception)\n        elif isinstance(exception, FlushError):\n            cls.handle_flush_error(exception)\n        else:\n            raise exception", "response": "Rollback changes made and handle any type of error raised by the DBMS."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles integrity error exceptions.", "response": "def handle_integrity_error(cls, exception):\n        \"\"\"Handle integrity error exceptions.\"\"\"\n\n        m = re.match(cls.MYSQL_INSERT_ERROR_REGEX,\n                     exception.statement)\n\n        if not m:\n            raise exception\n\n        model = find_model_by_table_name(m.group('table'))\n\n        if not model:\n            raise exception\n\n        m = re.match(cls.MYSQL_DUPLICATE_ENTRY_ERROR_REGEX,\n                     exception.orig.args[1])\n\n        if not m:\n            raise exception\n\n        entity = model.__name__\n        eid = m.group('value')\n\n        raise AlreadyExistsError(entity=entity, eid=eid)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles flush error exceptions.", "response": "def handle_flush_error(cls, exception):\n        \"\"\"Handle flush error exceptions.\"\"\"\n\n        trace = exception.args[0]\n        m = re.match(cls.MYSQL_FLUSH_ERROR_REGEX, trace)\n\n        if not m:\n            raise exception\n\n        entity = m.group('entity')\n        eid = m.group('eid')\n\n        raise AlreadyExistsError(entity=entity, eid=eid)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\naugment the affiliate method.", "response": "def run(self, *args):\n        \"\"\"Affiliate unique identities to organizations.\"\"\"\n\n        self.parser.parse_args(args)\n\n        code = self.affiliate()\n\n        return code"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\naffiliate unique identities. This method enrolls unique identities to organizations using email addresses and top/sub domains data. Only new enrollments will be created.", "response": "def affiliate(self):\n        \"\"\"Affiliate unique identities.\n\n        This method enrolls unique identities to organizations using email\n        addresses and top/sub domains data. Only new enrollments will be created.\n        \"\"\"\n        try:\n            uidentities = api.unique_identities(self.db)\n\n            for uid in uidentities:\n                uid.identities.sort(key=lambda x: x.id)\n\n                for identity in uid.identities:\n                    # Only check email address to find new affiliations\n                    if not identity.email:\n                        continue\n                    if not EMAIL_ADDRESS_PATTERN.match(identity.email):\n                        continue\n\n                    domain = identity.email.split('@')[-1]\n\n                    try:\n                        doms = api.domains(self.db, domain=domain, top=True)\n                    except NotFoundError as e:\n                        continue\n\n                    if len(doms) > 1:\n                        doms.sort(key=lambda d: len(d.domain), reverse=True)\n\n                        msg = \"multiple top domains for %s sub-domain. Domain %s selected.\"\n                        msg = msg % (domain, doms[0].domain)\n                        self.warning(msg)\n\n                    organization = doms[0].organization.name\n\n                    # Check enrollments to avoid insert affiliation twice\n                    enrollments = api.enrollments(self.db, uid.uuid,\n                                                  organization)\n\n                    if enrollments:\n                        continue\n\n                    api.add_enrollment(self.db, uid.uuid, organization)\n\n                    self.display('affiliate.tmpl', id=uid.uuid,\n                                 email=identity.email, organization=organization)\n        except (NotFoundError, InvalidValueError) as e:\n            self.error(str(e))\n            return e.code\n\n        return CMD_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run(self, *args):\n\n        params = self.parser.parse_args(args)\n\n        uuid = params.uuid\n        organization = params.organization\n\n        try:\n            from_date = utils.str_to_datetime(params.from_date)\n            to_date = utils.str_to_datetime(params.to_date)\n\n            code = self.withdraw(uuid, organization, from_date, to_date)\n        except InvalidDateError as e:\n            self.error(str(e))\n            return e.code\n\n        return code", "response": "Withdraw a unique identity from an organization."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwithdraw a unique identity from an organization.", "response": "def withdraw(self, uuid, organization, from_date=None, to_date=None):\n        \"\"\"Withdraw a unique identity from an organization.\n\n        This method removes all the enrollments between the unique identity,\n        identified by <uuid>, and <organization>. Both entities must exist\n        on the registry before being deleted.\n\n        When a period of time is given using either <from_date> and <to_date>\n        parameters, it will remove those enrollments which their periods fall\n        between these two parameters. Default values for these dates\n        are '1900-01-01' and '2100-01-01'.\n\n        :param uuid: unique identifier\n        :param organization: name of the organization\n        :param from_date: date when the enrollment starts\n        :param to_date: date when the enrollment ends\n        \"\"\"\n        # Empty or None values for uuid and organizations are not allowed,\n        # so do nothing\n        if not uuid or not organization:\n            return CMD_SUCCESS\n\n        try:\n            api.delete_enrollment(self.db, uuid, organization, from_date, to_date)\n        except (NotFoundError, InvalidValueError) as e:\n            self.error(str(e))\n            return e.code\n\n        return CMD_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshows information about countries.", "response": "def run(self, *args):\n        \"\"\"Show information about countries.\"\"\"\n\n        params = self.parser.parse_args(args)\n\n        ct = params.code_or_term\n\n        if ct and len(ct) < 2:\n            self.error('Code country or term must have 2 or more characters length')\n            return CODE_INVALID_FORMAT_ERROR\n\n        code = ct if ct and len(ct) == 2 else None\n        term = ct if ct and len(ct) > 2 else None\n\n        try:\n            countries = api.countries(self.db, code=code, term=term)\n            self.display('countries.tmpl', countries=countries)\n        except (NotFoundError, InvalidValueError) as e:\n            self.error(str(e))\n            return e.code\n\n        return CMD_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self, *args):\n\n        params = self.parser.parse_args(args)\n\n        from_id = params.from_id\n        to_uuid = params.to_uuid\n\n        code = self.move(from_id, to_uuid)\n\n        return code", "response": "Move an identity into a unique identity."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmoves an identity into a unique identity set.", "response": "def move(self, from_id, to_uuid):\n        \"\"\"Move an identity into a unique identity.\n\n        The method moves the identity identified by <from_id> to\n        the unique identity <to_uuid>.\n\n        In the case of<from_id> is equal to <to_uuid> and this unique identity\n        does not exist, a new unique identity will be created, detaching <from_id>\n        from its current unique identity and moving it to the new one.\n\n        When <to_uuid> is the unique identity that is currently related to\n        <from_id>, the action does not have any effect. The same occurs when\n        either <from_id> or <to_uuid> are None or empty.\n\n        :param from_id: identifier of the identity set to be moved\n        :param to_uuid: identifier of the unique identity where 'from_id'\n            will be moved\n        \"\"\"\n        if not from_id or not to_uuid:\n            return CMD_SUCCESS\n\n        try:\n            api.move_identity(self.db, from_id, to_uuid)\n            self.display('move.tmpl',\n                         from_id=from_id, to_uuid=to_uuid)\n        except NotFoundError as e:\n            self.error(str(e))\n            return e.code\n\n        return CMD_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def call_async(self, method_name: str, *args, rpc_timeout: float = None, **kwargs):\n        # if an rpc_timeout override is not specified, use the one set in the Client attributes\n        if rpc_timeout is None:\n            rpc_timeout = self.rpc_timeout\n\n        if rpc_timeout:\n            # Implementation note: this simply wraps the call in a timeout and converts to the built-in TimeoutError\n            try:\n                return await asyncio.wait_for(self._call_async(method_name, *args, **kwargs), timeout=rpc_timeout)\n            except asyncio.TimeoutError:\n                raise TimeoutError(f\"Timeout on client {self.endpoint}, method name {method_name}, class info: {self}\")\n        else:\n            return await self._call_async(method_name, *args, **kwargs)", "response": "Send a JSON RPC request to a backend socket and receive reply."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def _call_async(self, method_name: str, *args, **kwargs):\n        request = utils.rpc_request(method_name, *args, **kwargs)\n        _log.debug(\"Sending request: %s\", request)\n\n        # setup an event to notify us when the reply is received (potentially by a task scheduled by\n        # another call to _async_call). we do this before we send the request to catch the case\n        # where the reply comes back before we re-enter this thread\n        self._events[request.id] = asyncio.Event()\n\n        # schedule a task to receive the reply to ensure we have a task to receive the reply\n        asyncio.ensure_future(self._recv_reply())\n\n        await self._async_socket.send_multipart([to_msgpack(request)])\n        await self._events[request.id].wait()\n\n        reply = self._replies.pop(request.id)\n        if isinstance(reply, RPCError):\n            raise utils.RPCError(reply.error)\n        else:\n            return reply.result", "response": "Sends a request to the socket and waits for the reply."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def _recv_reply(self):\n        raw_reply, = await self._async_socket.recv_multipart()\n        reply = from_msgpack(raw_reply)\n        _log.debug(\"Received reply: %s\", reply)\n        self._replies[reply.id] = reply\n        self._events.pop(reply.id).set()", "response": "Helper task to recieve a reply store the result and trigger the associated event."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a JSON RPC request to a backend socket and receive a reply from the backend socket.", "response": "def call(self, method_name: str, *args, rpc_timeout: float = None, **kwargs):\n        \"\"\"\n        Send JSON RPC request to a backend socket and receive reply\n        Note that this uses the default event loop to run in a blocking manner. If you would rather run in an async\n        fashion or provide your own event loop then use .async_call instead\n\n        :param method_name: Method name\n        :param args: Args that will be passed to the remote function\n        :param float rpc_timeout: Timeout in seconds for Server response, set to None to disable the timeout\n        :param kwargs: Keyword args that will be passed to the remote function\n        \"\"\"\n        request = utils.rpc_request(method_name, *args, **kwargs)\n        _log.debug(\"Sending request: %s\", request)\n\n        self._socket.send_multipart([to_msgpack(request)])\n\n        # if an rpc_timeout override is not specified, use the one set in the Client attributes\n        if rpc_timeout is None:\n            rpc_timeout = self.rpc_timeout\n\n        start_time = time.time()\n        while True:\n            # Need to keep track of timeout manually in case this loop runs more than once. We subtract off already\n            # elapsed time from the timeout. The call to max is to make sure we don't send a negative value\n            # which would throw an error.\n            timeout = max((start_time + rpc_timeout - time.time()) * 1000, 0) if rpc_timeout is not None else None\n            if self._socket.poll(timeout) == 0:\n                raise TimeoutError(f\"Timeout on client {self.endpoint}, method name {method_name}, class info: {self}\")\n\n            raw_reply, = self._socket.recv_multipart()\n            reply = from_msgpack(raw_reply)\n            _log.debug(\"Received reply: %s\", reply)\n\n            # there's a possibility that the socket will have some leftover replies from a previous\n            # request on it if that .call() was cancelled or timed out. Therefore, we need to discard replies that\n            # don't match the request just like in the call_async case.\n            if reply.id == request.id:\n                break\n            else:\n                _log.debug('Discarding reply: %s', reply)\n\n        for warning in reply.warnings:\n            warn(f\"{warning.kind}: {warning.body}\")\n\n        if isinstance(reply, RPCError):\n            raise utils.RPCError(reply.error)\n        else:\n            return reply.result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclose the sockets and the async socket cache.", "response": "def close(self):\n        \"\"\"\n        Close the sockets\n        \"\"\"\n        self._socket.close()\n        if self._async_socket_cache:\n            self._async_socket_cache.close()\n            self._async_socket_cache = None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconnect to a DEALER socket at endpoint and turn off lingering.", "response": "def _connect_to_socket(self, context: zmq.Context, endpoint: str):\n        \"\"\"\n        Connect to a DEALER socket at endpoint and turn off lingering.\n\n        :param context: ZMQ Context to use (potentially async)\n        :param endpoint: Endpoint\n        :return: Connected socket\n        \"\"\"\n        socket = context.socket(zmq.DEALER)\n        socket.connect(endpoint)\n        socket.setsockopt(zmq.LINGER, 0)\n        _log.debug(\"Client connected to endpoint %s\", self.endpoint)\n        return socket"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _async_socket(self):\n        if not self._async_socket_cache:\n            self._async_socket_cache = self._connect_to_socket(zmq.asyncio.Context(), self.endpoint)\n\n        return self._async_socket_cache", "response": "Creates a new async socket if one doesn t already exist for this Client\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nruns server main task asynchronously.", "response": "async def run_async(self, endpoint: str):\n        \"\"\"\n        Run server main task (asynchronously).\n\n        :param endpoint: Socket endpoint to listen to, e.g. \"tcp://*:1234\"\n        \"\"\"\n        self._connect(endpoint)\n\n        # spawn an initial listen task\n        listen_task = asyncio.ensure_future(self._socket.recv_multipart())\n        task_list = [listen_task]\n\n        while True:\n            dones, pendings = await asyncio.wait(task_list, return_when=asyncio.FIRST_COMPLETED)\n\n            # grab one \"done\" task to handle\n            task_list, done_list = list(pendings), list(dones)\n            done = done_list.pop()\n            task_list += done_list\n\n            if done == listen_task:\n                try:\n                    # empty_frame may either be:\n                    # 1. a single null frame if the client is a REQ socket\n                    # 2. an empty list (ie. no frames) if the client is a DEALER socket\n                    identity, *empty_frame, msg = done.result()\n                    request = from_msgpack(msg)\n\n                    # spawn a processing task\n                    task_list.append(asyncio.ensure_future(\n                        self._process_request(identity, empty_frame, request)))\n                except Exception as e:\n                    if self.serialize_exceptions:\n                        _log.exception('Exception thrown in Server run loop during request '\n                                       'reception: {}'.format(str(e)))\n                    else:\n                        raise e\n                finally:\n                    # spawn a new listen task\n                    listen_task = asyncio.ensure_future(self._socket.recv_multipart())\n                    task_list.append(listen_task)\n            else:\n                # if there's been an exception during processing, consider reraising it\n                try:\n                    done.result()\n                except Exception as e:\n                    if self.serialize_exceptions:\n                        _log.exception('Exception thrown in Server run loop during request '\n                                       'dispatch: {}'.format(str(e)))\n                    else:\n                        raise e"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun server main task.", "response": "def run(self, endpoint: str, loop: AbstractEventLoop = None):\n        \"\"\"\n        Run server main task.\n\n        :param endpoint: Socket endpoint to listen to, e.g. \"tcp://*:1234\"\n        :param loop: Event loop to run server in (alternatively just use run_async method)\n        \"\"\"\n        if not loop:\n            loop = asyncio.get_event_loop()\n\n        try:\n            loop.run_until_complete(self.run_async(endpoint))\n        except KeyboardInterrupt:\n            self._shutdown()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nshuts down the server.", "response": "def _shutdown(self):\n        \"\"\"\n        Shut down the server.\n        \"\"\"\n        for exit_handler in self._exit_handlers:\n            exit_handler()\n\n        if self._socket:\n            self._socket.close()\n            self._socket = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconnects the server to an endpoint. Creates a ZMQ ROUTER socket for the given endpoint.", "response": "def _connect(self, endpoint: str):\n        \"\"\"\n        Connect the server to an endpoint. Creates a ZMQ ROUTER socket for the given endpoint.\n\n        :param endpoint: Socket endpoint, e.g. \"tcp://*:1234\"\n        \"\"\"\n        if self._socket:\n            raise RuntimeError('Cannot run multiple Servers on the same socket')\n\n        context = zmq.asyncio.Context()\n        self._socket = context.socket(zmq.ROUTER)\n        self._socket.bind(endpoint)\n\n        _log.info(\"Starting server, listening on endpoint {}\".format(endpoint))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprocesses a request and sends the reply to the socket.", "response": "async def _process_request(self, identity: bytes, empty_frame: list, request: RPCRequest):\n        \"\"\"\n        Executes the method specified in a JSON RPC request and then sends the reply to the socket.\n\n        :param identity: Client identity provided by ZeroMQ\n        :param empty_frame: Either an empty list or a single null frame depending on the client type\n        :param request: JSON RPC request\n        \"\"\"\n        try:\n            _log.debug(\"Client %s sent request: %s\", identity, request)\n            start_time = datetime.now()\n            reply = await self.rpc_spec.run_handler(request)\n            if self.announce_timing:\n                _log.info(\"Request {} for {} lasted {} seconds\".format(\n                    request.id, request.method, (datetime.now() - start_time).total_seconds()))\n\n            _log.debug(\"Sending client %s reply: %s\", identity, reply)\n            await self._socket.send_multipart([identity, *empty_frame, to_msgpack(reply)])\n        except Exception as e:\n            if self.serialize_exceptions:\n                _log.exception('Exception thrown in _process_request')\n            else:\n                raise e"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_handler(self, f):\n        if f.__name__.startswith('rpc_'):\n            raise ValueError(\"Server method names cannot start with rpc_.\")\n        self._json_rpc_methods[f.__name__] = f\n        return f", "response": "Adds the function f to the dictionary of JSON RPC methods."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_handler(self, request):\n        try:\n            f = self._json_rpc_methods[request.method]\n\n        except (AttributeError, KeyError):  # pragma no coverage\n            raise RPCMethodError(\"Received invalid method '{}'\".format(request.method))\n\n        return f", "response": "Get callable from JSON RPC request."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def run_handler(self, request: RPCRequest) -> Union[RPCReply, RPCError]:\n        with catch_warnings(record=True) as warnings:\n            try:\n                rpc_handler = self.get_handler(request)\n            except RPCMethodError as e:\n                return rpc_error(request.id, str(e), warnings=warnings)\n\n            try:\n                # Run RPC and get result\n                args, kwargs = get_input(request.params)\n                result = rpc_handler(*args, **kwargs)\n\n                if asyncio.iscoroutine(result):\n                    result = await result\n\n            except Exception as e:\n                if self.serialize_exceptions:\n                    _traceback = traceback.format_exc()\n                    _log.error(_traceback)\n                    if self.provide_tracebacks:\n                        return rpc_error(request.id, \"{}\\n{}\".format(str(e), _traceback),\n                                         warnings=warnings)\n                    else:\n                        return rpc_error(request.id, str(e), warnings=warnings)\n                else:\n                    raise e\n\n            return rpc_reply(request.id, result, warnings=warnings)", "response": "Process a JSON RPC request and return the reply."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rpc_request(method_name: str, *args, **kwargs) -> rpcq.messages.RPCRequest:\n    if args:\n        kwargs['*args'] = args\n\n    return rpcq.messages.RPCRequest(\n        jsonrpc='2.0',\n        id=str(uuid.uuid4()),\n        method=method_name,\n        params=kwargs\n    )", "response": "Create JSON RPC formatted request"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rpc_reply(id: Union[str, int], result: Optional[object],\n              warnings: Optional[List[Warning]] = None) -> rpcq.messages.RPCReply:\n    \"\"\"\n    Create RPC reply\n\n    :param str|int id: Request ID\n    :param result: Result\n    :param warnings: List of warnings to attach to the message\n    :return: JSON RPC formatted dict\n    \"\"\"\n    warnings = warnings or []\n\n    return rpcq.messages.RPCReply(\n        jsonrpc='2.0',\n        id=id,\n        result=result,\n        warnings=[rpc_warning(warning) for warning in warnings]\n    )", "response": "Create RPC reply\n\n    :param str|int id: Request ID\n    :param result: Result\n    :param warnings: List of warnings to attach to the message\n    :return: JSON RPC formatted dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate an RPC error with the given error message and optional list of warnings.", "response": "def rpc_error(id: Union[str, int], error_msg: str,\n              warnings: List[Any] = []) -> rpcq.messages.RPCError:\n    \"\"\"\n    Create RPC error\n\n    :param id: Request ID\n    :param error_msg: Error message\n    :param warning: List of warnings to attach to the message\n    :return: JSON RPC formatted dict\n    \"\"\"\n    return rpcq.messages.RPCError(\n        jsonrpc='2.0',\n        id=id,\n        error=error_msg,\n        warnings=[rpc_warning(warning) for warning in warnings])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_input(params: Union[dict, list]) -> Tuple[list, dict]:\n    # Backwards compatibility for old clients that send params as a list\n    if isinstance(params, list):\n        args = params\n        kwargs = {}\n    elif isinstance(params, dict):\n        args = params.pop('*args', [])\n        kwargs = params\n    else:  # pragma no coverage\n        raise TypeError(\n            'Unknown type {} of params, must be list or dict'.format(type(params)))\n\n    return args, kwargs", "response": "Get positional or keyword arguments from JSON RPC params\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrepresents a value in human readable form.", "response": "def repr_value(value):\n    \"\"\"\n    Represent a value in human readable form. For long list's this truncates the printed\n    representation.\n\n    :param value: The value to represent.\n    :return: A string representation.\n    :rtype: basestring\n    \"\"\"\n    if isinstance(value, list) and len(value) > REPR_LIST_TRUNCATION:\n        return \"[{},...]\".format(\", \".join(map(repr, value[:REPR_LIST_TRUNCATION])))\n    else:\n        return repr(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_msgpack(b, *, max_bin_len=MAX_BIN_LEN, max_str_len=MAX_STR_LEN):\n    # Docs for raw parameter are somewhat hard to find so they're copied here:\n    #   If true, unpack msgpack raw to Python bytes (default).\n    #   Otherwise, unpack to Python str (or unicode on Python 2) by decoding with UTF-8 encoding (recommended).\n    #   In msgpack >= 0.6, max_xxx_len is reduced from 2 GB to 1 MB, so we set the relevant ones\n    #       to 2 GB as to not run into issues with the size of the values returned from rpcq\n    return msgpack.loads(b, object_hook=_object_hook, raw=False,\n                         max_bin_len=max_bin_len, max_str_len=max_str_len)", "response": "Convert a byte array into a Python object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_yaml_file(obj, f):\n    yaml.dump(rapidjson.loads(to_json(obj)), f)", "response": "Convert Python objects to yaml and write it to f."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading a yaml file and convert to Python objects.", "response": "def from_yaml_file(f):\n    \"\"\"\n    Read a yaml file and convert to Python objects (including rpcq messages).\n    \"\"\"\n    return from_json(to_json(yaml.load(f, Loader=yaml.Loader)))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a tuple representation of the message.", "response": "def astuple(self):\n        \"\"\"\n        Create a tuple ``{fieldvalue1, ...}`` of the Message object.\n         :return: A tuple representation of the message.\n        :rtype: Tuple[Any]\n        \"\"\"\n        return tuple(getattr(self, f.name) for f in fields(self))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef types():\n        if Message._types is None:\n            Message._types = {}\n            classes_to_process = [Message]\n            while classes_to_process:\n                atom = classes_to_process.pop()\n                classes_to_process += atom.__subclasses__()\n                Message._types[atom.__name__] = atom\n        return Message._types", "response": "Returns a mapping of type_name to message_type for all defined Message s."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(cls, reactor, source='graphite', **options):\n        acls = cls.alerts[source]\n        return acls(reactor, **options)", "response": "Get an alert class by source."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_value_for_expr(self, expr, target):\n        if expr in LOGICAL_OPERATORS.values():\n            return None\n        rvalue = expr['value']\n        if rvalue == HISTORICAL:\n            history = self.history[target]\n            if len(history) < self.history_size:\n                return None\n            rvalue = sum(history) / float(len(history))\n\n        rvalue = expr['mod'](rvalue)\n        return rvalue", "response": "Get the value for expr for target."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nnotifies main reactor about event.", "response": "def notify(self, level, value, target=None, ntype=None, rule=None):\n        \"\"\"Notify main reactor about event.\"\"\"\n        # Did we see the event before?\n        if target in self.state and level == self.state[target]:\n            return False\n\n        # Do we see the event first time?\n        if target not in self.state and level == 'normal' \\\n                and not self.reactor.options['send_initial']:\n            return False\n\n        self.state[target] = level\n        return self.reactor.notify(level, self, value, target=target, ntype=ntype, rule=rule)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload data from Graphite.", "response": "def load(self):\n        \"\"\"Load data from Graphite.\"\"\"\n        LOGGER.debug('%s: start checking: %s', self.name, self.query)\n        if self.waiting:\n            self.notify('warning', 'Process takes too much time', target='waiting', ntype='common')\n        else:\n            self.waiting = True\n            try:\n                response = yield self.client.fetch(self.url, auth_username=self.auth_username,\n                                                   auth_password=self.auth_password,\n                                                   request_timeout=self.request_timeout,\n                                                   connect_timeout=self.connect_timeout,\n                                                   validate_cert=self.validate_cert)\n                records = (\n                    GraphiteRecord(line, self.default_nan_value, self.ignore_nan)\n                    for line in response.buffer)\n                data = [\n                    (None if record.empty else getattr(record, self.method), record.target)\n                    for record in records]\n                if len(data) == 0:\n                    raise ValueError('No data')\n                self.check(data)\n                self.notify('normal', 'Metrics are loaded', target='loading', ntype='common')\n            except Exception as e:\n                self.notify(\n                    self.loading_error, 'Loading error: %s' % e, target='loading', ntype='common')\n            self.waiting = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load(self):\n        LOGGER.debug('%s: start checking: %s', self.name, self.query)\n        if self.waiting:\n            self.notify('warning', 'Process takes too much time', target='waiting', ntype='common')\n        else:\n            self.waiting = True\n            try:\n                response = yield self.client.fetch(\n                    self.query, method=self.options.get('method', 'GET'),\n                    request_timeout=self.request_timeout,\n                    connect_timeout=self.connect_timeout,\n                    validate_cert=self.options.get('validate_cert', True))\n                self.check([(self.get_data(response), self.query)])\n                self.notify('normal', 'Metrics are loaded', target='loading', ntype='common')\n\n            except Exception as e:\n                self.notify('critical', str(e), target='loading', ntype='common')\n\n            self.waiting = False", "response": "Load the data from the API."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_loader(config):\n    if config.endswith('.yml') or config.endswith('.yaml'):\n        if not yaml:\n            LOGGER.error(\"pyyaml must be installed to use the YAML loader\")\n            # TODO: stop reactor if running\n            return None, None\n        return 'yaml', yaml.load\n    else:\n        return 'json', json.loads", "response": "Determine which loader to use based on a filename."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef start(self, start_loop=True):\n        self.start_alerts()\n        if self.options.get('pidfile'):\n            with open(self.options.get('pidfile'), 'w') as fpid:\n                fpid.write(str(os.getpid()))\n        self.callback.start()\n        LOGGER.info('Reactor starts')\n\n        if start_loop:\n            self.loop.start()", "response": "Start all the things."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nproviding the event to the handlers.", "response": "def notify(self, level, alert, value, target=None, ntype=None, rule=None):\n        \"\"\" Provide the event to the handlers. \"\"\"\n\n        LOGGER.info('Notify %s:%s:%s:%s', level, alert, value, target or \"\")\n\n        if ntype is None:\n            ntype = alert.source\n\n        for handler in self.handlers.get(level, []):\n            handler.notify(level, alert, value, target=target, ntype=ntype, rule=rule)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall every time chats are modified", "response": "def write_to_file(chats, chatfile):\n    \"\"\"called every time chats are modified\"\"\"\n    with open(chatfile, 'w') as handler:\n        handler.write('\\n'.join((str(id_) for id_ in chats)))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_chatlist(chatfile):\n    if not chatfile:\n        return set()\n    try:\n        with open(chatfile) as file_contents:\n            return set(int(chat) for chat in file_contents)\n    except (OSError, IOError) as exc:\n        LOGGER.error('could not load saved chats:\\n%s', exc)\n        return set()", "response": "Try reading ids of saved chats from file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_data(upd, bot_ident):\n\n    update_content = json.loads(upd.decode())\n    result = update_content['result']\n    data = (get_fields(update, bot_ident) for update in result)\n    return (dt for dt in data if dt is not None)", "response": "Parse telegram update and return data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_fields(upd, bot_ident):\n    msg = upd.get('message', {})\n    text = msg.get('text')\n    if not text:\n        return\n    chat_id = msg['chat']['id']\n    command = filter_commands(text, chat_id, bot_ident)\n    if not command:\n        return\n    return (upd['update_id'], chat_id, msg['message_id'], command)", "response": "Get fields from update."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef filter_commands(text, chat_id, correct_ident):\n    is_group = (chat_id < 0)  # always negative for groups\n    split_cmd = text.split()[:2]\n    command = split_cmd[0].strip().lower()\n\n    # make sure command is known\n    if command not in ('/activate', '/deactivate', '/help'):\n        return\n    # dont check bot_ident if not in group\n    if not is_group:\n        return command\n    # check bot_ident\n    if len(split_cmd) < 2:\n        return 'no_ident'\n    if split_cmd[1].strip() != correct_ident:\n        return 'wrong_ident'\n\n    return command", "response": "Check if text is valid command to bot."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmonitor new updates and send them further to self. _respond_commands where bot actions are decided.", "response": "def _listen_commands(self):\n        \"\"\"Monitor new updates and send them further to\n        self._respond_commands, where bot actions\n        are decided.\n        \"\"\"\n\n        self._last_update = None\n        update_body = {'timeout': 2}\n\n        while True:\n            latest = self._last_update\n            # increase offset to filter out older updates\n            update_body.update({'offset': latest + 1} if latest else {})\n            update_resp = self.client.get_updates(update_body)\n            update_resp.add_done_callback(self._respond_commands)\n            yield gen.sleep(5)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _respond_commands(self, update_response):\n\n        chatfile = self.chatfile\n        chats = self.chats\n\n        exc, upd = update_response.exception(), update_response.result().body\n        if exc:\n            LOGGER.error(str(exc))\n        if not upd:\n            return\n\n        data = get_data(upd, self.bot_ident)\n        for update_id, chat_id, message_id, command in data:\n            self._last_update = update_id\n            chat_is_known = chat_id in chats\n            chats_changed = False\n            reply_text = None\n\n            if command == '/activate':\n                if chat_is_known:\n                    reply_text = 'This chat is already activated.'\n                else:\n                    LOGGER.debug(\n                        'Adding chat [%s] to notify list.', chat_id)\n                    reply_text = 'Activated.'\n                    chats.add(chat_id)\n                    chats_changed = True\n\n            elif command == '/deactivate':\n                if chat_is_known:\n                    LOGGER.debug(\n                        'Deleting chat [%s] from notify list.', chat_id)\n                    reply_text = 'Deactivated.'\n                    chats.remove(chat_id)\n                    chats_changed = True\n\n            if chats_changed and chatfile:\n                write_to_file(chats, chatfile)\n\n            elif command == '/help':\n                reply_text = HELP_MESSAGE\n\n            else:\n                LOGGER.warning('Could not parse command: '\n                               'bot ident is wrong or missing')\n\n            if reply_text:\n                yield self.client.send_message({\n                    'chat_id': chat_id,\n                    'reply_to_message_id': message_id,\n                    'text': reply_text,\n                    'parse_mode': 'Markdown',\n                })", "response": "Respond to commands from update and update_response."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends alerts to telegram chats.", "response": "def notify(self, level, *args, **kwargs):\n        \"\"\"Sends alerts to telegram chats.\n        This method is called from top level module.\n        Do not rename it.\n        \"\"\"\n\n        LOGGER.debug('Handler (%s) %s', self.name, level)\n\n        notify_text = self.get_message(level, *args, **kwargs)\n        for chat in self.chats.copy():\n            data = {\"chat_id\": chat, \"text\": notify_text}\n            yield self.client.send_message(data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_message(self, level, alert, value, **kwargs):\n        target, ntype = kwargs.get('target'), kwargs.get('ntype')\n\n        msg_type = 'telegram' if ntype == 'graphite' else 'short'\n        tmpl = TEMPLATES[ntype][msg_type]\n        generated = tmpl.generate(\n            level=level, reactor=self.reactor, alert=alert,\n            value=value, target=target,)\n        return generated.decode().strip()", "response": "Standart alert message. Same format across all\n        graphite - beacon handlers."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetchmaker(self, telegram_api_method):\n\n        fetch = self.client.fetch\n        request = self.url(telegram_api_method)\n\n        def _fetcher(body, method='POST', headers=None):\n            \"\"\"Uses fetch method of tornado http client.\"\"\"\n            body = json.dumps(body)\n            if not headers:\n                headers = {}\n            headers.update({'Content-Type': 'application/json'})\n            return fetch(\n                request=request, body=body, method=method, headers=headers)\n        return _fetcher", "response": "Creates a function that returns a response from the tornado http client."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef substitute_variables(command, level, name, value, target=None, **kwargs):\n    rule = kwargs.get('rule', {})\n    rule_value = rule.get('value', '') if rule else ''\n    substitutes = {\n        '${level}': str(level),\n        '${target}': str(target),\n        '${name}': '\"' + str(name) + '\"',\n        '${value}': str(value),\n        '${limit_value}': str(rule_value),\n    }\n\n    result = command\n    for pattern, value in substitutes.items():\n        result = result.replace(pattern, value)\n\n    return result", "response": "Substitute variables in command fragments by values e. g. level => warning."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _normalize_value_ms(cls, value):\n        value = round(value / 1000) * 1000  # Ignore fractions of second\n\n        sorted_units = sorted(cls.UNITS_IN_MILLISECONDS.items(),\n                              key=lambda x: x[1], reverse=True)\n        for unit, unit_in_ms in sorted_units:\n            unit_value = value / unit_in_ms\n            if unit_value.is_integer():\n                return int(unit_value), unit\n        return value, MILLISECOND", "response": "Normalizes a value in ms to the largest unit possible without decimal places."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _normalize_unit(cls, unit):\n        if unit in cls.UNITS_IN_SECONDS:\n            return unit\n        return cls.UNIT_ALIASES_REVERSE.get(unit, None)", "response": "Resolve a unit to its real name if it s an alias."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef convert(cls, value, from_unit, to_unit):\n        value_ms = value * cls.UNITS_IN_MILLISECONDS[from_unit]\n        return value_ms / cls.UNITS_IN_MILLISECONDS[to_unit]", "response": "Convert a value from one time unit to another."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef iterator_mix(*iterators):\n    while True:\n        one_left = False\n\n        for it in iterators:\n            try:\n                yield it.next()\n            except StopIteration:\n                pass\n            else:\n                one_left = True\n\n        if not one_left:\n            break", "response": "A generator that iterates over a list of iterators."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_pr_comment(config, violations):\n    template = env.get_template('pr_comment.txt')\n    return template.render(violations=violations, LINTLY_IDENTIFIER=LINTLY_IDENTIFIER)", "response": "Builds a Markdown representation of the comment."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild a Markdown comment for a pull request.", "response": "def build_pr_review_line_comment(violation):\n    \"\"\"\n    Creates a Markdown representation of the comment to be posted to a pull request.\n    :return: The comment\n    \"\"\"\n    template = env.get_template('pr_review_line_comment.txt')\n    return template.render(violation=violation, LINTLY_IDENTIFIER=LINTLY_IDENTIFIER)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _normalize_path(self, path):\n        norm_path = os.path.normpath(path)\n        return os.path.relpath(norm_path, start=self._get_working_dir())", "response": "Normalizes a file path so that it returns a relative path to the root repo directory."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef translate_github_exception(func):\n\n    @functools.wraps(func)\n    def _wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except UnknownObjectException as e:\n            logger.exception('GitHub API 404 Exception')\n            raise NotFoundError(str(e))\n        except GithubException as e:\n            logger.exception('GitHub API Exception')\n            raise GitClientError(str(e))\n\n    return _wrapper", "response": "Decorator to catch GitHub - specific exceptions and raise them as GitClientError exceptions."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef violations(self):\n        return self._all_violations if self.config.fail_on == FAIL_ON_ANY else self._diff_violations", "response": "Returns either the diff violations or all violations depending on configuration."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execute(self):\n        if not self.config.pr:\n            raise NotPullRequestException\n\n        logger.debug('Using the following configuration:')\n        for name, value in self.config.as_dict().items():\n            logger.debug('  - {}={}'.format(name, repr(value)))\n\n        logger.info('Running Lintly against PR #{} for repo {}'.format(self.config.pr, self.project))\n\n        parser = PARSERS.get(self.config.format)\n        self._all_violations = parser.parse_violations(self.linter_output)\n        logger.info('Lintly found violations in {} files'.format(len(self._all_violations)))\n\n        diff = self.get_pr_diff()\n        patch = self.get_pr_patch(diff)\n        self._diff_violations = self.find_diff_violations(patch)\n        logger.info('Lintly found diff violations in {} files'.format(len(self._diff_violations)))\n\n        self.post_pr_comment(patch)\n        self.post_commit_status()", "response": "Executes a new build on a project."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_diff_violations(self, patch):\n        violations = collections.defaultdict(list)\n        for line in patch.changed_lines:\n            file_violations = self._all_violations.get(line['file_name'])\n            if not file_violations:\n                continue\n\n            line_violations = [v for v in file_violations if v.line == line['line_number']]\n\n            for v in line_violations:\n                violations[line['file_name']].append(v)\n\n        return violations", "response": "Find changed lines that also have violations."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef post_pr_comment(self, patch):\n        if self.has_violations:\n            post_pr_comment = True\n\n            # Attempt to post a PR review. If posting the PR review fails because the bot account\n            # does not have permission to review the PR then simply revert to posting a regular PR\n            # comment.\n            try:\n                logger.info('Deleting old PR review comments')\n                self.git_client.delete_pull_request_review_comments(self.config.pr)\n\n                logger.info('Creating PR review')\n                self.git_client.create_pull_request_review(self.config.pr, patch, self._diff_violations)\n                post_pr_comment = False\n            except GitClientError as e:\n                # TODO: Make `create_pull_request_review` raise an `UnauthorizedError`\n                # so that we don't have to check for a specific message in the exception\n                if 'Viewer does not have permission to review this pull request' in str(e):\n                    logger.warning(\"Could not post PR review (the account didn't have permission)\")\n                    pass\n                else:\n                    raise\n\n            if post_pr_comment:\n                logger.info('Deleting old PR comment')\n                self.git_client.delete_pull_request_comments(self.config.pr)\n\n                logger.info('Creating PR comment')\n                comment = build_pr_comment(self.config, self.violations)\n                self.git_client.create_pull_request_comment(self.config.pr, comment)", "response": "Post a comment to the GitHub PR."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nposting results to a commit status in GitHub if this build is for a pull request.", "response": "def post_commit_status(self):\n        \"\"\"\n        Posts results to a commit status in GitHub if this build is for a pull request.\n        \"\"\"\n        if self.violations:\n            plural = '' if self.introduced_issues_count == 1 else 's'\n            description = 'Pull Request introduced {} linting violation{}'.format(\n                self.introduced_issues_count, plural)\n            self._post_status('failure', description)\n        else:\n            self._post_status('success', 'Linting detected no new issues.')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _post_status(self, state, description):\n        if self.config.post_status:\n            logger.info('Commit statuses enabled')\n            if self.config.commit_sha:\n                logger.info('Posting {} status to commit SHA {}'.format(state, self.config.commit_sha))\n                self.git_client.post_status(\n                    state,\n                    description,\n                    sha=self.config.commit_sha\n                )\n            else:\n                logger.warning('Cannot post commit status because no commit SHA has been '\n                               'specified. Either use the --commit-sha CLI argument or '\n                               'set the LINTLY_COMMIT_SHA environment variable.')\n        else:\n            logger.info('Commit statuses disabled')", "response": "Post the status of a build to the GitHub repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntransforms a regular expression into a LEPL object.", "response": "def reg_to_lex(conditions, wildcards):\n    \"\"\"Transform a regular expression into a LEPL object.\n\n    Replace the wildcards in the conditions by LEPL elements,\n    like xM will be replaced by Any() & 'M'.\n    In case of multiple same wildcards (like xMx), aliases\n    are created to allow the regexp to compile, like\n    Any() > 'x_0' & 'M' & Any() > 'x_1', and we chech that the matched values\n    for all aliases like x_0, x_1 are the same.\n    \"\"\"\n    aliases = defaultdict(set)\n    n_conds = []\n\n    # All conditions\n    for i, _ in enumerate(conditions):\n        n_cond = []\n\n        for char in conditions[i]:\n            if char in wildcards:\n                alias = '%s_%s' % (char, len(aliases[char]))\n                aliases[char].add(alias)\n                n_cond.append(make_token(alias, reg=wildcards[char]))\n            else:\n                n_cond.append(~Literal(char))\n\n        n_cond.append(Eos())\n        n_conds.append(reduce(operator.and_, n_cond) > make_dict)\n\n    return tuple(n_conds), aliases"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main(**options):\n    configure_logging(log_all=options.get('log'))\n\n    stdin_stream = click.get_text_stream('stdin')\n    stdin_text = stdin_stream.read()\n\n    click.echo(stdin_text)\n\n    ci = find_ci_provider()\n    config = Config(options, ci=ci)\n\n    build = LintlyBuild(config, stdin_text)\n    try:\n        build.execute()\n    except NotPullRequestException:\n        logger.info('Not a PR. Lintly is exiting.')\n        sys.exit(0)\n\n    # Exit with the number of files that have violations\n    sys.exit(len(build.violations))", "response": "Main function for the linter."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef translate_gitlab_exception(func):\n\n    @functools.wraps(func)\n    def _wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except gitlab.GitlabError as e:\n            status_to_exception = {\n                401: UnauthorizedError,\n                404: NotFoundError,\n            }\n\n            exc_class = status_to_exception.get(e.response_code, GitClientError)\n            raise exc_class(str(e), status_code=e.response_code)\n\n    return _wrapper", "response": "Decorator to catch GitLab - specific exceptions and raise them as GitClientError exceptions."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitializes a generic DutSerial object for the local hardware dut.", "response": "def init_generic_serial_dut(contextlist, conf, index, args):\n    \"\"\"\n    Initializes a local hardware dut\n    \"\"\"\n    port = conf['serial_port']\n    baudrate = (args.baudrate if args.baudrate else conf.get(\n        \"application\", {}).get(\"baudrate\", 115200))\n    serial_config = {}\n    if args.serial_rtscts:\n        serial_config[\"serial_rtscts\"] = args.serial_rtscts\n    elif args.serial_xonxoff:\n        serial_config[\"serial_xonxoff\"] = args.serial_xonxoff\n\n    if args.serial_timeout:\n        serial_config[\"serial_timeout\"] = args.serial_timeout\n\n    ch_mode_config = {}\n    if args.serial_ch_size > 0:\n        ch_mode_config[\"ch_mode\"] = True\n        ch_mode_config[\"ch_mode_chunk_size\"] = args.serial_ch_size\n    elif args.serial_ch_size is 0:\n        ch_mode_config[\"ch_mode\"] = False\n\n    if args.ch_mode_ch_delay:\n        ch_mode_config[\"ch_mode_ch_delay\"] = args.ch_mode_ch_delay\n    dut = DutSerial(name=\"D%d\" % index, port=port, baudrate=baudrate,\n                    config=conf, ch_mode_config=ch_mode_config,\n                    serial_config=serial_config, params=args)\n    dut.index = index\n\n    dut.platform = conf.get(\"platform_name\", \"serial\")\n\n    msg = 'Use device in serial port {} as D{}'\n    contextlist.logger.info(msg.format(port,\n                                       index))\n\n    contextlist.duts.append(dut)\n    contextlist.dutinformations.append(dut.get_info())"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitializes a local hardware dut based on the given command line arguments.", "response": "def init_mbed_dut(contextlist, conf, index, args):\n    \"\"\"\n    Initializes a local hardware dut\n    \"\"\"\n    binary = None\n    try:\n        binary = conf[\"application\"]['bin']\n    except KeyError:\n        pass\n\n    dev = conf.get('allocated', None)\n    if not dev:\n        raise ResourceInitError(\"Allocated device not found.\")\n\n    port = dev['serial_port']\n    baudrate = (args.baudrate if args.baudrate else\n                conf.get(\"application\", {}).get(\"baudrate\", 115200))\n    serial_config = {}\n    if args.serial_rtscts:\n        serial_config[\"serial_rtscts\"] = args.serial_rtscts\n    elif args.serial_xonxoff:\n        serial_config[\"serial_xonxoff\"] = args.serial_xonxoff\n\n    if args.serial_timeout:\n        serial_config[\"serial_timeout\"] = args.serial_timeout\n\n    ch_mode_config = {}\n    if args.serial_ch_size > 0:\n        ch_mode_config[\"ch_mode\"] = True\n        ch_mode_config[\"ch_mode_chunk_size\"] = args.serial_ch_size\n    elif args.serial_ch_size is 0:\n        ch_mode_config[\"ch_mode\"] = False\n\n    if args.ch_mode_ch_delay:\n        ch_mode_config[\"ch_mode_ch_delay\"] = args.ch_mode_ch_delay\n\n    dut = DutMbed(name=\"D%d\" % index, port=port, baudrate=baudrate,\n                  config=conf, ch_mode_config=ch_mode_config,\n                  serial_config=serial_config, params=args)\n    dut.index = index\n\n    # If something to flash, get the allocated device and flash it\n    if binary and not args.skip_flash:\n        if contextlist.check_flashing_need('hardware',\n                                           binary,\n                                           args.forceflash):\n            if dut.flash(binary_location=binary, forceflash=args.forceflash):\n                contextlist.logger.info('flash ready')\n            else:\n                dut.close_dut(False)\n                dut.close_connection()\n                dut = None\n                raise ResourceInitError(\"Dut flashing failed!\")\n\n    dut.platform = dev[\"platform_name\"]\n\n    msg = 'Use board {} as \"{}\" (id: {})'\n    contextlist.logger.info(msg.format(dev['platform_name'],\n                                       dut.get_dut_name(),\n                                       dev['target_id']))\n\n    contextlist.duts.append(dut)\n    contextlist.dutinformations.append(dut.get_info())"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef init_process_dut(contextlist, conf, index, args):\n    if \"subtype\" in conf and conf[\"subtype\"]:\n        if conf[\"subtype\"] != \"console\":\n            msg = \"Unrecognized process subtype: {}\"\n            contextlist.logger.error(msg.format(conf[\"subtype\"]))\n            raise ResourceInitError(\"Unrecognized process subtype: {}\")\n        # This is a specialized 'console' process\n        config = None\n        if \"application\" in conf:\n            config = conf[\"application\"]\n        contextlist.logger.debug(\"Starting a remote console\")\n        dut = DutConsole(name=\"D%d\" % index, conf=config, params=args)\n        dut.index = index\n    else:\n        binary = conf[\"application\"]['bin']\n        app_config = conf[\"application\"]\n        init_cli_cmds = app_config.get(\"init_cli_cmds\", None)\n        post_cli_cmds = app_config.get(\"post_cli_cmds\", None)\n        contextlist.logger.debug(\"Starting process '%s'\" % binary)\n        dut = DutProcess(name=\"D%d\" % index, config=conf, params=args)\n        dut.index = index\n        dut.command = binary\n        if args.valgrind:\n            dut.use_valgrind(args.valgrind_tool,\n                             not args.valgrind_text,\n                             args.valgrind_console,\n                             args.valgrind_track_origins,\n                             args.valgrind_extra_params)\n        if args.gdb == index:\n            dut.use_gdb()\n            contextlist.logger.info(\"GDB is activated for node %i\" % index)\n        if args.gdbs == index:\n            dut.use_gdbs(True, args.gdbs_port)\n            contextlist.logger.info(\"GDBserver is activated for node %i\" % index)\n        if args.vgdb == index:\n            dut.use_vgdb()\n            contextlist.logger.info(\"VGDB is activated for node %i\" % index)\n        if args.nobuf:\n            dut.no_std_buf()\n\n        if init_cli_cmds is not None:\n            dut.set_init_cli_cmds(init_cli_cmds)\n        if post_cli_cmds is not None:\n            dut.set_post_cli_cmds(post_cli_cmds)\n\n    contextlist.duts.append(dut)\n    contextlist.dutinformations.append(dut.get_info())", "response": "Initialize process type Dut as DutProcess or DutConsole."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nallocates resources from available local hardware duts.", "response": "def allocate(self, dut_configuration_list, args=None):\n        \"\"\"\n        Allocates resources from available local devices.\n\n        :param dut_configuration_list: List of ResourceRequirements objects\n        :param args: Not used\n        :return: AllocationContextList with allocated resources\n        \"\"\"\n        dut_config_list = dut_configuration_list.get_dut_configuration()\n        # if we need one or more local hardware duts let's search attached\n        # devices using DutDetection\n        if not isinstance(dut_config_list, list):\n            raise AllocationError(\"Invalid dut configuration format!\")\n\n        if next((item for item in dut_config_list if item.get(\"type\") == \"hardware\"), False):\n            self._available_devices = DutDetection().get_available_devices()\n            if len(self._available_devices) < len(dut_config_list):\n                raise AllocationError(\"Required amount of devices not available.\")\n\n        # Enumerate all required DUT's\n        try:\n            for dut_config in dut_config_list:\n                if not self.can_allocate(dut_config.get_requirements()):\n                    raise AllocationError(\"Resource type is not supported\")\n                self._allocate(dut_config)\n        except AllocationError:\n            # Locally allocated don't need to be released any way for\n            # now, so just re-raise the error\n            raise\n        alloc_list = AllocationContextList()\n        res_id = None\n        for conf in dut_config_list:\n            if conf.get(\"type\") == \"mbed\":\n                res_id = conf.get(\"allocated\").get(\"target_id\")\n            context = AllocationContext(resource_id=res_id, alloc_data=conf)\n            alloc_list.append(context)\n\n        alloc_list.set_dut_init_function(\"serial\", init_generic_serial_dut)\n        alloc_list.set_dut_init_function(\"process\", init_process_dut)\n        alloc_list.set_dut_init_function(\"mbed\", init_mbed_dut)\n\n        return alloc_list"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register_tc_plugins(self, plugin_name, plugin_class):\n        if plugin_name in self.registered_plugins:\n            raise PluginException(\"Plugin {} already registered! Duplicate \"\n                                  \"plugins?\".format(plugin_name))\n        self.logger.debug(\"Registering plugin %s\", plugin_name)\n        plugin_class.init(bench=self.bench)\n        if plugin_class.get_bench_api() is not None:\n            register_func = self.plugin_types[PluginTypes.BENCH]\n            register_func(plugin_name, plugin_class)\n        if plugin_class.get_parsers() is not None:\n            register_func = self.plugin_types[PluginTypes.PARSER]\n            register_func(plugin_name, plugin_class)\n        if plugin_class.get_external_services() is not None:\n            register_func = self.plugin_types[PluginTypes.EXTSERVICE]\n            register_func(plugin_name, plugin_class)\n\n        self.registered_plugins.append(plugin_name)", "response": "Loads a plugin as a dictionary and attaches needed parts to correct areas for testing\n        parts."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nregistering a plugin as a dictionary and attaches needed parts to correct Icetea run global parts.", "response": "def register_run_plugins(self, plugin_name, plugin_class):\n        \"\"\"\n        Loads a plugin as a dictionary and attaches needed parts to correct Icetea run\n        global parts.\n\n        :param plugin_name: Name of the plugins\n        :param plugin_class: PluginBase\n        :return: Nothing\n        \"\"\"\n        if plugin_name in self.registered_plugins:\n            raise PluginException(\"Plugin {} already registered! \"\n                                  \"Duplicate plugins?\".format(plugin_name))\n        self.logger.debug(\"Registering plugin %s\", plugin_name)\n        if plugin_class.get_allocators():\n            register_func = self.plugin_types[PluginTypes.ALLOCATOR]\n            register_func(plugin_name, plugin_class)\n        self.registered_plugins.append(plugin_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload default test case level plugins from icetea_lib. Plugin. plugins. default_plugins.", "response": "def load_default_tc_plugins(self):\n        \"\"\"\n        Load default test case level plugins from icetea_lib.Plugin.plugins.default_plugins.\n\n        :return: Nothing\n        \"\"\"\n        for plugin_name, plugin_class in default_plugins.items():\n            if issubclass(plugin_class, PluginBase):\n                try:\n                    self.register_tc_plugins(plugin_name, plugin_class())\n                except PluginException as error:\n                    self.logger.debug(error)\n                    continue"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_custom_tc_plugins(self, plugin_path=None):\n        if not plugin_path:\n            return\n        directory = os.path.dirname(plugin_path)\n        sys.path.append(directory)\n        modulename = os.path.split(plugin_path)[1]\n        # Strip of file extension.\n        if \".\" in modulename:\n            modulename = modulename[:modulename.rindex(\".\")]\n        try:\n            module = importlib.import_module(modulename)\n        except ImportError:\n            raise PluginException(\"Unable to import custom plugin information from {}.\".format(\n                plugin_path))\n        for plugin_name, plugin_class in module.plugins_to_load.items():\n            if issubclass(plugin_class, PluginBase):\n                try:\n                    self.register_tc_plugins(plugin_name, plugin_class())\n                except PluginException as error:\n                    self.logger.debug(error)\n                    continue", "response": "Load custom test case level plugins from a path."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_default_run_plugins(self):\n        for plugin_name, plugin_class in default_plugins.items():\n            if issubclass(plugin_class, RunPluginBase):\n                try:\n                    self.register_run_plugins(plugin_name, plugin_class())\n                except PluginException as error:\n                    self.logger.debug(error)\n                    continue", "response": "Load default run level plugins from icetea_lib. Plugin. plugins. default_plugins."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstarting external service with given name with configuration conf.", "response": "def start_external_service(self, service_name, conf=None):\n        \"\"\"\n        Start external service service_name with configuration conf.\n\n        :param service_name: Name of service to start\n        :param conf:\n        :return: nothing\n        \"\"\"\n        if service_name in self._external_services:\n            ser = self._external_services[service_name]\n            service = ser(service_name, conf=conf, bench=self.bench)\n            try:\n                service.start()\n            except PluginException:\n                self.logger.exception(\"Starting service %s caused an exception!\", service_name)\n                raise PluginException(\"Failed to start external service {}\".format(service_name))\n            self._started_services.append(service)\n            setattr(self.bench, service_name, service)\n        else:\n            self.logger.warning(\"Service %s not found. Check your plugins.\", service_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstop all external services.", "response": "def stop_external_services(self):\n        \"\"\"\n        Stop all external services.\n\n        :return: Nothing\n        \"\"\"\n        for service in self._started_services:\n            self.logger.debug(\"Stopping application %s\", service.name)\n            try:\n                service.stop()\n            except PluginException:\n                self.logger.exception(\"Stopping external service %s caused and exception!\",\n                                      service.name)\n        self._started_services = []"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _register_bench_extension(self, plugin_name, plugin_instance):\n        for attr in plugin_instance.get_bench_api().keys():\n            if hasattr(self.bench, attr):\n                raise PluginException(\"Attribute {} already exists in bench! Unable to add \"\n                                      \"plugin {}.\".format(attr, plugin_name))\n            setattr(self.bench, attr, plugin_instance.get_bench_api().get(attr))", "response": "Register a bench extension."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nregisters a parser. :param plugin_name: Parser name :param plugin_instance: PluginBase :return: Nothing", "response": "def _register_dataparser(self, plugin_name, plugin_instance):\n        \"\"\"\n        Register a parser.\n\n        :param plugin_name: Parser name\n        :param plugin_instance: PluginBase\n        :return: Nothing\n        \"\"\"\n        for parser in plugin_instance.get_parsers().keys():\n            if self.responseparser.has_parser(parser):\n                raise PluginException(\"Parser {} already registered to parsers! Unable to \"\n                                      \"add parsers from {}.\".format(parser, plugin_name))\n            self.responseparser.add_parser(parser, plugin_instance.get_parsers().get(parser))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _register_external_service(self, plugin_name, plugin_instance):\n        for attr in plugin_instance.get_external_services().keys():\n            if attr in self._external_services:\n                raise PluginException(\"External service with name {} already exists! Unable to add \"\n                                      \"services from plugin {}.\".format(attr, plugin_name))\n            self._external_services[attr] = plugin_instance.get_external_services().get(attr)", "response": "Register an external service."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _register_allocator(self, plugin_name, plugin_instance):\n        for allocator in plugin_instance.get_allocators().keys():\n            if allocator in self._allocators:\n                raise PluginException(\"Allocator with name {} already exists! unable to add \"\n                                      \"allocators from plugin {}\".format(allocator, plugin_name))\n            self._allocators[allocator] = plugin_instance.get_allocators().get(allocator)", "response": "Register an allocator.\n\n        :param plugin_name: Allocator name\n        :param plugin_instance: RunPluginBase\n        :return:"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(host, port, result_converter=None, testcase_converter=None, args=None):\n    return SampleClient(host, port, result_converter, testcase_converter, args)", "response": "Function which creates an instance of the cloud client."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupload a result object to server.", "response": "def send_results(self, result):\n        \"\"\"\n        Upload a result object to server.\n        If resultConverter has been provided, use it to convert result object to format accepted\n        by the server.\n        If needed, use testcase_converter to convert tc metadata in result to suitable format.\n\n        returns new result entry as a dictionary or None.\n        \"\"\"\n        if self.result_converter:\n            print(self.result_converter(result))\n        else:\n            print(result)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_tc_api(self, host, headers=None, cert=None, logger=None):\n        '''\n        Gets HttpApi wrapped into a neat little package that raises TestStepFail\n        if expected status code is not returned by the server.\n        Default setting for expected status code is 200. Set expected to None when calling methods\n        to ignore the expected status code parameter or\n        set raiseException = False to disable raising the exception.\n        '''\n        if logger is None and self.logger:\n            logger = self.logger\n        return Api(host, headers, cert, logger)", "response": "Gets HttpApi wrapped into a neat little package that raises TestStepFail\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nraising a TestStepFail with neatly formatted error message", "response": "def _raise_fail(self, response, expected):\n        \"\"\"\n        Raise a TestStepFail with neatly formatted error message\n        \"\"\"\n        try:\n            if self.logger:\n                self.logger.error(\"Status code \"\n                                  \"{} != {}. \\n\\n \"\n                                  \"Payload: {}\".format(response.status_code,\n                                                       expected,\n                                                       response.content))\n            raise TestStepFail(\"Status code {} != {}.\".format(response.status_code, expected))\n        except TestStepFail:\n            raise\n        except:  # pylint: disable=bare-except\n            if self.logger:\n                self.logger.error(\"Status code \"\n                                  \"{} != {}. \\n\\n \"\n                                  \"Payload: {}\".format(response.status_code,\n                                                       expected,\n                                                       \"Unable to parse payload\"))\n            raise TestStepFail(\"Status code {} != {}.\".format(response.status_code, expected))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsearches with one value to return.", "response": "def find_one(line, lookup):\n        \"\"\"\n        regexp search with one value to return.\n\n        :param line: Line\n        :param lookup: regexp\n        :return: Match group or False\n        \"\"\"\n        match = re.search(lookup, line)\n        if match:\n            if match.group(1):\n                return match.group(1)\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialize duts of different types based on configuration provided by AllocationContext.", "response": "def init_duts(self, args):  # pylint: disable=too-many-locals,too-many-branches\n        \"\"\"\n        Initializes duts of different types based on configuration provided by AllocationContext.\n        Able to do the initialization of duts in parallel, if --parallel_flash was provided.\n\n        :param args: Argument Namespace object\n        :return: list of initialized duts.\n        \"\"\"\n        # TODO: Split into smaller chunks to reduce complexity.\n        threads = []\n        abort_queue = Queue()\n\n        def thread_wrapper(*thread_args, **thread_kwargs):\n            \"\"\"\n            Run initialization function for dut\n\n            :param thread_args: arguments to pass to the function\n            :param thread_kwargs: keyword arguments, (func: callable, abort_queue: Queue)\n            :return: Result of func(*thread_args)\n            \"\"\"\n            # pylint: disable=broad-except\n            try:\n                return thread_kwargs[\"func\"](*thread_args)\n            except Exception as error:\n                thread_kwargs[\"abort_queue\"].put((thread_args[2], error))\n\n        for index, dut_conf in enumerate(self._allocation_contexts):\n            dut_type = dut_conf.get(\"type\")\n            func = self.get_dut_init_function(dut_type)\n            if func is None:\n                continue\n\n            threads.append(((self, dut_conf.get_alloc_data().get_requirements(), index + 1, args),\n                            {\"func\": func, \"abort_queue\": abort_queue}))\n\n        try:\n            thread_limit = len(threads) if args.parallel_flash else 1\n            pool = ThreadPool(thread_limit)\n            async_results = [pool.apply_async(func=thread_wrapper,\n                                              args=t[0], kwds=t[1])\n                             for t in threads]\n            # Wait for resources to be ready.\n            [res.get() for res in async_results]  # pylint: disable=expression-not-assigned\n\n            pool.close()\n            pool.join()\n\n            if not abort_queue.empty():\n                msg = \"Dut Initialization failed, reason(s):\"\n                while not abort_queue.empty():\n                    dut_index, error = abort_queue.get()\n                    msg = \"{}\\nDUT index {} - {}\".format(msg, dut_index, error)\n\n                raise AllocationError(msg)\n\n            # Sort duts to same order as in dut_conf_list\n            self.duts.sort(key=lambda d: d.index)\n            self.dutinformations.sort(key=lambda d: d.index)\n\n        except KeyboardInterrupt:\n            msg = \"Received keyboard interrupt, waiting for flashing to finish\"\n            self.logger.info(msg)\n            for dut in self.duts:\n                dut.close_dut(False)\n                dut.close_connection()\n                if hasattr(dut, \"release\"):\n                    dut.release()\n                dut = None\n            raise\n        except RuntimeError:\n            self.logger.exception(\"RuntimeError during flashing\")\n        # ValueError is raised if ThreadPool is tried to initiate with\n        # zero threads.\n        except ValueError:\n            self.logger.exception(\"No devices allocated\")\n            raise AllocationError(\"Dut Initialization failed!\")\n        except (DutConnectionError, TypeError):\n            for dut in self.duts:\n                if hasattr(dut, \"release\"):\n                    dut.release()\n            raise AllocationError(\"Dut Initialization failed!\")\n        finally:\n            if pool:\n                pool.close()\n                pool.join()\n        self.logger.debug(\"Allocated following duts:\")\n        for dut in self.duts:\n            dut.print_info()\n\n        return self.duts"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nopen connections to Duts. Starts read threads.", "response": "def open_dut_connections(self):\n        \"\"\"\n        Opens connections to Duts. Starts Dut read threads.\n\n        :return: Nothing\n        :raises DutConnectionError: if problems were encountered while opening dut connection.\n        \"\"\"\n        for dut in self.duts:\n            try:\n                dut.start_dut_thread()\n                if hasattr(dut, \"command\"):\n                    dut.open_dut(dut.command)\n                else:\n                    dut.open_dut()\n            except DutConnectionError:\n                self.logger.exception(\"Failed when opening dut connection\")\n                dut.close_dut(False)\n                dut.close_connection()\n                dut = None\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_flashing_need(self, execution_type, build_id, force):\n        binary_file_name = AllocationContextList.get_build(build_id)\n        if binary_file_name:\n            if execution_type == 'hardware' and os.path.isfile(binary_file_name):\n                if not force:\n                    #@todo: Make a better check for binary compatibility\n                    extension_split = os.path.splitext(binary_file_name)\n                    extension = extension_split[-1].lower()\n                    if extension != '.bin' and extension != '.hex':\n                        self.logger.debug(\"File ('%s') is not supported to flash, skip it\" %(\n                            build_id))\n                        return False\n                    return True\n                return True\n            else:\n                raise ResourceInitError(\"Given binary %s does not exist\" % build_id)\n        else:\n            raise ResourceInitError(\"Given binary %s does not exist\" % build_id)", "response": "Check if flashing of local device is required."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves handlers from a logger.", "response": "def remove_handlers(logger):\n    # TODO: Issue related to placeholder logger objects appearing in some rare cases. Check below\n    # required as a workaround\n    \"\"\"\n    Remove handlers from logger.\n\n    :param logger: Logger whose handlers to remove\n    \"\"\"\n    if hasattr(logger, \"handlers\"):\n        for handler in logger.handlers[::-1]:\n            try:\n                if isinstance(handler, logging.FileHandler):\n                    handler.close()\n                logger.removeHandler(handler)\n            except:  # pylint: disable=bare-except\n                import traceback\n                traceback.print_exc()\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_base_logfilename(logname):\n    logdir = get_base_dir()\n    fname = os.path.join(logdir, logname)\n    GLOBAL_LOGFILES.append(fname)\n    return fname", "response": "Return the base filename for a logfile"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a file logger that will log into a file located in the testcase log directory.", "response": "def get_file_logger(name, formatter=None):\n    \"\"\"\n    Return a file logger that will log into a file located in the testcase log\n    directory. Anything logged with a file logger won't be visible in the\n    console or any other logger.\n\n    :param name: Name of the logger, eg. the module name\n    :param formatter: Formatter to use\n    \"\"\"\n    if name is None or name == \"\":\n        raise ValueError(\"Can't make a logger without name\")\n\n    logger = logging.getLogger(name)\n    remove_handlers(logger)\n    logger.setLevel(logging.INFO)\n\n    if formatter is None:\n        config = LOGGING_CONFIG.get(name, {}).get(\"file\", DEFAULT_LOGGING_CONFIG.get(\"file\"))\n        formatter = BenchFormatter(config.get(\"level\", \"DEBUG\"), config.get(\"dateformat\"))\n    func = get_testcase_logfilename(name + \".log\")\n    handler = _get_filehandler_with_formatter(func, formatter)\n    logger.addHandler(handler)\n    return logger"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if existing logger with name loggername exists.", "response": "def _check_existing_logger(loggername, short_name):\n    \"\"\"\n    Check if logger with name loggername exists.\n\n    :param loggername: Name of logger.\n    :param short_name: Shortened name for the logger.\n    :return: Logger or None\n    \"\"\"\n    if loggername in LOGGERS:\n        # Check if short_name matches the existing one, if not update it\n        if isinstance(LOGGERS[loggername], BenchLoggerAdapter):\n            if (\"source\" not in LOGGERS[loggername].extra or\n                    LOGGERS[loggername].extra[\"source\"] != short_name):\n                LOGGERS[loggername].extra[\"source\"] = short_name\n        return LOGGERS[loggername]\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _add_filehandler(logger, logpath, formatter=None, name=\"Bench\"):\n    formatter = formatter if formatter else BenchFormatterWithType(loggername=name)\n    handler = _get_filehandler_with_formatter(logpath, formatter)\n    config = LOGGING_CONFIG.get(name, {}).get(\"file\", DEFAULT_LOGGING_CONFIG.get(\"file\"))\n    handler.setLevel(getattr(logging, config.get(\"level\", \"DEBUG\")))\n    logger.addHandler(handler)\n    return logger", "response": "Adds a FileHandler to a Logger."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a logger with our basic configuration done.", "response": "def _get_basic_logger(loggername, log_to_file, logpath):\n    \"\"\"\n    Get a logger with our basic configuration done.\n\n    :param loggername: Name of logger.\n    :param log_to_file: Boolean, True if this logger should write a file.\n    :return: Logger\n    \"\"\"\n    logger = logging.getLogger(loggername)\n    logger.propagate = False\n    remove_handlers(logger)\n    logger.setLevel(logging.DEBUG)\n    logger_config = LOGGING_CONFIG.get(loggername, DEFAULT_LOGGING_CONFIG)\n    if TRUNCATE_LOG or logger_config.get(\"truncate_logs\").get(\"truncate\"):\n        cfilter = ContextFilter()\n        trunc_logs = logger_config.get(\"truncate_logs\")\n        # pylint: disable=invalid-name\n        cfilter.MAXIMUM_LENGTH = trunc_logs.get(\"max_len\",\n                                                DEFAULT_LOGGING_CONFIG.get(\n                                                    \"truncate_logs\").get(\"max_len\"))\n        cfilter.REVEAL_LENGTH = trunc_logs.get(\"reveal_len\",\n                                               DEFAULT_LOGGING_CONFIG.get(\n                                                   \"truncate_logs\").get(\"reveal_len\"))\n        logger.addFilter(cfilter)\n\n    # Filehandler for logger\n    if log_to_file:\n        _add_filehandler(logger, logpath, name=loggername)\n\n    return logger"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_resourceprovider_logger(name=None, short_name=\" \", log_to_file=True):\n\n    global LOGGERS\n    loggername = name\n    logger = _check_existing_logger(loggername, short_name)\n    if logger is not None:\n        return logger\n    logger_config = LOGGING_CONFIG.get(name, DEFAULT_LOGGING_CONFIG)\n    logger = _get_basic_logger(loggername, log_to_file, get_base_logfilename(loggername + \".log\"))\n\n    cbh = logging.StreamHandler()\n    cbh.formatter = BenchFormatterWithType(COLOR_ON)\n    if VERBOSE_LEVEL > 0 and not SILENT_ON:\n        cbh.setLevel(logging.DEBUG)\n    elif SILENT_ON:\n        cbh.setLevel(logging.WARN)\n    else:\n        cbh.setLevel(getattr(logging, logger_config.get(\"level\")))\n    logger.addHandler(cbh)\n\n    LOGGERS[loggername] = BenchLoggerAdapter(logger, {\"source\": short_name})\n\n    return LOGGERS[loggername]", "response": "Get a logger for ResourceProvider and its components."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_external_logger(name=None, short_name=\" \", log_to_file=True):\n\n    global LOGGERS\n    loggername = name\n    logger = _check_existing_logger(loggername, short_name)\n    if logger is not None:\n        return logger\n    logging_config = LOGGING_CONFIG.get(name, LOGGING_CONFIG.get(\"external\"))\n    filename = logging_config.get(\"file\", {}).get(\"name\", loggername)\n    if not filename.endswith(\".log\"):\n        filename = str(filename) + \".log\"\n    logger = _get_basic_logger(loggername, log_to_file, get_base_logfilename(filename))\n    cbh = logging.StreamHandler()\n    cbh.formatter = BenchFormatterWithType(COLOR_ON)\n\n    if VERBOSE_LEVEL == 1 and not SILENT_ON:\n        cbh.setLevel(logging.INFO)\n    elif VERBOSE_LEVEL >= 2 and not SILENT_ON:\n        cbh.setLevel(logging.DEBUG)\n    elif SILENT_ON:\n        cbh.setLevel(logging.ERROR)\n    else:\n        cbh.setLevel(getattr(logging, logging_config.get(\"level\")))\n    logger.addHandler(cbh)\n\n    LOGGERS[loggername] = BenchLoggerAdapter(logger, {\"source\": short_name})\n\n    return LOGGERS[loggername]", "response": "Get a logger for external modules."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_bench_logger(name=None, short_name=\"  \", log_to_file=True):\n    global LOGGERS\n\n    # Get the root bench logger if name is none or empty or bench\n    if name is None or name == \"\" or name == \"bench\":\n        return LOGGERS[\"bench\"]\n\n    loggername = \"bench.\" + name\n\n    logger = _check_existing_logger(loggername, short_name)\n    if logger is not None:\n        return logger\n    logger = _get_basic_logger(loggername, log_to_file, get_testcase_logfilename(loggername +\n                                                                                 \".log\"))\n    logger.propagate = True\n    LOGGERS[loggername] = BenchLoggerAdapter(logger, {\"source\": short_name})\n\n    return LOGGERS[loggername]", "response": "Returns a bench logger instance for the given name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the level for a given logger", "response": "def set_level(name, level):\n    \"\"\" Set level for given logger\n    :param name: Name of logger to set the level for\n    :param level: The new level, see possible levels from python logging library\n    \"\"\"\n    if name is None or name == \"\" or name == \"bench\":\n        logging.getLogger(\"bench\").setLevel(level)\n    loggername = \"bench.\" + name\n    logging.getLogger(loggername).setLevel(level)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialize the base logging for the Icetea run.", "response": "def init_base_logging(directory=\"./log\", verbose=0, silent=False, color=False, no_file=False,\n                      truncate=True, config_location=None):\n    \"\"\"\n    Initialize the Icetea logging by creating a directory to store logs\n    for this run and initialize the console logger for Icetea itself.\n\n    :param directory: Directory where to store the resulting logs\n    :param verbose: Log level as integer\n    :param silent: Log level warning\n    :param no_file: Log to file\n    :param color: Log coloring\n    :param truncate: Log truncating\n    :param config_location: Location of config file.\n    :raises IOError if unable to read configuration file.\n    :raises OSError if log path already exists.\n    :raises ImportError if colored logging was requested but coloredlogs module is not installed.\n    \"\"\"\n    global LOGPATHDIR\n    global STANDALONE_LOGGING\n    global TRUNCATE_LOG\n    global COLOR_ON\n    global SILENT_ON\n    global VERBOSE_LEVEL\n\n    if config_location:\n        try:\n            _read_config(config_location)\n        except IOError as error:\n            raise IOError(\"Unable to read from configuration file {}: {}\".format(config_location,\n                                                                                 error))\n        except jsonschema.SchemaError as error:\n            raise jsonschema.SchemaError(\"Logging configuration schema \"\n                                         \"file malformed: {}\".format(error))\n\n    LOGPATHDIR = os.path.join(directory, datetime.datetime.now().strftime(\n        \"%Y-%m-%d_%H%M%S.%f\").rstrip(\"0\"))\n\n    # Initialize the simple console logger for IceteaManager\n    icetealogger = logging.getLogger(\"icetea\")\n    icetealogger.propagate = False\n    icetealogger.setLevel(logging.DEBUG)\n    stream_handler = logging.StreamHandler()\n    formatter = BenchFormatter(LOGGING_CONFIG.get(\"IceteaManager\").get(\"format\"),\n                               LOGGING_CONFIG.get(\"IceteaManager\").get(\"dateformat\"))\n    if not color:\n        stream_handler.setFormatter(formatter)\n    elif color and not COLORS:\n        raise ImportError(\"Missing coloredlogs module. Please install with \"\n                          \"pip to use colors in logging.\")\n    else:\n\n        class ColoredBenchFormatter(coloredlogs.ColoredFormatter):\n            \"\"\"\n            This is defined as an internal class here because coloredlogs is and optional\n            dependency.\n            \"\"\"\n            converter = datetime.datetime.fromtimestamp\n\n            def formatTime(self, record, datefmt=None):\n                date_and_time = self.converter(record.created, tz=pytz.utc)\n                if \"%F\" in datefmt:\n                    msec = \"%03d\" % record.msecs\n                    datefmt = datefmt.replace(\"%F\", msec)\n                str_time = date_and_time.strftime(datefmt)\n                return str_time\n\n        COLOR_ON = color\n        stream_handler.setFormatter(ColoredBenchFormatter(\n            LOGGING_CONFIG.get(\"IceteaManager\").get(\"format\"),\n            LOGGING_CONFIG.get(\"IceteaManager\").get(\"dateformat\"),\n            LEVEL_FORMATS, FIELD_STYLES))\n\n    SILENT_ON = silent\n    VERBOSE_LEVEL = verbose\n    if not no_file:\n        try:\n            os.makedirs(LOGPATHDIR)\n        except OSError:\n            raise OSError(\"Log path %s already exists.\" % LOGPATHDIR)\n        filename = LOGGING_CONFIG.get(\"IceteaManager\").get(\"file\").get(\"name\", \"icetea.log\")\n        icetealogger = _add_filehandler(icetealogger, get_base_logfilename(filename),\n                                        formatter, \"IceteaManager\")\n    if verbose and not silent:\n        stream_handler.setLevel(logging.DEBUG)\n    elif silent:\n        stream_handler.setLevel(logging.WARN)\n    else:\n        stream_handler.setLevel(getattr(logging, LOGGING_CONFIG.get(\"IceteaManager\").get(\"level\")))\n    icetealogger.addHandler(stream_handler)\n    TRUNCATE_LOG = truncate\n    if TRUNCATE_LOG:\n        icetealogger.addFilter(ContextFilter())\n    STANDALONE_LOGGING = False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a logging. FileHandler for given logname using a given logging. Formatter", "response": "def _get_filehandler_with_formatter(logname, formatter=None):\n    \"\"\" Return a logging FileHandler for given logname using a given\n    logging formatter\n    :param logname: Name of the file where logs will be stored, \".log\"\n    extension will be added\n    :param formatter: An instance of logging.Formatter or None if the default\n    should be used\n    :return:\n    \"\"\"\n    handler = logging.FileHandler(logname)\n    if formatter is not None:\n        handler.setFormatter(formatter)\n    return handler"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef traverse_json_obj(obj, path=None, callback=None):\n    if path is None:\n        path = []\n\n    if isinstance(obj, dict):\n        value = {k: traverse_json_obj(v, path + [k], callback)\n                 for k, v in obj.items()}\n    elif isinstance(obj, list):\n        value = [traverse_json_obj(elem, path + [[]], callback)\n                 for elem in obj]\n    else:\n        value = obj\n\n    if callback is None:\n        return value\n    return callback(value)", "response": "Recursively loop through object and perform the function defined\n    in callback for every element."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading configuration for logging from a json file.", "response": "def _read_config(config_location):\n    \"\"\"\n    Read configuration for logging from a json file. Merges the read dictionary to LOGGING_CONFIG.\n\n    :param config_location: Location of file.\n    :return: nothing.\n    \"\"\"\n    global LOGGING_CONFIG\n    with open(config_location, \"r\") as config_loc:\n        cfg_file = json.load(config_loc)\n        if \"logging\" in cfg_file:\n            log_dict = cfg_file.get(\"logging\")\n            with open(os.path.abspath(os.path.join(__file__,\n                                                   os.path.pardir,\n                                                   'logging_schema.json'))) as schema_file:\n                logging_schema = json.load(schema_file)\n                jsonschema.validate(log_dict, logging_schema)\n                merged = jsonmerge.merge(LOGGING_CONFIG, log_dict)\n                LOGGING_CONFIG = merged"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nformat record with formatter.", "response": "def format(self, record):\n        \"\"\"\n        Format record with formatter.\n\n        :param record: Record to format\n        :return: Formatted record\n        \"\"\"\n        if not hasattr(record, \"type\"):\n            record.type = \"   \"\n        return self._formatter.format(record)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef filter(self, record):\n\n        def modify(value):\n            \"\"\"\n            Modify logged record, truncating it to max length and logging remaining length\n            :param value: Record to modify\n            :return:\n            \"\"\"\n            if isinstance(value, six.string_types):\n                if len(value) < ContextFilter.MAXIMUM_LENGTH:\n                    return value\n\n                try:\n                    return \"{}...[{} more bytes]\".format(\n                        value[:ContextFilter.REVEAL_LENGTH],\n                        len(value) - ContextFilter.REVEAL_LENGTH)\n                except UnicodeError:\n                    return \"{}...[{} more bytes]\".format(\n                        repr(value[:ContextFilter.REVEAL_LENGTH]),\n                        len(value) - ContextFilter.REVEAL_LENGTH)\n            elif isinstance(value, six.binary_type):\n                return \"{}...[{} more bytes]\".format(\n                    repr(value[:ContextFilter.REVEAL_LENGTH]),\n                    len(value) - ContextFilter.REVEAL_LENGTH)\n\n            else:\n                return value\n\n        record.msg = traverse_json_obj(record.msg, callback=modify)\n        return True", "response": "Filter log record by the filter"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nformats a message as a three - line error message.", "response": "def format_message(msg):\n    \"\"\"\n    Formatting function for assert messages. Fetches the filename,\n    function and line number of the code causing the fail\n    and formats it into a three-line error message. Stack inspection is used to get the information.\n    Originally done by BLE-team for their testcases.\n\n    :param msg: Message to be printed along with the information.\n    :return: Formatted message as string.\n    \"\"\"\n    callerframerecord = inspect.stack()[2]\n    frame = callerframerecord[0]\n    info = inspect.getframeinfo(frame)\n    _, filename = os.path.split(info.filename)\n    caller_site = \"In file {!s}, in function {!s}, at line {:d}\".format(filename,\n                                                                        info.function,\n                                                                        info.lineno)\n    return \"{!s}\\n{!s}\\n{!s}\".format(msg, caller_site, info.code_context)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nraise TestStepFail if response. verify_trace finds message from response traces.", "response": "def assertTraceDoesNotContain(response, message):\n    \"\"\"\n    Raise TestStepFail if response.verify_trace finds message from response traces.\n\n    :param response: Response. Must contain method verify_trace\n    :param message: Message to look for\n    :return: Nothing\n    :raises: AttributeError if response does not contain verify_trace method.\n    TestStepFail if verify_trace returns True.\n    \"\"\"\n    if not hasattr(response, \"verify_trace\"):\n        raise AttributeError(\"Response object does not contain verify_trace method!\")\n    if response.verify_trace(message, False):\n        raise TestStepFail('Assert: Message(s) \"%s\" in response' % message)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef assertTraceContains(response, message):\n    if not hasattr(response, \"verify_trace\"):\n        raise AttributeError(\"Response object does not contain verify_trace method!\")\n    if not response.verify_trace(message, False):\n        raise TestStepFail('Assert: Message(s) \"%s\" not in response' % message)", "response": "Raises TestStepFail if response. verify_trace does not find message from response traces."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef assertDutTraceDoesNotContain(dut, message, bench):\n    if not hasattr(bench, \"verify_trace\"):\n        raise AttributeError(\"Bench object does not contain verify_trace method!\")\n    if bench.verify_trace(dut, message, False):\n        raise TestStepFail('Assert: Message(s) \"%s\" in response' % message)", "response": "Assert that dut trace does not contain message in response."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef assertNone(expr, message=None):\n    if expr is not None:\n        raise TestStepFail(\n            format_message(message) if message is not None else \"Assert: %s != None\" % str(expr))", "response": "Assert that expr is None."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef assertNotNone(expr, message=None):\n    if expr is None:\n        raise TestStepFail(\n            format_message(message) if message is not None else \"Assert: %s == None\" % str(expr))", "response": "Assert that expr is not None."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef assertEqual(first, second, message=None):\n    if not first == second:\n        raise TestStepFail(\n            format_message(message) if message is not None else \"Assert: %s != %s\" % (str(first),\n                                                                                      str(second)))", "response": "Assert that first equals second."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nasserting that first does not equal second.", "response": "def assertNotEqual(first, second, message=None):\n    \"\"\"\n    Assert that first does not equal second.\n\n    :param first: First part to evaluate\n    :param second: Second part to evaluate\n    :param message: Failure message\n    :raises: TestStepFail if not first != second\n    \"\"\"\n    if not first != second:\n        raise TestStepFail(\n            format_message(message) if message is not None else \"Assert: %s == %s\" % (str(first),\n                                                                                      str(second)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nasserts that jsonStr contains key.", "response": "def assertJsonContains(jsonStr=None, key=None, message=None):\n    \"\"\"\n    Assert that jsonStr contains key.\n\n    :param jsonStr: Json as string\n    :param key: Key to look for\n    :param message: Failure message\n    :raises: TestStepFail if key is not in jsonStr or\n    if loading jsonStr to a dictionary fails or if jsonStr is None.\n    \"\"\"\n    if jsonStr is not None:\n        try:\n            data = json.loads(jsonStr)\n            if key not in data:\n                raise TestStepFail(\n                    format_message(message) if message is not None else \"Assert: \"\n                                                                        \"Key : %s is not \"\n                                                                        \"in : %s\" % (str(key),\n                                                                                     str(jsonStr)))\n        except (TypeError, ValueError) as e:\n            raise TestStepFail(\n                format_message(message) if message is not None else \"Unable to parse json \"+str(e))\n    else:\n        raise TestStepFail(\n            format_message(message) if message is not None else \"Json string is empty\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting absolute path for filename.", "response": "def get_path(filename):\n    \"\"\"\n    Get absolute path for filename.\n\n    :param filename: file\n    :return: path\n    \"\"\"\n    path = abspath(filename) if os.path.isdir(filename) else dirname(abspath(filename))\n    return path"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget relative path for filename in git root.", "response": "def get_git_file_path(filename):\n    \"\"\"\n    Get relative path for filename in git root.\n\n    :param filename: File name\n    :return: relative path or None\n    \"\"\"\n    git_root = get_git_root(filename)\n    return relpath(filename, git_root).replace(\"\\\\\", \"/\") if git_root else ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_remote_url(path, remote=\"origin\"):\n    path = get_path(path)\n    cmd = [\"config\", \"--get\", \"remote.%s.url\" % remote]\n    return __run_git(cmd, path)[0]", "response": "Get remote url in path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndetect GIT information by folder.", "response": "def get_git_info(git_folder, verbose=False):\n    \"\"\"\n    Detect GIT information by folder.\n\n    :param git_folder: Folder\n    :param verbose: Verbosity, boolean, default is False\n    :return: dict\n    \"\"\"\n    if verbose:\n        print(\"detect GIT info by folder: '%s'\" % git_folder)\n    try:\n        git_info = {\n            \"commitid\": get_commit_id(git_folder),\n            \"branch\": get_current_branch(git_folder),\n            \"git_path\": get_git_file_path(git_folder),\n            \"url\": get_remote_url(git_folder),\n            \"scm\": \"unknown\",\n            \"scm_group\": \"unknown\",\n            \"scm_path\": \"unknown\",\n            \"scm_link\": \"\"\n        }\n        if is_git_root_dirty(git_folder):\n            git_info['dirty'] = True\n    except Exception as err:  # pylint: disable=broad-except\n        print(\"GitTool exception:\")\n        print(err)\n        return {}\n\n    if isinstance(git_info['url'], str):\n        match = re.search(r\"github\\.com:(.*)\\/(.*)\", git_info['url'])\n        if match:\n            git_info[\"scm\"] = \"github.com\"\n            git_info[\"scm_path\"] = match.group(2)\n            git_info[\"scm_group\"] = match.group(1)\n            scm_link_end = \" %s/%s\" % (git_info[\"scm_group\"],\n                                       git_info[\"scm_path\"].replace(\".git\", \"\"))\n            git_info[\"scm_link\"] = \"https://github.com/\" + scm_link_end\n            git_info[\"scm_link\"] += \"/tree/%s/%s\" % (git_info['commitid'], git_info[\"git_path\"])\n\n    if verbose:\n        print(\"all git_info:\")\n        print(git_info)\n\n    return git_info"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting git binary location.", "response": "def __get_git_bin():\n    \"\"\"\n    Get git binary location.\n\n    :return: Check git location\n    \"\"\"\n    git = 'git'\n    alternatives = [\n        '/usr/bin/git'\n    ]\n    for alt in alternatives:\n        if os.path.exists(alt):\n            git = alt\n            break\n    return git"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __run_git(cmd, path=None):\n    exe = [__get_git_bin()] + cmd\n    try:\n        proc = subprocess.Popen(exe, cwd=path, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    except subprocess.CalledProcessError:\n        return None, None\n    except ValueError:\n        return None, None\n    except OSError:\n        return None, None\n\n    out, err = proc.communicate()\n    if IS_PYTHON3:\n        out = out.decode(\"utf-8\")\n    if err:\n        print(\"Cmd ('%s') fails: %s\" % (' '.join(exe), err))\n        return None, proc.returncode\n    return out.strip(), proc.returncode", "response": "internal run git command"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget build name. :return: build name. None if not found", "response": "def build(self):\n        \"\"\"\n        get build name.\n\n        :return: build name. None if not found\n        \"\"\"\n        # pylint: disable=len-as-condition\n        if len(self.dutinformation) > 0 and (self.dutinformation.get(0).build is not None):\n            return self.dutinformation.get(0).build.name\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget build date. :return: build date. None if not found", "response": "def build_date(self):\n        \"\"\"\n        get build date.\n\n        :return: build date. None if not found\n        \"\"\"\n        # pylint: disable=len-as-condition\n        if len(self.dutinformation) > 0 and (self.dutinformation.get(0).build is not None):\n            return self.dutinformation.get(0).build.date\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_sha1(self):\n        # pylint: disable=len-as-condition\n        if len(self.dutinformation) > 0 and (self.dutinformation.get(0).build is not None):\n            return self.dutinformation.get(0).build.sha1\n        return None", "response": "get sha1 hash of build."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget build git url.", "response": "def build_git_url(self):\n        \"\"\"\n        get build git url.\n\n        :return: build git url or None if not found\n        \"\"\"\n        # pylint: disable=len-as-condition\n        if len(self.dutinformation) > 0 and (self.dutinformation.get(0).build is not None):\n            return self.dutinformation.get(0).build.giturl\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_data(self):\n        # pylint: disable=len-as-condition\n        if len(self.dutinformation) > 0 and (self.dutinformation.get(0).build is not None):\n            return self.dutinformation.get(0).build.get_data()\n        return None", "response": "get build data.\n\n        :return: build data or None if not found"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build_branch(self):\n        # pylint: disable=len-as-condition\n        if len(self.dutinformation) > 0 and (self.dutinformation.get(0).build is not None):\n            return self.dutinformation.get(0).build.branch\n        return None", "response": "get build branch.\n\n        :return: build branch or None if not found"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef buildcommit(self):\n        # pylint: disable=len-as-condition\n        if len(self.dutinformation) > 0 and (self.dutinformation.get(0).build is not None):\n            return self.dutinformation.get(0).build.commit_id\n        return None", "response": "get build commit id."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_verdict(self, verdict, retcode=-1, duration=-1):\n        verdict = verdict.lower()\n        if not verdict in ['pass', 'fail', 'unknown', 'skip', 'inconclusive']:\n            raise ValueError(\"Unknown verdict {}\".format(verdict))\n        if retcode == -1 and verdict == 'pass':\n            retcode = 0\n        self.__verdict = verdict\n        self.retcode = retcode\n        if duration >= 0:\n            self.duration = duration", "response": "Sets the final verdict for this Result."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncollects metadata into this object", "response": "def build_result_metadata(self, data=None, args=None):\n        \"\"\"\n        collect metadata into this object\n\n        :param data: dict\n        :param args: build from args instead of data\n        \"\"\"\n        data = data if data else self._build_result_metainfo(args)\n        if data.get(\"build_branch\"):\n            self.build_branch = data.get(\"build_branch\")\n        if data.get(\"buildcommit\"):\n            self.buildcommit = data.get(\"buildcommit\")\n        if data.get(\"build_git_url\"):\n            self.build_git_url = data.get(\"build_git_url\")\n        if data.get(\"build_url\"):\n            self.build_url = data.get(\"build_url\")\n        if data.get(\"campaign\"):\n            self.campaign = data.get(\"campaign\")\n        if data.get(\"job_id\"):\n            self.job_id = data.get(\"job_id\")\n        if data.get(\"toolchain\"):\n            self.toolchain = data.get(\"toolchain\")\n        if data.get(\"build_date\"):\n            self.build_date = data.get(\"build_date\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _build_result_metainfo(args):\n        data = dict()\n        if hasattr(args, \"branch\") and args.branch:\n            data[\"build_branch\"] = args.branch\n        if hasattr(args, \"commitId\") and args.commitId:\n            data[\"buildcommit\"] = args.commitId\n        if hasattr(args, \"gitUrl\") and args.gitUrl:\n            data[\"build_git_url\"] = args.gitUrl\n        if hasattr(args, \"buildUrl\") and args.buildUrl:\n            data[\"build_url\"] = args.buildUrl\n        if hasattr(args, \"campaign\") and args.campaign:\n            data[\"campaign\"] = args.campaign\n        if hasattr(args, \"jobId\") and args.jobId:\n            data[\"job_id\"] = args.jobId\n        if hasattr(args, \"toolchain\") and args.toolchain:\n            data[\"toolchain\"] = args.toolchain\n        if hasattr(args, \"buildDate\") and args.buildDate:\n            data[\"build_date\"] = args.buildDate\n        return data", "response": "Internal helper for collecting metadata from args to results\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget test case duration.", "response": "def get_duration(self, seconds=False):\n        \"\"\"\n        Get test case duration.\n\n        :param seconds: if set to True, return tc duration in seconds, otherwise as str(\n        datetime.timedelta)\n        :return: str(datetime.timedelta) or duration as string in seconds\n        \"\"\"\n        if seconds:\n            return str(self.duration)\n        delta = datetime.timedelta(seconds=self.duration)\n        return str(delta)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if log files are available and return file names if they exist.", "response": "def has_logs(self):\n        \"\"\"\n        Check if log files are available and return file names if they exist.\n\n        :return: list\n        \"\"\"\n        found_files = []\n        if self.logpath is None:\n            return found_files\n        if os.path.exists(self.logpath):\n            for root, _, files in os.walk(os.path.abspath(self.logpath)):\n\n                for fil in files:\n                    found_files.append(os.path.join(root, fil))\n        return found_files"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef open_connection(self):\n        self.logger.debug(\"Open CLI Process '%s'\",\n                          (self.comport), extra={'type': '<->'})\n        self.cmd = self.comport if isinstance(self.comport, list) else [self.comport]\n        if not self.comport:\n            raise DutConnectionError(\"Process not defined!\")\n        try:\n            self.build = Build.init(self.cmd[0])\n        except NotImplementedError as error:\n            self.logger.error(\"Build initialization failed. Check your build location.\")\n            self.logger.debug(error)\n            raise DutConnectionError(error)\n        # Start process&reader thread. Call Dut.process_dut() when new data is coming\n        app = self.config.get(\"application\")\n        if app and app.get(\"bin_args\"):\n            self.cmd = self.cmd + app.get(\"bin_args\")\n        try:\n            self.start_process(self.cmd, processing_callback=lambda: Dut.process_dut(self))\n        except KeyboardInterrupt:\n            raise\n        except Exception as error:\n            raise DutConnectionError(\"Couldn't start DUT target process {}\".format(error))", "response": "Open connection by starting the process."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef close_connection(self):\n        self.logger.debug(\"Close CLI Process '%s'\" % self.cmd, extra={'type': '<->'})\n        self.stop_process()", "response": "Stop the process and close the connection."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite data to the process.", "response": "def writeline(self, data, crlf=\"\\n\"):  # pylint: disable=arguments-differ\n        \"\"\"\n        Write data to process.\n\n        :param data: data to write\n        :param crlf: line end character\n        :return: Nothing\n        \"\"\"\n        GenericProcess.writeline(self, data, crlf=crlf)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start(self):\n        NonBlockingStreamReader._stream_mtx.acquire()\n        NonBlockingStreamReader._streams.append(self._descriptor)\n        NonBlockingStreamReader._stream_mtx.release()", "response": "Start the reader, acquires the global lock before appending the descriptor on the stream.\n        Releases the lock afterwards.\n        :return: Nothing"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the streamdescriptor matching file_descr fileno.", "response": "def _get_sd(file_descr):\n        \"\"\"\n        Get streamdescriptor matching file_descr fileno.\n\n        :param file_descr: file object\n        :return: StreamDescriptor or None\n        \"\"\"\n        for stream_descr in NonBlockingStreamReader._streams:\n            if file_descr == stream_descr.stream.fileno():\n                return stream_descr\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _read_fd(file_descr):\n        try:\n            line = os.read(file_descr, 1024 * 1024)\n        except OSError:\n            stream_desc = NonBlockingStreamReader._get_sd(file_descr)\n            if stream_desc is not None:\n                stream_desc.has_error = True\n                if stream_desc.callback is not None:\n                    stream_desc.callback()\n            return 0\n\n        if line:\n            stream_desc = NonBlockingStreamReader._get_sd(file_descr)\n            if stream_desc is None:\n                return 0 # Process closing\n\n            if IS_PYTHON3:\n                try:\n                    # @TODO: further develop for not ascii/unicode binary content\n                    line = line.decode(\"ascii\")\n                except UnicodeDecodeError:\n                    line = repr(line)\n            stream_desc.buf += line\n            # Break lines\n            split = stream_desc.buf.split(os.linesep)\n            for line in split[:-1]:\n                stream_desc.read_queue.appendleft(strip_escape(line.strip()))\n                if stream_desc.callback is not None:\n                    stream_desc.callback()\n            # Store the remainded, its either '' if last char was '\\n'\n            # or remaining buffer before line end\n            stream_desc.buf = split[-1]\n            return len(line)\n        return 0", "response": "Read incoming data from file handle and return the number of bytes read."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads all pipes using select. poll method.", "response": "def _read_select_poll(poll):\n        \"\"\"\n        Read PIPEs using select.poll() method\n        Available on Linux and some Unixes\n        \"\"\"\n        npipes = len(NonBlockingStreamReader._streams)\n        for stream_descr in NonBlockingStreamReader._streams:\n            if not stream_descr.has_error:\n                poll.register(stream_descr.stream,\n                              select.POLLIN | select.POLLERR | select.POLLHUP | select.POLLNVAL)\n\n        while NonBlockingStreamReader._run_flag:\n            for (file_descr, event) in poll.poll(500):\n                if event == select.POLLIN:\n                    NonBlockingStreamReader._read_fd(file_descr)\n                else:\n                    # Because event != select.POLLIN, the pipe is closed\n                    # but we still want to read all bytes\n                    while NonBlockingStreamReader._read_fd(file_descr) != 0:\n                        pass\n                    # Dut died, signal the processing thread so it notices that no lines coming in\n                    stream_descr = NonBlockingStreamReader._get_sd(file_descr)\n                    if stream_descr is None:\n                        return # PIPE closed but DUT already disappeared\n                    stream_descr.has_error = True\n                    if stream_descr.callback is not None:\n                        stream_descr.callback()\n                        return # Force poll object to reregister only alive descriptors\n\n            # Check if new pipes added, don't need mutext just for reading the size\n            # If we will not get it right now, we will at next time\n            if npipes != len(NonBlockingStreamReader._streams):\n                return"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _read_select_kqueue(k_queue):\n        npipes = len(NonBlockingStreamReader._streams)\n        # Create list of kevent objects\n        # pylint: disable=no-member\n        kevents = [select.kevent(s.stream.fileno(),\n                                 filter=select.KQ_FILTER_READ,\n                                 flags=select.KQ_EV_ADD | select.KQ_EV_ENABLE)\n                   for s in NonBlockingStreamReader._streams]\n        while NonBlockingStreamReader._run_flag:\n            events = k_queue.control(kevents, npipes, 0.5)  # Wake up twice in second\n            for event in events:\n                if event.filter == select.KQ_FILTER_READ:  # pylint: disable=no-member\n                    NonBlockingStreamReader._read_fd(event.ident)\n            # Check if new pipes added.\n            if npipes != len(NonBlockingStreamReader._streams):\n                return", "response": "Read PIPES using BSD Kqueue\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run():\n        while NonBlockingStreamReader._run_flag:\n            # Wait for streams to appear\n            if not NonBlockingStreamReader._streams:\n                time.sleep(0.2)\n                continue\n            # Try to get correct select/poll method for this OS\n            # Try if select.poll() is supported (Linux/UNIX)\n            try:\n                poll = select.poll()\n            except AttributeError:\n                pass\n            else:\n                NonBlockingStreamReader._read_select_poll(poll)\n                del poll\n                continue\n            # Try is select.kqueue is supported (BSD/OS X)\n            try:\n                k_queue = select.kqueue()  # pylint: disable=no-member\n            except AttributeError:\n                pass\n            else:\n                NonBlockingStreamReader._read_select_kqueue(k_queue)\n                k_queue.close()\n                continue\n            # Not workable polling method found\n            raise RuntimeError('This OS is not supporting select.poll() or select.kqueue()')", "response": "Run loop for the current set of items in the current set of items."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef readline(self):\n        try:\n            return self._descriptor.read_queue.pop()\n        except IndexError:\n            # No lines in queue\n            if self.has_error():\n                raise RuntimeError(\"Errors reading PIPE\")\n        return None", "response": "Read a line from the queue."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset gdbs flag for process.", "response": "def use_gdbs(self, gdbs=True, port=2345):\n        \"\"\"\n        Set gdbs use for process.\n\n        :param gdbs: Boolean, default is True\n        :param port: Port number for gdbserver\n        \"\"\"\n        self.gdbs = gdbs\n        self.gdbs_port = port"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the valgrind tool to use.", "response": "def use_valgrind(self, tool, xml, console, track_origins, valgrind_extra_params):\n        \"\"\"\n        Use Valgrind.\n\n        :param tool: Tool name, must be memcheck, callgrind or massif\n        :param xml: Boolean output xml\n        :param console: Dump output to console, Boolean\n        :param track_origins: Boolean, set --track-origins=yes\n        :param valgrind_extra_params:  Extra parameters\n        :return: Nothing\n        :raises: AttributeError if invalid tool set.\n        \"\"\"\n        self.valgrind = tool\n        self.valgrind_xml = xml\n        self.valgrind_console = console\n        self.valgrind_track_origins = track_origins\n        self.valgrind_extra_params = valgrind_extra_params\n        if not tool in ['memcheck', 'callgrind', 'massif']:\n            raise AttributeError(\"Invalid valgrind tool: %s\" % tool)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __get_valgrind_params(self):\n        valgrind = []\n        if self.valgrind:\n            valgrind.extend(['valgrind'])\n            if self.valgrind == 'memcheck':\n                valgrind.extend(['--tool=memcheck', '--leak-check=full'])\n                if self.valgrind_track_origins:\n                    valgrind.extend(['--track-origins=yes'])\n                if self.valgrind_console:\n                    # just dump the default output, which is text dumped to console\n                    valgrind.extend([])\n                elif self.valgrind_xml:\n                    valgrind.extend([\n                        '--xml=yes',\n                        '--xml-file=' + LogManager.get_testcase_logfilename(\n                            self.name + '_valgrind_mem.xml', prepend_tc_name=True)\n                    ])\n                else:\n                    valgrind.extend([\n                        '--log-file=' + LogManager.get_testcase_logfilename(\n                            self.name + '_valgrind_mem.txt')\n                    ])\n\n            elif self.valgrind == 'callgrind':\n                valgrind.extend([\n                    '--tool=callgrind',\n                    '--dump-instr=yes',\n                    '--simulate-cache=yes',\n                    '--collect-jumps=yes'])\n                if self.valgrind_console:\n                    # just dump the default output, which is text dumped to console\n                    valgrind.extend([])\n                elif self.valgrind_xml:\n                    valgrind.extend([\n                        '--xml=yes',\n                        '--xml-file=' + LogManager.get_testcase_logfilename(\n                            self.name + '_valgrind_calls.xml', prepend_tc_name=True)\n                    ])\n                else:\n                    valgrind.extend([\n                        '--callgrind-out-file=' + LogManager.get_testcase_logfilename(\n                            self.name + '_valgrind_calls.data')\n                    ])\n            elif self.valgrind == 'massif':\n                valgrind.extend(['--tool=massif'])\n                valgrind.extend([\n                    '--massif-out-file=' + LogManager.get_testcase_logfilename(\n                        self.name + '_valgrind_massif.data')\n                    ])\n            # this allows one to specify misc params to valgrind,\n            # eg. \"--threshold=0.4\" to get some more data from massif\n            if self.valgrind_extra_params != '':\n                valgrind.extend(self.valgrind_extra_params.split())\n\n        return valgrind", "response": "Get Valgrind command as list."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start_process(self, cmd=None, path=\"\", processing_callback=None):\n        self.cmd = self.cmd if not cmd else cmd\n        self.path = self.path if not path else path\n        if self.path:\n            self.path = os.path.abspath(self.path)\n        self.cmd_arr = []\n\n        # set stdbuf in/out/err to zero size = no buffers in use\n        if self.nobuf:\n            self.cmd_arr.extend(['stdbuf', '-i0', '-o0', '-e0'])\n\n        # check if user want to debug this process\n        if self.gdb:\n            # add gdb parameters, run program immediately\n            self.cmd_arr.extend(['gdb', '-ex=run', '--args'])\n        elif self.gdbs:\n            # add gdbserver parameters, run program immediately\n            self.cmd_arr.extend(['gdbserver', 'localhost:' + str(self.gdbs_port)])\n        elif self.vgdb:\n            # add valgrind vgdb parameters, run program but wait for remote gdb connection\n            self.cmd_arr.extend(['valgrind', '--vgdb=yes', '--vgdb-error=0'])\n\n        if self.valgrind:\n            self.cmd_arr.extend(self.__get_valgrind_params())\n\n        self.cmd_arr.extend(self.cmd)\n        prefn = None\n        if not platform.system() == \"Windows\":\n            prefn = os.setsid\n\n        self.logger.debug(\"Instantiating process \"\n                          \"%s at %s with command %s\"\n                          % (self.name, self.path, \" \".join(self.cmd_arr)),\n                          extra={\"type\": \"   \"})\n        self.proc = subprocess.Popen(self.cmd_arr, cwd=self.path, stdout=subprocess.PIPE,\n                                     stdin=subprocess.PIPE, preexec_fn=prefn)\n\n        if UNIXPLATFORM:\n            import fcntl\n            file_descr = self.proc.stdout.fileno()\n            fcntl_var = fcntl.fcntl(file_descr, fcntl.F_GETFL)\n            fcntl.fcntl(file_descr, fcntl.F_SETFL, fcntl_var | os.O_NONBLOCK)\n\n        if self.proc.pid:\n            # Start stream reader thread\n            self.read_thread = NonBlockingStreamReader(self.proc.stdout, processing_callback)\n            self.read_thread.start()\n            self.logger.info(\"Process '%s' running with pid: %i\" % (' '.join(self.cmd_arr),\n                                                                    self.proc.pid),\n                             extra={'type': '<->'})\n        else:\n            self.logger.warning(\"Process start fails\", extra={'type': '<->'})\n            raise NameError('Connection Fails')", "response": "Start the process for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstop the process. :raises: EnvironmentError if stopping fails due to unknown environment TestStepError if process stops with non-default returncode and return code is not ignored.", "response": "def stop_process(self):\n        \"\"\"\n        Stop the process.\n\n        :raises: EnvironmentError if stopping fails due to unknown environment\n        TestStepError if process stops with non-default returncode and return code is not ignored.\n        \"\"\"\n        if self.read_thread is not None:\n            self.logger.debug(\"stop_process::readThread.stop()-in\")\n            self.read_thread.stop()\n            self.logger.debug(\"stop_process::readThread.stop()-out\")\n        returncode = None\n        if self.proc:\n            self.logger.debug(\"os.killpg(%d)\", self.proc.pid)\n\n            for sig in (signal.SIGINT, signal.SIGTERM, signal.SIGKILL):\n                timeout = 5\n                try:\n                    try:\n                        self.logger.debug(\"Trying signal %s\", sig)\n                        os.killpg(self.proc.pid, sig)\n                    except AttributeError:\n                        self.logger.debug(\"os.killpg::AttributeError\")\n                        # Failed most likely because in windows,\n                        # so use taskkill to kill whole process tree of proc\n                        if platform.system() == \"Windows\":\n                            subprocess.call(['taskkill', '/F', '/T', '/PID', str(self.proc.pid)])\n                        else:\n                            self.logger.debug(\"os.killpg::unknown env\")\n                            raise EnvironmentError(\"Unknown platform, \"\n                                                   \"don't know how to terminate process\")\n                    while self.proc.poll() is None and timeout > 0:\n                        time.sleep(1)\n                        timeout -= 1\n                    returncode = self.proc.poll()\n                    if returncode is not None:\n                        break\n                except OSError as error:\n                    self.logger.info(\"os.killpg::OSError: %s\", error)\n            self.proc = None\n\n        if returncode is not None:\n            self.logger.debug(\"Process stopped with returncode %s\" % returncode)\n            if returncode != self.default_retcode and not self.__ignore_return_code:\n                raise TestStepError(\"Process stopped with returncode %d\" % returncode)\n        self.logger.debug(\"stop_process-out\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef readline(self, timeout=1):  # pylint: disable=unused-argument\n        data = None\n        if self.read_thread:\n            # Ignore the timeout value, return imediately if no lines in queue\n            data = self.read_thread.readline()\n            if data and self.__print_io:\n                self.logger.info(data, extra={'type': '<--'})\n        return data", "response": "Read a line from the queue."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef writeline(self, data, crlf=\"\\r\\n\"):\n        if self.read_thread:\n            if self.read_thread.has_error():\n                raise RuntimeError(\"Error writing PIPE\")\n        # Check if process still alive\n        if self.proc.poll() is not None:\n            raise RuntimeError(\"Process stopped\")\n        if self.__print_io:\n            self.logger.info(data, extra={'type': '-->'})\n        self.proc.stdin.write(bytearray(data + crlf, 'ascii'))\n        self.proc.stdin.flush()", "response": "Writes data to the process stdin."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load(filename):\n        json_obj = Seed.load(filename)\n        return SeedInteger(json_obj[\"seed_value\"], json_obj[\"seed_id\"], json_obj[\"date\"])", "response": "Load seed from a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsafes version of sendBreak for 2. 7.", "response": "def _safe_sendBreak_v2_7(self):  # pylint: disable=invalid-name\n        \"\"\"! pyserial 2.7 API implementation of sendBreak/setBreak\n        @details\n        Below API is deprecated for pyserial 3.x versions!\n        http://pyserial.readthedocs.org/en/latest/pyserial_api.html#serial.Serial.sendBreak\n        http://pyserial.readthedocs.org/en/latest/pyserial_api.html#serial.Serial.setBreak\n        \"\"\"\n        result = True\n        try:\n            self.sendBreak()\n        except:  # pylint: disable=bare-except\n            # In Linux a termios.error is raised in sendBreak and in setBreak.\n            # The following setBreak() is needed to release the reset signal on the target mcu.\n            try:\n                self.setBreak(False)\n            except:  # pylint: disable=bare-except\n                result = False\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsafes version of sendBreak for Python 3. x.", "response": "def _safe_sendBreak_v3_0(self):  # pylint: disable=invalid-name\n        \"\"\"! pyserial 3.x API implementation of send_brea / break_condition\n        @details\n        http://pyserial.readthedocs.org/en/latest/pyserial_api.html#serial.Serial.send_break\n        http://pyserial.readthedocs.org/en/latest/pyserial_api.html#serial.Serial.break_condition\n        \"\"\"\n        result = True\n        try:\n            self.send_break()\n        except:  # pylint: disable=bare-except\n            # In Linux a termios.error is raised in sendBreak and in setBreak.\n            # The following break_condition = False is needed to\n            # release the reset signal on the target mcu.\n            self.break_condition = False\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef readline(self, timeout=1):\n        tries = 0\n        while 1:\n            try:\n                block = self.read(512)\n                if isinstance(block, bytes):\n                    block = block.decode()\n                elif isinstance(block, str):\n                    block = block.decode()\n                else:\n                    raise ValueError(\"Unknown data\")\n            except SerialTimeoutException:\n                # Exception that is raised on write timeouts.\n                block = ''\n            except SerialException:\n                # In case the device can not be found or can not be configured.\n                block = ''\n            except ValueError:\n                # Will be raised when parameter are out of range, e.g. baud rate, data bits.\n                # UnicodeError-Raised when a Unicode-related encoding or\n                # decoding error occurs. It is a subclass of ValueError.\n                block = ''\n            with self.buffer_lock:\n                # Let's lock, just in case\n                self.buf += block\n                pos = self.buf.find('\\n')\n                if pos >= 0:\n                    line, self.buf = self.buf[:pos+1], self.buf[pos+1:]\n                    return line\n            tries += 1\n            if tries * self.timeout > timeout:\n                break\n        return None", "response": "Read a line from the serial port."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads all lines that are available. abort after timeout when no more data arrives.", "response": "def readlines(self, timeout=1):\n        \"\"\"\n        read all lines that are available. abort after timeout\n        when no more data arrives.\n        \"\"\"\n        lines = []\n        while 1:\n            line = self.readline(timeout=timeout)\n            if line:\n                lines.append(line)\n            if not line or line[-1:] != '\\n':\n                break\n        return lines"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the value for a specific requirement.", "response": "def set(self, key, value):\n        \"\"\"\n        Sets the value for a specific requirement.\n\n        :param key: Name of requirement to be set\n        :param value: Value to set for requirement key\n        :return: Nothing, modifies requirement\n        \"\"\"\n        if key == \"tags\":\n            self._set_tag(tags=value)\n        else:\n            if isinstance(value, dict) and key in self._requirements and isinstance(\n                    self._requirements[key], dict):\n                self._requirements[key] = merge(self._requirements[key], value)\n            else:\n                self._requirements[key] = value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, key):\n        # Catch the case where the key is \".\"\n        if \".\" in key and len(key) > 1:\n            return self._recursive_get(key)\n        return self._requirements.get(key, None)", "response": "Gets contents of a requirement key."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _recursive_get(self, key, dic=None):\n        return recursive_search(key, dic) if dic else recursive_search(key, self._requirements)", "response": "Recursive function that searches for contents of a specific key inside nested requirement dicts."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the value of a specific tag or merges existing tags with a dict of new tags.", "response": "def _set_tag(self, tag=None, tags=None, value=True):\n        \"\"\"\n        Sets the value of a specific tag or merges existing tags with a dict of new tags.\n        Either tag or tags must be None.\n\n        :param tag: Tag which needs to be set.\n        :param tags: Set of tags which needs to be merged with existing tags.\n        :param value: Value to set for net tag named by :param tag.\n        :return: Nothing\n        \"\"\"\n        existing_tags = self._requirements.get(\"tags\")\n        if tags and not tag:\n            existing_tags = merge(existing_tags, tags)\n            self._requirements[\"tags\"] = existing_tags\n        elif tag and not tags:\n            existing_tags[tag] = value\n            self._requirements[\"tags\"] = existing_tags"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_empty_tags(self, tags=None):\n        new_tags = {}\n        old_tags = tags if tags else self.get(\"tags\")\n        for tag in old_tags.keys():\n            if old_tags[tag] is not None:\n                new_tags[tag] = old_tags[tag]\n        if not tags:\n            self._requirements[\"tags\"] = new_tags\n            return None\n        return new_tags", "response": "Removes empty tags from the tags dict."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef icetea_main():\n    from icetea_lib import IceteaManager\n    manager = IceteaManager.IceteaManager()\n    return_code = manager.run()\n    sys.exit(return_code)", "response": "Main function for running Icetea. Calls sys. exit with the return code to exit."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef random_list_elem(str_list):\n        if isinstance(str_list, list):\n            for elem in str_list:\n                if not isinstance(elem, str):\n                    raise TypeError(\"list element can only be string\")\n            return SeedString(random.choice(str_list))\n        return None", "response": "random_list_elem - randomizes a list of strings"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild documentation for Icetea.", "response": "def build_docs(location=\"doc-source\", target=None, library=\"icetea_lib\"):\n    \"\"\"\n    Build documentation for Icetea. Start by autogenerating module documentation\n    and finish by building html.\n\n    :param location: Documentation source\n    :param target: Documentation target path\n    :param library: Library location for autodoc.\n    :return: -1 if something fails. 0 if successfull.\n    \"\"\"\n    cmd_ar = [\"sphinx-apidoc\", \"-o\", location, library]\n    try:\n        print(\"Generating api docs.\")\n        retcode = check_call(cmd_ar)\n    except CalledProcessError as error:\n        print(\"Documentation build failed. Return code: {}\".format(error.returncode))\n        return 3\n    except OSError as error:\n        print(error)\n        print(\"Documentation build failed. Are you missing Sphinx? Please install sphinx using \"\n              \"'pip install sphinx'.\")\n        return 3\n\n    target = \"doc{}html\".format(os.sep) if target is None else target\n    cmd_ar = [\"sphinx-build\", \"-b\", \"html\", location, target]\n    try:\n        print(\"Building html documentation.\")\n        retcode = check_call(cmd_ar)\n    except CalledProcessError as error:\n        print(\"Documentation build failed. Return code: {}\".format(error.returncode))\n        return 3\n    except OSError as error:\n        print(error)\n        print(\"Documentation build failed. Are you missing Sphinx? Please install sphinx using \"\n              \"'pip install sphinx'.\")\n        return 3\n    print(\"Documentation built.\")\n    return 0"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef command(self, cmd, expected_retcode=0):  # pylint: disable=invalid-name\n        # expected_retcode kwd argument is used in many test cases, we cannot rename it.\n        \"\"\"\n        Shortcut for sending a command to this node specifically.\n        :param cmd: Command to send\n        :param expected_retcode: Expected return code as int, default is 0\n        :return: CliResponse\n        \"\"\"\n        return self.bench.execute_command(self.endpoint_id, cmd, expected_retcode=expected_retcode)", "response": "Shortcut for sending a command to this node specifically."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_base_arguments(parser):\n    thisfilepath = os.path.abspath(os.path.dirname(__file__))\n    group = parser.add_mutually_exclusive_group(required=False)\n    group.add_argument('--list',\n                       action='store_true',\n                       help='List of available testcases(nothing else)',\n                       default=False)\n    group.add_argument('--listsuites',\n                       action='store_true',\n                       help='List of available suites',\n                       default=False)\n    group.add_argument('--tc',\n                       help='execute testcase. Give test index, name, list of indices/'\n                            'names, or all to execute all testcases',\n                       default=False)\n    group.add_argument('--suite',\n                       default=False,\n                       help='Run tests from suite json file <suite>. Can be absolute path to '\n                            'suite file or path relative to --suitedir.')\n    group.add_argument('--version',\n                       action='store_true',\n                       default=False,\n                       help='Show version')\n\n    # Filters\n    filter_group = parser.add_argument_group(\"Filter arguments\", \"Arguments used for filtering \"\n                                                                 \"tc:s\")\n    filter_group.add_argument('--status', default=False,\n                              help='Run all testcases with status <status>')\n    filter_group.add_argument('--group',\n                              default=False,\n                              help='Run all testcases that have all items '\n                                   'in <group/subgroup> or <group,group2> in their group path.')\n    filter_group.add_argument('--testtype',\n                              default=False,\n                              help='Run all testcases with type <testtype>')\n    filter_group.add_argument('--subtype',\n                              default=False,\n                              help=\"Run all testcases with subtype <subtype\")\n    filter_group.add_argument('--component',\n                              default=False,\n                              help='Run all testcases with component <component>')\n    filter_group.add_argument('--feature',\n                              default=False,\n                              help='Run all testcases with feature <feature>')\n    filter_group.add_argument(\"--platform_filter\",\n                              default=False,\n                              help=\"Run all testcases that allow platform <platform_filter>\")\n\n    # JobId is BUILD_TAG (from Jenkins job), or generated UUID or command line argument value\n    info_group = parser.add_argument_group(\"Run information\", \"Information of run, such as job \"\n                                                              \"id and git or build information.\")\n    info_group.add_argument('--jobId',\n                            default=os.environ.get('BUILD_TAG', str(uuid.uuid1())),\n                            help='Job Unique ID')\n    info_group.add_argument('--gitUrl',\n                            default=os.environ.get('ghprbAuthorRepoGitUrl', None),\n                            help='Set application used git url for results')\n    info_group.add_argument('--branch',\n                            default=os.environ.get('GIT_BRANCH', 'master'),\n                            help='Set used build branch for results')\n    info_group.add_argument('--commitId',\n                            default=os.environ.get('ghprbActualCommit', None),\n                            help='Set used commit ID for results')\n    info_group.add_argument('--buildDate',\n                            default=None,\n                            help='Set build date')\n    info_group.add_argument('--toolchain',\n                            default=None,\n                            help='Set toolchain for results')\n    info_group.add_argument('--buildUrl',\n                            default=os.environ.get('BUILD_URL', None),\n                            help='Set build url for results')\n    info_group.add_argument('--campaign',\n                            default=os.environ.get('JOB_NAME', None),\n                            help='Set campaign name for results')\n\n    # Directories and paths\n    directories = parser.add_argument_group(\"Paths\", \"Directory and file paths for various \"\n                                                     \"Icetea features.\")\n    directories.add_argument('--tcdir',\n                             help='Search for testcases in directory <path>',\n                             default='./testcases')\n    directories.add_argument('--suitedir',\n                             help='Search for suites in directory <path>',\n                             default='./testcases/suites')\n    directories.add_argument(\"--cfg_file\",\n                             type=open,\n                             default=None,\n                             help=\"Load cli parameters from file. \"\n                                  \"This will overwrite parameters given before --cfg_file, but \"\n                                  \"results of this will be overwritten by \"\n                                  \"parameters given after this one\",\n                             action=LoadFromFile)\n\n    directories.add_argument('--plugin_path',\n                             default=os.path.abspath(\n                                 os.path.join(thisfilepath,\n                                              \"Plugin/plugins/plugins_to_load\")),\n                             help=\"location of file called plugins_to_load, \"\n                                  \"where custom plugins are imported from.\")\n\n    # Allocator group\n    alloc_group = parser.add_argument_group(\"Allocator\", \"Control allocation of resources for \"\n                                                         \"tests.\")\n    alloc_group.add_argument(\"--allocator\",\n                             default=\"LocalAllocator\",\n                             help=\"Allocator to be used for allocating resources. \"\n                                  \"Default is LocalAllocator\")\n    alloc_group.add_argument(\"--allocator_cfg\",\n                             help=\"File that contains configuration for used allocator.\",\n                             default=None)\n\n    # Other arguments\n    parser.add_argument('--env_cfg',\n                        help='Use user specific environment configuration file',\n                        default='')\n    parser.add_argument(\"--logging_cfg\",\n                        help=\"Location of JSON configuration for logging.\",\n                        default=None)\n    parser.add_argument('--repeat',\n                        help='Repeat testcases N times',\n                        default=1)\n    parser.add_argument('--stop_on_failure',\n                        help='Stop testruns/repeation on first failed TC',\n                        default=False,\n                        action=\"store_true\")\n    parser.add_argument('--clean',\n                        action='store_true',\n                        default=False,\n                        help='Clean old logs')\n    parser.add_argument('--connector',\n                        default=None,\n                        help='Connector credentials for selecting and/or generating endpoint '\n                             'certificates. Format should be domain[:token] where token is '\n                             'optional. Eg. --connector this_is_some_domain:this_is_my_token')\n    parser.add_argument('--failure_return_value',\n                        default=False,\n                        action=\"store_true\",\n                        help='Sets Icetea to return a failing code to caller if '\n                             'one or more tests fail during the run. Default is False')\n    parser.add_argument('--color',\n                        default=False,\n                        action=\"store_true\",\n                        help='Indicates if console logs are printed plain'\n                             ' or with colours. Default is False for plain'\n                             'logs.')\n    parser.add_argument(\"--check_version\",\n                        default=False,\n                        action=\"store_true\",\n                        help=\"Enables version checks for test cases.\")\n    parser.add_argument('--ignore_invalid_params',\n                        default=False,\n                        action=\"store_true\",\n                        help=\"Disables checks for invalid parameters.\")\n    parser.add_argument('--parallel_flash',\n                        default=False,\n                        action=\"store_true\",\n                        help=\"Enables parallel flash.\")\n    parser.add_argument('--disable_log_truncate',\n                        default=False,\n                        action=\"store_true\",\n                        help=\"Disable long log line truncating. Over 10000\"\n                             \"characters long lines are truncated by default.\")\n    parser.add_argument('--cm',\n                        default=\"opentmi_client\",\n                        help='name of module that is to be used to send results to a cloud '\n                             'service.')\n    parser.add_argument(\"--json\", action=\"store_true\", default=False,\n                        help=\"Output results of --list as json instead of a table.\")\n    parser.add_argument(\"--export\", default=None, metavar=\"SUITE_FILE_NAME\",\n                        help=\"Export list into suite template file.\")\n    parser.add_argument(\"--sync_start\", default=False, action=\"store_true\",\n                        help=\"Use echo-command to try and make sure duts have \"\n                             \"started before proceeding with test.\")\n    return parser", "response": "Adds base arguments to the argument parser."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd test case arguments to the given parser.", "response": "def get_tc_arguments(parser):\n    \"\"\"\n    Append test case arguments to parser.\n\n    :param parser: ArgumentParser\n    :return: ArgumentParser\n    \"\"\"\n    group2 = parser.add_argument_group('Test case arguments')\n    group2.add_argument('--log',\n                        default=os.path.abspath(\"./log\"),\n                        help='Store logs to specific path. Filename will be '\n                             '<path>/<testcase>_D<dutNumber>.log')\n    group2.add_argument('-s', '--silent',\n                        action='store_true',\n                        dest='silent',\n                        default=False,\n                        help='Silent mode, only prints results')\n    group2.add_argument('-v', \"--verbose\",\n                        dest='verbose',\n                        default=0,\n                        help=\"increase output verbosity, max 2 times.\",\n                        action=\"count\")\n    group2.add_argument('-w',\n                        action='store_true',\n                        dest='cloud',\n                        default=False,\n                        help='Store results to a cloud service.')\n\n    group2.add_argument('--with_logs',\n                        action='store_true',\n                        dest='with_logs',\n                        default=False,\n                        help=\"Store bench.log to cloud db after run.\")\n    group2.add_argument('--reset',\n                        dest='reset',\n                        action='store',\n                        nargs='?',\n                        const=True,\n                        help='reset device before executing test cases')\n    group2.add_argument('--iface',\n                        help=\"Used NW sniffer interface name\")\n    group2.add_argument('--bin',\n                        help=\"Used specific binary for DUTs, when process is in use. \"\n                             \"NOTE: Does not affect duts which specify their own binaries.\")\n    group2.add_argument('--tc_cfg',\n                        help='Testcase Configuration file')\n    group2.add_argument('--type',\n                        help='Overrides DUT type.',\n                        choices=['hardware', 'process', \"serial\", \"mbed\"])\n    group2.add_argument('--platform_name',\n                        help='Overrides used platform. Must be found in allowed_platforms in '\n                             'dut configuration if allowed_platforms is defined and non-empty.',\n                        default=None)\n    group2.add_argument('--putty',\n                        dest='putty',\n                        action='store_true',\n                        default=False,\n                        help='Open putty after TC executed')\n    group2.add_argument('--skip_setup',\n                        action='store_true',\n                        default=False,\n                        help='Skip TC setUp phase')\n    group2.add_argument('--skip_case',\n                        action='store_true',\n                        default=False,\n                        help='Skip TC body phase')\n    group2.add_argument('--skip_teardown',\n                        action='store_true',\n                        default=False,\n                        help='Skip TC tearDown phase')\n    group2.add_argument('--valgrind',\n                        action='store_true',\n                        default=False,\n                        help='Analyse nodes with valgrind (linux only)')\n    group2.add_argument('--valgrind_tool',\n                        help='Valgrind tool to use.',\n                        choices=['memcheck', 'callgrind', 'massif'])\n    group2.add_argument('--valgrind_extra_params',\n                        default='',\n                        help='Additional command line parameters to valgrind.')\n\n    # only one of the --valgrind_text or --valgrind_console is allowed\n    valgrind_group = parser.add_mutually_exclusive_group()\n    valgrind_group.add_argument('--valgrind_text',\n                                action='store_true',\n                                default=False,\n                                help='Output as Text. Default: xml format')\n    valgrind_group.add_argument('--valgrind_console',\n                                dest='valgrind_console',\n                                action='store_true',\n                                default=False,\n                                help='Output as Text to console. Default: xml format')\n\n    group2.add_argument('--valgrind_track_origins',\n                        action='store_true',\n                        default=False,\n                        help='Show origins of undefined values. Default: false; '\n                             'Used only if the Valgrind tool is memcheck')\n\n    group2.add_argument('--use_sniffer',\n                        dest='use_sniffer',\n                        action='store_true',\n                        default=False,\n                        help='Use Sniffer')\n    group2.add_argument('--my_duts',\n                        dest=\"my_duts\",\n                        help='Use only some of duts. e.g. --my_duts 1,3')\n    group2.add_argument('--pause_ext',\n                        action='store_true',\n                        dest=\"pause_when_external_dut\",\n                        default=False,\n                        help='Pause when external device command happens')\n\n    # only one of the --gdb, --gdbs or --vgdb is allowed\n    gdb_group = parser.add_mutually_exclusive_group()\n    gdb_group.add_argument('--gdb',\n                           type=int,\n                           help='Run specific process node with gdb (debugger). e.g. --gdb 1')\n    gdb_group.add_argument('--gdbs',\n                           type=int,\n                           help='Run specific process node with gdbserver '\n                                '(debugger). e.g. --gdbs 1')\n    gdb_group.add_argument('--vgdb',\n                           type=int,\n                           help='Run specific process node with vgdb '\n                                '(debugger under valgrind). e.g. --vgdb 1')\n\n    group2.add_argument('--gdbs-port',\n                        dest='gdbs_port',\n                        type=int,\n                        default=2345,\n                        help='select gdbs port')\n    group2.add_argument('--pre-cmds',\n                        dest='pre_cmds',\n                        help='Send extra commands right after DUT connection')\n    group2.add_argument('--post-cmds',\n                        dest='post_cmds',\n                        help='Send extra commands right before terminating dut connection.')\n    group2.add_argument('--baudrate',\n                        dest='baudrate',\n                        type=int,\n                        help='Use user defined serial baudrate (when serial device is in use)')\n    group2.add_argument('--serial_timeout',\n                        type=float,\n                        default=0.01,\n                        help='User defined serial timeout (default 0.01)')\n    group2.add_argument('--serial_xonxoff',\n                        action='store_true',\n                        default=False,\n                        help='Use software flow control')\n    group2.add_argument('--serial_rtscts',\n                        action='store_true',\n                        default=False,\n                        help='Use Hardware flow control')\n    group2.add_argument('--serial_ch_size',\n                        type=int,\n                        default=-1,\n                        help='use chunck mode with size N when writing to serial port. '\n                             '(default N=-1: '\n                             'use pre-defined mode, N=0: normal, N<0: chunk-mode with size N')\n    group2.add_argument('--serial_ch_delay',\n                        dest='ch_mode_ch_delay',\n                        type=float,\n                        help='User defined delay between characters. '\n                             'Used only when serial_ch_size>0. (default 0.01)')\n    group2.add_argument('--nobuf', help=\"Do not use stdio buffers in node process.\")\n    group2.add_argument('--kill_putty',\n                        action='store_true',\n                        help='Kill old putty/kitty processes')\n\n    # only one of the --forceflash, --forceflash_once is allowed\n    forceflash_group = parser.add_mutually_exclusive_group()\n    forceflash_group.add_argument('--forceflash',\n                                  action='store_true',\n                                  default=False,\n                                  help='Force flashing of hardware device if binary is given. '\n                                       'Defaults to False')\n    forceflash_group.add_argument('--forceflash_once',\n                                  action='store_true',\n                                  default=False,\n                                  help='Force flashing of hardware device if '\n                                       'binary is given, but only once. Defaults to False')\n    forceflash_group.add_argument(\"--skip_flash\",\n                                  default=False,\n                                  action=\"store_true\",\n                                  help=\"Skip flashing hardware devices during this run.\")\n    group2.add_argument('--interface',\n                        dest='interface',\n                        default='eth0',\n                        help='Network interface used in tests, unless the testcase specifies '\n                             'which one to use. Defaults to eth0')\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef str_arg_to_bool(value):\n    if value.lower() in [\"y\", \"yes\", \"true\", \"1\", \"t\"]:\n        return True\n    elif value.lower() in [\"n\", \"no\", \"false\", \"0\", \"f\"]:\n        return False\n    else:\n        raise argparse.ArgumentTypeError(\"Boolean value expected.\")", "response": "Convert a string argument into a boolean value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef forget(self):\n        self._observed_events = {}\n        if self in self._observers:\n            self._observers.remove(self)", "response": "Reset _observed events. Remove self from observers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding the next instance of find_str from lines starting from start_index.", "response": "def find_next(lines, find_str, start_index):\n    \"\"\"\n    Find the next instance of find_str from lines starting from start_index.\n\n    :param lines: Lines to look through\n    :param find_str: String or Invert to look for\n    :param start_index: Index to start from\n    :return: (boolean, index, line)\n    \"\"\"\n    mode = None\n    if isinstance(find_str, basestring):\n        mode = 'normal'\n        message = find_str\n    elif isinstance(find_str, Invert):\n        mode = 'invert'\n        message = str(find_str)\n    else:\n        raise TypeError(\"Unsupported message type\")\n    for i in range(start_index, len(lines)):\n        if re.search(message, lines[i]):\n            return mode == 'normal', i, lines[i]\n        elif message in lines[i]:\n            return mode == 'normal', i, lines[i]\n    if mode == 'invert':\n        return True, len(lines), None\n    raise LookupError(\"Not found\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef verify_message(lines, expected_response):\n    position = 0\n    if isinstance(expected_response, basestring):\n        expected_response = [expected_response]\n    if isinstance(expected_response, set):\n        expected_response = list(expected_response)\n    if not isinstance(expected_response, list):\n        raise TypeError(\"verify_message: expectedResponse must be list, set or string\")\n    for message in expected_response:\n        try:\n            found, position, _ = find_next(lines, message, position)\n            if not found:\n                return False\n            position = position + 1\n        except TypeError:\n            return False\n        except LookupError:\n            return False\n    return True", "response": "Verify that a message is in the expectedResponse."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _cleanlogs(silent=False, log_location=\"log\"):\n    try:\n        print(\"cleaning up Icetea log directory.\")\n        shutil.rmtree(log_location, ignore_errors=silent,\n                      onerror=None if silent else _clean_onerror)\n    except OSError as error:\n        print(error)", "response": "Cleans up Mbed - test default log directory."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_suites(suitedir=\"./testcases/suites\", cloud=False):\n        suites = []\n        suites.extend(TestSuite.get_suite_files(suitedir))\n\n        # no suitedir, or no suites -> append cloud.get_campaigns()\n\n        if cloud:\n            names = cloud.get_campaign_names()\n            if names:\n                suites.append(\"------------------------------------\")\n                suites.append(\"FROM CLOUD:\")\n                suites.extend(names)\n        if not suites:\n            return None\n\n        from prettytable import PrettyTable\n        table = PrettyTable([\"Testcase suites\"])\n        for suite in suites:\n            table.add_row([suite])\n        return table", "response": "Static method for listing test cases from both local source and cloud."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_arguments():\n        parser = get_base_arguments(get_parser())\n        parser = get_tc_arguments(parser)\n        args, unknown = parser.parse_known_args()\n        return args, unknown", "response": "Static method for paring arguments\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_args(self):\n        parser = get_base_arguments(get_parser())\n        parser = get_tc_arguments(parser)\n        # Disable \"Do not use len(SEQ) as condition value\"\n        # pylint: disable=C1801\n        if len(sys.argv) < 2:\n            self.logger.error(\"Icetea called with no arguments! \")\n            parser.print_help()\n            return False\n        elif not self.args.ignore_invalid_params and self.unknown:\n            self.logger.error(\"Unknown parameters received, exiting. \"\n                              \"To ignore this add --ignore_invalid_params flag.\")\n            self.logger.error(\"Following parameters were unknown: {}\".format(self.unknown))\n            parser.print_help()\n            return False\n        return True", "response": "Checks that a valid number of arguments were received and that all arguments were recognised."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing PluginManager and load run wide plugins.", "response": "def _init_pluginmanager(self):\n        \"\"\"\n        Initialize PluginManager and load run wide plugins.\n        \"\"\"\n        self.pluginmanager = PluginManager(logger=self.logger)\n        self.logger.debug(\"Registering execution wide plugins:\")\n        self.pluginmanager.load_default_run_plugins()\n        self.pluginmanager.load_custom_run_plugins(self.args.plugin_path)\n        self.logger.debug(\"Execution wide plugins loaded and registered.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run(self, args=None):\n        # Disable \"Too many branches\" and \"Too many return statemets\" warnings\n        # pylint: disable=R0912,R0911\n        retcodesummary = ExitCodes.EXIT_SUCCESS\n        self.args = args if args else self.args\n\n        if not self.check_args():\n            return retcodesummary\n\n        if self.args.clean:\n            if not self.args.tc and not self.args.suite:\n                return retcodesummary\n\n        # If called with --version print version and exit\n        version = get_fw_version()\n        if self.args.version and version:\n            print(version)\n            return retcodesummary\n        elif self.args.version and not version:\n            print(\"Unable to get version. Have you installed Icetea correctly?\")\n            return retcodesummary\n\n        self.logger.info(\"Using Icetea version {}\".format(version) if version\n                         else \"Unable to get Icetea version. Is Icetea installed?\")\n\n        # If cloud set, import cloud, get parameters from environment, initialize cloud\n        cloud = self._init_cloud(self.args.cloud)\n\n        # Check if called with listsuites. If so, print out suites either from cloud or from local\n        if self.args.listsuites:\n            table = self.list_suites(self.args.suitedir, cloud)\n            if table is None:\n                self.logger.error(\"No suites found!\")\n                retcodesummary = ExitCodes.EXIT_FAIL\n            else:\n                print(table)\n            return retcodesummary\n\n        try:\n            testsuite = TestSuite(logger=self.logger, cloud_module=cloud, args=self.args)\n        except SuiteException as error:\n            self.logger.error(\"Something went wrong in suite creation! {}\".format(error))\n            retcodesummary = ExitCodes.EXIT_INCONC\n            return retcodesummary\n\n        if self.args.list:\n            if self.args.cloud:\n                testsuite.update_testcases()\n            testcases = testsuite.list_testcases()\n            print(testcases)\n            return retcodesummary\n\n        results = self.runtestsuite(testsuite=testsuite)\n\n        if not results:\n            retcodesummary = ExitCodes.EXIT_SUCCESS\n        elif results.failure_count() and self.args.failure_return_value is True:\n            retcodesummary = ExitCodes.EXIT_FAIL\n        elif results.inconclusive_count() and self.args.failure_return_value is True:\n            retcodesummary = ExitCodes.EXIT_INCONC\n\n        return retcodesummary", "response": "Runs the set of tests within the given path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling cleanup for ResourceProvider of this run.", "response": "def _cleanup_resourceprovider(self):\n        \"\"\"\n        Calls cleanup for ResourceProvider of this run.\n\n        :return: Nothing\n        \"\"\"\n        # Disable too broad exception warning\n        # pylint: disable=W0703\n        self.resourceprovider = ResourceProvider(self.args)\n        try:\n            self.resourceprovider.cleanup()\n            self.logger.info(\"Cleanup done.\")\n        except Exception as error:\n            self.logger.error(\"Cleanup failed! %s\", error)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the cloud module object if cloud_arg is set.", "response": "def _init_cloud(self, cloud_arg):\n        \"\"\"\n        Initializes Cloud module if cloud_arg is set.\n\n        :param cloud_arg: taken from args.cloud\n        :return: cloud module object instance\n        \"\"\"\n        # Disable too broad exception warning\n        # pylint: disable=W0703\n        cloud = None\n        if cloud_arg:\n            try:\n                if hasattr(self.args, \"cm\"):\n                    cloud_module = self.args.cm if self.args.cm else None\n                    self.logger.info(\"Creating cloud module {}.\".format(cloud_module))\n                else:\n                    cloud_module = None\n\n                cloud = Cloud(host=None, module=cloud_module, logger=self.logger, args=self.args)\n            except Exception as error:\n                self.logger.warning(\"Cloud module could not be initialized: {}\".format(error))\n                cloud = None\n        return cloud"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef open_connection(self):\n        self.logger.debug(\"Open COM %s\", self.comport)\n        self.port = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        (ip_addr, port) = self.comport.split(':')\n        self.port.connect(ip_addr, num(port))", "response": "Open connection over TCP socket."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef close_connection(self):\n        if self.port:\n            self.port.close()\n            self.logger.debug(\"Close TCP port\")", "response": "Close TCP port\n        :return: Nothing"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading a line from the port and strip escape characters", "response": "def readline(self, timeout=None):  # timeout is not in use\n        \"\"\"\n        Read data from port and strip escape characters\n        :param timeout:\n        :return: Stripped line.\n        \"\"\"\n        fil = self.port.makefile()\n        line = fil.readline()\n        return strip_escape(line.strip())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate(self, *args, **kwargs):\n        title = kwargs.get(\"title\")\n        heads = kwargs.get(\"heads\")\n        refresh = kwargs.get(\"refresh\")\n        filename = args[0]\n        report = self._create(title, heads, refresh, path_start=os.path.dirname(filename))\n        ReportHtml.save(report, filename)", "response": "Implementation for the generate method defined in ReportBase. generate generates a html report and saves it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _create(self, title, heads, refresh=None, path_start=None):\n        # TODO: Refactor to make less complex\n        doc, tag, text = Doc().tagtext()\n        doc.asis('<!DOCTYPE html>')\n        heads[\"Date\"] = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        heads[\"Pass rate\"] = self.results.pass_rate()\n        heads[\"Pass rate excluding retries\"] = self.results.pass_rate(include_retries=False)\n\n        with tag('html'):\n            with tag('head'):\n                doc.asis(self.head)\n                if refresh:\n                    doc.asis('<META HTTP-EQUIV=\"refresh\" CONTENT=\"' + str(refresh) + '\">')\n            with tag('body', id='body'):\n                with tag('h1'):\n                    text(title)\n                with tag('table'):\n                    for head in heads:\n                        with tag('tr'):\n                            with tag('th', width=\"100px\"):\n                                text(head)\n                            with tag('td'):\n                                text(heads[head])\n                    with tag('tr'):\n                        with tag('th'):\n                            text('Executed')\n                        with tag('td'):\n                            text(str(self.summary[\"count\"]))\n                    with tag('tr'):\n                        with tag('th'):\n                            text('Pass:')\n                        with tag('td'):\n                            text(str(self.summary[\"pass\"]))\n                    with tag('tr'):\n                        with tag('th'):\n                            text('Fails:')\n                        with tag('td'):\n                            text(str(self.summary[\"fail\"]))\n                    with tag('tr'):\n                        with tag('th'):\n                            text('inconclusive:')\n                        with tag('td'):\n                            text(str(self.summary[\"inconclusive\"]))\n                    with tag('tr'):\n                        with tag('th'):\n                            text('Skip:')\n                        with tag('td'):\n                            text(str(self.summary[\"skip\"]))\n                    with tag('tr'):\n                        with tag('th'):\n                            text('Duration:')\n                        with tag('td'):\n                            text(self.duration_to_string(self.summary[\"duration\"]))\n                    with tag('tr'):\n                        with tag('th'):\n                            text('{} version:'.format(get_fw_name()))\n                        with tag('td'):\n                            text(get_fw_version())\n\n                with tag('table', style='border-collapse: collapse;'):\n                    with tag('tr'):\n                        with tag('th'):\n                            text(\"Test Case\")\n                        with tag('th'):\n                            text(\"Verdict\")\n                        with tag('th'):\n                            text(\"Fail Reason\")\n                        with tag('th'):\n                            text(\"Skip Reason\")\n                        with tag('th'):\n                            text(\"Retried\")\n                        with tag('th'):\n                            text(\"Duration\")\n                    for result in self.results:\n                        if result.success:\n                            klass = 'item_pass'\n                        elif result.inconclusive:\n                            klass = 'item_inconc'\n                        else:\n                            klass = 'item_fail'\n                        with tag('tr', klass='item %s' % klass, onclick='showhide(this)'):\n                            with tag('td', width=\"200px\"):\n                                text(result.get_tc_name())\n                            with tag('td', width=\"100px\"):\n                                if result.success:\n                                    color = 'green'\n                                elif result.failure:\n                                    color = 'red'\n                                else:\n                                    color = 'black'\n                                with tag('font', color=color):\n                                    text(result.get_verdict())\n                            with tag('td', width=\"350px\"):\n                                text(hex_escape_str(result.fail_reason))\n                            with tag('td', width=\"300px\"):\n                                text(result.skip_reason if result.skipped() else \"\")\n                            with tag('td', width=\"50px\"):\n                                text(\"Yes\" if result.retries_left != 0 else \"No\")\n                            with tag('td', width=\"100px\"):\n                                text(str(result.duration))\n                        with tag('tr', klass='info hidden'):\n                            with tag('td', colspan=\"5\"):\n                                if hasattr(result, 'tc_git_info') and \\\n                                        result.tc_git_info and \\\n                                        \"scm_link\" in result.tc_git_info:\n                                    # add tc git info only when available\n                                    link = result.tc_git_info['scm_link']\n                                    with tag('a', href=link):\n                                        text(link)\n                                    doc.stag('br')\n                                for fil in result.logfiles:\n                                    filepath = os.path.relpath(fil, path_start)\n                                    with tag('a', href=filepath):\n                                        text(filepath)\n                                    doc.stag('br')\n\n        return doc.getvalue()", "response": "Internal method to generate a yattag document with result data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_fw_version():\n    version = 'unknown'\n    try:\n        pkg = require(get_fw_name())[0]\n    except DistributionNotFound:\n        # Icetea is not installed. try to read version string from setup.py\n        try:\n            setup_path = os.path.abspath(os.path.dirname(__file__)+'/../..')\n            with open(os.path.join(setup_path, 'setup.py')) as setup_file:\n                lines = setup_file.readlines()\n                for line in lines:\n                    match = re.search(r\"VERSION = \\\"([\\S]{5,})\\\"\", line)\n                    if match:\n                        version = match.group(1)\n                        break\n        except Exception:  # pylint: disable=broad-except\n            pass\n    else:\n        version = \"-rc\".join(pkg.version.split(\"rc\"))\n    return version", "response": "Try to get version of the framework."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget sha1 of file", "response": "def sha1_of_file(filepath):\n    \"\"\"\n    Get sha1 of file\n    :param filepath: File to hash\n    :return: sha1 hash of file or None\n    \"\"\"\n    import hashlib\n    try:\n        with open(filepath, 'rb') as file_to_hash:\n            return hashlib.sha1(file_to_hash.read()).hexdigest()\n    except:  # pylint: disable=bare-except\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if the given integer is a valid number.", "response": "def check_int(integer):\n    \"\"\"\n    Check if number is integer or not.\n\n    :param integer: Number as str\n    :return: Boolean\n    \"\"\"\n    if not isinstance(integer, str):\n        return False\n    if integer[0] in ('-', '+'):\n        return integer[1:].isdigit()\n    return integer.isdigit()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _is_pid_running_on_unix(pid):\n    try:\n        os.kill(pid, 0)\n    except OSError as err:\n        # if error is ESRCH, it means the process doesn't exist\n        return not err.errno == os.errno.ESRCH\n    return True", "response": "Check if a process is running on Unix systems."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _is_pid_running_on_windows(pid):\n    import ctypes.wintypes\n\n    kernel32 = ctypes.windll.kernel32\n    handle = kernel32.OpenProcess(1, 0, pid)\n    if handle == 0:\n        return False\n    exit_code = ctypes.wintypes.DWORD()\n    ret = kernel32.GetExitCodeProcess(handle, ctypes.byref(exit_code))\n    is_alive = (ret == 0 or exit_code.value == _STILL_ALIVE)  # pylint: disable=undefined-variable\n    kernel32.CloseHandle(handle)\n    return is_alive", "response": "Check if a process is running on Windows systems."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef strip_escape(string='', encoding=\"utf-8\"):  # pylint: disable=redefined-outer-name\n    matches = []\n    try:\n        if hasattr(string, \"decode\"):\n            string = string.decode(encoding)\n    except Exception: # pylint: disable=broad-except\n        # Tried to decode something that is not decodeable in the specified encoding. Let's just\n        # move on.\n        pass\n    try:\n        for match in ansi_eng.finditer(string):\n            matches.append(match)\n    except TypeError as error:\n        raise TypeError(\"Unable to strip escape characters from data {}: {}\".format(\n            string, error))\n    matches.reverse()\n    for match in matches:\n        start = match.start()\n        end = match.end()\n        string = string[0:start] + string[end:]\n    return string", "response": "Strips escape characters from a string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_class(full_class_string, verbose=False, silent=False):\n    if not isinstance(full_class_string, str):\n        if not silent:\n            print(\"Error, loadClass: input not a string: %s\" % str(full_class_string))\n        return None\n    if len(full_class_string) == 0:  # pylint: disable=len-as-condition\n        if not silent:\n            print(\"Error, loadClass: empty string\")\n        return None\n    class_data = full_class_string.split(\".\")\n    module_path = \".\".join(class_data[:-1])\n    class_str = class_data[-1]\n    try:\n        module_ = importlib.import_module(module_path)\n        # Finally, we retrieve the Class\n        return getattr(module_, class_str)\n    except AttributeError:\n        return None\n    except Exception:\n        raise", "response": "Dynamically load a class from a string"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_abs_path(relative_path):\n    abs_path = os.path.sep.join(\n        os.path.abspath(sys.modules[__name__].__file__).split(os.path.sep)[:-1])\n    abs_path = os.path.abspath(abs_path + os.path.sep + relative_path)\n    return abs_path", "response": "Get absolute path for relative path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_pkg_version(pkg_name, parse=False):\n    import pkg_resources  # part of setuptools\n    try:\n        version = pkg_resources.require(pkg_name)[0].version\n        return pkg_resources.parse_version(version) if parse else version\n    except pkg_resources.DistributionNotFound:\n        return None", "response": "Verify and get installed python package version."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_number(string_nums):\n    match = re.match(r\".*([\\d]{1,})\", string_nums)\n    if match:\n        return int(match.group(1))\n    return None", "response": "Returns the number of the given string or None if the string is not found"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate reference and backreference graphs for objects of type class given in classlist.", "response": "def generate_object_graphs_by_class(classlist):\n    \"\"\"\n    Generate reference and backreference graphs\n    for objects of type class for each class given in classlist.\n    Useful for debugging reference leaks in framework etc.\n\n    Usage example to generate graphs for class \"someclass\":\n    >>> import someclass\n    >>> someclassobject = someclass()\n    >>> generate_object_graphs_by_class(someclass)\n\n    Needs \"objgraph\" module installed.\n    \"\"\"\n    try:\n        import objgraph\n        import gc\n    except ImportError:\n        return\n    graphcount = 0\n    if not isinstance(classlist, list):\n        classlist = [classlist]\n    for class_item in classlist:\n        for obj in gc.get_objects():\n            if isinstance(obj, class_item):\n                graphcount += 1\n                objgraph.show_refs([obj], filename='%d_%s_%d_refs.png' % (\n                    ogcounter, obj.__class__.__name__, graphcount))\n                objgraph.show_backrefs([obj], filename='%d_%s_%d_backrefs.png' % (\n                    ogcounter, obj.__class__.__name__, graphcount))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the combination of two urls and checks that there are no double slashes at the seam.", "response": "def combine_urls(path1, path2):\n    \"\"\"\n    Returns the combination of two urls and checks that there are no double slashes at the seam.\n    TODO: Extend to check for other anomalies as well.\n\n    :param path1: First part of the url\n    :param path2: Second part of the url\n    :return: Combination of the paths with double slashes removed\n    \"\"\"\n    if path1.endswith(\"/\") and path2.startswith(\"/\"):\n        path2 = path2.replace(\"/\", \"\", 1)\n    elif path1.endswith(\"/\") is False and path2.startswith(\"/\") is False:\n        path2 = \"/\" + path2\n    return path1 + path2"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget contents of requirement key recursively so users can search for specific keys inside nested requirement dicts. :param keys: key or dot separated string of keys to look for. :param dictionary: Dictionary to search from :return: results of search or None", "response": "def recursive_dictionary_get(keys, dictionary):\n    \"\"\"\n    Gets contents of requirement key recursively so users can search\n    for specific keys inside nested requirement dicts.\n\n    :param keys: key or dot separated string of keys to look for.\n    :param dictionary: Dictionary to search from\n    :return: results of search or None\n    \"\"\"\n    if \".\" in keys and len(keys) > 1:\n        key = keys.split(\".\", 1)\n        new_dict = dictionary.get(key[0])\n        # Make sure that the next level actually has a dict we can continue the search from.\n        if not new_dict or not hasattr(new_dict, \"get\"):\n            return None\n        return recursive_dictionary_get(key[1], new_dict)\n    else:\n        return dictionary.get(keys) if (dictionary and hasattr(dictionary, \"get\")) else None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove empty items from dictionary d", "response": "def remove_empty_from_dict(dictionary):\n    \"\"\"\n    Remove empty items from dictionary d\n\n    :param dictionary:\n    :return:\n    \"\"\"\n    if isinstance(dictionary, dict):\n        return dict(\n            (k,\n             remove_empty_from_dict(v)) for k, v in iteritems(\n                 dictionary) if v and remove_empty_from_dict(v))\n    elif isinstance(dictionary, list):\n        return [remove_empty_from_dict(v) for v in dictionary if v and remove_empty_from_dict(v)]\n    return dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hex_escape_str(original_str):\n    new = []\n    for char in original_str:\n        if str(char) in string.printable:\n            new.append(str(char))\n            continue\n\n        if IS_PYTHON3:\n            new.append(str(char).encode(\"unicode_escape\").decode(\"ascii\"))\n        else:\n            new.append(repr(char).replace(\"'\", \"\"))\n    return \"\".join(new)", "response": "Function to make sure we can generate proper string reports."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets value of key in dictionary.", "response": "def set_or_delete(dictionary, key, value):\n    \"\"\"\n    Set value as value of dict key key. If value is None, delete key key from dict.\n\n    :param dictionary: Dictionary to work on.\n    :param key: Key to set or delete. If deleting and key does not exist in dict, nothing is done.\n    :param value: Value to set. If value is None, delete key.\n    :return: Nothing, modifies dict in place.\n    \"\"\"\n    if value:\n        dictionary[key] = value\n    else:\n        if dictionary.get(key):\n            del dictionary[key]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef initLogger(name):  # pylint: disable=invalid-name\n    '''\n    Initializes a basic logger. Can be replaced when constructing the\n    HttpApi object or afterwards with setter\n    '''\n    logger = logging.getLogger(name)\n    logger.setLevel(logging.INFO)\n    # Skip attaching StreamHandler if one is already attached to logger\n    if not getattr(logger, \"streamhandler_set\", None):\n        consolehandler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        consolehandler.setFormatter(formatter)\n        consolehandler.setLevel(logging.INFO)\n        logger.addHandler(consolehandler)\n        logger.streamhandler_set = True\n    return logger", "response": "Initializes a basic logger."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a combined set of words from a list of words.", "response": "def _create_combined_set(words, startindex):\n    \"\"\"\n    Combines a single string wrapped in parenthesis from a list of words.\n    Example: ['feature1', 'or', '(feature2', 'and', 'feature3)'] -> '(feature2 and feature3)'\n    :param words: List of words\n    :param startindex: Index of starting parenthesis.\n    :return: string\n    \"\"\"\n    counter = 0\n    for i, word in enumerate(words[startindex:]):\n        if \")\" in word and counter == 0:\n            return \" \".join(words[startindex:startindex + i + 1]), i\n        elif \")\" in word and counter != 0:\n            amount = word.count(\")\")\n            counter -= amount\n        if \"(\" in word:\n            counter += word.count(\"(\")\n        if counter == 0:\n            return \" \".join(words[startindex:startindex + i + 1]), i\n    return None, 0"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a single boolean value for each component of words_as_string in a single tree tree.", "response": "def create_match_bool(words_as_string, eval_function, eval_function_args):\n    \"\"\"\n    Evaluates components of words_as_string step by step into a single boolean value using\n    eval_function to evaluate each separate component of words_as_string into booleans.\n    :param words_as_string: String to evaluate\n    :param eval_function: Function for evaluating each component of the string\n    :param eval_function_args: Arguments for eval_function as list or tuple\n    :return: Boolean\n    :raises: SyntaxError if eval raises one.\n    \"\"\"\n    new_set = []\n    count = 0\n    words_as_string = words_as_string.replace(\",\", \" or \")\n    words = words_as_string.split(\" \")\n    # First we combine items that contain spaces back into single entries\n    for i, word in enumerate(words):\n        if count != 0:\n            count -= 1\n            continue\n        if \"'\" in word:\n            # Combine stuff between quotes into single entry\n            combined_data, count = _create_combined_words(words, i)\n            if combined_data is None:\n                raise SyntaxError(\"Missing closing quote for: {}\".format(word))\n            # Count needed to skip over the N next items while we continue\n            new_set.append(combined_data)\n        else:\n            new_set.append(word)\n\n    newest_set = []\n\n    # Then we combine elements inside parentheses into single entries.\n    for i, word in enumerate(new_set):\n        if count != 0:\n            count -= 1\n            continue\n        if \"(\" in word:\n            # Combine stuff between parentheses into single entry that can be reduced later.\n            combined_data, count = _create_combined_set(new_set, i)\n            if combined_data is None:\n                raise SyntaxError(\"Missing closing parenthesis for: {}\".format(word))\n            # Count needed to skip over the N next items while we continue\n            newest_set.append(combined_data)\n        else:\n            newest_set.append(word)\n\n    # Finally we enter deeper inside the parenthesis structure and start working upwards\n    for i, word in enumerate(newest_set):\n        if \"(\" in word:\n            # Still parentheses remaining, we must go deeper.\n            result = create_match_bool(word[1:len(word) - 1], eval_function,\n                                       eval_function_args)\n            newest_set[i] = str(result)\n    for i, word in enumerate(newest_set):\n        if word not in [\"True\", \"False\", \"or\", \"and\", \"not\"]:\n            newest_set[i] = str(eval_function(word.replace(\"'\", \"\"), eval_function_args))\n    result = eval(\" \".join(newest_set))  # pylint: disable=eval-used\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_duplicate_keys(data):\n    out_dict = {}\n    for key, value in data:\n        if key in out_dict:\n            raise ValueError(\"Duplicate key: {}\".format(key))\n        out_dict[key] = value\n    return out_dict", "response": "Find duplicate keys in a layer of ordered pairs."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfunctions init ref: reference for build, e.g. file:c:\\\\.. or http://...", "response": "def init(ref):\n        \"\"\"function init\n        ref: reference for build, e.g. file:c:\\\\.. or http://...\n        \"\"\"\n        r_http = re.compile(r\"^(https?:.*)\")\n        r_uuid = re.compile(\n            r\"^([a-f0-9]{8}-?[a-f0-9]{4}-?[a-f0-9]{4}-?[89ab][a-f0-9]{3}-?[a-f0-9]{12})$\",\n            re.I)\n        r_id = re.compile(r\"^([0-9a-fA-F]{24})$\")\n        r_file = re.compile(r\"^file:(.*)$\")\n        r_any = re.compile(r\"([\\S\\s]{4,})$\")\n        types = [\n            {\"cls\": BuildHttp, \"res\": [r_http]},\n            {\"cls\": BuildDatabase, \"res\": [r_uuid, r_id]},\n            {\"cls\": BuildFile, \"res\": [r_file, r_any]}\n        ]\n\n        for _type in types:\n            for reg in _type[\"res\"]:\n                match = reg.match(ref)\n                if match:\n                    return _type[\"cls\"](ref=match.group(1))\n\n        raise NotImplementedError(\"Cannot detect reference type: %s\" % ref)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfunctioning load. :return: file contents :raises: NotFoundError if file not found", "response": "def _load(self):\n        \"\"\"\n        Function load.\n\n        :return: file contents\n        :raises: NotFoundError if file not found\n        \"\"\"\n        if self.is_exists():\n            return open(self._ref, \"rb\").read()\n        raise NotFoundError(\"File %s not found\" % self._ref)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfunction load. :return: Response content :raises: NotFoundError", "response": "def _load(self):\n        \"\"\"\n        Function load.\n        :return: Response content\n        :raises: NotFoundError\n        \"\"\"\n        try:\n            get = requests.get(self._ref,\n                               verify=self.http_verify,\n                               auth=self.auth,\n                               timeout=self.timeout)\n        except requests.exceptions.RequestException as err:\n            raise NotFoundError(err)\n        return get.content"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading data into a file and return path to file.", "response": "def get_file(self):\n        \"\"\"\n        Load data into a file and return file path.\n\n        :return: path to file as string\n        \"\"\"\n        content = self._load()\n        if not content:\n            return None\n        filename = \"temporary_file.bin\"\n        with open(filename, \"wb\") as file_name:\n            file_name.write(content)\n        return filename"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstarts the Timer for timeout seconds then joins the thread.", "response": "def wait(self, timeout):\n        \"\"\"\n        Starts the Timer for timeout seconds, then gives 5 second grace period to join the thread.\n        :param timeout: Duration for timer.\n        :return: Nothing\n        \"\"\"\n        self.timeout = timeout\n        self.start()\n        self.join(timeout=5)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, path, headers=None, params=None, **kwargs):\n\n        if headers is not None:\n            merger = jsonmerge.Merger(SCHEMA)\n            kwargs[\"headers\"] = merger.merge(self.defaultHeaders, headers)\n        else:\n            kwargs[\"headers\"] = self.defaultHeaders\n\n        if self.cert is not None:\n            kwargs[\"cert\"] = self.cert\n\n        if params is None:\n            params = {}\n\n        url = combine_urls(self.host, path)\n\n        self.logger.debug(\n            \"Trying to send HTTP GET to {0}{1}\".format(url,\n                                                       \"?\" + urllib.urlencode(\n                                                           params,\n                                                           doseq=True) if params else ''))\n        try:\n            resp = requests.get(url, params, **kwargs)\n            self._log_response(resp)\n        except requests.RequestException as es:\n            self._log_exception(es)\n            raise\n        return resp", "response": "Send a GET request to the server."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef post(self, path, data=None, json=None, headers=None, **kwargs):\n\n        if headers is not None:\n            merger = jsonmerge.Merger(SCHEMA)\n            kwargs[\"headers\"] = merger.merge(self.defaultHeaders, headers)\n        else:\n            kwargs[\"headers\"] = self.defaultHeaders\n\n        url = combine_urls(self.host, path)\n\n        if self.cert is not None:\n            kwargs[\"cert\"] = self.cert\n        self.logger.debug(\"Trying to send HTTP POST to {}\".format(url))\n        try:\n            resp = requests.post(url, data, json, **kwargs)\n            self._log_response(resp)\n        except requests.RequestException as es:\n            self._log_exception(es)\n            raise\n\n        return resp", "response": "Sends a HTTP POST request to the server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef as_dict(self):\n        my_info = {}\n        if self.platform:\n            my_info[\"model\"] = self.platform\n        if self.resource_id:\n            my_info[\"sn\"] = self.resource_id\n        if self.vendor:\n            my_info[\"vendor\"] = self.vendor\n        if self.provider:\n            my_info[\"provider\"] = self.provider\n        return my_info", "response": "Generate a dictionary of the contents of this DutInformation object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a list of dut models in this TC. Empty list is not available.", "response": "def get_uniq_list_dutmodels(self):\n        \"\"\"\n        Gets a list of dut models in this TC\n        :return: List of dut models in this TC. Empty list if information is not available.\n        \"\"\"\n        models = []\n        if self.dutinformations:\n            for info in self.dutinformations:\n                models.append(info.platform)\n            seen = []\n            for item in models:\n                if item not in seen:\n                    seen.append(item)\n            return seen\n        return models"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets resource ids as a list.", "response": "def get_resource_ids(self):\n        \"\"\"\n        Get resource ids as a list.\n\n        :return: List of resource id:s or \"unknown\"\n        \"\"\"\n        resids = []\n        if self.dutinformations:\n            for info in self.dutinformations:\n                resids.append(info.resource_id)\n            return resids\n        return \"unknown\""}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef push_resource_cache(resourceid, info):\n        if not resourceid:\n            raise ResourceInitError(\"Resource id missing\")\n        if not DutInformationList._cache.get(resourceid):\n            DutInformationList._cache[resourceid] = dict()\n        DutInformationList._cache[resourceid] = merge(DutInformationList._cache[resourceid], info)", "response": "Pushes the given dictionary to the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_resource_cache(resourceid):\n        if not resourceid:\n            raise ResourceInitError(\"Resource id missing\")\n        if not DutInformationList._cache.get(resourceid):\n            DutInformationList._cache[resourceid] = dict()\n        return DutInformationList._cache[resourceid]", "response": "Get a cached dictionary related to an individual resourceid."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_result_object(result):\n    _result = {\n        'tcid': result.get_tc_name(),\n        'campaign': result.campaign,\n        'cre': {\n            'user': result.tester\n        },\n        'job': {\n            'id': result.job_id\n        },\n        'exec': {\n            'verdict': result.get_verdict(),\n            'duration': result.duration,\n            'note': result.get_fail_reason(),\n            'dut': {\n                'count': result.dut_count,\n                'type': result.dut_type\n            },\n            'sut': {\n                'branch': result.build_branch,\n                'commitId': result.buildcommit,\n                'buildDate': result.build_date,\n                'buildSha1': result.build_sha1,\n                'buildUrl': result.build_url,\n                'gitUrl': result.build_git_url,\n                'cut': result.component,  # Component Under Uest\n                'fut': result.feature    # Feature Under Test\n            },\n            'env': {\n                'framework': {\n                    'name': result.fw_name,\n                    'ver': result.fw_version\n                }\n            },\n            \"logs\": []\n        }\n    }\n\n    if result.dut_resource_id:\n        _result[\"exec\"][\"dut\"][\"sn\"] = result.dut_resource_id\n\n    if result.dut_vendor and result.dut_vendor[0]:\n        _result[\"exec\"][\"dut\"][\"vendor\"] = result.dut_vendor[0]\n    if result.dut_models and result.dut_models[0]:\n        _result[\"exec\"][\"dut\"][\"model\"] = result.dut_models[0]\n    # pylint: disable=len-as-condition\n    if len(result.dut_models) == 1 and len(result.dut_resource_id) == 1:\n        _result[\"exec\"][\"dut\"][\"sn\"] = result.dut_resource_id[0]\n\n    return remove_empty_from_dict(_result)", "response": "Create cloud result object from Result."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef append_logs_to_result_object(result_obj, result):\n    logs = result.has_logs()\n    result_obj[\"exec\"][\"logs\"] = []\n    if logs and result.logfiles:\n        for log in logs:\n            typ = None\n            parts = log.split(os.sep)\n            if \"bench\" in parts[len(parts) - 1]:\n                typ = \"framework\"\n            # elif \"Dut\" in parts[len(parts)-1]:\n            #    typ = \"dut\"\n\n            if typ is not None:\n                name = parts[len(parts) - 1]\n                try:\n                    with open(log, \"r\") as file_name:\n                        data = file_name.read()\n                    dic = {\"data\": data, \"name\": name, \"from\": typ}\n                    result_obj[\"exec\"][\"logs\"].append(dic)\n                except OSError:\n                    pass\n            else:\n                continue", "response": "Append log files to cloud result object from Result."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts the metadata dict to match Opentmi metadata format", "response": "def _convert_to_db_tc_metadata(tc_metadata):\n        \"\"\"\n        Convert tc_metadata to match Opentmi metadata format\n        :param tc_metadata: metadata as dict\n        :return: converted metadata\n        \"\"\"\n        db_meta = copy.deepcopy(tc_metadata)\n\n        # tcid is a mandatory field, it should throw an error if it is missing\n        db_meta['tcid'] = db_meta['name']\n        del db_meta['name']\n\n        # Encapsulate current status inside dictionary\n        if 'status' in db_meta:\n            status = db_meta['status']\n            del db_meta['status']\n            db_meta['status'] = {'value': status}\n\n        # Node and dut information\n        if 'requirements' in db_meta:\n            db_meta['requirements']['node'] = {'count': 1}\n            try:\n                count = db_meta['requirements']['duts']['*']['count']\n                db_meta['requirements']['node']['count'] = count\n            except KeyError:\n                pass\n\n        # Collect and pack other info from meta\n        db_meta['other_info'] = {}\n        if 'title' in db_meta:\n            db_meta['other_info']['title'] = db_meta['title']\n            del db_meta['title']\n\n        if 'feature' in db_meta:\n            db_meta['other_info']['features'] = db_meta['feature']\n            del db_meta['feature']\n        else:\n            db_meta['other_info']['features'] = ['unknown']\n\n        if 'component' in db_meta:\n            db_meta['other_info']['components'] = db_meta[\"component\"]\n            del db_meta['component']\n\n        return db_meta"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nresolves cloud provider host name. Defaults to environment variables NODE_NAME or OPENTMI_ADDRESS_PRIVATE or OPENTMI_ADDRESS_PUBLIC. If that one does not exist returns localhost.", "response": "def _resolve_host(self):  # pylint: disable=no-self-use\n        \"\"\"\n        Resolve cloud provider host name. Defaults to environment variables\n        OPENTMI_ADDRESS_PRIVATE or OPENTMI_ADDRESS_PUBLIC if environment variable NODE_NAME\n        starts with 'aws'. Otherwise gets ICETEA_CLOUD_HOST environment variable OR\n        localhost:3000 if that one does not exist.\n        :return: Cloud host information\n        \"\"\"\n        node_name = os.environ.get('NODE_NAME', '')\n        if node_name.startswith('aws'):\n            _host = os.environ.get('OPENTMI_ADDRESS_PRIVATE', None)\n        else:\n            _host = os.environ.get('OPENTMI_ADDRESS_PUBLIC', None)\n\n        if _host is None:\n            _host = os.environ.get(\"ICETEA_CLOUD_HOST\", \"localhost:3000\")\n\n        return _host"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind port number from host. Defaults to 3000.", "response": "def _find_port(self, host):  # pylint: disable=no-self-use\n        \"\"\"\n        Finds port number from host. Defaults to 3000 if not found\n        :param host: host as string\n        :return: (host, port)\n        \"\"\"\n        ind = host.rfind(\":\")\n        if ind != -1:\n            try:\n                port = int(host[ind + 1:])\n                host = host[:ind]\n            except ValueError:\n                port = 3000\n        else:\n            port = 3000\n        return host, port"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend results to the cloud server.", "response": "def send_result(self, result):\n        \"\"\"\n        Send results to the cloud\n        :param result: result dictionary\n        :return: response from _client.upload_results(result) or None if something went wrong\n        \"\"\"\n        response_data = self._client.upload_results(result)\n        if response_data:\n            if self.logger is not None:\n                self.logger.info(\"Results sent to the server. ID: {}\".format(response_data[\"_id\"]))\n            return response_data\n        else:\n            if self.logger is not None:\n                self.logger.info(\"Server didn't respond or client initialization has failed.\")\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget available devices using mbedls and self. available_edbg_ports.", "response": "def get_available_devices(self):\n        \"\"\"\n        Gets available devices using mbedls and self.available_edbg_ports.\n\n        :return: List of connected devices as dictionaries.\n        \"\"\"\n        connected_devices = self.mbeds.list_mbeds() if self.mbeds else []\n        # Check non mbedOS supported devices.\n        # Just for backward compatible reason - is obsolete..\n        edbg_ports = self.available_edbg_ports()\n        for port in edbg_ports:\n            connected_devices.append({\n                \"platform_name\": \"SAM4E\",\n                \"serial_port\": port,\n                \"mount_point\": None,\n                \"target_id\": None,\n                \"baud_rate\": 460800\n            })\n        for dev in connected_devices:\n            dev['state'] = \"unknown\"\n\n        return connected_devices"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef available_edbg_ports(self):\n        ports_available = sorted(list(list_ports.comports()))\n        edbg_ports = []\n        for iport in ports_available:\n            port = iport[0]\n            desc = iport[1]\n            hwid = iport[2]\n            if str(desc).startswith(\"EDBG Virtual COM Port\") or \\\n                            \"VID:PID=03EB:2111\" in str(hwid).upper():\n                # print(\"%-10s: %s (%s)\\n\" % (port, desc, hwid))\n                try:\n                    edbg_ports.index(port, 0)\n                    print(\"There is multiple %s ports with same number!\" % port)\n                except ValueError:\n                    edbg_ports.append(port)\n        # print(\"Detected %i DUT's\" % len(edbg_ports))\n        return edbg_ports", "response": "Finds available EDBG COM ports."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef store_traces(self, value):\n        if not value:\n            self.logger.debug(\"Stopping storing received lines for dut %d\", self.index)\n            self._store_traces = False\n        else:\n            self.logger.debug(\"Resuming storing received lines for dut %d\", self.index)\n            self._store_traces = True", "response": "Setter for _store_traces. _store_traces controls in memory storing of received lines.\n        Also logs the change for the user.\n\n        :param value: Boolean\n        :return: Nothing"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of default init commands.", "response": "def set_default_init_cli_cmds(self):\n        \"\"\"\n        Default init commands are set --retcode true, echo off, set --vt100 off, set dut <dut name>\n        and set testcase <tc name>\n\n        :return: List of default cli initialization commands.\n        \"\"\"\n        init_cli_cmds = []\n        init_cli_cmds.append(\"set --retcode true\")\n        init_cli_cmds.append(\"echo off\")\n        init_cli_cmds.append(\"set --vt100 off\")\n\n        #set dut name as variable\n        init_cli_cmds.append('set dut \"'+self.name+'\"')\n        init_cli_cmds.append(['set testcase \"' + self.testcase + '\"', True])\n        return init_cli_cmds"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset default commands to restore cli to human readable state", "response": "def set_default_init_cli_human_cmds(self):  # pylint: disable=no-self-use\n        \"\"\"\n        Default commands to restore cli to human readable state are echo on, set --vt100 on,\n        set --retcode false.\n\n        :return: List of default commands to restore cli to human readable format\n        \"\"\"\n        post_cli_cmds = []\n        post_cli_cmds.append(\"echo on\")\n        post_cli_cmds.append(\"set --vt100 on\")\n        post_cli_cmds.append([\"set --retcode false\", False, False])  # last True is wait=<Boolean>\n        return post_cli_cmds"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef init_cli(self):\n        if self.init_cli_cmds is None:\n            self.init_cli_cmds = self.set_default_init_cli_cmds()\n\n        for cli_cmd in self.init_cli_cmds:\n            if isinstance(cli_cmd, list) and len(cli_cmd) >= 2:\n                asynchronous = cli_cmd[1]\n                if len(cli_cmd) > 2:\n                    wait = cli_cmd[2]\n                else:\n                    wait = True\n                self.execute_command(cli_cmd[0], wait=wait, asynchronous=asynchronous)\n            else:\n                self.execute_command(cli_cmd)", "response": "Initialize the internal cli for script."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing EventMatcher to wait for certain cli_ready_trigger to arrive from this Dut.", "response": "def init_wait_register(self):\n        \"\"\"\n        Initialize EventMatcher to wait for certain cli_ready_trigger to arrive from this Dut.\n\n        :return: None\n        \"\"\"\n        app = self.config.get(\"application\")\n\n        if app:\n            bef_init_cmds = app.get(\"cli_ready_trigger\")\n            if bef_init_cmds:\n                self.init_done.clear()\n                self.init_event_matcher = EventMatcher(EventTypes.DUT_LINE_RECEIVED,\n                                                       bef_init_cmds, self, self.init_done)\n                self.init_wait_timeout = app.get(\"cli_ready_trigger_timeout\", 30)\n                return\n        self.init_done.set()\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nblocking until init_done flag is set or until init_wait_timeout happens.", "response": "def wait_init(self):\n        \"\"\"\n        Block until init_done flag is set or until init_wait_timeout happens.\n\n        :return: value of init_done\n        \"\"\"\n        init_done = self.init_done.wait(timeout=self.init_wait_timeout)\n        if not init_done:\n            if hasattr(self, \"peek\"):\n                app = self.config.get(\"application\")\n                if app:\n                    bef_init_cmds = app.get(\"cli_ready_trigger\")\n                    if bef_init_cmds in self.peek():  # pylint: disable=no-member\n                        init_done = True\n        return init_done"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef init_cli_human(self):\n        if self.post_cli_cmds is None:\n            self.post_cli_cmds = self.set_default_init_cli_human_cmds()\n        for cli_cmd in self.post_cli_cmds:\n            try:\n                if isinstance(cli_cmd, list) and len(cli_cmd) >= 2:\n                    asynchronous = cli_cmd[1]\n                    if len(cli_cmd) > 2:\n                        wait = cli_cmd[2]\n                    else:\n                        wait = True\n                    self.execute_command(cli_cmd[0], wait=wait, asynchronous=asynchronous)\n                else:\n                    self.execute_command(cli_cmd)\n            except (TestStepFail, TestStepError, TestStepTimeout):\n                continue", "response": "Send post_cli_cmds to dut\n\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_time_function(self, function):\n        if isinstance(function, types.FunctionType):\n            self.get_time = function\n        else:\n            raise ValueError(\"Invalid value for DUT time function\")", "response": "Sets the time function to be used."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nopening connection to dut.", "response": "def open_dut(self, port=None):\n        \"\"\"\n        Open connection to dut.\n\n        :param port: com port to use.\n        :return:\n        \"\"\"\n        if port is not None:\n            self.comport = port\n\n        try:\n            self.open_connection()\n        except (DutConnectionError, ValueError) as err:\n            self.close_dut(use_prepare=False)\n            raise DutConnectionError(str(err))\n        except KeyboardInterrupt:\n            self.close_dut(use_prepare=False)\n            self.close_connection()\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _wait_for_exec_ready(self):\n        while not self.response_received.wait(1) and self.query_timeout != 0:\n            if self.query_timeout != 0 and self.query_timeout < self.get_time():\n                if self.prev:\n                    cmd = self.prev.cmd\n                else:\n                    cmd = \"???\"\n                self.logger.error(\"CMD timeout: \"+ cmd)\n                self.query_timeout = 0\n                raise TestStepTimeout(self.name + \" CMD timeout: \" + cmd)\n            self.logger.debug(\"Waiting for response... \"\n                              \"timeout=%d\", self.query_timeout - self.get_time())\n            self._dut_is_alive()\n\n        if self.response_coming_in == -1:\n            if self.query_async_response is not None:\n                # fullfill the async response with a dummy response and clean the state\n                self.query_async_response.set_response(CliResponse())\n                self.query_async_response = None\n            # raise and log the error\n            self.logger.error(\"No response received, DUT died\")\n            raise TestStepError(\"No response received, DUT \"+self.name+\" died\")\n\n        # if an async response is pending, fullfill it with the result\n        if self.query_async_response is not None:\n            self.query_async_response.set_response(self.response_coming_in)\n            self.query_async_response = None\n\n        self.query_timeout = 0\n        return self.response_coming_in", "response": "Wait for the command to be ready and return the result."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef execute_command(self, req, **kwargs):\n        if isinstance(req, string_types):\n            # backward compatible\n            timeout = 50  # Use same default timeout as bench.py\n            wait = True\n            asynchronous = False\n            for key in kwargs:\n                if key == 'wait':\n                    wait = kwargs[key]\n                elif key == 'timeout':\n                    timeout = kwargs[key]  # [ms]\n                elif key == 'asynchronous':\n                    asynchronous = kwargs[key]\n            req = CliRequest(req,\n                             timestamp=self.get_time(),\n                             wait=wait,\n                             timeout=timeout,\n                             asynchronous=asynchronous)\n\n        # wait for previous command ready\n        if req.wait:\n            response = self._wait_for_exec_ready()\n            if response is not None and self.query_async_expected is not None:\n                if response.retcode != self.query_async_expected:\n                    self.logger.error(\"Asynch call returned unexpected result, \"\n                                      \"expected %d was %d\", self.query_async_expected,\n                                      response.retcode)\n                    raise TestStepFail(\"Asynch call returned unexpected result\")\n                self.query_async_expected = None\n\n        # Tell Query to worker thread\n        self.response_received.clear()\n        self.query_timeout = self.get_time() + req.timeout if req.wait else 0\n        self.query = req\n\n        msg = \"Async CMD {}, \" \\\n              \"timeout={}, time={}\" if req.asynchronous else \"CMD {}, timeout={}, time={}\"\n        msg = msg.format(req.cmd, int(self.query_timeout), int(self.get_time()))\n        self.logger.debug(msg, extra={'type': '<->'})\n\n        Dut.process_dut(self)\n\n        if req.asynchronous is True:\n            self.query_async_expected = req.expected_retcode\n            async_response = CliAsyncResponse(self)\n            self.query_async_response = async_response\n            return async_response\n\n        if req.wait is False:\n            self.query_async_expected = req.expected_retcode\n            # if an async response was waiting, just discard the result\n            # since the new command has already been sent...\n            # This is not ideal but when a command has its flags \"Wait == False\"\n            # the result of the previous command is already discarded in previous\n            # stages\n            if self.query_async_response is not None:\n                self.query_async_response.set_response(CliResponse())\n            self.query_async_response = None\n            return CliResponse()\n\n        return self._wait_for_exec_ready()", "response": "Execute a command in DUT or CLIRequest and return CliResponse."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nclosing connection to dut.", "response": "def close_dut(self, use_prepare=True):\n        \"\"\"\n        Close connection to dut.\n\n        :param use_prepare: Boolean, default is True. Call prepare_connection_close before\n        closing connection.\n        :return: Nothing\n        \"\"\"\n        if not self.stopped:\n            self.logger.debug(\"Close '%s' connection\" % self.dut_name, extra={'type': '<->'})\n            if use_prepare:\n                try:\n                    self.prepare_connection_close()\n                except TestStepFail:\n                    # We can ignore this for dead Duts, just continue with cleanup\n                    pass\n            self.stopped = True\n            Dut._dutlist.remove(self)\n            # Remove myself from signalled dut list, if I'm still there\n            if Dut._signalled_duts and Dut._signalled_duts.count(self):\n                try:\n                    Dut._signalled_duts.remove(self)\n                except ValueError:\n                    pass\n\n            try:\n                if not Dut._dutlist:\n                    Dut._run = False\n                    Dut._sem.release()\n                    Dut._th.join()\n                    del Dut._th\n                    Dut._th = None\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsignaling worker thread that specified Dut needs processing", "response": "def process_dut(dut):\n        \"\"\"\n        Signal worker thread that specified Dut needs processing\n        \"\"\"\n        if dut.finished():\n            return\n        Dut._signalled_duts.appendleft(dut)\n        Dut._sem.release()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_retcode(self, line):\n        retcode = None\n        match = re.search(r\"retcode\\: ([-\\d]{1,})\", line)\n        if match:\n            retcode = num(str(match.group(1)))\n\n        match = re.search(\"cmd tasklet init\", line)\n        if match:\n            self.logger.debug(\"Device Boot up\", extra={'type': '   '})\n            return -1\n        return retcode", "response": "Check for retcode on line and return code if found."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start_dut_thread(self):  # pylint: disable=no-self-use\n        if Dut._th is None:\n            Dut._run = True\n            Dut._sem = Semaphore(0)\n            Dut._signalled_duts = deque()\n            Dut._logger = LogManager.get_bench_logger('Dut')\n            Dut._th = Thread(target=Dut.run, name='DutThread')\n\n            Dut._th.daemon = True\n            Dut._th.start()", "response": "Start the Dut thread."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _event_received(self, ref, data):\n        match = self._resolve_match_data(ref, data)\n        if match:\n            if self.flag_to_set:\n                self.flag_to_set.set()\n            if self.callback:\n                self.callback(EventMatch(ref, data, match))\n            if self.__forget:\n                self.forget()", "response": "Handle received event.\n\n        :param ref: ref is the object that generated the event.\n        :param data: event data.\n        :return: Nothing."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _resolve_match_data(self, ref, event_data):\n        if self.caller is None:\n            pass\n        elif ref is not self.caller:\n            return False\n        try:\n            dat = event_data if IS_PYTHON3 else event_data.decode(\"utf-8\")\n            if self.match_data.startswith(\"regex:\"):\n                splt = self.match_data.split(\":\", 1)\n                pttrn = re.compile(splt[1])\n                match = re.search(pttrn, dat)\n                return match if match is not None else False\n            return event_data if self.match_data in dat else False\n        except UnicodeDecodeError:\n            dat = repr(event_data)\n            return self._resolve_match_data(ref, dat)", "response": "Resolve the match_data for the ref and event_data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting a Python dictionary as JSON to a file.", "response": "def write_file(self, content, filepath=None, filename=None, indent=None, keys_to_write=None):\n        '''\n        Write a Python dictionary as JSON to a file.\n\n        :param content: Dictionary of key-value pairs to save to a file\n        :param filepath: Path where the file is to be created\n        :param filename: Name of the file to be created\n        :param indent: You can use this to specify indent level for pretty printing the file\n        :param keys_to_write: array of keys that are to be picked from data and written to file.\n                Default is None, when all data is written to file.\n        :return: Path of file used\n        :raises OSError, EnvironmentError, ValueError\n        '''\n        path = filepath if filepath else self.filepath\n        name = filename if filename else self.filename\n        if not os.path.exists(path):\n            try:\n                os.makedirs(path)\n            except OSError as error:\n                self.logger.error(\"Error while creating directory: {}\".format(error))\n                raise\n\n        name = self._ends_with(name, \".json\")\n        path = self._ends_with(path, os.path.sep)\n\n        if keys_to_write:\n            data_to_write = {}\n            for key in keys_to_write:\n                data_to_write[key] = content[key]\n        else:\n            data_to_write = content\n\n        try:\n            indent = indent if indent else 2\n            self._write_json(path, name, 'w', data_to_write, indent)\n            return os.path.join(path, name)\n        except EnvironmentError as error:\n            self.logger.error(\"Error while opening or writing to file: {}\".format(error))\n            raise\n        except ValueError:\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_file(self, filepath=None, filename=None):\n        name = filename if filename else self.filename\n        path = filepath if filepath else self.filepath\n        name = self._ends_with(name, \".json\")\n        path = self._ends_with(path, os.path.sep)\n\n        try:\n            return self._read_json(path, name)\n        except EnvironmentError as error:\n            self.logger.error(\"Error while opening or reading the file: {}\".format(error))\n            raise\n        except ValueError as error:\n            self.logger.error(\"File contents cannot be decoded to JSON: {}\".format(error))\n            raise", "response": "Reads the file and returns a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_value(self, key, filepath=None, filename=None):\n        path = filepath if filepath else self.filepath\n        name = filename if filename else self.filename\n        name = self._ends_with(name, \".json\")\n        path = self._ends_with(path, os.path.sep)\n\n        try:\n            output = self._read_json(path, name)\n            if key not in output:\n                raise KeyError(\"Key '{}' not found in file {}\".format(key, filename))\n            else:\n                return output[key]\n        except EnvironmentError as error:\n            self.logger.error(\"Error while opening or reading the file: {}\".format(error))\n            raise", "response": "Reads the value of given key from JSON file filename."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_values(self, data, filepath=None, filename=None, indent=None, keys_to_write=None):\n\n        name = filename if filename else self.filename\n        path = filepath if filepath else self.filepath\n        name = self._ends_with(name, \".json\")\n        path = self._ends_with(path, os.path.sep)\n\n        if not os.path.isfile(path + name):\n            try:\n                return self.write_file(data, path, name, indent, keys_to_write)\n            except EnvironmentError as error:\n                self.logger.error(\"Error while opening or writing to file: {}\".format(error))\n                raise\n            except ValueError:\n                raise\n\n        if keys_to_write:\n            data_to_write = {}\n            for key in keys_to_write:\n                data_to_write[key] = data[key]\n        else:\n            data_to_write = data\n\n        try:\n            with open(path + name, 'r') as fil:\n                output = json.load(fil)\n                self.logger.info(\"Read contents of {}\".format(filename))\n                for key in data_to_write:\n                    try:\n                        output[key] = data_to_write[key]\n                    except TypeError as error:\n                        self.logger.error(\n                            \"File contents could not be serialized into a dict. {}\".format(error))\n                        raise\n            self._write_json(path, name + \".temp\", \"w\", output, indent)\n            FileUtils.remove_file(name, path)\n            FileUtils.rename_file(name + '.temp', name, path)\n            return os.path.join(path, name)\n        except EnvironmentError as error:\n            self.logger.error(\n                \"Error while writing to, opening or reading the file: {}\".format(error))\n            raise\n        except ValueError as error:\n            self.logger.error(\n                \"File could not be decoded to JSON. It might be empty? {}\".format(error))\n            try:\n                self._write_json(path, name, \"w\", data_to_write, indent)\n                return os.path.join(path, name)\n            except EnvironmentError:\n                raise", "response": "Writes the data to a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _read_json(self, path, name):\n        with open(os.path.join(path, name), 'r') as fil:\n            output = json.load(fil)\n            self.logger.info(\"Read contents of {}\".format(name))\n            return output", "response": "Load a json into a dictionary from a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if string ends with end characters", "response": "def _ends_with(self, string_to_edit, end):  # pylint: disable=no-self-use\n        \"\"\"\n        Check if string ends with characters in end, if not merge end to string.\n\n        :param string_to_edit: string to check and edit.\n        :param end: str\n        :return: string_to_edit or string_to_edit + end\n        \"\"\"\n        if not string_to_edit.endswith(end):\n            return string_to_edit + end\n        return string_to_edit"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing response. :param args: List. 2 first items used as parser name and response to parse :param kwargs: dict, not used :return: dictionary or return value of called callable from parser.", "response": "def parse(self, *args, **kwargs):  # pylint: disable=unused-argument\n        \"\"\"\n        Parse response.\n\n        :param args: List. 2 first items used as parser name and response to parse\n        :param kwargs: dict, not used\n        :return: dictionary or return value of called callable from parser.\n        \"\"\"\n        # pylint: disable=W0703\n        cmd = args[0]\n        resp = args[1]\n        if cmd in self.parsers:\n            try:\n                return self.parsers[cmd](resp)\n            except Exception as err:\n                print(err)\n        return {}"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nappends a new Result to the list.", "response": "def append(self, result):\n        \"\"\"\n        Append a new Result to the list.\n\n        :param result: Result to append\n        :return: Nothing\n        :raises: TypeError if result is not Result or ResultList\n        \"\"\"\n        if isinstance(result, Result):\n            self.data.append(result)\n        elif isinstance(result, ResultList):\n            self.data += result.data\n        else:\n            raise TypeError('unknown result type')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save(self, heads, console=True):\n        # Junit\n        self._save_junit()\n        # HTML\n        self._save_html_report(heads)\n        if console:\n            # Console print\n            self._print_console_summary()", "response": "Create reports in different formats."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving Junit report. :return: Nothing", "response": "def _save_junit(self):\n        \"\"\"\n        Save Junit report.\n\n        :return: Nothing\n        \"\"\"\n        report = ReportJunit(self)\n        file_name = report.get_latest_filename(\"result.junit.xml\", \"\")\n        report.generate(file_name)\n\n        file_name = report.get_latest_filename(\"junit.xml\", \"../\")\n        report.generate(file_name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _save_html_report(self, heads=None, refresh=None):\n        report = ReportHtml(self)\n        heads = heads if heads else {}\n        test_report_filename = report.get_current_filename(\"html\")\n        report.generate(test_report_filename, title='Test Results', heads=heads, refresh=refresh)\n\n        # Update latest.html in the log root directory\n        latest_report_filename = report.get_latest_filename(\"html\")\n        report.generate(latest_report_filename, title='Test Results', heads=heads, refresh=refresh)", "response": "Save html report.\n\n        :param heads: headers as dict\n        :param refresh: Boolean, if True will add a reload-tag to the report\n        :return: Nothing"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the amount of passed test cases in this list.", "response": "def success_count(self):\n        \"\"\"\n        Amount of passed test cases in this list.\n\n        :return: integer\n        \"\"\"\n        return len([i for i, result in enumerate(self.data) if result.success])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef failure_count(self):\n        return len([i for i, result in enumerate(self.data) if result.failure])", "response": "Returns the number of failed test cases in this list."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\namounts of inconclusive test cases in this list.", "response": "def inconclusive_count(self):\n        \"\"\"\n        Amount of inconclusive test cases in this list.\n\n        :return: integer\n        \"\"\"\n        inconc_count = len([i for i, result in enumerate(self.data) if result.inconclusive])\n        unknown_count = len([i for i, result in enumerate(self.data) if result.get_verdict() ==\n                             \"unknown\"])\n        return inconc_count + unknown_count"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the amount of test cases that have been retried.", "response": "def retry_count(self):\n        \"\"\"\n        Amount of retried test cases in this list.\n\n        :return: integer\n        \"\"\"\n        retries = len([i for i, result in enumerate(self.data) if result.retries_left > 0])\n        return retries"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the number of skipped test cases in this list.", "response": "def skip_count(self):\n        \"\"\"\n        Amount of skipped test cases in this list.\n\n        :return: integer\n        \"\"\"\n        return len([i for i, result in enumerate(self.data) if result.skip])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if there are any fails that were not subsequently retried.", "response": "def clean_fails(self):\n        \"\"\"\n        Check if there are any fails that were not subsequently retried.\n\n        :return: Boolean\n        \"\"\"\n        for item in self.data:\n            if item.failure and not item.retries_left > 0:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if there are any inconclusives or uknowns that were not subsequently retried.", "response": "def clean_inconcs(self):\n        \"\"\"\n        Check if there are any inconclusives or uknowns that were not subsequently retried.\n\n        :return: Boolean\n        \"\"\"\n        for item in self.data:\n            if (item.inconclusive or item.get_verdict() == \"unknown\") and not item.retries_left > 0:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsumming of the durations of the tests in this list.", "response": "def total_duration(self):\n        \"\"\"\n        Sum of the durations of the tests in this list.\n\n        :return: integer\n        \"\"\"\n        durations = [result.duration for result in self.data]\n        return sum(durations)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the pass rate for tests in this list.", "response": "def pass_rate(self, include_skips=False, include_inconclusive=False, include_retries=True):\n        \"\"\"\n        Calculate pass rate for tests in this list.\n\n        :param include_skips: Boolean, if True skipped tc:s will be included. Default is False\n        :param include_inconclusive: Boolean, if True inconclusive tc:s will be included.\n        Default is False.\n        :param include_retries: Boolean, if True retried tc:s will be included in percentages.\n        :return: Percentage in format .2f %\n        \"\"\"\n        total = self.count()\n        success = self.success_count()\n        retries = self.retry_count()\n        try:\n            if include_inconclusive and include_skips and include_retries:\n                val = 100.0*success/total\n            elif include_inconclusive and include_skips and not include_retries:\n                val = 100.0 * success / (total - retries)\n            elif include_skips and include_retries and not include_inconclusive:\n                inconcs = self.inconclusive_count()\n                val = 100.0 * success / (total - inconcs)\n            elif include_skips and not include_retries and not include_inconclusive:\n                inconcs = self.inconclusive_count()\n                val = 100.0 * success / (total - inconcs - retries)\n            elif include_inconclusive and include_retries and not include_skips:\n                skipped = self.skip_count()\n                val = 100.0 * success / (total - skipped)\n            elif include_inconclusive and not include_retries and not include_skips:\n                skipped = self.skip_count()\n                val = 100.0 * success / (total - skipped - retries)\n            elif not include_inconclusive and not include_skips and include_retries:\n                failures = self.failure_count()\n                val = 100.0 * success / (failures + success)\n            else:\n                failures = self.clean_fails()\n                val = 100.0 * success / (failures + success)\n        except ZeroDivisionError:\n            val = 0\n        return format(val, '.2f') + \" %\""}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_summary(self):\n        return {\n            \"count\": self.count(),\n            \"pass\": self.success_count(),\n            \"fail\": self.failure_count(),\n            \"skip\": self.skip_count(),\n            \"inconclusive\": self.inconclusive_count(),\n            \"retries\": self.retry_count(),\n            \"duration\": self.total_duration()\n        }", "response": "Get a summary of this ResultLists contents as dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_file(filename, path=None):\n    cwd = os.getcwd()\n    try:\n        if path:\n            os.chdir(path)\n    except OSError:\n        raise\n    try:\n        os.remove(filename)\n        os.chdir(cwd)\n        return True\n    except OSError:\n        os.chdir(cwd)\n        raise", "response": "Removes a file from the sequence of files in path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrenaming a file. :param old: Old file name :param new: New file name :param path: Path to file :return: True if successfull :raises: OSError if chdir or rename fails.", "response": "def rename_file(old, new, path=None):\n    \"\"\"\n    Rename a file.\n\n    :param old: Old file name\n    :param new: New file name\n    :param path: Path to file\n    :return: True if successfull\n    :raises: OSError if chdir or rename fails.\n    \"\"\"\n    cwd = os.getcwd()\n    try:\n        if path:\n            os.chdir(path)\n    except OSError:\n        raise\n    try:\n        os.rename(old, new)\n        os.chdir(cwd)\n        return True\n    except OSError:\n        os.chdir(cwd)\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef acquire(self):\n        try:\n            self._lock_fd = os.open(self._lock_filename, os.O_CREAT | os.O_EXCL)\n        except OSError:\n            return False\n        return True", "response": "Acquire the lock.\n\n        :return: Boolean."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef release(self):\n        if self._lock_fd is not None:\n            os.close(self._lock_fd)\n            try:\n                os.remove(self._lock_filename)\n            except OSError:\n                # Hmm, someone deleted our lock while we had it locked?\n                # Nothing we can do, so just continue\n                pass", "response": "Release the lock.\n\n        :return: Nothing"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef verify_message(self, expected_response, break_in_fail=True):\n        ok = True\n        try:\n            ok = verify_message(self.lines, expected_response)\n        except (TypeError, LookupError) as inst:\n            ok = False\n            if break_in_fail:\n                raise inst\n        if ok is False and break_in_fail:\n            raise LookupError(\"Unexpected message found\")\n        return ok", "response": "Verifies that the expected_response is found in self. lines."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nverifies that the expected response is found in self. traces .", "response": "def verify_trace(self, expected_traces, break_in_fail=True):\n        \"\"\"\n        Verifies that expectedResponse is found in self.traces\n\n        :param expected_traces: response or responses to look for. Must be list or str.\n        :param break_in_fail: If set to True, re-raises exceptions caught or if message was\n        not found\n        :return: True or False\n        :raises: LookupError if message was not found and breakInFail was True. Other Exceptions\n        might also be raised through searcher.verify_message.\n        \"\"\"\n        ok = True\n        try:\n            ok = verify_message(self.traces, expected_traces)\n        except (TypeError, LookupError) as inst:\n            ok = False\n            if break_in_fail:\n                raise inst\n        if ok is False and break_in_fail:\n            raise LookupError(\"Unexpected message found\")\n        return ok"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef verify_response_duration(self, expected=None, zero=0, threshold_percent=0,\n                                 break_in_fail=True):\n        \"\"\"\n        Verify that response duration is in bounds.\n\n        :param expected: seconds what is expected duration\n        :param zero: seconds if one to normalize duration before calculating error rate\n        :param threshold_percent: allowed error in percents\n        :param break_in_fail: boolean, True if raise TestStepFail when out of bounds\n        :return: (duration, expected duration, error)\n        \"\"\"\n        was = self.timedelta - zero\n        error = abs(was/expected)*100.0 - 100.0 if expected > 0 else 0\n        msg = \"should: %.3f, was: %.3f, error: %.3f %%\" % (expected, was, error)\n        self.logger.debug(msg)\n        if abs(error) > threshold_percent:\n            msg = \"Thread::wait error(%.2f %%) was out of bounds (%.2f %%)\" \\\n                  % (error, threshold_percent)\n            self.logger.debug(msg)\n            if break_in_fail:\n                raise TestStepFail(msg)\n        return was, expected, error", "response": "Verify that response duration is in bounds."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nverify that response time span between request - response is reasonable.", "response": "def verify_response_time(self, expected_below):\n        \"\"\"\n        Verify that response time (time span between request-response) is reasonable.\n\n        :param expected_below: integer\n        :return: Nothing\n        :raises: ValueError if timedelta > expected time\n        \"\"\"\n        if self.timedelta > expected_below:\n            raise ValueError(\"Response time is more (%f) than expected (%f)!\"\n                             % (self.timedelta, expected_below))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the amount of hardware resources in the cache.", "response": "def _hardware_count(self):\n        \"\"\"\n        Amount of hardware resources.\n\n        :return: integer\n        \"\"\"\n        return self._counts.get(\"hardware\") + self._counts.get(\"serial\") + self._counts.get(\"mbed\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef resolve_configuration(self, configuration):\n        configuration = configuration if configuration else self.json_config\n        self._resolve_requirements(configuration[\"requirements\"])\n        self._resolve_dut_count()", "response": "Resolve requirements from given JSON encoded data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _solve_location(self, req, dut_req_len, idx):\n        if not req.get(\"location\"):\n            return\n        if len(req.get(\"location\")) == 2:\n            for x_and_y, coord in enumerate(req.get(\"location\")):\n\n                if isinstance(coord, string_types):\n                    coord = ResourceConfig.__replace_coord_variables(coord,\n                                                                     x_and_y,\n                                                                     dut_req_len,\n                                                                     idx)\n                    try:\n                        loc = req.get(\"location\")\n                        loc[x_and_y] = eval(coord)  # pylint: disable=eval-used\n                        req.set(\"location\", loc)\n                    except SyntaxError as error:\n                        self.logger.error(error)\n                        loc = req.get(\"location\")\n                        loc[x_and_y] = 0.0\n                        req.set(\"location\", loc)\n        else:\n            self.logger.error(\"invalid location field!\")\n            req.set(\"location\", [0.0, 0.0])", "response": "Solve the location of a resource in a Requirements dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreplace i and n in text with index + 1 and req_len.", "response": "def __replace_base_variables(text, req_len, idx):\n        \"\"\"\n        Replace i and n in text with index+1 and req_len.\n\n        :param text: base text to modify\n        :param req_len: amount of required resources\n        :param idx: index of resource we are working on\n        :return: modified string\n        \"\"\"\n        return text \\\n            .replace(\"{i}\", str(idx + 1)) \\\n            .replace(\"{n}\", str(req_len))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __replace_coord_variables(text, x_and_y, req_len, idx):\n        return ResourceConfig.__replace_base_variables(text, req_len, idx) \\\n            .replace(\"{xy}\", str(x_and_y)) \\\n            .replace(\"{pi}\", str(math.pi))", "response": "Replace x and y with their coordinates and replace pi with value of pi."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __generate_indexed_requirements(dut_count, basekeys, requirements):\n        dut_requirements = []\n        for i in range(1, dut_count + 1):\n            dut_requirement = ResourceRequirements(basekeys.copy())\n            if i in requirements[\"duts\"]:\n                for k in requirements[\"duts\"][i]:\n                    dut_requirement.set(k, requirements[\"duts\"][i][k])\n            elif str(i) in requirements[\"duts\"]:\n                i = str(i)\n                for k in requirements[\"duts\"][i]:\n                    dut_requirement.set(k, requirements[\"duts\"][i][k])\n            dut_requirements.append(dut_requirement)\n        return dut_requirements", "response": "Generate indexed requirements from general requirements."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _resolve_hardware_count(self):\n        length = len([d for d in self._dut_requirements if d.get(\"type\") in [\"hardware\",\n                                                                             \"serial\", \"mbed\"]])\n        self._hardware_count = length", "response": "Calculate amount of hardware resources."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _resolve_process_count(self):\n        length = len([d for d in self._dut_requirements if d.get(\"type\") == \"process\"])\n        self._process_count = length", "response": "Calculate the amount of process resources."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nresolve the total number of resources required and their types.", "response": "def _resolve_dut_count(self):\n        \"\"\"\n        Calculates total amount of resources required and their types.\n\n        :return: Nothing, modifies _dut_count, _hardware_count and\n        _process_count\n        :raises: ValueError if total count does not match counts of types separately.\n        \"\"\"\n        self._dut_count = len(self._dut_requirements)\n        self._resolve_process_count()\n        self._resolve_hardware_count()\n        if self._dut_count != self._hardware_count + self._process_count:\n            raise ValueError(\"Missing or invalid type fields in dut configuration!\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the configuration for the dut ident.", "response": "def set_dut_configuration(self, ident, config):\n        \"\"\"\n        Set requirements for dut ident.\n\n        :param ident: Identity of dut.\n        :param config: If ResourceRequirements object, add object as requirements for resource\n        ident. If dictionary, create new ResourceRequirements object from dictionary.\n        :return: Nothing\n        \"\"\"\n        if hasattr(config, \"get_requirements\"):\n            self._dut_requirements[ident] = config\n        elif isinstance(config, dict):\n            self._dut_requirements[ident] = ResourceRequirements(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nflashes a binary to the target device using mbed - flasher.", "response": "def flash(self, binary_location=None, forceflash=None):\n        \"\"\"\n        Flash a binary to the target device using mbed-flasher.\n\n        :param binary_location: Binary to flash to device.\n        :param forceflash: Not used.\n        :return: False if an unknown error was encountered during flashing.\n        True if flasher retcode == 0\n        :raises: ImportError if mbed-flasher not installed.\n        :raises: DutConnectionError if flashing fails.\n        \"\"\"\n        if not Flash:\n            self.logger.error(\"Mbed-flasher not installed!\")\n            raise ImportError(\"Mbed-flasher not installed!\")\n\n        try:\n            # create build object\n            self.build = Build.init(binary_location)\n        except NotImplementedError as error:\n            self.logger.error(\"Build initialization failed. \"\n                              \"Check your build location.\")\n            self.logger.debug(error)\n            raise DutConnectionError(error)\n\n        # check if need to flash - depend on forceflash -option\n        if not self._flash_needed(forceflash=forceflash):\n            self.logger.info(\"Skipping flash, not needed.\")\n            return True\n        # initialize mbed-flasher with proper logger\n        logger = get_external_logger(\"mbed-flasher\", \"FLS\")\n        flasher = Flash(logger=logger)\n\n        if not self.device:\n            self.logger.error(\"Trying to flash device but device is not there?\")\n            return False\n\n        try:\n            buildfile = self.build.get_file()\n            if not buildfile:\n                raise DutConnectionError(\"Binary {} not found\".format(buildfile))\n            self.logger.info('Flashing dev: %s', self.device['target_id'])\n            target_id = self.device.get(\"target_id\")\n            retcode = flasher.flash(build=buildfile, target_id=target_id,\n                                    device_mapping_table=[self.device])\n        except FLASHER_ERRORS as error:\n            if error.__class__ == NotImplementedError:\n                self.logger.error(\"Flashing not supported for this platform!\")\n            elif error.__class__ == SyntaxError:\n                self.logger.error(\"target_id required by mbed-flasher!\")\n            if FlashError is not None:\n                if error.__class__ == FlashError:\n                    self.logger.error(\"Flasher raised the following error: %s Error code: %i\",\n                                      error.message, error.return_code)\n            raise DutConnectionError(error)\n        if retcode == 0:\n            self.dutinformation.build_binary_sha1 = self.build.sha1\n            return True\n        self.dutinformation.build_binary_sha1 = None\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if flashing is needed.", "response": "def _flash_needed(self, **kwargs):\n        \"\"\"\n        Check if flashing is needed. Flashing can be skipped if resource binary_sha1 attribute\n        matches build sha1 and forceflash is not True.\n\n        :param kwargs: Keyword arguments (forceflash: Boolean)\n        :return: Boolean\n        \"\"\"\n        forceflash = kwargs.get(\"forceflash\", False)\n        cur_binary_sha1 = self.dutinformation.build_binary_sha1\n        if not forceflash and self.build.sha1 == cur_binary_sha1:\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets parameters as a tuple.", "response": "def get_params(self):\n        \"\"\"\n        Get parameters as a tuple.\n\n        :return: timeout, xonxoff, rtscts, baudrate\n        \"\"\"\n        return self.timeout, self.xonxoff, self.rtscts, self.baudrate"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_params(self):\n        return self.enabled, self.size, self.chunk_delay, self.start_delay", "response": "Get parameters.\n\n        :return: enabled, size, chunk_delay, start_delay"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nopen a serial port connection.", "response": "def open_connection(self):\n        \"\"\"\n        Open serial port connection.\n\n        :return: Nothing\n        :raises: DutConnectionError if serial port was already open or a SerialException occurs.\n        ValueError if EnhancedSerial __init__ or value setters raise ValueError\n        \"\"\"\n        if self.readthread is not None:\n            raise DutConnectionError(\"Trying to open serial port which was already open\")\n\n        self.logger.info(\"Open Connection \"\n                         \"for '%s' using '%s' baudrate: %d\" % (self.dut_name,\n                                                               self.comport,\n                                                               self.serial_baudrate),\n                         extra={'type': '<->'})\n        if self.serial_xonxoff:\n            self.logger.debug(\"Use software flow control for dut: %s\" % self.dut_name)\n        if self.serial_rtscts:\n            self.logger.debug(\"Use hardware flow control for dut: %s\" % self.dut_name)\n        try:\n            self.port = EnhancedSerial(self.comport)\n            self.port.baudrate = self.serial_baudrate\n            self.port.timeout = self.serial_timeout\n            self.port.xonxoff = self.serial_xonxoff\n            self.port.rtscts = self.serial_rtscts\n            self.port.flushInput()\n            self.port.flushOutput()\n        except SerialException as err:\n            self.logger.warning(err)\n            raise DutConnectionError(str(err))\n        except ValueError as err:\n            self.logger.warning(err)\n            raise ValueError(str(err))\n\n        if self.ch_mode:\n            self.logger.info(\"Use chunk-mode with size %d, delay: %.3f when write data\" %\n                             (self.ch_mode_chunk_size, self.ch_mode_ch_delay),\n                             extra={'type': '<->'})\n            time.sleep(self.ch_mode_start_delay)\n        else:\n            self.logger.info(\"Use normal serial write mode\", extra={'type': '<->'})\n        if self.params.reset:\n            self.reset()\n        # Start the serial reading thread\n        self.readthread = Thread(name=self.name, target=self.run)\n        self.readthread.start()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclose serial port connection.", "response": "def close_connection(self):  # pylint: disable=C0103\n        \"\"\"\n        Closes serial port connection.\n\n        :return: Nothing\n        \"\"\"\n        if self.port:\n            self.stop()\n            self.logger.debug(\"Close port '%s'\" % self.comport,\n                              extra={'type': '<->'})\n            self.port.close()\n            self.port = False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reset(self, method=None):\n        self.logger.info('Reset serial device %s' % self.name)\n        self.__send_break()", "response": "Resets the serial device. Internally calls __send_break()."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend a break to the device.", "response": "def __send_break(self):\n        \"\"\"\n        Sends break to device.\n\n        :return: result of EnhancedSerial safe_sendBreak()\n        \"\"\"\n        if self.port:\n            self.logger.debug(\"sendBreak to device to reboot\", extra={'type': '<->'})\n            result = self.port.safe_sendBreak()\n            time.sleep(1)\n            if result:\n                self.logger.debug(\"reset completed\", extra={'type': '<->'})\n            else:\n                self.logger.warning(\"reset failed\", extra={'type': '<->'})\n            return result\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef writeline(self, data):\n        try:\n            if self.ch_mode:\n                data += \"\\n\"\n                parts = split_by_n(data, self.ch_mode_chunk_size)\n                for split_str in parts:\n                    self.port.write(split_str.encode())\n                    time.sleep(self.ch_mode_ch_delay)\n            else:\n                self.port.write((data + \"\\n\").encode())\n        except SerialException as err:\n            self.logger.exception(\"SerialError occured while trying to write data {}.\".format(data))\n            raise RuntimeError(str(err))", "response": "Writes data to serial port."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread a line from serial port.", "response": "def _readline(self, timeout=1):\n        \"\"\"\n        Read line from serial port.\n\n        :param timeout: timeout, default is 1\n        :return: stripped line or None\n        \"\"\"\n        line = self.port.readline(timeout=timeout)\n        return strip_escape(line.strip()) if line is not None else line"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads lines while keep_reading is True. Calls process_dut for each received line.", "response": "def run(self):\n        \"\"\"\n        Read lines while keep_reading is True. Calls process_dut for each received line.\n\n        :return: Nothing\n        \"\"\"\n        self.keep_reading = True\n        while self.keep_reading:\n            line = self._readline()\n            if line:\n                self.input_queue.appendleft(line)\n                Dut.process_dut(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef stop(self):\n        self.keep_reading = False\n        if self.readthread is not None:\n            self.readthread.join()\n            self.readthread = None", "response": "Stops and joins readthread."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint information nicely formatted into a table.", "response": "def print_info(self):\n        \"\"\"\n        Prints Dut information nicely formatted into a table.\n        \"\"\"\n        table = PrettyTable()\n        start_string = \"DutSerial {} \\n\".format(self.name)\n        row = []\n        info_string = \"\"\n        if self.config:\n            info_string = info_string + \"Configuration for this DUT:\\n\\n {} \\n\".format(self.config)\n        if self.comport:\n            table.add_column(\"COM port\", [])\n            row.append(self.comport)\n        if self.port:\n            if hasattr(self.port, \"baudrate\"):\n                table.add_column(\"Baudrate\", [])\n                row.append(self.port.baudrate)\n            if hasattr(self.port, \"xonxoff\"):\n                table.add_column(\"XON/XOFF\", [])\n                row.append(self.port.xonxoff)\n            if hasattr(self.port, \"timeout\"):\n                table.add_column(\"Timeout\", [])\n                row.append(self.port.timeout)\n            if hasattr(self.port, \"rtscts\"):\n                table.add_column(\"RTSCTS\", [])\n                row.append(self.port.rtscts)\n        if self.location:\n            table.add_column(\"Location\", [])\n            row.append(\"X = {}, Y = {}\".format(self.location.x_coord, self.location.y_coord))\n        self.logger.info(start_string)\n        self.logger.debug(info_string)\n        table.add_row(row)\n        print(table)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_bench_api(self):\n        # Extend bench functionality with these new commands\n        ret_dict = dict()\n        ret_dict[\"assertTraceDoesNotContain\"] = asserts.assertTraceDoesNotContain\n        ret_dict[\"assertTraceContains\"] = asserts.assertTraceContains\n        ret_dict[\"assertDutTraceDoesNotContain\"] = self.assert_dut_trace_not_contains\n        ret_dict[\"assertDutTraceContains\"] = self.assert_dut_trace_contains\n        ret_dict[\"assertTrue\"] = asserts.assertTrue\n        ret_dict[\"assertFalse\"] = asserts.assertFalse\n        ret_dict[\"assertNone\"] = asserts.assertNone\n        ret_dict[\"assertNotNone\"] = asserts.assertNotNone\n        ret_dict[\"assertEqual\"] = asserts.assertEqual\n        ret_dict[\"assertNotEqual\"] = asserts.assertNotEqual\n        ret_dict[\"assertJsonContains\"] = asserts.assertJsonContains\n        return ret_dict", "response": "Returns a dictionary that contains all of the bench API functions that are used to create the log entries for the given log entries."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwraps to provice access to bench for assertDutTraceContains.", "response": "def assert_dut_trace_contains(self, k, message):\n        \"\"\"\n        Wrapper to provice access to bench for assertDutTraceContains.\n        :param k: index of dut\n        :param message: Message that should be in traces\n        :return: Nothing\n        \"\"\"\n        asserts.assertDutTraceContains(k, message, bench=self.bench)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwraps to provice access to bench for assertDutTraceDoesNotContain.", "response": "def assert_dut_trace_not_contains(self, k, message):\n        \"\"\"\n        Wrapper to provice access to bench for assertDutTraceDoesNotContain.\n        :param k: index of dut\n        :param message: Message that should not appear in traces\n        :return: Nothing\n        \"\"\"\n        asserts.assertDutTraceDoesNotContain(k, message, bench=self.bench)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate(self, *args, **kwargs):\n        # Generate TC result table\n        table = PrettyTable(\n            [\"Testcase\", \"Verdict\", \"Fail Reason\", \"Skip Reason\", \"platforms\", \"duration\",\n             \"Retried\"])\n        for result in self.results:\n            table.add_row([\n                result.get_tc_name(),\n                result.get_verdict(),\n                hex_escape_str(result.fail_reason)[:60],\n                str(result.skip_reason) if result.skipped() else \"\",\n                result.get_dut_models(),\n                str(result.duration),\n                \"Yes\" if result.retries_left != 0 else \"No\"\n            ])\n            # Print to console\n        print(table)  # pylint: disable=superfluous-parens\n\n        # Generate Summary table\n        table = PrettyTable(['Summary', ''])\n        final_verdict = \"FAIL\"\n        if self.summary[\"fail\"] == 0 and self.summary[\"inconclusive\"] == 0:\n            final_verdict = \"PASS\"\n        elif self.results.clean_inconcs() and not self.results.clean_fails():\n            final_verdict = \"INCONCLUSIVE\"\n        elif self.summary[\"fail\"] + self.summary[\"inconclusive\"] == self.summary[\"retries\"]:\n            final_verdict = \"PASS\"\n        table.add_row([\"Final Verdict\", final_verdict])\n        table.add_row([\"count\", str(self.summary[\"count\"])])\n\n        table.add_row([\"passrate\", self.results.pass_rate()])\n        table.add_row([\"passrate excluding retries\", self.results.pass_rate(include_retries=False)])\n        if self.summary[\"pass\"] > 0:\n            table.add_row([\"pass\", str(self.summary[\"pass\"])])\n        if self.summary[\"fail\"] > 0:\n            table.add_row([\"fail\", str(self.summary[\"fail\"])])\n        if self.summary[\"skip\"] > 0:\n            table.add_row([\"skip\", str(self.summary[\"skip\"])])\n        if self.summary[\"inconclusive\"] > 0:\n            table.add_row([\"inconclusive\", str(self.summary[\"inconclusive\"])])\n        table.add_row([\"Duration\", self.duration_to_string(self.summary[\"duration\"])])\n        # Print to console\n        print(table)", "response": "Generates and prints a console report of the TC results."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nappends a Data instance to self", "response": "def append(self, data):\n        \"\"\"Append a Data instance to self\"\"\"\n        for k in self._entries.keys():\n            self._entries[k].append(data._entries[k])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef init_group(self, group, chunk_size,\n                   compression=None, compression_opts=None):\n        \"\"\"Initializes a HDF5 group compliant with the stored data.\n\n        This method creates the datasets 'items', 'labels', 'features'\n        and 'index' and leaves them empty.\n\n        :param h5py.Group group: The group to initializes.\n        :param float chunk_size: The size of a chunk in the file (in MB).\n        :param str compression: Optional compression, see\n            :class:`h5features.writer` for details\n        :param str compression: Optional compression options, see\n            :class:`h5features.writer` for details\n\n        \"\"\"\n        create_index(group, chunk_size)\n\n        self._entries['items'].create_dataset(\n            group, chunk_size, compression=compression,\n            compression_opts=compression_opts)\n\n        self._entries['features'].create_dataset(\n            group, chunk_size, compression=compression,\n            compression_opts=compression_opts)\n\n        # chunking the labels depends on features chunks\n        self._entries['labels'].create_dataset(\n            group, self._entries['features'].nb_per_chunk,\n            compression=compression,\n            compression_opts=compression_opts)\n\n        if self.has_properties():\n            self._entries['properties'].create_dataset(\n                group, compression=compression,\n                compression_opts=compression_opts)", "response": "Initializes a HDF5 group compliant with the stored data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if the data can be appended to a given group.", "response": "def is_appendable_to(self, group):\n        \"\"\"Returns True if the data can be appended in a given group.\"\"\"\n        # First check only the names\n        if not all([k in group for k in self._entries.keys()]):\n            return False\n\n        # If names are matching, check the contents\n        for k in self._entries.keys():\n            if not self._entries[k].is_appendable_to(group):\n                return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_to(self, group, append=False):\n        write_index(self, group, append)\n        self._entries['items'].write_to(group)\n        self._entries['features'].write_to(group, append)\n        self._entries['labels'].write_to(group)\n        if self.has_properties():\n            self._entries['properties'].write_to(group, append=append)", "response": "Write the data to the given group."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nraise IOError if labels are not correct", "response": "def check(labels):\n        \"\"\"Raise IOError if labels are not correct\n\n        `labels` must be a list of sorted numpy arrays of equal\n             dimensions (must be 1D or 2D). In the case of 2D labels,\n             the second axis must have the same shape for all labels.\n\n        \"\"\"\n        # type checking\n        if not isinstance(labels, list):\n            raise IOError('labels are not in a list')\n        if not len(labels):\n            raise IOError('the labels list is empty')\n        if not all([isinstance(l, np.ndarray) for l in labels]):\n            raise IOError('all labels must be numpy arrays')\n\n        # dimension checking\n        ndim = labels[0].ndim\n        if ndim not in [1, 2]:\n            raise IOError('labels dimension must be 1 or 2')\n        if not all([l.ndim == ndim for l in labels]):\n            raise IOError('all labels dimensions must be equal')\n        if ndim == 2:\n            shape1 = labels[0].shape[1]\n            if not all([l.shape[1] == shape1 for l in labels]):\n                raise IOError('all labels must have same shape on 2nd dim')\n\n        # sort checking\n        for label in labels:\n            index = (np.argsort(label) if label.ndim == 1\n                     else np.lexsort(label.T))\n            # print label, index\n            # print len(index), label.shape[0]\n            assert len(index) == label.shape[0]\n            if not all(n == index[n] for n in range(label.shape[0]-1)):\n                raise IOError('labels are not sorted in increasing order')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _write(self, item, labels, features):\n        data = Data([item], [labels], [features])\n        self._writer.write(data, self.groupname, append=True)", "response": "Writes the given item to the owned file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts an input file to h5features based on its extension.", "response": "def convert(self, infile, item=None):\n        \"\"\"Convert an input file to h5features based on its extension.\n\n        :raise IOError: if `infile` is not a valid file.\n        :raise IOError: if `infile` extension is not supported.\n\n        \"\"\"\n        if not os.path.isfile(infile):\n            raise IOError('{} is not a valid file'.format(infile))\n\n        if item is None:\n            item = os.path.splitext(infile)[0]\n\n        ext = os.path.splitext(infile)[1]\n        if ext == '.npz':\n            self.npz_convert(infile, item)\n        elif ext == '.mat':\n            self.mat_convert(infile, item)\n        elif ext == '.h5':\n            self.h5features_convert(infile)\n        else:\n            raise IOError('Unknown file format for {}'.format(infile))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef npz_convert(self, infile, item):\n        data = np.load(infile)\n        labels = self._labels(data)\n        features = data['features']\n        self._write(item, labels, features)", "response": "Convert a numpy NPZ file to h5features."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mat_convert(self, infile, item):\n        data = sio.loadmat(infile)\n        labels = self._labels(data)\n        features = data['features']\n        self._write(item, labels, features)", "response": "Convert a Octave / Matlab file to h5features."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef h5features_convert(self, infile):\n        with h5py.File(infile, 'r') as f:\n            groups = list(f.keys())\n        for group in groups:\n            self._writer.write(\n                Reader(infile, group).read(),\n                self.groupname, append=True)", "response": "Convert a h5features file to the latest h5features version."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread in a h5features file.", "response": "def read(filename, groupname=None, from_item=None, to_item=None,\n         from_time=None, to_time=None, index=None):\n    \"\"\"Reads in a h5features file.\n\n    :param str filename: Path to a hdf5 file potentially serving as a\n        container for many small files\n\n    :param str groupname: HDF5 group to read the data from. If None,\n        guess there is one and only one group in `filename`.\n\n    :param str from_item: Optional. Read the data starting from this\n        item. (defaults to the first stored item)\n\n    :param str to_item: Optional. Read the data until reaching the\n        item. (defaults to from_item if it was specified and to the\n        last stored item otherwise)\n\n    :param float from_time: Optional. (defaults to the beginning time\n        in from_item) the specified times are included in the output\n\n    :param float to_time: Optional. (defaults to the ending time in\n        to_item) the specified times are included in the output\n\n    :param int index: Not implemented, raise if used.\n\n    :return: A tuple (times, features) or (times, features,\n        properties) such as:\n\n        * time is a dictionary of 1D arrays values (keys are items).\n\n        * features: A dictionary of 2D arrays values (keys are items)\n          with the 'features' dimension along the columns and the\n          'time' dimension along the lines.\n\n        * properties: A dictionnary of dictionnaries (keys are items)\n          with the corresponding properties. If there is no properties\n          recorded, this value is not returned.\n\n    .. note:: Note that all the files that are present on disk between\n        to_item and from_item will be loaded and returned. It's the\n        responsibility of the user to make sure that it will fit into\n        RAM memory.\n\n    \"\"\"\n    # TODO legacy read from index not implemented\n    if index is not None:\n        raise NotImplementedError\n\n    reader = Reader(filename, groupname)\n    data = (reader.read(from_item, to_item, from_time, to_time)\n            if index is None else reader.index_read(index))\n    if data.has_properties():\n        return data.dict_labels(), data.dict_features(), data.dict_properties()\n    else:\n        return data.dict_labels(), data.dict_features()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite h5features data in a HDF5 file. This function is a wrapper to the Writer class. It has three purposes: * Check parameters for errors (see details below), * Create Items, Times and Features objects * Send them to the Writer. :param str filename: HDF5 file to be writted, potentially serving as a container for many small files. If the file does not exist, it is created. If the file is already a valid HDF5 file, try to append the data in it. :param str groupname: Name of the group to write the data in, or to append the data to if the group already exists in the file. :param items: List of files from which the features where extracted. Items must not contain duplicates. :type items: list of str :param times: Time value for the features array. Elements of a 1D array are considered as the center of the time window associated with the features. A 2D array must have 2 columns corresponding to the begin and end timestamps of the features time window. :type times: list of 1D or 2D numpy arrays :param features: Features should have time along the lines and features along the columns (accomodating row-major storage in hdf5 files). :type features: list of 2D numpy arrays :param properties: Optional. Properties associated with each item. Properties describe the features associated with each item in a dictionnary. It can store parameters or fields recorded by the user. :type properties: list of dictionnaries :param str dformat: Optional. Which format to store the features into (sparse or dense). Default is dense. :param float chunk_size: Optional. In Mo, tuning parameter corresponding to the size of a chunk in the h5file. By default the chunk size is guessed automatically. Tis parameter is ignored if the file already exists. :param float sparsity: Optional. Tuning parameter corresponding to the expected proportion (in [0, 1]) of non-zeros elements on average in a single frame. :param char mode: Optional. The mode for overwriting an existing file, 'a' to append data to the file, 'w' to overwrite it :raise IOError: if the filename is not valid or parameters are inconsistent. :raise NotImplementedError: if dformat == 'sparse'", "response": "def write(filename, groupname, items, times, features, properties=None,\n          dformat='dense', chunk_size='auto', sparsity=0.1, mode='a'):\n    \"\"\"Write h5features data in a HDF5 file.\n\n    This function is a wrapper to the Writer class. It has three purposes:\n\n    * Check parameters for errors (see details below),\n    * Create Items, Times and Features objects\n    * Send them to the Writer.\n\n    :param str filename: HDF5 file to be writted, potentially serving\n        as a container for many small files. If the file does not\n        exist, it is created. If the file is already a valid HDF5\n        file, try to append the data in it.\n\n    :param str groupname: Name of the group to write the data in, or\n        to append the data to if the group already exists in the file.\n\n    :param items: List of files from which the features where\n        extracted. Items must not contain duplicates.\n    :type items: list of str\n\n    :param times: Time value for the features array. Elements of\n        a 1D array are considered as the center of the time window\n        associated with the features. A 2D array must have 2 columns\n        corresponding to the begin and end timestamps of the features\n        time window.\n    :type times: list of  1D or 2D numpy arrays\n\n    :param features: Features should have\n        time along the lines and features along the columns\n        (accomodating row-major storage in hdf5 files).\n    :type features: list of 2D numpy arrays\n\n    :param properties: Optional. Properties associated with each\n        item. Properties describe the features associated with each\n        item in a dictionnary. It can store parameters or fields\n        recorded by the user.\n    :type properties: list of dictionnaries\n\n    :param str dformat: Optional. Which format to store the features\n        into (sparse or dense). Default is dense.\n\n    :param float chunk_size: Optional. In Mo, tuning parameter\n        corresponding to the size of a chunk in the h5file. By default\n        the chunk size is guessed automatically. Tis parameter is\n        ignored if the file already exists.\n\n    :param float sparsity: Optional. Tuning parameter corresponding to\n        the expected proportion (in [0, 1]) of non-zeros elements on\n        average in a single frame.\n\n    :param char mode: Optional. The mode for overwriting an existing\n        file, 'a' to append data to the file, 'w' to overwrite it\n\n    :raise IOError: if the filename is not valid or parameters are\n        inconsistent.\n\n    :raise NotImplementedError: if dformat == 'sparse'\n\n    \"\"\"\n    # Prepare the data, raise on error\n    sparsity = sparsity if dformat == 'sparse' else None\n    data = Data(items, times, features, properties=properties,\n                sparsity=sparsity, check=True)\n\n    # Write all that stuff in the HDF5 file's specified group\n    Writer(filename, chunk_size=chunk_size).write(data, groupname, append=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsimplifies version of write when there is only one item.", "response": "def simple_write(filename, group, times, features,\n                 properties=None, item='item', mode='a'):\n    \"\"\"Simplified version of `write()` when there is only one item.\"\"\"\n    write(filename, group, [item], [times], [features], mode=mode,\n          properties=[properties] if properties is not None else None)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef contains_empty(features):\n    if not features:\n        return True\n    for feature in features:\n        if feature.shape[0] == 0:\n            return True\n    return False", "response": "Check if the features data is not empty."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning dformat or raise IOError if it is not dense or sparse", "response": "def parse_dformat(dformat, check=True):\n    \"\"\"Return `dformat` or raise if it is not 'dense' or 'sparse'\"\"\"\n    if check and dformat not in ['dense', 'sparse']:\n        raise IOError(\n            \"{} is a bad features format, please choose 'dense' or 'sparse'\"\n            .format(dformat))\n    return dformat"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the features scalar type.", "response": "def parse_dtype(features, check=True):\n    \"\"\"Return the features scalar type, raise if error\n\n    Raise IOError if all features have not the same data type.\n    Return dtype, the features scalar type.\n\n    \"\"\"\n    dtype = features[0].dtype\n    if check:\n        types = [x.dtype for x in features]\n        if not all([t == dtype for t in types]):\n            raise IOError('features must be homogeneous')\n    return dtype"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns True if features are appendable to a HDF5 group", "response": "def is_appendable_to(self, group):\n        \"\"\"Return True if features are appendable to a HDF5 group\"\"\"\n        return (group.attrs['format'] == self.dformat and\n                group[self.name].dtype == self.dtype and\n                # We use a method because dim differs in dense and sparse.\n                self._group_dim(group) == self.dim)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the features subgoup", "response": "def create_dataset(\n            self, group, chunk_size, compression=None, compression_opts=None):\n        \"\"\"Initialize the features subgoup\"\"\"\n        group.attrs['format'] = self.dformat\n        super(Features, self)._create_dataset(\n            group, chunk_size, compression, compression_opts)\n\n        # TODO attribute declared outside __init__ is not safe. Used\n        # because Labels.create_dataset need it.\n        if chunk_size != 'auto':\n            self.nb_per_chunk = nb_per_chunk(\n                self.dtype.itemsize, self.dim, chunk_size)\n        else:\n            self.nb_per_chunk = 'auto'"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_to(self, group, append=False):\n        if self.sparsetodense:\n            self.data = [x.todense() if sp.issparse(x) else x\n                         for x in self.data]\n\n        nframes = sum([d.shape[0] for d in self.data])\n        dim = self._group_dim(group)\n        feats = np.concatenate(self.data, axis=0)\n\n        if append:\n            nframes_group = group[self.name].shape[0]\n            group[self.name].resize(nframes_group + nframes, axis=0)\n            if dim == 1:\n                group[self.name][nframes_group:] = feats\n            else:\n                group[self.name][nframes_group:, :] = feats\n        else:\n            group[self.name].resize(nframes, axis=0)\n            group[self.name][...] = feats if dim == 1 else feats", "response": "Write stored features to a given group."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing sparse specific datasets for the current object.", "response": "def create_dataset(self, group, chunk_size):\n        \"\"\"Initializes sparse specific datasets\"\"\"\n        group.attrs['format'] = self.dformat\n        group.attrs['dim'] = self.dim\n\n        if chunk_size == 'auto':\n            group.create_dataset(\n                'coordinates', (0, 2), dtype=np.float64,\n                chunks=True, maxshape=(None, 2))\n\n            group.create_dataset(\n                self.name, (0,), dtype=self.dtype,\n                chunks=True, maxshape=(None,))\n\n        else:\n            # for storing sparse data we don't use the self.nb_per_chunk,\n            # which is only used by the Writer to determine times chunking.\n            per_chunk = nb_per_chunk(self.dtype.itemsize, 1, chunk_size)\n\n            group.create_dataset(\n                'coordinates', (0, 2), dtype=np.float64,\n                chunks=(per_chunk, 2), maxshape=(None, 2))\n\n            group.create_dataset(\n                self.name, (0,), dtype=self.dtype,\n                chunks=(per_chunk,), maxshape=(None,))\n\n        dtype = np.int64\n        if chunk_size == 'auto':\n            chunks = True\n            self.nb_per_chunk = 'auto'\n        else:\n            chunks = (nb_per_chunk(np.dtype(dtype).itemsize, 1, chunk_size),)\n            # Needed by Times.create_dataset\n            self.nb_per_chunk = nb_per_chunk(\n                self.dtype.itemsize,\n                int(round(self.sparsity*self.dim)),\n                chunk_size)\n\n        group.create_dataset(\n            'frames', (0,), dtype=dtype,\n            chunks=chunks, maxshape=(None,))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns properties loaded from a group", "response": "def read_properties(group):\n    \"\"\"Returns properties loaded from a group\"\"\"\n    if 'properties' not in group:\n        raise IOError('no properties in group')\n\n    data = group['properties'][...][0].replace(b'__NULL__', b'\\x00')\n    return pickle.loads(data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn True if d1 == d2 False otherwise", "response": "def _eq_dicts(d1, d2):\n        \"\"\"Returns True if d1 == d2, False otherwise\"\"\"\n        if not d1.keys() == d2.keys():\n            return False\n\n        for k, v1 in d1.items():\n            v2 = d2[k]\n            if not type(v1) == type(v2):\n                return False\n            if isinstance(v1, np.ndarray):\n                if not np.array_equal(v1, v2):\n                    return False\n            else:\n                if not v1 == v2:\n                    return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites the properties to a group or appends it", "response": "def write_to(self, group, append=False):\n        \"\"\"Writes the properties to a `group`, or append it\"\"\"\n        data = self.data\n        if append is True:\n            try:\n                # concatenate original and new properties in a single list\n                original = read_properties(group)\n                data = original + data\n            except EOFError:\n                pass  # no former data to append on\n\n        # h5py does not support embedded NULLs in strings ('\\x00')\n        data = pickle.dumps(data).replace(b'\\x00', b'__NULL__')\n        group['properties'][...] = np.void(data)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_data(nitem, nfeat=2, dim=10, labeldim=1, base='item'):\n    import numpy as np\n\n    # A list of item names\n    items = [base + '_' + str(i) for i in range(nitem)]\n\n    # A list of features arrays\n    features = [np.random.randn(nfeat, dim) for _ in range(nitem)]\n\n    # A list on 1D or 2D times arrays\n    if labeldim == 1:\n        labels = [np.linspace(0, 1, nfeat)] * nitem\n    else:\n        t = np.linspace(0, 1, nfeat)\n        labels = [np.array([t+i for i in range(labeldim)])] * nitem\n\n    # Format data as required by the writer\n    return h5f.Data(items, labels, features, check=True)", "response": "Generates a randomly generated dataset."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates an empty index dataset in the given group.", "response": "def create_index(group, chunk_size, compression=None, compression_opts=None):\n    \"\"\"Create an empty index dataset in the given group.\"\"\"\n    dtype = np.int64\n    if chunk_size == 'auto':\n        chunks = True\n    else:\n        chunks = (nb_per_chunk(np.dtype(dtype).itemsize, 1, chunk_size),)\n\n    group.create_dataset(\n        'index', (0,), dtype=dtype,\n        chunks=chunks, maxshape=(None,),\n        compression=compression, compression_opts=compression_opts)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write_index(data, group, append):\n    # build the index from data\n    nitems = group['items'].shape[0] if 'items' in group else 0\n    last_index = group['index'][-1] if nitems > 0 else -1\n    index = last_index + cumindex(data._entries['features'])\n\n    if append:\n        nidx = group['index'].shape[0]\n        # # in case we append to the end of an existing item\n        # if data._entries['items']._continue_last_item(group):\n        #     nidx -= 1\n\n        group['index'].resize((nidx + index.shape[0],))\n        group['index'][nidx:] = index\n    else:\n        group['index'].resize((index.shape[0],))\n        group['index'][...] = index", "response": "Write the data index to the given group."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the index stored in a h5features group.", "response": "def read_index(group, version='1.1'):\n    \"\"\"Return the index stored in a h5features group.\n\n    :param h5py.Group group: The group to read the index from.\n    :param str version: The h5features version of the `group`.\n    :return: a 1D numpy array of features indices.\n    \"\"\"\n    if version == '0.1':\n        return np.int64(group['index'][...])\n    elif version == '1.0':\n        return group['file_index'][...]\n    else:\n        return group['index'][...]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_args():\n    parser = argparse.ArgumentParser(\n        description='''Convert a set of files to a single h5features file, input files\n        can be npz (numpy) or mat (MATLAB) files.''')\n\n    parser.add_argument('file', nargs='+', type=str,\n                        help='File to convert in the h5features format')\n\n    parser.add_argument('-o', '--output', default='features.h5', type=str,\n                        help='''The output h5features file to write on\n                        (default is %(default)s)''')\n\n    parser.add_argument('-g', '--group', default='h5features', type=str,\n                        help='''The group to write in the output file\n                        (default is %(default)s)''')\n\n    parser.add_argument('--chunk', default=0.1, type=float,\n                        help='''size of a file chunk in MB\n                        (default is %(default)s)''')\n\n    return parser.parse_args()", "response": "Define and parse command line arguments"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main():\n    args = parse_args()\n    converter = h5f.Converter(args.output, args.group, args.chunk)\n    for infile in args.file:\n        converter.convert(infile)", "response": "The main function of the converter command - line tool convert2h5features"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nb_per_chunk(item_size, item_dim, chunk_size):\n    # from Mbytes to bytes\n    size = chunk_size * 10.**6\n    ratio = int(round(size / (item_size*item_dim)))\n    return max(10, ratio)", "response": "Return the number of items that can be stored in one chunk."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_appendable(self, entry):\n        try:\n            if (\n                    self.name == entry.name and\n                    self.dtype == entry.dtype and\n                    self.dim == entry.dim\n            ):\n                return True\n        except AttributeError:\n            return False\n        return False", "response": "Return True if entry can be appended to self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nappending an entry to the end of the list", "response": "def append(self, entry):\n        \"\"\"Append an entry to self\"\"\"\n        if not self.is_appendable(entry):\n            raise ValueError('entry not appendable')\n        self.data += entry.data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite the data in a specified group of the file.", "response": "def write(self, data, groupname='h5features', append=False):\n        \"\"\"Write h5features data in a specified group of the file.\n\n        :param dict data: A `h5features.Data` instance to be writed on disk.\n\n        :param str groupname: Optional. The name of the group in which\n            to write the data.\n\n        :param bool append: Optional. This parameter has no effect if\n           the `groupname` is not an existing group in the file. If\n           set to True, try to append new data in the group. If False\n           (default) erase all data in the group before writing.\n\n        :raise IOError: if append requested but not possible.\n\n        \"\"\"\n        if append and groupname in self.h5file:\n            # append data to the group, raise if we cannot\n            group = self.h5file[groupname]\n            if not is_same_version(self.version, group):\n                raise IOError(\n                    'data is not appendable to the group {}: '\n                    'versions are different'.format(group.name))\n\n            if not data.is_appendable_to(group):\n                raise IOError(\n                    'data is not appendable to the group {}'\n                    .format(group.name))\n        else:  # overwrite any existing data in group\n            group = self._prepare(data, groupname)\n\n        data.write_to(group, append)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing the group if existing and initialize empty datasets.", "response": "def _prepare(self, data, groupname):\n        \"\"\"Clear the group if existing and initialize empty datasets.\"\"\"\n        if groupname in self.h5file:\n            del self.h5file[groupname]\n        group = self.h5file.create_group(groupname)\n        group.attrs['version'] = self.version\n        data.init_group(\n            group, self.chunk_size, self.compression, self.compression_opts)\n        return group"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_items(group, version='1.1', check=False):\n    if version == '0.1':\n        # parse unicode to strings\n        return ''.join(\n            [unichr(int(c)) for c in group['files'][...]]\n        ).replace('/-', '/').split('/\\\\')\n    elif version == '1.0':\n        return Items(list(group['files'][...]), check)\n    else:\n        return Items(list(group['items'][...]), check)", "response": "Return an Items instance initialized from a h5features group."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite stored items to the given HDF5 group.", "response": "def write_to(self, group):\n        \"\"\"Write stored items to the given HDF5 group.\n\n        We assume that self.create() has been called.\n\n        \"\"\"\n        # The HDF5 group where to write data\n        items_group = group[self.name]\n\n        nitems = items_group.shape[0]\n        items_group.resize((nitems + len(self.data),))\n        items_group[nitems:] = self.data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning False if lower and upper are not a valid subitems interval.", "response": "def is_valid_interval(self, lower, upper):\n        \"\"\"Return False if [lower:upper] is not a valid subitems interval. If\n        it is, then returns a tuple of (lower index, upper index)\"\"\"\n        try:\n            lower_idx = self.data.index(lower)\n            upper_idx = self.data.index(upper)\n            return (lower_idx, upper_idx) if lower_idx <= upper_idx else False\n        except ValueError:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _create_dataset(\n            self, group, chunk_size, compression, compression_opts):\n        \"\"\"Create an empty dataset in a group.\"\"\"\n        if chunk_size == 'auto':\n            chunks = True\n        else:\n            # if dtype is a variable str, guess representative size is 20 bytes\n            per_chunk = (\n                nb_per_chunk(20, 1, chunk_size) if self.dtype == np.dtype('O')\n                else nb_per_chunk(\n                        np.dtype(self.dtype).itemsize, 1, chunk_size))\n            chunks = (per_chunk,)\n\n        shape = (0,)\n        maxshape = (None,)\n\n        # raise if per_chunk >= 4 Gb, this is requested by h5py\n        group.create_dataset(\n            self.name, shape, dtype=self.dtype,\n            chunks=chunks, maxshape=maxshape, compression=compression,\n            compression_opts=compression_opts)", "response": "Create an empty dataset in a group."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the h5features version of a given HDF5 group.", "response": "def read_version(group):\n    \"\"\"Return the h5features version of a given HDF5 `group`.\n\n    Look for a 'version' attribute in the `group` and return its\n    value. Return '0.1' if the version is not found. Raises an IOError\n    if it is not supported.\n\n    \"\"\"\n    version = ('0.1' if 'version' not in group.attrs\n               else group.attrs['version'])\n\n    # decode from bytes to str if needed\n    if isinstance(version, bytes):\n        version = version.decode()\n\n    if not is_supported_version(version):\n        raise IOError('version {} is not supported'.format(version))\n\n    return version"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read(self, from_item=None, to_item=None,\n             from_time=None, to_time=None):\n        \"\"\"Retrieve requested data coordinates from the h5features index.\n\n        :param str from_item: Optional. Read the data starting from\n            this item. (defaults to the first stored item)\n\n        :param str to_item: Optional. Read the data until reaching the\n            item. (defaults to from_item if it was specified and to\n            the last stored item otherwise).\n\n        :param float from_time: Optional. (defaults to the beginning\n            time in from_item) The specified times are included in the\n            output.\n\n        :param float to_time: Optional. (defaults to the ending time\n            in to_item) the specified times are included in the\n            output.\n\n        :return: An instance of h5features.Data read from the file.\n\n        \"\"\"\n        # handling default arguments\n        if to_item is None:\n            to_item = self.items.data[-1] if from_item is None else from_item\n        if from_item is None:\n            from_item = self.items.data[0]\n\n        # index coordinates of from/to_item. TODO optimize because we\n        # have 4 accesses to list.index() where 2 are enougth.\n        if not self.items.is_valid_interval(from_item, to_item):\n            raise IOError('cannot read items: not a valid interval')\n        from_idx = self.items.data.index(from_item)\n        to_idx = self.items.data.index(to_item)\n\n        from_pos = self._get_item_position(from_idx)\n        to_pos = self._get_item_position(to_idx)\n\n        lower = self._get_from_time(from_time, from_pos)\n        # upper included with +1\n        upper = self._get_to_time(to_time, to_pos) + 1\n\n        # Step 2: access actual data\n        if self.dformat == 'sparse':\n            raise NotImplementedError(\n                'Reading sparse features not implemented')\n        else:\n            features = (self.group['features'][:, lower:upper].T\n                        if self.version == '0.1'\n                        else self.group['features'][lower:upper, ...])\n            labels = self._labels_group[lower:upper]\n\n        # If we read a single item\n        if to_idx == from_idx:\n            features = [features]\n            labels = [labels]\n        # Several items case: split them from the index\n        else:\n            item_ends = self._index[from_idx:to_idx] - from_pos[0] + 1\n            features = np.split(features, item_ends, axis=0)\n            labels = np.split(labels, item_ends, axis=0)\n\n        items = self.items.data[from_idx:to_idx + 1]\n        if self.properties is None:\n            properties = None\n        else:\n            properties = self.properties[from_idx:to_idx + 1]\n\n        return Data(\n            items, labels, features, properties=properties, check=False)", "response": "Read the data from the index."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a tuple of start end indices of an item from its index.", "response": "def _get_item_position(self, idx):\n        \"\"\"Return a tuple of (start, end) indices of an item from its index.\"\"\"\n        start = 0 if idx == 0 else self._index[idx - 1] + 1\n        end = self._index[idx]\n        return start, end"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef writesgf(self, sgffilename):\n        \"Write the game to an SGF file after a game\"\n\n        size = self.size\n        outfile = open(sgffilename, \"w\")\n        if not outfile:\n            print \"Couldn't create \" + sgffilename\n            return\n        black_name = self.blackplayer.get_program_name()\n        white_name = self.whiteplayer.get_program_name()\n        black_seed = self.blackplayer.get_random_seed()\n        white_seed = self.whiteplayer.get_random_seed()\n        handicap = self.handicap\n        komi     = self.komi\n        result   = self.resultw\n\n        outfile.write(\"(;GM[1]FF[4]RU[Japanese]SZ[%s]HA[%s]KM[%s]RE[%s]\\n\" %\n                      (size, handicap, komi, result))\n        outfile.write(\"PW[%s (random seed %s)]PB[%s (random seed %s)]\\n\" %\n                      (white_name, white_seed, black_name, black_seed))\n        outfile.write(self.sgffilestart)\n\n        if handicap > 1:\n            outfile.write(\"AB\");\n            for stone in self.handicap_stones:\n                outfile.write(\"[%s]\" %(coords_to_sgf(size, stone)))\n            outfile.write(\"PL[W]\\n\")\n\n        to_play = self.first_to_play\n\n        for move in self.moves:\n            sgfmove = coords_to_sgf(size, move)\n            outfile.write(\";%s[%s]\\n\" % (to_play, sgfmove))\n            if to_play == \"B\":\n                to_play = \"W\"\n            else:\n                to_play = \"B\"\n        outfile.write(\")\\n\")\n        outfile.close", "response": "Write the game to an SGF file after a game"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsort 'self.data' in-place. Argument: - func : optional, default 'None' -- - If 'func' not given, sorting will be in ascending order. - If 'func' given, it will determine the sort order. 'func' must be a two-argument comparison function which returns -1, 0, or 1, to mean before, same, or after ordering.", "response": "def sort(self, func=None):\n\t\t\"\"\"\n\t\tSorts 'self.data' in-place. Argument:\n\t\t- func : optional, default 'None' --\n\t\t\t- If 'func' not given, sorting will be in ascending\n\t\t\t  order.\n\t\t\t- If 'func' given, it will determine the sort order.\n\t\t\t  'func' must be a two-argument comparison function\n\t\t\t  which returns -1, 0, or 1, to mean before, same,\n\t\t\t  or after ordering.\"\"\"\n \t\tif func:\n\t\t\tself.data.sort(func)\n\t\telse:\n\t\t\tself.data.sort()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _escapeText(text):\n\toutput = \"\"\n\tindex = 0\n\tmatch = reCharsToEscape.search(text, index)\n\twhile match:\n\t\toutput = output + text[index:match.start()] + '\\\\' + text[match.start()]\n\t\tindex = match.end()\n\t\tmatch = reCharsToEscape.search(text, index)\n\toutput = output + text[index:]\n\treturn output", "response": "Adds backslash - escapes to property value characters that need them."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse(self):\n\t\tc = Collection()\n\t\twhile self.index < self.datalen:\n\t\t\tg = self.parseOneGame()\n\t\t\tif g:\n\t\t\t\tc.append(g)\n\t\t\telse:\n\t\t\t\tbreak\n\t\treturn c", "response": "Parses the SGF data stored in self. data and returns a Collection object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parseOneGame(self):\n\t\tif self.index < self.datalen:\n\t\t\tmatch = self.reGameTreeStart.match(self.data, self.index)\n\t\t\tif match:\n\t\t\t\tself.index = match.end()\n\t\t\t\treturn self.parseGameTree()\n\t\treturn None", "response": "Parses one game from self. data. Returns a GameTree containing the game and None if the end of self. data is reached. Returns None if the end of self. data is reached."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall when an optional variation is encountered inside a GameTree. Returns a list of variation GameTree s. Raises EndOfDataParseError if the end of the GameTree is reached before the end of the GameTree.", "response": "def parseVariations(self):\n\t\t\"\"\" Called when \"(\" encountered inside a 'GameTree', ends when a\n\t\t\tnon-matching \")\" encountered. Returns a list of variation\n\t\t\t'GameTree''s. Raises 'EndOfDataParseError' if the end of 'self.data'\n\t\t\tis reached before the end of the enclosing 'GameTree'.\"\"\"\n\t\tv = []\n\t\twhile self.index < self.datalen:\n\t\t\t# check for \")\" at end of GameTree, but don't consume it\n\t\t\tmatch = self.reGameTreeEnd.match(self.data, self.index)\n\t\t\tif match:\n\t\t\t\treturn v\n\t\t\tg = self.parseGameTree()\n\t\t\tif g:\n\t\t\t\tv.append(g)\n\t\t\t# check for next variation, and consume \"(\"\n\t\t\tmatch = self.reGameTreeStart.match(self.data, self.index)\n\t\t\tif match:\n\t\t\t\tself.index = match.end()\n\t\traise EndOfDataParseError"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a property value. Returns a list of property values. Raises PropertyValueParseError if there is a property value parse error.", "response": "def parsePropertyValue(self):\n\t\t\"\"\" Called when \"[\" encountered (but not consumed), ends when the next\n\t\t\tproperty, node, or variation encountered. Parses and returns a list\n\t\t\tof property values. Raises 'PropertyValueParseError' if there is a\n\t\t\tproblem.\"\"\"\n\t\tpvlist = []\n\t\twhile self.index < self.datalen:\n\t\t\tmatch = self.rePropertyStart.match(self.data, self.index)\n\t\t\tif match:\n\t\t\t\tself.index = match.end()\n\t\t\t\tv = \"\"\t\t\t\t\t\t\t\t\t# value\n\t\t\t\t# scan for escaped characters (using '\\'), unescape them (remove linebreaks)\n\t\t\t\tmend = self.rePropertyEnd.search(self.data, self.index)\n\t\t\t\tmesc = self.reEscape.search(self.data, self.index)\n\t\t\t\twhile mesc and mend and (mesc.end() < mend.end()):\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t# copy up to '\\', but remove '\\'\n\t\t\t\t\tv = v + self.data[self.index:mesc.start()]\n\t\t\t\t\tmbreak = self.reLineBreak.match(self.data, mesc.end())\n\t\t\t\t\tif mbreak:\n\t\t\t\t\t\tself.index = mbreak.end()\t\t# remove linebreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tv = v + self.data[mesc.end()]\t# copy escaped character\n\t\t\t\t\t\tself.index = mesc.end() + 1\t\t# move to point after escaped char\n\t\t\t\t\tmend = self.rePropertyEnd.search(self.data, self.index)\n\t\t\t\t\tmesc = self.reEscape.search(self.data, self.index)\n\t\t\t\tif mend:\n\t\t\t\t\tv = v + self.data[self.index:mend.start()]\n\t\t\t\t\tself.index = mend.end()\n\t\t\t\t\tpvlist.append(self._convertControlChars(v))\n\t\t\t\telse:\n\t\t\t\t\traise PropertyValueParseError\n\t\t\telse:\t\t\t\t\t\t\t\t\t\t# reached end of Property\n\t\t\t\tbreak\n\t\tif len(pvlist) >= 1:\n\t\t\treturn pvlist\n\t\telse:\n\t\t\traise PropertyValueParseError"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall SGFParser. parseNode and returns the single Node parsed", "response": "def parseNode(self):\n\t\t\"\"\" Calls 'SGFParser.parseNode()', sets 'self.index' to point to the end\n\t\t\tof the data (effectively ending the 'GameTree' and 'Collection'),\n\t\t\tand returns the single (root) 'Node' parsed.\"\"\"\n\t\tn = SGFParser.parseNode(self)\t\t\t# process one Node as usual\n\t\tself.index = self.datalen\t\t\t\t# set end of data\n\t\treturn n"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mainline(self):\n\t\tif self.variations:\n\t\t\treturn GameTree(self.data + self.variations[0].mainline())\n\t\telse:\n\t\t\treturn self", "response": "Returns the main line of the game as a GameTree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef propertySearch(self, pid, getall=0):\n\t\tmatches = []\n\t\tfor n in self:\n\t\t\tif n.has_key(pid):\n\t\t\t\tmatches.append(n)\n\t\t\t\tif not getall:\n\t\t\t\t\tbreak\n\t\telse:\t# getall or not matches:\n\t\t\tfor v in self.variations:\n\t\t\t\tmatches = matches + v.propertySearch(pid, getall)\n\t\t\t\tif not getall and matches:\n\t\t\t\t\tbreak\n\t\treturn GameTree(matches)", "response": "This method searches this GameTree for nodes containing matching properties."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addProperty(self, property):\n\t\tif self.has_key(property.id):\n\t\t\traise DuplicatePropertyError\n\t\telse:\n\t\t\tself.data[property.id] = property\n\t\t\tself.order.append(property)", "response": "Adds a property to this node."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reset(self):\n\t\tself.gametree = self.game\n\t\tself.nodenum = 0\n\t\tself.index = 0\n\t\tself.stack = []\n\t\tself.node = self.gametree[self.index]\n\t\tself._setChildren()\n\t\tself._setFlags()", "response": "Reset the cursor to the start of the root GameTree."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmoves the Cursor to & returns the previous Node. Raises a GameTreeEndError if the start of a branch is exceeded. Raises a GameTreeEndError if the start of a branch is exceeded.", "response": "def previous(self):\n\t\t\"\"\" Moves the 'Cursor' to & returns the previous 'Node'. Raises\n\t\t\t'GameTreeEndError' if the start of a branch is exceeded.\"\"\"\n\t\tif self.index - 1 >= 0:\t\t\t\t\t# more main line?\n\t\t\tself.index = self.index - 1\n\t\telif self.stack:\t\t\t\t\t\t# were we in a variation?\n\t\t\tself.gametree = self.stack.pop()\n\t\t\tself.index = len(self.gametree) - 1\n\t\telse:\n\t\t\traise GameTreeEndError\n\t\tself.node = self.gametree[self.index]\n\t\tself.nodenum = self.nodenum - 1\n\t\tself._setChildren()\n\t\tself._setFlags()\n\t\treturn self.node"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _setChildren(self):\n\t\tif self.index + 1 < len(self.gametree):\n\t\t\tself.children = [self.gametree[self.index+1]]\n\t\telse:\n\t\t\tself.children = map(lambda list: list[0], self.gametree.variations)", "response": "Sets up self. children."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _setFlags(self):\n\t\tself.atEnd = not self.gametree.variations and (self.index + 1 == len(self.gametree))\n\t\tself.atStart = not self.stack and (self.index == 0)", "response": "Sets up the flags self. atEnd and self. atStart."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning symbolic logic for an N - bit ripple carry adder.", "response": "def ripple_carry_add(A, B, cin=0):\n    \"\"\"Return symbolic logic for an N-bit ripple carry adder.\"\"\"\n    if len(A) != len(B):\n        raise ValueError(\"expected A and B to be equal length\")\n    ss, cs = list(), list()\n    for i, a in enumerate(A):\n        c = (cin if i == 0 else cs[i-1])\n        ss.append(a ^ B[i] ^ c)\n        cs.append(a & B[i] | a & c | B[i] & c)\n    return farray(ss), farray(cs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef kogge_stone_add(A, B, cin=0):\n    if len(A) != len(B):\n        raise ValueError(\"expected A and B to be equal length\")\n    N = len(A)\n    # generate/propagate logic\n    gs = [A[i] & B[i] for i in range(N)]\n    ps = [A[i] ^ B[i] for i in range(N)]\n    for i in range(clog2(N)):\n        start = 1 << i\n        for j in range(start, N):\n            gs[j] = gs[j] | ps[j] & gs[j-start]\n            ps[j] = ps[j] & ps[j-start]\n    # sum logic\n    ss = [A[0] ^ B[0] ^ cin]\n    ss += [A[i] ^ B[i] ^ gs[i-1] for i in range(1, N)]\n    return farray(ss), farray(gs)", "response": "Return symbolic logic for an N - bit Kogge - Stone adder."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef brent_kung_add(A, B, cin=0):\n    if len(A) != len(B):\n        raise ValueError(\"expected A and B to be equal length\")\n    N = len(A)\n    # generate/propagate logic\n    gs = [A[i] & B[i] for i in range(N)]\n    ps = [A[i] ^ B[i] for i in range(N)]\n    # carry tree\n    for i in range(floor(log(N, 2))):\n        step = 2**i\n        for start in range(2**(i+1)-1, N, 2**(i+1)):\n            gs[start] = gs[start] | ps[start] & gs[start-step]\n            ps[start] = ps[start] & ps[start-step]\n    # inverse carry tree\n    for i in range(floor(log(N, 2))-2, -1, -1):\n        start = 2**(i+1)-1\n        step = 2**i\n        while start + step < N:\n            gs[start+step] = gs[start+step] | ps[start+step] & gs[start]\n            ps[start+step] = ps[start+step] & ps[start]\n            start += step\n    # sum logic\n    ss = [A[0] ^ B[0] ^ cin]\n    ss += [A[i] ^ B[i] ^ gs[i-1] for i in range(1, N)]\n    return farray(ss), farray(gs)", "response": "Return symbolic logic for an N - bit Brent - Kung adder."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _expect_token(lexer, types):\n    tok = next(lexer)\n    if any(isinstance(tok, t) for t in types):\n        return tok\n    else:\n        raise Error(\"unexpected token: \" + str(tok))", "response": "Return the next token or raise an exception."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_cnf(s, varname='x'):\n    lexer = iter(CNFLexer(s))\n    try:\n        ast = _cnf(lexer, varname)\n    except lex.RunError as exc:\n        fstr = (\"{0.args[0]}: \"\n                \"(line: {0.lineno}, offset: {0.offset}, text: {0.text})\")\n        raise Error(fstr.format(exc))\n\n    # Check for end of buffer\n    _expect_token(lexer, {EndToken})\n\n    return ast", "response": "Parse an input string in DIMACS CNF format and return an expression abstract syntax tree."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a DIMACS CNF.", "response": "def _cnf(lexer, varname):\n    \"\"\"Return a DIMACS CNF.\"\"\"\n    _expect_token(lexer, {KW_p})\n    _expect_token(lexer, {KW_cnf})\n    nvars = _expect_token(lexer, {IntegerToken}).value\n    nclauses = _expect_token(lexer, {IntegerToken}).value\n    return _cnf_formula(lexer, varname, nvars, nclauses)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a DIMACS CNF formula.", "response": "def _cnf_formula(lexer, varname, nvars, nclauses):\n    \"\"\"Return a DIMACS CNF formula.\"\"\"\n    clauses = _clauses(lexer, varname, nvars)\n\n    if len(clauses) < nclauses:\n        fstr = \"formula has fewer than {} clauses\"\n        raise Error(fstr.format(nclauses))\n    if len(clauses) > nclauses:\n        fstr = \"formula has more than {} clauses\"\n        raise Error(fstr.format(nclauses))\n\n    return ('and', ) + clauses"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a tuple of DIMACS CNF clauses.", "response": "def _clauses(lexer, varname, nvars):\n    \"\"\"Return a tuple of DIMACS CNF clauses.\"\"\"\n    tok = next(lexer)\n    toktype = type(tok)\n    if toktype is OP_not or toktype is IntegerToken:\n        lexer.unpop_token(tok)\n        first = _clause(lexer, varname, nvars)\n        rest = _clauses(lexer, varname, nvars)\n        return (first, ) + rest\n    # null\n    else:\n        lexer.unpop_token(tok)\n        return tuple()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _lits(lexer, varname, nvars):\n    tok = _expect_token(lexer, {OP_not, IntegerToken})\n    if isinstance(tok, IntegerToken) and tok.value == 0:\n        return tuple()\n    else:\n        if isinstance(tok, OP_not):\n            neg = True\n            tok = _expect_token(lexer, {IntegerToken})\n        else:\n            neg = False\n        index = tok.value\n\n        if index > nvars:\n            fstr = \"formula literal {} is greater than {}\"\n            raise Error(fstr.format(index, nvars))\n\n        lit = ('var', (varname, ), (index, ))\n        if neg:\n            lit = ('not', lit)\n\n        return (lit, ) + _lits(lexer, varname, nvars)", "response": "Return a tuple of DIMACS CNF clause literals."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_sat(s, varname='x'):\n    lexer = iter(SATLexer(s))\n\n    try:\n        ast = _sat(lexer, varname)\n    except lex.RunError as exc:\n        fstr = (\"{0.args[0]}: \"\n                \"(line: {0.lineno}, offset: {0.offset}, text: {0.text})\")\n        raise Error(fstr.format(exc))\n\n    # Check for end of buffer\n    _expect_token(lexer, {EndToken})\n\n    return ast", "response": "Parse an input string in DIMACS SAT format and return an expression."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a DIMACS SAT.", "response": "def _sat(lexer, varname):\n    \"\"\"Return a DIMACS SAT.\"\"\"\n    _expect_token(lexer, {KW_p})\n    fmt = _expect_token(lexer, {KW_sat, KW_satx, KW_sate, KW_satex}).value\n    nvars = _expect_token(lexer, {IntegerToken}).value\n    return _sat_formula(lexer, varname, fmt, nvars)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a DIMACS SAT formula.", "response": "def _sat_formula(lexer, varname, fmt, nvars):\n    \"\"\"Return a DIMACS SAT formula.\"\"\"\n    types = {IntegerToken, LPAREN} | _SAT_TOKS[fmt]\n    tok = _expect_token(lexer, types)\n    # INT\n    if isinstance(tok, IntegerToken):\n        index = tok.value\n        if not 0 < index <= nvars:\n            fstr = \"formula literal {} outside valid range: (0, {}]\"\n            raise Error(fstr.format(index, nvars))\n        return ('var', (varname, ), (index, ))\n    # '-'\n    elif isinstance(tok, OP_not):\n        tok = _expect_token(lexer, {IntegerToken, LPAREN})\n        # '-' INT\n        if isinstance(tok, IntegerToken):\n            index = tok.value\n            if not 0 < index <= nvars:\n                fstr = \"formula literal {} outside valid range: (0, {}]\"\n                raise Error(fstr.format(index, nvars))\n            return ('not', ('var', (varname, ), (index, )))\n        # '-' '(' FORMULA ')'\n        else:\n            formula = _sat_formula(lexer, varname, fmt, nvars)\n            _expect_token(lexer, {RPAREN})\n            return ('not', formula)\n    # '(' FORMULA ')'\n    elif isinstance(tok, LPAREN):\n        formula = _sat_formula(lexer, varname, fmt, nvars)\n        _expect_token(lexer, {RPAREN})\n        return formula\n    # OP '(' FORMULAS ')'\n    else:\n        _expect_token(lexer, {LPAREN})\n        formulas = _formulas(lexer, varname, fmt, nvars)\n        _expect_token(lexer, {RPAREN})\n        return (tok.ASTOP, ) + formulas"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _formulas(lexer, varname, fmt, nvars):\n    types = {IntegerToken, LPAREN} | _SAT_TOKS[fmt]\n    tok = lexer.peek_token()\n    if any(isinstance(tok, t) for t in types):\n        first = _sat_formula(lexer, varname, fmt, nvars)\n        rest = _formulas(lexer, varname, fmt, nvars)\n        return (first, ) + rest\n    # null\n    else:\n        return tuple()", "response": "Return a tuple of DIMACS SAT formulas."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npushing a keyword onto the token queue.", "response": "def keyword(self, text):\n        \"\"\"Push a keyword onto the token queue.\"\"\"\n        cls = self.KEYWORDS[text]\n        self.push_token(cls(text, self.lineno, self.offset))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef operator(self, text):\n        cls = self.OPERATORS[text]\n        self.push_token(cls(text, self.lineno, self.offset))", "response": "Push an operator onto the token queue."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npushing punctuation onto the token queue.", "response": "def punct(self, text):\n        \"\"\"Push punctuation onto the token queue.\"\"\"\n        cls = self.PUNCTUATION[text]\n        self.push_token(cls(text, self.lineno, self.offset))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse(s):\n    d = dict(ninputs=None, noutputs=None,\n             input_labels=None, output_labels=None,\n             intype=None, cover=set())\n\n    lines = [line.strip() for line in s.splitlines()]\n    for i, line in enumerate(lines, start=1):\n        # skip comments\n        if not line or _COMMENT.match(line):\n            continue\n\n        # .i\n        m_in = _NINS.match(line)\n        if m_in:\n            if d['ninputs'] is None:\n                d['ninputs'] = int(m_in.group(1))\n                continue\n            else:\n                raise Error(\".i declared more than once\")\n\n        # .o\n        m_out = _NOUTS.match(line)\n        if m_out:\n            if d['noutputs'] is None:\n                d['noutputs'] = int(m_out.group(1))\n                continue\n            else:\n                raise Error(\".o declared more than once\")\n\n        # ignore .p\n        m_prod = _PROD.match(line)\n        if m_prod:\n            continue\n\n        # .ilb\n        m_ilb = _ILB.match(line)\n        if m_ilb:\n            if d['input_labels'] is None:\n                d['input_labels'] = m_ilb.group(1).split()\n                continue\n            else:\n                raise Error(\".ilb declared more than once\")\n\n        # .ob\n        m_ob = _OB.match(line)\n        if m_ob:\n            if d['output_labels'] is None:\n                d['output_labels'] = m_ob.group(1).split()\n                continue\n            else:\n                raise Error(\".ob declared more than once\")\n\n        # .type\n        m_type = _TYPE.match(line)\n        if m_type:\n            if d['intype'] is None:\n                d['intype'] = _TYPES[m_type.group(1)]\n                continue\n            else:\n                raise Error(\".type declared more tha once\")\n\n        # cube\n        m_cube = _CUBE.match(line)\n        if m_cube:\n            inputs, outputs = m_cube.groups()\n            invec = tuple(_INCODE[c] for c in inputs)\n            outvec = tuple(_OUTCODE[c] for c in outputs)\n            d['cover'].add((invec, outvec))\n            continue\n\n        # ignore .e\n        m_end = _END.match(line)\n        if m_end:\n            continue\n\n        raise Error(\"syntax error on line {}: {}\".format(i, line))\n\n    return d", "response": "Parses an input string in PLA format and returns an intermediate representation dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a parser action property.", "response": "def action(toktype):\n    \"\"\"Return a parser action property.\"\"\"\n    def outer(func):\n        \"\"\"Return a function that pushes a token onto the token queue.\"\"\"\n        def inner(lexer, text):\n            \"\"\"Push a token onto the token queue.\"\"\"\n            value = func(lexer, text)\n            lexer.tokens.append(toktype(value, lexer.lineno, lexer.offset))\n        return inner\n    return outer"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _compile_rules(self):\n        for state, table in self.RULES.items():\n            patterns = list()\n            actions = list()\n            nextstates = list()\n            for i, row in enumerate(table):\n                if len(row) == 2:\n                    pattern, _action = row\n                    nextstate = None\n                elif len(row) == 3:\n                    pattern, _action, nextstate = row\n                else:\n                    fstr = \"invalid RULES: state {}, row {}\"\n                    raise CompileError(fstr.format(state, i))\n                patterns.append(pattern)\n                actions.append(_action)\n                nextstates.append(nextstate)\n            reobj = re.compile('|'.join(\"(\" + p + \")\" for p in patterns))\n            self._rules[state] = (reobj, actions, nextstates)", "response": "Compile the rules into the internal lexer state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\niterate through all tokens in the input string.", "response": "def _iter_tokens(self):\n        \"\"\"Iterate through all tokens in the input string.\"\"\"\n        reobj, actions, nextstates = self._rules[self.states[-1]]\n        mobj = reobj.match(self.string, self.pos)\n        while mobj is not None:\n            text = mobj.group(0)\n            idx = mobj.lastindex - 1\n            nextstate = nextstates[idx]\n\n            # Take action\n            actions[idx](self, text)\n            while self.tokens:\n                yield self.pop_token()\n            if nextstate and nextstate != self.states[-1]:\n                self.states[-1] = nextstate\n\n            # Update position variables\n            self.pos = mobj.end()\n            lines = text.split('\\n')\n            nlines = len(lines) - 1\n            if nlines == 0:\n                self.offset = self.offset + len(lines[0])\n            else:\n                self.lineno = self.lineno + nlines\n                self.offset = 1 + len(lines[-1])\n\n            reobj, actions, nextstates = self._rules[self.states[-1]]\n            mobj = reobj.match(self.string, self.pos)\n\n        if self.pos != len(self.string):\n            msg = \"unexpected character\"\n            text = self.string[self.pos]\n            raise RunError(msg, self.lineno, self.offset, text)\n\n        yield EndToken(\"\", self.lineno, self.offset)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clog2(num: int) -> int:\n    if num < 1:\n        raise ValueError(\"expected num >= 1\")\n    accum, shifter = 0, 1\n    while num > shifter:\n        shifter <<= 1\n        accum += 1\n    return accum", "response": "r Return the ceiling log base two of an integer num."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parity(num: int) -> int:\n    if num < 0:\n        raise ValueError(\"expected num >= 0\")\n    par = 0\n    while num:\n        par ^= (num & 1)\n        num >>= 1\n    return par", "response": "Return the parity of a non - negative integer."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cached_property(func):\n    def get(self):\n        \"\"\"this docstring will be over-written by func.__doc__\"\"\"\n        try:\n            return self._property_cache[func]\n        except AttributeError:\n            self._property_cache = dict()\n            prop = self._property_cache[func] = func(self)\n            return prop\n        except KeyError:\n            prop = self._property_cache[func] = func(self)\n            return prop\n    get.__doc__ = func.__doc__\n    return property(get)", "response": "Return a property that caches the result of the given function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a unique Variable instance.", "response": "def var(name, index=None):\n    \"\"\"Return a unique Variable instance.\n\n    .. note::\n       Do **NOT** call this function directly.\n       Instead, use one of the concrete implementations:\n\n       * :func:`pyeda.boolalg.bdd.bddvar`\n       * :func:`pyeda.boolalg.expr.exprvar`,\n       * :func:`pyeda.boolalg.table.ttvar`.\n    \"\"\"\n    tname = type(name)\n    if tname is str:\n        names = (name, )\n    elif tname is tuple:\n        names = name\n    else:\n        fstr = \"expected name to be a str or tuple, got {0.__name__}\"\n        raise TypeError(fstr.format(tname))\n\n    if not names:\n        raise ValueError(\"expected at least one name\")\n\n    for name in names:\n        tname = type(name)\n        if tname is not str:\n            fstr = \"expected name to be a str, got {0.__name__}\"\n            raise TypeError(fstr.format(tname))\n\n    if index is None:\n        indices = tuple()\n    else:\n        tindex = type(index)\n        if tindex is int:\n            indices = (index, )\n        elif tindex is tuple:\n            indices = index\n        else:\n            fstr = \"expected index to be an int or tuple, got {0.__name__}\"\n            raise TypeError(fstr.format(tindex))\n\n    for index in indices:\n        tindex = type(index)\n        if tindex is not int:\n            fstr = \"expected index to be an int, got {0.__name__}\"\n            raise TypeError(fstr.format(tindex))\n        if index < 0:\n            fstr = \"expected index to be >= 0, got {}\"\n            raise ValueError(fstr.format(index))\n\n    try:\n        v = VARIABLES[(names, indices)]\n    except KeyError:\n        v = Variable(names, indices)\n        VARIABLES[(names, indices)] = v\n    return v"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef num2point(num, vs):\n    if not isinstance(num, int):\n        fstr = \"expected num to be an int, got {0.__name__}\"\n        raise TypeError(fstr.format(type(num)))\n    n = len(vs)\n    if not 0 <= num < 2**n:\n        fstr = \"expected num to be in range [0, {}), got {}\"\n        raise ValueError(fstr.format(2**n, num))\n\n    return {v: bit_on(num, i) for i, v in enumerate(vs)}", "response": "Convert a number into a point in an N - dimensional Boolean space."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a number into a min or max term in an N - dimensional Boolean space.", "response": "def num2term(num, fs, conj=False):\n    \"\"\"Convert *num* into a min/max term in an N-dimensional Boolean space.\n\n    The *fs* argument is a sequence of :math:`N` Boolean functions.\n    There are :math:`2^N` points in the corresponding Boolean space.\n    The dimension number of each function is its index in the sequence.\n\n    The *num* argument is an int in range :math:`[0, 2^N)`.\n\n    If *conj* is ``False``, return a minterm.\n    Otherwise, return a maxterm.\n\n    For example, consider the 3-dimensional space formed by functions\n    :math:`f`, :math:`g`, :math:`h`.\n    Each vertex corresponds to a min/max term as summarized by the table::\n\n                6-----------7  ===== ======= ========== ==========\n               /|          /|   num   f g h    minterm    maxterm\n              / |         / |  ===== ======= ========== ==========\n             /  |        /  |    0    0 0 0   f' g' h'   f  g  h\n            4-----------5   |    1    1 0 0   f  g' h'   f' g  h\n            |   |       |   |    2    0 1 0   f' g  h'   f  g' h\n            |   |       |   |    3    1 1 0   f  g  h'   f' g' h\n            |   2-------|---3    4    0 0 1   f' g' h    f  g  h'\n            |  /        |  /     5    1 0 1   f  g' h    f' g  h'\n       h g  | /         | /      6    0 1 1   f' g  h    f  g' h'\n       |/   |/          |/       7    1 1 1   f  g  h    f' g' h'\n       +-f  0-----------1      ===== ======= ========= ===========\n\n    .. note::\n       The ``f g h`` column is the binary representation of *num*\n       written in little-endian order.\n    \"\"\"\n    if not isinstance(num, int):\n        fstr = \"expected num to be an int, got {0.__name__}\"\n        raise TypeError(fstr.format(type(num)))\n    n = len(fs)\n    if not 0 <= num < 2**n:\n        fstr = \"expected num to be in range [0, {}), got {}\"\n        raise ValueError(fstr.format(2**n, num))\n\n    if conj:\n        return tuple(~f if bit_on(num, i) else f for i, f in enumerate(fs))\n    else:\n        return tuple(f if bit_on(num, i) else ~f for i, f in enumerate(fs))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef point2upoint(point):\n    upoint = [set(), set()]\n    for v, val in point.items():\n        upoint[val].add(v.uniqid)\n    upoint[0] = frozenset(upoint[0])\n    upoint[1] = frozenset(upoint[1])\n    return tuple(upoint)", "response": "Convert a point into an untyped point."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a point into a min or max term.", "response": "def point2term(point, conj=False):\n    \"\"\"Convert *point* into a min/max term.\n\n    If *conj* is ``False``, return a minterm.\n    Otherwise, return a maxterm.\n    \"\"\"\n    if conj:\n        return tuple(~v if val else v for v, val in point.items())\n    else:\n        return tuple(v if val else ~v for v, val in point.items())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iter_terms(fs, conj=False):\n    for num in range(1 << len(fs)):\n        yield num2term(num, fs, conj)", "response": "Iterate through all min and max terms in an N - dimensional Boolean space."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef vpoint2point(vpoint):\n    point = dict()\n    for v, val in vpoint.items():\n        point.update(_flatten(v, val))\n    return point", "response": "Convert a vpoint into a N - dimensional Boolean space."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _flatten(v, val):\n    if isinstance(v, Variable):\n        yield v, int(val)\n    else:\n        if len(v) != len(val):\n            raise ValueError(\"expected 1:1 mapping from Variable => {0, 1}\")\n        for _var, _val in zip(v, val):\n            yield from _flatten(_var, _val)", "response": "Recursively flatten vectorized var => 1 mappings."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\niterate through all ( point element pairs in the relation.", "response": "def iter_relation(self):\n        \"\"\"Iterate through all (point, element) pairs in the relation.\"\"\"\n        for point in iter_points(self.inputs):\n            yield (point, self.restrict(point))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef consensus(self, vs=None):\n        return functools.reduce(operator.and_, self.iter_cofactors(vs))", "response": "r Return the consensus of a function over a sequence of N variables."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _expect_vars(vs=None):\n        if vs is None:\n            return list()\n        elif isinstance(vs, Variable):\n            return [vs]\n        else:\n            checked = list()\n            # Will raise TypeError if vs is not iterable\n            for v in vs:\n                if isinstance(v, Variable):\n                    checked.append(v)\n                else:\n                    fstr = \"expected Variable, got {0.__name__}\"\n                    raise TypeError(fstr.format(type(v)))\n            return checked", "response": "Verify the input type and return a list of Variables."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a solution point for a Sudoku grid.", "response": "def solve(self, grid):\n        \"\"\"Return a solution point for a Sudoku grid.\"\"\"\n        soln = self.S.satisfy_one(assumptions=self._parse_grid(grid))\n        return self.S.soln2point(soln, self.litmap)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_grid(self, grid):\n        chars = [c for c in grid if c in DIGITS or c in \"0.\"]\n        if len(chars) != 9**2:\n            raise ValueError(\"expected 9x9 grid\")\n        return [self.litmap[self.X[i // 9 + 1, i % 9 + 1, int(c)]]\n                for i, c in enumerate(chars) if c in DIGITS]", "response": "Return the input constraints for a Sudoku grid."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _soln2str(self, soln, fancy=False):\n        chars = list()\n        for r in range(1, 10):\n            for c in range(1, 10):\n                if fancy and c in (4, 7):\n                    chars.append(\"|\")\n                chars.append(self._get_val(soln, r, c))\n            if fancy and r != 9:\n                chars.append(\"\\n\")\n                if r in (3, 6):\n                    chars.append(\"---+---+---\\n\")\n        return \"\".join(chars)", "response": "Convert a Sudoku solution point to a string."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the string value for a solution coordinate.", "response": "def _get_val(self, soln, r, c):\n        \"\"\"Return the string value for a solution coordinate.\"\"\"\n        for v in range(1, 10):\n            if soln[self.X[r, c, v]]:\n                return DIGITS[v-1]\n        return \"X\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a TruthTable variable.", "response": "def ttvar(name, index=None):\n    \"\"\"Return a TruthTable variable.\n\n    Parameters\n    ----------\n    name : str\n        The variable's identifier string.\n    index : int or tuple[int], optional\n        One or more integer suffixes for variables that are part of a\n        multi-dimensional bit-vector, eg x[1], x[1][2][3]\n    \"\"\"\n    bvar = boolfunc.var(name, index)\n    try:\n        var = _VARS[bvar.uniqid]\n    except KeyError:\n        var = _VARS[bvar.uniqid] = TTVariable(bvar)\n    return var"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef truthtable(inputs, outputs):\n    def items():\n        \"\"\"Convert all outputs to PC notation.\"\"\"\n        for output in outputs:\n            if isinstance(output, boolfunc.Function):\n                output = output.unbox()\n            if output in (0, '0'):\n                yield PC_ZERO\n            elif output in (1, '1'):\n                yield PC_ONE\n            elif output in \"-xX\":\n                yield PC_DC\n            else:\n                fstr = \"expected output in [01-xX], got {}\"\n                raise ValueError(fstr.format(output))\n    inputs = [ttvar(v.names, v.indices) for v in inputs]\n    pcdata = PCData(items())\n    if len(pcdata) != (1 << len(inputs)):\n        fstr = \"expected {} outputs, got {}\"\n        raise ValueError(fstr.format(1 << len(inputs), len(pcdata)))\n    return _truthtable(inputs, pcdata)", "response": "Convert a list of inputs and outputs to a truth table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a truth table.", "response": "def _truthtable(inputs, pcdata):\n    \"\"\"Return a truth table.\"\"\"\n    if len(inputs) == 0 and pcdata[0] in {PC_ZERO, PC_ONE}:\n        return {\n            PC_ZERO : TTZERO,\n            PC_ONE  : TTONE\n        }[pcdata[0]]\n    elif len(inputs) == 1 and pcdata[0] == PC_ZERO and pcdata[1] == PC_ONE:\n        return inputs[0]\n    else:\n        return TruthTable(inputs, pcdata)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef expr2truthtable(expr):\n    inputs = [ttvar(v.names, v.indices) for v in expr.inputs]\n    return truthtable(inputs, expr.iter_image())", "response": "Convert an expression into a truth table."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef truthtable2expr(tt, conj=False):\n    if conj:\n        outer, inner = (And, Or)\n        nums = tt.pcdata.iter_zeros()\n    else:\n        outer, inner = (Or, And)\n        nums = tt.pcdata.iter_ones()\n    inputs = [exprvar(v.names, v.indices) for v in tt.inputs]\n    terms = [boolfunc.num2term(num, inputs, conj) for num in nums]\n    return outer(*[inner(*term) for term in terms])", "response": "Convert a truth table into an expression."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _bin_zfill(num, width=None):\n    s = bin(num)[2:]\n    return s if width is None else s.zfill(width)", "response": "Convert a base - 10 number to a binary string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef zero_mask(self):\n        accum = 0\n        for i in range(self.data.itemsize):\n            accum += (0x55 << (i << 3))\n        return accum", "response": "Return a mask to determine whether an array chunk has any zeros."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef one_mask(self):\n        accum = 0\n        for i in range(self.data.itemsize):\n            accum += (0xAA << (i << 3))\n        return accum", "response": "Return a mask to determine whether an array chunk has any ones."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iter_zeros(self):\n        num = quotient = 0\n        while num < self._len:\n            chunk = self.data[quotient]\n            if chunk & self.zero_mask:\n                remainder = 0\n                while remainder < self.width and num < self._len:\n                    item = (chunk >> remainder) & 3\n                    if item == PC_ZERO:\n                        yield num\n                    remainder += 2\n                    num += 1\n            else:\n                num += (self.width >> 1)\n            quotient += 1", "response": "Iterate through the indices of all zero items."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_one(self):\n        num = quotient = 0\n        while num < self._len:\n            chunk = self.data[quotient]\n            if chunk & self.one_mask:\n                remainder = 0\n                while remainder < self.width and num < self._len:\n                    item = (chunk >> remainder) & 3\n                    if item == PC_ONE:\n                        return num\n                    remainder += 2\n                    num += 1\n            else:\n                num += (self.width >> 1)\n            quotient += 1\n        return None", "response": "Return the first index of an entry that is either one or DC."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _iter_restrict(self, zeros, ones):\n        inputs = list(self.inputs)\n        unmapped = dict()\n        for i, v in enumerate(self.inputs):\n            if v in zeros:\n                inputs[i] = 0\n            elif v in ones:\n                inputs[i] = 1\n            else:\n                unmapped[v] = i\n        vs = sorted(unmapped.keys())\n        for num in range(1 << len(vs)):\n            for v, val in boolfunc.num2point(num, vs).items():\n                inputs[unmapped[v]] = val\n            yield sum((val << i) for i, val in enumerate(inputs))", "response": "Iterate through indices of all table entries that vary."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bddvar(name, index=None):\n    bvar = boolfunc.var(name, index)\n    try:\n        var = _VARS[bvar.uniqid]\n    except KeyError:\n        var = _VARS[bvar.uniqid] = BDDVariable(bvar)\n        _BDDS[var.node] = var\n    return var", "response": "r Returns a unique BDD variable."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert an expression into a BDD node.", "response": "def _expr2bddnode(expr):\n    \"\"\"Convert an expression into a BDD node.\"\"\"\n    if expr.is_zero():\n        return BDDNODEZERO\n    elif expr.is_one():\n        return BDDNODEONE\n    else:\n        top = expr.top\n\n        # Register this variable\n        _ = bddvar(top.names, top.indices)\n\n        root = top.uniqid\n        lo = _expr2bddnode(expr.restrict({top: 0}))\n        hi = _expr2bddnode(expr.restrict({top: 1}))\n        return _bddnode(root, lo, hi)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bdd2expr(bdd, conj=False):\n    if conj:\n        outer, inner = (And, Or)\n        paths = _iter_all_paths(bdd.node, BDDNODEZERO)\n    else:\n        outer, inner = (Or, And)\n        paths = _iter_all_paths(bdd.node, BDDNODEONE)\n    terms = list()\n    for path in paths:\n        expr_point = {exprvar(v.names, v.indices): val\n                      for v, val in _path2point(path).items()}\n        terms.append(boolfunc.point2term(expr_point, conj))\n    return outer(*[inner(*term) for term in terms])", "response": "Convert a binary decision diagram into an expression."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef upoint2bddpoint(upoint):\n    point = dict()\n    for uniqid in upoint[0]:\n        point[_VARS[uniqid]] = 0\n    for uniqid in upoint[1]:\n        point[_VARS[uniqid]] = 1\n    return point", "response": "Convert an untyped point into a BDD point."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _bddnode(root, lo, hi):\n    if lo is hi:\n        node = lo\n    else:\n        key = (root, lo, hi)\n        try:\n            node = _NODES[key]\n        except KeyError:\n            node = _NODES[key] = BDDNode(*key)\n    return node", "response": "Return a unique BDD node."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _bdd(node):\n    try:\n        bdd = _BDDS[node]\n    except KeyError:\n        bdd = _BDDS[node] = BinaryDecisionDiagram(node)\n    return bdd", "response": "Return a unique BDD."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a BDD path to a BDD point.", "response": "def _path2point(path):\n    \"\"\"Convert a BDD path to a BDD point.\"\"\"\n    return {_VARS[node.root]: int(node.hi is path[i+1])\n            for i, node in enumerate(path[:-1])}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the inverse of node.", "response": "def _neg(node):\n    \"\"\"Return the inverse of *node*.\"\"\"\n    if node is BDDNODEZERO:\n        return BDDNODEONE\n    elif node is BDDNODEONE:\n        return BDDNODEZERO\n    else:\n        return _bddnode(node.root, _neg(node.lo), _neg(node.hi))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _ite(f, g, h):\n    # ITE(f, 1, 0) = f\n    if g is BDDNODEONE and h is BDDNODEZERO:\n        return f\n    # ITE(f, 0, 1) = f'\n    elif g is BDDNODEZERO and h is BDDNODEONE:\n        return _neg(f)\n    # ITE(1, g, h) = g\n    elif f is BDDNODEONE:\n        return g\n    # ITE(0, g, h) = h\n    elif f is BDDNODEZERO:\n        return h\n    # ITE(f, g, g) = g\n    elif g is h:\n        return g\n    else:\n        # ITE(f, g, h) = ITE(x, ITE(fx', gx', hx'), ITE(fx, gx, hx))\n        root = min(node.root for node in (f, g, h) if node.root > 0)\n        npoint0 = {root: BDDNODEZERO}\n        npoint1 = {root: BDDNODEONE}\n        fv0, gv0, hv0 = [_restrict(node, npoint0) for node in (f, g, h)]\n        fv1, gv1, hv1 = [_restrict(node, npoint1) for node in (f, g, h)]\n        return _bddnode(root, _ite(fv0, gv0, hv0), _ite(fv1, gv1, hv1))", "response": "Return node that results from recursively applying ITE."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrestricting a subset of support variables to { 0 1 }.", "response": "def _restrict(node, npoint, cache=None):\n    \"\"\"Restrict a subset of support variables to {0, 1}.\"\"\"\n    if node is BDDNODEZERO or node is BDDNODEONE:\n        return node\n\n    if cache is None:\n        cache = dict()\n\n    try:\n        ret = cache[node]\n    except KeyError:\n        try:\n            val = npoint[node.root]\n        except KeyError:\n            lo = _restrict(node.lo, npoint, cache)\n            hi = _restrict(node.hi, npoint, cache)\n            ret = _bddnode(node.root, lo, hi)\n        else:\n            child = {BDDNODEZERO: node.lo, BDDNODEONE: node.hi}[val]\n            ret = _restrict(child, npoint, cache)\n        cache[node] = ret\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _find_path(start, end, path=tuple()):\n    path = path + (start, )\n    if start is end:\n        return path\n    else:\n        ret = None\n        if start.lo is not None:\n            ret = _find_path(start.lo, end, path)\n        if ret is None and start.hi is not None:\n            ret = _find_path(start.hi, end, path)\n        return ret", "response": "Return the path from start to end."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\niterating through all paths from start to end.", "response": "def _iter_all_paths(start, end, rand=False, path=tuple()):\n    \"\"\"Iterate through all paths from start to end.\"\"\"\n    path = path + (start, )\n    if start is end:\n        yield path\n    else:\n        nodes = [start.lo, start.hi]\n        if rand: # pragma: no cover\n            random.shuffle(nodes)\n        for node in nodes:\n            if node is not None:\n                yield from _iter_all_paths(node, end, rand, path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\niterating through nodes in DFS pre - order.", "response": "def _dfs_preorder(node, visited):\n    \"\"\"Iterate through nodes in DFS pre-order.\"\"\"\n    if node not in visited:\n        visited.add(node)\n        yield node\n    if node.lo is not None:\n        yield from _dfs_preorder(node.lo, visited)\n    if node.hi is not None:\n        yield from _dfs_preorder(node.hi, visited)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _dfs_postorder(node, visited):\n    if node.lo is not None:\n        yield from _dfs_postorder(node.lo, visited)\n    if node.hi is not None:\n        yield from _dfs_postorder(node.hi, visited)\n    if node not in visited:\n        visited.add(node)\n        yield node", "response": "Iterate through nodes in DFS post - order."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\niterating through nodes in BFS order.", "response": "def _bfs(node, visited):\n    \"\"\"Iterate through nodes in BFS order.\"\"\"\n    queue = collections.deque()\n    queue.appendleft(node)\n    while queue:\n        node = queue.pop()\n        if node not in visited:\n            if node.lo is not None:\n                queue.appendleft(node.lo)\n            if node.hi is not None:\n                queue.appendleft(node.hi)\n            visited.add(node)\n            yield node"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning whether this BDD is equivalent to other.", "response": "def equivalent(self, other):\n        \"\"\"Return whether this BDD is equivalent to *other*.\n\n        You can also use Python's ``is`` operator for BDD equivalency testing.\n\n        For example::\n\n           >>> a, b, c = map(bddvar, 'abc')\n           >>> f1 = a ^ b ^ c\n           >>> f2 = a & ~b & ~c | ~a & b & ~c | ~a & ~b & c | a & b & c\n           >>> f1 is f2\n           True\n        \"\"\"\n        other = self.box(other)\n        return self.node is other.node"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_dot(self, name='BDD'): # pragma: no cover\n        parts = ['graph', name, '{']\n        for node in self.dfs_postorder():\n            if node is BDDNODEZERO:\n                parts += ['n' + str(id(node)), '[label=0,shape=box];']\n            elif node is BDDNODEONE:\n                parts += ['n' + str(id(node)), '[label=1,shape=box];']\n            else:\n                v = _VARS[node.root]\n                parts.append('n' + str(id(node)))\n                parts.append('[label=\"{}\",shape=circle];'.format(v))\n        for node in self.dfs_postorder():\n            if node is not BDDNODEZERO and node is not BDDNODEONE:\n                parts += ['n' + str(id(node)), '--',\n                          'n' + str(id(node.lo)),\n                          '[label=0,style=dashed];']\n                parts += ['n' + str(id(node)), '--',\n                          'n' + str(id(node.hi)),\n                          '[label=1];']\n        parts.append('}')\n        return \" \".join(parts)", "response": "Convert the tree to DOT language representation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a string containing a Boolean expression and returns an abstract syntax tree.", "response": "def parse(s):\n    \"\"\"\n    Parse a Boolean expression string,\n    and return an expression abstract syntax tree.\n\n    Parameters\n    ----------\n    s : str\n        String containing a Boolean expression.\n        See ``pyeda.parsing.boolexpr.GRAMMAR`` for details.\n\n    Examples\n    --------\n    >>> parse(\"a | b ^ c & d\")\n    ('or', ('var', ('a',), ()), ('xor', ('var', ('b',), ()), ('and', ('var', ('c',), ()), ('var', ('d',), ()))))\n    >>> parse(\"p => q\")\n    ('implies', ('var', ('p',), ()), ('var', ('q',), ()))\n\n    Returns\n    -------\n    An ast tuple, defined recursively:\n\n    ast := ('const', bool)\n         | ('var', names, indices)\n         | ('not', ast)\n         | ('implies', ast, ast)\n         | ('ite', ast, ast, ast)\n         | (func, ast, ...)\n\n    bool := 0 | 1\n\n    names := (name, ...)\n\n    indices := (index, ...)\n\n    func := 'or' | 'and'\n          | 'nor' | 'nand'\n          | 'xor' | 'xnor'\n          | 'equal' | 'unequal'\n          | 'onehot0' | 'onehot'\n          | 'majority' | 'achillesheel'\n    \"\"\"\n    lexer = iter(BoolExprLexer(s))\n    try:\n        expr = _expr(lexer)\n    except lex.RunError as exc:\n        fstr = (\"{0.args[0]}: \"\n                \"(line: {0.lineno}, offset: {0.offset}, text: {0.text})\")\n        raise Error(fstr.format(exc))\n\n    # Check for end of buffer\n    _expect_token(lexer, {EndToken})\n\n    return expr"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an ITE expression.", "response": "def _ite(lexer):\n    \"\"\"Return an ITE expression.\"\"\"\n    s = _impl(lexer)\n\n    tok = next(lexer)\n    # IMPL '?' ITE ':' ITE\n    if isinstance(tok, OP_question):\n        d1 = _ite(lexer)\n        _expect_token(lexer, {OP_colon})\n        d0 = _ite(lexer)\n        return ('ite', s, d1, d0)\n    # IMPL\n    else:\n        lexer.unpop_token(tok)\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _impl(lexer):\n    p = _sumterm(lexer)\n\n    tok = next(lexer)\n    # SUMTERM '=>' IMPL\n    if isinstance(tok, OP_rarrow):\n        q = _impl(lexer)\n        return ('implies', p, q)\n    # SUMTERM '<=>' IMPL\n    elif isinstance(tok, OP_lrarrow):\n        q = _impl(lexer)\n        return ('equal', p, q)\n    # SUMTERM\n    else:\n        lexer.unpop_token(tok)\n        return p", "response": "Return an Implies expression."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _sumterm(lexer):\n    xorterm = _xorterm(lexer)\n    sumterm_prime = _sumterm_prime(lexer)\n    if sumterm_prime is None:\n        return xorterm\n    else:\n        return ('or', xorterm, sumterm_prime)", "response": "Return a sum term expresssion."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _sumterm_prime(lexer):\n    tok = next(lexer)\n    # '|' XORTERM SUMTERM'\n    if isinstance(tok, OP_or):\n        xorterm = _xorterm(lexer)\n        sumterm_prime = _sumterm_prime(lexer)\n        if sumterm_prime is None:\n            return xorterm\n        else:\n            return ('or', xorterm, sumterm_prime)\n    # null\n    else:\n        lexer.unpop_token(tok)\n        return None", "response": "Return a sum term expression eliminates left recursion."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an xor term expresssion.", "response": "def _xorterm(lexer):\n    \"\"\"Return an xor term expresssion.\"\"\"\n    prodterm = _prodterm(lexer)\n    xorterm_prime = _xorterm_prime(lexer)\n    if xorterm_prime is None:\n        return prodterm\n    else:\n        return ('xor', prodterm, xorterm_prime)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _xorterm_prime(lexer):\n    tok = next(lexer)\n    # '^' PRODTERM XORTERM'\n    if isinstance(tok, OP_xor):\n        prodterm = _prodterm(lexer)\n        xorterm_prime = _xorterm_prime(lexer)\n        if xorterm_prime is None:\n            return prodterm\n        else:\n            return ('xor', prodterm, xorterm_prime)\n    # null\n    else:\n        lexer.unpop_token(tok)\n        return None", "response": "Return an xor term expression eliminates left recursion."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _prodterm(lexer):\n    factor = _factor(lexer)\n    prodterm_prime = _prodterm_prime(lexer)\n    if prodterm_prime is None:\n        return factor\n    else:\n        return ('and', factor, prodterm_prime)", "response": "Return a product term expression."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a product term expression eliminates left recursion.", "response": "def _prodterm_prime(lexer):\n    \"\"\"Return a product term' expression, eliminates left recursion.\"\"\"\n    tok = next(lexer)\n    # '&' FACTOR PRODTERM'\n    if isinstance(tok, OP_and):\n        factor = _factor(lexer)\n        prodterm_prime = _prodterm_prime(lexer)\n        if prodterm_prime is None:\n            return factor\n        else:\n            return ('and', factor, prodterm_prime)\n    # null\n    else:\n        lexer.unpop_token(tok)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a factor expression.", "response": "def _factor(lexer):\n    \"\"\"Return a factor expression.\"\"\"\n    tok = _expect_token(lexer, FACTOR_TOKS)\n    # '~' F\n    toktype = type(tok)\n    if toktype is OP_not:\n        return ('not', _factor(lexer))\n    # '(' EXPR ')'\n    elif toktype is LPAREN:\n        expr = _expr(lexer)\n        _expect_token(lexer, {RPAREN})\n        return expr\n    # OPN '(' ... ')'\n    elif any(toktype is t for t in OPN_TOKS):\n        op = tok.ASTOP\n        _expect_token(lexer, {LPAREN})\n        tok = next(lexer)\n        # OPN '(' ')'\n        if isinstance(tok, RPAREN):\n            xs = tuple()\n        # OPN '(' XS ')'\n        else:\n            lexer.unpop_token(tok)\n            xs = _args(lexer)\n            _expect_token(lexer, {RPAREN})\n        return (op, ) + xs\n    # ITE '(' EXPR ',' EXPR ',' EXPR ')'\n    elif toktype is KW_ite:\n        _expect_token(lexer, {LPAREN})\n        s = _expr(lexer)\n        _expect_token(lexer, {COMMA})\n        d1 = _expr(lexer)\n        _expect_token(lexer, {COMMA})\n        d0 = _expr(lexer)\n        _expect_token(lexer, {RPAREN})\n        return ('ite', s, d1, d0)\n    # Implies '(' EXPR ',' EXPR ')'\n    elif toktype is KW_implies:\n        _expect_token(lexer, {LPAREN})\n        p = _expr(lexer)\n        _expect_token(lexer, {COMMA})\n        q = _expr(lexer)\n        _expect_token(lexer, {RPAREN})\n        return ('implies', p, q)\n    # Not '(' EXPR ')'\n    elif toktype is KW_not:\n        _expect_token(lexer, {LPAREN})\n        x = _expr(lexer)\n        _expect_token(lexer, {RPAREN})\n        return ('not', x)\n    # VARIABLE\n    elif toktype is NameToken:\n        lexer.unpop_token(tok)\n        return _variable(lexer)\n    # '0' | '1'\n    else:\n        if tok.value not in {0, 1}:\n            raise Error(\"unexpected token: \" + str(tok))\n        return ('const', tok.value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning zero or more arguments.", "response": "def _zom_arg(lexer):\n    \"\"\"Return zero or more arguments.\"\"\"\n    tok = next(lexer)\n    # ',' EXPR ZOM_X\n    if isinstance(tok, COMMA):\n        return (_expr(lexer), ) + _zom_arg(lexer)\n    # null\n    else:\n        lexer.unpop_token(tok)\n        return tuple()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a variable expression.", "response": "def _variable(lexer):\n    \"\"\"Return a variable expression.\"\"\"\n    names = _names(lexer)\n\n    tok = next(lexer)\n    # NAMES '[' ... ']'\n    if isinstance(tok, LBRACK):\n        indices = _indices(lexer)\n        _expect_token(lexer, {RBRACK})\n    # NAMES\n    else:\n        lexer.unpop_token(tok)\n        indices = tuple()\n\n    return ('var', names, indices)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a tuple of names.", "response": "def _names(lexer):\n    \"\"\"Return a tuple of names.\"\"\"\n    first = _expect_token(lexer, {NameToken}).value\n    rest = _zom_name(lexer)\n    rnames = (first, ) + rest\n    return rnames[::-1]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning zero or more names.", "response": "def _zom_name(lexer):\n    \"\"\"Return zero or more names.\"\"\"\n    tok = next(lexer)\n    # '.' NAME ZOM_NAME\n    if isinstance(tok, DOT):\n        first = _expect_token(lexer, {NameToken}).value\n        rest = _zom_name(lexer)\n        return (first, ) + rest\n    # null\n    else:\n        lexer.unpop_token(tok)\n        return tuple()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _indices(lexer):\n    first = _expect_token(lexer, {IntegerToken}).value\n    rest = _zom_index(lexer)\n    return (first, ) + rest", "response": "Return a tuple of indices."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn zero or more indices.", "response": "def _zom_index(lexer):\n    \"\"\"Return zero or more indices.\"\"\"\n    tok = next(lexer)\n    # ',' INT\n    if isinstance(tok, COMMA):\n        first = _expect_token(lexer, {IntegerToken}).value\n        rest = _zom_index(lexer)\n        return (first, ) + rest\n    # null\n    else:\n        lexer.unpop_token(tok)\n        return tuple()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef subword(w):\n    w = w.reshape(4, 8)\n    return SBOX[w[0]] + SBOX[w[1]] + SBOX[w[2]] + SBOX[w[3]]", "response": "Function used in the Key Expansion routine that takes a four - byte input word\n    and applies an S - box to each of the four bytes to produce a subword."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninverse subword transformation in the Inverse Cipher that is the inverse of SubBytes.", "response": "def invsubword(w):\n    \"\"\"\n    Transformation in the Inverse Cipher that is the inverse of SubBytes().\n    \"\"\"\n    w = w.reshape(4, 8)\n    return ISBOX[w[0]] + ISBOX[w[1]] + ISBOX[w[2]] + ISBOX[w[3]]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef multiply(a, col):\n    a = a.reshape(4, 4, 4)\n    col = col.reshape(4, 8)\n    return fcat(\n        rowxcol(a[0], col),\n        rowxcol(a[1], col),\n        rowxcol(a[2], col),\n        rowxcol(a[3], col),\n    )", "response": "Multiply a matrix by one column."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rowxcol(row, col):\n    row = row.reshape(4, 4)\n    col = col.reshape(4, 8)\n    ret = uint2exprs(0, 8)\n    for i in range(4):\n        for j in range(4):\n            if row[i, j]:\n                ret ^= xtime(col[i], j)\n    return ret", "response": "Multiply one row and one column."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef xtime(b, n):\n    b = b.reshape(8)\n    for _ in range(n):\n        b = exprzeros(1) + b[:7] ^ uint2exprs(0x1b, 8) & b[7]*8\n    return b", "response": "Repeated polynomial multiplication in GF ( 2^8 )."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_round_key(state, rkey):\n    state = state.reshape(4, 32)\n    rkey = rkey.reshape(4, 32)\n    return fcat(\n        state[0] ^ rkey[0],\n        state[1] ^ rkey[1],\n        state[2] ^ rkey[2],\n        state[3] ^ rkey[3],\n    )", "response": "This function adds a Round Key to the State."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sub_bytes(state):\n    state = state.reshape(4, 32)\n    return fcat(\n        subword(state[0]),\n        subword(state[1]),\n        subword(state[2]),\n        subword(state[3]),\n    )", "response": "This function transforms a State into a non\u00adlinear\n    byte substitution table."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef inv_sub_bytes(state):\n    state = state.reshape(4, 32)\n    return fcat(\n        invsubword(state[0]),\n        invsubword(state[1]),\n        invsubword(state[2]),\n        invsubword(state[3]),\n    )", "response": "This function is used to transform a state in the Inverse Cipher that is the inverse of SubBytes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef shift_rows(state):\n    state = state.reshape(4, 4, 8)\n    return fcat(\n        state[0][0], state[1][1], state[2][2], state[3][3],\n        state[1][0], state[2][1], state[3][2], state[0][3],\n        state[2][0], state[3][1], state[0][2], state[1][3],\n        state[3][0], state[0][1], state[1][2], state[2][3]\n    )", "response": "This function takes a State and returns a new State that is shifted by the last three rows of the State."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mix_columns(state):\n    state = state.reshape(4, 4, 8)\n    return fcat(\n        multiply(MA, state[0]),\n        multiply(MA, state[1]),\n        multiply(MA, state[2]),\n        multiply(MA, state[3]),\n    )", "response": "This function takes all of the columns of the State and returns a new State that has the same number of columns."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef key_expand(key, Nk=4):\n    assert Nk in {4, 6, 8}\n    Nr = Nk + 6\n\n    key = key.reshape(Nk, 32)\n    rkey = exprzeros(4*(Nr+1), 32)\n\n    for i in range(Nk):\n        rkey[i] = key[i]\n\n    for i in range(Nk, 4*(Nr+1)):\n        if i % Nk == 0:\n            rkey[i] = rkey[i-Nk] ^ subword(rotword(rkey[i-1])) ^ RCON[i//Nk].zext(32-8)\n        elif Nk > 6 and i % Nk == 4:\n            rkey[i] = rkey[i-Nk] ^ subword(rkey[i-1])\n        else:\n            rkey[i] = rkey[i-Nk] ^ rkey[i-1]\n\n    return rkey", "response": "Expand the key into the round key."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nencrypting a plain text block.", "response": "def encrypt(key, pt, Nk=4):\n    \"\"\"Encrypt a plain text block.\"\"\"\n    assert Nk in {4, 6, 8}\n    rkey = key_expand(key, Nk)\n    ct = cipher(rkey, pt, Nk)\n\n    return ct"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a gray - coded vector into a binary - coded vector.", "response": "def gray2bin(G):\n    \"\"\"Convert a gray-coded vector into a binary-coded vector.\"\"\"\n    return farray([G[i:].uxor() for i, _ in enumerate(G)])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _assume2point():\n    point = dict()\n    for lit in _ASSUMPTIONS:\n        if isinstance(lit, Complement):\n            point[~lit] = 0\n        elif isinstance(lit, Variable):\n            point[lit] = 1\n    return point", "response": "Convert global assumptions to a point."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a unique Expression complement.", "response": "def _exprcomp(node):\n    \"\"\"Return a unique Expression complement.\"\"\"\n    try:\n        comp = _LITS[node.data()]\n    except KeyError:\n        comp = _LITS[node.data()] = Complement(node)\n    return comp"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts an arbitrary object into an Expression.", "response": "def expr(obj, simplify=True):\n    \"\"\"Convert an arbitrary object into an Expression.\"\"\"\n    if isinstance(obj, Expression):\n        return obj\n    # False, True, 0, 1\n    elif isinstance(obj, int) and obj in {0, 1}:\n        return _CONSTS[obj]\n    elif isinstance(obj, str):\n        ast = pyeda.parsing.boolexpr.parse(obj)\n        ex = ast2expr(ast)\n        if simplify:\n            ex = ex.simplify()\n        return ex\n    else:\n        return One if bool(obj) else Zero"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts an abstract syntax tree to an Expression.", "response": "def ast2expr(ast):\n    \"\"\"Convert an abstract syntax tree to an Expression.\"\"\"\n    if ast[0] == 'const':\n        return _CONSTS[ast[1]]\n    elif ast[0] == 'var':\n        return exprvar(ast[1], ast[2])\n    else:\n        xs = [ast2expr(x) for x in ast[1:]]\n        return ASTOPS[ast[0]](*xs, simplify=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts an expression into an equivalent DIMACS CNF.", "response": "def expr2dimacscnf(ex):\n    \"\"\"Convert an expression into an equivalent DIMACS CNF.\"\"\"\n    litmap, nvars, clauses = ex.encode_cnf()\n    return litmap, DimacsCNF(nvars, clauses)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef expr2dimacssat(ex):\n    if not ex.simple:\n        raise ValueError(\"expected ex to be simplified\")\n\n    litmap, nvars = ex.encode_inputs()\n\n    formula = _expr2sat(ex, litmap)\n    if 'xor' in formula:\n        if '=' in formula:\n            fmt = 'satex'\n        else:\n            fmt = 'satx'\n    elif '=' in formula:\n        fmt = 'sate'\n    else:\n        fmt = 'sat'\n\n    return \"p {} {}\\n{}\".format(fmt, nvars, formula)", "response": "Convert an expression into an equivalent DIMACS SAT string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting an expression to a DIMACS SAT string.", "response": "def _expr2sat(ex, litmap): # pragma: no cover\n    \"\"\"Convert an expression to a DIMACS SAT string.\"\"\"\n    if isinstance(ex, Literal):\n        return str(litmap[ex])\n    elif isinstance(ex, NotOp):\n        return \"-(\" + _expr2sat(ex.x, litmap) + \")\"\n    elif isinstance(ex, OrOp):\n        return \"+(\" + \" \".join(_expr2sat(x, litmap)\n                               for x in ex.xs) + \")\"\n    elif isinstance(ex, AndOp):\n        return \"*(\" + \" \".join(_expr2sat(x, litmap)\n                               for x in ex.xs) + \")\"\n    elif isinstance(ex, XorOp):\n        return (\"xor(\" + \" \".join(_expr2sat(x, litmap)\n                                  for x in ex.xs) + \")\")\n    elif isinstance(ex, EqualOp):\n        return \"=(\" + \" \".join(_expr2sat(x, litmap)\n                               for x in ex.xs) + \")\"\n    else:\n        fstr = (\"expected ex to be a Literal or Not/Or/And/Xor/Equal op, \"\n                \"got {0.__name__}\")\n        raise ValueError(fstr.format(type(ex)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts an untyped point into an Expression point.", "response": "def upoint2exprpoint(upoint):\n    \"\"\"Convert an untyped point into an Expression point.\n\n    .. seealso::\n       For definitions of points and untyped points,\n       see the :mod:`pyeda.boolalg.boolfunc` module.\n    \"\"\"\n    point = dict()\n    for uniqid in upoint[0]:\n        point[_LITS[uniqid]] = 0\n    for uniqid in upoint[1]:\n        point[_LITS[uniqid]] = 1\n    return point"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef Not(x, simplify=True):\n    x = Expression.box(x).node\n    y = exprnode.not_(x)\n    if simplify:\n        y = y.simplify()\n    return _expr(y)", "response": "Expression negation operator\n\n    If *simplify* is ``True``, return a simplified expression."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef Or(*xs, simplify=True):\n    xs = [Expression.box(x).node for x in xs]\n    y = exprnode.or_(*xs)\n    if simplify:\n        y = y.simplify()\n    return _expr(y)", "response": "Expression disjunction ( sum OR ) operator"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef Xor(*xs, simplify=True):\n    xs = [Expression.box(x).node for x in xs]\n    y = exprnode.xor(*xs)\n    if simplify:\n        y = y.simplify()\n    return _expr(y)", "response": "Expression exclusive or operator."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ITE(s, d1, d0, simplify=True):\n    s = Expression.box(s).node\n    d1 = Expression.box(d1).node\n    d0 = Expression.box(d0).node\n    y = exprnode.ite(s, d1, d0)\n    if simplify:\n        y = y.simplify()\n    return _expr(y)", "response": "Expression If - Then - Else operator."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef Nand(*xs, simplify=True):\n    xs = [Expression.box(x).node for x in xs]\n    y = exprnode.not_(exprnode.and_(*xs))\n    if simplify:\n        y = y.simplify()\n    return _expr(y)", "response": "Expression NAND (not AND) operator\n\n    If *simplify* is ``True``, return a simplified expression."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef Xnor(*xs, simplify=True):\n    xs = [Expression.box(x).node for x in xs]\n    y = exprnode.not_(exprnode.xor(*xs))\n    if simplify:\n        y = y.simplify()\n    return _expr(y)", "response": "Expression exclusive nor operator."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning an expression that means at most one input function is true.", "response": "def OneHot0(*xs, simplify=True, conj=True):\n    \"\"\"\n    Return an expression that means\n    \"at most one input function is true\".\n\n    If *simplify* is ``True``, return a simplified expression.\n\n    If *conj* is ``True``, return a CNF.\n    Otherwise, return a DNF.\n    \"\"\"\n    xs = [Expression.box(x).node for x in xs]\n    terms = list()\n    if conj:\n        for x0, x1 in itertools.combinations(xs, 2):\n            terms.append(exprnode.or_(exprnode.not_(x0),\n                                      exprnode.not_(x1)))\n        y = exprnode.and_(*terms)\n    else:\n        for _xs in itertools.combinations(xs, len(xs) - 1):\n            terms.append(exprnode.and_(*[exprnode.not_(x) for x in _xs]))\n        y = exprnode.or_(*terms)\n    if simplify:\n        y = y.simplify()\n    return _expr(y)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef OneHot(*xs, simplify=True, conj=True):\n    xs = [Expression.box(x).node for x in xs]\n    terms = list()\n    if conj:\n        for x0, x1 in itertools.combinations(xs, 2):\n            terms.append(exprnode.or_(exprnode.not_(x0),\n                                      exprnode.not_(x1)))\n        terms.append(exprnode.or_(*xs))\n        y = exprnode.and_(*terms)\n    else:\n        for i, xi in enumerate(xs):\n            zeros = [exprnode.not_(x) for x in xs[:i] + xs[i+1:]]\n            terms.append(exprnode.and_(xi, *zeros))\n        y = exprnode.or_(*terms)\n    if simplify:\n        y = y.simplify()\n    return _expr(y)", "response": "Return an expression that means\n    exactly one input function is true."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn an expression that means exactly N input functions are true.", "response": "def NHot(n, *xs, simplify=True):\n    \"\"\"\n    Return an expression that means\n    \"exactly N input functions are true\".\n\n    If *simplify* is ``True``, return a simplified expression.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"expected n to be an int\")\n    if not 0 <= n <= len(xs):\n        fstr = \"expected 0 <= n <= {}, got {}\"\n        raise ValueError(fstr.format(len(xs), n))\n\n    xs = [Expression.box(x).node for x in xs]\n    num = len(xs)\n    terms = list()\n    for hot_idxs in itertools.combinations(range(num), n):\n        hot_idxs = set(hot_idxs)\n        _xs = [xs[i] if i in hot_idxs else exprnode.not_(xs[i])\n               for i in range(num)]\n        terms.append(exprnode.and_(*_xs))\n    y = exprnode.or_(*terms)\n    if simplify:\n        y = y.simplify()\n    return _expr(y)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an expression that means the majority of input functions are true.", "response": "def Majority(*xs, simplify=True, conj=False):\n    \"\"\"\n    Return an expression that means\n    \"the majority of input functions are true\".\n\n    If *simplify* is ``True``, return a simplified expression.\n\n    If *conj* is ``True``, return a CNF.\n    Otherwise, return a DNF.\n    \"\"\"\n    xs = [Expression.box(x).node for x in xs]\n    if conj:\n        terms = list()\n        for _xs in itertools.combinations(xs, (len(xs) + 1) // 2):\n            terms.append(exprnode.or_(*_xs))\n        y = exprnode.and_(*terms)\n    else:\n        terms = list()\n        for _xs in itertools.combinations(xs, len(xs) // 2 + 1):\n            terms.append(exprnode.and_(*_xs))\n        y = exprnode.or_(*terms)\n    if simplify:\n        y = y.simplify()\n    return _expr(y)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef Mux(fs, sel, simplify=True):\n    # convert Mux([a, b], x) to Mux([a, b], [x])\n    if isinstance(sel, Expression):\n        sel = [sel]\n\n    if len(sel) < clog2(len(fs)):\n        fstr = \"expected at least {} select bits, got {}\"\n        raise ValueError(fstr.format(clog2(len(fs)), len(sel)))\n\n    it = boolfunc.iter_terms(sel)\n    y = exprnode.or_(*[exprnode.and_(f.node, *[lit.node for lit in next(it)])\n                       for f in fs])\n    if simplify:\n        y = y.simplify()\n    return _expr(y)", "response": "Returns an expression that multiplexes a sequence of input functions over a sequence of select functions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\niterate through all satisfying points using backtrack algorithm.", "response": "def _iter_backtrack(ex, rand=False):\n    \"\"\"Iterate through all satisfying points using backtrack algorithm.\"\"\"\n    if ex is One:\n        yield dict()\n    elif ex is not Zero:\n        if rand:\n            v = random.choice(ex.inputs) if rand else ex.top\n        else:\n            v = ex.top\n        points = [{v: 0}, {v: 1}]\n        if rand:\n            random.shuffle(points)\n        for point in points:\n            for soln in _iter_backtrack(ex.restrict(point), rand):\n                soln.update(point)\n                yield soln"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _tseitin(ex, auxvarname, auxvars=None):\n    if isinstance(ex, Literal):\n        return ex, list()\n    else:\n        if auxvars is None:\n            auxvars = list()\n\n        lits = list()\n        constraints = list()\n        for x in ex.xs:\n            lit, subcons = _tseitin(x, auxvarname, auxvars)\n            lits.append(lit)\n            constraints.extend(subcons)\n\n        auxvarindex = len(auxvars)\n        auxvar = exprvar(auxvarname, auxvarindex)\n        auxvars.append(auxvar)\n\n        f = ASTOPS[ex.ASTOP](*lits)\n        constraints.append((auxvar, f))\n        return auxvar, constraints", "response": "Convert a factored expression to a literal and a list of constraints."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pushdown_not(self):\n        node = self.node.pushdown_not()\n        if node is self.node:\n            return self\n        else:\n            return _expr(node)", "response": "Return an expression with NOT operators pushed down thru dual ops."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a simplified expression.", "response": "def simplify(self):\n        \"\"\"Return a simplified expression.\"\"\"\n        node = self.node.simplify()\n        if node is self.node:\n            return self\n        else:\n            return _expr(node)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts N - ary operators to binary operators.", "response": "def to_binary(self):\n        \"\"\"Convert N-ary operators to binary operators.\"\"\"\n        node = self.node.to_binary()\n        if node is self.node:\n            return self\n        else:\n            return _expr(node)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns an equivalent expression is negation normal form.", "response": "def to_nnf(self):\n        \"\"\"Return an equivalent expression is negation normal form.\"\"\"\n        node = self.node.to_nnf()\n        if node is self.node:\n            return self\n        else:\n            return _expr(node)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an equivalent expression in disjunctive normal form.", "response": "def to_dnf(self):\n        \"\"\"Return an equivalent expression in disjunctive normal form.\"\"\"\n        node = self.node.to_dnf()\n        if node is self.node:\n            return self\n        else:\n            return _expr(node)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an equivalent expression in conjunctive normal form.", "response": "def to_cnf(self):\n        \"\"\"Return an equivalent expression in conjunctive normal form.\"\"\"\n        node = self.node.to_cnf()\n        if node is self.node:\n            return self\n        else:\n            return _expr(node)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an equivalent DNF expression that includes all prime implicants.", "response": "def complete_sum(self):\n        \"\"\"\n        Return an equivalent DNF expression that includes all prime\n        implicants.\n        \"\"\"\n        node = self.node.complete_sum()\n        if node is self.node:\n            return self\n        else:\n            return _expr(node)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the Shannon expansion with respect to a list of variables.", "response": "def expand(self, vs=None, conj=False):\n        \"\"\"Return the Shannon expansion with respect to a list of variables.\"\"\"\n        vs = self._expect_vars(vs)\n        if vs:\n            outer, inner = (And, Or) if conj else (Or, And)\n            terms = [inner(self.restrict(p),\n                           *boolfunc.point2term(p, conj))\n                     for p in boolfunc.iter_points(vs)]\n            if conj:\n                terms = [term for term in terms if term is not One]\n            else:\n                terms = [term for term in terms if term is not Zero]\n            return outer(*terms, simplify=False)\n        else:\n            return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a compact encoding for input variables.", "response": "def encode_inputs(self):\n        \"\"\"Return a compact encoding for input variables.\"\"\"\n        litmap = dict()\n        nvars = 0\n        for i, v in enumerate(self.inputs, start=1):\n            litmap[v] = i\n            litmap[~v] = -i\n            litmap[i] = v\n            litmap[-i] = ~v\n            nvars += 1\n        return litmap, nvars"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts the expression to Tseitin s encoding.", "response": "def tseitin(self, auxvarname='aux'):\n        \"\"\"Convert the expression to Tseitin's encoding.\"\"\"\n        if self.is_cnf():\n            return self\n\n        _, constraints = _tseitin(self.to_nnf(), auxvarname)\n        fst = constraints[-1][1]\n        rst = [Equal(v, ex).to_cnf() for v, ex in constraints[:-1]]\n        return And(fst, *rst)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns True if this expression is equivalent to other.", "response": "def equivalent(self, other):\n        \"\"\"Return True if this expression is equivalent to other.\"\"\"\n        f = Xor(self, self.box(other))\n        return f.satisfy_one() is None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_dot(self, name='EXPR'): # pragma: no cover\n        parts = ['graph', name, '{', 'rankdir=BT;']\n        for ex in self.iter_dfs():\n            exid = ex.node.id()\n            if ex is Zero:\n                parts += [\"n{} [label=0,shape=box];\".format(exid)]\n            elif ex is One:\n                parts += [\"n{} [label=1,shape=box];\".format(exid)]\n            elif isinstance(ex, Literal):\n                parts += ['n{} [label=\"{}\",shape=box];'.format(exid, ex)]\n            else:\n                parts += [\"n{0} [label={1.ASTOP},shape=circle];\".format(exid, ex)]\n        for ex in self.iter_dfs():\n            exid = ex.node.id()\n            if isinstance(ex, NotOp):\n                parts += [\"n{} -- n{};\".format(ex.x.node.id(), exid)]\n            elif isinstance(ex, ImpliesOp):\n                p, q = ex.xs\n                parts += [\"n{} -- n{} [label=p];\".format(p.node.id(), exid)]\n                parts += [\"n{} -- n{} [label=q];\".format(q.node.id(), exid)]\n            elif isinstance(ex, IfThenElseOp):\n                s, d1, d0 = ex.xs\n                parts += [\"n{} -- n{} [label=s];\".format(s.node.id(), exid)]\n                parts += [\"n{} -- n{} [label=d1];\".format(d1.node.id(), exid)]\n                parts += [\"n{} -- n{} [label=d0];\".format(d0.node.id(), exid)]\n            elif isinstance(ex, NaryOp):\n                for x in ex.xs:\n                    parts += [\"n{} -- n{};\".format(x.node.id(), exid)]\n        parts.append('}')\n        return \" \".join(parts)", "response": "Convert the tree to DOT language representation."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreduce to a canonical form.", "response": "def reduce(self):\n        \"\"\"Reduce to a canonical form.\"\"\"\n        support = frozenset(range(1, self.nvars+1))\n        new_clauses = set()\n        for clause in self.clauses:\n            vs = list(support - {abs(uniqid) for uniqid in clause})\n            if vs:\n                for num in range(1 << len(vs)):\n                    new_part = {v if bit_on(num, i) else ~v\n                                for i, v in enumerate(vs)}\n                    new_clauses.add(clause | new_part)\n            else:\n                new_clauses.add(clause)\n        return self.__class__(self.nvars, new_clauses)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert the DNF to an expression.", "response": "def decode(self, litmap):\n        \"\"\"Convert the DNF to an expression.\"\"\"\n        return Or(*[And(*[litmap[idx] for idx in clause])\n                    for clause in self.clauses])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\niterating through all satisfying input points.", "response": "def satisfy_all(self, **params):\n        \"\"\"Iterate through all satisfying input points.\"\"\"\n        verbosity = params.get('verbosity', 0)\n        default_phase = params.get('default_phase', 2)\n        propagation_limit = params.get('propagation_limit', -1)\n        decision_limit = params.get('decision_limit', -1)\n        seed = params.get('seed', 1)\n        yield from picosat.satisfy_all(self.nvars, self.clauses, verbosity,\n                                       default_phase, propagation_limit,\n                                       decision_limit, seed)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a solution vector to a point.", "response": "def soln2point(soln, litmap):\n        \"\"\"Convert a solution vector to a point.\"\"\"\n        return {litmap[i]: int(val > 0)\n                for i, val in enumerate(soln, start=1)}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef espresso_exprs(*exprs):\n    for f in exprs:\n        if not (isinstance(f, Expression) and f.is_dnf()):\n            raise ValueError(\"expected a DNF expression\")\n\n    support = frozenset.union(*[f.support for f in exprs])\n    inputs = sorted(support)\n\n    # Gather all cubes in the cover of input functions\n    fscover = set()\n    for f in exprs:\n        fscover.update(f.cover)\n\n    ninputs = len(inputs)\n    noutputs = len(exprs)\n\n    cover = set()\n    for fscube in fscover:\n        invec = list()\n        for v in inputs:\n            if ~v in fscube:\n                invec.append(1)\n            elif v in fscube:\n                invec.append(2)\n            else:\n                invec.append(3)\n        outvec = list()\n        for f in exprs:\n            for fcube in f.cover:\n                if fcube <= fscube:\n                    outvec.append(1)\n                    break\n            else:\n                outvec.append(0)\n\n        cover.add((tuple(invec), tuple(outvec)))\n\n    set_config(**CONFIG)\n\n    cover = espresso(ninputs, noutputs, cover, intype=FTYPE)\n    return _cover2exprs(inputs, noutputs, cover)", "response": "Return a tuple of expressions optimized using Espresso."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a tuple of expressions optimized using Espresso.", "response": "def espresso_tts(*tts):\n    \"\"\"Return a tuple of expressions optimized using Espresso.\n\n    The variadic *tts* argument is a sequence of truth tables.\n\n    For example::\n\n       >>> from pyeda.boolalg.bfarray import exprvars\n       >>> from pyeda.boolalg.table import truthtable\n       >>> X = exprvars('x', 4)\n       >>> f1 = truthtable(X, \"0000011111------\")\n       >>> f2 = truthtable(X, \"0001111100------\")\n       >>> f1m, f2m = espresso_tts(f1, f2)\n       >>> f1m.equivalent(X[3] | X[0] & X[2] | X[1] & X[2])\n       True\n       >>> f2m.equivalent(X[2] | X[0] & X[1])\n       True\n    \"\"\"\n    for f in tts:\n        if not isinstance(f, TruthTable):\n            raise ValueError(\"expected a TruthTable instance\")\n\n    support = frozenset.union(*[f.support for f in tts])\n    inputs = sorted(support)\n\n    ninputs = len(inputs)\n    noutputs = len(tts)\n\n    cover = set()\n    for i, point in enumerate(boolfunc.iter_points(inputs)):\n        invec = [2 if point[v] else 1 for v in inputs]\n        outvec = list()\n        for f in tts:\n            val = f.pcdata[i]\n            if val == PC_ZERO:\n                outvec.append(0)\n            elif val == PC_ONE:\n                outvec.append(1)\n            elif val == PC_DC:\n                outvec.append(2)\n            else:\n                raise ValueError(\"expected truth table entry in {0, 1, -}\")\n        cover.add((tuple(invec), tuple(outvec)))\n\n    set_config(**CONFIG)\n\n    cover = espresso(ninputs, noutputs, cover, intype=FTYPE|DTYPE|RTYPE)\n    inputs = [exprvar(v.names, v.indices) for v in inputs]\n    return _cover2exprs(inputs, noutputs, cover)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a cover to a tuple of Expression instances.", "response": "def _cover2exprs(inputs, noutputs, cover):\n    \"\"\"Convert a cover to a tuple of Expression instances.\"\"\"\n    fs = list()\n    for i in range(noutputs):\n        terms = list()\n        for invec, outvec in cover:\n            if outvec[i]:\n                term = list()\n                for j, v in enumerate(inputs):\n                    if invec[j] == 1:\n                        term.append(~v)\n                    elif invec[j] == 2:\n                        term.append(v)\n                terms.append(term)\n        fs.append(Or(*[And(*term) for term in terms]))\n\n    return tuple(fs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconcatenates a sequence of functions or arrays.", "response": "def fcat(*fs):\n    \"\"\"Concatenate a sequence of farrays.\n\n    The variadic *fs* input is a homogeneous sequence of functions or arrays.\n    \"\"\"\n    items = list()\n    for f in fs:\n        if isinstance(f, boolfunc.Function):\n            items.append(f)\n        elif isinstance(f, farray):\n            items.extend(f.flat)\n        else:\n            raise TypeError(\"expected Function or farray\")\n    return farray(items)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts input dimensions to a shape.", "response": "def _dims2shape(*dims):\n    \"\"\"Convert input dimensions to a shape.\"\"\"\n    if not dims:\n        raise ValueError(\"expected at least one dimension spec\")\n    shape = list()\n    for dim in dims:\n        if isinstance(dim, int):\n            dim = (0, dim)\n        if isinstance(dim, tuple) and len(dim) == 2:\n            if dim[0] < 0:\n                raise ValueError(\"expected low dimension to be >= 0\")\n            if dim[1] < 0:\n                raise ValueError(\"expected high dimension to be >= 0\")\n            if dim[0] > dim[1]:\n                raise ValueError(\"expected low <= high dimensions\")\n            start, stop = dim\n        else:\n            raise TypeError(\"expected dimension to be int or (int, int)\")\n        shape.append((start, stop))\n    return tuple(shape)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _volume(shape):\n    prod = 1\n    for start, stop in shape:\n        prod *= stop - start\n    return prod", "response": "Return the volume of a shape."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a new farray filled with zeros.", "response": "def _zeros(ftype, *dims):\n    \"\"\"Return a new farray filled with zeros.\"\"\"\n    shape = _dims2shape(*dims)\n    objs = [ftype.box(0) for _ in range(_volume(shape))]\n    return farray(objs, shape, ftype)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _vars(ftype, name, *dims):\n    shape = _dims2shape(*dims)\n    objs = list()\n    for indices in itertools.product(*[range(i, j) for i, j in shape]):\n        objs.append(_VAR[ftype](name, indices))\n    return farray(objs, shape, ftype)", "response": "Return a new farray filled with Boolean variables."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts an unsigned integer to a list of constant expressions.", "response": "def _uint2objs(ftype, num, length=None):\n    \"\"\"Convert an unsigned integer to a list of constant expressions.\"\"\"\n    if num == 0:\n        objs = [ftype.box(0)]\n    else:\n        _num = num\n        objs = list()\n        while _num != 0:\n            objs.append(ftype.box(_num & 1))\n            _num >>= 1\n\n    if length:\n        if length < len(objs):\n            fstr = \"overflow: num = {} requires length >= {}, got length = {}\"\n            raise ValueError(fstr.format(num, len(objs), length))\n        else:\n            while len(objs) < length:\n                objs.append(ftype.box(0))\n\n    return objs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _uint2farray(ftype, num, length=None):\n    if num < 0:\n        raise ValueError(\"expected num >= 0\")\n    else:\n        objs = _uint2objs(ftype, num, length)\n        return farray(objs)", "response": "Convert an unsigned integer to an farray."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a signed integer to an farray.", "response": "def _int2farray(ftype, num, length=None):\n    \"\"\"Convert a signed integer to an farray.\"\"\"\n    if num < 0:\n        req_length = clog2(abs(num)) + 1\n        objs = _uint2objs(ftype, 2**req_length + num)\n    else:\n        req_length = clog2(num + 1) + 1\n        objs = _uint2objs(ftype, num, req_length)\n\n    if length:\n        if length < req_length:\n            fstr = \"overflow: num = {} requires length >= {}, got length = {}\"\n            raise ValueError(fstr.format(num, req_length, length))\n        else:\n            sign = objs[-1]\n            objs += [sign] * (length - req_length)\n\n    return farray(objs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _itemize(objs):\n    if not isinstance(objs, collections.Sequence):\n        raise TypeError(\"expected a sequence of Function\")\n\n    isseq = [isinstance(obj, collections.Sequence) for obj in objs]\n    if not any(isseq):\n        ftype = None\n        for obj in objs:\n            if ftype is None:\n                if isinstance(obj, BinaryDecisionDiagram):\n                    ftype = BinaryDecisionDiagram\n                elif isinstance(obj, Expression):\n                    ftype = Expression\n                elif isinstance(obj, TruthTable):\n                    ftype = TruthTable\n                else:\n                    raise TypeError(\"expected valid Function inputs\")\n            elif not isinstance(obj, ftype):\n                raise ValueError(\"expected uniform Function types\")\n        return list(objs), ((0, len(objs)), ), ftype\n    elif all(isseq):\n        items = list()\n        shape = None\n        ftype = None\n        for obj in objs:\n            _items, _shape, _ftype = _itemize(obj)\n            if shape is None:\n                shape = _shape\n            elif shape != _shape:\n                raise ValueError(\"expected uniform farray dimensions\")\n            if ftype is None:\n                ftype = _ftype\n            elif ftype != _ftype:\n                raise ValueError(\"expected uniform Function types\")\n            items += _items\n        shape = ((0, len(objs)), ) + shape\n        return items, shape, ftype\n    else:\n        raise ValueError(\"expected uniform farray dimensions\")", "response": "Recursive helper function for farray."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nverifies that a shape has the right format.", "response": "def _check_shape(shape):\n    \"\"\"Verify that a shape has the right format.\"\"\"\n    if isinstance(shape, tuple):\n        for dim in shape:\n            if (isinstance(dim, tuple) and len(dim) == 2 and\n                    isinstance(dim[0], int) and isinstance(dim[1], int)):\n                if dim[0] < 0:\n                    raise ValueError(\"expected low dimension to be >= 0\")\n                if dim[1] < 0:\n                    raise ValueError(\"expected high dimension to be >= 0\")\n                if dim[0] > dim[1]:\n                    raise ValueError(\"expected low <= high dimensions\")\n            else:\n                raise TypeError(\"expected shape dimension to be (int, int)\")\n    else:\n        raise TypeError(\"expected shape to be tuple of (int, int)\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_key2sl(key):\n    if isinstance(key, (int, farray)) or key is Ellipsis:\n        return key\n    elif isinstance(key, slice):\n        # Forbid slice steps\n        if key.step is not None:\n            raise ValueError(\"farray slice step is not supported\")\n        return key\n    elif isinstance(key, boolfunc.Function):\n        return farray([key])\n    else:\n        raise TypeError(\"expected int, slice, Function, farray, or ...\")", "response": "Convert a key part to a slice part."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a key part to a slice part.", "response": "def _set_key2sl(key):\n    \"\"\"Convert a key part to a slice part.\"\"\"\n    if isinstance(key, int) or key is Ellipsis:\n        return key\n    elif isinstance(key, slice):\n        # Forbid slice steps\n        if key.step is not None:\n            raise ValueError(\"farray slice step is not supported\")\n        return key\n    else:\n        raise TypeError(\"expected int, slice, or ...\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _norm_index(dim, index, start, stop):\n    length = stop - start\n    if -length <= index < 0:\n        normindex = index + length\n    elif start <= index < stop:\n        normindex = index - start\n    else:\n        fstr = \"expected dim {} index in range [{}, {})\"\n        raise IndexError(fstr.format(dim, start, stop))\n    return normindex", "response": "Return an index normalized to an farray start index."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _norm_slice(sl, start, stop):\n    length = stop - start\n    if sl.start is None:\n        normstart = 0\n    else:\n        if sl.start < 0:\n            if sl.start < -length:\n                normstart = 0\n            else:\n                normstart = sl.start + length\n        else:\n            if sl.start > stop:\n                normstart = length\n            else:\n                normstart = sl.start - start\n    if sl.stop is None:\n        normstop = length\n    else:\n        if sl.stop < 0:\n            if sl.stop < -length:\n                normstop = 0\n            else:\n                normstop = sl.stop + length\n        else:\n            if sl.stop > stop:\n                normstop = length\n            else:\n                normstop = sl.stop - start\n    if normstop < normstart:\n        normstop = normstart\n    return slice(normstart, normstop)", "response": "Return a slice normalized to an farray start index."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn items shape filtered by a dimension slice.", "response": "def _filtdim(items, shape, dim, nsl):\n    \"\"\"Return items, shape filtered by a dimension slice.\"\"\"\n    normshape = tuple(stop - start for start, stop in shape)\n    nsl_type = type(nsl)\n    newitems = list()\n    # Number of groups\n    num = reduce(operator.mul, normshape[:dim+1])\n    # Size of each group\n    size = len(items) // num\n    # Size of the dimension\n    n = normshape[dim]\n    if nsl_type is int:\n        for i in range(num):\n            if i % n == nsl:\n                newitems += items[size*i:size*(i+1)]\n        # Collapse dimension\n        newshape = shape[:dim] + shape[dim+1:]\n    elif nsl_type is slice:\n        for i in range(num):\n            if nsl.start <= (i % n) < nsl.stop:\n                newitems += items[size*i:size*(i+1)]\n        # Reshape dimension\n        offset = shape[dim][0]\n        redim = (offset + nsl.start, offset + nsl.stop)\n        newshape = shape[:dim] + (redim, ) + shape[dim+1:]\n    # farray\n    else:\n        if nsl.size < clog2(n):\n            fstr = \"expected dim {} select to have >= {} bits, got {}\"\n            raise ValueError(fstr.format(dim, clog2(n), nsl.size))\n        groups = [list() for _ in range(n)]\n        for i in range(num):\n            groups[i % n] += items[size*i:size*(i+1)]\n        for muxins in zip(*groups):\n            it = boolfunc.iter_terms(nsl._items)\n            xs = [reduce(operator.and_, (muxin, ) + next(it))\n                  for muxin in muxins]\n            newitems.append(reduce(operator.or_, xs))\n        # Collapse dimension\n        newshape = shape[:dim] + shape[dim+1:]\n    return newitems, newshape"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\niterating through all matching coordinates in a sequence of slices.", "response": "def _iter_coords(nsls):\n    \"\"\"Iterate through all matching coordinates in a sequence of slices.\"\"\"\n    # First convert all slices to ranges\n    ranges = list()\n    for nsl in nsls:\n        if isinstance(nsl, int):\n            ranges.append(range(nsl, nsl+1))\n        else:\n            ranges.append(range(nsl.start, nsl.stop))\n    # Iterate through all matching coordinates\n    yield from itertools.product(*ranges)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef restrict(self, point):\n        items = [f.restrict(point) for f in self._items]\n        return self.__class__(items, self.shape, self.ftype)", "response": "Apply the restrict method to all functions.\n        Returns a new farray."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compose(self, mapping):\n        items = [f.compose(mapping) for f in self._items]\n        return self.__class__(items, self.shape, self.ftype)", "response": "Apply the compose method to all functions.\n        Returns a new farray."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reshape(self, *dims):\n        shape = _dims2shape(*dims)\n        if _volume(shape) != self.size:\n            raise ValueError(\"expected shape with equal volume\")\n        return self.__class__(self._items, shape, self.ftype)", "response": "Return an equivalent farray with a modified shape."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert vector to an unsigned integer if possible.", "response": "def to_uint(self):\n        \"\"\"Convert vector to an unsigned integer, if possible.\n\n        This is only useful for arrays filled with zero/one entries.\n        \"\"\"\n        num = 0\n        for i, f in enumerate(self._items):\n            if f.is_zero():\n                pass\n            elif f.is_one():\n                num += 1 << i\n            else:\n                fstr = \"expected all functions to be a constant (0 or 1) form\"\n                raise ValueError(fstr)\n        return num"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_int(self):\n        num = self.to_uint()\n        if num and self._items[-1].unbox():\n            return num - (1 << self.size)\n        else:\n            return num", "response": "Convert vector to an integer if possible."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef zext(self, num):\n        zero = self.ftype.box(0)\n        return self.__class__(self._items + [zero] * num, ftype=self.ftype)", "response": "Zero - extend this farray by num * bits."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sext(self, num):\n        sign = self._items[-1]\n        return self.__class__(self._items + [sign] * num, ftype=self.ftype)", "response": "Sign - extend this farray by num * bits.\n        Returns a new farray."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef uor(self):\n        return reduce(operator.or_, self._items, self.ftype.box(0))", "response": "Unary OR reduction operator"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef uand(self):\n        return reduce(operator.and_, self._items, self.ftype.box(1))", "response": "Unary AND reduction operator"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef uxor(self):\n        return reduce(operator.xor, self._items, self.ftype.box(0))", "response": "Unary XOR reduction operator"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rsh(self, num, cin=None):\n        if num < 0 or num > self.size:\n            raise ValueError(\"expected 0 <= num <= {0.size}\".format(self))\n        if cin is None:\n            items = [self.ftype.box(0) for _ in range(num)]\n            cin = self.__class__(items, ftype=self.ftype)\n        else:\n            if len(cin) != num:\n                raise ValueError(\"expected length of cin to be equal to num\")\n        if num == 0:\n            return self, self.__class__([], ftype=self.ftype)\n        else:\n            fs = self.__class__(self._items[num:] + cin._items,\n                                ftype=self.ftype)\n            cout = self.__class__(self._items[:num], ftype=self.ftype)\n            return fs, cout", "response": "Right shift the farray by num places."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a new object with the items in the list.", "response": "def decode(self):\n        r\"\"\"Return a :math:`N \\rightarrow 2^N` decoder.\n\n        Example Truth Table for a 2:4 decoder:\n\n        .. csv-table::\n           :header: :math:`A_1`, :math:`A_0`, \\\n                    :math:`D_3`, :math:`D_2`, :math:`D_1`, :math:`D_0`\n           :stub-columns: 2\n\n           0, 0, 0, 0, 0, 1\n           0, 1, 0, 0, 1, 0\n           1, 0, 0, 1, 0, 0\n           1, 1, 1, 0, 0, 0\n        \"\"\"\n        items = [reduce(operator.and_, boolfunc.num2term(i, self._items),\n                        self.ftype.box(1))\n                 for i in range(2 ** self.size)]\n\n        return self.__class__(items, ftype=self.ftype)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts an input key to a list of slices.", "response": "def _keys2sls(self, keys, key2sl):\n        \"\"\"Convert an input key to a list of slices.\"\"\"\n        sls = list()\n        if isinstance(keys, tuple):\n            for key in keys:\n                sls.append(key2sl(key))\n        else:\n            sls.append(key2sl(keys))\n        if len(sls) > self.ndim:\n            fstr = \"expected <= {0.ndim} slice dimensions, got {1}\"\n            raise ValueError(fstr.format(self, len(sls)))\n        return sls"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfill all '...' and ':' slice entries.", "response": "def _fill_slices(self, sls):\n        \"\"\"Fill all '...' and ':' slice entries.\"\"\"\n        # Fill '...' entries with ':'\n        nfill = self.ndim - len(sls)\n        fsls = list()\n        for sl in sls:\n            if sl is Ellipsis:\n                while nfill:\n                    fsls.append(slice(None, None))\n                    nfill -= 1\n                fsls.append(slice(None, None))\n            else:\n                fsls.append(sl)\n\n        # Append ':' to the end\n        for _ in range(self.ndim - len(fsls)):\n            fsls.append(slice(None, None))\n\n        return fsls"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert slices to a normalized tuple of int slice or farray.", "response": "def _norm_slices(self, fsls):\n        \"\"\"Convert slices to a normalized tuple of int/slice/farray.\"\"\"\n        # Normalize indices, and fill empty slice entries\n        nsls = list()\n        for i, fsl in enumerate(fsls):\n            fsl_type = type(fsl)\n            if fsl_type is int:\n                nsls.append(_norm_index(i, fsl, *self.shape[i]))\n            elif fsl_type is slice:\n                nsls.append(_norm_slice(fsl, *self.shape[i]))\n            # farray\n            else:\n                nsls.append(fsl)\n\n        return nsls"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _coord2offset(self, coord):\n        size = self.size\n        offset = 0\n        for dim, index in enumerate(coord):\n            size //= self._normshape[dim]\n            offset += size * index\n        return offset", "response": "Convert a normalized coordinate to an item offset."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _op_shape(self, other):\n        if isinstance(other, farray):\n            if self.shape == other.shape:\n                return self.shape\n            elif self.size == other.size:\n                return None\n            else:\n                raise ValueError(\"expected operand sizes to match\")\n        else:\n            raise TypeError(\"expected farray input\")", "response": "Return shape that will be used by farray constructor."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncleaning up files on server and mark the record as deleted", "response": "def delete_records(keep=20):\n    \"\"\"Clean up files on server and mark the record as deleted\"\"\"\n    sql = \"SELECT * from records where is_deleted<>1 ORDER BY id desc LIMIT -1 offset {}\".format(keep)\n    assert isinstance(g.db, sqlite3.Connection)\n    c = g.db.cursor()\n    c.execute(sql)\n    rows = c.fetchall()\n    for row in rows:\n        name = row[1]\n        xmind = join(app.config['UPLOAD_FOLDER'], name)\n        xml = join(app.config['UPLOAD_FOLDER'], name[:-5] + 'xml')\n\n        for f in [xmind, xml]:\n            if exists(f):\n                os.remove(f)\n\n        sql = 'UPDATE records SET is_deleted=1 WHERE id = ?'\n        c.execute(sql, (row[0],))\n        g.db.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef allowed_error_messages(*error_messages):\n    def wrapper(func):\n        setattr(func, ALLOWED_ERROR_MESSAGES, error_messages)\n        return func\n    return wrapper", "response": "Decorator to set ALLOWED_ERROR_MESSAGES attribute on the wrapped function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_expected_errors(self, test_method):\n        f = lambda key, default=[]: getattr(test_method, key, default)\n        expected_error_page = f(EXPECTED_ERROR_PAGE, default=None)\n        allowed_error_pages = f(ALLOWED_ERROR_PAGES)\n        expected_error_messages = f(EXPECTED_ERROR_MESSAGES)\n        allowed_error_messages = f(ALLOWED_ERROR_MESSAGES)\n        self.check_errors(\n            expected_error_page,\n            allowed_error_pages,\n            expected_error_messages,\n            allowed_error_messages,\n        )", "response": "This method is called after each test. It will read the test method informations and check if there are expected errors."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_errors(self, expected_error_page=None, allowed_error_pages=[], expected_error_messages=[], allowed_error_messages=[]):\n        # Close unexpected alerts (it's blocking).\n        self.close_alert(ignore_exception=True)\n\n        expected_error_pages = set([expected_error_page]) if expected_error_page else set()\n        allowed_error_pages = set(allowed_error_pages)\n        error_page = self.get_error_page()\n        error_pages = set([error_page]) if error_page else set()\n        if (\n                error_pages & expected_error_pages != expected_error_pages\n                or\n                error_pages - (expected_error_pages | allowed_error_pages)\n        ):\n            traceback = self.get_error_traceback()\n            raise ErrorPageException(self.current_url, error_page, expected_error_page, allowed_error_pages, traceback)\n\n        error_messages = set(self.get_error_messages())\n        expected_error_messages = set(expected_error_messages)\n        allowed_error_messages = error_messages if allowed_error_messages is ANY else set(allowed_error_messages)\n        if (\n                error_messages & expected_error_messages != expected_error_messages\n                or\n                error_messages - (expected_error_messages | allowed_error_messages)\n        ):\n            raise ErrorMessagesException(self.current_url, error_messages, expected_error_messages, allowed_error_messages)\n\n        js_errors = self.get_js_errors()\n        if js_errors:\n            raise JSErrorsException(self.current_url, js_errors)", "response": "This method checks if there is an error in the current page and if it is not raise an error page exception or ErrorMessagesException."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_error_page(self):\n        try:\n            error_page = self.get_elm(class_name='error-page')\n        except NoSuchElementException:\n            pass\n        else:\n            header = error_page.get_elm(tag_name='h1')\n            return header.text", "response": "Method returning error page. Should return string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_error_messages(self):\n        try:\n            error_elms = self.get_elms(class_name='error')\n        except NoSuchElementException:\n            return []\n        else:\n            try:\n                error_values = [error_elm.get_attribute('error') for error_elm in error_elms]\n            except Exception:\n                error_values = [error_elm.text for error_elm in error_elms]\n            finally:\n                return error_values", "response": "Method returning error messages. Should return list of messages."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fill_out_and_submit(self, data, prefix='', skip_reset=False):\n        self.fill_out(data, prefix, skip_reset)\n        self.submit()", "response": "Fills out the data and then submits the form."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fill_out(self, data, prefix='', skip_reset=False):\n        for elm_name, value in data.items():\n            FormElement(self, prefix + elm_name).fill_out(value, skip_reset)", "response": "Fill out data by dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef submit(self):\n        elm_name = '%s_submit' % self.get_attribute('id')\n        try:\n            self.click(elm_name)\n        except NoSuchElementException:\n            super(Form, self).submit()", "response": "Submits the current form by pressing enter."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nclicks on current element.", "response": "def click(self, *args, **kwds):\n        \"\"\"\n        When you not pass any argument, it clicks on current element. If you\n        pass some arguments, it works as following snippet. For more info what\n        you can pass check out method :py:meth:`~._WebdriverBaseWrapper.get_elm`.\n\n        .. code-block:: python\n\n            driver.get_elm('someid').click()\n        \"\"\"\n        if args or kwds:\n            elm = self.get_elm(*args, **kwds)\n            elm.click()\n        else:\n            super().click()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn first found element in the page.", "response": "def get_elm(\n            self,\n            id_=None, class_name=None, name=None, tag_name=None, text=None, xpath=None,\n            parent_id=None, parent_class_name=None, parent_name=None, parent_tag_name=None,\n            css_selector=None\n    ):\n        \"\"\"\n        Returns first found element. This method uses\n        :py:meth:`~._WebdriverBaseWrapper.get_elms`.\n        \"\"\"\n        elms = self.get_elms(\n            id_, class_name, name, tag_name, text, xpath,\n            parent_id, parent_class_name, parent_name, parent_tag_name,\n            css_selector\n        )\n        if not elms:\n            raise selenium_exc.NoSuchElementException(_create_exception_msg(\n                id_, class_name, name, tag_name,\n                parent_id, parent_class_name, parent_name, parent_tag_name,\n                text, xpath, css_selector, self.current_url,\n                driver=self._driver,\n            ))\n        return elms[0]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget elements from the page.", "response": "def get_elms(\n            self,\n            id_=None, class_name=None, name=None, tag_name=None, text=None, xpath=None,\n            parent_id=None, parent_class_name=None, parent_name=None, parent_tag_name=None,\n            css_selector=None\n    ):\n        \"\"\"\n        Shortcut for :py:meth:`find_element* <selenium.webdriver.remote.webelement.WebElement.find_element>`\n        methods. It's shorter and you can quickly find element in element.\n\n        .. code-block:: python\n\n            elm = driver.find_element_by_id('someid')\n            elm.find_elements_by_class_name('someclasss')\n\n            # vs.\n\n            elm = driver.get_elm(parent_id='someid', class_name='someclass')\n\n        .. versionchanged:: 2.8\n            Added ``text`` param. Use it instead of old ``find_element[s]_by_text`` methods.\n            Thanks to that it can be used also in ``wait_for_element*`` methods.\n        \"\"\"\n        if parent_id or parent_class_name or parent_name or parent_tag_name:\n            parent = self.get_elm(parent_id, parent_class_name, parent_name, parent_tag_name)\n        else:\n            parent = self\n\n        if len([x for x in (id_, class_name, tag_name, text, xpath) if x is not None]) > 1:\n            raise Exception('You can find element only by one param.')\n\n        if id_ is not None:\n            return parent.find_elements_by_id(id_)\n        if class_name is not None:\n            return parent.find_elements_by_class_name(class_name)\n        if name is not None:\n            return parent.find_elements_by_name(name)\n        if tag_name is not None:\n            return parent.find_elements_by_tag_name(tag_name)\n        if text is not None:\n            xpath = './/*/text()[contains(., \"{}\") and not(ancestor-or-self::*[@data-selenium-not-search])]/..'.format(text)\n        if xpath is not None:\n            return parent.find_elements_by_xpath(xpath)\n        if css_selector is not None:\n            return parent.find_elements_by_css_selector(css_selector)\n        raise Exception('You must specify id or name of element on which you want to click.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wait_for_element_show(self, timeout=None, message='', *args, **kwds):\n        if not timeout:\n            timeout = self.default_wait_timeout\n        if not message:\n            message = _create_exception_msg(*args, url=self.current_url, **kwds)\n\n        def callback(driver):\n            elms = driver.get_elms(*args, **kwds)\n            if not elms:\n                return False\n            try:\n                if all(not elm.is_displayed() for elm in elms):\n                    return False\n            except selenium_exc.StaleElementReferenceException:\n                # Some element can be out, but need to check all elements.\n                # Let's wait for another run.\n                return False\n            return True\n        self.wait(timeout).until(callback, message=message)\n\n        # Also return that element for which is waiting.\n        elm = self.get_elm(*args, **kwds)\n        return elm", "response": "Shortcut for waiting for visible element."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wait(self, timeout=None):\n        if not timeout:\n            timeout = self.default_wait_timeout\n        return WebDriverWait(self, timeout)", "response": "Wait for the element to be available."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the innerHTML of whole page. On page have to be tag body.", "response": "def html(self):\n        \"\"\"\n        Returns ``innerHTML`` of whole page. On page have to be tag ``body``.\n\n        .. versionadded:: 2.2\n        \"\"\"\n        try:\n            body = self.get_elm(tag_name='body')\n        except selenium_exc.NoSuchElementException:\n            return None\n        else:\n            return body.get_attribute('innerHTML')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngo to another web app.", "response": "def go_to(self, path=None, query=None):\n        \"\"\"\n        You have to pass absolute URL to method\n        :py:meth:`~selenium.webdriver.remote.webdriver.WebDriver.get`. This\n        method help you to pass only relative ``path`` and/or ``query``. See\n        method :py:meth:`.get_url` for more information.\n\n        .. versionchanged:: 2.0\n            Removed parameter ``domain``. If you want to go to completely\n            another web app, use absolute address.\n        \"\"\"\n        self.get(self.get_url(path, query))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef close_window(self, window_name=None, title=None, url=None):\n        main_window_handle = self.current_window_handle\n        self.switch_to_window(window_name, title, url)\n        self.close()\n        self.switch_to_window(main_window_handle)", "response": "This method closes the current window."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclose all not current windows. Useful for tests - after each test you can automatically close all windows.", "response": "def close_other_windows(self):\n        \"\"\"\n        Closes all not current windows. Useful for tests - after each test you\n        can automatically close all windows.\n        \"\"\"\n        main_window_handle = self.current_window_handle\n        for window_handle in self.window_handles:\n            if window_handle == main_window_handle:\n                continue\n            self.switch_to_window(window_handle)\n            self.close()\n        self.switch_to_window(main_window_handle)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncopy DocstringMeta from another instance.", "response": "def from_meta(cls, meta: \"DocstringMeta\") -> T.Any:\n        \"\"\"Copy DocstringMeta from another instance.\"\"\"\n        return cls(args=meta.args, description=meta.description)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef type_name(self) -> T.Optional[str]:\n        return self.args[1] if len(self.args) > 1 else None", "response": "Return type name associated with given docstring metadata."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef arg_name(self) -> T.Optional[str]:\n        if len(self.args) > 2:\n            return self.args[2]\n        elif len(self.args) > 1:\n            return self.args[1]\n        return None", "response": "Return argument name associated with given param."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns parameters indicated in docstring.", "response": "def params(self) -> T.List[DocstringParam]:\n        \"\"\"Return parameters indicated in docstring.\"\"\"\n        return [\n            DocstringParam.from_meta(meta)\n            for meta in self.meta\n            if meta.args[0]\n            in {\"param\", \"parameter\", \"arg\", \"argument\", \"key\", \"keyword\"}\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef raises(self) -> T.List[DocstringRaises]:\n        return [\n            DocstringRaises.from_meta(meta)\n            for meta in self.meta\n            if meta.args[0] in {\"raises\", \"raise\", \"except\", \"exception\"}\n        ]", "response": "Return exceptions indicated in docstring."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning return information indicated in docstring.", "response": "def returns(self) -> T.Optional[DocstringReturns]:\n        \"\"\"Return return information indicated in docstring.\"\"\"\n        try:\n            return next(\n                DocstringReturns.from_meta(meta)\n                for meta in self.meta\n                if meta.args[0] in {\"return\", \"returns\", \"yield\", \"yields\"}\n            )\n        except StopIteration:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the given text into its components.", "response": "def parse(text: str, style: Style = Style.auto) -> Docstring:\n    \"\"\"\n    Parse the docstring into its components.\n\n    :param text: docstring text to parse\n    :param style: docstring style\n    :returns: parsed docstring representation\n    \"\"\"\n\n    if style != Style.auto:\n        return _styles[style](text)\n    rets = []\n    for parse_ in _styles.values():\n        try:\n            rets.append(parse_(text))\n        except ParseError as e:\n            exc = e\n    if not rets:\n        raise exc\n    return sorted(rets, key=lambda d: len(d.meta), reverse=True)[0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds the docstring meta element.", "response": "def _build_meta(text: str, title: str) -> DocstringMeta:\n    \"\"\"Build docstring element.\n\n    :param text: docstring element text\n    :param title: title of section containing element\n    :return:\n    \"\"\"\n\n    meta = _sections[title]\n    if meta == \"returns\" and \":\" not in text.split()[0]:\n        return DocstringMeta([meta], description=text)\n\n    # Split spec and description\n    before, desc = text.split(\":\", 1)\n    if desc:\n        desc = desc[1:] if desc[0] == \" \" else desc\n        if \"\\n\" in desc:\n            first_line, rest = desc.split(\"\\n\", 1)\n            desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n        desc = desc.strip(\"\\n\")\n\n    # Build Meta args\n    m = re.match(r\"(\\S+) \\((\\S+)\\)$\", before)\n    if meta == \"param\" and m:\n        arg_name, type_name = m.group(1, 2)\n        args = [meta, type_name, arg_name]\n    else:\n        args = [meta, before]\n\n    return DocstringMeta(args, description=desc)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(text: str) -> Docstring:\n    ret = Docstring()\n    if not text:\n        return ret\n\n    # Clean according to PEP-0257\n    text = inspect.cleandoc(text)\n\n    # Find first title and split on its position\n    match = _titles_re.search(text)\n    if match:\n        desc_chunk = text[: match.start()]\n        meta_chunk = text[match.start() :]\n    else:\n        desc_chunk = text\n        meta_chunk = \"\"\n\n    # Break description into short and long parts\n    parts = desc_chunk.split(\"\\n\", 1)\n    ret.short_description = parts[0] or None\n    if len(parts) > 1:\n        long_desc_chunk = parts[1] or \"\"\n        ret.blank_after_short_description = long_desc_chunk.startswith(\"\\n\")\n        ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n        ret.long_description = long_desc_chunk.strip() or None\n\n    # Split by sections determined by titles\n    matches = list(_titles_re.finditer(meta_chunk))\n    if not matches:\n        return ret\n    splits = []\n    for j in range(len(matches) - 1):\n        splits.append((matches[j].end(), matches[j + 1].start()))\n    splits.append((matches[-1].end(), len(meta_chunk)))\n\n    chunks = {}\n    for j, (start, end) in enumerate(splits):\n        title = matches[j].group(1)\n        if title not in _valid:\n            continue\n        chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n    if not chunks:\n        return ret\n\n    # Add elements from each chunk\n    for title, chunk in chunks.items():\n        # Determine indent\n        indent_match = re.search(r\"^\\s+\", chunk)\n        if not indent_match:\n            raise ParseError(f'Can\\'t infer indent from \"{chunk}\"')\n        indent = indent_match.group()\n\n        # Check for returns/yeilds (only one element)\n        if _sections[title] in (\"returns\", \"yields\"):\n            part = inspect.cleandoc(chunk)\n            ret.meta.append(_build_meta(part, title))\n            continue\n\n        # Split based on lines which have exactly that indent\n        _re = \"^\" + indent + r\"(?=\\S)\"\n        c_matches = list(re.finditer(_re, chunk, flags=re.M))\n        if not c_matches:\n            raise ParseError(f'No specification for \"{title}\": \"{chunk}\"')\n        c_splits = []\n        for j in range(len(c_matches) - 1):\n            c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n        c_splits.append((c_matches[-1].end(), len(chunk)))\n        for j, (start, end) in enumerate(c_splits):\n            part = chunk[start:end].strip(\"\\n\")\n            ret.meta.append(_build_meta(part, title))\n\n    return ret", "response": "Parses the Google - style docstring into its components."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _determine_tool(files):\n    for file in files:\n        linker_ext = file.split('.')[-1]\n        if \"sct\" in linker_ext or \"lin\" in linker_ext:\n            yield (str(file),\"uvision\")\n        elif \"ld\" in linker_ext:\n            yield (str(file),\"make_gcc_arm\")\n        elif \"icf\" in linker_ext:\n            yield (str(file),\"iar_arm\")", "response": "Yields tuples of the form of ( linker file tool the file links for"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_yaml(directory, project_name, board,output_dir):\n    # lay out what the common section a project yaml file will look like\n    # The value mapped to by each key are the file extensions that will help us get valid files for each section\n    logger.debug(\"Project name: %s, Target: %s\"%(project_name,board))\n    common_section = {\n        'linker_file': FILES_EXTENSIONS['linker_file'],\n        'sources': FILES_EXTENSIONS['source_files_c'] + FILES_EXTENSIONS['source_files_cpp'] +\n                   FILES_EXTENSIONS['source_files_s'] + FILES_EXTENSIONS['source_files_obj'],\n        'includes': FILES_EXTENSIONS['include_files']\n    }\n\n    # will be written to projects.yaml\n    root = os.path.relpath(directory)\n    projects_yaml = {\n        'projects': {\n            project_name:\n                ['project.yaml']\n        },\n        'settings': {'export_dir': os.path.relpath(output_dir)}\n    }\n\n    # will be written to project.yaml\n    project_yaml = {\n        'common': {},\n        'tool_specific': {}\n    }\n    # iterate over the common section defined above\n    for section, extensions in common_section.items():\n        # look for files in this directory that have the defined extensions, and add them to our project file\n        project_yaml['common'][section] = _scan(section, directory,extensions)\n\n    project_yaml['common']['target'] = [board] # user passes target in command line\n\n    \"\"\"Find what tool the linker works for - if multiple linkers in this dir, project_yaml['common']['linker_file']\n        is a list. Tools is an iterator\"\"\"\n    tools = _determine_tool(project_yaml['common']['linker_file'])\n\n    linkers = {}   # dictionary containing all linker files in the project directory\n\n    # exhaust the iterator and add its yielded values to linkers\n    for (file,tool) in tools:\n        if tool in linkers:\n            linkers[tool].append(file)\n        else:\n            linkers[tool] = [file]\n\n    for tool, linker in linkers.items():\n        if len(linker) > 1:\n            # The project directory defined more than one linker for a tool\n            print(\"\\nMultipe linkers found for \" + tool + \"\\n\")\n            for i, file in enumerate(linker):\n                print(str(i) + \": \" + file)\n            answer = raw_input('\\nWhich file do you want? ')\n            while int(answer) not in range(0,len(linker)):\n                answer = raw_input('Answer not in list. Which file do you want? ')\n            project_yaml['tool_specific'][tool] = {'linker_file': [linkers[tool][int(answer)]]}\n        else:\n            project_yaml['tool_specific'][tool] = {'linker_file': linker}\n\n    # linker file is now in tool_specific section\n    del project_yaml['common']['linker_file']\n\n    ret = _generate_file(\"projects.yaml\", projects_yaml)\n    if ret < 0: # make sure the first file generated correctly\n        return -1\n    ret = _generate_file(\"project.yaml\", project_yaml)\n    return ret", "response": "Create a project. yaml file for the given project."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_option(self, settings, find_key):\n        # This is used as in IAR template, everything \n        # is as an array with random positions. We look for key with an index\n        for option in settings:\n            if option['name'] == find_key:\n                return settings.index(option)", "response": "Return the index of a specific option in the settings array"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the options for the ICCARM and C ++ options.", "response": "def _ewp_iccarm_set(self, ewp_dic, project_dic):\n        \"\"\" C/C++ options (ICCARM) \"\"\"\n        index_iccarm = self._get_option(ewp_dic, 'ICCARM')\n        index_option = self._get_option(ewp_dic[index_iccarm]['data']['option'], 'CCDefines')\n        self._set_multiple_option(ewp_dic[index_iccarm]['data']['option'][index_option], project_dic['macros'])\n        index_option = self._get_option(ewp_dic[index_iccarm]['data']['option'], 'CCIncludePath2')\n        self._set_multiple_option(ewp_dic[index_iccarm]['data']['option'][index_option], project_dic['include_paths'])\n\n        iccarm_dic = ewp_dic[index_iccarm]['data']['option']\n        self._ewp_flags_set(iccarm_dic, project_dic, 'cxx_flags', self.FLAG_TO_IAR['cxx_flags'])\n        self._ewp_flags_set(iccarm_dic, project_dic, 'c_flags', self.FLAG_TO_IAR['c_flags'])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _ewp_aarm_set(self, ewp_dic, project_dic):\n        index_aarm = self._get_option(ewp_dic, 'AARM')\n\n        aarm_dic = ewp_dic[index_aarm]['data']['option']\n        self._ewp_flags_set(aarm_dic, project_dic, 'asm_flags', self.FLAG_TO_IAR['asm_flags'])", "response": "Set the Assembly flags for the A ARM."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the Linker options for an Ilink", "response": "def _ewp_ilink_set(self, ewp_dic, project_dic):\n        \"\"\" Linker options (ILINK) \"\"\"\n        index_ilink = self._get_option(ewp_dic, 'ILINK')\n        index_option = self._get_option(ewp_dic[index_ilink]['data']['option'], 'IlinkIcfFile')\n        self._set_option(ewp_dic[index_ilink]['data']['option'][index_option], project_dic['linker_file'])\n\n        ilink_dic = ewp_dic[index_ilink]['data']['option']\n        self._ewp_flags_set(ilink_dic, project_dic, 'ld_flags', self.FLAG_TO_IAR['ld_flags'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _ewp_flags_set(self, ewp_dic_subset, project_dic, flag_type, flag_dic):\n        try:\n            if flag_type in project_dic['misc'].keys():\n                # enable commands\n                index_option = self._get_option(ewp_dic_subset, flag_dic['enable'])\n                self._set_option(ewp_dic_subset[index_option], '1')\n\n                index_option = self._get_option(ewp_dic_subset, flag_dic['set'])\n                if type(ewp_dic_subset[index_option]['state']) != list:\n                    # if it's string, only one state\n                    previous_state = ewp_dic_subset[index_option]['state']\n                    ewp_dic_subset[index_option]['state'] = []\n                    ewp_dic_subset[index_option]['state'].append(previous_state)\n\n                for item in project_dic['misc'][flag_type]:\n                    ewp_dic_subset[index_option]['state'].append(item)\n        except KeyError:\n            return", "response": "Sets flags from misc to ewp project"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _ewp_files_set(self, ewp_dic, project_dic):\n        # empty any files in the template which are not grouped\n        try:\n            ewp_dic['project']['file'] = []\n        except KeyError:\n            pass\n        # empty groups\n        ewp_dic['project']['group'] = []\n        i = 0\n        for group_name, files in project_dic['groups'].items():\n            ewp_dic['project']['group'].append({'name': group_name, 'file': []})\n            for file in files:\n                ewp_dic['project']['group'][i]['file'].append({'name': file})\n            ewp_dic['project']['group'][i]['file'] = sorted(ewp_dic['project']['group'][i]['file'], key=lambda x: os.path.basename(x['name'].lower()))\n            i += 1", "response": "Fills the ewp dictionary with the files in the template which are not grouped"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _clean_xmldict_single_dic(self, dictionary):\n        for k, v in dictionary.items():\n            if v is None:\n                dictionary[k] = ''", "response": "Remove None values from the dic and replace them with empty strings"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _fix_paths(self, data):\n        data['include_paths'] = [join('$PROJ_DIR$', path) for path in data['include_paths']]\n\n        if data['linker_file']:\n            data['linker_file'] = join('$PROJ_DIR$', data['linker_file'])\n\n        data['groups'] = {}\n        for attribute in SOURCE_KEYS:\n            for k, v in data[attribute].items():\n                if k not in data['groups']:\n                    data['groups'][k] = []\n                data['groups'][k].extend([join('$PROJ_DIR$', file) for file in v])\n        for k,v in data['include_files'].items():\n            if k not in data['groups']:\n                data['groups'][k] = []\n            data['groups'][k].extend([join('$PROJ_DIR$', file) for file in v])\n\n        # sort groups\n        data['groups'] = OrderedDict(sorted(data['groups'].items(), key=lambda t: t[0]))", "response": "Fix all paths needed to be fixed - add PROJ_DIR prefix + normalize"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _export_single_project(self):\n        expanded_dic = self.workspace.copy()\n\n        self._fix_paths(expanded_dic)\n\n        # generic tool template specified or project\n        if expanded_dic['template']:\n            template_ewp = False\n            template_ewd = False\n            # process each template file\n            for template in expanded_dic['template']:\n                template = join(getcwd(), template)\n                # we support .ewp or .ewp.tmpl templates\n                if os.path.splitext(template)[1] == '.ewp' or re.match('.*\\.ewp.tmpl$', template):\n                    try:\n                        ewp_dic = xmltodict.parse(open(template), dict_constructor=dict)\n                        template_ewp = True\n                    except IOError:\n                        logger.info(\"Template file %s not found\" % template)\n                        ewp_dic = xmltodict.parse(open(self.ewp_file).read())\n                if os.path.splitext(template)[1] == '.ewd' or re.match('.*\\.ewd.tmpl$', template):\n                    try:\n                        ewd_dic = xmltodict.parse(open(template), dict_constructor=dict)\n                        template_ewd = True\n                    except IOError:\n                        logger.info(\"Template file %s not found\" % template)\n                        ewd_dic = xmltodict.parse(open(self.ewd_file).read())\n                # handle non valid template files or not specified\n                if not template_ewp and template_ewd:\n                    ewp_dic, _ = self._get_default_templates() \n                elif not template_ewd and template_ewp:\n                    _, ewd_dic = self._get_default_templates()\n                else:\n                    ewp_dic, ewd_dic = self._get_default_templates()\n        elif 'iar' in self.env_settings.templates.keys():\n            template_ewp = False\n            template_ewd = False\n            # template overrides what is set in the yaml files\n            for template in self.env_settings.templates['iar']:\n                template = join(getcwd(), template)\n                if os.path.splitext(template)[1] == '.ewp' or re.match('.*\\.ewp.tmpl$', template):\n                    try:\n                        ewp_dic = xmltodict.parse(open(template), dict_constructor=dict)\n                        template_ewp = True\n                    except IOError:\n                        logger.info(\"Template file %s not found\" % template)\n                        ewp_dic = xmltodict.parse(open(self.ewp_file).read())\n                if os.path.splitext(template)[1] == '.ewd' or re.match('.*\\.ewd.tmpl$', template):\n                    # get ewd template\n                    try:\n                        ewd_dic = xmltodict.parse(open(template), dict_constructor=dict)\n                        template_ewd = True\n                    except IOError:\n                        logger.info(\"Template file %s not found\" % template)\n                        ewd_dic = xmltodict.parse(open(self.ewd_file).read())\n                # handle non valid template files or not specified\n                if not template_ewp and template_ewd:\n                    ewp_dic, _ = self._get_default_templates() \n                elif not template_ewd and template_ewp:\n                    _, ewd_dic = self._get_default_templates()\n                else:\n                    ewp_dic, ewd_dic = self._get_default_templates()\n        else:\n            ewp_dic, ewd_dic = self._get_default_templates()\n\n        eww = None\n        if self.workspace['singular']:\n            # TODO 0xc0170: if we use here self.definitions.eww, travis fails. I cant reproduce it and dont see\n            # eww used anywhere prior to exporting this.\n            eww_dic = {u'workspace': {u'project': {u'path': u''}, u'batchBuild': None}}\n            # set eww\n            self._eww_set_path_single_project(eww_dic, expanded_dic['name'])\n            eww_xml = xmltodict.unparse(eww_dic, pretty=True)\n            project_path, eww = self.gen_file_raw(eww_xml, '%s.eww' % expanded_dic['name'], expanded_dic['output_dir']['path'])\n\n\n        try:\n            ewp_configuration = ewp_dic['project']['configuration'][0]\n            logging.debug(\"Provided .ewp file has multiple configuration, we use only the first one\")\n            ewp_dic['project']['configuration'] = ewp_dic['project']['configuration'][0]\n        except KeyError:\n            ewp_configuration = ewp_dic['project']['configuration']\n\n        try:\n            ewp_configuration = ewp_dic['project']['configuration'][0]\n            logging.debug(\"Provided .ewp file has multiple configuration, we use only the first one\")\n            ewp_dic['project']['configuration'] = ewp_dic['project']['configuration'][0]\n        except KeyError:\n            ewp_configuration = ewp_dic['project']['configuration']\n\n        # replace all None with empty strings ''\n        self._clean_xmldict_ewp(ewp_configuration)\n        #self._clean_xmldict_ewd(ewd_dic)\n\n        try:\n            self._ewp_set_name(ewp_configuration, expanded_dic['name'])\n        except KeyError:\n            raise RuntimeError(\"The IAR template is not valid .ewp file\")\n\n        # set ARM toolchain and project name\\\n        self._ewp_set_toolchain(ewp_configuration, 'ARM')\n\n        # set common things we have for IAR\n        self._ewp_general_set(ewp_configuration['settings'], expanded_dic)\n        self._ewp_iccarm_set(ewp_configuration['settings'], expanded_dic)\n        self._ewp_aarm_set(ewp_configuration['settings'], expanded_dic)\n        self._ewp_ilink_set(ewp_configuration['settings'], expanded_dic)\n        self._ewp_files_set(ewp_dic, expanded_dic)\n\n        # set target only if defined, otherwise use from template/default one\n        if expanded_dic['target']:\n            # get target definition (target + mcu)\n            proj_def = ProGenDef('iar')\n            if not proj_def.is_supported(expanded_dic['target'].lower()):\n                raise RuntimeError(\"Target %s is not supported.\" % expanded_dic['target'].lower())\n            mcu_def_dic = proj_def.get_tool_definition(expanded_dic['target'].lower())\n            if not mcu_def_dic:\n                 raise RuntimeError(\n                    \"Mcu definitions were not found for %s. Please add them to https://github.com/project-generator/project_generator_definitions\" % expanded_dic['target'].lower())\n            self._normalize_mcu_def(mcu_def_dic)\n            logger.debug(\"Mcu definitions: %s\" % mcu_def_dic)\n            self._ewp_set_target(ewp_configuration['settings'], mcu_def_dic)\n\n            try:\n                debugger = proj_def.get_debugger(expanded_dic['target'])\n                self._ewd_set_debugger(ewd_dic['project']['configuration']['settings'], debugger)\n            except KeyError as err:\n                # TODO: worth reporting?\n                pass\n\n        # overwrite debugger only if defined in the project file, otherwise use either default or from template\n        if expanded_dic['debugger']:\n            try:\n                self._ewd_set_debugger(ewd_dic['project']['configuration']['settings'], expanded_dic['debugger'])\n            except KeyError:\n                raise RuntimeError(\"Debugger %s is not supported\" % expanded_dic['debugger'])\n\n        self._ewd_set_name(ewd_dic['project']['configuration'], expanded_dic['name'])\n\n        # IAR uses ident 2 spaces, encoding iso-8859-1\n        ewp_xml = xmltodict.unparse(ewp_dic, encoding='iso-8859-1', pretty=True, indent='  ')\n        project_path, ewp = self.gen_file_raw(ewp_xml, '%s.ewp' % expanded_dic['name'], expanded_dic['output_dir']['path'])\n\n        ewd_xml = xmltodict.unparse(ewd_dic, encoding='iso-8859-1', pretty=True, indent='  ')\n        project_path, ewd = self.gen_file_raw(ewd_xml, '%s.ewd' % expanded_dic['name'], expanded_dic['output_dir']['path'])\n        return project_path, [ewp, eww, ewd]", "response": "A single project export"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate a file using Jinja2.", "response": "def gen_file_jinja(self, template_file, data, output, dest_path):\n        if not os.path.exists(dest_path):\n            os.makedirs(dest_path)\n        output = join(dest_path, output)\n        logger.debug(\"Generating: %s\" % output)\n\n        \"\"\" Fills data to the project template, using jinja2. \"\"\"\n        env = Environment()\n        env.loader = FileSystemLoader(self.TEMPLATE_DIR)\n        # TODO: undefined=StrictUndefined - this needs fixes in templates\n        template = env.get_template(template_file)\n        target_text = template.render(data)\n\n        open(output, \"w\").write(target_text)\n        return dirname(output), output"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexpanding data for uvision", "response": "def _expand_data(self, old_data, new_data, group):\n        \"\"\" data expansion - uvision needs filename and path separately. \"\"\"\n        for file in old_data:\n            if file:\n                extension = file.split(\".\")[-1].lower()\n                if extension in self.file_types.keys():\n                    new_data['groups'][group].append(self._expand_one_file(normpath(file),\n                                                                           new_data, extension))\n                else:\n                    logger.debug(\"Filetype for file %s not recognized\" % file)\n        if hasattr(self, '_expand_sort_key'):\n            new_data['groups'][group] = sorted(new_data['groups'][group],\n                                               key=self._expand_sort_key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_groups(self, data):\n        groups = []\n        for attribute in SOURCE_KEYS:\n            for k, v in data[attribute].items():\n                if k == None:\n                    k = 'Sources'\n                if k not in groups:\n                    groups.append(k)\n        for k, v in data['include_files'].items():\n            if k == None:\n                k = 'Includes'\n            if k not in groups:\n                groups.append(k)\n        return groups", "response": "Get all groups defined in the data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprocessing the single project and generates a single project file.", "response": "def _export_single_project(self):\n        \"\"\" Processes groups and misc options specific for CoIDE, and run generator \"\"\"\n        expanded_dic = self.workspace.copy()\n\n        # TODO 0xc0170: fix misc , its a list with a dictionary\n        if 'misc' in expanded_dic and bool(expanded_dic['misc']):\n            print (\"Using deprecated misc options for coide. Please use template project files.\")\n\n        groups = self._get_groups(self.workspace)\n        expanded_dic['groups'] = {}\n        for group in groups:\n            expanded_dic['groups'][group] = []\n        self._iterate(self.workspace, expanded_dic)\n\n        # generic tool template specified or project\n        if expanded_dic['template']:\n            for template in expanded_dic['template']:\n                template = join(getcwd(), template)\n                if splitext(template)[1] == '.coproj' or re.match('.*\\.coproj.tmpl$', template):\n                    try:\n                        coproj_dic = xmltodict.parse(open(template))\n                    except IOError:\n                        logger.info(\"Template file %s not found. Using default template\" % template)\n                        coproj_dic = self.definitions.coproj_file\n                else:\n                    logger.info(\"Template file %s contains unknown template extension (.coproj/.coproj.tmpl are valid). Using default one\" % template)\n                    coproj_dic = self.definitions.coproj_file\n        elif 'coide' in self.env_settings.templates.keys():\n            # template overrides what is set in the yaml files\n            for template in self.env_settings.templates['coide']:\n                template = join(getcwd(), template)\n                if splitext(template)[1] == '.coproj' or re.match('.*\\.coproj.tmpl$', template):\n                    try:\n                        coproj_dic = xmltodict.parse(open(template))\n                    except IOError:\n                        logger.info(\"Template file %s not found. Using default template\" % template)\n                        coproj_dic = self.definitions.coproj_file\n                else:\n                    logger.info(\"Template file %s contains unknown template extension (.coproj/.coproj.tmpl are valid). Using default one\" % template)\n                    coproj_dic = self.definitions.coproj_file\n        else:\n            # setting values from the yaml files\n            coproj_dic = self.definitions.coproj_file\n\n        # set name and target\n        try:\n            coproj_dic['Project']['@name'] = expanded_dic['name']\n        except KeyError:\n            raise RuntimeError(\"The coide template is not valid .coproj file\")\n\n        coproj_dic['Project']['Target']['@name'] = expanded_dic['name']\n        # library/exe\n        coproj_dic['Project']['Target']['BuildOption']['Output']['Option'][0]['@value'] = 0 if expanded_dic['output_type'] == 'exe' else 1\n\n        # Fill in progen data to the coproj_dic\n        self._coproj_set_files(coproj_dic, expanded_dic)\n        self._coproj_set_macros(coproj_dic, expanded_dic)\n        self._coproj_set_includepaths(coproj_dic, expanded_dic)\n        self._coproj_set_linker(coproj_dic, expanded_dic)\n\n        # set target only if defined, otherwise use from template/default one\n        if expanded_dic['target']:\n            pro_def = ProGenDef('coide')\n            if not pro_def.is_supported(expanded_dic['target'].lower()):\n                raise RuntimeError(\"Target %s is not supported.\" % expanded_dic['target'].lower())\n            mcu_def_dic = pro_def.get_tool_definition(expanded_dic['target'].lower())\n            if not mcu_def_dic:\n                 raise RuntimeError(\n                    \"Mcu definitions were not found for %s. Please add them to https://github.com/0xc0170/project_generator_definitions\"\n                    % expanded_dic['target'].lower())\n            self._normalize_mcu_def(mcu_def_dic)\n            logger.debug(\"Mcu definitions: %s\" % mcu_def_dic)\n            # correct attributes from definition, as yaml does not allowed multiple keys (=dict), we need to\n            # do this magic.\n            for k, v in mcu_def_dic['Device'].items():\n                del mcu_def_dic['Device'][k]\n                mcu_def_dic['Device']['@' + k] = str(v)\n            memory_areas = []\n            for k, v in mcu_def_dic['MemoryAreas'].items():\n                # ??? duplicate use of k\n                for k, att in v.items():\n                    del v[k]\n                    v['@' + k] = str(att)\n                memory_areas.append(v)\n\n            coproj_dic['Project']['Target']['Device'].update(mcu_def_dic['Device'])\n            # TODO 0xc0170: fix debug options\n            # coproj_dic['Project']['Target']['DebugOption'].update(mcu_def_dic['DebugOption'])\n            coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'] = memory_areas\n\n            # TODO 0xc0170: create a method and look at finding that option if we can reuse already defined method\n            try:\n                # find debugger definitions in the list of options\n                index = 0\n                for option in coproj_dic['Project']['Target']['DebugOption']['Option']:\n                    # ??? k, v not used ???\n                    for k, v in option.items():\n                        if option['@name'] == 'org.coocox.codebugger.gdbjtag.core.adapter':\n                            found = index\n                index += 1\n                debugger_name =pro_def.get_debugger(expanded_dic['target'])['name']\n                coproj_dic['Project']['Target']['DebugOption']['Option'][found]['@value'] = self.definitions.debuggers[debugger_name]['Target']['DebugOption']['org.coocox.codebugger.gdbjtag.core.adapter']\n            except (TypeError, KeyError) as err:\n                pass\n\n\n        # get debugger definitions\n        if expanded_dic['debugger']:\n            try:\n                # find debugger definitions in the list of options\n                index = 0\n                for option in coproj_dic['Project']['Target']['DebugOption']['Option']:\n                    # ??? k, v not used ???\n                    for k, v in option.items():\n                        if option['@name'] == 'org.coocox.codebugger.gdbjtag.core.adapter':\n                            found = index\n                index += 1\n                coproj_dic['Project']['Target']['DebugOption']['Option'][found]['@value'] = self.definitions.debuggers[expanded_dic['debugger']]['Target']['DebugOption']['org.coocox.codebugger.gdbjtag.core.adapter']\n            except KeyError:\n                raise RuntimeError(\"Debugger %s is not supported\" % expanded_dic['debugger'])\n\n        # Project file\n        # somehow this xml is not compatible with coide, coide v2.0 changing few things, lets use jinja\n        # for now, more testing to get xml output right. Jinja template follows the xml dictionary,which is\n        # what we want anyway.\n        # coproj_xml = xmltodict.unparse(coproj_dic, pretty=True)\n        project_path, projfile = self.gen_file_jinja(\n            'coide.coproj.tmpl', coproj_dic, '%s.coproj' % expanded_dic['name'], expanded_dic['output_dir']['path'])\n        return project_path, projfile"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a new project file for the current project and returns it", "response": "def export_project(self):\n        \"\"\" Processes groups and misc options specific for eclipse, and run generator \"\"\"\n\n        output = copy.deepcopy(self.generated_project)\n        data_for_make = self.workspace.copy()\n\n        self.exporter.process_data_for_makefile(data_for_make)\n        output['path'], output['files']['makefile'] = self.gen_file_jinja('makefile_gcc.tmpl', data_for_make, 'Makefile', data_for_make['output_dir']['path'])\n\n        expanded_dic = self.workspace.copy()\n        expanded_dic['rel_path'] = data_for_make['output_dir']['rel_path']\n        groups = self._get_groups(expanded_dic)\n        expanded_dic['groups'] = {}\n        for group in groups:\n            expanded_dic['groups'][group] = []\n        self._iterate(self.workspace, expanded_dic)\n\n        # Project file\n        project_path, output['files']['cproj'] = self.gen_file_jinja(\n            'eclipse_makefile.cproject.tmpl', expanded_dic, '.cproject', data_for_make['output_dir']['path'])\n        project_path, output['files']['proj_file'] = self.gen_file_jinja(\n            'eclipse.project.tmpl', expanded_dic, '.project', data_for_make['output_dir']['path'])\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate(self, tool, copied=False, copy=False):\n\n        # copied - already done by external script, copy - do actual copy\n\n        tools = []\n        if not tool:\n            logger.info(\"Workspace supports one tool for all projects within.\")\n            return -1\n        else:\n            tools = [tool]\n\n        result = 0\n        for export_tool in tools:\n            tool_export = ToolsSupported().get_tool(export_tool)\n            if tool_export is None:\n                result = -1\n                continue\n\n            project_export_dir_overwrite = False\n            if self.settings.export_location_format != self.settings.DEFAULT_EXPORT_LOCATION_FORMAT:\n                location_format = self.settings.export_location_format\n            else:\n                if 'export_dir' in self.workspace_settings:\n                    location_format = self.workspace_settings['export_dir'][0]\n                    project_export_dir_overwrite = True\n                else:\n                    location_format = self.settings.export_location_format\n\n            # substitute all of the different dynamic values\n            location = PartialFormatter().format(location_format, **{\n                'project_name': self.name,\n                'tool': tool,\n                'workspace_name': self.name\n            })\n\n            workspace_dic = {\n                'projects': [],\n                'settings': {\n                    'name': self.name,\n                    'path': os.path.normpath(location),\n                },\n            }\n\n            for project in self.projects:\n                generated_files = {\n                    'projects' : [],\n                    'workspaces': [],\n                }\n\n                if project_export_dir_overwrite:\n                    project.project['common']['export_dir'] = location\n                # Merge all dics, copy sources if required, correct output dir. This happens here\n                # because we need tool to set proper path (tool might be used as string template)\n                project._fill_export_dict(export_tool, copied)\n\n                if copy:\n                    project._copy_sources_to_generated_destination()\n                project.project['export']['singular'] = False\n                files = tool_export(project.project['export'], self.settings).export_project()\n                # we gather all generated files, needed for workspace files\n                workspace_dic['projects'].append(files)\n                generated_files['projects'].append(files)\n\n            # all projects are genereated, now generate workspace files\n            generated_files['workspaces'] = tool_export(workspace_dic, self.settings).export_workspace()\n\n            self.generated_files[export_tool] = generated_files\n            return result", "response": "Generates a workspace for the specified tool."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a dictionary of project data.", "response": "def get_project_template(name=\"Default\", output_type='exe', debugger=None, build_dir='build'):\n        \"\"\" Project data (+ data) \"\"\"\n\n        project_template = {\n            'build_dir' : build_dir,  # Build output path\n            'debugger' : debugger,    # Debugger\n            'export_dir': '',         # Export directory path\n            'name': name,             # project name\n            'output_type': output_type, # output type, default - exe\n            'target': '',             # target\n            'tools_supported': [],    # Tools which are supported,\n        }\n        project_template.update(ProjectTemplate._get_common_data_template())\n        project_template.update(ProjectTemplate._get_tool_specific_data_template())\n        return project_template"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nuses tool_supported or tool", "response": "def _validate_tools(self, tool):\n        \"\"\" Use tool_supported or tool \"\"\"\n\n        tools = []\n        if not tool:\n            if len(self.project['common']['tools_supported']) == 0:\n                logger.info(\"No tool defined.\")\n                return -1\n            tools = self.project['common']['tools_supported']\n        else:\n            tools = [tool]\n        return tools"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncopies all sources to generated directory - generated dir", "response": "def _copy_sources_to_generated_destination(self):\n        \"\"\" Copies all project files to specified directory - generated dir \"\"\"\n\n        files = []\n        for key in FILES_EXTENSIONS.keys():\n            if type(self.project['export'][key]) is dict:\n                for k,v in self.project['export'][key].items():\n                    files.extend(v)\n            elif type(self.project['export'][key]) is list:\n                files.extend(self.project['export'][key])\n            else:\n                files.append(self.project['export'][key])\n\n        destination = os.path.join(self.settings.root, self.project['export']['output_dir']['path'])\n        if os.path.exists(destination):\n            shutil.rmtree(destination)\n        for item in files:\n            s = os.path.join(self.settings.root, item)\n            d = os.path.join(destination, item)\n            if os.path.isdir(s):\n                shutil.copytree(s,d)\n            else:\n                if not os.path.exists(os.path.dirname(d)):\n                    os.makedirs(os.path.join(self.settings.root, os.path.dirname(d)))\n                shutil.copy2(s,d)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate(self, tool, copied=False, copy=False):\n\n        tools = self._validate_tools(tool)\n        if tools == -1:\n            return -1\n\n        generated_files = {}\n        result = 0\n        for export_tool in tools:\n            exporter = ToolsSupported().get_tool(export_tool)\n\n            # None is an error\n            if exporter is None:\n                result = -1\n                logger.debug(\"Tool: %s was not found\" % export_tool)\n                continue\n\n            self._fill_export_dict(export_tool, copied)\n            if copy:\n                logger.debug(\"Copying sources to the output directory\")\n                self._copy_sources_to_generated_destination()\n            # dump a log file if debug is enabled\n            if logger.isEnabledFor(logging.DEBUG):\n                dump_data = {}\n                dump_data['common'] = self.project['common']\n                dump_data['tool_specific'] = self.project['tool_specific']\n                dump_data['merged'] = self.project['export']\n                handler = logging.FileHandler(os.path.join(os.getcwd(), \"%s.log\" % self.name),\"w\", encoding=None, delay=\"true\")\n                handler.setLevel(logging.DEBUG)\n                logger.addHandler(handler)\n                logger.debug(\"\\n\" + yaml.dump(dump_data))\n\n            files = exporter(self.project['export'], self.settings).export_project()\n            generated_files[export_tool] = files\n        self.generated_files = generated_files\n        return result", "response": "Generates a project from the specified tool."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the generated project files for a specific tool", "response": "def get_generated_project_files(self, tool):\n        \"\"\" Get generated project files, the content depends on a tool. Look at tool implementation \"\"\"\n\n        exporter = ToolsSupported().get_tool(tool)\n        return exporter(self.generated_files[tool], self.settings).get_generated_project_files()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a new project with the appropriate metadata", "response": "def export_project(self):\n        \"\"\" Processes misc options specific for GCC ARM, and run generator \"\"\"\n        generated_projects = deepcopy(self.generated_projects)\n        self.process_data_for_makefile(self.workspace)\n        generated_projects['path'], generated_projects['files']['makefile'] = self.gen_file_jinja('makefile_armcc.tmpl', self.workspace, 'Makefile', self.workspace['output_dir']['path'])\n        return generated_projects"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_specific_options(self, data):\n        data['common_flags'] = []\n        data['ld_flags'] = []\n        data['c_flags'] = []\n        data['cxx_flags'] = []\n        data['asm_flags'] = []\n        for k, v in data['misc'].items():\n            if type(v) is list:\n                if k not in data:\n                    data[k] = []\n                data[k].extend(v)\n            else:\n                if k not in data:\n                    data[k] = ''\n                data[k] = v", "response": "Parse all specific options."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef export_project(self):\n        output = copy.deepcopy(self.generated_project)\n        self.process_data_for_makefile(self.workspace)\n        self._fix_sublime_paths(self.workspace)\n        self.workspace['linker_options'] =[]\n\n        output['path'], output['files']['makefile'] = self.gen_file_jinja('makefile_gcc.tmpl', self.workspace, 'Makefile', self.workspace['output_dir']['path'])\n\n        self.workspace['buildsys_name'] = 'Make'\n        self.workspace['buildsys_cmd'] = 'make all'\n\n        path, output['files']['sublimetext'] = self.gen_file_jinja(\n            'sublimetext.sublime-project.tmpl', self.workspace, '%s.sublime-project' % self.workspace['name'], self.workspace['output_dir']['path'])\n        generated_projects = output\n        return generated_projects", "response": "Generate a new project file for GCC ARM and run generator."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfixes paths for extension list", "response": "def fix_paths(project_data, rel_path, extensions):\n    \"\"\" Fix paths for extension list \"\"\"\n    norm_func = lambda path : os.path.normpath(os.path.join(rel_path, path))\n    for key in extensions:\n        if type(project_data[key]) is dict:\n            for k,v in project_data[key].items():\n                project_data[key][k] = [norm_func(i) for i in v]\n        elif type(project_data[key]) is list:\n            project_data[key] = [norm_func(i) for i in project_data[key]]\n        else:\n            project_data[key] = norm_func(project_data[key])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert value to self. _cls if it is not instance of self. _cls. Otherwise returns value.", "response": "def _make_cls(self, value):\n        \"\"\"If value is not instance of self._cls, converts and returns\n        it. Otherwise, returns value.\n\n        :param value: the thing to make a self._cls from\n        :rtype self._cls\n        \"\"\"\n        if isinstance(value, self._cls):\n            return value\n        return self._cls(value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nestablish connection and returns http response based off of request.", "response": "def _send_request(self, request):\n        \"\"\"Establishes connection and returns http response based off of request.\n\n        :param request: HTTPRequest object\n        :type request: :class:`tincan.http_request.HTTPRequest`\n        :returns: LRS Response object\n        :rtype: :class:`tincan.lrs_response.LRSResponse`\n        \"\"\"\n        headers = {\"X-Experience-API-Version\": self.version}\n\n        if self.auth is not None:\n            headers[\"Authorization\"] = self.auth\n\n        headers.update(request.headers)\n\n        params = request.query_params\n        params = {k: unicode(params[k]).encode('utf-8') for k in params.keys()}\n        params = urllib.urlencode(params)\n\n        if request.resource.startswith('http'):\n            url = request.resource\n        else:\n            url = self.endpoint\n            url += request.resource\n\n        parsed = urlparse(url)\n\n        if parsed.scheme == \"https\":\n            web_req = httplib.HTTPSConnection(parsed.hostname, parsed.port)\n        else:\n            web_req = httplib.HTTPConnection(parsed.hostname, parsed.port)\n\n        path = parsed.path\n        if parsed.query or parsed.path:\n            path += \"?\"\n            if parsed.query:\n                path += parsed.query\n            if params:\n                path += params\n\n        if hasattr(request, \"content\") and request.content is not None:\n            web_req.request(\n                method=request.method,\n                url=path,\n                body=request.content,\n                headers=headers,\n            )\n        else:\n            web_req.request(\n                method=request.method,\n                url=path,\n                headers=headers,\n            )\n\n        response = web_req.getresponse()\n        data = response.read()\n        web_req.close()\n\n        if (200 <= response.status < 300\n            or (response.status == 404\n                and hasattr(request, \"ignore404\")\n                and request.ignore404)):\n            success = True\n        else:\n            success = False\n\n        return LRSResponse(\n            success=success,\n            request=request,\n            response=response,\n            data=data,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef about(self):\n        request = HTTPRequest(\n            method=\"GET\",\n            resource=\"about\"\n        )\n        lrs_response = self._send_request(request)\n\n        if lrs_response.success:\n            lrs_response.content = About.from_json(lrs_response.data)\n\n        return lrs_response", "response": "Gets about response from LRS"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsave statement to LRS and update statement id if necessary", "response": "def save_statement(self, statement):\n        \"\"\"Save statement to LRS and update statement id if necessary\n\n        :param statement: Statement object to be saved\n        :type statement: :class:`tincan.statement.Statement`\n        :return: LRS Response object with the saved statement as content\n        :rtype: :class:`tincan.lrs_response.LRSResponse`\n        \"\"\"\n        if not isinstance(statement, Statement):\n            statement = Statement(statement)\n\n        request = HTTPRequest(\n            method=\"POST\",\n            resource=\"statements\"\n        )\n        if statement.id is not None:\n            request.method = \"PUT\"\n            request.query_params[\"statementId\"] = statement.id\n\n        request.headers[\"Content-Type\"] = \"application/json\"\n        request.content = statement.to_json(self.version)\n\n        lrs_response = self._send_request(request)\n\n        if lrs_response.success:\n            if statement.id is None:\n                statement.id = json.loads(lrs_response.data)[0]\n            lrs_response.content = statement\n\n        return lrs_response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsave a list of statements to LRS and update their statement id s", "response": "def save_statements(self, statements):\n        \"\"\"Save statements to LRS and update their statement id's\n\n        :param statements: A list of statement objects to be saved\n        :type statements: :class:`StatementList`\n        :return: LRS Response object with the saved list of statements as content\n        :rtype: :class:`tincan.lrs_response.LRSResponse`\n        \"\"\"\n        if not isinstance(statements, StatementList):\n            statements = StatementList(statements)\n\n        request = HTTPRequest(\n            method=\"POST\",\n            resource=\"statements\"\n        )\n        request.headers[\"Content-Type\"] = \"application/json\"\n\n        request.content = statements.to_json()\n\n        lrs_response = self._send_request(request)\n\n        if lrs_response.success:\n            id_list = json.loads(lrs_response.data)\n            for s, statement_id in zip(statements, id_list):\n                s.id = statement_id\n\n            lrs_response.content = statements\n\n        return lrs_response"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve a statement from the server from its id", "response": "def retrieve_statement(self, statement_id):\n        \"\"\"Retrieve a statement from the server from its id\n\n        :param statement_id: The UUID of the desired statement\n        :type statement_id: str | unicode\n        :return: LRS Response object with the retrieved statement as content\n        :rtype: :class:`tincan.lrs_response.LRSResponse`\n        \"\"\"\n        request = HTTPRequest(\n            method=\"GET\",\n            resource=\"statements\"\n        )\n        request.query_params[\"statementId\"] = statement_id\n\n        lrs_response = self._send_request(request)\n\n        if lrs_response.success:\n            lrs_response.content = Statement.from_json(lrs_response.data)\n\n        return lrs_response"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nquerying the LRS for Statements with the specified query parameters and their values.", "response": "def query_statements(self, query):\n        \"\"\"Query the LRS for statements with specified parameters\n\n        :param query: Dictionary of query parameters and their values\n        :type query: dict\n        :return: LRS Response object with the returned StatementsResult object as content\n        :rtype: :class:`tincan.lrs_response.LRSResponse`\n\n        .. note::\n           Optional query parameters are\\n\n               **statementId:** (*str*) ID of the Statement to fetch\n               **voidedStatementId:** (*str*) ID of the voided Statement to fetch\n               **agent:** (*Agent* |*Group*) Filter to return Statements for which the\n               specified Agent or Group is the Actor\n               **verb:** (*Verb id IRI*) Filter to return Statements matching the verb id\n               **activity:** (*Activity id IRI*) Filter to return Statements for which the\n               specified Activity is the Object\n               **registration:** (*UUID*) Filter to return Statements matching the specified registration ID\n               **related_activities:** (*bool*) Include Statements for which the Object,\n               Context Activities or any Sub-Statement\n               properties match the specified Activity\n               **related_agents:** (*bool*) Include Statements for which the Actor, Object,\n               Authority, Instructor, Team, or any Sub-Statement properties match the specified Agent\n               **since:** (*datetime*) Filter to return Statements stored since the specified datetime\n               **until:** (*datetime*) Filter to return Statements stored at or before the specified datetime\n               **limit:** (*positive int*) Allow <limit> Statements to be returned. 0 indicates the\n               maximum supported by the LRS\n               **format:** (*str* {\"ids\"|\"exact\"|\"canonical\"}) Manipulates how the LRS handles\n               importing and returning the statements\n               **attachments:** (*bool*) If true, the LRS will use multipart responses and include\n               all attachment data per Statement returned.\n               Otherwise, application/json is used and no attachment information will be returned\n               **ascending:** (*bool*) If true, the LRS will return results in ascending order of\n               stored time (oldest first)\n        \"\"\"\n        params = {}\n\n        param_keys = [\n            \"registration\",\n            \"since\",\n            \"until\",\n            \"limit\",\n            \"ascending\",\n            \"related_activities\",\n            \"related_agents\",\n            \"format\",\n            \"attachments\",\n        ]\n\n        for k, v in query.iteritems():\n            if v is not None:\n                if k == \"agent\":\n                    params[k] = v.to_json(self.version)\n                elif k == \"verb\" or k == \"activity\":\n                    params[k] = v.id\n                elif k in param_keys:\n                    params[k] = v\n\n        request = HTTPRequest(\n            method=\"GET\",\n            resource=\"statements\"\n        )\n        request.query_params = params\n\n        lrs_response = self._send_request(request)\n\n        if lrs_response.success:\n            lrs_response.content = StatementsResult.from_json(lrs_response.data)\n\n        return lrs_response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef more_statements(self, more_url):\n        if isinstance(more_url, StatementsResult):\n            more_url = more_url.more\n\n        more_url = self.get_endpoint_server_root() + more_url\n\n        request = HTTPRequest(\n            method=\"GET\",\n            resource=more_url\n        )\n\n        lrs_response = self._send_request(request)\n\n        if lrs_response.success:\n            lrs_response.content = StatementsResult.from_json(lrs_response.data)\n\n        return lrs_response", "response": "Query the LRS for more statements."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving state id s from the LRS with the provided parameters.", "response": "def retrieve_state_ids(self, activity, agent, registration=None, since=None):\n        \"\"\"Retrieve state id's from the LRS with the provided parameters\n\n        :param activity: Activity object of desired states\n        :type activity: :class:`tincan.activity.Activity`\n        :param agent: Agent object of desired states\n        :type agent: :class:`tincan.agent.Agent`\n        :param registration: Registration UUID of desired states\n        :type registration: str | unicode\n        :param since: Retrieve state id's since this time\n        :type since: str | unicode\n        :return: LRS Response object with the retrieved state id's as content\n        :rtype: :class:`tincan.lrs_response.LRSResponse`\n        \"\"\"\n        if not isinstance(activity, Activity):\n            activity = Activity(activity)\n\n        if not isinstance(agent, Agent):\n            agent = Agent(agent)\n\n        request = HTTPRequest(\n            method=\"GET\",\n            resource=\"activities/state\"\n        )\n        request.query_params = {\n            \"activityId\": activity.id,\n            \"agent\": agent.to_json(self.version)\n        }\n\n        if registration is not None:\n            request.query_params[\"registration\"] = registration\n        if since is not None:\n            request.query_params[\"since\"] = since\n\n        lrs_response = self._send_request(request)\n\n        if lrs_response.success:\n            lrs_response.content = json.loads(lrs_response.data)\n\n        return lrs_response"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves state from LRS with the provided parameters.", "response": "def retrieve_state(self, activity, agent, state_id, registration=None):\n        \"\"\"Retrieve state from LRS with the provided parameters\n\n        :param activity: Activity object of desired state\n        :type activity: :class:`tincan.activity.Activity`\n        :param agent: Agent object of desired state\n        :type agent: :class:`tincan.agent.Agent`\n        :param state_id: UUID of desired state\n        :type state_id: str | unicode\n        :param registration: registration UUID of desired state\n        :type registration: str | unicode\n        :return: LRS Response object with retrieved state document as content\n        :rtype: :class:`tincan.lrs_response.LRSResponse`\n        \"\"\"\n        if not isinstance(activity, Activity):\n            activity = Activity(activity)\n\n        if not isinstance(agent, Agent):\n            agent = Agent(agent)\n\n        request = HTTPRequest(\n            method=\"GET\",\n            resource=\"activities/state\",\n            ignore404=True\n        )\n\n        request.query_params = {\n            \"activityId\": activity.id,\n            \"agent\": agent.to_json(self.version),\n            \"stateId\": state_id\n        }\n\n        if registration is not None:\n            request.query_params[\"registration\"] = registration\n\n        lrs_response = self._send_request(request)\n\n        if lrs_response.success:\n            doc = StateDocument(\n                id=state_id,\n                content=lrs_response.data,\n                activity=activity,\n                agent=agent\n            )\n            if registration is not None:\n                doc.registration = registration\n\n            headers = lrs_response.response.getheaders()\n            if \"lastModified\" in headers and headers[\"lastModified\"] is not None:\n                doc.timestamp = headers[\"lastModified\"]\n            if \"contentType\" in headers and headers[\"contentType\"] is not None:\n                doc.content_type = headers[\"contentType\"]\n            if \"etag\" in headers and headers[\"etag\"] is not None:\n                doc.etag = headers[\"etag\"]\n\n            lrs_response.content = doc\n\n        return lrs_response"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsaving a state document to the LRS", "response": "def save_state(self, state):\n        \"\"\"Save a state doc to the LRS\n\n        :param state: State document to be saved\n        :type state: :class:`tincan.documents.state_document.StateDocument`\n        :return: LRS Response object with saved state as content\n        :rtype: :class:`tincan.lrs_response.LRSResponse`\n        \"\"\"\n        request = HTTPRequest(\n            method=\"PUT\",\n            resource=\"activities/state\",\n            content=state.content,\n        )\n        if state.content_type is not None:\n            request.headers[\"Content-Type\"] = state.content_type\n        else:\n            request.headers[\"Content-Type\"] = \"application/octet-stream\"\n\n        if state.etag is not None:\n            request.headers[\"If-Match\"] = state.etag\n\n        request.query_params = {\n            \"stateId\": state.id,\n            \"activityId\": state.activity.id,\n            \"agent\": state.agent.to_json(self.version)\n        }\n        lrs_response = self._send_request(request)\n        lrs_response.content = state\n\n        return self._send_request(request)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _delete_state(self, activity, agent, state_id=None, registration=None, etag=None):\n        if not isinstance(activity, Activity):\n            activity = Activity(activity)\n\n        if not isinstance(agent, Agent):\n            agent = Agent(agent)\n\n        request = HTTPRequest(\n            method=\"DELETE\",\n            resource=\"activities/state\"\n        )\n\n        if etag is not None:\n            request.headers[\"If-Match\"] = etag\n\n        request.query_params = {\n            \"activityId\": activity.id,\n            \"agent\": agent.to_json(self.version)\n        }\n        if state_id is not None:\n            request.query_params[\"stateId\"] = state_id\n\n        if registration is not None:\n            request.query_params[\"registration\"] = registration\n\n        lrs_response = self._send_request(request)\n\n        return lrs_response", "response": "Private method to delete a specified state from the LRS."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_state(self, state):\n        return self._delete_state(\n            activity=state.activity,\n            agent=state.agent,\n            state_id=state.id,\n            etag=state.etag\n        )", "response": "Delete a specified state from the LRS."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes state with specified activity and agent and optionally registration UUID.", "response": "def clear_state(self, activity, agent, registration=None):\n        \"\"\"Clear state(s) with specified activity and agent\n\n        :param activity: Activity object of state(s) to be deleted\n        :type activity: :class:`tincan.activity.Activity`\n        :param agent: Agent object of state(s) to be deleted\n        :type agent: :class:`tincan.agent.Agent`\n        :param registration: registration UUID of state(s) to be deleted\n        :type registration: str | unicode\n        :return: LRS Response object\n        :rtype: :class:`tincan.lrs_response.LRSResponse`\n        \"\"\"\n        return self._delete_state(\n            activity=activity,\n            agent=agent,\n            registration=registration\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef retrieve_activity_profile_ids(self, activity, since=None):\n        if not isinstance(activity, Activity):\n            activity = Activity(activity)\n\n        request = HTTPRequest(\n            method=\"GET\",\n            resource=\"activities/profile\"\n        )\n        request.query_params[\"activityId\"] = activity.id\n\n        if since is not None:\n            request.query_params[\"since\"] = since\n\n        lrs_response = self._send_request(request)\n\n        if lrs_response.success:\n            lrs_response.content = json.loads(lrs_response.data)\n\n        return lrs_response", "response": "Retrieve the activity profile id s with the specified parameters"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef retrieve_activity_profile(self, activity, profile_id):\n        if not isinstance(activity, Activity):\n            activity = Activity(activity)\n\n        request = HTTPRequest(\n            method=\"GET\",\n            resource=\"activities/profile\",\n            ignore404=True\n        )\n        request.query_params = {\n            \"profileId\": profile_id,\n            \"activityId\": activity.id\n        }\n        lrs_response = self._send_request(request)\n\n        if lrs_response.success:\n            doc = ActivityProfileDocument(\n                id=profile_id,\n                content=lrs_response.data,\n                activity=activity\n            )\n            headers = lrs_response.response.getheaders()\n            if \"lastModified\" in headers and headers[\"lastModified\"] is not None:\n                doc.timestamp = headers[\"lastModified\"]\n            if \"contentType\" in headers and headers[\"contentType\"] is not None:\n                doc.content_type = headers[\"contentType\"]\n            if \"etag\" in headers and headers[\"etag\"] is not None:\n                doc.etag = headers[\"etag\"]\n\n            lrs_response.content = doc\n\n        return lrs_response", "response": "Retrieve an activity profile with the specified parameters"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save_activity_profile(self, profile):\n        request = HTTPRequest(\n            method=\"PUT\",\n            resource=\"activities/profile\",\n            content=profile.content\n        )\n        if profile.content_type is not None:\n            request.headers[\"Content-Type\"] = profile.content_type\n        else:\n            request.headers[\"Content-Type\"] = \"application/octet-stream\"\n\n        if profile.etag is not None:\n            request.headers[\"If-Match\"] = profile.etag\n\n        request.query_params = {\n            \"profileId\": profile.id,\n            \"activityId\": profile.activity.id\n        }\n        lrs_response = self._send_request(request)\n        lrs_response.content = profile\n\n        return lrs_response", "response": "Save an activity profile doc to the LRS"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeleting activity profile document from LRS", "response": "def delete_activity_profile(self, profile):\n        \"\"\"Delete activity profile doc from LRS\n\n        :param profile: Activity profile document to be deleted\n        :type profile: :class:`tincan.documents.activity_profile_document.ActivityProfileDocument`\n        :return: LRS Response object\n        :rtype: :class:`tincan.lrs_response.LRSResponse`\n        \"\"\"\n        request = HTTPRequest(\n            method=\"DELETE\",\n            resource=\"activities/profile\"\n        )\n        request.query_params = {\n            \"profileId\": profile.id,\n            \"activityId\": profile.activity.id\n        }\n\n        if profile.etag is not None:\n            request.headers[\"If-Match\"] = profile.etag\n\n        return self._send_request(request)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef retrieve_agent_profile_ids(self, agent, since=None):\n        if not isinstance(agent, Agent):\n            agent = Agent(agent)\n\n        request = HTTPRequest(\n            method=\"GET\",\n            resource=\"agents/profile\"\n        )\n        request.query_params[\"agent\"] = agent.to_json(self.version)\n\n        if since is not None:\n            request.query_params[\"since\"] = since\n\n        lrs_response = self._send_request(request)\n\n        if lrs_response.success:\n            lrs_response.content = json.loads(lrs_response.data)\n\n        return lrs_response", "response": "Retrieve agent profile id s with the specified parameters"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve an agent profile with the specified parameters", "response": "def retrieve_agent_profile(self, agent, profile_id):\n        \"\"\"Retrieve agent profile with the specified parameters\n\n        :param agent: Agent object of the desired agent profile\n        :type agent: :class:`tincan.agent.Agent`\n        :param profile_id: UUID of the desired agent profile\n        :type profile_id: str | unicode\n        :return: LRS Response object with an agent profile doc as content\n        :rtype: :class:`tincan.lrs_response.LRSResponse`\n        \"\"\"\n        if not isinstance(agent, Agent):\n            agent = Agent(agent)\n\n        request = HTTPRequest(\n            method=\"GET\",\n            resource=\"agents/profile\",\n            ignore404=True\n        )\n        request.query_params = {\n            \"profileId\": profile_id,\n            \"agent\": agent.to_json(self.version)\n        }\n\n        lrs_response = self._send_request(request)\n\n        if lrs_response.success:\n            doc = AgentProfileDocument(\n                id=profile_id,\n                content=lrs_response.data,\n                agent=agent\n            )\n            headers = lrs_response.response.getheaders()\n            if \"lastModified\" in headers and headers[\"lastModified\"] is not None:\n                doc.timestamp = headers[\"lastModified\"]\n            if \"contentType\" in headers and headers[\"contentType\"] is not None:\n                doc.content_type = headers[\"contentType\"]\n            if \"etag\" in headers and headers[\"etag\"] is not None:\n                doc.etag = headers[\"etag\"]\n\n            lrs_response.content = doc\n\n        return lrs_response"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsaving an agent profile doc to the LRS", "response": "def save_agent_profile(self, profile):\n        \"\"\"Save an agent profile doc to the LRS\n\n        :param profile: Agent profile doc to be saved\n        :type profile: :class:`tincan.documents.agent_profile_document.AgentProfileDocument`\n        :return: LRS Response object with the saved agent profile doc as content\n        :rtype: :class:`tincan.lrs_response.LRSResponse`\n        \"\"\"\n        request = HTTPRequest(\n            method=\"PUT\",\n            resource=\"agents/profile\",\n            content=profile.content,\n        )\n        if profile.content_type is not None:\n            request.headers[\"Content-Type\"] = profile.content_type\n        else:\n            request.headers[\"Content-Type\"] = \"application/octet-stream\"\n\n        if profile.etag is not None:\n            request.headers[\"If-Match\"] = profile.etag\n\n        request.query_params = {\n            \"profileId\": profile.id,\n            \"agent\": profile.agent.to_json(self.version)\n        }\n        lrs_response = self._send_request(request)\n        lrs_response.content = profile\n\n        return lrs_response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete an agent profile document from LRS", "response": "def delete_agent_profile(self, profile):\n        \"\"\"Delete agent profile doc from LRS\n\n        :param profile: Agent profile document to be deleted\n        :type profile: :class:`tincan.documents.agent_profile_document.AgentProfileDocument`\n        :return: LRS Response object\n        :rtype: :class:`tincan.lrs_response.LRSResponse`\n        \"\"\"\n        request = HTTPRequest(\n            method=\"DELETE\",\n            resource=\"agents/profile\"\n        )\n        request.query_params = {\n            \"profileId\": profile.id,\n            \"agent\": profile.agent.to_json(self.version)\n        }\n\n        if profile.etag is not None:\n            request.headers[\"If-Match\"] = profile.etag\n\n        return self._send_request(request)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_endpoint_server_root(self):\n        parsed = urlparse(self._endpoint)\n        root = parsed.scheme + \"://\" + parsed.hostname\n\n        if parsed.port is not None:\n            root += \":\" + unicode(parsed.port)\n\n        return root", "response": "Parses the RemoteLRS object s endpoint and returns its root\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_json(cls, json_data):\n        data = json.loads(json_data)\n        result = cls(data)\n        if hasattr(result, \"_from_json\"):\n            result._from_json()\n        return result", "response": "Tries to convert a JSON representation of a language map object to an object of the same type as self\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_json(self, version=Version.latest):\n        return json.dumps(self.as_version(version))", "response": "Tries to serialize an object into a JSON representation and return\n        the resulting string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef as_version(self, version=Version.latest):\n        if not isinstance(self, list):\n            result = {}\n            for k, v in self.iteritems() if isinstance(self, dict) else vars(self).iteritems():\n                k = self._props_corrected.get(k, k)\n                if isinstance(v, SerializableBase):\n                    result[k] = v.as_version(version)\n                elif isinstance(v, list):\n                    result[k] = []\n                    for val in v:\n                        if isinstance(val, SerializableBase):\n                            result[k].append(val.as_version(version))\n                        else:\n                            result[k].append(val)\n                elif isinstance(v, uuid.UUID):\n                    result[k] = unicode(v)\n                elif isinstance(v, datetime.timedelta):\n                    result[k] = jsonify_timedelta(v)\n                elif isinstance(v, datetime.datetime):\n                    result[k] = jsonify_datetime(v)\n                else:\n                    result[k] = v\n            result = self._filter_none(result)\n        else:\n            result = []\n            for v in self:\n                if isinstance(v, SerializableBase):\n                    result.append(v.as_version(version))\n                else:\n                    result.append(v)\n        return result", "response": "Returns a dict that has been modified based on versioning\n        implementation in order to be represented in JSON properly"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfiltering out attributes set to None prior to serialization.", "response": "def _filter_none(obj):\n        \"\"\"Filters out attributes set to None prior to serialization, and\n        returns a new object without those attributes. This saves\n        the serializer from sending empty bytes over the network. This method also\n        fixes the keys to look as expected by ignoring a leading '_' if it\n        is present.\n\n        :param obj: the dictionary representation of an object that may have\n        None attributes\n        :type obj: dict\n\n        \"\"\"\n        result = {}\n        for k, v in obj.iteritems():\n            if v is not None:\n                if k.startswith('_'):\n                    k = k[1:]\n                result[k] = v\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntry to convert the given value to a datetime. timedelta.", "response": "def make_timedelta(value):\n    \"\"\"Tries to convert the given value to a :class:`datetime.timedelta`.\n\n    Strings will be parsed as ISO 8601 durations.\n\n    If a number is provided, it will be interpreted as the number of\n    seconds.\n\n    If a `dict` is provided, does `datetime.timedelta(**value)`.\n\n    :param value: something to convert\n    :type value: str | unicode | float | int | datetime.timedelta | dict\n    :return: the value after conversion\n    :rtype: datetime.timedelta\n\n    \"\"\"\n\n    if isinstance(value, basestring):\n        try:\n            return aniso8601.parse_duration(value)\n        except Exception as e:\n            msg = (\n                \"Conversion to datetime.timedelta failed. Could not \"\n                \"parse the given string as an ISO 8601 duration: \"\n                \"%s\\n\\n\"\n                \"%s\" %\n                (\n                    repr(value),\n                    e.message,\n                )\n            )\n            raise ValueError(msg)\n\n    try:\n        if isinstance(value, datetime.timedelta):\n            return value\n        elif isinstance(value, dict):\n            return datetime.timedelta(**value)\n        elif isinstance(value, (float, int)):\n            return datetime.timedelta(seconds=value)\n        else:\n            return datetime.timedelta(value)\n    except Exception as e:\n        msg = (\n            \"Could not convert the given value of type '%s' to a \"\n            \"datetime.timedelta: %s\\n\\n\"\n            \"%s\" %\n            (\n                value.__class__.__name__,\n                repr(value),\n                e.message,\n            )\n        )\n        raise TypeError(msg) if isinstance(e, TypeError) else ValueError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a datetime. timedelta object to an ISO 8601 duration string for JSON -ification.", "response": "def jsonify_timedelta(value):\n    \"\"\"Converts a `datetime.timedelta` to an ISO 8601 duration\n    string for JSON-ification.\n\n    :param value: something to convert\n    :type value: datetime.timedelta\n    :return: the value after conversion\n    :rtype unicode\n\n    \"\"\"\n\n    assert isinstance(value, datetime.timedelta)\n\n    # split seconds to larger units\n    seconds = value.total_seconds()\n    minutes, seconds = divmod(seconds, 60)\n    hours, minutes = divmod(minutes, 60)\n    days, hours = divmod(hours, 24)\n\n    days, hours, minutes = map(int, (days, hours, minutes))\n    seconds = round(seconds, 6)\n\n    # build date\n    date = ''\n    if days:\n        date = '%sD' % days\n\n    # build time\n    time = u'T'\n\n    # hours\n    bigger_exists = date or hours\n    if bigger_exists:\n        time += '{:02}H'.format(hours)\n\n    # minutes\n    bigger_exists = bigger_exists or minutes\n    if bigger_exists:\n        time += '{:02}M'.format(minutes)\n\n    # seconds\n    if seconds.is_integer():\n        seconds = '{:02}'.format(int(seconds))\n    else:\n        # 9 chars long w/leading 0, 6 digits after decimal\n        seconds = '%09.6f' % seconds\n        # remove trailing zeros\n        seconds = seconds.rstrip('0')\n\n    time += '{}S'.format(seconds)\n\n    return u'P' + date + time"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntrying to convert the given value to a datetime. datetime object.", "response": "def make_datetime(value):\n    \"\"\"Tries to convert the given value to a :class:`datetime.datetime`. If\n    no timezone is given, raises a ValueError.\n\n    Strings will be parsed as ISO 8601 timestamps.\n\n    If a number is provided, it will be interpreted as a UNIX\n    timestamp, which by definition is UTC.\n\n    If a `dict` is provided, does `datetime.datetime(**value)`.\n\n    If a `tuple` or a `list` is provided, does\n    `datetime.datetime(*value)`. Uses the timezone in the tuple or\n    list if provided.\n\n    :param value: something to convert\n    :type value: str | unicode | float | int | :class:`datetime.datetime` | dict | list | tuple\n    :return: the value after conversion\n    :rtype: :class:`datetime.datetime`\n    :raises: ValueError | TypeError\n\n    \"\"\"\n    result = _make_datetime(value)\n    if not result.tzinfo:\n        raise ValueError(\n            \"value was a timestamp, but no timezone was set! \"\n            \"Value was a '%s' object: %s\"\n            \"\\n\\n\"\n            \"Converted to naive 'datetime.datetime' object: %s\" %\n            (\n                value.__class__.__name__,\n                repr(value),\n                repr(result),\n            )\n        )\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a single member to this group s list of members.", "response": "def addmember(self, value):\n        \"\"\"Adds a single member to this group's list of members.\n        Tries to convert to :class:`tincan.Agent`\n\n        :param value: The member to add to this group\n        :type value: :class:`tincan.Agent`\n\n        \"\"\"\n\n        if value is not None and not isinstance(value, Agent):\n            value = Agent(value)\n\n        self._member.append(value)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _activity_or_list(value):\n        result = value\n        if value is not None and not isinstance(value, ActivityList):\n            try:\n                result = ActivityList([Activity(value)])\n            except (TypeError, AttributeError):\n                result = ActivityList(value)\n        return result", "response": "Tries to convert value to a list of Activity objects."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the root path for a resource.", "response": "def get_root_path(self, name):\n        \"\"\"\n        Attempt to compute a root path for a (hopefully importable) name.\n\n        Based in part on Flask's `root_path` calculation. See:\n\n            https://github.com/mitsuhiko/flask/blob/master/flask/helpers.py#L777\n\n        \"\"\"\n        module = modules.get(name)\n        if module is not None and hasattr(module, '__file__'):\n            return dirname(abspath(module.__file__))\n\n        # Flask keeps looking at this point. We instead set the root path to None,\n        # assume that the user doesn't need resource loading, and raise an error\n        # when resolving the resource path.\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef zip_dicts(left, right, prefix=()):\n    for key, left_value in left.items():\n        path = prefix + (key, )\n        right_value = right.get(key)\n\n        if isinstance(left_value, dict):\n            yield from zip_dicts(left_value, right_value or {}, path)\n        else:\n            yield path, left, left_value, right, right_value", "response": "A generator that yields all keys of left dictionary and right dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild a fresh configuration.", "response": "def configure(defaults, metadata, loader):\n    \"\"\"\n    Build a fresh configuration.\n\n    :params defaults: a nested dictionary of keys and their default values\n    :params metadata: the graph metadata\n    :params loader: a configuration loader\n\n    \"\"\"\n    config = Configuration(defaults)\n    config.merge(loader(metadata))\n    validate(defaults, metadata, config)\n    return config"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a boolean value.", "response": "def boolean(value):\n    \"\"\"\n    Configuration-friendly boolean type converter.\n\n    Supports both boolean-valued and string-valued inputs (e.g. from env vars).\n\n    \"\"\"\n    if isinstance(value, bool):\n        return value\n\n    if value == \"\":\n        return False\n\n    return strtobool(value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading configuration from environment variables.", "response": "def _load_from_environ(metadata, value_func=None):\n    \"\"\"\n    Load configuration from environment variables.\n\n    Any environment variable prefixed with the metadata's name will be\n    used to recursively set dictionary keys, splitting on '__'.\n\n    :param value_func: a mutator for the envvar's value (if any)\n\n    \"\"\"\n    # We'll match the ennvar name against the metadata's name. The ennvar\n    # name must be uppercase and hyphens in names converted to underscores.\n    #\n    # | envar       | name    | matches? |\n    # +-------------+---------+----------+\n    # | FOO_BAR     | foo     | yes      |\n    # | FOO_BAR     | bar     | no       |\n    # | foo_bar     | bar     | no       |\n    # | FOO_BAR_BAZ | foo_bar | yes      |\n    # | FOO_BAR_BAZ | foo-bar | yes      |\n    # +-------------+---------+----------+\n\n    prefix = metadata.name.upper().replace(\"-\", \"_\")\n\n    return expand_config(\n        environ,\n        separator=\"__\",\n        skip_to=1,\n        key_parts_filter=lambda key_parts: len(key_parts) > 1 and key_parts[0] == prefix,\n        value_func=lambda value: value_func(value) if value_func else value,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_from_dict(dct=None, **kwargs):\n    dct = dct or dict()\n    dct.update(kwargs)\n\n    def _load_from_dict(metadata):\n        return dict(dct)\n    return _load_from_dict", "response": "Load a configuration from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef binding(key, registry=None):\n    if registry is None:\n        registry = _registry\n\n    def decorator(func):\n        registry.bind(key, func)\n        return func\n    return decorator", "response": "Creates a decorator that binds a factory function to a key."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a decorator that saves the provided kwargs as defaults for a new object.", "response": "def defaults(**kwargs):\n    \"\"\"\n    Creates a decorator that saves the provided kwargs as defaults for a factory function.\n\n    \"\"\"\n    def decorator(func):\n        setattr(func, DEFAULTS, kwargs)\n        return func\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninvoking a hook on the target object.", "response": "def _invoke_hook(hook_name, target):\n    \"\"\"\n    Generic hook invocation.\n\n    \"\"\"\n    try:\n        for value in getattr(target, hook_name):\n            func, args, kwargs = value\n            func(target, *args, **kwargs)\n    except AttributeError:\n        # no hook defined\n        pass\n    except (TypeError, ValueError):\n        # hook not properly defined (might be a mock)\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nregister a resolution hook.", "response": "def on_resolve(target, func, *args, **kwargs):\n    \"\"\"\n    Register a resolution hook.\n\n    \"\"\"\n    return _register_hook(ON_RESOLVE, target, func, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_cache(name):\n    caches = {\n        subclass.name(): subclass\n        for subclass in Cache.__subclasses__()\n    }\n    return caches.get(name, NaiveCache)()", "response": "Create a cache by name."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nderives a configuration file name from the FOO_SETTINGS environment variable.", "response": "def get_config_filename(metadata):\n    \"\"\"\n    Derive a configuration file name from the FOO_SETTINGS\n    environment variable.\n\n    \"\"\"\n    envvar = \"{}__SETTINGS\".format(underscore(metadata.name).upper())\n    try:\n        return environ[envvar]\n    except KeyError:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _load_from_file(metadata, load_func):\n    config_filename = get_config_filename(metadata)\n    if config_filename is None:\n        return dict()\n\n    with open(config_filename, \"r\") as file_:\n        data = load_func(file_.read())\n        return dict(data)", "response": "Load configuration from a file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_scoped_config(self, graph):\n        def loader(metadata):\n            if not self.current_scope:\n                target = graph.config\n            else:\n                target = graph.config.get(self.current_scope, {})\n            return {\n                self.key: target.get(self.key, {}),\n            }\n\n        defaults = {\n            self.key: get_defaults(self.func),\n        }\n        return configure(defaults, graph.metadata, loader)", "response": "Compute a configuration using the current scope."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef resolve(self, graph):\n        cached = graph.get(self.scoped_key)\n        if cached:\n            return cached\n\n        component = self.create(graph)\n        graph.assign(self.scoped_key, component)\n        return component", "response": "Resolve a scoped component respecting the graph cache."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self, graph):\n        scoped_config = self.get_scoped_config(graph)\n        scoped_graph = ScopedGraph(graph, scoped_config)\n        return self.func(scoped_graph)", "response": "Create a new scoped component."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_each(*loaders):\n    def _load_each(metadata):\n        return merge(\n            loader(metadata)\n            for loader in loaders\n        )\n    return _load_each", "response": "Returns a Loader factory that combines a series of loaders."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmerging a value into a partition for a key path.", "response": "def merge_partition(self, partition, path, value):\n        \"\"\"\n        Merge a value into a partition for a key path.\n\n        \"\"\"\n        dct = self.partitions[partition]\n        *heads, tail = path\n        for part in heads:\n            dct = dct.setdefault(part, dict())\n        dct[tail] = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef all(self):\n        return {\n            key: value\n            for key, value in chain(self.entry_points.items(), self.factories.items())\n        }", "response": "Return a synthetic dictionary of all entry points and factories."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a nested dicionary of all registered factory defaults.", "response": "def defaults(self):\n        \"\"\"\n        Return a nested dicionary of all registered factory defaults.\n\n        \"\"\"\n        return {\n            key: get_defaults(value)\n            for key, value in self.all.items()\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bind(self, key, factory):\n        if key in self.factories:\n            raise AlreadyBoundError(key)\n        else:\n            self.factories[key] = factory", "response": "Bind a factory to a key."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef resolve(self, key):\n        try:\n            return self._resolve_from_binding(key)\n        except NotBoundError:\n            return self._resolve_from_entry_point(key)", "response": "Resolves a key to a factory."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexpand a dictionary recursively by splitting keys along the separator and then expanding the value of the key.", "response": "def expand_config(dct,\n                  separator='.',\n                  skip_to=0,\n                  key_func=lambda key: key.lower(),\n                  key_parts_filter=lambda key_parts: True,\n                  value_func=lambda value: value):\n    \"\"\"\n    Expand a dictionary recursively by splitting keys along the separator.\n\n    :param dct: a non-recursive dictionary\n    :param separator: a separator charactor for splitting dictionary keys\n    :param skip_to: index to start splitting keys on; can be used to skip over a key prefix\n    :param key_func: a key mapping function\n    :param key_parts_filter: a filter function for excluding keys\n    :param value_func: a value mapping func\n\n    \"\"\"\n    config = {}\n\n    for key, value in dct.items():\n        key_separator = separator(key) if callable(separator) else separator\n        key_parts = key.split(key_separator)\n        if not key_parts_filter(key_parts):\n            continue\n        key_config = config\n        # skip prefix\n        for key_part in key_parts[skip_to:-1]:\n            key_config = key_config.setdefault(key_func(key_part), dict())\n        key_config[key_func(key_parts[-1])] = value_func(value)\n\n    return config"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new object graph.", "response": "def create_object_graph(name,\n                        debug=False,\n                        testing=False,\n                        import_name=None,\n                        root_path=None,\n                        loader=load_from_environ,\n                        registry=_registry,\n                        profiler=None,\n                        cache=None):\n    \"\"\"\n    Create a new object graph.\n\n    :param name: the name of the microservice\n    :param debug: is development debugging enabled?\n    :param testing: is unit testing enabled?\n    :param loader: the configuration loader to use\n    :param registry: the registry to use (defaults to the global)\n\n    \"\"\"\n    metadata = Metadata(\n        name=name,\n        debug=debug,\n        testing=testing,\n        import_name=import_name,\n        root_path=root_path,\n    )\n\n    defaults = registry.defaults\n    config = configure(defaults, metadata, loader)\n\n    if profiler is None:\n        profiler = NoopProfiler()\n\n    if cache is None or isinstance(cache, str):\n        cache = create_cache(cache)\n\n    return ObjectGraph(\n        metadata=metadata,\n        config=config,\n        registry=registry,\n        profiler=profiler,\n        cache=cache,\n        loader=loader,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _reserve(self, key):\n        self.assign(key, RESERVED)\n        try:\n            yield\n        finally:\n            del self._cache[key]", "response": "Reserve a component s binding temporarily."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nattempt to lazily create a component.", "response": "def _resolve_key(self, key):\n        \"\"\"\n        Attempt to lazily create a component.\n\n        :raises NotBoundError: if the component does not have a bound factory\n        :raises CyclicGraphError: if the factory function requires a cycle\n        :raises LockedGraphError: if the graph is locked\n        \"\"\"\n        with self._reserve(key):\n            factory = self.factory_for(key)\n            with self._profiler(key):\n                component = factory(self)\n            invoke_resolve_hook(component)\n\n        return self.assign(key, component)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef scoped(self, func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            scope = kwargs.get(\"scope\", self.__factory__.default_scope)\n            with self.scoped_to(scope):\n                return func(*args, **kwargs)\n        return wrapper", "response": "Decorator to switch scopes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef merge(self, dct=None, **kwargs):\n        if dct is None:\n            dct = {}\n        if kwargs:\n            dct.update(**kwargs)\n\n        for key, value in dct.items():\n            if all((\n                    isinstance(value, dict),\n                    isinstance(self.get(key), Configuration),\n                    getattr(self.get(key), \"__merge__\", True),\n            )):\n                # recursively merge\n                self[key].merge(value)\n            elif isinstance(value, list) and isinstance(self.get(key), list):\n                # append\n                self[key] += value\n            else:\n                # set the new value\n                self[key] = value", "response": "Recursively merge a dictionary or kwargs into the current dict."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _request(self, *args, **kwargs):\n        # type (Any) -> Response\n        \"\"\"Make requests using configured :class:`requests.Session`.\n        Any error details will be extracted to an :class:`HTTPError`\n        which will contain relevant error details when printed.\"\"\"\n        self._amend_request_kwargs(kwargs)\n        _response = self._requests_session.request(*args, **kwargs)\n        try:\n            _response.raise_for_status()\n        except HTTPError as e:\n            if e.response is not None:\n                raise_from(ConjureHTTPError(e), e)\n            raise e\n        return _response", "response": "Make a request to the specified resource."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndecoding a json object into a conjure bean type.", "response": "def decode_conjure_bean_type(cls, obj, conjure_type):\n        \"\"\"Decodes json into a conjure bean type (a plain bean, not enum\n        or union).\n\n        Args:\n            obj: the json object to decode\n            conjure_type: a class object which is the bean type\n                we're decoding into\n        Returns:\n            A instance of a bean of type conjure_type.\n        \"\"\"\n        deserialized = {}  # type: Dict[str, Any]\n        for (python_arg_name, field_definition) \\\n                in conjure_type._fields().items():\n            field_identifier = field_definition.identifier\n\n            if field_identifier not in obj or obj[field_identifier] is None:\n                cls.check_null_field(\n                    obj, deserialized, python_arg_name, field_definition)\n            else:\n                value = obj[field_identifier]\n                field_type = field_definition.field_type\n                deserialized[python_arg_name] = \\\n                    cls.do_decode(value, field_type)\n        return conjure_type(**deserialized)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndecode a json object into a conjure union type.", "response": "def decode_conjure_union_type(cls, obj, conjure_type):\n        \"\"\"Decodes json into a conjure union type.\n\n        Args:\n            obj: the json object to decode\n            conjure_type: a class object which is the union type\n                we're decoding into\n        Returns:\n            An instance of type conjure_type.\n        \"\"\"\n        type_of_union = obj[\"type\"]  # type: str\n        for attr, conjure_field in conjure_type._options().items():\n            if conjure_field.identifier == type_of_union:\n                attribute = attr\n                conjure_field_definition = conjure_field\n                break\n        else:\n            raise ValueError(\n                \"unknown union type {0} for {1}\".format(\n                    type_of_union, conjure_type\n                )\n            )\n\n        deserialized = {}  # type: Dict[str, Any]\n        if type_of_union not in obj or obj[type_of_union] is None:\n            cls.check_null_field(obj, deserialized, conjure_field_definition)\n        else:\n            value = obj[type_of_union]\n            field_type = conjure_field_definition.field_type\n            deserialized[attribute] = cls.do_decode(value, field_type)\n        return conjure_type(**deserialized)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndecoding a json object into a conjure enum type.", "response": "def decode_conjure_enum_type(cls, obj, conjure_type):\n        \"\"\"Decodes json into a conjure enum type.\n\n        Args:\n            obj: the json object to decode\n            conjure_type: a class object which is the enum type\n                we're decoding into.\n        Returns:\n            An instance of enum of type conjure_type.\n        \"\"\"\n        if not (isinstance(obj, str) or str(type(obj)) == \"<type 'unicode'>\"):\n            raise Exception(\n                'Expected to find str type but found {} instead'.format(\n                    type(obj)))\n\n        if obj in conjure_type.__members__:\n            return conjure_type[obj]\n\n        else:\n            return conjure_type[\"UNKNOWN\"]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef decode_dict(\n            cls,\n            obj,  # type: Dict[Any, Any]\n            key_type,  # ConjureTypeType\n            item_type,  # ConjureTypeType\n    ):  # type: (...) -> Dict[Any, Any]\n        \"\"\"Decodes json into a dictionary, handling conversion of the\n        keys/values (the keys/values may themselves require conversion).\n\n        Args:\n            obj: the json object to decode\n            key_type: a class object which is the conjure type\n                of the keys in this dict\n            item_type: a class object which is the conjure type\n                of the values in this dict\n        Returns:\n            A python dictionary, where the keys are instances of type key_type\n            and the values are of type value_type.\n        \"\"\"\n        if not isinstance(obj, dict):\n            raise Exception(\"expected a python dict\")\n        if key_type == str or isinstance(key_type, BinaryType) \\\n            or (inspect.isclass(key_type)\n                and issubclass(key_type, ConjureEnumType)):\n            return dict((\n                (cls.do_decode(x[0], key_type), cls.do_decode(x[1], item_type))\n                for x in obj.items()))\n\n        return dict((\n            (cls.do_decode(json.loads(x[0]), key_type),\n             cls.do_decode(x[1], item_type))\n            for x in obj.items()))", "response": "Decodes a json object into a python dictionary handling conversion of the\n            keys and values."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decode_list(cls, obj, element_type):\n        # type: (List[Any], ConjureTypeType) -> List[Any]\n        \"\"\"Decodes json into a list, handling conversion of the elements.\n\n        Args:\n            obj: the json object to decode\n            element_type: a class object which is the conjure type of\n                the elements in this list.\n        Returns:\n            A python list where the elements are instances of type\n                element_type.\n        \"\"\"\n        if not isinstance(obj, list):\n            raise Exception(\"expected a python list\")\n\n        return list(map(lambda x: cls.do_decode(x, element_type), obj))", "response": "Decodes a json object into a list handling conversion of the elements."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef do_decode(cls, obj, obj_type):\n        # type: (Any, ConjureTypeType) -> Any\n        \"\"\"Decodes json into the specified type\n\n        Args:\n            obj: the json object to decode\n            element_type: a class object which is the type we're decoding into.\n        \"\"\"\n        if inspect.isclass(obj_type) and issubclass(  # type: ignore\n                obj_type, ConjureBeanType\n        ):\n            return cls.decode_conjure_bean_type(obj, obj_type)  # type: ignore\n\n        elif inspect.isclass(obj_type) and issubclass(  # type: ignore\n                obj_type, ConjureUnionType\n        ):\n            return cls.decode_conjure_union_type(obj, obj_type)\n\n        elif inspect.isclass(obj_type) and issubclass(  # type: ignore\n                obj_type, ConjureEnumType\n        ):\n            return cls.decode_conjure_enum_type(obj, obj_type)\n\n        elif isinstance(obj_type, DictType):\n            return cls.decode_dict(obj, obj_type.key_type, obj_type.value_type)\n\n        elif isinstance(obj_type, ListType):\n            return cls.decode_list(obj, obj_type.item_type)\n\n        elif isinstance(obj_type, OptionalType):\n            return cls.decode_optional(obj, obj_type.item_type)\n\n        return cls.decode_primitive(obj, obj_type)", "response": "Decodes the json into the specified type\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef encode_conjure_bean_type(cls, obj):\n        # type: (ConjureBeanType) -> Any\n        \"\"\"Encodes a conjure bean into json\"\"\"\n        encoded = {}  # type: Dict[str, Any]\n        for attribute_name, field_definition in obj._fields().items():\n            encoded[field_definition.identifier] = cls.do_encode(\n                getattr(obj, attribute_name)\n            )\n        return encoded", "response": "Encodes a conjure bean into json"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encode_conjure_union_type(cls, obj):\n        # type: (ConjureUnionType) -> Any\n        \"\"\"Encodes a conjure union into json\"\"\"\n        encoded = {}  # type: Dict[str, Any]\n        encoded[\"type\"] = obj.type\n        for attr, field_definition in obj._options().items():\n            if field_definition.identifier == obj.type:\n                attribute = attr\n                break\n        else:\n            raise ValueError(\n                \"could not find attribute for union \" +\n                \"member {0} of type {1}\".format(obj.type, obj.__class__)\n            )\n\n        defined_field_definition = obj._options()[attribute]\n        encoded[defined_field_definition.identifier] = cls.do_encode(\n            getattr(obj, attribute)\n        )\n        return encoded", "response": "Encodes a conjure union into json"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nencodes the passed object into json", "response": "def do_encode(cls, obj):\n        # type: (Any) -> Any\n        \"\"\"Encodes the passed object into json\"\"\"\n        if isinstance(obj, ConjureBeanType):\n            return cls.encode_conjure_bean_type(obj)\n\n        elif isinstance(obj, ConjureUnionType):\n            return cls.encode_conjure_union_type(obj)\n\n        elif isinstance(obj, ConjureEnumType):\n            return obj.value\n\n        elif isinstance(obj, list):\n            return list(map(cls.do_encode, obj))\n\n        elif isinstance(obj, dict):\n            return {cls.do_encode(key): cls.do_encode(value)\n                    for key, value in obj.items()}\n\n        else:\n            return cls.encode_primitive(obj)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef become(cls, session_token):\n        response = client.get('/users/me', params={'session_token': session_token})\n        content = response.json()\n        user = cls()\n        user._update_data(content)\n        user._handle_save_result(True)\n        if 'smsCode' not in content:\n            user._attributes.pop('smsCode', None)\n        return user", "response": "Returns a new User object with the given session token."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsign up a user.", "response": "def sign_up(self, username=None, password=None):\n        \"\"\"\n        \u521b\u5efa\u4e00\u4e2a\u65b0\u7528\u6237\u3002\u65b0\u521b\u5efa\u7684 User \u5bf9\u8c61\uff0c\u5e94\u8be5\u4f7f\u7528\u6b64\u65b9\u6cd5\u6765\u5c06\u6570\u636e\u4fdd\u5b58\u81f3\u670d\u52a1\u5668\uff0c\u800c\u4e0d\u662f\u4f7f\u7528 save \u65b9\u6cd5\u3002\n        \u7528\u6237\u5bf9\u8c61\u4e0a\u5fc5\u987b\u5305\u542b username \u548c password \u4e24\u4e2a\u5b57\u6bb5\n        \"\"\"\n        if username:\n            self.set('username', username)\n        if password:\n            self.set('password', password)\n\n        username = self.get('username')\n        if not username:\n            raise TypeError('invalid username: {0}'.format(username))\n        password = self.get('password')\n        if not password:\n            raise TypeError('invalid password')\n\n        self.save(make_current=True)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlogin to the API.", "response": "def login(self, username=None, password=None):\n        \"\"\"\n        \u767b\u9646\u7528\u6237\u3002\u5982\u679c\u7528\u6237\u540d\u548c\u5bc6\u7801\u6b63\u786e\uff0c\u670d\u52a1\u5668\u4f1a\u8fd4\u56de\u7528\u6237\u7684 sessionToken \u3002\n        \"\"\"\n        if username:\n            self.set('username', username)\n        if password:\n            self.set('password', password)\n        response = client.post('/login', params=self.dump())\n        content = response.json()\n        self._update_data(content)\n        self._handle_save_result(True)\n        if 'smsCode' not in content:\n            self._attributes.pop('smsCode', None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfollows the user with the specified id.", "response": "def follow(self, target_id):\n        \"\"\"\n        \u5173\u6ce8\u4e00\u4e2a\u7528\u6237\u3002\n\n        :param target_id: \u9700\u8981\u5173\u6ce8\u7684\u7528\u6237\u7684 id\n        \"\"\"\n        if self.id is None:\n            raise ValueError('Please sign in')\n        response = client.post('/users/{0}/friendship/{1}'.format(self.id, target_id), None)\n        assert response.ok"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlogs-in with third - party authentication data.", "response": "def login_with(cls, platform, third_party_auth_data):\n        '''\n        \u628a\u7b2c\u4e09\u65b9\u5e73\u53f0\u53f7\u7ed1\u5b9a\u5230 User \u4e0a\n\n        \uff1aparam platform: \u7b2c\u4e09\u65b9\u5e73\u53f0\u540d\u79f0 base string\n        '''\n        user = User()\n        return user.link_with(platform, third_party_auth_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unlink_from(self, provider):\n        '''\n        \u89e3\u7ed1\u7279\u5b9a\u7b2c\u4e09\u65b9\u5e73\u53f0\n        '''\n        if type(provider) != str:\n            raise TypeError('input should be a string')\n        self.link_with(provider, None)\n        # self._sync_auth_data(provider)\n        return self", "response": "unlink from a provider"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef signup_or_login_with_mobile_phone(cls, phone_number, sms_code):\n        '''\n        param phone_nubmer: string_types\n        param sms_code: string_types\n\n        \u5728\u8c03\u7528\u6b64\u65b9\u6cd5\u524d\u8bf7\u5148\u4f7f\u7528 request_sms_code \u8bf7\u6c42 sms code\n        '''\n        data = {\n            'mobilePhoneNumber': phone_number,\n            'smsCode': sms_code\n        }\n        response = client.post('/usersByMobilePhone', data)\n        content = response.json()\n        user = cls()\n        user._update_data(content)\n        user._handle_save_result(True)\n        if 'smsCode' not in content:\n            user._attributes.pop('smsCode', None)\n        return user", "response": "signup_or_login_with_mobile_phone - Signup or login with mobile phone number sms_code - sms code"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef refresh_session_token(self):\n        response = client.put('/users/{}/refreshSessionToken'.format(self.id), None)\n        content = response.json()\n        self._update_data(content)\n        self._handle_save_result(False)", "response": "\u91cd\u7f6e\u5f53\u524d\u7528\u6237 `session token`\u3002\n        \u4f1a\u4f7f\u5176\u4ed6\u5ba2\u6237\u7aef\u5df2\u767b\u5f55\u7528\u6237\u767b\u5f55\u5931\u6548\u3002"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_authenticated(self):\n        '''\n        \u5224\u65ad\u5f53\u524d\u7528\u6237\u5bf9\u8c61\u662f\u5426\u5df2\u767b\u5f55\u3002\n        \u4f1a\u5148\u68c0\u67e5\u6b64\u7528\u6237\u5bf9\u8c61\u4e0a\u662f\u5426\u6709 `session_token`\uff0c\u5982\u679c\u6709\u7684\u8bdd\uff0c\u4f1a\u7ee7\u7eed\u8bf7\u6c42\u670d\u52a1\u5668\u9a8c\u8bc1 `session_token` \u662f\u5426\u5408\u6cd5\u3002\n        '''\n        session_token = self.get_session_token()\n        if not session_token:\n            return False\n        try:\n            response = client.get('/users/me', params={'session_token': session_token})\n        except LeanCloudError as e:\n            if e.code == 211:\n                return False\n            else:\n                raise\n        return response.status_code == 200", "response": "Check if user is authenticated"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind all messages from a client.", "response": "def find_by_client(cls, from_client, limit=None, before_time=None, before_message_id=None):\n        # type: (str, Optional[int], Optional[Union[datetime, float]], Optional[str]) -> List[Message]\n        \"\"\"\u83b7\u53d6\u67d0\u4e2a client \u7684\u804a\u5929\u8bb0\u5f55\n\n        :param from_client: \u8981\u83b7\u53d6\u804a\u5929\u8bb0\u5f55\u7684 client id\n        :param limit: \u8fd4\u56de\u6761\u6570\u9650\u5236\uff0c\u53ef\u9009\uff0c\u670d\u52a1\u7aef\u9ed8\u8ba4 100 \u6761\uff0c\u6700\u5927 1000 \u6761\n        :param before_time: \u67e5\u8be2\u8d77\u59cb\u7684\u65f6\u95f4\u6233\uff0c\u8fd4\u56de\u5c0f\u4e8e\u8fd9\u4e2a\u65f6\u95f4(\u4e0d\u5305\u542b)\u7684\u8bb0\u5f55\uff0c\u670d\u52a1\u7aef\u9ed8\u8ba4\u662f\u5f53\u524d\u65f6\u95f4\n        :param before_message_id: \u8d77\u59cb\u7684\u6d88\u606f id\uff0c\u4f7f\u7528\u65f6\u5fc5\u987b\u52a0\u4e0a\u5bf9\u5e94\u6d88\u606f\u7684\u65f6\u95f4 before_time \u53c2\u6570\uff0c\u4e00\u8d77\u4f5c\u4e3a\u67e5\u8be2\u7684\u8d77\u70b9\n        :return: \u7b26\u5408\u6761\u4ef6\u7684\u804a\u5929\u8bb0\u5f55\n        \"\"\"\n        query_params = {}  # type: Dict[str, Any]\n        query_params['from'] = from_client\n        if limit is not None:\n            query_params['limit'] = limit\n        if isinstance(before_time, datetime):\n            query_params['max_ts'] =  round(before_time.timestamp() * 1000)\n        elif isinstance(before_time, six.integer_types) or isinstance(before_time, float):\n            query_params['max_ts'] = round(before_time * 1000)\n        if before_message_id is not None:\n            query_params['msgid'] = before_message_id\n        return list(cls._find(query_params))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef extend(cls, name):\n        if six.PY2 and isinstance(name, six.text_type):\n            # In python2, class name must be a python2 str.\n            name = name.encode('utf-8')\n        return type(name, (cls,), {})", "response": "Extend a leancloud. Object class by adding new object attributes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(cls, class_name, **attributes):\n        object_class = cls.extend(class_name)\n        return object_class(**attributes)", "response": "Create a new object of the specified class."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_without_data(cls, id_):\n        if cls is Object:\n            raise RuntimeError('can not call create_without_data on leancloud.Object')\n        obj = cls()\n        obj.id = id_\n        return obj", "response": "create a new object without data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndestroy all objects in a list", "response": "def destroy_all(cls, objs):\n        \"\"\"\n        \u5728\u4e00\u4e2a\u8bf7\u6c42\u4e2d destroy \u591a\u4e2a leancloud.Object \u5bf9\u8c61\u5b9e\u4f8b\u3002\n\n        :param objs: \u9700\u8981 destroy \u7684\u5bf9\u8c61\n        :type objs: list\n        \"\"\"\n        if not objs:\n            return\n        if any(x.is_new() for x in objs):\n            raise ValueError(\"Could not destroy unsaved object\")\n\n        dumped_objs = []\n        for obj in objs:\n            dumped_obj = {\n                'method': 'DELETE',\n                'path': '/{0}/classes/{1}/{2}'.format(client.SERVER_VERSION, obj._class_name, obj.id),\n                'body': obj._flags,\n            }\n            dumped_objs.append(dumped_obj)\n\n        response = client.post('/batch', params={'requests': dumped_objs}).json()\n\n        errors = []\n        for idx, obj in enumerate(objs):\n            content = response[idx]\n            error = content.get('error')\n            if error:\n                errors.append(leancloud.LeanCloudError(error.get('code'), error.get('error')))\n\n        if errors:\n            # TODO: how to raise list of errors?\n            # raise MultipleValidationErrors(errors)\n            # add test\n            raise errors[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save(self, where=None, fetch_when_save=None):\n        if where and not isinstance(where, leancloud.Query):\n            raise TypeError('where param type should be leancloud.Query, got %s', type(where))\n\n        if where and where._query_class._class_name != self._class_name:\n            raise TypeError('where param\\'s class name not equal to the current object\\'s class name')\n\n        if where and self.is_new():\n            raise TypeError('where params works only when leancloud.Object is saved')\n\n        unsaved_children = []\n        unsaved_files = []\n        self._find_unsaved_children(self._attributes, unsaved_children, unsaved_files)\n        if unsaved_children or unsaved_files:\n            self._deep_save(unsaved_children, unsaved_files, exclude=self._attributes)\n\n        data = self._dump_save()\n        fetch_when_save = 'true' if fetch_when_save else 'false'\n\n        if self.is_new():\n            response = client.post('/classes/{0}?fetchWhenSave={1}'.format(self._class_name, fetch_when_save), data)\n        else:\n            url = '/classes/{0}/{1}?fetchWhenSave={2}'.format(self._class_name, self.id, fetch_when_save)\n            if where:\n                url += '&where=' + json.dumps(where.dump()['where'], separators=(',', ':'))\n            response = client.put(url, data)\n\n        self._update_data(response.json())", "response": "Save the current object to the server."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a relation object with the specified attribute.", "response": "def relation(self, attr):\n        \"\"\"\n        \u8fd4\u56de\u5bf9\u8c61\u4e0a\u76f8\u5e94\u5b57\u6bb5\u7684 Relation\n\n        :param attr: \u5b57\u6bb5\u540d\n        :type attr: string_types\n        :return: Relation\n        :rtype: leancloud.Relation\n        \"\"\"\n        value = self.get(attr)\n        if value is not None:\n            if not isinstance(value, leancloud.Relation):\n                raise TypeError('field %s is not Relation'.format(attr))\n            value._ensure_parent_and_key(self, attr)\n            return value\n        return leancloud.Relation(self, attr)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the value of the object.", "response": "def set(self, key_or_attrs, value=None, unset=False):\n        \"\"\"\n        \u5728\u5f53\u524d\u5bf9\u8c61\u6b64\u5b57\u6bb5\u4e0a\u8d4b\u503c\n\n        :param key_or_attrs: \u5b57\u6bb5\u540d\uff0c\u6216\u8005\u4e00\u4e2a\u5305\u542b \u5b57\u6bb5\u540d / \u503c\u7684 dict\n        :type key_or_attrs: string_types or dict\n        :param value: \u5b57\u6bb5\u503c\n        :param unset:\n        :return: \u5f53\u524d\u5bf9\u8c61\uff0c\u4f9b\u94fe\u5f0f\u8c03\u7528\n        \"\"\"\n        if isinstance(key_or_attrs, dict) and value is None:\n            attrs = key_or_attrs\n            keys = attrs.keys()\n            for k in keys:\n                if isinstance(attrs[k], LocalProxy):\n                    attrs[k] = attrs[k]._get_current_object()\n        else:\n            key = key_or_attrs\n            if isinstance(value, LocalProxy):\n                value = value._get_current_object()\n            attrs = {key: utils.decode(key, value)}\n\n        if unset:\n            for k in attrs.keys():\n                attrs[k] = operation.Unset()\n\n        self.validate(attrs)\n\n        self._merge_metadata(attrs)\n\n        keys = list(attrs.keys())\n        for k in keys:\n            v = attrs[k]\n            # TODO: Relation\n\n            if not isinstance(v, operation.BaseOp):\n                v = operation.Set(v)\n\n            self._attributes[k] = v._apply(self._attributes.get(k), self, k)\n            if self._attributes[k] == operation._UNSET:\n                del self._attributes[k]\n            self._changes[k] = v._merge(self._changes.get(k))\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a unique item to the set attr.", "response": "def add_unique(self, attr, item):\n        \"\"\"\n        \u5728\u5bf9\u8c61\u6b64\u5b57\u6bb5\u5bf9\u5e94\u7684\u6570\u7ec4\u672b\u5c3e\u6dfb\u52a0\u6307\u5b9a\u5bf9\u8c61\uff0c\u5982\u679c\u6b64\u5bf9\u8c61\u5e76\u6ca1\u6709\u5305\u542b\u5728\u5b57\u6bb5\u4e2d\u3002\n\n        :param attr: \u5b57\u6bb5\u540d\n        :param item: \u8981\u6dfb\u52a0\u7684\u5bf9\u8c61\n        :return: \u5f53\u524d\u5bf9\u8c61\n        \"\"\"\n        return self.set(attr, operation.AddUnique([item]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove(self, attr, item):\n        return self.set(attr, operation.Remove([item]))", "response": "\u5728\u5bf9\u8c61\u6b64\u5b57\u6bb5\u5bf9\u5e94\u7684\u6570\u7ec4\u4e2d\uff0c\u5c06\u6307\u5b9a\u5bf9\u8c61\u5168\u90e8\u79fb\u9664\u3002\n\n        :param attr: \u5b57\u6bb5\u540d\n        :param item: \u8981\u79fb\u9664\u7684\u5bf9\u8c61\n        :return: \u5f53\u524d\u5bf9\u8c61"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfetch the related object from the API.", "response": "def fetch(self, select=None, include=None):\n        \"\"\"\n        \u4ece\u670d\u52a1\u5668\u83b7\u53d6\u5f53\u524d\u5bf9\u8c61\u6240\u6709\u7684\u503c\uff0c\u5982\u679c\u4e0e\u672c\u5730\u503c\u4e0d\u540c\uff0c\u5c06\u4f1a\u8986\u76d6\u672c\u5730\u7684\u503c\u3002\n\n        :return: \u5f53\u524d\u5bf9\u8c61\n        \"\"\"\n        data = {}\n        if select:\n            if not isinstance(select, (list, tuple)):\n                raise TypeError('select parameter must be a list or a tuple')\n            data['keys'] = ','.join(select)\n        if include:\n            if not isinstance(include, (list, tuple)):\n                raise TypeError('include parameter must be a list or a tuple')\n            data['include'] = ','.join(include)\n        response = client.get('/classes/{0}/{1}'.format(self._class_name, self.id), data)\n        self._update_data(response.json())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send(data, channels=None, push_time=None, expiration_time=None, expiration_interval=None, where=None, cql=None):\n    if expiration_interval and expiration_time:\n        raise TypeError('Both expiration_time and expiration_interval can\\'t be set')\n\n    params = {\n        'data': data,\n    }\n\n    if client.USE_PRODUCTION == '0':\n        params['prod'] = 'dev'\n\n    if channels:\n        params['channels'] = channels\n    if push_time:\n        tzinfo = push_time.tzinfo\n        if tzinfo is None:\n            tzinfo = tz.tzlocal()\n        params['push_time'] = arrow.get(push_time, tzinfo).to('utc').format('YYYY-MM-DDTHH:mm:ss.SSS') + 'Z'\n    if expiration_time:\n        params['expiration_time'] = expiration_time.isoformat()\n    if expiration_interval:\n        params['expiration_interval'] = expiration_interval\n    if where:\n        params['where'] = where.dump().get('where', {})\n    if cql:\n        params['cql'] = cql\n\n    result = client.post('/push', params=params).json()\n\n    notification = Notification.create_without_data(result['objectId'])\n    return notification", "response": "Send data to a list of channels."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfetching the data from the server", "response": "def fetch(self, *args, **kwargs):\n        \"\"\"\u540c\u6b65\u670d\u52a1\u5668\u7684 Notification \u6570\u636e\n        \"\"\"\n        response = client.get('/tables/Notifications/{0}'.format(self.id))\n        self._update_data(response.json())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a new object to the relation.", "response": "def add(self, *obj_or_objs):\n        \"\"\"\n        \u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684 leancloud.Object \u81f3 Relation\u3002\n\n        :param obj_or_objs: \u9700\u8981\u6dfb\u52a0\u7684\u5bf9\u8c61\u6216\u5bf9\u8c61\u5217\u8868\n        \"\"\"\n        objs = obj_or_objs\n        if not isinstance(obj_or_objs, (list, tuple)):\n            objs = (obj_or_objs, )\n        change = operation.Relation(objs, ())\n        self.parent.set(self.key, change)\n        self.target_class_name = change._target_class_name"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a Query object that can be used to query the relation.", "response": "def query(self):\n        \"\"\"\n        \u83b7\u53d6\u6307\u5411 Relation \u5185\u5bb9\u7684 Query \u5bf9\u8c61\u3002\n\n        :rtype: leancloud.Query\n        \"\"\"\n\n        if self.target_class_name is None:\n            target_class = leancloud.Object.extend(self.parent._class_name)\n            query = leancloud.Query(target_class)\n            query._extra['redirectClassNameForKey'] = self.key\n        else:\n            target_class = leancloud.Object.extend(self.target_class_name)\n            query = leancloud.Query(target_class)\n\n        query._add_condition('$relatedTo', 'object', self.parent._to_pointer())\n        query._add_condition('$relatedTo', 'key', self.key)\n\n        return query"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef or_(cls, *queries):\n        if len(queries) < 2:\n            raise ValueError('or_ need two queries at least')\n        if not all(x._query_class._class_name == queries[0]._query_class._class_name for x in queries):\n            raise TypeError('All queries must be for the same class')\n        query = Query(queries[0]._query_class._class_name)\n        query._or_query(queries)\n        return query", "response": "Returns a new Query instance with the given class or all of the given queries."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef and_(cls, *queries):\n        if len(queries) < 2:\n            raise ValueError('and_ need two queries at least')\n        if not all(x._query_class._class_name == queries[0]._query_class._class_name for x in queries):\n            raise TypeError('All queries must be for the same class')\n        query = Query(queries[0]._query_class._class_name)\n        query._and_query(queries)\n        return query", "response": "A wrapper for _and_ query that returns a new Query instance with the same class and all of the given queries."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef do_cloud_query(cls, cql, *pvalues):\n        params = {'cql': cql}\n        if len(pvalues) == 1 and isinstance(pvalues[0], (tuple, list)):\n            pvalues = json.dumps(pvalues[0])\n        if len(pvalues) > 0:\n            params['pvalues'] = json.dumps(pvalues)\n\n        content = client.get('/cloudQuery', params).json()\n\n        objs = []\n        query = cls(content['className'])\n        for result in content['results']:\n            obj = query._new_object()\n            obj._update_data(query._process_result(result))\n            objs.append(obj)\n\n        return CQLResult(objs, content.get('count'), content.get('className'))", "response": "Query the Cloud Infrastructure for a given CQL query."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dump(self):\n        params = {\n            'where': self._where,\n        }\n        if self._include:\n            params['include'] = ','.join(self._include)\n        if self._select:\n            params['keys'] = ','.join(self._select)\n        if self._include_acl is not None:\n            params['returnACL'] = json.dumps(self._include_acl)\n        if self._limit >= 0:\n            params['limit'] = self._limit\n        if self._skip > 0:\n            params['skip'] = self._skip\n        if self._order:\n            params['order'] = \",\".join(self._order)\n        params.update(self._extra)\n        return params", "response": "Returns a dict representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the first object in the object store.", "response": "def first(self):\n        \"\"\"\n        \u6839\u636e\u67e5\u8be2\u83b7\u53d6\u6700\u591a\u4e00\u4e2a\u5bf9\u8c61\u3002\n\n        :return: \u67e5\u8be2\u7ed3\u679c\n        :rtype: Object\n        :raise: LeanCloudError\n        \"\"\"\n        params = self.dump()\n        params['limit'] = 1\n        content = self._do_request(params)\n        results = content['results']\n        if not results:\n            raise LeanCloudError(101, 'Object not found')\n        obj = self._new_object()\n        obj._update_data(self._process_result(results[0]))\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, object_id):\n        if not object_id:\n            raise LeanCloudError(code=101, error='Object not found.')\n        obj = self._query_class.create_without_data(object_id)\n        obj.fetch(select=self._select, include=self._include)\n        return obj", "response": "Get object by id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of all the objects in the database.", "response": "def find(self):\n        \"\"\"\n        \u6839\u636e\u67e5\u8be2\u6761\u4ef6\uff0c\u83b7\u53d6\u5305\u542b\u6240\u6709\u6ee1\u8db3\u6761\u4ef6\u7684\u5bf9\u8c61\u3002\n\n        :rtype: list\n        \"\"\"\n        content = self._do_request(self.dump())\n\n        objs = []\n        for result in content['results']:\n            obj = self._new_object()\n            obj._update_data(self._process_result(result))\n            objs.append(obj)\n\n        return objs"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget count of all the keys", "response": "def count(self):\n        \"\"\"\n        \u8fd4\u56de\u6ee1\u8db3\u67e5\u8be2\u6761\u4ef6\u7684\u5bf9\u8c61\u7684\u6570\u91cf\u3002\n\n        :rtype: int\n        \"\"\"\n        params = self.dump()\n        params['limit'] = 0\n        params['count'] = 1\n        content = self._do_request(params)\n        return content['count']"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef equal_to(self, key, value):\n        self._where[key] = utils.encode(value)\n        return self", "response": "Sets the value of the key in the set of where clauses."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the condition for the current instance to match the given key.", "response": "def matched(self, key, regex, ignore_case=False, multi_line=False):\n        \"\"\"\n        \u589e\u52a0\u67e5\u8be2\u6761\u4ef6\uff0c\u9650\u5236\u67e5\u8be2\u7ed3\u679c\u5bf9\u8c61\u6307\u5b9a\u5b57\u6bb5\u6ee1\u8db3\u6307\u5b9a\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\u3002\n\n        :param key: \u67e5\u8be2\u6761\u4ef6\u5b57\u6bb5\u540d\n        :param regex: \u67e5\u8be2\u6b63\u5219\u8868\u8fbe\u5f0f\n        :param ignore_case: \u67e5\u8be2\u662f\u5426\u5ffd\u7565\u5927\u5c0f\u5199\uff0c\u9ed8\u8ba4\u4e0d\u5ffd\u7565\n        :param multi_line: \u67e5\u8be2\u662f\u5426\u5339\u914d\u591a\u884c\uff0c\u9ed8\u8ba4\u4e0d\u5339\u914d\n        :rtype: Query\n        \"\"\"\n        if not isinstance(regex, six.string_types):\n            raise TypeError('matched only accept str or unicode')\n        self._add_condition(key, '$regex', regex)\n        modifiers = ''\n        if ignore_case:\n            modifiers += 'i'\n        if multi_line:\n            modifiers += 'm'\n        if modifiers:\n            self._add_condition(key, '$options', modifiers)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the condition that matches the given query.", "response": "def matches_query(self, key, query):\n        \"\"\"\n        \u589e\u52a0\u67e5\u8be2\u6761\u4ef6\uff0c\u9650\u5236\u67e5\u8be2\u7ed3\u679c\u5bf9\u8c61\u6307\u5b9a\u5b57\u6bb5\u7684\u503c\uff0c\u4e0e\u53e6\u5916\u4e00\u4e2a\u67e5\u8be2\u5bf9\u8c61\u7684\u8fd4\u56de\u7ed3\u679c\u76f8\u540c\u3002\n\n        :param key: \u67e5\u8be2\u6761\u4ef6\u5b57\u6bb5\u540d\n        :param query: \u67e5\u8be2\u5bf9\u8c61\n        :type query: Query\n        :rtype: Query\n        \"\"\"\n        dumped = query.dump()\n        dumped['className'] = query._query_class._class_name\n        self._add_condition(key, '$inQuery', dumped)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef matches_key_in_query(self, key, query_key, query):\n        dumped = query.dump()\n        dumped['className'] = query._query_class._class_name\n        self._add_condition(key, '$select', {'key': query_key, 'query': dumped})\n        return self", "response": "Sets the condition that matches the key in the query."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef contains(self, key, value):\n        self._add_condition(key, '$regex', self._quote(value))\n        return self", "response": "Sets the condition to be true if the key is contained in the value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the condition key to match the given value.", "response": "def startswith(self, key, value):\n        \"\"\"\n        \u589e\u52a0\u67e5\u8be2\u6761\u4ef6\uff0c\u9650\u5236\u67e5\u8be2\u7ed3\u679c\u5bf9\u8c61\u6307\u5b9a\u6700\u77ed\u7684\u503c\uff0c\u4ee5\u6307\u5b9a\u5b57\u7b26\u4e32\u5f00\u5934\u3002\u5728\u6570\u636e\u91cf\u6bd4\u8f83\u5927\u7684\u60c5\u51b5\u4e0b\u4f1a\u6bd4\u8f83\u6162\u3002\n\n        :param key: \u67e5\u8be2\u6761\u4ef6\u5b57\u6bb5\u540d\n        :param value: \u9700\u8981\u67e5\u8be2\u7684\u5b57\u7b26\u4e32\n        :rtype: Query\n        \"\"\"\n        value = value if isinstance(value, six.text_type) else value.decode('utf-8')\n        self._add_condition(key, '$regex', '^' + self._quote(value))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef near(self, key, point):\n        if point is None:\n            raise ValueError('near query does not accept None')\n\n        self._add_condition(key, '$nearSphere', point)\n        return self", "response": "add a near - sphere condition to the set"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef within_radians(self, key, point, max_distance, min_distance=None):\n        self.near(key, point)\n        self._add_condition(key, '$maxDistance', max_distance)\n        if min_distance is not None:\n            self._add_condition(key, '$minDistance', min_distance)\n        return self", "response": "Query the set of keys that are within a given distance from a point."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef within_miles(self, key, point, max_distance, min_distance=None):\n        if min_distance is not None:\n            min_distance = min_distance / 3958.8\n        return self.within_radians(key, point, max_distance / 3958.8, min_distance)", "response": "Query the set of keys within Miles."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nquerying the set of keys within kilometers.", "response": "def within_kilometers(self, key, point, max_distance, min_distance=None):\n        \"\"\"\n        \u589e\u52a0\u67e5\u8be2\u6761\u4ef6\uff0c\u9650\u5236\u8fd4\u56de\u7ed3\u679c\u6307\u5b9a\u5b57\u6bb5\u503c\u7684\u4f4d\u7f6e\u5728\u67d0\u70b9\u7684\u4e00\u6bb5\u8ddd\u79bb\u4e4b\u5185\u3002\n\n        :param key: \u67e5\u8be2\u6761\u4ef6\u5b57\u6bb5\u540d\n        :param point: \u67e5\u8be2\u5730\u7406\u4f4d\u7f6e\n        :param max_distance: \u6700\u5927\u8ddd\u79bb\u9650\u5b9a\uff08\u5343\u7c73\uff09\n        :param min_distance: \u6700\u5c0f\u8ddd\u79bb\u9650\u5b9a\uff08\u5343\u7c73\uff09\n        :rtype: Query\n        \"\"\"\n        if min_distance is not None:\n            min_distance = min_distance / 6371.0\n        return self.within_radians(key, point, max_distance / 6371.0, min_distance)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a where clause that checks if a key is within a geo box", "response": "def within_geo_box(self, key, southwest, northeast):\n        \"\"\"\n        \u589e\u52a0\u67e5\u8be2\u6761\u4ef6\uff0c\u9650\u5236\u8fd4\u56de\u7ed3\u679c\u6307\u5b9a\u5b57\u6bb5\u503c\u7684\u4f4d\u7f6e\u5728\u6307\u5b9a\u5750\u6807\u8303\u56f4\u4e4b\u5185\u3002\n\n        :param key: \u67e5\u8be2\u6761\u4ef6\u5b57\u6bb5\u540d\n        :param southwest: \u9650\u5236\u8303\u56f4\u897f\u5357\u89d2\u5750\u6807\n        :param northeast: \u9650\u5236\u8303\u56f4\u4e1c\u5317\u89d2\u5750\u6807\n        :rtype: Query\n        \"\"\"\n        self._add_condition(key, '$within', {'$box': [southwest, northeast]})\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a set of keys to the include list.", "response": "def include(self, *keys):\n        \"\"\"\n        \u6307\u5b9a\u67e5\u8be2\u8fd4\u56de\u7ed3\u679c\u4e2d\u5305\u542b\u5173\u8054\u8868\u5b57\u6bb5\u3002\n\n        :param keys: \u5173\u8054\u5b50\u8868\u5b57\u6bb5\u540d\n        :rtype: Query\n        \"\"\"\n        if len(keys) == 1 and isinstance(keys[0], (list, tuple)):\n            keys = keys[0]\n        self._include += keys\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef select(self, *keys):\n        if len(keys) == 1 and isinstance(keys[0], (list, tuple)):\n            keys = keys[0]\n        self._select += keys\n        return self", "response": "Select all the keys in the current set."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(_cloud_func_name, **params):\n    response = leancloud.client.post('/functions/{0}'.format(_cloud_func_name), params=params)\n    content = response.json()\n    return utils.decode(None, content)['result']", "response": "\u8c03\u7528 LeanEngine \u4e0a\u7684\u8fdc\u7a0b\u4ee3\u7801\n    :param name: \u9700\u8981\u8c03\u7528\u7684\u8fdc\u7a0b Cloud Code \u7684\u540d\u79f0\n    :type name: string_types\n    :param params: \u8c03\u7528\u53c2\u6570\n    :return: \u8c03\u7528\u7ed3\u679c"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef request_sms_code(phone_number, idd='+86', sms_type='sms',\n                     validate_token=None, template=None, sign=None,\n                     params=None):\n    \"\"\"\n    \u8bf7\u6c42\u53d1\u9001\u624b\u673a\u9a8c\u8bc1\u7801\n    :param phone_number: \u9700\u8981\u9a8c\u8bc1\u7684\u624b\u673a\u53f7\u7801\n    :param idd: \u53f7\u7801\u7684\u6240\u5728\u5730\u56fd\u5bb6\u4ee3\u7801\uff0c\u9ed8\u8ba4\u4e3a\u4e2d\u56fd\uff08+86\uff09\n    :param sms_type: \u9a8c\u8bc1\u7801\u53d1\u9001\u65b9\u5f0f\uff0c'voice' \u4e3a\u8bed\u97f3\uff0c'sms' \u4e3a\u77ed\u4fe1\n    :param template: \u6a21\u7248\u540d\u79f0\n    :param sign: \u77ed\u4fe1\u7b7e\u540d\u540d\u79f0\n    :return: None\n    \"\"\"\n    if not isinstance(phone_number, six.string_types):\n        raise TypeError('phone_number must be a string')\n\n    data = {\n        'mobilePhoneNumber': idd + phone_number,\n        'smsType': sms_type,\n    }\n\n    if template is not None:\n        data['template'] = template\n\n    if sign is not None:\n        data['sign'] = sign\n\n    if validate_token is not None:\n        data['validate_token'] = validate_token\n\n    if params is not None:\n        data.update(params)\n\n    leancloud.client.post('/requestSmsCode', params=data)", "response": "\u8bf7\u6c42\u53d1\u9001\u624b\u673a\u9a8c\u8bc1\u7801\n    :param phone_number: \u9700\u8981\u9a8c\u8bc1\u7684\u624b\u673a\u53f7\u7801\n    :param idd: \u53f7\u7801\u7684\u6240\u5728\u5730\u56fd\u5bb6\u4ee3\u7801\uff0c\u9ed8\u8ba4\u4e3a\u4e2d\u56fd\uff08+86\uff09\n    :param sms_type: \u9a8c\u8bc1\u7801\u53d1\u9001\u65b9\u5f0f\uff0c'voice' \u4e3a\u8bed\u97f3\uff0c'sms' \u4e3a\u77ed\u4fe1\n    :param template: \u6a21\u7248\u540d\u79f0\n    :param sign: \u77ed\u4fe1\u7b7e\u540d\u540d\u79f0\n    :return: None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrequest a new captcha.", "response": "def request_captcha(size=None, width=None, height=None, ttl=None):\n    \"\"\"\n    \u8bf7\u6c42\u751f\u6210\u65b0\u7684\u56fe\u5f62\u9a8c\u8bc1\u7801\n    :return: Captcha\n    \"\"\"\n    params = {\n        'size': size,\n        'width': width,\n        'height': height,\n        'ttl': ttl,\n    }\n    params = {k: v for k, v in params.items() if v is not None}\n\n    response = leancloud.client.get('/requestCaptcha', params)\n    content = response.json()\n    return Captcha(content['captcha_token'], content['captcha_url'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a message to the specified list of nodes.", "response": "def send(self, from_client, message, to_clients=None, transient=False, push_data=None):\n        \"\"\"\n        \u5728\u6307\u5b9a\u4f1a\u8bdd\u4e2d\u53d1\u9001\u6d88\u606f\u3002\n\n        :param from_client: \u53d1\u9001\u8005 id\n        :param message: \u6d88\u606f\u5185\u5bb9\n        :param to_clients: \u63a5\u53d7\u8005 id\uff0c\u53ea\u5728\u7cfb\u7edf\u4f1a\u8bdd\u4e2d\u751f\u6548\n        :param transient: \u662f\u5426\u4ee5\u6682\u6001\u5f62\u5f0f\u53d1\u9001\u6d88\u606f\n        :param push_data: \u63a8\u9001\u6d88\u606f\u5185\u5bb9\uff0c\u53c2\u8003\uff1ahttps://url.leanapp.cn/pushData\n        \"\"\"\n        if isinstance(message, dict):\n            message = json.dumps(message)\n        params = {\n            'from_peer': from_client,\n            'conv_id': self.id,\n            'transient': transient,\n            'message': message,\n        }\n        if to_clients:\n            params['to_peers'] = to_clients\n        if push_data:\n            params['push_data'] = push_data\n        client.post('/rtm/messages', params=params).json()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef broadcast(self, from_client, message, valid_till=None, push_data=None):\n        if isinstance(message, dict):\n            message = json.dumps(message)\n        params = {\n            'from_peer': from_client,\n            'conv_id': self.id,\n            'message': message,\n        }\n        if push_data:\n            params['push_data'] = push_data\n        if valid_till:\n            if isinstance(valid_till, datetime):\n                valid_till = arrow.get(valid_till).datetime\n            params['valid_till'] = valid_till\n        client.post('/rtm/broadcast', params=params).json()", "response": "broadcast a message to the peer"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize the LeanCloud application.", "response": "def init(app_id, app_key=None, master_key=None, hook_key=None):\n    \"\"\"\u521d\u59cb\u5316 LeanCloud \u7684 AppId / AppKey / MasterKey\n\n    :type app_id: string_types\n    :param app_id: \u5e94\u7528\u7684 Application ID\n    :type app_key: None or string_types\n    :param app_key: \u5e94\u7528\u7684 Application Key\n    :type master_key: None or string_types\n    :param master_key: \u5e94\u7528\u7684 Master Key\n    :param hook_key: application's hook key\n    :type hook_key: None or string_type\n    \"\"\"\n    if (not app_key) and (not master_key):\n        raise RuntimeError('app_key or master_key must be specified')\n    global APP_ID, APP_KEY, MASTER_KEY, HOOK_KEY\n    APP_ID = app_id\n    APP_KEY = app_key\n    MASTER_KEY = master_key\n    if hook_key:\n        HOOK_KEY = hook_key\n    else:\n        HOOK_KEY = os.environ.get('LEANCLOUD_APP_HOOK_KEY')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the global USE_MASTER_KEY to True if the master key is not set.", "response": "def use_master_key(flag=True):\n    \"\"\"\u662f\u5426\u4f7f\u7528 master key \u53d1\u9001\u8bf7\u6c42\u3002\n    \u5982\u679c\u4e0d\u8c03\u7528\u6b64\u51fd\u6570\uff0c\u4f1a\u6839\u636e leancloud.init \u7684\u53c2\u6570\u6765\u51b3\u5b9a\u662f\u5426\u4f7f\u7528 master key\u3002\n\n    :type flag: bool\n    \"\"\"\n    global USE_MASTER_KEY\n    if not flag:\n        USE_MASTER_KEY = False\n        return\n    if not MASTER_KEY:\n        raise RuntimeError('LeanCloud SDK master key not specified')\n    USE_MASTER_KEY = True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef radians_to(self, other):\n        d2r = math.pi / 180.0\n        lat1rad = self.latitude * d2r\n        long1rad = self.longitude * d2r\n\n        lat2rad = other.latitude * d2r\n        long2rad = other.longitude * d2r\n\n        delta_lat = lat1rad - lat2rad\n        delta_long = long1rad - long2rad\n\n        sin_delta_lat_div2 = math.sin(delta_lat / 2.0)\n        sin_delta_long_div2 = math.sin(delta_long / 2.0)\n\n        a = ((sin_delta_lat_div2 * sin_delta_lat_div2) +\n             (math.cos(lat1rad) * math.cos(lat2rad) *\n              sin_delta_long_div2 * sin_delta_long_div2))\n        a = min(1.0, a)\n        return 2 * math.asin(math.sqrt(a))", "response": "Returns the distance from this GeoPoint to another in radians."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npaint checkbox and text _| | _| _", "response": "def paint(self, painter, option, index):\n        \"\"\"Paint checkbox and text\n         _\n        |_|  My label\n\n        \"\"\"\n\n        body_rect = QtCore.QRectF(option.rect)\n\n        check_rect = QtCore.QRectF(body_rect)\n        check_rect.setWidth(check_rect.height())\n        check_rect.adjust(6, 6, -6, -6)\n\n        check_color = colors[\"idle\"]\n\n        if index.data(model.IsProcessing) is True:\n            check_color = colors[\"active\"]\n\n        elif index.data(model.HasFailed) is True:\n            check_color = colors[\"warning\"]\n\n        elif index.data(model.HasSucceeded) is True:\n            check_color = colors[\"ok\"]\n\n        elif index.data(model.HasProcessed) is True:\n            check_color = colors[\"ok\"]\n\n        metrics = painter.fontMetrics()\n\n        label_rect = QtCore.QRectF(option.rect.adjusted(\n            check_rect.width() + 12, 2, 0, -2))\n\n        assert label_rect.width() > 0\n\n        label = index.data(model.Label)\n        label = metrics.elidedText(label,\n                                   QtCore.Qt.ElideRight,\n                                   label_rect.width() - 20)\n\n        font_color = colors[\"idle\"]\n        if not index.data(model.IsChecked):\n            font_color = colors[\"inactive\"]\n\n        # Maintain reference to state, so we can restore it once we're done\n        painter.save()\n\n        # Draw label\n        painter.setFont(fonts[\"h4\"])\n        painter.setPen(QtGui.QPen(font_color))\n        painter.drawText(label_rect, label)\n\n        # Draw action icon\n        if index.data(model.ActionIconVisible):\n            painter.save()\n\n            if index.data(model.ActionIdle):\n                color = colors[\"idle\"]\n            elif index.data(model.IsProcessing):\n                color = colors[\"active\"]\n            elif index.data(model.ActionFailed):\n                color = colors[\"warning\"]\n            else:\n                color = colors[\"ok\"]\n\n            painter.setFont(fonts[\"smallAwesome\"])\n            painter.setPen(QtGui.QPen(color))\n\n            icon_rect = QtCore.QRectF(option.rect.adjusted(\n                label_rect.width() + 1, label_rect.height() / 3, 0, 0))\n            painter.drawText(icon_rect, icons[\"action\"])\n\n            painter.restore()\n\n        # Draw checkbox\n        pen = QtGui.QPen(check_color, 1)\n        painter.setPen(pen)\n\n        if index.data(model.IsOptional):\n            painter.drawRect(check_rect)\n\n            if index.data(model.IsChecked):\n                painter.fillRect(check_rect, check_color)\n\n        elif not index.data(model.IsIdle) and index.data(model.IsChecked):\n                painter.fillRect(check_rect, check_color)\n\n        if option.state & QtWidgets.QStyle.State_MouseOver:\n            painter.fillRect(body_rect, colors[\"hover\"])\n\n        if option.state & QtWidgets.QStyle.State_Selected:\n            painter.fillRect(body_rect, colors[\"selected\"])\n\n        # Ok, we're done, tidy up.\n        painter.restore()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef paint(self, painter, option, index):\n\n        # Layout\n        spacing = 10\n        metrics = painter.fontMetrics()\n\n        body_rect = QtCore.QRectF(option.rect).adjusted(2, 2, -8, -2)\n        content_rect = body_rect.adjusted(5, 5, -5, -5)\n\n        toggle_rect = QtCore.QRectF(body_rect)\n        toggle_rect.setWidth(7)\n        toggle_rect.adjust(1, 1, 0, -1)\n\n        icon_rect = QtCore.QRectF(content_rect)\n        icon_rect.translate(toggle_rect.width() + spacing, 3)\n        icon_rect.setWidth(35)\n        icon_rect.setHeight(35)\n\n        duration_rect = QtCore.QRectF(content_rect)\n        duration_rect.translate(content_rect.width() - 50, 0)\n\n        label_rect = QtCore.QRectF(content_rect)\n        label_rect.translate(icon_rect.width() +\n                             spacing, 0)\n        label_rect.setHeight(metrics.lineSpacing() + spacing)\n\n        families_rect = QtCore.QRectF(label_rect)\n        families_rect.translate(0, label_rect.height())\n\n        # Colors\n        check_color = colors[\"idle\"]\n\n        if index.data(model.IsProcessing) is True:\n            check_color = colors[\"active\"]\n\n        elif index.data(model.HasFailed) is True:\n            check_color = colors[\"warning\"]\n\n        elif index.data(model.HasSucceeded) is True:\n            check_color = colors[\"ok\"]\n\n        elif index.data(model.HasProcessed) is True:\n            check_color = colors[\"ok\"]\n\n        icon = index.data(model.Icon) or icons[\"file\"]\n        label = index.data(model.Label)\n        families = \", \".join(index.data(model.Families))\n\n        # Elide\n        label = metrics.elidedText(label,\n                                   QtCore.Qt.ElideRight,\n                                   label_rect.width())\n\n        families = metrics.elidedText(families,\n                                      QtCore.Qt.ElideRight,\n                                      label_rect.width())\n\n        font_color = colors[\"idle\"]\n        if not index.data(model.IsChecked):\n            font_color = colors[\"inactive\"]\n\n        # Maintan reference to state, so we can restore it once we're done\n        painter.save()\n\n        # Draw background\n        painter.fillRect(body_rect, colors[\"hover\"])\n\n        painter.setFont(fonts[\"largeAwesome\"])\n        painter.setPen(QtGui.QPen(font_color))\n        painter.drawText(icon_rect, icon)\n\n        # Draw label\n        painter.setFont(fonts[\"h3\"])\n        painter.drawText(label_rect, label)\n\n        # Draw families\n        painter.setFont(fonts[\"h5\"])\n        painter.setPen(QtGui.QPen(colors[\"inactive\"]))\n        painter.drawText(families_rect, families)\n\n        # Draw checkbox\n        pen = QtGui.QPen(check_color, 1)\n        painter.setPen(pen)\n\n        if index.data(model.IsOptional):\n            painter.drawRect(toggle_rect)\n\n            if index.data(model.IsChecked):\n                painter.fillRect(toggle_rect, check_color)\n\n        elif not index.data(model.IsIdle) and index.data(model.IsChecked):\n                painter.fillRect(toggle_rect, check_color)\n\n        if option.state & QtWidgets.QStyle.State_MouseOver:\n            painter.fillRect(body_rect, colors[\"hover\"])\n\n        if option.state & QtWidgets.QStyle.State_Selected:\n            painter.fillRect(body_rect, colors[\"selected\"])\n\n        painter.setPen(colors[\"outline\"])\n        painter.drawRect(body_rect)\n\n        # Ok, we're done, tidy up.\n        painter.restore()", "response": "Paint checkbox and text\n        "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef paint(self, painter, option, index):\n\n        icon_rect = QtCore.QRectF(option.rect).adjusted(3, 3, -3, -3)\n        icon_rect.setWidth(14)\n        icon_rect.setHeight(14)\n\n        icon_color = colors[\"idle\"]\n        icon = icons[index.data(model.Type)]\n\n        if index.data(model.Type) == \"record\":\n            icon_color = record_colors[index.data(model.LogLevel)]\n\n        elif index.data(model.Type) == \"error\":\n            icon_color = colors[\"warning\"]\n\n        metrics = painter.fontMetrics()\n\n        label_rect = QtCore.QRectF(option.rect.adjusted(\n            icon_rect.width() + 12, 2, 0, -2))\n\n        assert label_rect.width() > 0\n\n        label = index.data(model.Label)\n        label = metrics.elidedText(label,\n                                   QtCore.Qt.ElideRight,\n                                   label_rect.width() - 20)\n\n        font_color = colors[\"idle\"]\n\n        hover = QtGui.QPainterPath()\n        hover.addRect(QtCore.QRectF(option.rect).adjusted(0, 0, -1, -1))\n\n        # Maintain reference to state, so we can restore it once we're done\n        painter.save()\n\n        # Draw label\n        painter.setFont(fonts[\"h4\"])\n        painter.setPen(QtGui.QPen(font_color))\n        painter.drawText(label_rect, label)\n\n        # Draw icon\n        painter.setFont(fonts[\"smallAwesome\"])\n        painter.setPen(QtGui.QPen(icon_color))\n        painter.drawText(icon_rect, QtCore.Qt.AlignCenter, icon)\n\n        if option.state & QtWidgets.QStyle.State_MouseOver:\n            painter.fillPath(hover, colors[\"hover\"])\n\n        if option.state & QtWidgets.QStyle.State_Selected:\n            painter.fillPath(hover, colors[\"selected\"])\n\n        # Ok, we're done, tidy up.\n        painter.restore()", "response": "Paint text for the current entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nappends item to the end of the model", "response": "def append(self, item):\n        \"\"\"Append item to end of model\"\"\"\n        self.beginInsertRows(QtCore.QModelIndex(),\n                             self.rowCount(),\n                             self.rowCount())\n\n        self.items.append(item)\n        self.endInsertRows()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfiltering items in self. includes and self. excludes.", "response": "def filterAcceptsRow(self, source_row, source_parent):\n        \"\"\"Exclude items in `self.excludes`\"\"\"\n        model = self.sourceModel()\n        item = model.items[source_row]\n        key = getattr(item, \"filter\", None)\n        if key is not None:\n            regex = self.filterRegExp()\n            if regex.pattern():\n                match = regex.indexIn(key)\n                return False if match == -1 else True\n\n        # --- Check if any family assigned to the plugin is in allowed families\n        for role, values in self.includes.items():\n            includes_list = [([x] if isinstance(x, (list, tuple)) else x)\n                             for x in getattr(item, role, None)]\n            return any(include in values for include in includes_list)\n\n        for role, values in self.excludes.items():\n            data = getattr(item, role, None)\n            if data in values:\n                return False\n\n        return super(ProxyModel, self).filterAcceptsRow(\n            source_row, source_parent)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef on_item_toggled(self, index, state=None):\n        if not index.data(model.IsIdle):\n            return self.info(\"Cannot toggle\")\n\n        if not index.data(model.IsOptional):\n            return self.info(\"This item is mandatory\")\n\n        if state is None:\n            state = not index.data(model.IsChecked)\n\n        index.model().setData(index, state, model.IsChecked)\n\n        # Withdraw option to publish if no instances are toggled\n        play = self.findChild(QtWidgets.QWidget, \"Play\")\n        validate = self.findChild(QtWidgets.QWidget, \"Validate\")\n        any_instances = any(index.data(model.IsChecked)\n                            for index in self.data[\"models\"][\"instances\"])\n        play.setEnabled(any_instances)\n        validate.setEnabled(any_instances)\n\n        # Emit signals\n        if index.data(model.Type) == \"instance\":\n            instance = self.data[\"models\"][\"instances\"].items[index.row()]\n            util.defer(\n                100, lambda: self.controller.emit_(\n                    signal=\"instanceToggled\",\n                    kwargs={\"new_value\": state,\n                            \"old_value\": not state,\n                            \"instance\": instance}))\n\n        if index.data(model.Type) == \"plugin\":\n            util.defer(\n                100, lambda: self.controller.emit_(\n                    signal=\"pluginToggled\",\n                    kwargs={\"new_value\": state,\n                            \"old_value\": not state,\n                            \"plugin\": index.data(model.Object)}))", "response": "Update the state of the item with the new state"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall when the user has typed a comment", "response": "def on_comment_entered(self):\n        \"\"\"The user has typed a comment\"\"\"\n        text_edit = self.findChild(QtWidgets.QWidget, \"CommentBox\")\n        comment = text_edit.text()\n\n        # Store within context\n        context = self.controller.context\n        context.data[\"comment\"] = comment\n\n        placeholder = self.findChild(QtWidgets.QLabel, \"CommentPlaceholder\")\n        placeholder.setVisible(not comment)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreflect currently running pair in GUI", "response": "def on_about_to_process(self, plugin, instance):\n        \"\"\"Reflect currently running pair in GUI\"\"\"\n\n        if instance is not None:\n            instance_model = self.data[\"models\"][\"instances\"]\n            index = instance_model.items.index(instance)\n            index = instance_model.createIndex(index, 0)\n            instance_model.setData(index, True, model.IsProcessing)\n\n        plugin_model = self.data[\"models\"][\"plugins\"]\n        index = plugin_model.items.index(plugin)\n        index = plugin_model.createIndex(index, 0)\n        plugin_model.setData(index, True, model.IsProcessing)\n        self.info(\"%s %s\" % (self.tr(\"Processing\"), index.data(model.Label)))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_plugin_action_menu_requested(self, pos):\n\n        index = self.data[\"views\"][\"right\"].indexAt(pos)\n        actions = index.data(model.Actions)\n\n        if not actions:\n            return\n\n        menu = QtWidgets.QMenu(self)\n        plugins_index = self.data[\"models\"][\"filter\"].mapToSource(index)\n        plugin = self.data[\"models\"][\"plugins\"].items[plugins_index.row()]\n        print(\"plugin is: %s\" % plugin)\n\n        for action in actions:\n            qaction = QtWidgets.QAction(action.label or action.__name__, self)\n            qaction.triggered.connect(partial(self.act, plugin, action))\n            menu.addAction(qaction)\n\n        menu.popup(self.data[\"views\"][\"right\"].viewport().mapToGlobal(pos))", "response": "The user right - clicked on a plug - in\n         button."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling when the user has finished processing the log.", "response": "def on_finished(self):\n        \"\"\"Finished signal handler\"\"\"\n        self.controller.is_running = False\n\n        error = self.controller.current_error\n        if error is not None:\n            self.info(self.tr(\"Stopped due to error(s), see Terminal.\"))\n        else:\n            self.info(self.tr(\"Finished successfully!\"))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nresets the current instance and all related objects.", "response": "def reset(self):\n        \"\"\"Prepare GUI for reset\"\"\"\n        self.info(self.tr(\"About to reset..\"))\n\n        models = self.data[\"models\"]\n\n        models[\"instances\"].store_checkstate()\n        models[\"plugins\"].store_checkstate()\n\n        # Reset current ids to secure no previous instances get mixed in.\n        models[\"instances\"].ids = []\n\n        for m in models.values():\n            m.reset()\n\n        for b in self.data[\"buttons\"].values():\n            b.hide()\n\n        comment_box = self.findChild(QtWidgets.QWidget, \"CommentBox\")\n        comment_box.hide()\n\n        util.defer(500, self.controller.reset)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef closeEvent(self, event):\n\n        # Make it snappy, but take care to clean it all up.\n        # TODO(marcus): Enable GUI to return on problem, such\n        # as asking whether or not the user really wants to quit\n        # given there are things currently running.\n        self.hide()\n\n        if self.data[\"state\"][\"is_closing\"]:\n\n            # Explicitly clear potentially referenced data\n            self.info(self.tr(\"Cleaning up models..\"))\n            for v in self.data[\"views\"].values():\n                v.model().deleteLater()\n                v.setModel(None)\n\n            self.info(self.tr(\"Cleaning up terminal..\"))\n            for item in self.data[\"models\"][\"terminal\"].items:\n                del(item)\n\n            self.info(self.tr(\"Cleaning up controller..\"))\n            self.controller.cleanup()\n\n            self.info(self.tr(\"All clean!\"))\n            self.info(self.tr(\"Good bye\"))\n            return super(Window, self).closeEvent(event)\n\n        self.info(self.tr(\"Closing..\"))\n\n        def on_problem():\n            self.heads_up(\"Warning\", \"Had trouble closing down. \"\n                          \"Please tell someone and try again.\")\n            self.show()\n\n        if self.controller.is_running:\n            self.info(self.tr(\"..as soon as processing is finished..\"))\n            self.controller.is_running = False\n            self.finished.connect(self.close)\n            util.defer(2000, on_problem)\n            return event.ignore()\n\n        self.data[\"state\"][\"is_closing\"] = True\n\n        util.defer(200, self.close)\n        return event.ignore()", "response": "Closes the current object and cleans up all related data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprint user - facing information for the current user - related class", "response": "def info(self, message):\n        \"\"\"Print user-facing information\n\n        Arguments:\n            message (str): Text message for the user\n\n        \"\"\"\n\n        info = self.findChild(QtWidgets.QLabel, \"Info\")\n        info.setText(message)\n\n        # Include message in terminal\n        self.data[\"models\"][\"terminal\"].append({\n            \"label\": message,\n            \"type\": \"info\"\n        })\n\n        animation = self.data[\"animation\"][\"display_info\"]\n        animation.stop()\n        animation.start()\n\n        # TODO(marcus): Should this be configurable? Do we want\n        # the shell to fill up with these messages?\n        util.u_print(message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reset(self):\n        self.context = pyblish.api.Context()\n        self.plugins = pyblish.api.discover()\n\n        self.was_discovered.emit()\n\n        self.pair_generator = None\n        self.current_pair = (None, None)\n        self.current_error = None\n\n        self.processing = {\n            \"nextOrder\": None,\n            \"ordersWithError\": set()\n        }\n\n        self._load()\n        self._run(until=pyblish.api.CollectorOrder,\n                  on_finished=self.was_reset.emit)", "response": "Discover plug - ins and run collection"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _load(self):\n        self.is_running = True\n        self.pair_generator = self._iterator(self.plugins,\n                                             self.context)\n        self.current_pair = next(self.pair_generator, (None, None))\n        self.current_error = None\n        self.is_running = False", "response": "Initiate new generator and load first pair"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprocesses the instance and plugin and return the result.", "response": "def _process(self, plugin, instance=None):\n        \"\"\"Produce `result` from `plugin` and `instance`\n\n        :func:`process` shares state with :func:`_iterator` such that\n        an instance/plugin pair can be fetched and processed in isolation.\n\n        Arguments:\n            plugin (pyblish.api.Plugin): Produce result using plug-in\n            instance (optional, pyblish.api.Instance): Process this instance,\n                if no instance is provided, context is processed.\n\n        \"\"\"\n\n        self.processing[\"nextOrder\"] = plugin.order\n\n        try:\n            result = pyblish.plugin.process(plugin, self.context, instance)\n\n        except Exception as e:\n            raise Exception(\"Unknown error: %s\" % e)\n\n        else:\n            # Make note of the order at which the\n            # potential error error occured.\n            has_error = result[\"error\"] is not None\n            if has_error:\n                self.processing[\"ordersWithError\"].add(plugin.order)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprocess the current pair and store next pair for next process", "response": "def _run(self, until=float(\"inf\"), on_finished=lambda: None):\n        \"\"\"Process current pair and store next pair for next process\n\n        Arguments:\n            until (pyblish.api.Order, optional): Keep fetching next()\n                until this order, default value is infinity.\n            on_finished (callable, optional): What to do when finishing,\n                defaults to doing nothing.\n\n        \"\"\"\n\n        def on_next():\n            if self.current_pair == (None, None):\n                return util.defer(100, on_finished_)\n\n            # The magic number 0.5 is the range between\n            # the various CVEI processing stages;\n            # e.g.\n            #  - Collection is 0 +- 0.5 (-0.5 - 0.5)\n            #  - Validation is 1 +- 0.5 (0.5  - 1.5)\n            #\n            # TODO(marcus): Make this less magical\n            #\n            order = self.current_pair[0].order\n            if order > (until + 0.5):\n                return util.defer(100, on_finished_)\n\n            self.about_to_process.emit(*self.current_pair)\n\n            util.defer(10, on_process)\n\n        def on_process():\n            try:\n                result = self._process(*self.current_pair)\n\n                if result[\"error\"] is not None:\n                    self.current_error = result[\"error\"]\n\n                self.was_processed.emit(result)\n\n            except Exception as e:\n                stack = traceback.format_exc(e)\n                return util.defer(\n                    500, lambda: on_unexpected_error(error=stack))\n\n            # Now that processing has completed, and context potentially\n            # modified with new instances, produce the next pair.\n            #\n            # IMPORTANT: This *must* be done *after* processing of\n            # the current pair, otherwise data generated at that point\n            # will *not* be included.\n            try:\n                self.current_pair = next(self.pair_generator)\n\n            except StopIteration:\n                # All pairs were processed successfully!\n                self.current_pair = (None, None)\n                return util.defer(500, on_finished_)\n\n            except Exception as e:\n                # This is a bug\n                stack = traceback.format_exc(e)\n                self.current_pair = (None, None)\n                return util.defer(\n                    500, lambda: on_unexpected_error(error=stack))\n\n            util.defer(10, on_next)\n\n        def on_unexpected_error(error):\n            util.u_print(u\"An unexpected error occurred:\\n %s\" % error)\n            return util.defer(500, on_finished_)\n\n        def on_finished_():\n            on_finished()\n            self.was_finished.emit()\n\n        self.is_running = True\n        util.defer(10, on_next)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nyield next plug - in and instance to process.", "response": "def _iterator(self, plugins, context):\n        \"\"\"Yield next plug-in and instance to process.\n\n        Arguments:\n            plugins (list): Plug-ins to process\n            context (pyblish.api.Context): Context to process\n\n        \"\"\"\n\n        test = pyblish.logic.registered_test()\n\n        for plug, instance in pyblish.logic.Iterator(plugins, context):\n            if not plug.active:\n                continue\n\n            if instance is not None and instance.data.get(\"publish\") is False:\n                continue\n\n            self.processing[\"nextOrder\"] = plug.order\n\n            if not self.is_running:\n                raise StopIteration(\"Stopped\")\n\n            if test(**self.processing):\n                raise StopIteration(\"Stopped due to %s\" % test(\n                    **self.processing))\n\n            yield plug, instance"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning root URI - strip query and fragment.", "response": "def get_root_uri(uri):\n    \"\"\"Return root URI - strip query and fragment.\"\"\"\n    chunks = urlsplit(uri)\n    return urlunsplit((chunks.scheme, chunks.netloc, chunks.path, '', ''))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef collect(since, to, top=DEFAULT_TOP):\n    summary = CspReportSummary(since, to, top=top)\n    queryset = CSPReport.objects.filter(created__range=(since, to))\n    valid_queryset = queryset.filter(is_valid=True)\n    invalid_queryset = queryset.filter(is_valid=False)\n\n    summary.total_count = queryset.count()\n    summary.valid_count = valid_queryset.count()\n\n    # Collect sources\n    sources = {}\n    for report in valid_queryset:\n        root_uri = get_root_uri(report.document_uri)\n        info = sources.setdefault(root_uri, ViolationInfo(root_uri))\n        info.append(report)\n    summary.sources = sorted(sources.values(), key=attrgetter('count'), reverse=True)[:top]\n\n    # Collect blocks\n    blocks = {}\n    for report in valid_queryset:\n        root_uri = get_root_uri(report.blocked_uri)\n        info = blocks.setdefault(root_uri, ViolationInfo(root_uri))\n        info.append(report)\n    summary.blocks = sorted(blocks.values(), key=attrgetter('count'), reverse=True)[:top]\n\n    # Collect invalid reports\n    summary.invalid_count = invalid_queryset.count()\n    summary.invalid_reports = tuple(invalid_queryset[:top])\n\n    return summary", "response": "Collect the CSP report."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nappend a new CSP report.", "response": "def append(self, report):\n        \"\"\"Append a new CSP report.\"\"\"\n        assert report not in self.examples\n        self.count += 1\n        if len(self.examples) < self.top:\n            self.examples.append(report)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a date input.", "response": "def _parse_date_input(date_input, default_offset=0):\n    \"\"\"Parses a date input.\"\"\"\n    if date_input:\n        try:\n            return parse_date_input(date_input)\n        except ValueError as err:\n            raise CommandError(force_text(err))\n    else:\n        return get_midnight() - timedelta(days=default_offset)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a nicely formatted original report.", "response": "def nice_report(self):\n        \"\"\"Return a nicely formatted original report.\"\"\"\n        if not self.json:\n            return '[no CSP report data]'\n        try:\n            data = json.loads(self.json)\n        except ValueError:\n            return \"Invalid CSP report: '{}'\".format(self.json)\n        if 'csp-report' not in data:\n            return 'Invalid CSP report: ' + json.dumps(data, indent=4, sort_keys=True, separators=(',', ': '))\n        return json.dumps(data['csp-report'], indent=4, sort_keys=True, separators=(',', ': '))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_message(cls, message):\n        self = cls(json=message)\n        try:\n            decoded_data = json.loads(message)\n        except ValueError:\n            # Message is not a valid JSON. Return as invalid.\n            return self\n        try:\n            report_data = decoded_data['csp-report']\n        except KeyError:\n            # Message is not a valid CSP report. Return as invalid.\n            return self\n\n        # Extract individual fields\n        for report_name, field_name in REQUIRED_FIELD_MAP + OPTIONAL_FIELD_MAP:\n            setattr(self, field_name, report_data.get(report_name))\n        # Extract integer fields\n        for report_name, field_name in INTEGER_FIELD_MAP:\n            value = report_data.get(report_name)\n            field = self._meta.get_field(field_name)\n            min_value, max_value = connection.ops.integer_field_range(field.get_internal_type())\n            if min_value is None:\n                min_value = 0\n            # All these fields are possitive. Value can't be negative.\n            min_value = max(min_value, 0)\n            if value is not None and min_value <= value and (max_value is None or value <= max_value):\n                setattr(self, field_name, value)\n        # Extract disposition\n        disposition = report_data.get('disposition')\n        if disposition in dict(DISPOSITIONS).keys():\n            self.disposition = disposition\n\n        # Check if report is valid\n        is_valid = True\n        for field_name in dict(REQUIRED_FIELD_MAP).values():\n            if getattr(self, field_name) is None:\n                is_valid = False\n                break\n        self.is_valid = is_valid\n\n        return self", "response": "Creates an instance of the class from a CSP report message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef data(self):\n        try:\n            data = self._data\n        except AttributeError:\n            data = self._data = json.loads(self.json)\n        return data", "response": "Returns the data as a python object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef json_as_html(self):\n\n        # To avoid circular import\n        from cspreports import utils\n\n        formatted_json = utils.format_report(self.json)\n        return mark_safe(\"<pre>\\n%s</pre>\" % escape(formatted_json))", "response": "Print out self. json in a nice way."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef process_report(request):\n    if config.EMAIL_ADMINS:\n        email_admins(request)\n    if config.LOG:\n        log_report(request)\n    if config.SAVE:\n        save_report(request)\n    if config.ADDITIONAL_HANDLERS:\n        run_additional_handlers(request)", "response": "Process a CSP violation report."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef format_report(jsn):\n    if isinstance(jsn, bytes):\n        jsn = jsn.decode('utf-8')\n    try:\n        return json.dumps(json.loads(jsn), indent=4, sort_keys=True, separators=(',', ': '))\n    except ValueError:\n        return \"Invalid JSON. Raw dump is below.\\n\\n\" + jsn", "response": "Given a JSON report return a nicely formatted string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_additional_handlers():\n    global _additional_handlers\n    if not isinstance(_additional_handlers, list):\n        handlers = []\n        for name in config.ADDITIONAL_HANDLERS:\n            module_name, function_name = name.rsplit('.', 1)\n            function = getattr(import_module(module_name), function_name)\n            handlers.append(function)\n        _additional_handlers = handlers\n    return _additional_handlers", "response": "Returns the actual functions from the dotted paths specified in ADDITIONAL_HANDLERS."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_date_input(value):\n    try:\n        limit = parse_date(value)\n    except ValueError:\n        limit = None\n    if limit is None:\n        raise ValueError(\"'{}' is not a valid date.\".format(value))\n    limit = datetime(limit.year, limit.month, limit.day)\n    if settings.USE_TZ:\n        limit = make_aware(limit)\n    return limit", "response": "Return datetime based on the user s input."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning last midnight in localtime as datetime.", "response": "def get_midnight():\n    \"\"\"Return last midnight in localtime as datetime.\n\n    @return: Midnight datetime\n    \"\"\"\n    limit = now()\n    if settings.USE_TZ:\n        limit = localtime(limit)\n    return limit.replace(hour=0, minute=0, second=0, microsecond=0)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning python function and add job to self", "response": "def python_job(self, function, parameters=None):\n        \"\"\"\n        Run python function\n\n        function    :   Python callable to execute\n        name        :   Name of function (if not given, will used function.__name__)\n        parameters  :   Parameters to parse to function\n        label       :   Function label; for logging purposes\n        \"\"\"\n        \n        if not callable(function):\n            raise utils.StimelaCabRuntimeError('Object given as function is not callable')\n        \n        if self.name is None:\n            self.name = function.__name__\n\n        self.job = {\n                        'function'  :   function,\n                        'parameters':   parameters,\n                   }\n\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning a single job in a single cab", "response": "def singularity_job(self, image, config, singularity_image_dir,\n            input=None, output=None, msdir=None,\n            **kw):\n        \n        \"\"\"\n            Run task in singularity\n            \n        image   :   stimela cab name, e.g. 'cab/simms'\n        name    :   This name will be part of the name of the contaier that will \n                    execute the task (now optional)\n        config  :   Dictionary of options to parse to the task. This will modify \n                    the parameters in the default parameter file which \n                    can be viewd by running 'stimela cabs -i <cab name>', e.g 'stimela cabs -i simms'\n        input   :   input dirctory for cab\n        output  :   output directory for cab\n        msdir   :   MS directory for cab. Only specify if different from recipe ms_dir\n\n\n        \"\"\"\n\n        # check if name has any offending charecters\n        offenders = re.findall('\\W', self.name)\n        if offenders:\n            raise StimelaCabParameterError('The cab name \\'{:s}\\' has some non-alphanumeric characters.'\n                                           ' Charecters making up this name must be in [a-z,A-Z,0-9,_]'.format(self.name))\n\n        ## Update I/O with values specified on command line\n        # TODO (sphe) I think this feature should be removed\n        script_context = self.recipe.stimela_context\n        input = script_context.get('_STIMELA_INPUT', None) or input\n        output = script_context.get('_STIMELA_OUTPUT', None) or output\n        msdir = script_context.get('_STIMELA_MSDIR', None) or msdir\n\n        # Get location of template parameters file\n        cabpath = self.recipe.stimela_path + \"/cargo/cab/{0:s}/\".format(image.split(\"/\")[1])\n        parameter_file = cabpath+'/parameters.json'\n\n        name = '{0}-{1}{2}'.format(self.name, id(image), str(time.time()).replace('.', ''))\n        _name = '{0}-{1}{2}'.format(self.name, id(image), str(time.time()).replace('.', ''))\n        name = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(3))\n\n        _cab = cab.CabDefinition(indir=input, outdir=output,\n                    msdir=msdir, parameter_file=parameter_file)\n\n        cab.IODEST = {\n            \"input\"     : \"/scratch/input\",\n            \"output\"    : \"/scratch/output\",\n            \"msfile\"    : \"/scratch/msdir\",\n        }\n        \n        cont = singularity.Container(image, name, \n                    logger=self.log, time_out=self.time_out)\n\n        # Container parameter file will be updated and validated before the container is executed\n        cont._cab = _cab\n        cont.parameter_file_name = '{0}/{1}.json'.format(self.recipe.parameter_file_dir, name)\n\n        # Remove dismissable kw arguments:\n        ops_to_pop = []\n        for op in config:\n            if isinstance(config[op], dismissable):\n                ops_to_pop.append(op)\n        for op in ops_to_pop:\n            arg = config.pop(op)()\n            if arg is not None:\n                config[op] = arg\n        cont.config = config\n\n        # These are standard volumes and\n        # environmental variables. These will be\n        # always exist in a cab container\n        cont.add_volume(self.recipe.stimela_path, '/scratch/stimela', perm='ro')\n        cont.add_volume(cont.parameter_file_name, '/scratch/configfile', perm='ro', noverify=True)\n        cont.add_volume(\"{0:s}/cargo/cab/{1:s}/src/\".format( \n                self.recipe.stimela_path, _cab.task), \"/scratch/code\", \"ro\")\n        cont.add_volume(\"{0:s}/cargo/cab/singularity_run\".format(self.recipe.stimela_path, \n                _cab.task), \"/singularity\")\n\n        if msdir:\n            md = '/scratch/msdir'\n            cont.add_volume(msdir, md)\n            # Keep a record of the content of the\n            # volume\n            dirname, dirs, files = [a for a in next(os.walk(msdir))]\n            cont.msdir_content = {\n                \"volume\"    :   dirname,\n                \"dirs\"      :   dirs,\n                \"files\"     :   files,\n            }\n\n            self.log.debug('Mounting volume \\'{0}\\' from local file system to \\'{1}\\' in the container'.format(msdir, md))\n\n        if input:\n            cont.add_volume( input,'/scratch/input', perm='ro')\n            # Keep a record of the content of the\n            # volume\n            dirname, dirs, files = [a for a in next(os.walk(input))]\n            cont.input_content = {\n                \"volume\"    :   dirname,\n                \"dirs\"      :   dirs,\n                \"files\"     :   files,\n            }\n\n            self.log.debug('Mounting volume \\'{0}\\' from local file system to \\'{1}\\' in the container'.format(input, '/scratch/input'))\n\n        if not os.path.exists(output):\n            os.mkdir(output)\n\n        od = '/scratch/output'\n        self.logfile = cont.logfile = '{0}/log-{1}.txt'.format(self.log_dir, _name.split('-')[0])\n        if not os.path.exists(self.logfile):\n            with open(self.logfile, 'w') as std:\n                pass\n        cont.add_volume(self.log_dir, \"/scratch/logs/logfile\")\n        cont.add_volume(output, od)\n        self.log.debug('Mounting volume \\'{0}\\' from local file system to \\'{1}\\' in the container'.format(output, od))\n        \n        simage = _cab.base.replace(\"/\", \"_\")\n        cont.image = '{0:s}/{1:s}_{2:s}.img'.format(singularity_image_dir, simage, _cab.tag)\n        # Added and ready for execution\n        self.job = cont\n\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a new task to a stimela recipe and return the Docker job object.", "response": "def docker_job(self, image, config=None,\n            input=None, output=None, msdir=None,\n            shared_memory='1gb', build_label=None,\n            **kw):\n        \"\"\"\n        Add a task to a stimela recipe\n\n        image   :   stimela cab name, e.g. 'cab/simms'\n        name    :   This name will be part of the name of the contaier that will \n                    execute the task (now optional)\n        config  :   Dictionary of options to parse to the task. This will modify \n                    the parameters in the default parameter file which \n                    can be viewd by running 'stimela cabs -i <cab name>', e.g 'stimela cabs -i simms'\n        input   :   input dirctory for cab\n        output  :   output directory for cab\n        msdir   :   MS directory for cab. Only specify if different from recipe ms_dir\n        \"\"\"\n\n        # check if name has any offending charecters\n        offenders = re.findall('\\W', self.name)\n        if offenders:\n            raise StimelaCabParameterError('The cab name \\'{:s}\\' has some non-alphanumeric characters.'\n                                           ' Charecters making up this name must be in [a-z,A-Z,0-9,_]'.format(self.name))\n\n        ## Update I/O with values specified on command line\n        # TODO (sphe) I think this feature should be removed\n        script_context = self.recipe.stimela_context\n        input = script_context.get('_STIMELA_INPUT', None) or input\n        output = script_context.get('_STIMELA_OUTPUT', None) or output\n        msdir = script_context.get('_STIMELA_MSDIR', None) or msdir\n        build_label = script_context.get('_STIMELA_BUILD_LABEL', None) or build_label\n\n        # Get location of template parameters file\n        cabs_logger = stimela.get_cabs('{0:s}/{1:s}_stimela_logfile.json'.format(stimela.LOG_HOME, build_label))\n        try:\n            cabpath = cabs_logger['{0:s}_{1:s}'.format(build_label, image)]['DIR']\n        except KeyError:\n            raise StimelaCabParameterError('Cab {} has is uknown to stimela. Was it built?'.format(image))\n        parameter_file = cabpath+'/parameters.json'\n\n        name = '{0}-{1}{2}'.format(self.name, id(image), str(time.time()).replace('.', ''))\n\n        _cab = cab.CabDefinition(indir=input, outdir=output,\n                    msdir=msdir, parameter_file=parameter_file)\n        \n        cont = docker.Container(image, name,\n                     label=self.label, logger=self.log,\n                     shared_memory=shared_memory, \n                     log_container=stimela.LOG_FILE,\n                     time_out=self.time_out)\n\n        # Container parameter file will be updated and validated before the container is executed\n        cont._cab = _cab\n        cont.parameter_file_name = '{0}/{1}.json'.format(self.recipe.parameter_file_dir, name)\n\n        # Remove dismissable kw arguments:\n        ops_to_pop = []\n        for op in config:\n            if isinstance(config[op], dismissable):\n                ops_to_pop.append(op)\n        for op in ops_to_pop:\n            arg = config.pop(op)()\n            if arg is not None:\n                config[op] = arg\n        cont.config = config\n\n        # These are standard volumes and\n        # environmental variables. These will be\n        # always exist in a cab container\n        cont.add_volume(self.recipe.stimela_path, '/scratch/stimela', perm='ro')\n        cont.add_volume(self.recipe.parameter_file_dir, '/configs', perm='ro')\n        cont.add_environ('CONFIG', '/configs/{}.json'.format(name))\n\n        if msdir:\n            md = '/home/{0:s}/msdir'.format(USER)\n            cont.add_volume(msdir, md)\n            cont.add_environ('MSDIR', md)\n            # Keep a record of the content of the\n            # volume\n            dirname, dirs, files = [a for a in next(os.walk(msdir))]\n            cont.msdir_content = {\n                \"volume\"    :   dirname,\n                \"dirs\"      :   dirs,\n                \"files\"     :   files,\n            }\n\n            self.log.debug('Mounting volume \\'{0}\\' from local file system to \\'{1}\\' in the container'.format(msdir, md))\n\n        if input:\n            cont.add_volume( input,'/input', perm='ro')\n            cont.add_environ('INPUT', '/input')\n            # Keep a record of the content of the\n            # volume\n            dirname, dirs, files = [a for a in next(os.walk(input))]\n            cont.input_content = {\n                \"volume\"    :   dirname,\n                \"dirs\"      :   dirs,\n                \"files\"     :   files,\n            }\n\n            self.log.debug('Mounting volume \\'{0}\\' from local file system to \\'{1}\\' in the container'.format(input, '/input'))\n\n        if not os.path.exists(output):\n            os.mkdir(output)\n\n        od = '/home/{0:s}/output'.format(USER)\n        cont.add_environ('HOME', od)\n        self.logfile = cont.logfile = '{0:s}/log-{1:s}.txt'.format(self.log_dir, name.split('-')[0])\n        cont.add_volume(output, od)\n        if not os.path.exists(cont.logfile):\n            with open(cont.logfile, \"w\") as std:\n                pass\n\n        logfile_cont = '/home/{0:s}/{1:s}/log-{2:s}.txt'.format(USER, self.log_dir, name.split('-')[0])\n        cont.add_volume(cont.logfile, logfile_cont, \"rw\")\n        cont.add_environ('OUTPUT', od)\n        cont.add_environ('LOGFILE',  logfile_cont)\n        self.log.debug('Mounting volume \\'{0}\\' from local file system to \\'{1}\\' in the container'.format(output, od))\n\n        cont.image = '{0}_{1}'.format(build_label, image)\n        # Added and ready for execution\n        self.job = cont\n\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning a Stimela recipe. steps : recipe steps to run resume : resume recipe from last run redo : Re-run an old recipe from a .last file", "response": "def run(self, steps=None, resume=False, redo=None):\n        \"\"\"\n        Run a Stimela recipe. \n\n        steps   :   recipe steps to run\n        resume  :   resume recipe from last run\n        redo    :   Re-run an old recipe from a .last file\n        \"\"\"\n\n        recipe = {\n            \"name\"      :   self.name,\n            \"steps\"     :   []\n        }\n        start_at = 0\n\n        if redo:\n            recipe = utils.readJson(redo)\n            self.log.info('Rerunning recipe {0} from {1}'.format(recipe['name'], redo))\n            self.log.info('Recreating recipe instance..')\n            self.jobs = []\n            for step in recipe['steps']:\n                \n            #        add I/O folders to the json file\n            #        add a string describing the contents of these folders\n            #        The user has to ensure that these folders exist, and have the required content\n                if step['jtype'] == 'docker':\n                    self.log.info('Adding job \\'{0}\\' to recipe. The container will be named \\'{1}\\''.format(step['cab'], step['name']))\n                    cont = docker.Container(step['cab'], step['name'],\n                                          label=step['label'], logger=self.log,\n                                          shared_memory=step['shared_memory'])\n\n                    self.log.debug('Adding volumes {0} and environmental variables {1}'.format(step['volumes'], step['environs']))\n                    cont.volumes = step['volumes']\n                    cont.environs = step['environs']\n                    cont.shared_memory = step['shared_memory']\n                    cont.input_content = step['input_content']\n                    cont.msdir_content = step['msdir_content']\n                    cont.logfile = step['logfile']\n                    job = StimelaJob(step['name'], recipe=self, label=step['label'])\n                    job.job = cont\n                    job.jtype = 'docker'\n\n\n                elif step['jtype'] == 'function':\n                    name = step['name']\n                    func = inspect.currentframe().f_back.f_locals[step['function']]\n                    job = StimelaJob(name, recipe=self, label=step['label'])\n                    job.python_job(func, step['parameters'])\n                    job.jtype = 'function'\n\n                self.jobs.append(job)\n\n        elif resume:\n            self.log.info(\"Resuming recipe from last run.\")\n            try:\n                recipe = utils.readJson(self.resume_file)\n            except IOError:\n                raise StimelaRecipeExecutionError(\"Cannot resume pipeline, resume file '{}' not found\".format(self.resume_file))\n\n            steps_ = recipe.pop('steps')\n            recipe['steps'] = []\n            _steps = []\n            for step in steps_:\n                if step['status'] == 'completed':\n                    recipe['steps'].append(step)\n                    continue\n\n                label = step['label']\n                number = step['number']\n                \n                # Check if the recipe flow has changed\n                if label == self.jobs[number-1].label:\n                    self.log.info('recipe step \\'{0}\\' is fit for re-execution. Label = {1}'.format(number, label))\n                    _steps.append(number)\n                else:\n                    raise StimelaRecipeExecutionError('Recipe flow, or task scheduling has changed. Cannot resume recipe. Label = {0}'.format(label))\n\n            # Check whether there are steps to resume        \n            if len(_steps)==0:\n                self.log.info('All the steps were completed. No steps to resume')\n                sys.exit(0)\n            steps = _steps\n\n        if getattr(steps, '__iter__', False):\n            _steps = []\n            if isinstance(steps[0], str):\n                labels = [ job.label.split('::')[0] for job in self.jobs]\n\n                for step in steps:\n                    try:\n                        _steps.append(labels.index(step)+1)\n                    except ValueError:\n                        raise StimelaCabParameterError('Recipe label ID [{0}] doesn\\'t exist'.format(step))\n                steps = _steps\n        else:\n            steps = range(1, len(self.jobs)+1)\n\n        jobs = [(step, self.jobs[step-1]) for step in steps]\n        \n        for i, (step, job) in enumerate(jobs):\n\n            self.log.info('Running job {}'.format(job.name))\n            self.log.info('STEP {0} :: {1}'.format(i+1, job.label))\n            self.active = job\n            try:\n                if job.jtype == 'function':\n                    job.run_python_job()\n                elif job.jtype in ['docker', 'singularity']:\n                    with open(job.job.logfile, 'a') as astd:\n                        astd.write('\\n-----------------------------------\\n')\n                        astd.write('Stimela version     : {}\\n'.format(version.version))\n                        astd.write('Cab name            : {}\\n'.format(job.job.image))\n                        astd.write('-------------------------------------\\n')\n\n                    run_job = getattr(job, \"run_{0:s}_job\".format(job.jtype))\n                    run_job()\n                    \n\n                self.log2recipe(job, recipe, step, 'completed')\n\n            except (utils.StimelaCabRuntimeError,\n                   StimelaRecipeExecutionError,\n                   StimelaCabParameterError) as e:\n                self.completed = [jb[1] for jb in jobs[:i]]\n                self.remaining = [jb[1] for jb in jobs[i+1:]]\n                self.failed = job\n\n                self.log.info('Recipe execution failed while running job {}'.format(job.name))\n                self.log.info('Completed jobs : {}'.format([c.name for c in self.completed]))\n                self.log.info('Remaining jobs : {}'.format([c.name for c in self.remaining]))\n\n                self.log2recipe(job, recipe, step, 'failed')\n                for step, jb in jobs[i+1:]:\n                    self.log.info('Logging remaining task: {}'.format(jb.label))\n                    self.log2recipe(jb, recipe, step, 'remaining')\n\n                self.log.info('Saving pipeline information in {}'.format(self.resume_file))\n                utils.writeJson(self.resume_file, recipe)\n\n                pe = PipelineException(e, self.completed, job, self.remaining)\n                raise_(pe, None, sys.exc_info()[2])\n            except:\n                import traceback\n                traceback.print_exc()\n                raise RuntimeError(\"An unhandled exception has occured. This is a bug, please report\")\n\n            finally:\n                if job.jtype == 'docker' and job.created:\n                    job.job.stop()\n                    job.job.remove()\n                if job.jtype == 'singularity' and job.created:\n                    job.job.stop()\n\n        self.log.info('Saving pipeline information in {}'.format(self.resume_file))\n        utils.writeJson(self.resume_file, recipe)\n\n        self.log.info('Recipe executed successfully')\n        \n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstart a singularity container instance", "response": "def start(self, *args):\n        \"\"\"\n        Create a singularity container instance\n        \"\"\"\n\n        if self.volumes: \n            volumes = \" --bind \" + \" --bind \".join(self.volumes)\n        else:\n            volumes = \"\"\n        \n        self._print(\"Instantiating container [{0:s}]. Timeout set to {1:d}. The container ID is printed below.\".format(self.name, self.time_out))\n        utils.xrun(\"singularity instance.start\", \n                        list(args) + [volumes,\n#                        \"-c\",\n                        self.image, self.name])\n\n        self.status = \"created\"\n\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun a singularity container instance", "response": "def run(self, *args):\n        \"\"\"\n        Run a singularity container instance\n        \"\"\"\n\n        if self.volumes: \n            volumes = \" --bind \" + \" --bind \".join(self.volumes)\n        else:\n            volumes = \"\"\n        \n        self._print(\"Starting container [{0:s}]. Timeout set to {1:d}. The container ID is printed below.\".format(self.name, self.time_out))\n        utils.xrun(\"singularity run\", [\"instance://{0:s} {1:s}\".format(self.name, self.RUNSCRIPT)],\n                   timeout= self.time_out, kill_callback=self.stop)\n\n        self.status = \"running\"\n\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstop a singularity container instance", "response": "def stop(self, *args):\n        \"\"\"\n        Stop a singularity container instance\n        \"\"\"\n\n        if self.volumes: \n            volumes = \" --bind \" + \" --bind \".join(self.volumes)\n        else:\n            volumes = \"\"\n        \n        self._print(\"Stopping container [{}]. The container ID is printed below.\".format(self.name))\n        utils.xrun(\"singularity\", [\"instance.stop {0:s}\".format(self.name)])\n\n        self.status = \"exited\"\n\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting image into predicted visibilities", "response": "def predict_vis (msname, image, column=\"MODEL_DATA\", \n        chanchunk=None, chanstart=0, chanstep=1):\n  \"\"\"Converts image into predicted visibilities\"\"\"\n\n  # CASA to convert them\n  casaimage = '{0}/{1}.img'.format(OUTPUT, os.path.basename(image))\n  \n  # convert to CASA image\n  img = pyrap.images.image(image)\n  img.saveas(casaimage)\n\n  imgshp = img.shape()\n  ftab = table(msname+'/SPECTRAL_WINDOW')\n  numchans = ftab.getcol('NUM_CHAN')[0]\n  # default chunk list is entire chanel range. Update this if needed\n  chunklist = [ (0, numchans, None, None) ]\n  if len(imgshp) == 4 and imgshp[0] > 1:\n      nimgchan = imgshp[0]\n\n      print(\"image cube has {0} channels, MS has {1} channels\".format(nimgchan, numchans))\n\n      imgchansize = imgshp[1]*imgshp[2]*imgshp[3]*4  # size of an image channel in bytes\n      if chanchunk is None:\n          mem_bytes = os.sysconf('SC_PAGE_SIZE') * os.sysconf('SC_PHYS_PAGES')  # e.g. 4015976448\n          chanchunk = max((mem_bytes/20)/imgchansize, 1)\n          print(\"based on available memory ({0}), max image chunk is {1} channels\".format(mem_bytes, chanchunk))\n      if chanchunk < nimgchan:\n          mschanstep = numchans*chanstep/nimgchan\n          if numchans%nimgchan:\n              warn(\"MS channels not evenly divisible into $nimgchan image channels, chunking may be incorrect\")\n          chunklist = []\n          for chan0 in range(0, nimgchan, chanchunk):\n              imch0, imch1 = chan0, (min(chan0+chanchunk, nimgchan)-1)\n              msch0 = chanstart + imch0*mschanstep\n              msnch = (imch1-imch0+1)*mschanstep/chanstep\n              # overlap each chunk from 1 onwards by a half-chunk back to take care of extrapolated visibilties\n              # from previous channel\n              if imch0:\n                  imch0 -= 1\n                  msch0 -= mschanstep/2\n                  msnch += mschanstep/2\n              print(\"image chunk {0}~{1} corresponds to MS chunk {2}~{3}\".format(imch0, imch1, msch0, msch0+msnch-1))\n              chunklist.append((msch0, msnch, imch0, imch1))\n              \n  # even in fill-model mode where it claims to ignore image parameters, the image channelization\n  # arguments need to be \"just so\" as per below, otherwise it gives a GridFT: weights all zero message\n  kw0 = {}\n  kw0.update(ms=msname, model=casaimage, \n      niter=0, fixed=1, mode=\"channel\", operation=\"csclean\",\n      img_nchan=1, img_chanstart=chanstart, img_chanstep=numchans*chanstep)\n  kw0['fillmodel'] = 1\n                   \n  blc = [0]*len(imgshp)\n  trc = [ x-1 for x in imgshp ]\n\n  # now loop over image frequency chunks\n  for ichunk, (mschanstart, msnumchans, imgch0, imgch1) in enumerate(chunklist):\n      if len(chunklist) > 1:\n          blc[0], trc[0] = imgch0, imgch1\n          print(\"writing CASA image for slice {0} {1}\".format(blc, trc))\n          casaimage1 = II(\"{0}.{1}.img\".format(image, ichunk1))\n          rm_fr(casaimage1)\n          print(\"writing CASA image for slice {0} {1} to {2}\".format(blc, trc, casaimage1))\n          img.subimage(blc, trc, dropdegenerate=False).saveas(casaimage1)\n          kw0.update(model=casaimage1)\n      else:\n          img.unlock()\n      # setup imager options\n      kw0.update(chanstart=mschanstart, chanstep=chanstep, nchan=msnumchans)\n      print(\"predicting visibilities into MODEL_DATA\")\n\n      _run(predict=True, **kw0)\n      if len(chunklist) > 1:\n        rm_fr(casaimage1)   \n  rm_fr(casaimage)\n  \n  if column != \"MODEL_DATA\":\n    print('Data was predicted to MODEL_DATA column. Will now copy it to the {} column as requested'.format(column))\n    msutils.copycol(msname=msname, fromcol=\"MODEL_DATA\", tocol=column)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef build(image, build_path, tag=None, build_args=None, fromline=None, args=[]):\n\n    if tag:\n        image = \":\".join([image, tag])\n\n    bdir = tempfile.mkdtemp()\n    os.system('cp -r {0:s}/* {1:s}'.format(build_path, bdir))\n    if build_args:\n        stdw = tempfile.NamedTemporaryFile(dir=bdir, mode='w')\n        with open(\"{}/Dockerfile\".format(bdir)) as std:\n            dfile = std.readlines()\n\n        for line in dfile:\n            if fromline and line.lower().startswith('from'):\n                stdw.write('FROM {:s}\\n'.format(fromline))\n            elif line.lower().startswith(\"cmd\"):\n                for arg in build_args:\n                    stdw.write(arg+\"\\n\")\n                stdw.write(line)\n            else:\n                stdw.write(line)\n        stdw.flush()\n        utils.xrun(\"docker build\", args+[\"--force-rm\",\"-f\", stdw.name, \n                   \"-t\", image, \n                    bdir])\n\n        stdw.close()\n    else:\n        utils.xrun(\"docker build\", args+[\"--force-rm\", \"-t\", image, \n                    bdir])\n\n    os.system('rm -rf {:s}'.format(bdir))", "response": "build a docker image"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pull(image, tag=None):\n    if tag:\n        image = \":\".join([image, tag])\n\n    utils.xrun(\"docker pull\", [image])", "response": "pull a docker image"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint out help information about a cab", "response": "def info(cabdir, header=False):\n    \"\"\" prints out help information about a cab \"\"\"\n\n    # First check if cab exists\n    pfile = \"{}/parameters.json\".format(cabdir)\n    if not os.path.exists(pfile):\n        raise RuntimeError(\"Cab could not be found at : {}\".format(cabdir))\n    # Get cab info\n    cab_definition = cab.CabDefinition(parameter_file=pfile)\n    cab_definition.display(header)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun something on command line.", "response": "def xrun(command, options, log=None, _log_container_as_started=False, logfile=None, timeout=-1, kill_callback=None):\n    \"\"\"\n        Run something on command line.\n\n        Example: _run(\"ls\", [\"-lrt\", \"../\"])\n    \"\"\"\n    \n    cmd = \" \".join([command] + list(map(str, options)) )\n\n    def _print_info(msg):\n        if msg is None: return\n        if log:\n            log.info(msg)\n        else:\n            print(msg)\n\n    def _print_warn(msg):\n        if msg is None: return\n        if log:\n            log.warn(msg)\n        else:\n            print(msg)\n    \n    _print_info(u\"Running: {0:s}\".format(cmd))\n\n    sys.stdout.flush()\n    starttime = time.time()\n    process = p = None\n    try:\n        foutname = os.path.join(\"/tmp\", \"stimela_output_{0:s}_{1:f}\".format(hashlib.md5(cmd.encode('utf-8')).hexdigest(), starttime))\n        with open(foutname, \"w+\") as fout:\n            p = process = subprocess.Popen(cmd,\n                                            stderr=fout,\n                                            stdout=fout,\n                                            shell=True)\n\n            def clock_killer(p):\n                while process.poll() is None and (timeout >= 0):\n                    currenttime = time.time()\n                    if (currenttime - starttime < timeout):\n                        DEBUG and _print_warn(u\"Clock Reaper: has been running for {0:f}, must finish in {1:f}\".format(currenttime - starttime, timeout))\n                    else:\n                        _print_warn(u\"Clock Reaper: Timeout reached for '{0:s}'... sending the KILL signal\".format(cmd))\n                        (kill_callback is not None) and kill_callback()\n                    time.sleep(INTERRUPT_TIME)\n\n            Thread(target=clock_killer, args=tuple([p])).start()\n\n            while (process.poll() is None):\n                currenttime = time.time()\n                DEBUG and _print_info(u\"God mode on: has been running for {0:f}\".format(currenttime - starttime))\n                time.sleep(INTERRUPT_TIME) # this is probably not ideal as it interrupts the process every few seconds, \n                #check whether there is an alternative with a callback\n            assert hasattr(process, \"returncode\"), \"No returncode after termination!\"\n        with open(foutname, \"r\") as fout:\n            _print_info(fout.read())\n    finally:\n        if (process is not None) and process.returncode:\n            raise StimelaCabRuntimeError('%s: returns errr code %d' % (command, process.returncode))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning a CASA task given a list of options.", "response": "def icasa(taskname, mult=None, clearstart=False, loadthese=[],**kw0):\n    \"\"\" \n      runs a CASA task given a list of options.\n      A given task can be run multiple times with a different options, \n      in this case the options must be parsed as a list/tuple of dictionaries via mult, e.g \n      icasa('exportfits',mult=[{'imagename':'img1.image','fitsimage':'image1.fits},{'imagename':'img2.image','fitsimage':'image2.fits}]). \n      Options you want be common between the multiple commands should be specified as key word args.\n    \"\"\"\n\n    # create temp directory from which to run casapy\n    td = tempfile.mkdtemp(dir='.')\n    # we want get back to the working directory once casapy is launched\n    cdir = os.path.realpath('.')\n\n    # load modules in loadthese\n    _load = \"\"\n    if \"os\" not in loadthese or \"import os\" not in loadthese:\n        loadthese.append(\"os\")\n\n    if loadthese:\n        exclude = filter(lambda line: line.startswith(\"import\") or line.startswith(\"from\"), loadthese)\n        for line in loadthese:\n            if line not in exclude:\n                line = \"import %s\"%line\n            _load += \"%s\\n\"%line\n\n    if mult:\n        if isinstance(mult,(tuple,list)):\n            for opts in mult:\n                opts.update(kw0)\n        else:\n            mult.upadte(kw0)\n            mult = [mult]\n    else:\n        mult = [kw0]\n\n    run_cmd = \"\"\" \"\"\"\n    for kw in mult:\n        task_cmds = []\n        for key,val in kw.items():\n            if isinstance(val,(str, unicode)):\n                 val = '\"%s\"'%val\n            task_cmds .append('%s=%s'%(key,val))\n\n        task_cmds = \", \".join(task_cmds)\n        run_cmd += \"\"\" \n%s\nos.chdir('%s')\n%s\n%s(%s)\n\"\"\"%(_load, cdir,\"clearstart()\" if clearstart else \"\", taskname, task_cmds)\n\n    tf = tempfile.NamedTemporaryFile(suffix='.py')\n    tf.write(run_cmd)\n    tf.flush()\n    t0 = time.time()\n    # all logging information will be in the pyxis log files \n    print(\"Running {}\".format(run_cmd))\n    xrun(\"cd\", [td, \"&& casa --nologger --log2term --nologfile -c\", tf.name])\n\n    # log taskname.last \n    task_last = '%s.last'%taskname\n    if os.path.exists(task_last):\n        with open(task_last,'r') as last:\n            print('%s.last is: \\n %s'%(taskname, last.read()))\n\n    # remove temp directory. This also gets rid of the casa log files; so long suckers!\n    xrun(\"rm\", [\"-fr \", td, task_last])\n    tf.close()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstack a list of FITS files along a given axis.", "response": "def stack_fits(fitslist, outname, axis=0, ctype=None, keep_old=False, fits=False):\n    \"\"\" Stack a list of fits files along a given axiis.\n       \n       fitslist: list of fits file to combine\n       outname: output file name\n       axis: axis along which to combine the files\n       fits: If True will axis FITS ordering axes\n       ctype: Axis label in the fits header (if given, axis will be ignored)\n       keep_old: Keep component files after combining?\n    \"\"\"\n    import numpy\n    try:\n        import pyfits\n    except ImportError:\n        warnings.warn(\"Could not find pyfits on this system. FITS files will not be stacked\")\n        sys.exit(0)\n\n    hdu = pyfits.open(fitslist[0])[0]\n    hdr = hdu.header\n    naxis = hdr['NAXIS']\n\n    # find axis via CTYPE key\n    if ctype is not None:\n        for i in range(1,naxis+1):\n            if hdr['CTYPE%d'%i].lower().startswith(ctype.lower()):\n                axis = naxis - i # fits to numpy convention\n    elif fits:\n      axis = naxis - axis\n\n    fits_ind = abs(axis-naxis)\n    crval = hdr['CRVAL%d'%fits_ind]\n\n    imslice = [slice(None)]*naxis\n    _sorted = sorted([pyfits.open(fits) for fits in fitslist],\n                    key=lambda a: a[0].header['CRVAL%d'%(naxis-axis)])\n\n    # define structure of new FITS file\n    nn = [ hd[0].header['NAXIS%d'%(naxis-axis)] for hd in _sorted]\n    shape = list(hdu.data.shape)\n    shape[axis] = sum(nn)\n    data = numpy.zeros(shape,dtype=float)\n\n    for i, hdu0 in enumerate(_sorted):\n        h = hdu0[0].header\n        d = hdu0[0].data\n        imslice[axis] = range(sum(nn[:i]),sum(nn[:i+1]) )\n        data[imslice] = d \n        if crval > h['CRVAL%d'%fits_ind]:\n            crval =  h['CRVAL%d'%fits_ind]\n\n    # update header\n    hdr['CRVAL%d'%fits_ind] = crval\n    hdr['CRPIX%d'%fits_ind] = 1 \n\n    pyfits.writeto(outname, data, hdr, clobber=True)\n    print(\"Successfully stacked images. Output image is %s\"%outname)\n\n    # remove old files\n    if not keep_old:\n        for fits in fitslist:\n            os.system('rm -f %s'%fits)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a column to a MS object", "response": "def addcol(msname, colname=None, shape=None,\n           data_desc_type='array', valuetype=None, init_with=0, **kw):\n    \"\"\" add column to MS \n        msanme : MS to add colmn to\n        colname : column name\n        shape : shape\n        valuetype : data type \n        data_desc_type : 'scalar' for scalar elements and array for 'array' elements\n        init_with : value to initialise the column with \n    \"\"\"\n    import numpy\n    import pyrap.tables\n    tab = pyrap.tables.table(msname,readonly=False)\n\n    try: \n        tab.getcol(colname)\n        print('Column already exists')\n\n    except RuntimeError:\n        print('Attempting to add %s column to %s'%(colname,msname))\n\n        from pyrap.tables import maketabdesc\n        valuetype = valuetype or 'complex'\n\n        if shape is None: \n            dshape = list(tab.getcol('DATA').shape)\n            shape = dshape[1:]\n\n        if data_desc_type=='array':\n            from pyrap.tables import makearrcoldesc\n            coldmi = tab.getdminfo('DATA') # God forbid this (or the TIME) column doesn't exist\n            coldmi['NAME'] = colname.lower()\n            tab.addcols(maketabdesc(makearrcoldesc(colname,init_with,shape=shape,valuetype=valuetype)),coldmi)\n\n        elif data_desc_type=='scalar':\n            from pyrap.tables import makescacoldesc\n            coldmi = tab.getdminfo('TIME')\n            coldmi['NAME'] = colname.lower()\n            tab.addcols(maketabdesc(makescacoldesc(colname,init_with,valuetype=valuetype)),coldmi)\n\n        print('Column added successfuly.')\n\n        if init_with:\n            nrows = dshape[0]\n\n            rowchunk = nrows//10 if nrows > 1000 else nrows\n            for row0 in range(0,nrows,rowchunk):\n                nr = min(rowchunk,nrows-row0)\n                dshape[0] = nr\n                tab.putcol(colname,numpy.ones(dshape,dtype=valuetype)*init_with,row0,nr)\n\n    tab.close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsumming columns in cols list.", "response": "def sumcols(msname, col1=None, col2=None, outcol=None, cols=None, suntract=False):\n    \"\"\" add col1 to col2, or sum columns in 'cols' list.\n        If subtract, subtract col2 from col1\n    \"\"\"\n    from pyrap.tables import table\n\n    tab = table(msname, readonly=False)\n    if cols:\n        data = 0\n        for col in cols:\n            data += tab.getcol(col)\n    else:\n        if subtract:\n            data = tab.getcol(col1) - tab.getcol(col2)\n        else:\n            data = tab.getcol(col1) + tab.getcol(col2)\n\n\n    rowchunk = nrows//10 if nrows > 1000 else nrows\n    for row0 in range(0, nrows, rowchunk):\n        nr = min(rowchunk, nrows-row0)\n        tab.putcol(outcol, data[row0:row0+nr], row0, nr)\n\n    tab.close()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compute_vis_noise(msname, sefd, spw_id=0):\n    from pyrap.tables import table\n\n    tab = table(msname)\n    spwtab = table(msname + \"/SPECTRAL_WINDOW\")\n\n    freq0 = spwtab.getcol(\"CHAN_FREQ\")[spw_id, 0]\n    wavelength = 300e+6/freq0\n    bw = spwtab.getcol(\"CHAN_WIDTH\")[spw_id, 0]\n    dt = tab.getcol(\"EXPOSURE\", 0, 1)[0]\n    dtf = (tab.getcol(\"TIME\", tab.nrows()-1, 1)-tab.getcol(\"TIME\", 0, 1))[0]\n\n    # close tables properly, else the calls below will hang waiting for a lock...\n    tab.close()\n    spwtab.close()\n\n    print(\">>> %s freq %.2f MHz (lambda=%.2fm), bandwidth %.2g kHz, %.2fs integrations, %.2fh synthesis\"%(msname, freq0*1e-6, wavelength, bw*1e-3, dt, dtf/3600))\n    noise = sefd/math.sqrt(abs(2*bw*dt))\n    print(\">>> SEFD of %.2f Jy gives per-visibility noise of %.2f mJy\"%(sefd, noise*1000))\n\n    return noise", "response": "Computes nominal per - visibility noise for a given MSS file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget information about a single FITS file.", "response": "def fitsInfo(fitsname = None):\n    \"\"\"\n    Get fits info\n    \"\"\"\n    hdu = pyfits.open(fitsname)\n    hdr = hdu[0].header\n    ra = hdr['CRVAL1']\n    dra = abs(hdr['CDELT1'])\n    raPix = hdr['CRPIX1']\n    dec = hdr['CRVAL2']\n    ddec = abs(hdr['CDELT2'])\n    decPix = hdr['CRPIX2']\n    freq0 = 0\n    for i in range(1,hdr['NAXIS']+1):\n        if hdr['CTYPE%d'%i].strip() == 'FREQ':\n            freq0 = hdr['CRVAL%d'%i]\n            break\n\n    ndim = hdr[\"NAXIS\"]\n    imslice = np.zeros(ndim, dtype=int).tolist()\n    imslice[-2:] = slice(None), slice(None)\n    image = hdu[0].data[imslice]\n    wcs = WCS(hdr,mode='pyfits')\n\n    return {'image':image,'wcs':wcs,'ra':ra,'dec':dec,'dra':dra,'ddec':ddec,'raPix':raPix,'decPix':decPix,'freq0':freq0}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sky2px(wcs,ra,dec,dra,ddec,cell, beam):\n    dra = beam if dra<beam else dra # assume every source is at least as large as the psf\n    ddec = beam if ddec<beam else ddec\n    offsetDec = int((ddec/2.)/cell)\n    offsetRA = int((dra/2.)/cell)\n    if offsetDec%2==1:\n        offsetDec += 1\n    if offsetRA%2==1:\n        offsetRA += 1\n\n    raPix,decPix = map(int, wcs.wcs2pix(ra,dec))\n    return np.array([raPix-offsetRA,raPix+offsetRA,decPix-offsetDec,decPix+offsetDec])", "response": "convert a sky region to pixel positions"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef addSPI(fitsname_alpha=None, fitsname_alpha_error=None, lsmname=None,\n           outfile=None,freq0=None, beam=None, spitol=(-10,10)):\n    \"\"\"\n        Add spectral index to a tigger lsm from a spectral index map (fits format)\n        takes in a spectral index map, input lsm and output lsm name.\n    \"\"\"\n#    import pylab as plt\n    if beam is None:\n        raise RuntimeError(\"the beam option must be specified\")\n\n    print \"INFO: Getting fits info from: %s, %s\" %(fitsname_alpha, fitsname_alpha_error)\n\n    fits_alpha = fitsInfo(fitsname_alpha)    # Get fits info\n    image_alpha = fits_alpha['image']     # get image data\n\n    if fitsname_alpha_error:\n        fits_alpha_error = fitsInfo(fitsname_alpha_error)\n        image_alpha_error = fits_alpha_error['image']\n    else:\n        fits_alpha_error = fitsInfo(fitsname_alpha)\n        image_alpha_error = fits_alpha_error['image']\n        image_alpha_error[...] = 1.0\n\n    # may supply FITS file for freq0, in which case just pull ref frequency from FITS file,\n    # else explicit frequency, else get frequency from alpha image\n    if type(freq0) is str:\n        freq0 = fitsInfo(freq0)['freq0']\n    else:\n        freq0 = freq0 or fits_alpha['freq0']\n\n    model = Tigger.load(lsmname)    # load output sky model\n    rad = lambda a: a*(180/np.pi) # convert radians to degrees\n\n    for src in model.sources:\n        ra = rad(src.pos.ra)\n        dec = rad(src.pos.dec)\n\n        # Cater for point sources and assume source extent equal to the\n        # Gaussian major axis along both ra and dec axis\n        dra = rad(src.shape.ex) if src.shape  else beam[0]\n        ddec = rad(src.shape.ey) if src.shape  else beam[1]\n        pa = rad(src.shape.pa) if src.shape  else beam[2]\n\n        emin, emaj = sorted([dra, ddec])\n        # Determine region of interest\n        rgn = sky2px(fits_alpha[\"wcs\"],ra,dec,dra,ddec,fits_alpha[\"dra\"], beam[1])\n        imslice = slice(rgn[2], rgn[3]), slice(rgn[0], rgn[3])\n        alpha = image_alpha[imslice]\n        xpix, ypix = alpha.shape\n        xx, yy = np.ogrid[-xpix:xpix, -ypix:ypix]\n\n        emajPix = emaj/fits_alpha[\"dra\"]\n        eminPix = emin/fits_alpha[\"dra\"]\n        # Create elliptcal mask which has same shape as source\n        mask = ((xx/emajPix)**2 + (yy/eminPix)**2 <= 1)[xpix*2-xpix:xpix*2+xpix, ypix*2-ypix:ypix*2+ypix]\n        mask = ndimage.rotate(mask, angle=pa, order=0, reshape=False)\n        \n        draPix = dra/fits_alpha[\"dra\"]\n        ddPix = ddec/fits_alpha[\"ddec\"]\n\n        alpha *= mask\n        alpha_error = image_alpha_error[imslice]*mask\n        good = np.where( np.logical_and(alpha!=0, alpha!=np.nan))\n        alpha = alpha[good]\n        alpha_error = alpha_error[good]\n        good = np.where( np.logical_and(alpha_error!=np.nan, alpha_error!=np.inf))\n\n        alpha = alpha[good]\n        alpha_error = alpha_error[good]\n\n        subIm_weight = 1/alpha_error\n        subIm_weighted = alpha*subIm_weight\n\n        if len(subIm_weighted)>0:\n            subIm_normalization = np.sum(subIm_weight)\n            spi = float(np.sum(subIm_weighted)/subIm_normalization)\n            spi_error = 1/float(subIm_normalization)\n            if spi > spitol[0] or spi < spitol[-1]:\n                sys.stdout.write(\"INFO: Adding spi: %.3f (at %.3g MHz) to source %s\" % (\n                                 spi, freq0/1e6, src.name))\n                src.spectrum = Tigger.Models.ModelClasses.SpectralIndex(spi, freq0)\n                src.setAttribute('spi_error', spi_error)\n        else:\n            sys.stdout.write(\"ALERT: no spi info found in %s for source %s\" % (\n                             fitsname_alpha, src.name))\n\n    model.save(outfile)", "response": "Add a spectral index map to a tigger lsm."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the components of chord quality", "response": "def get_components(self, root='C', visible=False):\n        \"\"\" Get components of chord quality\n\n        :param str root: the root note of the chord\n        :param bool visible: returns the name of notes if True\n        :rtype: list[str|int]\n        :return: components of chord quality\n        \"\"\"\n        root_val = note_to_val(root)\n        components = [v + root_val for v in self.components]\n\n        if visible:\n            components = [val_to_note(c, scale=root) for c in components]\n\n        return components"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nappending on chord to the list of components.", "response": "def append_on_chord(self, on_chord, root):\n        \"\"\" Append on chord\n\n        To create Am7/G\n        q = Quality('m7')\n        q.append_on_chord('G', root='A')\n\n        :param str on_chord: bass note of the chord\n        :param str root: root note of the chord\n        \"\"\"\n        root_val = note_to_val(root)\n        on_chord_val = note_to_val(on_chord) - root_val\n\n        list_ = list(self.components)\n        for idx, val in enumerate(list_):\n            if val % 12 == on_chord_val:\n                self.components.remove(val)\n                break\n\n        if on_chord_val > root_val:\n            on_chord_val -= 12\n\n        if on_chord_val not in self.components:\n            self.components.insert(0, on_chord_val)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef append_note(self, note, root, scale=0):\n        root_val = note_to_val(root)\n        note_val = note_to_val(note) - root_val + scale * 12\n        if note_val not in self.components:\n            self.components.append(note_val)\n            self.components.sort()", "response": "Append a note to the quality set."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef append_notes(self, notes, root, scale=0):\n        for note in notes:\n            self.append_note(note, root, scale)", "response": "Append notes to the quality set"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninsert a chord into the list of Chords in the cache.", "response": "def insert(self, index, chord):\n        \"\"\" Insert a chord to chord progressions\n\n        :param int index: Index to insert a chord\n        :type chord: str|pychord.Chord\n        :param chord: A chord to insert\n        :return:\n        \"\"\"\n        self._chords.insert(index, as_chord(chord))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef as_chord(chord):\n    if isinstance(chord, Chord):\n        return chord\n    elif isinstance(chord, str):\n        return Chord(chord)\n    else:\n        raise TypeError(\"input type should be str or Chord instance.\")", "response": "convert from str to Chord instance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef info(self):\n        return \"\"\"{}\nroot={}\nquality={}\nappended={}\non={}\"\"\".format(self._chord, self._root, self._quality, self._appended, self._on)", "response": "Return information about the current chord"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntransposes the chords of the key sequence.", "response": "def transpose(self, trans, scale=\"C\"):\n        \"\"\" Transpose the chord\n\n        :param int trans: Transpose key\n        :param str scale: key scale\n        :return:\n        \"\"\"\n        if not isinstance(trans, int):\n            raise TypeError(\"Expected integers, not {}\".format(type(trans)))\n        self._root = transpose_note(self._root, trans, scale)\n        if self._on:\n            self._on = transpose_note(self._on, trans, scale)\n        self._reconfigure_chord()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef components(self, visible=True):\n        if self._on:\n            self._quality.append_on_chord(self.on, self.root)\n\n        return self._quality.get_components(root=self._root, visible=visible)", "response": "Return the component notes of chord\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse(self, chord):\n        root, quality, appended, on = parse(chord)\n        self._root = root\n        self._quality = quality\n        self._appended = appended\n        self._on = on", "response": "parse a chord\n\n        :param str chord: Name of chord."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef transpose_note(note, transpose, scale=\"C\"):\n    val = note_to_val(note)\n    val += transpose\n    return val_to_note(val, scale)", "response": "Transpose a note in a node - order order"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse(chord):\n    if len(chord) > 1 and chord[1] in (\"b\", \"#\"):\n        root = chord[:2]\n        rest = chord[2:]\n    else:\n        root = chord[:1]\n        rest = chord[1:]\n    check_note(root, chord)\n    on_chord_idx = rest.find(\"/\")\n    if on_chord_idx >= 0:\n        on = rest[on_chord_idx + 1:]\n        rest = rest[:on_chord_idx]\n        check_note(on, chord)\n    else:\n        on = None\n    if rest in QUALITY_DICT:\n        quality = Quality(rest)\n    else:\n        raise ValueError(\"Invalid chord {}: Unknown quality {}\".format(chord, rest))\n    # TODO: Implement parser for appended notes\n    appended = []\n    return root, quality, appended, on", "response": "Parse a string to get a chord component\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if the note is valid.", "response": "def check_note(note, chord):\n    \"\"\" Return True if the note is valid.\n\n    :param str note: note to check its validity\n    :param str chord: the chord which includes the note\n    :rtype: bool\n    \"\"\"\n    if note not in NOTE_VAL_DICT:\n        raise ValueError(\"Invalid chord {}: Unknown note {}\".format(chord, note))\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a list of notes to a list of Chords.", "response": "def note_to_chord(notes):\n    \"\"\" Convert note list to chord list\n\n    :param list[str] notes: list of note arranged from lower note. ex) [\"C\", \"Eb\", \"G\"]\n    :rtype: list[pychord.Chord]\n    :return: list of chord\n    \"\"\"\n    if not notes:\n        raise ValueError(\"Please specify notes which consist a chord.\")\n    root = notes[0]\n    root_and_positions = []\n    for rotated_notes in get_all_rotated_notes(notes):\n        rotated_root = rotated_notes[0]\n        root_and_positions.append([rotated_root, notes_to_positions(rotated_notes, rotated_notes[0])])\n    chords = []\n    for temp_root, positions in root_and_positions:\n        quality = find_quality(positions)\n        if quality is None:\n            continue\n        if temp_root == root:\n            chord = \"{}{}\".format(root, quality)\n        else:\n            chord = \"{}{}/{}\".format(temp_root, quality, root)\n        chords.append(Chord(chord))\n    return chords"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef notes_to_positions(notes, root):\n    root_pos = note_to_val(root)\n    current_pos = root_pos\n    positions = []\n    for note in notes:\n        note_pos = note_to_val(note)\n        if note_pos < current_pos:\n            note_pos += 12 * ((current_pos - note_pos) // 12 + 1)\n        positions.append(note_pos - root_pos)\n        current_pos = note_pos\n    return positions", "response": "Get notes positions.\n\n    ex) notes_to_positions([\"C\", \"E\", \"G\"], \"C\") -> [0, 4, 7]\n\n    :param list[str] notes: list of notes\n    :param str root: the root note\n    :rtype: list[int]\n    :return: list of note positions"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_all_rotated_notes(notes):\n    notes_list = []\n    for x in range(len(notes)):\n        notes_list.append(notes[x:] + notes[:x])\n    return notes_list", "response": "Get all rotated notes in the order of the notes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_quality(positions):\n    for q, p in QUALITY_DICT.items():\n        if positions == list(p):\n            return q\n    return None", "response": "Find a quality consists of positions\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nserialize value as a timestamp or a UTC isoformat string.", "response": "def _serialize(self, value, attr, obj):\n        \"\"\"\n        Serialize value as a timestamp, either as a Unix timestamp (in float second) or a UTC isoformat string.\n\n        \"\"\"\n        if value is None:\n            return None\n\n        if self.use_isoformat:\n            return datetime.utcfromtimestamp(value).isoformat()\n        else:\n            return value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _deserialize(self, value, attr, obj):\n        if value is None:\n            return None\n\n        try:\n            return float(value)\n        except ValueError:\n            parsed = parser.parse(value)\n            if parsed.tzinfo:\n                if parsed.utcoffset().total_seconds():\n                    raise ValidationError(\"Timestamps must be defined in UTC\")\n                parsed = parsed.replace(tzinfo=None)\n            return (parsed - TimestampField.EPOCH).total_seconds()", "response": "Deserialize value as a Unix timestamp in seconds."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\napplying mappings to a namespace.", "response": "def configure(self, ns, mappings=None, **kwargs):\n        \"\"\"\n        Apply mappings to a namespace.\n\n        \"\"\"\n        if mappings is None:\n            mappings = dict()\n        mappings.update(kwargs)\n\n        for operation, definition in mappings.items():\n            try:\n                configure_func = self._find_func(operation)\n            except AttributeError:\n                pass\n            else:\n                configure_func(ns, self._make_definition(definition))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _find_func(self, operation):\n        if isinstance(operation, Operation):\n            operation_name = operation.name.lower()\n        else:\n            operation_name = operation.lower()\n\n        return getattr(self, \"configure_{}\".format(operation_name))", "response": "Find the function to use to configure the given operation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a EndpointDefinition object from a tuple.", "response": "def _make_definition(self, definition):\n        \"\"\"\n        Generate a definition.\n\n        The input might already be a `EndpointDefinition` or it might be a tuple.\n\n        \"\"\"\n        if not definition:\n            return EndpointDefinition()\n        if isinstance(definition, EndpointDefinition):\n            return definition\n        elif len(definition) == 1:\n            return EndpointDefinition(\n                func=definition[0],\n            )\n        elif len(definition) == 2:\n            return EndpointDefinition(\n                func=definition[0],\n                response_schema=definition[1],\n            )\n        elif len(definition) == 3:\n            return EndpointDefinition(\n                func=definition[0],\n                request_schema=definition[1],\n                response_schema=definition[2],\n            )\n        elif len(definition) == 4:\n            return EndpointDefinition(\n                func=definition[0],\n                request_schema=definition[1],\n                response_schema=definition[2],\n                header_func=definition[3],\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates links for an iterable of operations on a starting page.", "response": "def iter_links(operations, page):\n    \"\"\"\n    Generate links for an iterable of operations on a starting page.\n\n    \"\"\"\n    for operation, ns, rule, func in operations:\n        yield Link.for_(\n            operation=operation,\n            ns=ns,\n            type=ns.subject_name,\n            qs=page.to_items(),\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild a singleton endpoint that provides a link to all search endpoints.", "response": "def configure_discovery(graph):\n    \"\"\"\n    Build a singleton endpoint that provides a link to all search endpoints.\n\n    \"\"\"\n    ns = Namespace(\n        subject=graph.config.discovery_convention.name,\n    )\n    convention = DiscoveryConvention(graph)\n    convention.configure(ns, discover=tuple())\n    return ns.subject"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding all matching endpoints in the discovery namespace.", "response": "def find_matching_endpoints(self, discovery_ns):\n        \"\"\"\n        Compute current matching endpoints.\n\n        Evaluated as a property to defer evaluation.\n\n        \"\"\"\n        def match_func(operation, ns, rule):\n            return operation in self.matching_operations\n\n        return list(iter_endpoints(self.graph, match_func))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nregistering a discovery endpoint for a set of operations.", "response": "def configure_discover(self, ns, definition):\n        \"\"\"\n        Register a discovery endpoint for a set of operations.\n\n        \"\"\"\n        page_schema = OffsetLimitPageSchema()\n\n        @self.add_route(\"/\", Operation.Discover, ns)\n        def discover():\n            # accept pagination limit from request\n            page = OffsetLimitPage.from_query_string(page_schema)\n            page.offset = 0\n\n            response_data = dict(\n                _links=Links({\n                    \"self\": Link.for_(Operation.Discover, ns, qs=page.to_items()),\n                    \"search\": [\n                        link for link in iter_links(self.find_matching_endpoints(ns), page)\n                    ],\n                }).to_dict()\n            )\n            return make_response(response_data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef nested(*contexts):\n    with ExitStack() as stack:\n        results = [\n            stack.enter_context(context)\n            for context in contexts\n        ]\n        yield results", "response": "Yields the nested items of the given contexts."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupload a file to a temporary location. Flask will not load sufficiently large files into memory, so it makes sense to always load files into a temporary directory.", "response": "def temporary_upload(name, fileobj):\n    \"\"\"\n    Upload a file to a temporary location.\n\n    Flask will not load sufficiently large files into memory, so it\n    makes sense to always load files into a temporary directory.\n\n    \"\"\"\n    tempdir = mkdtemp()\n    filename = secure_filename(fileobj.filename)\n    filepath = join(tempdir, filename)\n    fileobj.save(filepath)\n    try:\n        yield name, filepath, fileobj.filename\n    finally:\n        rmtree(tempdir)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef configure_upload(graph, ns, mappings, exclude_func=None):\n    convention = UploadConvention(graph, exclude_func)\n    convention.configure(ns, mappings)", "response": "Register Upload endpoints for a resource object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef configure_upload(self, ns, definition):\n        upload = self.create_upload_func(ns, definition, ns.collection_path, Operation.Upload)\n        upload.__doc__ = \"Upload a {}\".format(ns.subject_name)", "response": "Register an upload endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef configure_uploadfor(self, ns, definition):\n        upload_for = self.create_upload_func(ns, definition, ns.relation_path, Operation.UploadFor)\n        upload_for.__doc__ = \"Upload a {} for a {}\".format(ns.subject_name, ns.object_name)", "response": "Register an upload - for relation endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_etag(self, response, include_etag=True, **kwargs):\n        if not include_etag:\n            return\n\n        if not spooky:\n            # use built-in md5\n            response.add_etag()\n            return\n\n        # use spooky\n        response.headers[\"ETag\"] = quote_etag(\n            hexlify(\n                spooky.hash128(\n                    response.get_data(),\n                ).to_bytes(16, \"little\"),\n            ).decode(\"utf-8\"),\n        )", "response": "Build an etag for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the object with the new value and re - encrypt the object.", "response": "def update_and_reencrypt(self, **kwargs):\n        \"\"\"\n        Support re-encryption by enforcing that every update triggers a\n        new encryption call, even if the the original call does not update\n        the encrypted field.\n\n        \"\"\"\n        encrypted_field_name = self.store.model_class.__plaintext__\n\n        id_ = kwargs[self.identifier_key]\n        current_model = self.store.retrieve(id_)\n        current_value = current_model.plaintext\n\n        null_update = (\n            # Check if the update is for the encrypted field, and if it's explicitly set to null\n            encrypted_field_name in kwargs\n            and kwargs.get(encrypted_field_name) is None\n        )\n        new_value = kwargs.pop(self.store.model_class.__plaintext__, None)\n        use_new_value = new_value is not None or null_update\n\n        updated_value = new_value if use_new_value else current_value\n\n        model_kwargs = {\n            self.identifier_key: id_,\n            encrypted_field_name: updated_value,\n            **kwargs,\n        }\n\n        return super().update(\n            **model_kwargs,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unflatten(self, obj):\n        obj.substitutions = [\n            dict(from_id=key, to_id=value)\n            for key, value in getattr(obj, \"substitutions\", {}).items()\n        ]", "response": "Translate substitutions dictionary into objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clone(self, substitutions, commit=True, **kwargs):\n        return self.store.clone(substitutions, **kwargs)", "response": "Clone a DAG optionally skipping the commit"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef configure_relation(graph, ns, mappings):\n    convention = RelationConvention(graph)\n    convention.configure(ns, mappings)", "response": "Register relation endpoint endpoints between two resources."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nregister a create - for relation endpoint.", "response": "def configure_createfor(self, ns, definition):\n        \"\"\"\n        Register a create-for relation endpoint.\n\n        The definition's func should be a create function, which must:\n        - accept kwargs for the new instance creation parameters\n        - return the created instance\n\n        :param ns: the namespace\n        :param definition: the endpoint definition\n\n        \"\"\"\n        @self.add_route(ns.relation_path, Operation.CreateFor, ns)\n        @request(definition.request_schema)\n        @response(definition.response_schema)\n        @wraps(definition.func)\n        def create(**path_data):\n            request_data = load_request_data(definition.request_schema)\n            response_data = require_response_data(definition.func(**merge_data(path_data, request_data)))\n            headers = encode_id_header(response_data)\n            definition.header_func(headers, response_data)\n            response_format = self.negotiate_response_content(definition.response_formats)\n            return dump_response_data(\n                definition.response_schema,\n                response_data,\n                Operation.CreateFor.value.default_code,\n                headers=headers,\n                response_format=response_format,\n            )\n\n        create.__doc__ = \"Create a new {} relative to a {}\".format(pluralize(ns.object_name), ns.subject_name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef configure_deletefor(self, ns, definition):\n        @self.add_route(ns.relation_path, Operation.DeleteFor, ns)\n        @wraps(definition.func)\n        def delete(**path_data):\n            headers = dict()\n            response_data = dict()\n            require_response_data(definition.func(**path_data))\n            definition.header_func(headers, response_data)\n            response_format = self.negotiate_response_content(definition.response_formats)\n            return dump_response_data(\n                \"\",\n                None,\n                status_code=Operation.DeleteFor.value.default_code,\n                headers=headers,\n                response_format=response_format,\n            )\n\n        delete.__doc__ = \"Delete a {} relative to a {}\".format(pluralize(ns.object_name), ns.subject_name)", "response": "Register a delete - for relation endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nregistering a replace - for relation endpoint.", "response": "def configure_replacefor(self, ns, definition):\n        \"\"\"\n        Register a replace-for relation endpoint.\n\n        For typical usage, this relation is not strictly required; once an object exists and has its own ID,\n        it is better to operate on it directly via dedicated CRUD routes.\n        However, in some cases, the composite key of (subject_id, object_id) is required to look up the object.\n        This happens, for example, when using DynamoDB where an object which maintains both a hash key and a range key\n        requires specifying them both for access.\n\n        The definition's func should be a replace function, which must:\n\n        - accept kwargs for the new instance replacement parameters\n        - return the instance\n\n        :param ns: the namespace\n        :param definition: the endpoint definition\n\n        \"\"\"\n        @self.add_route(ns.relation_path, Operation.ReplaceFor, ns)\n        @request(definition.request_schema)\n        @response(definition.response_schema)\n        @wraps(definition.func)\n        def replace(**path_data):\n            headers = dict()\n            request_data = load_request_data(definition.request_schema)\n            response_data = require_response_data(definition.func(**merge_data(path_data, request_data)))\n            definition.header_func(headers, response_data)\n            response_format = self.negotiate_response_content(definition.response_formats)\n            return dump_response_data(\n                definition.response_schema,\n                response_data,\n                status_code=Operation.ReplaceFor.value.default_code,\n                headers=headers,\n                response_format=response_format,\n            )\n\n        replace.__doc__ = \"Replace a {} relative to a {}\".format(pluralize(ns.object_name), ns.subject_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef configure_retrievefor(self, ns, definition):\n        request_schema = definition.request_schema or Schema()\n\n        @self.add_route(ns.relation_path, Operation.RetrieveFor, ns)\n        @qs(request_schema)\n        @response(definition.response_schema)\n        @wraps(definition.func)\n        def retrieve(**path_data):\n            headers = dict()\n            request_data = load_query_string_data(request_schema)\n            response_data = require_response_data(definition.func(**merge_data(path_data, request_data)))\n            definition.header_func(headers, response_data)\n            response_format = self.negotiate_response_content(definition.response_formats)\n            return dump_response_data(\n                definition.response_schema,\n                response_data,\n                headers=headers,\n                response_format=response_format,\n            )\n\n        retrieve.__doc__ = \"Retrieve {} relative to a {}\".format(pluralize(ns.object_name), ns.subject_name)", "response": "Register a retrieve for endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef configure_searchfor(self, ns, definition):\n        paginated_list_schema = self.page_cls.make_paginated_list_schema_class(\n            ns.object_ns,\n            definition.response_schema,\n        )()\n\n        @self.add_route(ns.relation_path, Operation.SearchFor, ns)\n        @qs(definition.request_schema)\n        @response(paginated_list_schema)\n        @wraps(definition.func)\n        def search(**path_data):\n            page = self.page_cls.from_query_string(definition.request_schema)\n            result = definition.func(**merge_data(path_data, page.to_dict(func=identity)))\n            response_data, headers = page.to_paginated_list(result, ns, Operation.SearchFor)\n            definition.header_func(headers, response_data)\n            response_format = self.negotiate_response_content(definition.response_formats)\n            return dump_response_data(\n                paginated_list_schema,\n                response_data,\n                headers=headers,\n                response_format=response_format,\n            )\n\n        search.__doc__ = \"Search for {} relative to a {}\".format(pluralize(ns.object_name), ns.subject_name)", "response": "Register a search for endpoint."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef configure_config(graph):\n    ns = Namespace(\n        subject=Config,\n    )\n\n    convention = ConfigDiscoveryConvention(\n        graph,\n    )\n    convention.configure(ns, retrieve=tuple())\n    return convention.config_discovery", "response": "Configure the health endpoint."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nencodes the name status of all checks and current overall status.", "response": "def to_dict(self):\n        \"\"\"\n        Encode the name, the status of all checks, and the current overall status.\n\n        \"\"\"\n        if not isinstance(self.graph.loader, PartitioningLoader):\n            return dict(msg=\"Config sharing disabled for non-partioned loader\")\n\n        if not hasattr(self.graph.loader, \"secrets\"):\n            return dict(msg=\"Config sharing disabled if no secrets are labelled\")\n\n        def remove_nulls(dct):\n            return {key: value for key, value in dct.items() if value is not None}\n\n        return loads(\n            dumps(self.graph.loader.config, skipkeys=True, default=lambda obj: None),\n            object_hook=remove_nulls,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds a swagger parameter from a marshmallow field.", "response": "def build(self, field: Field) -> Mapping[str, Any]:\n        \"\"\"\n        Build a swagger parameter from a marshmallow field.\n\n        \"\"\"\n        builder_types = self.builder_types() + [\n            # put default last\n            self.default_builder_type()\n        ]\n\n        builders: List[ParameterBuilder] = [\n            builder_type(\n                build_parameter=self.build,\n            )\n            for builder_type in builder_types\n        ]\n\n        builder = next(\n            builder\n            for builder in builders\n            if builder.supports_field(field)\n        )\n\n        return builder.build(field)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the available builder types.", "response": "def builder_types(cls) -> List[Type[ParameterBuilder]]:\n        \"\"\"\n        Define the available builder types.\n\n        \"\"\"\n        return [\n            entry_point.load()\n            for entry_point in iter_entry_points(ENTRY_POINT)\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconfiguring CRUD endpoints for a resource object.", "response": "def configure_crud(graph, ns, mappings):\n    \"\"\"\n    Register CRUD endpoints for a resource object.\n\n    :param mappings: a dictionary from operations to tuple, where each tuple contains\n                     the target function and zero or more marshmallow schemas according\n                     to the signature of the \"register_<foo>_endpoint\" functions\n\n    Example mapping:\n\n        {\n            Operation.Create: (create_foo, NewFooSchema(), FooSchema()),\n            Operation.Delete: (delete_foo,),\n            Operation.Retrieve: (retrieve_foo, FooSchema()),\n            Operation.Search: (search_foo, SearchFooSchema(), FooSchema(), [ResponseFormats.CSV]),\n        }\n\n    \"\"\"\n    convention = CRUDConvention(graph)\n    convention.configure(ns, mappings)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nregister a count endpoint.", "response": "def configure_count(self, ns, definition):\n        \"\"\"\n        Register a count endpoint.\n\n        The definition's func should be a count function, which must:\n        - accept kwargs for the query string\n        - return a count is the total number of items available\n\n        The definition's request_schema will be used to process query string arguments.\n\n        :param ns: the namespace\n        :param definition: the endpoint definition\n\n        \"\"\"\n        @self.add_route(ns.collection_path, Operation.Count, ns)\n        @qs(definition.request_schema)\n        @wraps(definition.func)\n        def count(**path_data):\n            request_data = load_query_string_data(definition.request_schema)\n            response_data = dict()\n            count = definition.func(**merge_data(path_data, request_data))\n            headers = encode_count_header(count)\n            definition.header_func(headers, response_data)\n            response_format = self.negotiate_response_content(definition.response_formats)\n            return dump_response_data(\n                None,\n                None,\n                headers=headers,\n                response_format=response_format,\n            )\n\n        count.__doc__ = \"Count the size of the collection of all {}\".format(pluralize(ns.subject_name))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef configure_create(self, ns, definition):\n        @self.add_route(ns.collection_path, Operation.Create, ns)\n        @request(definition.request_schema)\n        @response(definition.response_schema)\n        @wraps(definition.func)\n        def create(**path_data):\n            request_data = load_request_data(definition.request_schema)\n            response_data = definition.func(**merge_data(path_data, request_data))\n            headers = encode_id_header(response_data)\n            definition.header_func(headers, response_data)\n            response_format = self.negotiate_response_content(definition.response_formats)\n            return dump_response_data(\n                definition.response_schema,\n                response_data,\n                status_code=Operation.Create.value.default_code,\n                headers=headers,\n                response_format=response_format,\n            )\n\n        create.__doc__ = \"Create a new {}\".format(ns.subject_name)", "response": "Register a create endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef configure_updatebatch(self, ns, definition):\n        operation = Operation.UpdateBatch\n\n        @self.add_route(ns.collection_path, operation, ns)\n        @request(definition.request_schema)\n        @response(definition.response_schema)\n        @wraps(definition.func)\n        def update_batch(**path_data):\n            headers = dict()\n            request_data = load_request_data(definition.request_schema)\n            response_data = definition.func(**merge_data(path_data, request_data))\n            definition.header_func(headers, response_data)\n            response_format = self.negotiate_response_content(definition.response_formats)\n            return dump_response_data(\n                definition.response_schema,\n                response_data,\n                status_code=operation.value.default_code,\n                headers=headers,\n                response_format=response_format,\n            )\n\n        update_batch.__doc__ = \"Update a batch of {}\".format(ns.subject_name)", "response": "Register an update batch endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef configure_retrieve(self, ns, definition):\n        request_schema = definition.request_schema or Schema()\n\n        @self.add_route(ns.instance_path, Operation.Retrieve, ns)\n        @qs(request_schema)\n        @response(definition.response_schema)\n        @wraps(definition.func)\n        def retrieve(**path_data):\n            headers = dict()\n            request_data = load_query_string_data(request_schema)\n            response_data = require_response_data(definition.func(**merge_data(path_data, request_data)))\n            definition.header_func(headers, response_data)\n            response_format = self.negotiate_response_content(definition.response_formats)\n            return dump_response_data(\n                definition.response_schema,\n                response_data,\n                headers=headers,\n                response_format=response_format,\n            )\n\n        retrieve.__doc__ = \"Retrieve a {} by id\".format(ns.subject_name)", "response": "Register a retrieve endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef configure_delete(self, ns, definition):\n        request_schema = definition.request_schema or Schema()\n\n        @self.add_route(ns.instance_path, Operation.Delete, ns)\n        @qs(request_schema)\n        @wraps(definition.func)\n        def delete(**path_data):\n            headers = dict()\n            request_data = load_query_string_data(request_schema)\n            response_data = require_response_data(definition.func(**merge_data(path_data, request_data)))\n            definition.header_func(headers, response_data)\n            response_format = self.negotiate_response_content(definition.response_formats)\n            return dump_response_data(\n                \"\",\n                None,\n                status_code=Operation.Delete.value.default_code,\n                headers=headers,\n                response_format=response_format,\n            )\n\n        delete.__doc__ = \"Delete a {} by id\".format(ns.subject_name)", "response": "Register a delete endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nregisters a replace endpoint.", "response": "def configure_replace(self, ns, definition):\n        \"\"\"\n        Register a replace endpoint.\n\n        The definition's func should be a replace function, which must:\n        - accept kwargs for the request and path data\n        - return the replaced item\n\n        :param ns: the namespace\n        :param definition: the endpoint definition\n\n        \"\"\"\n        @self.add_route(ns.instance_path, Operation.Replace, ns)\n        @request(definition.request_schema)\n        @response(definition.response_schema)\n        @wraps(definition.func)\n        def replace(**path_data):\n            headers = dict()\n            request_data = load_request_data(definition.request_schema)\n            # Replace/put should create a resource if not already present, but we do not\n            # enforce these semantics at the HTTP layer. If `func` returns falsey, we\n            # will raise a 404.\n            response_data = require_response_data(definition.func(**merge_data(path_data, request_data)))\n            definition.header_func(headers, response_data)\n            response_format = self.negotiate_response_content(definition.response_formats)\n            return dump_response_data(\n                definition.response_schema,\n                response_data,\n                headers=headers,\n                response_format=response_format,\n            )\n\n        replace.__doc__ = \"Create or update a {} by id\".format(ns.subject_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef configure_update(self, ns, definition):\n        @self.add_route(ns.instance_path, Operation.Update, ns)\n        @request(definition.request_schema)\n        @response(definition.response_schema)\n        @wraps(definition.func)\n        def update(**path_data):\n            headers = dict()\n            # NB: using partial here means that marshmallow will not validate required fields\n            request_data = load_request_data(definition.request_schema, partial=True)\n            response_data = require_response_data(definition.func(**merge_data(path_data, request_data)))\n            definition.header_func(headers, response_data)\n            response_format = self.negotiate_response_content(definition.response_formats)\n            return dump_response_data(\n                definition.response_schema,\n                response_data,\n                headers=headers,\n                response_format=response_format,\n            )\n\n        update.__doc__ = \"Update some or all of a {} by id\".format(ns.subject_name)", "response": "Register an update endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nregister create collection endpoint.", "response": "def configure_createcollection(self, ns, definition):\n        \"\"\"\n        Register create collection endpoint.\n\n        :param ns: the namespace\n        :param definition: the endpoint definition\n        \"\"\"\n        paginated_list_schema = self.page_cls.make_paginated_list_schema_class(\n            ns,\n            definition.response_schema,\n        )()\n\n        @self.add_route(ns.collection_path, Operation.CreateCollection, ns)\n        @request(definition.request_schema)\n        @response(paginated_list_schema)\n        @wraps(definition.func)\n        def create_collection(**path_data):\n            request_data = load_request_data(definition.request_schema)\n            # NB: if we don't filter the request body through an explicit page schema,\n            # we will leak other request arguments into the pagination query strings\n            page = self.page_cls.from_query_string(self.page_schema(), request_data)\n\n            result = definition.func(**merge_data(\n                path_data,\n                merge_data(\n                    request_data,\n                    page.to_dict(func=identity),\n                ),\n            ))\n\n            response_data, headers = page.to_paginated_list(result, ns, Operation.CreateCollection)\n            definition.header_func(headers, response_data)\n            response_format = self.negotiate_response_content(definition.response_formats)\n            return dump_response_data(\n                paginated_list_schema,\n                response_data,\n                headers=headers,\n                response_format=response_format,\n            )\n\n        create_collection.__doc__ = \"Create the collection of {}\".format(pluralize(ns.subject_name))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef configure_health(graph):\n    ns = Namespace(\n        subject=Health,\n    )\n\n    include_build_info = strtobool(graph.config.health_convention.include_build_info)\n    convention = HealthConvention(graph, include_build_info)\n    convention.configure(ns, retrieve=tuple())\n    return convention.health", "response": "Configure the health endpoint."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a dictionary representation of the current service.", "response": "def to_dict(self):\n        \"\"\"\n        Encode the name, the status of all checks, and the current overall status.\n\n        \"\"\"\n        # evaluate checks\n        checks = {\n            key: HealthResult.evaluate(func, self.graph)\n            for key, func in self.checks.items()\n        }\n        dct = dict(\n            # return the service name helps for routing debugging\n            name=self.name,\n            ok=all(checks.values()),\n        )\n        if checks:\n            dct[\"checks\"] = {\n                key: checks[key].to_dict()\n                for key in sorted(checks.keys())\n            }\n        return dct"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the reference type for nested fields.", "response": "def parse_ref(self, field: Field) -> str:\n        \"\"\"\n        Parse the reference type for nested fields, if any.\n\n        \"\"\"\n        ref_name = type_name(name_for(field.schema))\n        return f\"#/definitions/{ref_name}\""}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef configure_build_info(graph):\n    ns = Namespace(\n        subject=BuildInfo,\n    )\n\n    convention = BuildInfoConvention(graph)\n    convention.configure(ns, retrieve=tuple())\n    return convention.build_info", "response": "Configure the build info endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding a DFS tree representing the logger layout.", "response": "def build_logger_tree():\n    \"\"\"\n    Build a DFS tree representing the logger layout.\n\n    Adapted with much appreciation from: https://github.com/brandon-rhodes/logging_tree\n\n    \"\"\"\n    cache = {}\n    tree = make_logger_node(\"\", root)\n    for name, logger in sorted(root.manager.loggerDict.items()):\n        if \".\" in name:\n            parent_name = \".\".join(name.split(\".\")[:-1])\n            parent = cache[parent_name]\n        else:\n            parent = tree\n\n        cache[name] = make_logger_node(name, logger, parent)\n    return tree"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\niterating over the parsed values of a field.", "response": "def iter_parsed_values(self, field: Field) -> Iterable[Tuple[str, Any]]:\n        \"\"\"\n        Walk the dictionary of parsers and emit all non-null values.\n\n        \"\"\"\n        for key, func in self.parsers.items():\n            value = func(field)\n            if not value:\n                continue\n            yield key, value"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds the path leading up to this namespace.", "response": "def path(self):\n        \"\"\"\n        Build the path (prefix) leading up to this namespace.\n\n        \"\"\"\n        return \"/\".join([\n            part\n            for part in [\n                self.version,\n                self.qualifier,\n            ]\n            if part\n        ])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new namespace for the current object value.", "response": "def object_ns(self):\n        \"\"\"\n        Create a new namespace for the current namespace's object value.\n\n        \"\"\"\n        return Namespace(\n            subject=self.object_,\n            object_=None,\n            prefix=self.prefix,\n            qualifier=self.qualifier,\n            version=self.version,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a unique endpoint name from an operation and a namespace.", "response": "def endpoint_for(self, operation):\n        \"\"\"\n        Create a (unique) endpoint name from an operation and a namespace.\n\n        This naming convention matches how Flask blueprints routes are resolved\n        (assuming that the blueprint and resources share the same name).\n\n        Examples: `foo.search`, `bar.search_for.baz`\n\n        \"\"\"\n        return operation.value.pattern.format(\n            subject=self.subject_name,\n            operation=operation.value.name,\n            object_=self.object_name if self.object_ else None,\n            version=self.version or \"v1\",\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert an endpoint name into an operation and ns tuple.", "response": "def parse_endpoint(endpoint, identifier_type=None):\n        \"\"\"\n        Convert an endpoint name into an (operation, ns) tuple.\n\n        \"\"\"\n        # compute the operation\n        parts = endpoint.split(\".\")\n        operation = Operation.from_name(parts[1])\n\n        # extract its parts\n        matcher = match(operation.endpoint_pattern, endpoint)\n        if not matcher:\n            raise InternalServerError(\"Malformed operation endpoint: {}\".format(endpoint))\n        kwargs = matcher.groupdict()\n        del kwargs[\"operation\"]\n        if identifier_type is not None:\n            kwargs[\"identifier_type\"] = identifier_type\n        return operation, Namespace(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef url_for(self, operation, _external=True, **kwargs):\n        return url_for(self.endpoint_for(operation), _external=_external, **kwargs)", "response": "Construct a URL for an operation against a resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs an href for an operation against a resource.", "response": "def href_for(self, operation, qs=None, **kwargs):\n        \"\"\"\n        Construct an full href for an operation against a resource.\n\n        :parm qs: the query string dictionary, if any\n        :param kwargs: additional arguments for path expansion\n\n        \"\"\"\n        url = urljoin(request.url_root, self.url_for(operation, **kwargs))\n        qs_character = \"?\" if url.find(\"?\") == -1 else \"&\"\n\n        return \"{}{}\".format(\n            url,\n            \"{}{}\".format(qs_character, urlencode(qs)) if qs else \"\",\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild a singleton endpoint that provides swagger definitions for all operations.", "response": "def configure_swagger(graph):\n    \"\"\"\n    Build a singleton endpoint that provides swagger definitions for all operations.\n\n    \"\"\"\n    ns = Namespace(\n        subject=graph.config.swagger_convention.name,\n        version=graph.config.swagger_convention.version,\n    )\n    convention = SwaggerConvention(graph)\n    convention.configure(ns, discover=tuple())\n    return ns.subject"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind all matching endpoints that are in the current swagger namespace.", "response": "def find_matching_endpoints(self, swagger_ns):\n        \"\"\"\n        Compute current matching endpoints.\n\n        Evaluated as a property to defer evaluation.\n\n        \"\"\"\n        def match_func(operation, ns, rule):\n            # only expose endpoints that have the correct path prefix and operation\n            return (\n                rule.rule.startswith(self.graph.build_route_path(swagger_ns.path, swagger_ns.prefix)) and\n                operation in self.matching_operations\n            )\n\n        return list(iter_endpoints(self.graph, match_func))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef configure_discover(self, ns, definition):\n        @self.add_route(ns.singleton_path, Operation.Discover, ns)\n        def discover():\n            swagger = build_swagger(self.graph, ns, self.find_matching_endpoints(ns))\n            g.hide_body = True\n            return make_response(swagger)", "response": "Register a swagger endpoint for a set of operations."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the child item type for list fields.", "response": "def parse_items(self, field: Field) -> Mapping[str, Any]:\n        \"\"\"\n        Parse the child item type for list fields, if any.\n\n        \"\"\"\n        return self.build_parameter(field.container)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a link to an operation on a resource object.", "response": "def for_(cls, operation, ns, qs=None, type=None, allow_templates=False, **kwargs):\n        \"\"\"\n        Create a link to an operation on a resource object.\n\n        Supports link templating if enabled by making a best guess as to the URI\n        template construction.\n\n        See also [RFC 6570]( https://tools.ietf.org/html/rfc6570).\n\n        :param operation: the operation\n        :param ns: the namespace\n        :param qs: an optional query string (e.g. for paging)\n        :param type: an optional link type\n        :param allow_templates: whether generated links are allowed to contain templates\n        :param kwargs: optional endpoint expansion arguments (e.g. for URI parameters)\n        :raises BuildError: if link templating is needed and disallowed\n        \"\"\"\n        assert isinstance(ns, Namespace)\n        try:\n            href, templated = ns.href_for(operation, qs=qs, **kwargs), False\n        except BuildError as error:\n            if not allow_templates:\n                raise\n            uri_templates = {\n                argument: \"{{{}}}\".format(argument)\n                for argument in error.suggested.arguments\n            }\n            kwargs.update(uri_templates)\n            href, templated = ns.href_for(operation, qs=qs, **kwargs), True\n\n        return cls(\n            href=href,\n            type=type,\n            templated=templated,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef use_forwarded_port(graph):\n    # There must be a better way!\n    context = _request_ctx_stack.top\n\n    if _request_ctx_stack is None:\n        return None\n\n    # determine the configured overrides\n    forwarded_host = graph.config.port_forwarding.get(\"host\")\n    forwarded_port = request.headers.get(\"X-Forwarded-Port\")\n\n    if not forwarded_port and not forwarded_host:\n        return None\n\n    # determine the current server name\n    if \":\" in context.url_adapter.server_name:\n        server_host, server_port = context.url_adapter.server_name.split(\":\", 1)\n    else:\n        server_host = context.url_adapter.server_name\n        server_port = 443 if context.url_adapter.url_scheme == \"https\" else 80\n\n    # choose a new server name\n    if forwarded_host:\n        server_name = forwarded_host\n    elif server_port:\n        server_name = \"{}:{}\".format(server_host, forwarded_port)\n    else:\n        server_name = \"{}:{}\".format(server_host, server_port)\n\n    context.url_adapter.server_name = server_name\n    return server_name", "response": "Returns the server name that is used by url_for to build a URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef format(self, response_data):\n        if \"items\" in response_data:\n            list_response_data = response_data[\"items\"]\n        else:\n            list_response_data = [response_data]\n\n        write_column_names = type(list_response_data[0]) not in (tuple, list)\n\n        output = StringIO()\n        csv_writer = writer(output, quoting=QUOTE_MINIMAL)\n\n        if write_column_names:\n            column_names = self.get_column_names(list_response_data)\n            csv_writer.writerow(column_names)\n\n        for item in list_response_data:\n            csv_writer.writerow(\n                [item[column] for column in column_names] if write_column_names else list(item)\n            )\n\n        # Ideally we'd want to `yield` each line to stream the content\n        # But something downstream seems to break streaming\n        yield output.getvalue()", "response": "Format the response data as a CSV file"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef build_schema(schema: Schema) -> Mapping[str, Any]:\n    builder = Schemas(build_parameter=build_parameter)\n    return builder.build(schema)", "response": "Build a JSON schema from a marshmallow schema."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iter_schemas(schema: Schema) -> Iterable[Tuple[str, Any]]:\n    builder = Schemas(build_parameter=build_parameter)\n    return builder.iter_schemas(schema)", "response": "Iterate over all JSON schemas in a marshmallow schema."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build_parameter(field: Field) -> Mapping[str, Any]:\n    builder = Parameters()\n    return builder.build(field)", "response": "Build a JSON parameter from a marshmallow field."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nregistering a saved search endpoint.", "response": "def configure_savedsearch(self, ns, definition):\n        \"\"\"\n        Register a saved search endpoint.\n\n        The definition's func should be a search function, which must:\n        - accept kwargs for the request data\n        - return a tuple of (items, count) where count is the total number of items\n          available (in the case of pagination)\n\n        The definition's request_schema will be used to process query string arguments.\n\n        :param ns: the namespace\n        :param definition: the endpoint definition\n\n        \"\"\"\n        paginated_list_schema = self.page_cls.make_paginated_list_schema_class(\n            ns,\n            definition.response_schema,\n        )()\n\n        @self.add_route(ns.collection_path, Operation.SavedSearch, ns)\n        @request(definition.request_schema)\n        @response(paginated_list_schema)\n        @wraps(definition.func)\n        def saved_search(**path_data):\n            request_data = load_request_data(definition.request_schema)\n            page = self.page_cls.from_dict(request_data)\n            request_data.update(page.to_dict(func=identity))\n            result = definition.func(**merge_data(path_data, request_data))\n            response_data, headers = page.to_paginated_list(result, ns, Operation.SavedSearch)\n            definition.header_func(headers, response_data)\n            response_format = self.negotiate_response_content(definition.response_formats)\n            return dump_response_data(\n                paginated_list_schema,\n                response_data,\n                headers=headers,\n                response_format=response_format,\n            )\n\n        saved_search.__doc__ = \"Persist and return the search results of {}\".format(pluralize(ns.subject_name))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhiding a set of request and/or response fields from logs. Example: @hide(\"id\") def create_foo(): return Foo(id=uuid4())", "response": "def hide(*keys):\n    \"\"\"\n    Hide a set of request and/or response fields from logs.\n\n    Example:\n\n        @hide(\"id\")\n        def create_foo():\n            return Foo(id=uuid4())\n\n    \"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            g.hide_request_fields = keys\n            g.hide_response_fields = keys\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_as(**mappings):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            g.show_request_fields = mappings\n            g.show_response_fields = mappings\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator", "response": "Decorator that creates a new object and sets the show_request_fields and show_response_fields attributes of the logs using a different key."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encode_basic_auth(username, password):\n    return \"Basic {}\".format(\n        b64encode(\n            \"{}:{}\".format(\n                username,\n                password,\n            ).encode(\"utf-8\")\n        ).decode(\"utf-8\")\n    )", "response": "Encode basic auth credentials."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconfigures a basic auth decorator.", "response": "def configure_basic_auth_decorator(graph):\n    \"\"\"\n    Configure a basic auth decorator.\n\n    \"\"\"\n    # use the metadata name if no realm is defined\n    graph.config.setdefault(\"BASIC_AUTH_REALM\", graph.metadata.name)\n    return ConfigBasicAuth(\n        app=graph.flask,\n        # wrap in dict to allow lists of items as well as dictionaries\n        credentials=dict(graph.config.basic_auth.credentials),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_credentials(self, username, password):\n        return password is not None and self.credentials.get(username, None) == password", "response": "Check if username and password are valid."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef challenge(self):\n        response = super(ConfigBasicAuth, self).challenge()\n        raise with_headers(Unauthorized(), response.headers)", "response": "Override challenge to raise an exception that will trigger regular error handling."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding JSON schema from a marshmallow schema.", "response": "def build(self, schema: Schema) -> Mapping[str, Any]:\n        \"\"\"\n        Build JSON schema from a marshmallow schema.\n\n        \"\"\"\n        fields = list(self.iter_fields(schema))\n\n        properties = {\n            field.name: self.build_parameter(field)\n            for name, field in fields\n        }\n\n        result = dict(\n            type=\"object\",\n            properties=properties,\n        )\n\n        required_fields = [\n            name\n            for name, field in fields\n            if field.required and not field.allow_none\n        ]\n\n        if required_fields:\n            result[\"required\"] = required_fields\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef iter_fields(self, schema: Schema) -> Iterable[Tuple[str, Field]]:\n        for name in sorted(schema.fields.keys()):\n            field = schema.fields[name]\n            yield field.dump_to or name, field", "response": "Iterate through marshmallow schema fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iter_schemas(self, schema: Schema) -> Iterable[Tuple[str, Any]]:\n        if not schema:\n            return\n\n        yield self.to_tuple(schema)\n\n        for name, field in self.iter_fields(schema):\n            if isinstance(field, Nested):\n                yield self.to_tuple(field.schema)\n                yield from self.iter_schemas(field.schema)\n\n            if isinstance(field, List) and isinstance(field.container, Nested):\n                yield self.to_tuple(field.container.schema)\n                yield from self.iter_schemas(field.container.schema)", "response": "Iterate over all schema names and values in a marshmallow schema."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef links(self):\n        links = Links()\n        links[\"self\"] = Link.for_(\n            self._operation,\n            self._ns,\n            qs=self._page.to_items(),\n            **self._context\n        )\n        return links", "response": "Return a list of links for this instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef links(self):\n        links = super(OffsetLimitPaginatedList, self).links\n        if self._page.offset + self._page.limit < self.count:\n            links[\"next\"] = Link.for_(\n                self._operation,\n                self._ns,\n                qs=self._page.next_page.to_items(),\n                **self._context\n            )\n        if self.offset > 0:\n            links[\"prev\"] = Link.for_(\n                self._operation,\n                self._ns,\n                qs=self._page.prev_page.to_items(),\n                **self._context\n            )\n        return links", "response": "Returns a list of links that are included in the current page."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_items(self, func=str):\n        return [\n            (key, func(self.kwargs[key]))\n            for key in sorted(self.kwargs.keys())\n        ]", "response": "Converts the dictionary to a list of items."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_paginated_list(self, result, _ns, _operation, **kwargs):\n        items, context = self.parse_result(result)\n        headers = dict()\n        paginated_list = PaginatedList(\n            items=items,\n            _page=self,\n            _ns=_ns,\n            _operation=_operation,\n            _context=context,\n        )\n        return paginated_list, headers", "response": "Convert a controller result to a paginated list."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses a simple items result.", "response": "def parse_result(cls, result):\n        \"\"\"\n        Parse a simple items result.\n\n        May either be two item tuple containing items and a context dictionary (see: relation convention)\n        or a list of items.\n\n        \"\"\"\n        if isinstance(result, tuple) == 2:\n            items, context = result\n        else:\n            context = {}\n            items = result\n        return items, context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract a page from the current query string.", "response": "def from_query_string(cls, schema, qs=None):\n        \"\"\"\n        Extract a page from the current query string.\n\n        :param qs: a query string dictionary (`request.args` will be used if omitted)\n\n        \"\"\"\n        dct = load_query_string_data(schema, qs)\n        return cls.from_dict(dct)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate a schema class that represents a paginted list of items.", "response": "def make_paginated_list_schema_class(cls, ns, item_schema):\n        \"\"\"\n        Generate a schema class that represents a paginted list of items.\n\n        \"\"\"\n        class PaginatedListSchema(Schema):\n            __alias__ = \"{}_list\".format(ns.subject_name)\n            items = fields.List(fields.Nested(item_schema), required=True)\n            _links = fields.Raw()\n\n        return PaginatedListSchema"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_result(cls, result):\n        if len(result) == 3:\n            items, count, context = result\n        else:\n            context = {}\n            items, count = result\n        return items, count, context", "response": "Parse an items + count tuple result."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts an operation obj pair into a swagger verb name.", "response": "def operation_name(operation, ns):\n    \"\"\"\n    Convert an operation, obj(s) pair into a swagger operation id.\n\n    For compatability with Bravado, we want to use underscores instead of dots and\n    verb-friendly names. Example:\n\n        foo.retrieve       => client.foo.retrieve()\n        foo.search_for.bar => client.foo.search_for_bars()\n\n    \"\"\"\n    verb = operation.value.name\n    if ns.object_:\n        return \"{}_{}\".format(verb, pluralize(ns.object_name))\n    else:\n        return verb"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nnormalize a URI and return a URIResult", "response": "def normalize_uri_result(uri):\n    \"\"\"\n    Normalize a URI (And return a URIResult)\n\n    \"\"\"\n    ref = uri_reference(uri).normalize()\n\n    return ref._replace(\n        authority=normalize_uri_authority(ref),\n        query=normalize_uri_query(ref),\n        path=normalize_uri_path(ref),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a name for something.", "response": "def name_for(obj):\n    \"\"\"\n    Get a name for something.\n\n    Allows overriding of default names using the `__alias__` attribute.\n\n    \"\"\"\n    if isinstance(obj, str):\n        return obj\n\n    cls = obj if isclass(obj) else obj.__class__\n\n    if hasattr(cls, \"__alias__\"):\n        return underscore(cls.__alias__)\n    else:\n        return underscore(cls.__name__)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef instance_path_for(name, identifier_type, identifier_key=None):\n    return \"/{}/<{}:{}>\".format(\n        name_for(name),\n        identifier_type,\n        identifier_key or \"{}_id\".format(name_for(name)),\n    )", "response": "Get a path for a thing."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a path relating a thing to another.", "response": "def relation_path_for(from_name, to_name, identifier_type, identifier_key=None):\n    \"\"\"\n    Get a path relating a thing to another.\n\n    \"\"\"\n    return \"/{}/<{}:{}>/{}\".format(\n        name_for(from_name),\n        identifier_type,\n        identifier_key or \"{}_id\".format(name_for(from_name)),\n        name_for(to_name),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef configure_flask(graph):\n    app = Flask(graph.metadata.import_name)\n    app.debug = graph.metadata.debug\n    app.testing = graph.metadata.testing\n\n    # copy in the graph's configuration for non-nested keys\n    app.config.update({\n        key: value\n        for key, value in graph.config.items()\n        if not isinstance(value, dict)\n    })\n\n    return app", "response": "Create a Flask instance bound to the Flask key."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef configure_alias(graph, ns, mappings):\n    convention = AliasConvention(graph)\n    convention.configure(ns, mappings)", "response": "Register Alias endpoints for a resource object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nregistering an alias endpoint which will redirect to a resource s retrieve endpoint.", "response": "def configure_alias(self, ns, definition):\n        \"\"\"\n        Register an alias endpoint which will redirect to a resource's retrieve endpoint.\n\n        Note that the retrieve endpoint MUST be registered prior to the alias endpoint.\n\n        The definition's func should be a retrieve function, which must:\n        - accept kwargs for path data\n        - return a resource\n\n        :param ns: the namespace\n        :param definition: the endpoint definition\n\n        \"\"\"\n        @self.add_route(ns.alias_path, Operation.Alias, ns)\n        @qs(definition.request_schema)\n        @wraps(definition.func)\n        def retrieve(**path_data):\n            # request_schema is optional for Alias\n            request_data = (\n                load_query_string_data(definition.request_schema)\n                if definition.request_schema\n                else dict()\n            )\n            resource = definition.func(**merge_data(path_data, request_data))\n\n            kwargs = dict()\n            identifier = \"{}_id\".format(name_for(ns.subject))\n            kwargs[identifier] = resource.id\n            url = ns.url_for(Operation.Retrieve, **kwargs)\n\n            return redirect(url)\n\n        retrieve.__doc__ = \"Alias a {} by name\".format(ns.subject_name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a header for a newly created resource.", "response": "def encode_id_header(resource):\n    \"\"\"\n    Generate a header for a newly created resource.\n\n    Assume `id` attribute convention.\n\n    \"\"\"\n    if not hasattr(resource, \"id\"):\n        return {}\n\n    return {\n        \"X-{}-Id\".format(\n            camelize(name_for(resource))\n        ): str(resource.id),\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading request data as JSON using the given schema.", "response": "def load_request_data(request_schema, partial=False):\n    \"\"\"\n    Load request data as JSON using the given schema.\n\n    Forces JSON decoding even if the client not specify the `Content-Type` header properly.\n\n    This is friendlier to client and test software, even at the cost of not distinguishing\n    HTTP 400 and 415 errors.\n\n    \"\"\"\n    try:\n        json_data = request.get_json(force=True) or {}\n    except Exception:\n        # if `simplpejson` is installed, simplejson.scanner.JSONDecodeError will be raised\n        # on malformed JSON, where as built-in `json` returns None\n        json_data = {}\n    request_data = request_schema.load(json_data, partial=partial)\n    if request_data.errors:\n        # pass the validation errors back in the context\n        raise with_context(\n            UnprocessableEntity(\"Validation error\"), [{\n                \"message\": \"Could not validate field: {}\".format(field),\n                \"field\": field,\n                \"reasons\": reasons\n            } for field, reasons in request_data.errors.items()],\n        )\n    return request_data.data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_query_string_data(request_schema, query_string_data=None):\n    if query_string_data is None:\n        query_string_data = request.args\n\n    request_data = request_schema.load(query_string_data)\n    if request_data.errors:\n        # pass the validation errors back in the context\n        raise with_context(UnprocessableEntity(\"Validation error\"), dict(errors=request_data.errors))\n    return request_data.data", "response": "Load query string data using the given schema."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dump_response_data(response_schema,\n                       response_data,\n                       status_code=200,\n                       headers=None,\n                       response_format=None):\n    \"\"\"\n    Dumps response data as JSON using the given schema.\n\n    Forces JSON encoding even if the client did not specify the `Accept` header properly.\n\n    This is friendlier to client and test software, even at the cost of not distinguishing\n    HTTP 400 and 406 errors.\n\n    \"\"\"\n    if response_schema:\n        response_data = response_schema.dump(response_data).data\n\n    return make_response(response_data, response_schema, response_format, status_code, headers)", "response": "Dumps response data as JSON using the given schema."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef merge_data(path_data, request_data):\n    merged = request_data.copy() if request_data else {}\n    merged.update(path_data or {})\n    return merged", "response": "Merge data from the URI path and the request."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_response_format(allowed_response_formats):\n    # allowed formats default to [] before this\n    if not allowed_response_formats:\n        allowed_response_formats = [ResponseFormats.JSON]\n\n    content_type = request.headers.get(\"Accept\")\n    if content_type is None:\n        # Nothing specified, default to endpoint definition\n        if allowed_response_formats:\n            return allowed_response_formats[0]\n        # Finally, default to JSON\n        return ResponseFormats.JSON\n\n    for response_format in ResponseFormats.prioritized():\n        if response_format not in allowed_response_formats:\n            continue\n        if response_format.matches(content_type):\n            return response_format\n\n    # fallback for previous behavior\n    return ResponseFormats.JSON", "response": "Find the most appropriate response format for the current request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_swagger(graph, ns, operations):\n    base_path = graph.build_route_path(ns.path, ns.prefix)\n    schema = swagger.Swagger(\n        swagger=\"2.0\",\n        info=swagger.Info(\n            title=graph.metadata.name,\n            version=ns.version,\n        ),\n        consumes=swagger.MediaTypeList([\n            swagger.MimeType(\"application/json\"),\n        ]),\n        produces=swagger.MediaTypeList([\n            swagger.MimeType(\"application/json\"),\n        ]),\n        basePath=base_path,\n        paths=swagger.Paths(),\n        definitions=swagger.Definitions(),\n    )\n    add_paths(schema.paths, base_path, operations)\n    add_definitions(schema.definitions, operations)\n    try:\n        schema.validate()\n    except Exception:\n        logger.exception(\"Swagger definition did not validate against swagger schema\")\n        raise\n\n    return schema", "response": "Builds out the top - level swagger definition."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd paths to swagger.", "response": "def add_paths(paths, base_path, operations):\n    \"\"\"\n    Add paths to swagger.\n\n    \"\"\"\n    for operation, ns, rule, func in operations:\n        path = build_path(operation, ns)\n        if not path.startswith(base_path):\n            continue\n        method = operation.value.method.lower()\n        # If there is no version number or prefix, we'd expect the base path to be \"\"\n        # However, OpenAPI requires the minimal base path to be \"/\"\n        # This means we need branching logic for that special case\n        suffix_start = 0 if len(base_path) == 1 else len(base_path)\n        paths.setdefault(\n            path[suffix_start:],\n            swagger.PathItem(),\n        )[method] = build_operation(operation, ns, rule, func)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_definitions(definitions, operations):\n    for definition_schema in iter_definitions(definitions, operations):\n        if definition_schema is None:\n            continue\n        if isinstance(definition_schema, str):\n            continue\n\n        for name, schema in iter_schemas(definition_schema):\n            definitions.setdefault(name, swagger.Schema(schema))", "response": "Add definitions to swagger."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate definitions to be converted to swagger schema.", "response": "def iter_definitions(definitions, operations):\n    \"\"\"\n    Generate definitions to be converted to swagger schema.\n\n    \"\"\"\n    # general error schema per errors.py\n    for error_schema_class in [ErrorSchema, ErrorContextSchema, SubErrorSchema]:\n        yield error_schema_class()\n\n    # add all request and response schemas\n    for operation, obj, rule, func in operations:\n        yield get_request_schema(func)\n        yield get_response_schema(func)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build_path(operation, ns):\n    try:\n        return ns.url_for(operation, _external=False)\n    except BuildError as error:\n        # we are missing some URI path parameters\n        uri_templates = {\n            argument: \"{{{}}}\".format(argument)\n            for argument in error.suggested.arguments\n        }\n        # flask will sometimes try to quote '{' and '}' characters\n        return unquote(ns.url_for(operation, _external=False, **uri_templates))", "response": "Build a path URI for an operation."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef header_param(name, required=False, param_type=\"string\"):\n    return swagger.HeaderParameterSubSchema(**{\n        \"name\": name,\n        \"in\": \"header\",\n        \"required\": required,\n        \"type\": param_type,\n    })", "response": "Build a header parameter definition."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding a query parameter definition.", "response": "def query_param(name, field, required=False):\n    \"\"\"\n    Build a query parameter definition.\n\n    \"\"\"\n    parameter = build_parameter(field)\n    parameter[\"name\"] = name\n    parameter[\"in\"] = \"query\"\n    parameter[\"required\"] = False\n\n    return swagger.QueryParameterSubSchema(**parameter)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding a path parameter definition.", "response": "def path_param(name, ns):\n    \"\"\"\n    Build a path parameter definition.\n\n    \"\"\"\n    if ns.identifier_type == \"uuid\":\n        param_type = \"string\"\n        param_format = \"uuid\"\n    else:\n        param_type = \"string\"\n        param_format = None\n\n    kwargs = {\n        \"name\": name,\n        \"in\": \"path\",\n        \"required\": True,\n        \"type\": param_type,\n    }\n    if param_format:\n        kwargs[\"format\"] = param_format\n    return swagger.PathParameterSubSchema(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_operation(operation, ns, rule, func):\n    swagger_operation = swagger.Operation(\n        operationId=operation_name(operation, ns),\n        parameters=swagger.ParametersList([\n        ]),\n        responses=swagger.Responses(),\n        tags=[ns.subject_name],\n    )\n\n    # custom header parameter\n    swagger_operation.parameters.append(\n        header_param(\"X-Response-Skip-Null\")\n    )\n\n    # path parameters\n    swagger_operation.parameters.extend([\n        path_param(argument, ns)\n        for argument in rule.arguments\n    ])\n\n    # query string parameters\n    qs_schema = get_qs_schema(func)\n    if qs_schema:\n        swagger_operation.parameters.extend([\n            query_param(name, field)\n            for name, field in qs_schema.fields.items()\n        ])\n\n    # body parameter\n    request_schema = get_request_schema(func)\n    if request_schema:\n        swagger_operation.parameters.append(\n            body_param(request_schema)\n        )\n\n    # sort parameters for predictable output\n    swagger_operation.parameters.sort(key=lambda parameter: parameter[\"name\"])\n\n    add_responses(swagger_operation, operation, ns, func)\n    return swagger_operation", "response": "Builds an operation definition."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_responses(swagger_operation, operation, ns, func):\n    # default error\n    swagger_operation.responses[\"default\"] = build_response(\n        description=\"An error occurred\",\n        resource=type_name(name_for(ErrorSchema())),\n    )\n\n    if getattr(func, \"__doc__\", None):\n        description = func.__doc__.strip().splitlines()[0]\n    else:\n        description = \"{} {}\".format(operation.value.name, ns.subject_name)\n\n    if operation in (Operation.Upload, Operation.UploadFor):\n        swagger_operation.consumes = [\n            \"multipart/form-data\"\n        ]\n\n    # resource request\n    request_resource = get_request_schema(func)\n    if isinstance(request_resource, str):\n        if not hasattr(swagger_operation, \"consumes\"):\n            swagger_operation.consumes = []\n        swagger_operation.consumes.append(request_resource)\n\n    # resources response\n    response_resource = get_response_schema(func)\n    if isinstance(response_resource, str):\n        if not hasattr(swagger_operation, \"produces\"):\n            swagger_operation.produces = []\n        swagger_operation.produces.append(response_resource)\n    elif not response_resource:\n        response_code = (\n            204\n            if operation.value.default_code == 200\n            else operation.value.default_code\n        )\n        swagger_operation.responses[str(response_code)] = build_response(\n            description=description,\n        )\n    else:\n        swagger_operation.responses[str(operation.value.default_code)] = build_response(\n            description=description,\n            resource=response_resource,\n        )", "response": "Add responses to an operation."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild a response definition.", "response": "def build_response(description, resource=None):\n    \"\"\"\n    Build a response definition.\n\n    \"\"\"\n    response = swagger.Response(\n        description=description,\n    )\n    if resource is not None:\n        response.schema = swagger.JsonReference({\n            \"$ref\": \"#/definitions/{}\".format(type_name(name_for(resource))),\n        })\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\niterates through matching endpoints.", "response": "def iter_endpoints(graph, match_func):\n    \"\"\"\n    Iterate through matching endpoints.\n\n    The `match_func` is expected to have a signature of:\n\n        def matches(operation, ns, rule):\n            return True\n\n    :returns: a generator over (`Operation`, `Namespace`, rule, func) tuples.\n\n    \"\"\"\n    for rule in graph.flask.url_map.iter_rules():\n        try:\n            operation, ns = Namespace.parse_endpoint(rule.endpoint, get_converter(rule))\n        except (IndexError, ValueError, InternalServerError):\n            # operation follows a different convention (e.g. \"static\")\n            continue\n        else:\n            # match_func gets access to rule to support path version filtering\n            if match_func(operation, ns, rule):\n                func = graph.flask.view_functions[rule.endpoint]\n                yield operation, ns, rule, func"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the converter for the given rule", "response": "def get_converter(rule):\n    \"\"\"\n    Parse rule will extract the converter from the rule as a generator\n\n    We iterate through the parse_rule results to find the converter\n    parse_url returns the static rule part in the first iteration\n    parse_url returns the dynamic rule part in the second iteration if its dynamic\n\n    \"\"\"\n    for converter, _, _ in parse_rule(str(rule)):\n        if converter is not None:\n            return converter\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef request(schema):\n    def wrapper(func):\n        setattr(func, REQUEST, schema)\n        return func\n    return wrapper", "response": "Decorator to set a function s REQUEST attribute to the given schema."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndecorate a function with a response schema.", "response": "def response(schema):\n    \"\"\"\n    Decorate a function with a response schema.\n\n    \"\"\"\n    def wrapper(func):\n        setattr(func, RESPONSE, schema)\n        return func\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndecorates a function with a query string schema.", "response": "def qs(schema):\n    \"\"\"\n    Decorate a function with a query string schema.\n\n    \"\"\"\n    def wrapper(func):\n        setattr(func, QS, schema)\n        return func\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nregister a session factory function so that a new session will be saved to the database tiers.", "response": "def register_session_factory(graph, key, session_factory):\n    \"\"\"\n    Register a session creation function so that a new session (of user-defined type)\n    will be saved to `flask.g` on every request (and closed on teardown).\n\n    In other words: this os a mechanism to register a SQLAlchemy session instance\n    or similar without coupling the web and database tiers directly.\n\n    The session function should have the signature:\n\n        def session_factory(graph):\n            return Session()\n\n    If the session instance is closeable, it will be closed on teardown.\n\n    \"\"\"\n    @graph.flask.before_request\n    def begin_session():\n        setattr(g, key, session_factory(graph))\n\n    @graph.flask.teardown_request\n    def end_session(*args, **kwargs):\n        # NB: session will be none if there's an error raised in `before_request`\n        session = getattr(g, key, None)\n        if session is not None and hasattr(session, \"close\"):\n            session.close()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef should_skip_logging(func):\n    disabled = strtobool(request.headers.get(\"x-request-nolog\", \"false\"))\n    return disabled or getattr(func, SKIP_LOGGING, False)", "response": "Returns True if the handler should skip logging."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef audit(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        options = AuditOptions(\n            include_request_body=DEFAULT_INCLUDE_REQUEST_BODY,\n            include_response_body=DEFAULT_INCLUDE_RESPONSE_BODY,\n            include_path=True,\n            include_query_string=True,\n        )\n        with logging_levels():\n            return _audit_request(options, func, None, *args, **kwargs)\n\n    return wrapper", "response": "A decorator that creates a JSON record for every request."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning a request function under audit.", "response": "def _audit_request(options, func, request_context, *args, **kwargs):  # noqa: C901\n    \"\"\"\n    Run a request function under audit.\n\n    \"\"\"\n    logger = getLogger(\"audit\")\n\n    request_info = RequestInfo(options, func, request_context)\n    response = None\n\n    request_info.capture_request()\n    try:\n        # process the request\n        with elapsed_time(request_info.timing):\n            response = func(*args, **kwargs)\n    except Exception as error:\n        request_info.capture_error(error)\n        raise\n    else:\n        request_info.capture_response(response)\n        return response\n    finally:\n        if not should_skip_logging(func):\n            request_info.log(logger)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_response(response):\n    if isinstance(response, tuple):\n        if len(response) > 2:\n            return response[0], response[1], response[2]\n        elif len(response) > 1:\n            return response[0], response[1], {}\n    try:\n        return response.data, response.status_code, response.headers\n    except AttributeError:\n        return response, 200, {}", "response": "Parse a Flask response into a body a status code and headers"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconfigure the audit decorator.", "response": "def configure_audit_decorator(graph):\n    \"\"\"\n    Configure the audit decorator.\n\n    Example Usage:\n\n        @graph.audit\n        def login(username, password):\n            ...\n    \"\"\"\n    include_request_body = int(graph.config.audit.include_request_body)\n    include_response_body = int(graph.config.audit.include_response_body)\n    include_path = strtobool(graph.config.audit.include_path)\n    include_query_string = strtobool(graph.config.audit.include_query_string)\n\n    def _audit(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            options = AuditOptions(\n                include_request_body=include_request_body,\n                include_response_body=include_response_body,\n                include_path=include_path,\n                include_query_string=include_query_string,\n            )\n            return _audit_request(options, func, graph.request_context, *args, **kwargs)\n        return wrapper\n    return _audit"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef post_process_response_headers(self, dct):\n        if not self.response_headers:\n            return\n\n        for key, value in self.response_headers.items():\n            parts = key.split(\"-\")\n            if len(parts) != 3:\n                continue\n            if parts[0] != \"X\":\n                continue\n            if parts[-1] != \"Id\":\n                continue\n\n            dct[\"{}_id\".format(underscore(parts[1]))] = value", "response": "Rewrite X -<> - Id header into audit logs."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef configure_route_decorator(graph):\n    enable_audit = graph.config.route.enable_audit\n    enable_basic_auth = graph.config.route.enable_basic_auth\n    enable_context_logger = graph.config.route.enable_context_logger\n    enable_cors = graph.config.route.enable_cors\n\n    # routes depends on converters\n    graph.use(*graph.config.route.converters)\n\n    def route(path, operation, ns):\n        \"\"\"\n        :param path: a URI path, possibly derived from a property of the `ns`\n        :param operation: an `Operation` enum value\n        :param ns: a `Namespace` instance\n\n        \"\"\"\n        def decorator(func):\n            endpoint = ns.endpoint_for(operation)\n            endpoint_path = graph.build_route_path(path, ns.prefix)\n\n            if enable_cors:\n                func = cross_origin(supports_credentials=True)(func)\n\n            if enable_basic_auth or ns.enable_basic_auth:\n                func = graph.basic_auth.required(func)\n\n            if enable_context_logger and ns.controller is not None:\n                func = context_logger(\n                    graph.request_context,\n                    func,\n                    parent=ns.controller,\n                )\n\n            # set the opaque component data_func to look at the flask request context\n            func = graph.opaque.initialize(graph.request_context)(func)\n\n            if graph.route_metrics.enabled:\n                func = graph.route_metrics(endpoint)(func)\n\n            # keep audit decoration last (before registering the route) so that\n            # errors raised by other decorators are captured in the audit trail\n            if enable_audit:\n                func = graph.audit(func)\n\n            graph.app.route(\n                endpoint_path,\n                endpoint=endpoint,\n                methods=[operation.value.method],\n            )(func)\n            return func\n        return decorator\n    return route", "response": "Configure a flask route decorator that operates on Operation and Namespace objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef extract_status_code(error):\n    try:\n        return int(error.code)\n    except (AttributeError, TypeError, ValueError):\n        try:\n            return int(error.status_code)\n        except (AttributeError, TypeError, ValueError):\n            try:\n                return int(error.errno)\n            except (AttributeError, TypeError, ValueError):\n                return 500", "response": "Extract an error code from an error message."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nextract a useful message from an error object.", "response": "def extract_error_message(error):\n    \"\"\"\n    Extract a useful message from an error.\n\n    Prefer the description attribute, then the message attribute, then\n    the errors string conversion. In each case, fall back to the error class's\n    name in the event that the attribute value was set to a uselessly empty string.\n\n    \"\"\"\n    try:\n        return error.description or error.__class__.__name__\n    except AttributeError:\n        try:\n            return str(error.message) or error.__class__.__name__\n        except AttributeError:\n            return str(error) or error.__class__.__name__"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_json_error(error):\n    message = extract_error_message(error)\n    status_code = extract_status_code(error)\n    context = extract_context(error)\n    retryable = extract_retryable(error)\n    headers = extract_headers(error)\n\n    # Flask will not log user exception (fortunately), but will log an error\n    # for exceptions that escape out of the application entirely (e.g. if the\n    # error handler raises an error)\n    error_logger.debug(\"Handling {} error: {}\".format(\n        status_code,\n        message,\n    ))\n\n    # Serialize into JSON response\n    response_data = {\n        \"code\": status_code,\n        \"context\": context,\n        \"message\": message,\n        \"retryable\": retryable,\n    }\n    # Don't pass in the error schema because it will suppress any extra fields\n    return dump_response_data(None, response_data, status_code, headers)", "response": "Handle an error by logging and returning a JSON response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _deserialize(self, value, attr, obj):\n        if value is None:\n            return None\n\n        try:\n            attribute_elements = [attr_element.split(\",\") for attr_element in obj.getlist(attr)]\n            attribute_params = [param for attr_param in attribute_elements for param in attr_param]\n\n            return PrintableList(super(QueryStringList, self)._deserialize(attribute_params, attr, obj))\n        except ValueError:\n            raise ValidationError(\"Invalid query string list argument\")", "response": "Deserialize a query string list into a list of values."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate a batch of items in a resource.", "response": "def update_batch(self, **kwargs):\n        \"\"\"\n        Simplistic batch update operation implemented in terms of `replace()`.\n\n        Assumes that:\n\n         - Request and response schemas contains lists of items.\n         - Request items define a primary key identifier\n         - The entire batch succeeds or fails together.\n\n        \"\"\"\n        items = kwargs.pop(\"items\")\n\n        def transform(item):\n            \"\"\"\n            Transform the dictionary expected for replace (which uses the URI path's id)\n            into the resource expected from individual resources (which uses plain id).\n\n            \"\"\"\n            item[self.identifier_key] = item.pop(\"id\")\n            return item\n\n        return dict(\n            items=[\n                self.replace(**transform(item))\n                for item in items\n            ],\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a dictionary for the document with values converted to JSON safe types.", "response": "def to_json_type(self):\n        \"\"\"\n        Return a dictionary for the document with values converted to JSON safe\n        types.\n        \"\"\"\n        document_dict = self._json_safe(self._document)\n        self._remove_keys(document_dict, self._private_fields)\n        return document_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _json_safe(cls, value):\n        # Date\n        if type(value) == date:\n            return str(value)\n\n        # Datetime\n        elif type(value) == datetime:\n            return value.strftime('%Y-%m-%d %H:%M:%S')\n\n        # Object Id\n        elif isinstance(value, ObjectId):\n            return str(value)\n\n        # Frame\n        elif isinstance(value, _BaseFrame):\n            return value.to_json_type()\n\n        # Lists\n        elif isinstance(value, (list, tuple)):\n            return [cls._json_safe(v) for v in value]\n\n        # Dictionaries\n        elif isinstance(value, dict):\n            return {k:cls._json_safe(v) for k, v in value.items()}\n\n        return value", "response": "Return a JSON safe value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _path_to_keys(cls, path):\n\n        # Paths are cached for performance\n        keys = _BaseFrame._path_to_keys_cache.get(path)\n        if keys is None:\n            keys = _BaseFrame._path_to_keys_cache[path] = path.split('.')\n\n        return keys", "response": "Return a list of keys for a given path"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a value from a dictionary at the given path", "response": "def _path_to_value(cls, path, parent_dict):\n        \"\"\"Return a value from a dictionary at the given path\"\"\"\n        keys = cls._path_to_keys(path)\n\n        # Traverse to the tip of the path\n        child_dict = parent_dict\n        for key in keys[:-1]:\n            child_dict = child_dict.get(key)\n            if child_dict is None:\n                return\n\n        return child_dict.get(keys[-1])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _remove_keys(cls, parent_dict, paths):\n\n        for path in paths:\n            keys = cls._path_to_keys(path)\n\n            # Traverse to the tip of the path\n            child_dict = parent_dict\n            for key in keys[:-1]:\n                child_dict = child_dict.get(key)\n\n                if child_dict is None:\n                    break\n\n            if child_dict is None:\n                continue\n\n            # Remove the key\n            if keys[-1] in child_dict:\n                child_dict.pop(keys[-1])", "response": "Remove a list of keys from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef insert(self):\n        from mongoframes.queries import to_refs\n\n        # Send insert signal\n        signal('insert').send(self.__class__, frames=[self])\n\n        # Prepare the document to be inserted\n        document = to_refs(self._document)\n\n        # Insert the document and update the Id\n        self._id = self.get_collection().insert_one(document).inserted_id\n\n        # Send inserted signal\n        signal('inserted').send(self.__class__, frames=[self])", "response": "Insert this document into the database."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate this document. Optionally a specific list of fields to update can be specified.", "response": "def update(self, *fields):\n        \"\"\"\n        Update this document. Optionally a specific list of fields to update can\n        be specified.\n        \"\"\"\n        from mongoframes.queries import to_refs\n\n        assert '_id' in self._document, \"Can't update documents without `_id`\"\n\n        # Send update signal\n        signal('update').send(self.__class__, frames=[self])\n\n        # Check for selective updates\n        if len(fields) > 0:\n            document = {}\n            for field in fields:\n                document[field] = self._path_to_value(field, self._document)\n        else:\n            document = self._document\n\n        # Prepare the document to be updated\n        document = to_refs(document)\n        document.pop('_id', None)\n\n        # Update the document\n        self.get_collection().update_one({'_id': self._id}, {'$set': document})\n\n        # Send updated signal\n        signal('updated').send(self.__class__, frames=[self])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates or insert this document depending on whether it exists or not.", "response": "def upsert(self, *fields):\n        \"\"\"\n        Update or Insert this document depending on whether it exists or not.\n        The presense of an `_id` value in the document is used to determine if\n        the document exists.\n\n        NOTE: This method is not the same as specifying the `upsert` flag when\n        calling MongoDB. When called for a document with an `_id` value, this\n        method will call the database to see if a record with that Id exists,\n        if not it will call `insert`, if so it will call `update`. This\n        operation is therefore not atomic and much slower than the equivalent\n        MongoDB operation (due to the extra call).\n        \"\"\"\n\n        # If no `_id` is provided then we insert the document\n        if not self._id:\n            return self.insert()\n\n        # If an `_id` is provided then we need to check if it exists before\n        # performing the `upsert`.\n        #\n        if self.count({'_id': self._id}) == 0:\n            self.insert()\n        else:\n            self.update(*fields)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninsert a list of documents into the collection.", "response": "def insert_many(cls, documents):\n        \"\"\"Insert a list of documents\"\"\"\n        from mongoframes.queries import to_refs\n\n        # Ensure all documents have been converted to frames\n        frames = cls._ensure_frames(documents)\n\n        # Send insert signal\n        signal('insert').send(cls, frames=frames)\n\n        # Prepare the documents to be inserted\n        documents = [to_refs(f._document) for f in frames]\n\n        # Bulk insert\n        ids = cls.get_collection().insert_many(documents).inserted_ids\n\n        # Apply the Ids to the frames\n        for i, id in enumerate(ids):\n            frames[i]._id = id\n\n        # Send inserted signal\n        signal('inserted').send(cls, frames=frames)\n\n        return frames"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating multiple documents. Optionally a specific list of fields to update can be specified.", "response": "def update_many(cls, documents, *fields):\n        \"\"\"\n        Update multiple documents. Optionally a specific list of fields to\n        update can be specified.\n        \"\"\"\n        from mongoframes.queries import to_refs\n\n        # Ensure all documents have been converted to frames\n        frames = cls._ensure_frames(documents)\n\n        all_count = len(documents)\n        assert len([f for f in frames if '_id' in f._document]) == all_count, \\\n                \"Can't update documents without `_id`s\"\n\n        # Send update signal\n        signal('update').send(cls, frames=frames)\n\n        # Prepare the documents to be updated\n\n        # Check for selective updates\n        if len(fields) > 0:\n            documents = []\n            for frame in frames:\n                document = {'_id': frame._id}\n                for field in fields:\n                    document[field] = cls._path_to_value(\n                        field,\n                        frame._document\n                        )\n                documents.append(to_refs(document))\n        else:\n            documents = [to_refs(f._document) for f in frames]\n\n        # Update the documents\n        for document in documents:\n            _id = document.pop('_id')\n            cls.get_collection().update(\n                {'_id': _id}, {'$set': document})\n\n        # Send updated signal\n        signal('updated').send(cls, frames=frames)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _ensure_frames(cls, documents):\n        frames = []\n        for document in documents:\n            if not isinstance(document, Frame):\n                frames.append(cls(document))\n            else:\n                frames.append(document)\n        return frames", "response": "Ensure all items in a list are frames by converting those that aren t."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreload the document from the database", "response": "def reload(self, **kwargs):\n        \"\"\"Reload the document\"\"\"\n        frame = self.one({'_id': self._id}, **kwargs)\n        self._document = frame._document"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef count(cls, filter=None, **kwargs):\n        from mongoframes.queries import Condition, Group, to_refs\n\n        if isinstance(filter, (Condition, Group)):\n            filter = filter.to_dict()\n\n        return cls.get_collection().count(to_refs(filter), **kwargs)", "response": "Return a count of documents matching the filter"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of Ids for documents matching the filter", "response": "def ids(cls, filter=None, **kwargs):\n        \"\"\"Return a list of Ids for documents matching the filter\"\"\"\n        from mongoframes.queries import Condition, Group, to_refs\n\n        # Find the documents\n        if isinstance(filter, (Condition, Group)):\n            filter = filter.to_dict()\n\n        documents = cls.get_collection().find(\n            to_refs(filter),\n            projection={'_id': True},\n            **kwargs\n            )\n\n        return [d['_id'] for d in list(documents)]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef one(cls, filter=None, **kwargs):\n        from mongoframes.queries import Condition, Group, to_refs\n\n        # Flatten the projection\n        kwargs['projection'], references, subs = \\\n                cls._flatten_projection(\n                    kwargs.get('projection', cls._default_projection)\n                    )\n\n        # Find the document\n        if isinstance(filter, (Condition, Group)):\n            filter = filter.to_dict()\n\n        document = cls.get_collection().find_one(to_refs(filter), **kwargs)\n\n        # Make sure we found a document\n        if not document:\n            return\n\n        # Dereference the document (if required)\n        if references:\n            cls._dereference([document], references)\n\n        # Add sub-frames to the document (if required)\n        if subs:\n            cls._apply_sub_frames([document], subs)\n\n        return cls(document)", "response": "Return the first document matching the filter"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef many(cls, filter=None, **kwargs):\n        from mongoframes.queries import Condition, Group, to_refs\n\n        # Flatten the projection\n        kwargs['projection'], references, subs = \\\n                cls._flatten_projection(\n                    kwargs.get('projection', cls._default_projection)\n                    )\n\n        # Find the documents\n        if isinstance(filter, (Condition, Group)):\n            filter = filter.to_dict()\n\n        documents = list(cls.get_collection().find(to_refs(filter), **kwargs))\n\n        # Dereference the documents (if required)\n        if references:\n            cls._dereference(documents, references)\n\n        # Add sub-frames to the documents (if required)\n        if subs:\n            cls._apply_sub_frames(documents, subs)\n\n        return [cls(d) for d in documents]", "response": "Return a list of documents matching the filter"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _apply_sub_frames(cls, documents, subs):\n\n        # Dereference each reference\n        for path, projection in subs.items():\n\n            # Get the SubFrame class we'll use to wrap the embedded document\n            sub = None\n            expect_map = False\n            if '$sub' in projection:\n                sub = projection.pop('$sub')\n            elif '$sub.' in projection:\n                sub = projection.pop('$sub.')\n                expect_map = True\n            else:\n                continue\n\n            # Add sub-frames to the documents\n            raw_subs = []\n            for document in documents:\n                value = cls._path_to_value(path, document)\n                if value is None:\n                    continue\n\n                if isinstance(value, dict):\n                    if expect_map:\n                        # Dictionary of embedded documents\n                        raw_subs += value.values()\n                        for k, v in value.items():\n                            if isinstance(v ,list):\n                                value[k] = [\n                                    sub(u) for u in v if isinstance(u, dict)]\n                            else:\n                                value[k] = sub(v)\n\n                    # Single embedded document\n                    else:\n                        raw_subs.append(value)\n                        value = sub(value)\n\n                elif isinstance(value, list):\n                    # List of embedded documents\n                    raw_subs += value\n                    value = [sub(v) for v in value if isinstance(v, dict)]\n\n                else:\n                    raise TypeError('Not a supported sub-frame type')\n\n                child_document = document\n                keys = cls._path_to_keys(path)\n                for key in keys[:-1]:\n                    child_document = child_document[key]\n                child_document[keys[-1]] = value\n\n            # Apply the projection to the list of sub frames\n            if projection:\n                sub._apply_projection(raw_subs, projection)", "response": "Convert embedded documents to sub - frames for one or more documents"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _dereference(cls, documents, references):\n\n        # Dereference each reference\n        for path, projection in references.items():\n\n            # Check there is a $ref in the projection, else skip it\n            if '$ref' not in projection:\n                continue\n\n            # Collect Ids of documents to dereference\n            ids = set()\n            for document in documents:\n                value = cls._path_to_value(path, document)\n                if not value:\n                    continue\n\n                if isinstance(value, list):\n                    ids.update(value)\n\n                elif isinstance(value, dict):\n                    ids.update(value.values())\n\n                else:\n                    ids.add(value)\n\n            # Find the referenced documents\n            ref = projection.pop('$ref')\n            frames = ref.many(\n                {'_id': {'$in': list(ids)}},\n                projection=projection\n                )\n            frames = {f._id: f for f in frames}\n\n            # Add dereferenced frames to the document\n            for document in documents:\n                value = cls._path_to_value(path, document)\n                if not value:\n                    continue\n\n                if isinstance(value, list):\n                    # List of references\n                    value = [frames[id] for id in value if id in frames]\n\n                elif isinstance(value, dict):\n                    # Dictionary of references\n                    value = {key: frames.get(id) for key, id in value.items()}\n\n                else:\n                    value = frames.get(value, None)\n\n                child_document = document\n                keys = cls._path_to_keys(path)\n                for key in keys[:-1]:\n                    child_document = child_document[key]\n                child_document[keys[-1]] = value", "response": "Dereference one or more documents"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nflatten a structured projection of the related objects.", "response": "def _flatten_projection(cls, projection):\n        \"\"\"\n        Flatten a structured projection (structure projections support for\n        projections of (to be) dereferenced fields.\n        \"\"\"\n\n        # If `projection` is empty return a full projection based on `_fields`\n        if not projection:\n            return {f: True for f in cls._fields}, {}, {}\n\n        # Flatten the projection\n        flat_projection = {}\n        references = {}\n        subs = {}\n        inclusive = True\n        for key, value in deepcopy(projection).items():\n            if isinstance(value, dict):\n\n                # Build the projection value for the field (allowing for\n                # special mongo directives).\n                project_value = {\n                    k: v for k, v in value.items()\n                    if k.startswith('$') and k not in ['$ref', '$sub', '$sub.']\n                }\n                if len(project_value) == 0:\n                    project_value = True\n                else:\n                    inclusive = False\n\n                # Store a reference/sub-frame projection\n                if '$ref' in value:\n                    references[key] = value\n\n                elif '$sub' in value or '$sub.' in value:\n                    subs[key] = value\n\n                    if '$sub' in value:\n                        sub_frame = value['$sub']\n\n                    if '$sub.' in value:\n                        sub_frame = value['$sub.']\n\n                    project_value = sub_frame._projection_to_paths(key, value)\n\n                if isinstance(project_value, dict):\n                    flat_projection.update(project_value)\n\n                else:\n                    flat_projection[key] = project_value\n\n            elif key == '$ref':\n                # Strip any $ref key\n                continue\n\n            elif key == '$sub' or key == '$sub.':\n                # Strip any $sub key\n                continue\n\n            else:\n                # Store the root projection value\n                flat_projection[key] = value\n                inclusive = False\n\n        # If only references and sub-frames where specified in the projection\n        # then return a full projection based on `_fields`.\n        if inclusive:\n            flat_projection = {f: True for f in cls._fields}\n\n        return flat_projection, references, subs"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef timestamp_update(sender, frames):\n        for frame in frames:\n            frame.modified = datetime.now(timezone.utc)", "response": "Timestamp the modified field for all documents."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cascade(cls, ref_cls, field, frames):\n        from mongoframes.queries import to_refs\n        ids = [to_refs(f[field]) for f in frames if f.get(field)]\n        ref_cls.get_collection().delete_many({'_id': {'$in': ids}})", "response": "Apply a cascading delete ( does not emit signals"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef nullify(cls, ref_cls, field, frames):\n        from mongoframes.queries import to_refs\n        ids = [to_refs(f) for f in frames]\n        ref_cls.get_collection().update_many(\n            {field: {'$in': ids}},\n            {'$set': {field: None}}\n            )", "response": "Nullify a reference field"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a callback for a signal against the class", "response": "def listen(cls, event, func):\n        \"\"\"Add a callback for a signal against the class\"\"\"\n        signal(event).connect(func, sender=cls)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef stop_listening(cls, event, func):\n        signal(event).disconnect(func, sender=cls)", "response": "Remove a callback for a signal against the class"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_db(cls):\n        if cls._db:\n            return getattr(cls._client, cls._db)\n        return cls._client.get_default_database()", "response": "Return the database for the collection"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _projection_to_paths(cls, root_key, projection):\n\n        # Referenced projections are handled separately so just flag the\n        # reference field to true.\n        if '$ref' in projection:\n            return True\n\n        inclusive = True\n        sub_projection = {}\n        for key, value in projection.items():\n            if key in ['$sub', '$sub.']:\n                continue\n\n            if key.startswith('$'):\n                sub_projection[root_key] = {key: value}\n                inclusive = False\n                continue\n\n            sub_key = root_key + '.' + key\n\n            if isinstance(value, dict):\n                sub_value = cls._projection_to_paths(sub_key, value)\n                if isinstance(sub_value, dict):\n                    sub_projection.update(sub_value)\n                else:\n                    sub_projection[sub_key] = True\n\n            else:\n                sub_projection[sub_key] = True\n                inclusive = False\n\n        if inclusive:\n            # No specific keys so this is inclusive\n            return True\n\n        return sub_projection", "response": "Expand a sub - key to a flat path mapping."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _flatten_projection(cls, projection):\n\n        # If `projection` is empty return a full projection\n        if not projection:\n            return {'__': False}, {}, {}\n\n        # Flatten the projection\n        flat_projection = {}\n        references = {}\n        subs = {}\n        inclusive = True\n        for key, value in deepcopy(projection).items():\n            if isinstance(value, dict):\n                # Store a reference/SubFrame projection\n                if '$ref' in value:\n                    references[key] = value\n                elif '$sub' in value or '$sub.' in value:\n                    subs[key] = value\n                flat_projection[key] = True\n\n            elif key == '$ref':\n                # Strip any `$ref` key\n                continue\n\n            elif key == '$sub' or key == '$sub.':\n                # Strip any `$sub` key\n                continue\n\n            else:\n                # Store the root projection value\n                flat_projection[key] = value\n                inclusive = False\n\n        # If only references and `SubFrames` were specified in the projection\n        # then return a full projection.\n        if inclusive:\n            flat_projection = {'__': False}\n\n        return flat_projection, references, subs", "response": "Flatten a structured projection"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _default_service_formatter(\n        service_url,\n        width,\n        height,\n        background,\n        foreground,\n        options\n        ):\n        \"\"\"Generate an image URL for a service\"\"\"\n\n        # Build the base URL\n        image_tmp = '{service_url}/{width}x{height}/{background}/{foreground}/'\n        image_url = image_tmp.format(\n            service_url=service_url,\n            width=width,\n            height=height,\n            background=background,\n            foreground=foreground\n            )\n\n        # Add any options\n        if options:\n            image_url += '?' + urlencode(options)\n\n        return image_url", "response": "Generate an image URL for a service."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates a body of text", "response": "def _body(self, paragraphs):\n        \"\"\"Generate a body of text\"\"\"\n        body = []\n        for i in range(paragraphs):\n            paragraph = self._paragraph(random.randint(1, 10))\n            body.append(paragraph)\n\n        return '\\n'.join(body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _paragraph(self, sentences):\n        paragraph = []\n        for i in range(sentences):\n            sentence = self._sentence(random.randint(5, 16))\n            paragraph.append(sentence)\n\n        return ' '.join(paragraph)", "response": "Generate a paragraph of text"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _sentence(self, words):\n        db = self.database\n\n        # Generate 2 words to start a sentence with\n        seed = random.randint(0, db['word_count'] - 3)\n        seed_word, next_word = db['words'][seed], db['words'][seed + 1]\n        w1, w2 = seed_word, next_word\n\n        # Generate the complete sentence\n        sentence = []\n        for i in range(0, words - 1):\n            sentence.append(w1)\n            w1, w2 = w2, random.choice(db['freqs'][(w1, w2)])\n        sentence.append(w2)\n\n        # Make the sentence respectable\n        sentence = ' '.join(sentence)\n\n        # Capitalize the sentence\n        sentence = sentence.capitalize()\n\n        # Remove additional sentence ending puntuation\n        sentence = sentence.replace('.', '')\n        sentence = sentence.replace('!', '')\n        sentence = sentence.replace('?', '')\n        sentence = sentence.replace(':', '')\n\n        # Remove quote tags\n        sentence = sentence.replace('.', '')\n        sentence = sentence.replace('!', '')\n        sentence = sentence.replace('?', '')\n        sentence = sentence.replace(':', '')\n        sentence = sentence.replace('\"', '')\n\n        # If the last character is not an alphanumeric remove it\n        sentence = re.sub('[^a-zA-Z0-9]$', '', sentence)\n\n        # Remove excess space\n        sentence = re.sub('\\s+', ' ', sentence)\n\n        # Add a full stop\n        sentence += '.'\n\n        return sentence", "response": "Generate a sentence from the words in the database."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize a database of words for the given name.", "response": "def init_word_db(cls, name, text):\n        \"\"\"Initialize a database of words for the maker with the given name\"\"\"\n        # Prep the words\n        text = text.replace('\\n', ' ').replace('\\r', ' ')\n        words = [w.strip() for w in text.split(' ') if w.strip()]\n\n        assert len(words) > 2, \\\n                'Database text sources must contain 3 or more words.'\n\n        # Build the database\n        freqs = {}\n        for i in range(len(words) - 2):\n\n            # Create a triplet from the current word\n            w1 = words[i]\n            w2 = words[i + 1]\n            w3 = words[i + 2]\n\n            # Add the triplet to the database\n            key = (w1, w2)\n            if key in freqs:\n                freqs[key].append(w3)\n            else:\n                freqs[key] = [w3]\n\n        # Store the database so it can be used\n        cls._dbs[name] = {\n            'freqs': freqs,\n            'words': words,\n            'word_count': len(words) - 2\n            }"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef weighted(weights):\n\n        # Convert weights to floats\n        weights = [float(w) for w in weights]\n\n        # Pick a value at random\n        choice = random.uniform(0, sum(weights))\n\n        # Find the value\n        position = 0\n        for i, weight in enumerate(weights):\n            if position + weight >= choice:\n                return i\n            position += weight", "response": "Return a random integer 0 <= N < = N < = N < = N - 1 where the weightsdetermine the probability of each possible integer."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the probability that the weight i will be present in the sample.", "response": "def p(i, sample_size, weights):\n        \"\"\"\n        Given a weighted set and sample size return the probabilty that the\n        weight `i` will be present in the sample.\n\n        Created to test the output of the `SomeOf` maker class. The math was\n        provided by Andy Blackshaw - thank you dad :)\n        \"\"\"\n\n        # Determine the initial pick values\n        weight_i = weights[i]\n        weights_sum = sum(weights)\n\n        # Build a list of weights that don't contain the weight `i`. This list will\n        # be used to build the possible picks before weight `i`.\n        other_weights = list(weights)\n        del other_weights[i]\n\n        # Calculate the probability\n        probability_of_i = 0\n        for picks in range(0, sample_size):\n\n            # Build the list of possible permutations for this pick in the sample\n            permutations = list(itertools.permutations(other_weights, picks))\n\n            # Calculate the probability for this permutation\n            permutation_probabilities = []\n            for permutation in permutations:\n\n                # Calculate the probability for each pick in the permutation\n                pick_probabilities = []\n                pick_weight_sum = weights_sum\n\n                for pick in permutation:\n                    pick_probabilities.append(pick / pick_weight_sum)\n\n                    # Each time we pick we update the sum of the weight the next\n                    # pick is from.\n                    pick_weight_sum -= pick\n\n                # Add the probability of picking i as the last pick\n                pick_probabilities += [weight_i / pick_weight_sum]\n\n                # Multiply all the probabilities for the permutation together\n                permutation_probability = reduce(\n                    lambda x, y: x * y, pick_probabilities\n                    )\n                permutation_probabilities.append(permutation_probability)\n\n            # Add together all the probabilities for all permutations together\n            probability_of_i += sum(permutation_probabilities)\n\n        return probability_of_i"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef weighted(weights, sample_size, with_replacement=False):\n        assert sample_size <= len(weights), \"The sample size must be smaller \\\nthan or equal to the number of weights it's taken from.\"\n\n        # Convert weights to floats\n        weights = [float(w) for w in weights]\n        weight_indexes = list(range(0, len(weights)))\n\n        samples = []\n        while len(samples) < sample_size:\n            # Choice a weight\n            sample = OneOf.weighted(weights)\n\n            # Add the choosen weight to our samples\n            samples.append(weight_indexes[sample])\n\n            if not with_replacement:\n                # Remove the weight from the list of weights we can select from\n                del weights[sample]\n                del weight_indexes[sample]\n\n        return samples", "response": "Return a list of random integers from the set of possible integers with the given weights."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a shared faker factory used to generate fake data", "response": "def get_fake(locale=None):\n        \"\"\"Return a shared faker factory used to generate fake data\"\"\"\n        if locale is None:\n            locale = Faker.default_locale\n\n        if not hasattr(Maker, '_fake_' + locale):\n            Faker._fake = faker.Factory.create(locale)\n        return Faker._fake"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a unique value using the assigned maker", "response": "def _get_unique(self, *args):\n        \"\"\"Generate a unique value using the assigned maker\"\"\"\n\n        # Generate a unique values\n        value = ''\n        attempts = 0\n        while True:\n            attempts += 1\n            value = self._maker(*args)\n            if value not in self._used_values:\n                break\n\n            assert attempts < self._max_attempts, \\\n                'Too many attempts to generate a unique value'\n\n        # Add the value to the set of used values\n        self._used_values.add(value)\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nassembles a single document using the blueprint", "response": "def assemble(cls):\n        \"\"\"Assemble a single document using the blueprint\"\"\"\n        document = {}\n        for field_name, maker in cls._instructions.items():\n            with maker.target(document):\n                document[field_name] = maker()\n        return document"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntake a assembled document and convert all assembled values to finished values.", "response": "def finish(cls, document):\n        \"\"\"\n        Take a assembled document and convert all assembled values to\n        finished values.\n        \"\"\"\n        target_document = {}\n        document_copy = {}\n        for field_name, value in document.items():\n            maker = cls._instructions[field_name]\n            target_document = document.copy()\n            with maker.target(target_document):\n                document_copy[field_name] = maker(value)\n                target_document[field_name] = document_copy[field_name]\n        return document_copy"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reassemble(cls, fields, document):\n        for field_name in cls._instructions:\n            if field_name in fields:\n                maker = cls._instructions[field_name]\n                with maker.target(document):\n                    document[field_name] = maker()", "response": "Reassemble the given set of items in the given document."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns True if there are any differences logged", "response": "def is_diff(self):\n        \"\"\"Return True if there are any differences logged\"\"\"\n        if not isinstance(self.details, dict):\n            return False\n\n        for key in ['additions', 'updates', 'deletions']:\n            if self.details.get(key, None):\n                return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_diff(self, original, new):\n        changes = {}\n\n        # Check for additions and updates\n        for new_key, new_value in new.items():\n\n            # Additions\n            if new_key not in original:\n                if 'additions' not in changes:\n                    changes['additions'] = {}\n                new_value = self.diff_safe(new_value)\n                changes['additions'][new_key] = new_value\n\n            # Updates\n            elif original[new_key] != new_value:\n                if 'updates' not in changes:\n                    changes['updates'] = {}\n\n                original_value = self.diff_safe(original[new_key])\n                new_value = self.diff_safe(new_value)\n\n                changes['updates'][new_key] = [original_value, new_value]\n\n                # Check for password type fields and redact them\n                if 'password' in new_key:\n                    changes['updates'][new_key] = ['*****', '*****']\n\n        # Check for deletions\n        for original_key, original_value in original.items():\n            if original_key not in new:\n                if 'deletions' not in changes:\n                    changes['deletions'] = {}\n\n                original_value = self.diff_safe(original_value)\n                changes['deletions'][original_key] = original_value\n\n        self.details = changes", "response": "Adds the diff between two dictionary of word - level properties."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef diff_to_html(cls, details):\n        changes = []\n\n        # Check that there are details to convert to HMTL\n        if not details:\n            return ''\n\n        def _frame(value):\n            \"\"\"\n            Handle converted `Frame` references where the human identifier is\n            stored against the `_str` key.\n            \"\"\"\n            if isinstance(value, dict) and '_str' in value:\n                return value['_str']\n            elif isinstance(value, list):\n                return ', '.join([_frame(v) for v in value])\n            return str(value)\n\n        # Additions\n        fields = sorted(details.get('additions', {}))\n        for field in fields:\n            new_value = _frame(details['additions'][field])\n            if isinstance(new_value, list):\n                new_value = ', '.join([_frame(v) for v in new_value])\n\n            change = cls._templates['add'].format(\n                field=field,\n                new_value=new_value\n                )\n            changes.append(change)\n\n        # Updates\n        fields = sorted(details.get('updates', {}))\n        for field in fields:\n            original_value = _frame(details['updates'][field][0])\n            if isinstance(original_value, list):\n                original_value = ', '.join([_frame(v) for v in original_value])\n\n            new_value = _frame(details['updates'][field][1])\n            if isinstance(new_value, list):\n                new_value = ', '.join([_frame(v) for v in new_value])\n\n            change = cls._templates['update'].format(\n                field=field,\n                original_value=original_value,\n                new_value=new_value\n                )\n            changes.append(change)\n\n        # Deletions\n        fields = sorted(details.get('deletions', {}))\n        for field in fields:\n            original_value = _frame(details['deletions'][field])\n            if isinstance(original_value, list):\n                original_value = ', '.join([_frame(v) for v in original_value])\n\n            change = cls._templates['delete'].format(\n                field=field,\n                original_value=original_value\n                )\n            changes.append(change)\n\n        return '\\n'.join(changes)", "response": "Return an entry s details in HTML format"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a value that can be safely stored as a diff", "response": "def diff_safe(cls, value):\n        \"\"\"Return a value that can be safely stored as a diff\"\"\"\n        if isinstance(value, Frame):\n            return {'_str': str(value), '_id': value._id}\n        elif isinstance(value, (list, tuple)):\n            return [cls.diff_safe(v) for v in value]\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef comparable(self):\n        document_dict = self.compare_safe(self._document)\n\n        # Remove uncompared fields\n        self._remove_keys(document_dict, self._uncompared_fields)\n\n        # Remove any empty values\n        clean_document_dict = {}\n        for k, v in document_dict.items():\n            if not v and not isinstance(v, (int, float)):\n                continue\n            clean_document_dict[k] = v\n\n        # Convert any referenced fields to Frames\n        for ref_field, ref_cls in self._compared_refs.items():\n            ref = getattr(self, ref_field)\n            if not ref:\n                continue\n\n            # Check for fields which contain a list of references\n            if isinstance(ref, list):\n                if isinstance(ref[0], Frame):\n                    continue\n\n                # Dereference the list of reference IDs\n                setattr(\n                    clean_document_dict,\n                    ref_field,\n                    ref_cls.many(In(Q._id, ref))\n                    )\n\n            else:\n                if isinstance(ref, Frame):\n                    continue\n\n                # Dereference the reference ID\n                setattr(\n                    clean_document_dict,\n                    ref_field,\n                    ref_cls.byId(ref)\n                    )\n\n        return clean_document_dict", "response": "Return a dictionary that can be compared with the current object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef logged_delete(self, user):\n\n        self.delete()\n\n        # Log the change\n        entry = ChangeLogEntry({\n            'type': 'DELETED',\n            'documents': [self],\n            'user': user\n            })\n        entry.insert()\n\n        return entry", "response": "Delete the document and log the event in the change log"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating and insert the document and log the event in the change log", "response": "def logged_insert(self, user):\n        \"\"\"Create and insert the document and log the event in the change log\"\"\"\n\n        # Insert the frame's document\n        self.insert()\n\n        # Log the insert\n        entry = ChangeLogEntry({\n            'type': 'ADDED',\n            'documents': [self],\n            'user': user\n            })\n        entry.insert()\n\n        return entry"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef logged_update(self, user, data, *fields):\n\n        # Get a copy of the frames comparable data before the update\n        original = self.comparable\n\n        # Update the frame\n        _fields = fields\n        if len(fields) == 0:\n             _fields = data.keys()\n\n        for field in _fields:\n            if field in data:\n                setattr(self, field, data[field])\n\n        self.update(*fields)\n\n        # Create an entry and perform a diff\n        entry = ChangeLogEntry({\n            'type': 'UPDATED',\n            'documents': [self],\n            'user': user\n            })\n        entry.add_diff(original, self.comparable)\n\n        # Check there's a change to apply/log\n        if not entry.is_diff:\n            return\n        entry.insert()\n\n        return entry", "response": "Update the document with the dictionary of data provided and log the change log event in the change log."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a value that can be safely compared", "response": "def compare_safe(cls, value):\n        \"\"\"Return a value that can be safely compared\"\"\"\n\n        # Date\n        if type(value) == date:\n            return str(value)\n\n        # Lists\n        elif isinstance(value, (list, tuple)):\n            return [cls.compare_safe(v) for v in value]\n\n        # Dictionaries\n        elif isinstance(value, dict):\n            return {k: cls.compare_safe(v) for k, v in value.items()}\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a list of Q objects into a list of sort instructions", "response": "def SortBy(*qs):\n    \"\"\"Convert a list of Q objects into list of sort instructions\"\"\"\n\n    sort = []\n    for q in qs:\n        if q._path.endswith('.desc'):\n            sort.append((q._path[:-5], DESCENDING))\n        else:\n            sort.append((q._path, ASCENDING))\n    return sort"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef deep_merge(source, dest):\n    for key, value in source.items():\n        if key in dest:\n            if isinstance(value, dict) and isinstance(dest[key], dict):\n                deep_merge(value, dest[key])\n                continue\n            elif isinstance(value, list) and isinstance(dest[key], list):\n                for item in value:\n                    if item not in dest[key]:\n                        dest[key].append(item)\n                continue\n        dest[key] = value", "response": "Deep merges source dict into dest dict"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_refs(value):\n    from mongoframes.frames import Frame, SubFrame\n\n    # Frame\n    if isinstance(value, Frame):\n        return value._id\n\n    # SubFrame\n    elif isinstance(value, SubFrame):\n        return to_refs(value._document)\n\n    # Lists\n    elif isinstance(value, (list, tuple)):\n        return [to_refs(v) for v in value]\n\n    # Dictionaries\n    elif isinstance(value, dict):\n        return {k: to_refs(v) for k, v in value.items()}\n\n    return value", "response": "Convert all Frame instances within the given value to Ids"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_dict(self):\n        if self.operator == '$eq':\n            return {self.q: self.value}\n        if self.q is None:\n            return {self.operator: self.value}\n        return {self.q: {self.operator: self.value}}", "response": "Return a dictionary suitable for use with pymongo as a filter"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_dict(self):\n        raw_conditions = []\n        for condition in self.conditions:\n            if isinstance(condition, (Condition, Group)):\n                raw_conditions.append(condition.to_dict())\n            else:\n                raw_conditions.append(condition)\n        return {self.operator: raw_conditions}", "response": "Return a dictionary suitable for use with pymongo as a filter"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nassemble a quota of documents", "response": "def assemble(self, blueprint, quota):\n        \"\"\"Assemble a quota of documents\"\"\"\n\n        # Reset the blueprint\n        blueprint.reset()\n\n        # Assemble the documents\n        documents = []\n        for i in range(0, int(quota)):\n            documents.append(blueprint.assemble())\n\n        return documents"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinishes a list of pre - assembled documents", "response": "def finish(self, blueprint, documents):\n        \"\"\"Finish a list of pre-assembled documents\"\"\"\n\n        # Reset the blueprint\n        blueprint.reset()\n\n        # Finish the documents\n        finished = []\n        for document in documents:\n            finished.append(blueprint.finish(document))\n\n        return finished"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npopulating the database with documents", "response": "def populate(self, blueprint, documents):\n        \"\"\"Populate the database with documents\"\"\"\n\n        # Finish the documents\n        documents = self.finish(blueprint, documents)\n\n        # Convert the documents to frame instances\n        frames = []\n        for document in documents:\n            # Separate out any meta fields\n            meta_document = {}\n            for field_name in blueprint._meta_fields:\n                meta_document[field_name] = document[field_name]\n                document.pop(field_name)\n\n            # Initialize the frame\n            frame = blueprint.get_frame_cls()(document)\n\n            # Apply any meta fields\n            for key, value in meta_document.items():\n                setattr(frame, key, value)\n\n            frames.append(frame)\n\n        # Insert the documents\n        blueprint.on_fake(frames)\n        frames = blueprint.get_frame_cls().insert_many(frames)\n        blueprint.on_faked(frames)\n\n        return frames"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreassembles the given set of fields for a list of pre - assembed documents.", "response": "def reassemble(self, blueprint, fields, documents):\n        \"\"\"\n        Reassemble the given set of fields for a list of pre-assembed documents.\n\n        NOTE: Reassembly is done in place, since the data you send the method\n        should be JSON type safe, if you need to retain the existing document\n        it is recommended that you copy them using `copy.deepcopy`.\n        \"\"\"\n\n        # Reset the blueprint\n        blueprint.reset()\n\n        # Reassemble the documents\n        for document in documents:\n            blueprint.reassemble(fields, document)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef can_publish(self):\n        with self.published_context():\n            published = self.one(\n                Q._uid == self._uid,\n                projection={'revision': True}\n                )\n\n        if not published:\n            return True\n\n        with self.draft_context():\n            draft = self.one(Q._uid == self._uid, projection={'revision': True})\n\n        return draft.revision > published.revision", "response": "Return True if there is a draft version of the document that s ready to be published."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if we can revert the draft version of the document to the currently published version.", "response": "def can_revert(self):\n        \"\"\"\n        Return True if we can revert the draft version of the document to the\n        currently published version.\n        \"\"\"\n\n        if self.can_publish:\n            with self.published_context():\n                return self.count(Q._uid == self._uid) > 0\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_publisher_doc(self):\n        with self.draft_context():\n            # Select the draft document from the database\n            draft = self.one(Q._uid == self._uid)\n            publisher_doc = draft._document\n\n            # Remove any keys from the document that should not be transferred\n            # when publishing.\n            self._remove_keys(publisher_doc, self._unpublished_fields)\n\n        return publisher_doc", "response": "Return a publish safe version of the frame s document"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef publish(self):\n        publisher_doc = self.get_publisher_doc()\n\n        with self.published_context():\n            # Select the published document\n            published = self.one(Q._uid == self._uid)\n\n            # If there's no published version of the document create one\n            if not published:\n                published = self.__class__()\n\n            # Update the document\n            for field, value in publisher_doc.items():\n                setattr(published, field, value)\n\n            # Save published version\n            published.upsert()\n\n        # Set the revisions number for draft/published version, we use PyMongo\n        # directly as it's more convienent to use the shared `_uid`.\n        now = datetime.now()\n\n        with self.draft_context():\n            self.get_collection().update(\n                {'_uid': self._uid},\n                {'$set': {'revision': now}}\n                )\n\n        with self.published_context():\n            self.get_collection().update(\n                {'_uid': self._uid},\n                {'$set': {'revision': now}}\n                )", "response": "Publish the current document."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsave a new revision of the document", "response": "def new_revision(self, *fields):\n        \"\"\"Save a new revision of the document\"\"\"\n\n        # Ensure this document is a draft\n        if not self._id:\n            assert g.get('draft'), \\\n                    'Only draft documents can be assigned new revisions'\n        else:\n            with self.draft_context():\n                assert self.count(Q._id == self._id) == 1, \\\n                        'Only draft documents can be assigned new revisions'\n\n        # Set the revision\n        if len(fields) > 0:\n           fields.append('revision')\n\n        self.revision = datetime.now()\n\n        # Update the document\n        self.upsert(*fields)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete this document and any counterpart document", "response": "def delete(self):\n        \"\"\"Delete this document and any counterpart document\"\"\"\n\n        with self.draft_context():\n            draft = self.one(Q._uid == self._uid)\n            if draft:\n                super(PublisherFrame, draft).delete()\n\n        with self.published_context():\n            published = self.one(Q._uid == self._uid)\n            if published:\n                super(PublisherFrame, published).delete()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreverting the document to currently published version", "response": "def revert(self):\n        \"\"\"Revert the document to currently published version\"\"\"\n\n        with self.draft_context():\n            draft = self.one(Q._uid == self._uid)\n\n        with self.published_context():\n            published = self.one(Q._uid == self._uid)\n\n        for field, value in draft._document.items():\n            if field in self._unpublished_fields:\n                continue\n            setattr(draft, field, getattr(published, field))\n\n        # Revert the revision\n        draft.revision = published.revision\n\n        draft.update()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_collection(cls):\n\n        # By default the collection returned will be the published collection,\n        # however if the `draft` flag has been set against the global context\n        # (e.g `g`) then the collection returned will contain draft documents.\n\n        if g.get('draft'):\n            return getattr(\n                cls.get_db(),\n                '{collection}_draft'.format(collection=cls._collection)\n                )\n\n        return getattr(cls.get_db(), cls._collection)", "response": "Return a reference to the database collection for the class"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the context to draft", "response": "def draft_context(cls):\n        \"\"\"Set the context to draft\"\"\"\n        previous_state = g.get('draft')\n        try:\n            g.draft = True\n            yield\n        finally:\n            g.draft = previous_state"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the context to published", "response": "def published_context(cls):\n        \"\"\"Set the context to published\"\"\"\n        previous_state = g.get('draft')\n        try:\n            g.draft = False\n            yield\n        finally:\n            g.draft = previous_state"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef initialize_registry(args: argparse.Namespace, backend: StorageBackend, log: logging.Logger):\n    try:\n        backend.reset(args.force)\n    except ExistingBackendError:\n        return 1\n\n    log.info(\"Resetting the index ...\")\n    backend.index.reset()\n    try:\n        backend.index.upload(\"reset\", {})\n    except ValueError:\n        return 1\n    log.info(\"Successfully initialized\")", "response": "Initialize the registry and index."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npublish a model to Google Cloud Storage and update the index file.", "response": "def publish_model(args: argparse.Namespace, backend: StorageBackend, log: logging.Logger):\n    \"\"\"\n    Push the model to Google Cloud Storage and updates the index file.\n\n    :param args: :class:`argparse.Namespace` with \"model\", \"backend\", \"args\", \"force\", \"meta\" \\\n                 \"update_default\", \"username\", \"password\", \"remote_repo\", \"template_model\", \\\n                 \"template_readme\" and \"log_level\".\n    :param backend: Backend which is responsible for working with model files.\n    :param log: Logger supplied by supply_backend\n    :return: None if successful, 1 otherwise.\n    \"\"\"\n    path = os.path.abspath(args.model)\n    try:\n        model = GenericModel(source=path, dummy=True)\n    except ValueError as e:\n        log.critical('\"model\" must be a path: %s', e)\n        return 1\n    except Exception as e:\n        log.critical(\"Failed to load the model: %s: %s\" % (type(e).__name__, e))\n        return 1\n    base_meta = model.meta\n    try:\n        model_url = backend.upload_model(path, base_meta, args.force)\n    except ModelAlreadyExistsError:\n        return 1\n\n    log.info(\"Uploaded as %s\", model_url)\n    with open(os.path.join(args.meta), encoding=\"utf-8\") as _in:\n        extra_meta = json.load(_in)\n    model_type, model_uuid = base_meta[\"model\"], base_meta[\"uuid\"]\n    meta = extract_model_meta(base_meta, extra_meta, model_url)\n    log.info(\"Updating the models index...\")\n    try:\n        template_model = backend.index.load_template(args.template_model)\n        template_readme = backend.index.load_template(args.template_readme)\n    except ValueError:\n        return 1\n    backend.index.add_model(model_type, model_uuid, meta, template_model, args.update_default)\n    backend.index.update_readme(template_readme)\n    try:\n        backend.index.upload(\"add\", {\"model\": model_type, \"uuid\": model_uuid})\n    except ValueError:  # TODO: replace with PorcelainError, see related TODO in index.py:181\n        return 1\n    log.info(\"Successfully published.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlists the known models in the registry.", "response": "def list_models(args: argparse.Namespace):\n    \"\"\"\n    Output the list of known models in the registry.\n\n    :param args: :class:`argparse.Namespace` with \"username\", \"password\", \"remote_repo\" and \\\n                        \"log_level\"\n    :return: None\n    \"\"\"\n    try:\n        git_index = GitIndex(remote=args.index_repo, username=args.username,\n                             password=args.password, cache=args.cache, log_level=args.log_level)\n    except ValueError:\n        return 1\n    for model_type, models in git_index.models.items():\n        print(model_type)\n        default = git_index.meta[model_type][\"default\"]\n        for uuid, model in sorted(models.items(),\n                                  key=lambda m: parse_datetime(m[1][\"created_at\"]),\n                                  reverse=True):\n            print(\"  %s %s\" % (\"*\" if default == uuid else \" \", uuid),\n                  model[\"created_at\"])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete a model from the index.", "response": "def delete_model(args: argparse.Namespace, backend: StorageBackend, log: logging.Logger):\n    \"\"\"\n    Delete a model.\n\n    :param args: :class:`argparse.Namespace` with \"input\", \"backend\", \"args\", \"meta\", \\\n                        \"update_default\", \"username\", \"password\", \"remote_repo\", \\\n                        \"template_model\", \"template_readme\" and \"log_level\".\n    :param backend: Backend which is responsible for working with model files.\n    :param log: Logger supplied by supply_backend\n    :return: None\n    \"\"\"\n    try:\n        meta = backend.index.remove_model(args.input)\n        template_readme = backend.index.load_template(args.template_readme)\n        backend.index.update_readme(template_readme)\n    except ValueError:\n        return 1\n    backend.delete_model(meta)\n    log.info(\"Updating the models index...\")\n    try:\n        backend.index.upload(\"delete\", meta)\n    except ValueError:  # TODO: replace with PorcelainError\n        return 1\n    log.info(\"Successfully deleted.\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef install_environment(args: argparse.Namespace, backend: StorageBackend, log: logging.Logger):\n    model = _load_generic_model(args.input, backend, log)\n    if model is None:\n        return 1\n    packages = [\"%s==%s\" % (pkg, ver) for pkg, ver in model.environment[\"packages\"]]\n    cmdline = [sys.executable, \"-m\", \"pip\", \"install\"] + args.pip + packages\n    log.info(\" \".join(cmdline))\n    subprocess.check_call(cmdline)\n    if args.reproduce:\n        for dataset in model.datasets:\n            download_http(dataset[0], dataset[1], log)", "response": "Install the packages mentioned in the model s metadata."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dump_model(args: argparse.Namespace, backend: StorageBackend, log: logging.Logger):\n    model = _load_generic_model(args.input, backend, log)\n    if model is None:\n        return 1\n    print(model)", "response": "Dump the model information about the current model."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register_backend(cls: Type[StorageBackend]):\n    if not issubclass(cls, StorageBackend):\n        raise TypeError(\"cls must be a subclass of StorageBackend\")\n    __registry__[cls.NAME] = cls\n    return cls", "response": "Decorator to register another StorageBackend using it s NAME."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize a new StorageBackend by it s name and the specified model registry.", "response": "def create_backend(name: str=None, git_index: GitIndex=None, args: str=None) -> StorageBackend:\n    \"\"\"Initialize a new StorageBackend by it's name and the specified model registry.\"\"\"\n    if name is None:\n        name = config.BACKEND\n    if not args:\n        args = config.BACKEND_ARGS\n    if args:\n        try:\n            kwargs = dict(p.split(\"=\") for p in args.split(\",\"))\n        except:  # flake8: noqa\n            raise ValueError(\"Invalid args\") from None\n    else:\n        kwargs = {}\n    if git_index is None:\n        git_index = GitIndex()\n    kwargs[\"index\"] = git_index\n    return __registry__[name](**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_backend_noexc(log: logging.Logger, name: str=None, git_index: GitIndex=None,\n                         args: str=None) -> Optional[StorageBackend]:\n    \"\"\"Initialize a new Backend, return None if there was a known problem.\"\"\"\n    try:\n        return create_backend(name, git_index, args)\n    except KeyError:\n        log.critical(\"No such backend: %s (looked in %s)\",\n                     name, list(__registry__.keys()))\n        return None\n    except ValueError:\n        log.critical(\"Invalid backend arguments: %s\", args)\n        return None", "response": "Initialize a new backend return None if there was a known problem."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate the metadata for a given model name and the list of dependencies.", "response": "def generate_new_meta(name: str, description: str, vendor: str, license: str) -> dict:\n    \"\"\"\n    Create the metadata tree for the given model name and the list of dependencies.\n\n    :param name: Name of the model.\n    :param description: Description of the model.\n    :param vendor: Name of the party which is responsible for support of the model.\n    :param license: License identifier.\n    :return: dict with the metadata.\n    \"\"\"\n    check_license(license)\n    return {\n        \"code\": None,\n        \"created_at\": get_datetime_now(),\n        \"datasets\": [],\n        \"dependencies\": [],\n        \"description\": description,\n        \"vendor\": vendor,\n        \"environment\": collect_environment_without_packages(),\n        \"extra\": None,\n        \"license\": license,\n        \"metrics\": {},\n        \"model\": name,\n        \"parent\": None,\n        \"references\": [],\n        \"series\": None,\n        \"tags\": [],\n        \"uuid\": str(uuid.uuid4()),\n        \"version\": [1, 0, 0],\n    }"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nextract the metadata from the backend and the extra metadata into a dict which is suitable for index. json.", "response": "def extract_model_meta(base_meta: dict, extra_meta: dict, model_url: str) -> dict:\n    \"\"\"\n    Merge the metadata from the backend and the extra metadata into a dict which is suitable for \\\n    `index.json`.\n\n    :param base_meta: tree[\"meta\"] :class:`dict` containing data from the backend.\n    :param extra_meta: dict containing data from the user, similar to `template_meta.json`.\n    :param model_url: public URL of the model.\n    :return: converted dict.\n    \"\"\"\n    meta = {\"default\": {\"default\": base_meta[\"uuid\"],\n                        \"description\": base_meta[\"description\"],\n                        \"code\": extra_meta[\"code\"]}}\n    del base_meta[\"model\"]\n    del base_meta[\"uuid\"]\n    meta[\"model\"] = base_meta\n    meta[\"model\"].update({k: extra_meta[k] for k in (\"code\", \"datasets\", \"references\", \"tags\",\n                                                     \"extra\")})\n    response = requests.get(model_url, stream=True)\n    meta[\"model\"][\"size\"] = humanize.naturalsize(int(response.headers[\"content-length\"]))\n    meta[\"model\"][\"url\"] = model_url\n    meta[\"model\"][\"created_at\"] = format_datetime(meta[\"model\"][\"created_at\"])\n    return meta"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmerging the list of strings into two arrays.", "response": "def merge_strings(list_of_strings: Union[List[str], Tuple[str]]) -> dict:\n    \"\"\"\n    Pack the list of strings into two arrays: the concatenated chars and the \\\n    individual string lengths. :func:`split_strings()` does the inverse.\n\n    :param list_of_strings: The :class:`tuple` or :class:`list` of :class:`str`-s \\\n                            or :class:`bytes`-s to pack.\n    :return: :class:`dict` with \"strings\" and \"lengths\" \\\n             :class:`numpy.ndarray`-s.\n    \"\"\"\n    if not isinstance(list_of_strings, (tuple, list)):\n        raise TypeError(\"list_of_strings must be either a tuple or a list\")\n    if len(list_of_strings) == 0:\n        return {\"strings\": numpy.array([], dtype=\"S1\"),\n                \"lengths\": numpy.array([], dtype=int),\n                \"str\": None}\n    with_str = not isinstance(list_of_strings[0], bytes)\n    if with_str:\n        if not isinstance(list_of_strings[0], str):\n            raise TypeError(\"list_of_strings must contain either bytes or strings\")\n        strings = numpy.array([\"\".join(list_of_strings).encode(\"utf-8\")])\n    else:\n        merged = bytearray(sum(len(s) for s in list_of_strings))\n        offset = 0\n        for s in list_of_strings:\n            merged[offset:offset + len(s)] = s\n            offset += len(s)\n        strings = numpy.frombuffer(merged, dtype=\"S%d\" % len(merged))\n    lengths = [0] * len(list_of_strings)\n    for i, s in enumerate(list_of_strings):\n        lengths[i] = len(s)\n    lengths = squeeze_bits(numpy.array(lengths, dtype=int))\n    return {\"strings\": strings, \"lengths\": lengths, \"str\": with_str}"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef split_strings(subtree: dict) -> List[str]:\n    strings = subtree[\"strings\"]\n    lengths = subtree[\"lengths\"]\n    if lengths.shape[0] == 0 and strings.shape[0] == 0:\n        return []\n    strings = strings[0]\n    if subtree.get(\"str\", True):\n        strings = strings.decode(\"utf-8\")\n    result = [None] * lengths.shape[0]\n    offset = 0\n    for i, l in enumerate(lengths):\n        result[i] = strings[offset:offset + l]\n        offset += l\n    return result", "response": "Takes a dictionary containing strings and lengths and returns a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntransform a scipy. sparse matrix into a serializable collection of \\ articles.", "response": "def disassemble_sparse_matrix(matrix: scipy.sparse.spmatrix) -> dict:\n    \"\"\"\n    Transform a scipy.sparse matrix into the serializable collection of \\\n    :class:`numpy.ndarray`-s. :func:`assemble_sparse_matrix()` does the inverse.\n\n    :param matrix: :mod:`scipy.sparse` matrix; csr, csc and coo formats are \\\n                   supported.\n    :return: :class:`dict` with \"shape\", \"format\" and \"data\" - :class:`tuple` \\\n             of :class:`numpy.ndarray`.\n    \"\"\"\n    fmt = matrix.getformat()\n    if fmt not in (\"csr\", \"csc\", \"coo\"):\n        raise ValueError(\"Unsupported scipy.sparse matrix format: %s.\" % fmt)\n    result = {\n        \"shape\": matrix.shape,\n        \"format\": fmt\n    }\n    if isinstance(matrix, (scipy.sparse.csr_matrix, scipy.sparse.csc_matrix)):\n        lengths = numpy.concatenate(([0], numpy.diff(matrix.indptr)))\n        result[\"data\"] = matrix.data, squeeze_bits(matrix.indices), squeeze_bits(lengths)\n    elif isinstance(matrix, scipy.sparse.coo_matrix):\n        result[\"data\"] = matrix.data, (squeeze_bits(matrix.row), squeeze_bits(matrix.col))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nassembles a dictionary with shape format and data into the \\ scipy. sparse. spmatrix.", "response": "def assemble_sparse_matrix(subtree: dict) -> scipy.sparse.spmatrix:\n    \"\"\"\n    Transform a dictionary with \"shape\", \"format\" and \"data\" into the \\\n    :mod:`scipy.sparse` matrix. \\\n    Opposite to :func:`disassemble_sparse_matrix()`.\n\n    :param subtree: :class:`dict` which describes the :mod:`scipy.sparse` \\\n                    matrix.\n    :return: :mod:`scipy.sparse` matrix of the specified format.\n    \"\"\"\n    matrix_class = getattr(scipy.sparse, \"%s_matrix\" % subtree[\"format\"])\n    if subtree[\"format\"] in (\"csr\", \"csc\"):\n        indptr = subtree[\"data\"][2]\n        if indptr[-1] != subtree[\"data\"][0].shape[0]:\n            # indptr is diff-ed\n            subtree[\"data\"][2] = indptr.cumsum()\n    matrix = matrix_class(tuple(subtree[\"data\"]), shape=subtree[\"shape\"])\n    return matrix"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a copy of an integer numpy array with the minimum bitness.", "response": "def squeeze_bits(arr: numpy.ndarray) -> numpy.ndarray:\n    \"\"\"Return a copy of an integer numpy array with the minimum bitness.\"\"\"\n    assert arr.dtype.kind in (\"i\", \"u\")\n    if arr.dtype.kind == \"i\":\n        assert arr.min() >= 0\n    mlbl = int(arr.max()).bit_length()\n    if mlbl <= 8:\n        dtype = numpy.uint8\n    elif mlbl <= 16:\n        dtype = numpy.uint16\n    elif mlbl <= 32:\n        dtype = numpy.uint32\n    else:\n        dtype = numpy.uint64\n    return arr.astype(dtype)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load(self, source: Union[str, BinaryIO, \"Model\"]=None, cache_dir: str=None,\n             backend: StorageBackend=None, lazy=False) -> \"Model\":\n        \"\"\"\n        Build a new Model instance.\n\n        :param source: UUID, file system path, file object or an URL; None means auto.\n        :param cache_dir: The directory where to store the downloaded model.\n        :param backend: Remote storage backend to use if ``source`` is a UUID or a URL.\n        :param lazy: Do not really load numpy arrays into memory. Instead, mmap() them. \\\n                     User is expected to call Model.close() when the tree is no longer needed.\n        \"\"\"\n        if isinstance(source, Model):\n            if not isinstance(source, type(self)):\n                raise TypeError(\"Incompatible model instance: %s <> %s\" %\n                                (type(source), type(self)))\n            self.__dict__ = source.__dict__\n            return self\n\n        if backend is not None and not isinstance(backend, StorageBackend):\n            raise TypeError(\"backend must be an instance of \"\n                            \"modelforge.storage_backend.StorageBackend\")\n        self._source = str(source)\n        generic = self.NAME == self.GENERIC_NAME\n        try:\n            if source is None or (isinstance(source, str) and not os.path.isfile(source)):\n                if cache_dir is None:\n                    if not generic:\n                        cache_dir = os.path.join(self.cache_dir(), self.NAME)\n                    else:\n                        cache_dir = tempfile.mkdtemp(prefix=\"modelforge-\")\n                try:\n                    uuid.UUID(source)\n                    is_uuid = True\n                except (TypeError, ValueError):\n                    is_uuid = False\n                model_id = self.DEFAULT_NAME if not is_uuid else source\n                file_name = model_id + self.DEFAULT_FILE_EXT\n                file_name = os.path.join(os.path.expanduser(cache_dir), file_name)\n                if os.path.exists(file_name) and (not source or not os.path.exists(source)):\n                    source = file_name\n                elif source is None or is_uuid:\n                    if backend is None:\n                        raise ValueError(\"The backend must be set to load a UUID or the default \"\n                                         \"model.\")\n                    index = backend.index.contents\n                    config = index[\"models\"]\n                    if not generic:\n                        if not is_uuid:\n                            model_id = index[\"meta\"][self.NAME][model_id]\n                        source = config[self.NAME][model_id]\n                    else:\n                        if not is_uuid:\n                            raise ValueError(\"File path, URL or UUID is needed.\")\n                        for models in config.values():\n                            if source in models:\n                                source = models[source]\n                                break\n                        else:\n                            raise FileNotFoundError(\"Model %s not found.\" % source)\n                    source = source[\"url\"]\n                if re.match(r\"\\w+://\", source):\n                    if backend is None:\n                        raise ValueError(\"The backend must be set to load a URL.\")\n                    backend.fetch_model(source, file_name)\n                    self._source = source\n                    source = file_name\n            if isinstance(source, str):\n                size = os.stat(source).st_size\n            else:\n                self._source = \"<file object>\"\n                pos = source.tell()\n                size = source.seek(0, os.SEEK_END) - pos\n                source.seek(pos, os.SEEK_SET)\n            self._log.info(\"Reading %s (%s)...\", source, humanize.naturalsize(size))\n            model = asdf.open(source, copy_arrays=not lazy, lazy_load=lazy)\n            try:\n                tree = model.tree\n                self._meta = tree[\"meta\"]\n                self._initial_version = list(self.version)\n                if not generic:\n                    meta_name = self._meta[\"model\"]\n                    matched = self.NAME == meta_name\n                    if not matched:\n                        needed = {self.NAME}\n                        for child in type(self).__subclasses__():\n                            needed.add(child.NAME)\n                            matched |= child.NAME == meta_name\n                        if not matched:\n                            raise ValueError(\n                                \"The supplied model is of the wrong type: needed \"\n                                \"%s, got %s.\" % (needed, meta_name))\n                self._load_tree(tree)\n            finally:\n                if not lazy:\n                    model.close()\n                else:\n                    self._asdf = model\n        finally:\n            if generic and cache_dir is not None:\n                shutil.rmtree(cache_dir)\n        self._size = size\n        return self", "response": "Loads a model from a file system path or file object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nderiving the current model from a new version.", "response": "def derive(self, new_version: Union[tuple, list]=None) -> \"Model\":\n        \"\"\"\n        Inherit the new model from the current one - used for versioning. \\\n        This operation is in-place.\n\n        :param new_version: The version of the new model.\n        :return: The derived model - self.\n        \"\"\"\n        meta = self.meta\n        first_time = self._initial_version == self.version\n        if new_version is None:\n            new_version = meta[\"version\"]\n            new_version[-1] += 1\n        if not isinstance(new_version, (tuple, list)):\n            raise ValueError(\"new_version must be either a list or a tuple, got %s\"\n                             % type(new_version))\n        meta[\"version\"] = list(new_version)\n        if first_time:\n            meta[\"parent\"] = meta[\"uuid\"]\n        meta[\"uuid\"] = str(uuid.uuid4())\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the default cache directory where downloaded models are stored.", "response": "def cache_dir() -> str:\n        \"\"\"Return the default cache directory where downloaded models are stored.\"\"\"\n        if config.VENDOR is None:\n            raise RuntimeError(\"modelforge is not configured; look at modelforge.configuration. \"\n                               \"Depending on your objective you may or may not want to create a \"\n                               \"modelforgecfg.py file which sets VENDOR and the rest.\")\n        return os.path.join(\"~\", \".\" + config.VENDOR)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_dep(self, name: str) -> str:\n        deps = self.meta[\"dependencies\"]\n        for d in deps:\n            if d[\"model\"] == name:\n                return d\n        raise KeyError(\"%s not found in %s.\" % (name, deps))", "response": "Return the uuid of the dependency identified with name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_dep(self, *deps) -> \"Model\":\n        self.meta[\"dependencies\"] = [\n            (d.meta if not isinstance(d, dict) else d) for d in deps]\n        return self", "response": "Register the dependencies for this model."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save(self, output: Union[str, BinaryIO], series: Optional[str] = None,\n             deps: Iterable=tuple(), create_missing_dirs: bool=True) -> \"Model\":\n        \"\"\"\n        Serialize the model to a file.\n\n        :param output: Path to the file or a file object.\n        :param series: Name of the model series. If it is None, it will be taken from \\\n                       the current value; if the current value is empty, an error is raised.\n        :param deps: List of the dependencies.\n        :param create_missing_dirs: create missing directories in output path if the output is a \\\n                                    path.\n        :return: self\n        \"\"\"\n        check_license(self.license)\n        if series is None:\n            if self.series is None:\n                raise ValueError(\"series must be specified\")\n        else:\n            self.series = series\n        if isinstance(output, str) and create_missing_dirs:\n            dirs = os.path.split(output)[0]\n            if dirs:\n                os.makedirs(dirs, exist_ok=True)\n        self.set_dep(*deps)\n        tree = self._generate_tree()\n        self._write_tree(tree, output)\n        self._initial_version = self.version\n        return self", "response": "Serialize the current model to a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _write_tree(self, tree: dict, output: Union[str, BinaryIO], file_mode: int=0o666) -> None:\n        self.meta[\"created_at\"] = get_datetime_now()\n        meta = self.meta.copy()\n        meta[\"environment\"] = collect_environment()\n        final_tree = {}\n        final_tree.update(tree)\n        final_tree[\"meta\"] = meta\n        isfileobj = not isinstance(output, str)\n        if not isfileobj:\n            self._source = output\n            path = output\n            output = open(output, \"wb\")\n            os.chmod(path, file_mode)\n            pos = 0\n        else:\n            pos = output.tell()\n        try:\n            with asdf.AsdfFile(final_tree) as file:\n                queue = [(\"\", tree)]\n                while queue:\n                    path, element = queue.pop()\n                    if isinstance(element, dict):\n                        for key, val in element.items():\n                            queue.append((path + \"/\" + key, val))\n                    elif isinstance(element, (list, tuple)):\n                        for child in element:\n                            queue.append((path, child))\n                    elif isinstance(element, numpy.ndarray):\n                        path += \"/\"\n                        if path not in self._compression_prefixes:\n                            self._log.debug(\"%s -> %s compression\", path, self.ARRAY_COMPRESSION)\n                            file.set_array_compression(element, self.ARRAY_COMPRESSION)\n                        else:\n                            self._log.debug(\"%s -> compression disabled\", path)\n                file.write_to(output)\n            self._size = output.seek(0, os.SEEK_END) - pos\n        finally:\n            if not isfileobj:\n                output.close()", "response": "Write the ASDF tree to disk."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef refresh():\n    override_files = []\n    for stack in traceback.extract_stack():\n        f = os.path.join(os.path.dirname(stack[0]), OVERRIDE_FILE)\n        if f not in override_files:\n            override_files.insert(0, f)\n    if OVERRIDE_FILE in override_files:\n        del override_files[override_files.index(OVERRIDE_FILE)]\n    override_files.append(OVERRIDE_FILE)\n\n    def import_path(path):\n        if sys.version_info < (3, 5, 0):\n            from importlib.machinery import SourceFileLoader\n            return SourceFileLoader(__name__, path).load_module()\n        import importlib.util\n        spec = importlib.util.spec_from_file_location(__name__, path)\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)\n        return module\n\n    for override_file in override_files:\n        if not os.path.isfile(override_file):\n            continue\n        mod = import_path(override_file)\n        globals().update({n: getattr(mod, n) for n in dir(mod) if not n.startswith(\"__\")})", "response": "Scan over all the involved directories and load configs from them."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating GCS API client.", "response": "def create_client(self) -> \"google.cloud.storage.Client\":\n        \"\"\"\n        Construct GCS API client.\n        \"\"\"\n        # Client should be imported here because grpc starts threads during import\n        # and if you call fork after that, a child process will be hang during exit\n        from google.cloud.storage import Client\n        if self.credentials:\n            client = Client.from_service_account_json(self.credentials)\n        else:\n            client = Client()\n        return client"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef connect(self) -> \"google.cloud.storage.Bucket\":\n        log = self._log\n        log.info(\"Connecting to the bucket...\")\n        client = self.create_client()\n        return client.lookup_bucket(self.bucket_name)", "response": "Connect to the assigned bucket."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconnect to the assigned bucket or create if needed. Clear all the blobs inside.", "response": "def reset(self, force):\n        \"\"\"Connect to the assigned bucket or create if needed. Clear all the blobs inside.\"\"\"\n        client = self.create_client()\n        bucket = client.lookup_bucket(self.bucket_name)\n        if bucket is not None:\n            if not force:\n                self._log.error(\"Bucket already exists, aborting.\")\n                raise ExistingBackendError\n            self._log.info(\"Bucket already exists, deleting all content.\")\n            for blob in bucket.list_blobs():\n                self._log.info(\"Deleting %s ...\" % blob.name)\n                bucket.delete_blob(blob.name)\n        else:\n            client.create_bucket(self.bucket_name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupload the model to GCS.", "response": "def upload_model(self, path: str, meta: dict, force: bool):\n        \"\"\"Put the model to GCS.\"\"\"\n        bucket = self.connect()\n        if bucket is None:\n            raise BackendRequiredError\n        blob = bucket.blob(\"models/%s/%s.asdf\" % (meta[\"model\"], meta[\"uuid\"]))\n        if blob.exists() and not force:\n            self._log.error(\"Model %s already exists, aborted.\", meta[\"uuid\"])\n            raise ModelAlreadyExistsError\n        self._log.info(\"Uploading %s from %s...\", meta[\"model\"], os.path.abspath(path))\n\n        def tracker(data):\n            return self._Tracker(data, self._log)\n\n        make_transport = blob._make_transport\n\n        def make_transport_with_progress(client):\n            transport = make_transport(client)\n            request = transport.request\n\n            def request_with_progress(method, url, data=None, headers=None, **kwargs):\n                return request(method, url, data=tracker(data), headers=headers, **kwargs)\n\n            transport.request = request_with_progress\n            return transport\n\n        blob._make_transport = make_transport_with_progress\n\n        with open(path, \"rb\") as fin:\n            blob.upload_from_file(fin, content_type=\"application/x-yaml\")\n        blob.make_public()\n        return blob.public_url"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fetch_model(self, source: str, file: Union[str, BinaryIO],\n                    chunk_size: int=DEFAULT_DOWNLOAD_CHUNK_SIZE) -> None:\n        \"\"\"Download the model from GCS.\"\"\"\n        download_http(source, file, self._log, chunk_size)", "response": "Download the model from GCS."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting the model from GCS.", "response": "def delete_model(self, meta: dict):\n        \"\"\"Delete the model from GCS.\"\"\"\n        bucket = self.connect()\n        if bucket is None:\n            raise BackendRequiredError\n        blob_name = \"models/%s/%s.asdf\" % (meta[\"model\"], meta[\"uuid\"])\n        self._log.info(blob_name)\n        try:\n            self._log.info(\"Deleting model ...\")\n            bucket.delete_blob(blob_name)\n        except NotFound:\n            self._log.warning(\"Model %s already deleted.\", meta[\"uuid\"])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--log-level\", default=\"INFO\",\n                        choices=logging._nameToLevel,\n                        help=\"Logging verbosity.\")\n    subparsers = parser.add_subparsers(help=\"Commands\", dest=\"command\")\n\n    def add_backend_args(p):\n        p.add_argument(\"--backend\", default=None, help=\"Backend to use.\")\n        p.add_argument(\"--args\", default=None, help=\"Backend's arguments.\")\n\n    def add_index_args(p):\n        p.add_argument(\"--username\", default=\"\",\n                       help=\"Username for the Git repository with the index.\")\n        p.add_argument(\"--password\", default=\"\",\n                       help=\"Password for the Git repository with the index.\")\n        p.add_argument(\"--index-repo\", default=None,\n                       help=\"Url of the remote Git repository.\")\n        p.add_argument(\"--cache\", default=None,\n                       help=\"Path to the folder where the Git repository will be cached.\")\n        p.add_argument(\"-s\", \"--signoff\", action=\"store_true\",\n                       help=\"Add Signed-off-by line by the committer at the end of the commit log \"\n                            \"message. The meaning of a signoff depends on the project, but it \"\n                            \"typically certifies that committer has the rights to submit this work\"\n                            \" under the same license and agrees to a Developer Certificate of \"\n                            \"Origin (see http://developercertificate.org/ for more information).\")\n\n    def add_templates_args(p):\n        p.add_argument(\n            \"--template-model\",\n            default=os.path.join(os.path.dirname(__file__), \"templates/template_model.md.jinja2\"),\n            help=\"Path to the jinja2 template used in the index for the model.\")\n        p.add_argument(\n            \"--template-readme\",\n            default=os.path.join(os.path.dirname(__file__), \"templates/template_readme.md.jinja2\"),\n            help=\"Path to the jinja2 template used in the index for the readme.\")\n\n    # ------------------------------------------------------------------------\n    init_parser = subparsers.add_parser(\"init\", help=\"Initialize the registry.\")\n    init_parser.set_defaults(handler=initialize_registry)\n    init_parser.add_argument(\"-f\", \"--force\", action=\"store_true\",\n                             help=\"Destructively initialize the registry.\")\n    add_index_args(init_parser)\n    add_backend_args(init_parser)\n    # ------------------------------------------------------------------------\n    dump_parser = subparsers.add_parser(\n        \"dump\", help=\"Print a brief information about the model to stdout.\")\n    dump_parser.set_defaults(handler=dump_model)\n    dump_parser.add_argument(\n        \"input\", help=\"Path to the model file, URL or UUID.\")\n    add_index_args(dump_parser)\n    add_backend_args(dump_parser)\n    # ------------------------------------------------------------------------\n    install_parser = subparsers.add_parser(\n        \"install\", help=\"Install the environment to run the model.\")\n    install_parser.set_defaults(handler=install_environment)\n    install_parser.add_argument(\n        \"input\", help=\"Path to the model file, URL or UUID.\")\n    install_parser.add_argument(\n        \"--reproduce\", action=\"store_true\",\n        help=\"Ensure that training the model is possible.\")\n    install_parser.add_argument(\n        \"--pip\", nargs=\"*\", help=\"Additional arguments to pass to pip.\")\n    add_index_args(install_parser)\n    add_backend_args(install_parser)\n    # ------------------------------------------------------------------------\n    publish_parser = subparsers.add_parser(\n        \"publish\", help=\"Upload the model and update the registry.\")\n    publish_parser.set_defaults(handler=publish_model)\n    publish_parser.add_argument(\n        \"model\", help=\"The path to the model to publish.\")\n    publish_parser.add_argument(\n        \"--meta\", default=os.path.join(os.path.dirname(__file__), \"templates/template_meta.json\"),\n        help=\"Path to the JSON file which contains the additional metadata of the model.\")\n    publish_parser.add_argument(\"-d\", \"--update-default\", action=\"store_true\",\n                                help=\"Set this model as the default one.\")\n    publish_parser.add_argument(\"-f\", \"--force\", action=\"store_true\",\n                                help=\"Overwrite existing models.\")\n    add_index_args(publish_parser)\n    add_backend_args(publish_parser)\n    add_templates_args(publish_parser)\n    # ------------------------------------------------------------------------\n    list_parser = subparsers.add_parser(\n        \"list\", help=\"Lists all the models in the registry.\")\n    list_parser.set_defaults(handler=list_models)\n    add_index_args(list_parser)\n    # ------------------------------------------------------------------------\n    delete_parser = subparsers.add_parser(\"delete\", help=\"Delete a model.\")\n    delete_parser.set_defaults(handler=delete_model)\n    delete_parser.add_argument(\n        \"input\", help=\"UUID of the model to be deleted.\")\n    add_index_args(delete_parser)\n    add_backend_args(delete_parser)\n    add_templates_args(delete_parser)\n    # ------------------------------------------------------------------------\n    args = parser.parse_args()\n    args.log_level = logging._nameToLevel[args.log_level]\n    slogging.setup(args.log_level, False)\n    try:\n        handler = args.handler\n    except AttributeError:\n        def print_usage(_):\n            parser.print_usage()\n\n        handler = print_usage\n    return handler(args)", "response": "This function creates all the argparse - rs and invokes the function from set_defaults."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndownload a file from an HTTP source.", "response": "def download_http(source: str, file: Union[str, BinaryIO], log: logging.Logger,\n                  chunk_size: int=DEFAULT_DOWNLOAD_CHUNK_SIZE) -> None:\n    \"\"\"\n    Download a file from an HTTP source.\n\n    :param source: URL to fetch.\n    :param file: Where to store the downloaded data.\n    :param log: Logger.\n    :param chunk_size: Size of download buffer.\n    \"\"\"\n    log.info(\"Fetching %s...\", source)\n    r = requests.get(source, stream=True)\n    if r.status_code != 200:\n        log.error(\n            \"An error occurred while fetching the model, with code %s\" % r.status_code)\n        raise ValueError\n    if isinstance(file, str):\n        os.makedirs(os.path.dirname(file), exist_ok=True)\n        f = open(file, \"wb\")\n    else:\n        f = file\n    try:\n        total_length = int(r.headers.get(\"content-length\"))\n        num_chunks = math.ceil(total_length / chunk_size)\n        if num_chunks == 1:\n            f.write(r.content)\n        else:\n            for chunk in progress_bar(\n                    r.iter_content(chunk_size=chunk_size),\n                    log,\n                    expected_size=num_chunks):\n                if chunk:\n                    f.write(chunk)\n    finally:\n        if isinstance(file, str):\n            f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef upload_model(self, path: str, meta: dict, force: bool) -> str:\n        raise NotImplementedError", "response": "Uploads the given file to the remote storage."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_timezone() -> Tuple[datetime.tzinfo, str]:\n    dt = get_datetime_now().astimezone()\n    tzstr = dt.strftime(\"%z\")\n    tzstr = tzstr[:-2] + \":\" + tzstr[-2:]\n    return dt.tzinfo, tzstr", "response": "Discover the current time zone and its standard string representation ( for source { d }."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setup(level: Union[str, int], structured: bool, config_path: str = None):\n    global logs_are_structured\n    logs_are_structured = structured\n\n    if not isinstance(level, int):\n        level = logging._nameToLevel[level]\n\n    def ensure_utf8_stream(stream):\n        if not isinstance(stream, io.StringIO) and hasattr(stream, \"buffer\"):\n            stream = codecs.getwriter(\"utf-8\")(stream.buffer)\n            stream.encoding = \"utf-8\"\n        return stream\n\n    sys.stdout, sys.stderr = (ensure_utf8_stream(s)\n                              for s in (sys.stdout, sys.stderr))\n\n    # basicConfig is only called to make sure there is at least one handler for the root logger.\n    # All the output level setting is down right afterwards.\n    logging.basicConfig()\n    logging.setLogRecordFactory(NumpyLogRecord)\n    if config_path is not None and os.path.isfile(config_path):\n        with open(config_path) as fh:\n            config = yaml.safe_load(fh)\n        for key, val in config.items():\n            logging.getLogger(key).setLevel(logging._nameToLevel.get(val, level))\n    root = logging.getLogger()\n    root.setLevel(level)\n\n    if not structured:\n        if not sys.stdin.closed and sys.stdout.isatty():\n            handler = root.handlers[0]\n            handler.setFormatter(AwesomeFormatter())\n    else:\n        root.handlers[0] = StructuredHandler(level)", "response": "Initializes the logging and structured logging environments."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_context(context):\n    try:\n        handler = logging.getLogger().handlers[0]\n    except IndexError:\n        # logging is not initialized\n        return\n    if not isinstance(handler, StructuredHandler):\n        return\n    handler.acquire()\n    try:\n        handler.local.context = context\n    finally:\n        handler.release()", "response": "Assign the logging context - an abstract object - to the current thread."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds logging - related command line flags specific to the given parser.", "response": "def add_logging_args(parser: argparse.ArgumentParser, patch: bool = True,\n                     erase_args: bool = True) -> None:\n    \"\"\"\n    Add command line flags specific to logging.\n\n    :param parser: `argparse` parser where to add new flags.\n    :param erase_args: Automatically remove logging-related flags from parsed args.\n    :param patch: Patch parse_args() to automatically setup logging.\n    \"\"\"\n    parser.add_argument(\"--log-level\", default=\"INFO\", choices=logging._nameToLevel,\n                        help=\"Logging verbosity.\")\n    parser.add_argument(\"--log-structured\", action=\"store_true\",\n                        help=\"Enable structured logging (JSON record per line).\")\n    parser.add_argument(\"--log-config\",\n                        help=\"Path to the file which sets individual log levels of domains.\")\n    # monkey-patch parse_args()\n    # custom actions do not work, unfortunately, because they are not invoked if\n    # the corresponding --flags are not specified\n\n    def _patched_parse_args(args=None, namespace=None) -> argparse.Namespace:\n        args = parser._original_parse_args(args, namespace)\n        setup(args.log_level, args.log_structured, args.log_config)\n        if erase_args:\n            for log_arg in (\"log_level\", \"log_structured\", \"log_config\"):\n                delattr(args, log_arg)\n        return args\n\n    if patch and not hasattr(parser, \"_original_parse_args\"):\n        parser._original_parse_args = parser.parse_args\n        parser.parse_args = _patched_parse_args"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nformats numpy array as a string.", "response": "def array2string(arr: numpy.ndarray) -> str:\n        \"\"\"Format numpy array as a string.\"\"\"\n        shape = str(arr.shape)[1:-1]\n        if shape.endswith(\",\"):\n            shape = shape[:-1]\n        return numpy.array2string(arr, threshold=11) + \"%s[%s]\" % (arr.dtype, shape)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getMessage(self):\n        if isinstance(self.msg, numpy.ndarray):\n            msg = self.array2string(self.msg)\n        else:\n            msg = str(self.msg)\n        if self.args:\n            a2s = self.array2string\n            if isinstance(self.args, Dict):\n                args = {k: (a2s(v) if isinstance(v, numpy.ndarray) else v)\n                        for (k, v) in self.args.items()}\n            elif isinstance(self.args, Sequence):\n                args = tuple((a2s(a) if isinstance(a, numpy.ndarray) else a)\n                             for a in self.args)\n            else:\n                raise TypeError(\"Unexpected input '%s' with type '%s'\" % (self.args,\n                                                                          type(self.args)))\n            msg = msg % args\n        return msg", "response": "Return the message for this LogRecord."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef formatMessage(self, record: logging.LogRecord) -> str:\n        level_color = \"0\"\n        text_color = \"0\"\n        fmt = \"\"\n        if record.levelno <= logging.DEBUG:\n            fmt = \"\\033[0;37m\" + logging.BASIC_FORMAT + \"\\033[0m\"\n        elif record.levelno <= logging.INFO:\n            level_color = \"1;36\"\n            lmsg = record.message.lower()\n            if self.GREEN_RE.search(lmsg):\n                text_color = \"1;32\"\n        elif record.levelno <= logging.WARNING:\n            level_color = \"1;33\"\n        elif record.levelno <= logging.CRITICAL:\n            level_color = \"1;31\"\n        if not fmt:\n            fmt = \"\\033[\" + level_color + \\\n                  \"m%(levelname)s\\033[0m:%(rthread)s:%(name)s:\\033[\" + text_color + \\\n                  \"m%(message)s\\033[0m\"\n        fmt = _fest + fmt\n        record.rthread = reduce_thread_id(record.thread)\n        return fmt % record.__dict__", "response": "Convert the already filled log record to a string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprint the log record formatted as JSON to stdout.", "response": "def emit(self, record: logging.LogRecord):\n        \"\"\"Print the log record formatted as JSON to stdout.\"\"\"\n        created = datetime.datetime.fromtimestamp(record.created, timezone)\n        obj = {\n            \"level\": record.levelname.lower(),\n            \"msg\": record.msg % record.args,\n            \"source\": \"%s:%d\" % (record.filename, record.lineno),\n            \"time\": format_datetime(created),\n            \"thread\": reduce_thread_id(record.thread),\n        }\n        if record.exc_info is not None:\n            obj[\"error\"] = traceback.format_exception(*record.exc_info)[1:]\n        try:\n            obj[\"context\"] = self.local.context\n        except AttributeError:\n            pass\n        json.dump(obj, sys.stdout, sort_keys=True)\n        sys.stdout.write(\"\\n\")\n        sys.stdout.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_model(cls: Type[Model]):\n    if not issubclass(cls, Model):\n        raise TypeError(\"model bust be a subclass of Model\")\n    if issubclass(cls, GenericModel):\n        raise TypeError(\"model must not be a subclass of GenericModel\")\n    __models__.add(cls)\n    return cls", "response": "Registers the given model class into the registry."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads from the associated Git repository.", "response": "def fetch(self):\n        \"\"\"Load from the associated Git repository.\"\"\"\n        os.makedirs(os.path.dirname(self.cached_repo), exist_ok=True)\n        if not os.path.exists(self.cached_repo):\n            self._log.warning(\"Index not found, caching %s in %s\", self.repo, self.cached_repo)\n            git.clone(self.remote_url, self.cached_repo, checkout=True)\n        else:\n            self._log.debug(\"Index is cached\")\n            if self._are_local_and_remote_heads_different():\n                self._log.info(\"Cached index is not up to date, pulling %s\", self. repo)\n                git.pull(self.cached_repo, self.remote_url)\n        with open(os.path.join(self.cached_repo, self.INDEX_FILE), encoding=\"utf-8\") as _in:\n            self.contents = json.load(_in)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_model(self, model_uuid: str) -> dict:\n        model_type = None\n        for key, val in self.models.items():\n            if model_uuid in val:\n                self._log.info(\"Found %s among %s models.\", model_uuid, key)\n                model_type = key\n                break\n        if model_type is None:\n            self._log.error(\"Model not found, aborted.\")\n            raise ValueError\n        model_directory = os.path.join(self.cached_repo, model_type)\n        model_node = self.models[model_type]\n        meta_node = self.meta[model_type]\n        if len(model_node) == 1:\n            self.models.pop(model_type)\n            self.meta.pop(model_type)\n            paths = [os.path.join(model_directory, model) for model in os.listdir(model_directory)]\n        else:\n            if meta_node[\"default\"] == model_uuid:\n                self._log.info(\"Model is set as default, removing from index ...\")\n                meta_node[\"default\"] = \"\"\n            model_node.pop(model_uuid)\n            paths = [os.path.join(model_directory, model_uuid + \".md\")]\n        git.remove(self.cached_repo, paths)\n        return {\"model\": model_type, \"uuid\": model_uuid}", "response": "Delete the model from the registry. Call upload to update the remote side."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_model(self, model_type: str, model_uuid: str, meta: dict,\n                  template_model: Template, update_default: bool=False):\n        \"\"\"Add a new model to the registry. Call `upload()` to update the remote side.\"\"\"\n        if update_default or model_type not in self.meta:\n            self.meta[model_type] = meta[\"default\"]\n        model_meta = meta[\"model\"]\n        self.models.setdefault(model_type, {})[model_uuid] = model_meta\n        model_directory = os.path.join(self.cached_repo, model_type)\n        os.makedirs(model_directory, exist_ok=True)\n        model = os.path.join(model_directory, model_uuid + \".md\")\n        if os.path.exists(model):\n            os.remove(model)\n        links = {}\n        for m_type, items in self.models.items():\n            for uuid in items:\n                if uuid in model_meta[\"dependencies\"]:\n                    links[uuid] = os.path.join(\"/\", m_type, \"%s.md\" % uuid)\n        with open(model, \"w\") as fout:\n            fout.write(template_model.render(model_type=model_type, model_uuid=model_uuid,\n                                             meta=model_meta, links=links))\n        git.add(self.cached_repo, [model])\n        self._log.info(\"Added %s\", model)", "response": "Add a new model to the registry."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_readme(self, template_readme: Template):\n        readme = os.path.join(self.cached_repo, \"README.md\")\n        if os.path.exists(readme):\n            os.remove(readme)\n        links = {model_type: {} for model_type in self.models.keys()}\n        for model_type, model_uuids in self.models.items():\n            for model_uuid in model_uuids:\n                links[model_type][model_uuid] = os.path.join(\"/\", model_type, \"%s.md\" % model_uuid)\n        with open(readme, \"w\") as fout:\n            fout.write(template_readme.render(models=self.models, meta=self.meta, links=links))\n        git.add(self.cached_repo, [readme])\n        self._log.info(\"Updated %s\", readme)", "response": "Generate the new README file locally."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the remote Git repository.", "response": "def reset(self):\n        \"\"\"Initialize the remote Git repository.\"\"\"\n        paths = []\n        for filename in os.listdir(self.cached_repo):\n            if filename.startswith(\".git\"):\n                continue\n            path = os.path.join(self.cached_repo, filename)\n            if os.path.isfile(path):\n                paths.append(path)\n            elif os.path.isdir(path):\n                for model in os.listdir(path):\n                    paths.append(os.path.join(path, model))\n        git.remove(self.cached_repo, paths)\n        self.contents = {\"models\": {}, \"meta\": {}}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef upload(self, cmd: str, meta: dict):\n        index = os.path.join(self.cached_repo, self.INDEX_FILE)\n        if os.path.exists(index):\n            os.remove(index)\n        self._log.info(\"Writing the new index.json ...\")\n        with open(index, \"w\") as _out:\n            json.dump(self.contents, _out)\n        git.add(self.cached_repo, [index])\n        message = self.COMMIT_MESSAGES[cmd].format(**meta)\n        if self.signoff:\n            global_conf_path = os.path.expanduser(\"~/.gitconfig\")\n            if os.path.exists(global_conf_path):\n                with open(global_conf_path, \"br\") as _in:\n                    conf = ConfigFile.from_file(_in)\n                    try:\n                        name = conf.get(b\"user\", b\"name\").decode()\n                        email = conf.get(b\"user\", b\"email\").decode()\n                        message += self.DCO_MESSAGE.format(name=name, email=email)\n                    except KeyError:\n                        self._log.warning(\n                            \"Did not find name or email in %s, committing without DCO.\",\n                            global_conf_path)\n            else:\n                self._log.warning(\"Global git configuration file %s does not exist, \"\n                                  \"committing without DCO.\", global_conf_path)\n        else:\n            self._log.info(\"Committing the index without DCO.\")\n        git.commit(self.cached_repo, message=message)\n        self._log.info(\"Pushing the updated index ...\")\n        # TODO: change when https://github.com/dulwich/dulwich/issues/631 gets addressed\n        git.push(self.cached_repo, self.remote_url, b\"master\")\n        if self._are_local_and_remote_heads_different():\n            self._log.error(\"Push has failed\")\n            raise ValueError(\"Push has failed\")", "response": "Push the current state of the registry to Git."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_template(self, template: str) -> Template:\n        env = dict(trim_blocks=True, lstrip_blocks=True, keep_trailing_newline=False)\n        jinja2_ext = \".jinja2\"\n        if not template.endswith(jinja2_ext):\n            self._log.error(\"Template file name must end with %s\" % jinja2_ext)\n            raise ValueError\n        if not template[:-len(jinja2_ext)].endswith(\".md\"):\n            self._log.error(\"Template file should be a Markdown file.\")\n            raise ValueError\n        if not os.path.isabs(template):\n            template = os.path.join(os.path.dirname(__file__), template)\n        with open(template, encoding=\"utf-8\") as fin:\n            template_obj = Template(fin.read(), **env)\n        template_obj.filename = template\n        self._log.info(\"Loaded %s\", template)\n        return template_obj", "response": "Load a Jinja2 template from the source directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwraps the given iterator with a progress bar.", "response": "def progress_bar(enumerable, logger, **kwargs):\n    \"\"\"\n    Show the progress bar in the terminal, if the logging level matches and we are interactive.\n\n    :param enumerable: The iterator of which we indicate the progress.\n    :param logger: The bound logging.Logger.\n    :param kwargs: Keyword arguments to pass to clint.textui.progress.bar.\n    :return: The wrapped iterator.\n    \"\"\"\n    if not logger.isEnabledFor(logging.INFO) or sys.stdin.closed or not sys.stdin.isatty():\n        return enumerable\n    return progress.bar(enumerable, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef collect_environment(no_cache: bool = False) -> dict:\n    global _env\n    if _env is None or no_cache:\n        _env = collect_environment_without_packages()\n        _env[\"packages\"] = collect_loaded_packages()\n    return _env", "response": "Collect the current Python executable and the current platform."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef collect_loaded_packages() -> List[Tuple[str, str]]:\n    dists = get_installed_distributions()\n    get_dist_files = DistFilesFinder()\n    file_table = {}\n    for dist in dists:\n        for file in get_dist_files(dist):\n            file_table[file] = dist\n    used_dists = set()\n    # we greedily load all values to a list to avoid weird\n    # \"dictionary changed size during iteration\" errors\n    for module in list(sys.modules.values()):\n        try:\n            dist = file_table[module.__file__]\n        except (AttributeError, KeyError):\n            continue\n        used_dists.add(dist)\n    return sorted((dist.project_name, dist.version) for dist in used_dists)", "response": "Return the currently loaded packages and their versions."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd some nice default routes.", "response": "def _add_routes(self):\n        \"\"\"Add some nice default routes.\"\"\"\n        if self.app.has_static_folder:\n            self.add_url_rule(\"/favicon.ico\", \"favicon\", self.favicon)\n        self.add_url_rule(\"/\", \"__default_redirect_to_status\", self.redirect_to_status)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncustomize a parser to get the correct options.", "response": "def get_argparser(parser=None):\n        \"\"\"Customize a parser to get the correct options.\"\"\"\n        parser = parser or argparse.ArgumentParser()\n        parser.add_argument(\"--host\", default=\"0.0.0.0\", help=\"Host listen address\")\n        parser.add_argument(\"--port\", \"-p\", default=9050, help=\"Listen port\", type=int)\n        parser.add_argument(\n            \"--debug\",\n            \"-d\",\n            default=False,\n            action=\"store_true\",\n            help=\"Enable debug mode\",\n        )\n        parser.add_argument(\n            \"--log-level\",\n            \"-l\",\n            default=\"INFO\",\n            help=\"Log Level, empty string to disable.\",\n        )\n        parser.add_argument(\n            \"--twisted\",\n            default=False,\n            action=\"store_true\",\n            help=\"Use twisted to server requests.\",\n        )\n        parser.add_argument(\n            \"--gunicorn\",\n            default=False,\n            action=\"store_true\",\n            help=\"Use gunicorn to server requests.\",\n        )\n        parser.add_argument(\n            \"--threads\", default=None, help=\"Number of threads to use.\", type=int\n        )\n        parser.add_argument(\"--disable-embedded-logging\",\n                            default=False,\n                            action=\"store_true\",\n                            help=\"Disable embedded logging configuration\")\n        return parser"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a new url rule to the flask app.", "response": "def add_url_rule(self, route, endpoint, handler):\n        \"\"\"Add a new url route.\n\n        Args:\n            See flask.Flask.add_url_route().\n        \"\"\"\n        self.app.add_url_rule(route, endpoint, handler)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef healthy(self):\n        try:\n            if self.is_healthy():\n                return \"OK\", 200\n\n            else:\n                return \"FAIL\", 500\n\n        except Exception as e:\n            self.app.logger.exception(e)\n            return str(e), 500", "response": "Return 200 is healthy else 500."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning 200 is ready else 500.", "response": "def ready(self):\n        \"\"\"Return 200 is ready, else 500.\n\n        Override is_ready() to change the readiness check.\n        \"\"\"\n        try:\n            if self.is_ready():\n                return \"OK\", 200\n\n            else:\n                return \"FAIL\", 500\n\n        except Exception as e:\n            self.app.logger.exception()\n            return str(e), 500"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns with werkzeug simple wsgi container.", "response": "def run_with_werkzeug(self, **options):\n        \"\"\"Run with werkzeug simple wsgi container.\"\"\"\n        threaded = self.threads is not None and (self.threads > 0)\n        self.app.run(\n            host=self.host,\n            port=self.port,\n            debug=self.debug,\n            threaded=threaded,\n            **options\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntaking a plain text message as an argument returns a list of tuples where the first element denotes whether the text should be quoted by default.", "response": "def quote(text, limit=1000):\n    \"\"\"\n    Takes a plain text message as an argument, returns a list of tuples. The\n    first argument of the tuple denotes whether the text should be expanded by\n    default. The second argument is the unmodified corresponding text.\n\n    Example: [(True, 'expanded text'), (False, '> Some quoted text')]\n\n    Unless the limit param is set to None, the text will automatically be quoted\n    starting at the line where the limit is reached.\n    \"\"\"\n\n    lines = text.split('\\n')\n\n    found = _internal.find_quote_position(lines, _patterns.MAX_WRAP_LINES, limit)\n\n    if found != None:\n        return [(True, '\\n'.join(lines[:found+1])), (False, '\\n'.join(lines[found+1:]))]\n\n    return [(True, text)]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef quote_html(html, limit=1000):\n    from . import _html\n\n    tree = _html.get_html_tree(html)\n\n    start_refs, end_refs, lines = _html.get_line_info(tree, limit+1)\n\n    found = _internal.find_quote_position(lines, 1, limit)\n\n    if found == None:\n        # No quoting found and we're below limit. We're done.\n        return [(True, _html.render_html_tree(tree))]\n    else:\n        start_tree = _html.slice_tree(tree, start_refs, end_refs,\n                                      (0, found+1), html_copy=html)\n        end_tree   = _html.slice_tree(tree, start_refs, end_refs,\n                                      (found+1, None))\n\n    return [\n        (True, _html.render_html_tree(start_tree)),\n        (False, _html.render_html_tree(end_tree)),\n    ]", "response": "Like quote but takes an HTML message as an argument."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unwrap(text):\n\n    lines = text.split('\\n')\n\n    result = _internal.unwrap(lines, _patterns.MAX_WRAP_LINES,\n                    _patterns.MIN_HEADER_LINES,_patterns.MIN_QUOTED_LINES)\n    if result:\n        typ, top_range, hdrs, main_range, bottom_range, needs_unindent = result\n\n        text_top = lines[slice(*top_range)] if top_range else ''\n        text = lines[slice(*main_range)] if main_range else ''\n        text_bottom = lines[slice(*bottom_range)] if bottom_range else ''\n\n        if needs_unindent:\n            text = _internal.unindent_lines(text)\n\n        result = {\n            'type': typ,\n        }\n\n        text = '\\n'.join(text).strip()\n        text_top = '\\n'.join(text_top).strip()\n        text_bottom = '\\n'.join(text_bottom).strip()\n\n        if text:\n            result['text'] = text\n        if text_top:\n            result['text_top'] = text_top\n        if text_bottom:\n            result['text_bottom'] = text_bottom\n\n        if hdrs:\n            result.update(hdrs)\n\n        return result", "response": "Unwraps the passed text into a reply or forward message."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unwrap_html(html):\n    from . import _html\n\n    tree = _html.get_html_tree(html)\n\n    start_refs, end_refs, lines = _html.get_line_info(tree)\n\n    result = _internal.unwrap(lines, 1, _patterns.MIN_HEADER_LINES, 1)\n\n    if result:\n        typ, top_range, hdrs, main_range, bottom_range, needs_unindent = result\n\n        result = {\n            'type': typ,\n        }\n\n        top_range = _html.trim_slice(lines, top_range)\n        main_range = _html.trim_slice(lines, main_range)\n        bottom_range = _html.trim_slice(lines, bottom_range)\n\n        if top_range:\n            top_tree = _html.slice_tree(tree, start_refs, end_refs, top_range,\n                                        html_copy=html)\n            html_top = _html.render_html_tree(top_tree)\n            if html_top:\n                result['html_top'] = html_top\n\n        if bottom_range:\n            bottom_tree = _html.slice_tree(tree, start_refs, end_refs,\n                                           bottom_range, html_copy=html)\n            html_bottom = _html.render_html_tree(bottom_tree)\n            if html_bottom:\n                result['html_bottom'] = html_bottom\n\n        if main_range:\n            main_tree = _html.slice_tree(tree, start_refs, end_refs, main_range)\n            if needs_unindent:\n                _html.unindent_tree(main_tree)\n            html = _html.render_html_tree(main_tree)\n            if html:\n                result['html'] = html\n\n        if hdrs:\n            result.update(hdrs)\n\n    return result", "response": "Unwraps the passed HTML into a new object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds a forward or reply pattern within the given lines on the given line number.", "response": "def find_pattern_on_line(lines, n, max_wrap_lines):\n    \"\"\"\n    Finds a forward/reply pattern within the given lines on text on the given\n    line number and returns a tuple with the type ('reply' or 'forward') and\n    line number of where the pattern ends. The returned line number may be\n    different from the given line number in case the pattern wraps over\n    multiple lines.\n\n    Returns (None, None) if no pattern was found.\n    \"\"\"\n    for typ, regexes in COMPILED_PATTERN_MAP.items():\n        for regex in regexes:\n            for m in range(max_wrap_lines):\n                match_line = join_wrapped_lines(lines[n:n+1+m])\n                if match_line.startswith('>'):\n                    match_line = match_line[1:].strip()\n                if regex.match(match_line.strip()):\n                    return n+m, typ\n    return None, None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_quote_position(lines, max_wrap_lines, limit=None):\n\n    for n in range(len(lines)):\n        end, typ = find_pattern_on_line(lines, n, max_wrap_lines)\n        if typ:\n            return end\n        if limit != None and n >= limit-1:\n            return n\n\n    return None", "response": "Find the end of a quoting pattern."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef join_wrapped_lines(lines):\n    if len(lines) == 1:\n        return lines[0]\n\n    joined = lines[0]\n    for line in lines[1:]:\n        if joined and joined[-1] in STRIP_SPACE_CHARS:\n            joined += line\n        else:\n            joined += ' '\n            joined += line\n\n    return joined", "response": "Joins one or multiple lines that are wrapped. Returns the reconstructed line."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract email headers from the given lines.", "response": "def extract_headers(lines, max_wrap_lines):\n    \"\"\"\n    Extracts email headers from the given lines. Returns a dict with the\n    detected headers and the amount of lines that were processed.\n    \"\"\"\n    hdrs = {}\n    header_name = None\n\n    # Track overlong headers that extend over multiple lines\n    extend_lines = 0\n\n    lines_processed = 0\n\n    for n, line in enumerate(lines):\n        if not line.strip():\n            header_name = None\n            continue\n\n        match = HEADER_RE.match(line)\n        if match:\n            header_name, header_value = match.groups()\n            header_name = header_name.strip().lower()\n            extend_lines = 0\n\n            if header_name in HEADER_MAP:\n                hdrs[HEADER_MAP[header_name]] = header_value.strip()\n            lines_processed = n+1\n        else:\n            extend_lines += 1\n            if extend_lines < max_wrap_lines and header_name in HEADER_MAP:\n                hdrs[HEADER_MAP[header_name]] = join_wrapped_lines(\n                        [hdrs[HEADER_MAP[header_name]], line.strip()])\n                lines_processed = n+1\n            else:\n                # no more headers found\n                break\n\n    return hdrs, lines_processed"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_reply(line):\n    if line.startswith('>'):\n        line = line[1:].strip()\n\n    date = user = None\n\n    for pattern in COMPILED_PATTERN_MAP['reply']:\n        match = pattern.match(line)\n        if match:\n            groups = match.groups()\n            if len(groups) == 2:\n                # We're lucky and got both date and user split up.\n                date, user = groups\n            else:\n                split_match = REPLY_DATE_SPLIT_REGEX.match(groups[0])\n                if split_match:\n                    split_groups = split_match.groups()\n                    date = split_groups[0]\n                    user = split_groups[-1]\n                else:\n                    # Try a simple comma split\n                    split = groups[0].rsplit(',', 1)\n                    if len(split) == 2:\n                        date, user = split\n\n    if date:\n        date = date.strip()\n\n    if user:\n        user = user.strip()\n\n    if date and user:\n        return {\n            'date': date.strip(),\n            'from': user.strip(),\n        }", "response": "Parses the given reply line and returns a dictionary with the Date and From keys."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding the starting point of a wrapped email.", "response": "def find_unwrap_start(lines, max_wrap_lines, min_header_lines, min_quoted_lines):\n    \"\"\"\n    Finds the starting point of a wrapped email. Returns a tuple containing\n    (start_line_number, end_line_number, type), where type can be one of the\n    following:\n\n     * 'forward': A matching forwarding pattern was found\n     * 'reply': A matching reply pattern was found\n     * 'headers': Headers were found (usually a forwarded email)\n     * 'quote': A quote was found\n\n    start_line_number corresponds to the line number where the forwarding/reply\n    pattern starts, or where the headers/quote starts. end_line_number is only\n    different from start_line_number if the forwarding/reply pattern spans over\n    multiple lines (it does not extend to the end of the headers or of the\n    quoted section).\n\n    Returns (None, None, None) if nothing was found.\n    \"\"\"\n\n    for n, line in enumerate(lines):\n        if not line.strip():\n            continue\n\n        # Find a forward / reply start pattern\n\n        end, typ = find_pattern_on_line(lines, n, max_wrap_lines)\n        if typ:\n            return n, end, typ\n\n        # Find a quote\n        if line.startswith('>'):\n            # Check if there are at least min_quoted_lines lines that match\n            matched_lines = 1\n\n            if matched_lines >= min_quoted_lines:\n                return n, n, 'quoted'\n\n            for peek_line in lines[n+1:]:\n                if not peek_line.strip():\n                    continue\n                if not peek_line.startswith('>'):\n                    break\n                else:\n                    matched_lines += 1\n                if matched_lines >= min_quoted_lines:\n                    return n, n, 'quoted'\n\n        # Find a header\n        match = HEADER_RE.match(line)\n        if match:\n            if len(extract_headers(lines[n:], max_wrap_lines)[0]) >= min_header_lines:\n                return n, n, 'headers'\n\n    return None, None, None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nunwraps a message into a single object.", "response": "def unwrap(lines, max_wrap_lines, min_header_lines, min_quoted_lines):\n    \"\"\"\n    Returns a tuple of:\n    - Type ('forward', 'reply', 'headers', 'quoted')\n    - Range of the text at the top of the wrapped message (or None)\n    - Headers dict (or None)\n    - Range of the text of the wrapped message (or None)\n    - Range of the text below the wrapped message (or None)\n    - Whether the wrapped text needs to be unindented\n    \"\"\"\n\n    headers = {}\n\n    # Get line number and wrapping type.\n    start, end, typ = find_unwrap_start(lines, max_wrap_lines, min_header_lines, min_quoted_lines)\n\n    # We found a line indicating that it's a forward/reply.\n    if typ in ('forward', 'reply'):\n        main_type = typ\n\n        if typ == 'reply':\n            reply_headers = parse_reply(join_wrapped_lines(lines[start:end+1]))\n            if reply_headers:\n                headers.update(reply_headers)\n\n        # Find where the headers or the quoted section starts.\n        # We can set min_quoted_lines to 1 because we expect a quoted section.\n        start2, end2, typ = find_unwrap_start(lines[end+1:], max_wrap_lines, min_header_lines, 1)\n\n        if typ == 'quoted':\n            # Quoted section starts. Unindent and check if there are headers.\n            quoted_start = end+1+start2\n            unquoted = unindent_lines(lines[quoted_start:])\n            rest_start = quoted_start + len(unquoted)\n            start3, end3, typ = find_unwrap_start(unquoted, max_wrap_lines, min_header_lines, min_quoted_lines)\n            if typ == 'headers':\n                hdrs, hdrs_length = extract_headers(unquoted[start3:], max_wrap_lines)\n                if hdrs:\n                    headers.update(hdrs)\n                rest2_start = quoted_start+start3+hdrs_length\n                return main_type, (0, start), headers, (rest2_start, rest_start), (rest_start, None), True\n            else:\n                return main_type, (0, start), headers, (quoted_start, rest_start), (rest_start, None), True\n\n        elif typ == 'headers':\n            hdrs, hdrs_length = extract_headers(lines[start+1:], max_wrap_lines)\n            if hdrs:\n                headers.update(hdrs)\n            rest_start = start + 1 + hdrs_length\n            return main_type, (0, start), headers, (rest_start, None), None, False\n        else:\n            # Didn't find quoted section or headers, assume that everything\n            # below is the qouted text.\n            return main_type, (0, start), headers, (start+(start2 or 0)+1, None), None, False\n\n    # We just found headers, which usually indicates a forwarding.\n    elif typ == 'headers':\n        main_type = 'forward'\n        hdrs, hdrs_length = extract_headers(lines[start:], max_wrap_lines)\n        rest_start = start + hdrs_length\n        return main_type, (0, start), hdrs, (rest_start, None), None, False\n\n    # We found quoted text. Headers may be within the quoted text.\n    elif typ == 'quoted':\n        unquoted = unindent_lines(lines[start:])\n        rest_start = start + len(unquoted)\n        start2, end2, typ = find_unwrap_start(unquoted, max_wrap_lines, min_header_lines, min_quoted_lines)\n        if typ == 'headers':\n            main_type = 'forward'\n            hdrs, hdrs_length = extract_headers(unquoted[start2:], max_wrap_lines)\n            rest2_start = start + hdrs_length\n            return main_type, (0, start), hdrs, (rest2_start, rest_start), (rest_start, None), True\n        else:\n            main_type = 'quote'\n            return main_type, (None, start), None, (start, rest_start), (rest_start, None), True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef trim_tree_after(element, include_element=True):\n    el = element\n    for parent_el in element.iterancestors():\n        el.tail = None\n        if el != element or include_element:\n            el = el.getnext()\n        while el is not None:\n            remove_el = el\n            el = el.getnext()\n            parent_el.remove(remove_el)\n        el = parent_el", "response": "Removes the document tree following the given element."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef trim_tree_before(element, include_element=True, keep_head=True):\n    el = element\n    for parent_el in element.iterancestors():\n        parent_el.text = None\n        if el != element or include_element:\n            el = el.getprevious()\n        else:\n            parent_el.text = el.tail\n        while el is not None:\n            remove_el = el\n            el = el.getprevious()\n            tag = remove_el.tag\n            is_head = isinstance(tag, string_class) and tag.lower() == 'head'\n            if not keep_head or not is_head:\n                parent_el.remove(remove_el)\n        el = parent_el", "response": "Removes the document tree preceding the given element."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef trim_slice(lines, slice_tuple):\n    def _empty(line):\n        return not line or line.strip() == '>'\n\n    if not slice_tuple:\n        return None\n\n    slice_start, slice_end = slice_tuple\n\n    if slice_start is None:\n        slice_start = 0\n    if slice_end is None:\n        slice_end = len(lines)\n\n    # Trim from beginning\n    while slice_start < slice_end and _empty(lines[slice_start]):\n        slice_start += 1\n\n    # Trim from end\n    while slice_end > slice_start and _empty(lines[slice_end-1]):\n        slice_end -= 1\n\n    return (slice_start, slice_end)", "response": "Trim a slice tuple from the beginning and end of the tree tree."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unindent_tree(element):\n    for el in element.iter():\n        if is_indentation_element(el):\n            el.attrib.clear()\n            el.tag = 'div'\n            return", "response": "Removes the outermost indent from the tree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the HTML tree with the given start_refs and end_refs.", "response": "def slice_tree(tree, start_refs, end_refs, slice_tuple, html_copy=None):\n    \"\"\"\n    Slices the HTML tree with the given start_refs and end_refs (obtained via\n    get_line_info) at the given slice_tuple, a tuple (start, end) containing\n    the start and end of the slice (or None, to start from the start / end at\n    the end of the tree). If html_copy is specified, a new tree is constructed\n    from the given HTML (which must be the equal to the original tree's HTML*).\n    The resulting tree is returned.\n\n    *) The reason we have to specify the HTML is that we can't reliably\n       construct a copy of the tree using copy.copy() (see bug\n       https://bugs.launchpad.net/lxml/+bug/1562550).\n    \"\"\"\n\n    start_ref = None\n    end_ref = None\n\n    if slice_tuple:\n        slice_start, slice_end = slice_tuple\n\n        if ((slice_start is not None and slice_start >= len(start_refs)) or\n            (slice_end is not None and slice_end <= 0)):\n            return get_html_tree('')\n\n        if slice_start != None and slice_start <= 0:\n            slice_start = None\n\n        if slice_end != None and slice_end >= len(start_refs):\n            slice_end = None\n    else:\n        slice_start, slice_end = None, None\n\n    if slice_start is not None:\n        start_ref = start_refs[slice_start]\n\n    if slice_end is not None:\n        if slice_end < len(end_refs):\n            end_ref = end_refs[slice_end-1]\n\n    if html_copy is not None:\n        et = lxml.etree.ElementTree(tree)\n\n        new_tree = get_html_tree(html_copy)\n\n        if start_ref:\n            selector = et.getelementpath(start_ref[0])\n            start_ref = (new_tree.find(selector), start_ref[1])\n\n        if end_ref:\n            selector = et.getelementpath(end_ref[0])\n            end_ref = (new_tree.find(selector), end_ref[1])\n\n    else:\n        new_tree = tree\n\n    if start_ref:\n        include_start = (start_ref[1] == BEGIN)\n    if end_ref:\n        include_end = (end_ref[1] == END)\n\n    # If start_ref is the same as end_ref, and we don't include the element,\n    # we are removing the entire tree. We need to handle this separately,\n    # otherwise trim_tree_after won't work because it can't find the already\n    # removed reference.\n    if start_ref and end_ref and start_ref[0] == end_ref[0]:\n        if not include_start or not include_end:\n            return get_html_tree('')\n\n    if start_ref:\n        trim_tree_before(start_ref[0], include_element=include_start)\n    if end_ref:\n        trim_tree_after(end_ref[0], include_element=include_end)\n\n    return new_tree"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_html_tree(html):\n\n    parser = lxml.html.HTMLParser(encoding='utf-8')\n    html = html.encode('utf8')\n\n    try:\n        tree = lxml.html.fromstring(html, parser=parser)\n    except lxml.etree.Error:\n        # E.g. empty document. Use dummy <div>\n        tree = lxml.html.fromstring('<div></div>')\n\n    # If the document doesn't start with a top level tag, wrap it with a <div>\n    # that will be later stripped out for consistent behavior.\n    if tree.tag not in lxml.html.defs.top_level_tags:\n        html = b'<div>%s</div>' % html\n        tree = lxml.html.fromstring(html, parser=parser)\n\n    # HACK for Outlook emails, where tags like <o:p> are rendered as <p>. We\n    # can generally ignore these tags so we replace them with <span>, which\n    # doesn't cause a line break. Also, we can't look up the element path of\n    # tags that contain colons. When rendering the tree, we will restore the\n    # tag name.\n    for el in tree.iter():\n        if el.nsmap or (isinstance(el.tag, string_class) and ':' in el.tag):\n            if el.nsmap:\n                actual_tag_name = '{}:{}'.format(list(el.nsmap.keys())[0], el.tag)\n            else:\n                actual_tag_name = el.tag\n            el.tag = 'span'\n            el.attrib['__tag_name'] = actual_tag_name\n\n    return tree", "response": "Given the HTML string returns a LXML tree object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef strip_wrapping(html):\n    if html.startswith('<div>') and html.endswith('</div>'):\n        html = html[5:-6]\n    return html.strip()", "response": "Removes wrapping that might have resulted when using get_html_tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef render_html_tree(tree):\n\n    # Restore any tag names that were changed in get_html_tree()\n    for el in tree.iter():\n        if '__tag_name' in el.attrib:\n            actual_tag_name = el.attrib.pop('__tag_name')\n            el.tag = actual_tag_name\n\n    html = lxml.html.tostring(tree, encoding='utf8').decode('utf8')\n\n    return strip_wrapping(html)", "response": "Renders the given HTML tree and strips any wrapping that was applied in the given HTML tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tree_line_generator(el, max_lines=None):\n\n    def _trim_spaces(text):\n        return MULTIPLE_WHITESPACE_RE.sub(' ', text).strip()\n\n    counter = 1\n    if max_lines != None and counter > max_lines:\n        return\n\n    # Buffer for the current line.\n    line = ''\n\n    # The reference tuple (element, position) for the start of the line.\n    start_ref = None\n\n    # The indentation level at the start of the line.\n    start_indentation_level = None\n\n    for token in tree_token_generator(el):\n        if token is None:\n            continue\n\n        elif isinstance(token, tuple):\n            el, state, indentation_level = token\n\n            tag_name = el.tag.lower()\n\n            line_break = (tag_name == 'br' and state == BEGIN)\n            is_block = (tag_name not in INLINE_TAGS)\n            is_forward = (is_block and state == BEGIN and\n                          el.attrib.get('style') in FORWARD_STYLES)\n\n            if is_block or line_break:\n                line = _trim_spaces(line)\n\n                if line or line_break or is_forward:\n                    end_ref = (el, state)\n                    yield start_ref, end_ref, start_indentation_level, line\n                    counter += 1\n                    if max_lines != None and counter > max_lines:\n                        return\n                    line = ''\n\n                    if is_forward:\n                        # Simulate forward\n                        yield (end_ref, end_ref, start_indentation_level,\n                               FORWARD_LINE)\n                        counter += 1\n                        if max_lines != None and counter > max_lines:\n                            return\n\n                if not line:\n                    start_ref = (el, state)\n                    start_indentation_level = indentation_level\n\n        elif isinstance(token, string_class):\n            line += token\n\n        else:\n            raise RuntimeError('invalid token: {}'.format(token))\n\n    line = _trim_spaces(line)\n    if line:\n        yield line", "response": "Internal generator that yields a tuple of the current line of the tree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nliking tree_line_generator, but yields tuples (start_ref, end_ref, line), where the line already takes the indentation into account by having \"> \" prepended. If a line already starts with \">\", it is escaped (\"\\\\>\"). This makes it possible to reliably use methods that analyze plain text to detect quoting.", "response": "def indented_tree_line_generator(el, max_lines=None):\n    \"\"\"\n    Like tree_line_generator, but yields tuples (start_ref, end_ref, line),\n    where the line already takes the indentation into account by having \"> \"\n    prepended. If a line already starts with \">\", it is escaped (\"\\\\>\"). This\n    makes it possible to reliably use methods that analyze plain text to detect\n    quoting.\n    \"\"\"\n    gen = tree_line_generator(el, max_lines)\n    for start_ref, end_ref, indentation_level, line in gen:\n        # Escape line\n        if line.startswith('>'):\n            line = '\\\\' + line\n        yield start_ref, end_ref, '> '*indentation_level + line"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle_error(self, exc, msg):\n        if self.mode == \"api\":\n            logger.error(msg)\n            if self.strict:\n                raise exc\n        elif self.mode == \"cli\":\n            sys.stderr.write(msg)\n            sys.exit(1)", "response": "Handle an error and return the user s ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the EPSG code for a given PRJ file or other text - based spatial reference file.", "response": "def get_epsg(self):\n        \"\"\"\n        Attempts to determine the EPSG code for a given PRJ file or other\n        similar text-based spatial reference file.\n\n        First, it looks up the PRJ text in the included epsg.db SQLite\n        database, which was manually sourced and cleaned from an ESRI website,\n        https://developers.arcgis.com/javascript/jshelp/pcs.html\n\n        If it cannot be found there, it next tries the prj2epsg.org API.\n        If an exact match is found, that EPSG code is returned and saved to\n        the database to avoid future external API calls.\n\n        TODO:\n        If that API cannot find an exact match but several partial matches,\n        those partials will be displayed to the user with the option to select one to save to the\n        database.\n        \"\"\"\n        cur = self.conn.cursor()\n        cur.execute(\"SELECT epsg_code FROM prj_epsg WHERE prjtext = ?\", (self.prj,))\n        # prjtext has a unique constraint on it, we should only ever fetchone()\n        result = cur.fetchone()\n        if not result and self.call_remote_api:\n            return self.call_api()\n        elif result is not None:\n            self.epsg_code = result[0]\n            return self.epsg_code"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_epsg(self, epsg_code):\n        self.epsg_code = epsg_code\n        assert isinstance(self.epsg_code, int)\n        cur = self.conn.cursor()\n        cur.execute(\"SELECT prjtext FROM prj_epsg WHERE epsg_code = ?\", (self.epsg_code,))\n        result = cur.fetchone()\n        if result is not None:\n            self.prj = result[0]\n            return True\n\n        return False", "response": "Load the prjtext from an epsg."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsaving prj WKT to given file.", "response": "def to_prj(self, filename):\n        \"\"\"\n        Saves prj WKT to given file.\n        \"\"\"\n        with open(filename, \"w\") as fp:\n            fp.write(self.prj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the current head version of the current script.", "response": "def get_current_head_version(graph):\n    \"\"\"\n    Returns the current head version.\n\n    \"\"\"\n    script_dir = ScriptDirectory(\"/\", version_locations=[graph.metadata.get_path(\"migrations\")])\n    return script_dir.get_current_head()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new temporary table from another table.", "response": "def create_temporary_table(from_table, name=None, on_commit=None):\n    \"\"\"\n    Create a new temporary table from another table.\n\n    \"\"\"\n    from_table = from_table.__table__ if hasattr(from_table, \"__table__\") else from_table\n\n    name = name or f\"temporary_{from_table.name}\"\n\n    # copy the origin table into the metadata with the new name.\n    temporary_table = copy_table(from_table, name)\n\n    # change create clause to: CREATE TEMPORARY TABLE\n    temporary_table._prefixes = list(from_table._prefixes)\n    temporary_table._prefixes.append(\"TEMPORARY\")\n\n    # change post create clause to: ON COMMIT DROP\n    if on_commit:\n        temporary_table.dialect_options[\"postgresql\"].update(\n            on_commit=on_commit,\n        )\n\n    temporary_table.insert_many = MethodType(insert_many, temporary_table)\n    temporary_table.select_from = MethodType(select_from, temporary_table)\n    temporary_table.upsert_into = MethodType(upsert_into, temporary_table)\n\n    return temporary_table"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the current revision of the database head.", "response": "def get_current_head(graph):\n    \"\"\"\n    Get the current database head revision, if any.\n\n    \"\"\"\n    session = new_session(graph)\n    try:\n        result = session.execute(\"SELECT version_num FROM alembic_version\")\n    except ProgrammingError:\n        return None\n    else:\n        return result.scalar()\n    finally:\n        session.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_all(graph):\n    head = get_current_head(graph)\n    if head is None:\n        Model.metadata.create_all(graph.postgres)\n        stamp_head(graph)", "response": "Create all database tables."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef flushing(self):\n        try:\n            yield\n            self.session.flush()\n        except (FlushError, IntegrityError) as error:\n            error_message = str(error)\n            # There ought to be a cleaner way to capture this condition\n            if \"duplicate\" in error_message:\n                raise DuplicateModelError(error)\n            if \"already exists\" in error_message:\n                raise DuplicateModelError(error)\n            if \"conflicts with\" in error_message and \"identity key\" in error_message:\n                raise DuplicateModelError(error)\n            elif \"still referenced\" in error_message:\n                raise ReferencedModelError(error)\n            elif \"is not present\" in error_message:\n                raise MissingDependencyError(error)\n            else:\n                raise ModelIntegrityError(error)", "response": "Flush the current session handling common errors."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create(self, instance):\n        with self.flushing():\n            if instance.id is None:\n                instance.id = self.new_object_id()\n            self.session.add(instance)\n        return instance", "response": "Create a new model instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef retrieve(self, identifier, *criterion):\n        return self._retrieve(\n            self.model_class.id == identifier,\n            *criterion\n        )", "response": "Retrieve a model by primary key and zero or more other criteria."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate an existing model with a new one.", "response": "def update(self, identifier, new_instance):\n        \"\"\"\n        Update an existing model with a new one.\n\n        :raises `ModelNotFoundError` if there is no existing model\n\n        \"\"\"\n        with self.flushing():\n            instance = self.retrieve(identifier)\n            self.merge(instance, new_instance)\n            instance.updated_at = instance.new_timestamp()\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating an existing model with a new one.", "response": "def update_with_diff(self, identifier, new_instance):\n        \"\"\"\n        Update an existing model with a new one.\n\n        :raises `ModelNotFoundError` if there is no existing model\n\n        \"\"\"\n        with self.flushing():\n            instance = self.retrieve(identifier)\n            before = Version(instance)\n            self.merge(instance, new_instance)\n            instance.updated_at = instance.new_timestamp()\n            after = Version(instance)\n        return instance, before - after"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreplaces an existing entry in the cache with a new one.", "response": "def replace(self, identifier, new_instance):\n        \"\"\"\n        Create or update a model.\n\n        \"\"\"\n        try:\n            # Note that `self.update()` ultimately calls merge, which will not enforce\n            # a strict replacement; absent fields will default to the current values.\n            return self.update(identifier, new_instance)\n        except ModelNotFoundError:\n            return self.create(new_instance)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef count(self, *criterion, **kwargs):\n        query = self._query(*criterion)\n        query = self._filter(query, **kwargs)\n        return query.count()", "response": "Count the number of models matching some criterion."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef search(self, *criterion, **kwargs):\n        query = self._query(*criterion)\n        query = self._order_by(query, **kwargs)\n        query = self._filter(query, **kwargs)\n        # NB: pagination must go last\n        query = self._paginate(query, **kwargs)\n        return query.all()", "response": "Search for the set of related resources matching some criterion."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsearches the cache for the first entry based on the given criteria.", "response": "def search_first(self, *criterion, **kwargs):\n        \"\"\"\n        Returns the first match based on criteria or None.\n\n        \"\"\"\n        query = self._query(*criterion)\n        query = self._order_by(query, **kwargs)\n        query = self._filter(query, **kwargs)\n        # NB: pagination must go last\n        query = self._paginate(query, **kwargs)\n        return query.first()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _filter(self, query, **kwargs):\n        query = self._auto_filter(query, **kwargs)\n        return query", "response": "Filter a query with user - supplied arguments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving a single record by some criteria.", "response": "def _retrieve(self, *criterion):\n        \"\"\"\n        Retrieve a model by some criteria.\n\n        :raises `ModelNotFoundError` if the row cannot be deleted.\n\n        \"\"\"\n        try:\n            return self._query(*criterion).one()\n        except NoResultFound as error:\n            raise ModelNotFoundError(\n                \"{} not found\".format(\n                    self.model_class.__name__,\n                ),\n                error,\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _delete(self, *criterion):\n        with self.flushing():\n            count = self._query(*criterion).delete()\n        if count == 0:\n            raise ModelNotFoundError\n        return True", "response": "Delete a model by some criterion."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct a query for the model.", "response": "def _query(self, *criterion):\n        \"\"\"\n        Construct a query for the model.\n\n        \"\"\"\n        return self.session.query(\n            self.model_class\n        ).filter(\n            *criterion\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef transaction(commit=True):\n    try:\n        yield SessionContext.session\n        if commit:\n            SessionContext.session.commit()\n    except Exception:\n        if SessionContext.session:\n            SessionContext.session.rollback()\n        raise", "response": "A context manager that commits or rollbacks the current session."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef transactional(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        with transaction():\n            return func(*args, **kwargs)\n    return wrapper", "response": "Decorator for functions that are called in a transaction."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef maybe_transactional(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        commit = kwargs.get(\"commit\", True)\n        with transaction(commit=commit):\n            return func(*args, **kwargs)\n    return wrapper", "response": "Decorator that ensures that the function is called with a transaction."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_alembic_config(temporary_dir, migrations_dir):\n    config = Config()\n    config.set_main_option(\"temporary_dir\", temporary_dir)\n    config.set_main_option(\"migrations_dir\", migrations_dir)\n    return config", "response": "Alembic uses the alembic. ini file to configure where it looks for everything else."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_script_directory(cls, config):\n    temporary_dir = config.get_main_option(\"temporary_dir\")\n    migrations_dir = config.get_main_option(\"migrations_dir\")\n\n    return cls(\n        dir=temporary_dir,\n        version_locations=[migrations_dir],\n    )", "response": "Alembic uses a script directory to encapsulate its env. py file its migrations\n    directory and its script. py. ako revision template."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run_online_migration(self):\n    connectable = self.graph.postgres\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection,\n            # assumes that all models extend our base\n            target_metadata=Model.metadata,\n            **get_alembic_environment_options(self.graph),\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()", "response": "Run an online migration using microcosm configuration."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef patch_script_directory(graph):\n    temporary_dir = mkdtemp()\n    from_config_original = getattr(ScriptDirectory, \"from_config\")\n    run_env_original = getattr(ScriptDirectory, \"run_env\")\n\n    # use a temporary directory for the revision template\n    with open(join(temporary_dir, \"script.py.mako\"), \"w\") as file_:\n        file_.write(make_script_py_mako())\n        file_.flush()\n\n    # monkey patch our script directory and migration logic\n    setattr(ScriptDirectory, \"from_config\", classmethod(make_script_directory))\n    setattr(ScriptDirectory, \"run_env\", run_online_migration)\n    setattr(ScriptDirectory, \"graph\", graph)\n    try:\n        yield temporary_dir\n    finally:\n        # cleanup\n        delattr(ScriptDirectory, \"graph\")\n        setattr(ScriptDirectory, \"run_env\", run_env_original)\n        setattr(ScriptDirectory, \"from_config\", from_config_original)\n        rmtree(temporary_dir)", "response": "Monkey patch the ScriptDirectory class to work around configuration assumptions."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_migrations_dir(graph):\n    try:\n        migrations_dir = graph.migrations_dir\n    except (LockedGraphError, NotBoundError):\n        migrations_dir = graph.metadata.get_path(\"migrations\")\n\n    if not isdir(migrations_dir):\n        raise Exception(\"Migrations dir must exist: {}\".format(migrations_dir))\n    return migrations_dir", "response": "Resolve the migrations directory path."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates the SQLAlchemy session class.", "response": "def configure_sessionmaker(graph):\n    \"\"\"\n    Create the SQLAlchemy session class.\n\n    \"\"\"\n    engine_routing_strategy = getattr(graph, graph.config.sessionmaker.engine_routing_strategy)\n\n    if engine_routing_strategy.supports_multiple_binds:\n        ScopedFactory.infect(graph, \"postgres\")\n\n    class RoutingSession(Session):\n        \"\"\"\n        Route session bind to an appropriate engine.\n\n        See: http://docs.sqlalchemy.org/en/latest/orm/persistence_techniques.html#partitioning-strategies\n\n        \"\"\"\n        def get_bind(self, mapper=None, clause=None):\n            return engine_routing_strategy.get_bind(mapper, clause)\n\n    return sessionmaker(class_=RoutingSession)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, identifier, new_instance):\n        old_instance = self.retrieve(identifier)\n        old_encrypted_identifier = old_instance.encrypted_identifier\n\n        if (\n            new_instance.encryption_context_key and\n            old_instance.encryption_context_key != new_instance.encryption_context_key\n        ):\n            raise ValueError(\"Cannot change encryption context key\")\n\n        # If updating a non encrypted field - skip\n        if new_instance.plaintext is None and new_instance.encrypted_relationship is None:\n            result = super().update(identifier, new_instance)\n            self.expunge(result)\n            return result\n\n        # Verify that the new instance is encrypted if it should be\n        # If it's not - encrypt it with the old key\n        # If it is - save the expected new plaintext\n        if new_instance.plaintext is not None:\n            expected_new_plaintext = new_instance.plaintext\n            new_instance = self.reencrypt_instance(new_instance, old_instance.encryption_context_key)\n        else:\n            decrypt, expected_new_plaintext = decrypt_instance(new_instance)\n\n        result = super().update(identifier, new_instance)\n\n        # Delete the old encrypted value (instead of using sqlalchemy cascade)\n        if old_encrypted_identifier != new_instance.encrypted_identifier:\n            self.encrypted_store.delete(old_encrypted_identifier)\n\n        # Update the return result, super().update() won't do it.\n        self.expunge(result)\n        result.plaintext = expected_new_plaintext\n        return result", "response": "Update an encrypted version of the key - value pair."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncloning an instance of Model that uses IdentityMixin.", "response": "def clone(instance, substitutions, ignore=()):\n    \"\"\"\n    Clone an instance of `Model` that uses `IdentityMixin`.\n\n    :param instance: the instance to clonse\n    :param substitutions: a dictionary of substitutions\n    :param ignore: a tuple of column names to ignore\n\n    \"\"\"\n    substitutions[instance.id] = new_object_id()\n\n    def substitute(value):\n        try:\n            hash(value)\n        except Exception:\n            return value\n        else:\n            return substitutions.get(value, value)\n\n    return instance.__class__(**{\n        key:  substitute(value)\n        for key, value in iter_items(instance, ignore)\n    }).create()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a MultiTenantEncryptor from configured keys.", "response": "def configure_encryptor(graph):\n    \"\"\"\n    Create a MultiTenantEncryptor from configured keys.\n\n    \"\"\"\n    encryptor = graph.multi_tenant_key_registry.make_encryptor(graph)\n\n    # register the encryptor will each encryptable type\n    for encryptable in EncryptableMixin.__subclasses__():\n        encryptable.register(encryptor)\n\n    return encryptor"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef toposorted(nodes, edges):\n    incoming = defaultdict(set)\n    outgoing = defaultdict(set)\n    for edge in edges:\n        incoming[edge.to_id].add(edge.from_id)\n        outgoing[edge.from_id].add(edge.to_id)\n\n    working_set = list(nodes.values())\n    results = []\n    while working_set:\n        remaining = []\n        for node in working_set:\n            if incoming[node.id]:\n                # node still has incoming edges\n                remaining.append(node)\n                continue\n\n            results.append(node)\n            for child in outgoing[node.id]:\n                incoming[child].remove(node.id)\n\n        if len(working_set) == len(remaining):\n            raise Exception(\"Cycle detected\")\n        working_set = remaining\n\n    return results", "response": "Perform a topological sort on the input resources."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef should_copy(column):\n    if not isinstance(column.type, Serial):\n        return True\n\n    if column.nullable:\n        return True\n\n    if not column.server_default:\n        return True\n\n    # do not create temporary serial values; they will be defaulted on upsert/insert\n    return False", "response": "Determines if a column should be copied."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copy_table(from_table, name):\n    metadata = from_table.metadata\n\n    if name in metadata.tables:\n        return metadata.tables[name]\n\n    schema = metadata.schema\n\n    columns = [\n        copy_column(column, schema)\n        for column in from_table.columns\n        if should_copy(column)\n    ]\n\n    return Table(\n        name,\n        metadata,\n        schema=schema,\n        comment=from_table.comment,\n        *columns,\n        **from_table.kwargs,\n    )", "response": "Copy a table.\n\n    Based on `Table.tometadata`, but simplified to remove constraints and indexes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef encrypt(self,\n                encryption_context_key: str,\n                plaintext: str) -> Tuple[bytes, Sequence[str]]:\n        \"\"\"\n        Encrypt a plaintext string value.\n\n        The return value will include *both* the resulting binary ciphertext and the\n        master key ids used for encryption. In the likely case that the encryptor was initialized\n        with master key aliases, these master key ids returned will represent the unaliased key.\n\n        \"\"\"\n        encryption_context = dict(\n            microcosm=encryption_context_key,\n        )\n\n        cyphertext, header = encrypt(\n            source=plaintext,\n            materials_manager=self.materials_manager,\n            encryption_context=encryption_context,\n        )\n\n        key_ids = [\n            self.unpack_key_id(encrypted_data_key.key_provider)\n            for encrypted_data_key in header.encrypted_data_keys\n        ]\n        return cyphertext, key_ids", "response": "Encrypt a plaintext string value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nintercept SQLAlchemy's instance init event. SQLALchemy allows callback to intercept ORM instance init functions. The calling arguments will be an empty instance of the `target` model, plus the arguments passed to `__init__`. The `kwargs` dictionary is mutable (which is why it is not passed as `**kwargs`). We leverage this callback to conditionally remove the `__plaintext__` value and set the `ciphertext` property.", "response": "def on_init(target: \"EncryptableMixin\", args, kwargs):\n    \"\"\"\n    Intercept SQLAlchemy's instance init event.\n\n    SQLALchemy allows callback to intercept ORM instance init functions. The calling arguments\n    will be an empty instance of the `target` model, plus the arguments passed to `__init__`.\n\n    The `kwargs` dictionary is mutable (which is why it is not passed as `**kwargs`). We leverage\n    this callback to conditionally remove the `__plaintext__` value and set the `ciphertext` property.\n\n    \"\"\"\n    encryptor = target.__encryptor__\n\n    # encryption context may be nullable\n    try:\n        encryption_context_key = str(kwargs[target.__encryption_context_key__])\n    except KeyError:\n        return\n\n    # do not encrypt targets that are not configured for it\n    if encryption_context_key not in encryptor:\n        return\n\n    plaintext = target.plaintext_to_str(kwargs.pop(target.__plaintext__))\n\n    # do not try to encrypt when plaintext is None\n    if plaintext is None:\n        return\n\n    ciphertext, key_ids = encryptor.encrypt(encryption_context_key, plaintext)\n    target.ciphertext = (ciphertext, key_ids)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef on_load(target: \"EncryptableMixin\", context):\n    decrypt, plaintext = decrypt_instance(target)\n    if decrypt:\n        target.plaintext = plaintext", "response": "Decrypt SQLAlchemy s instance load event."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nregisters this encryptable with an encryptor.", "response": "def register(cls, encryptor: Encryptor):\n        \"\"\"\n        Register this encryptable with an encryptor.\n\n        Instances of this encryptor will be encrypted on initialization and decrypted on load.\n\n        \"\"\"\n        # save the current encryptor statically\n        cls.__encryptor__ = encryptor\n\n        # NB: we cannot use the before_insert listener in conjunction with a foreign key relationship\n        # for encrypted data; SQLAlchemy will warn about using 'related attribute set' operation so\n        # late in its insert/flush process.\n        listeners = dict(\n            init=on_init,\n            load=on_load,\n        )\n\n        for name, func in listeners.items():\n            # If we initialize the graph multiple times (as in many unit testing scenarios),\n            # we will accumulate listener functions -- with unpredictable results. As protection,\n            # we need to remove existing listeners before adding new ones; this solution only\n            # works if the id (e.g. memory address) of the listener does not change, which means\n            # they cannot be closures around the `encryptor` reference.\n            #\n            # Hence the `__encryptor__` hack above...\n            if contains(cls, name, func):\n                remove(cls, name, func)\n            listen(cls, name, func)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nodes_map(self):\n        dct = dict()\n        for node in self.nodes.values():\n            cls = next(base for base in getmro(node.__class__) if \"__tablename__\" in base.__dict__)\n            key = getattr(cls, \"__alias__\", underscore(cls.__name__))\n            dct.setdefault(key, []).append(node)\n        return dct", "response": "Build a mapping from node type to a list of nodes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_edges(self):\n        self.edges = [\n            edge if isinstance(edge, Edge) else Edge(*edge)\n            for node in self.nodes.values()\n            for edge in getattr(node, \"edges\", [])\n            if edge[0] in self.nodes and edge[1] in self.nodes\n        ]\n        return self", "response": "Build edges based on node edges property."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clone(self, ignore=()):\n        nodes = [\n            clone(node, self.substitutions, ignore)\n            for node in toposorted(self.nodes, self.edges)\n        ]\n        return DAG(nodes=nodes, substitutions=self.substitutions).build_edges()", "response": "Clone this dag using a set of substitutions."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef explain(self, **kwargs):\n        root = self.retrieve_root(**kwargs)\n        children = self.iter_children(root, **kwargs)\n        dag = DAG.from_nodes(root, *children)\n        return self.add_edges(dag)", "response": "Generate a dry run DAG of that state that WILL be cloned."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchooses the database name to use.", "response": "def choose_database_name(metadata, config):\n    \"\"\"\n    Choose the database name to use.\n\n    As a default, databases should be named after the service that uses them. In addition,\n    database names should be different between unit testing and runtime so that there is\n    no chance of a unit test dropping a real database by accident.\n\n    \"\"\"\n    if config.database_name is not None:\n        # we allow -- but do not encourage -- database name configuration\n        return config.database_name\n\n    if metadata.testing:\n        # by convention, we provision different databases for unit testing and runtime\n        return f\"{metadata.name}_test_db\"\n\n    return f\"{metadata.name}_db\""}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nchoose the database username to use.", "response": "def choose_username(metadata, config):\n    \"\"\"\n    Choose the database username to use.\n\n    Because databases should not be shared between services, database usernames should be\n    the same as the service that uses them.\n\n    \"\"\"\n    if config.username is not None:\n        # we allow -- but do not encourage -- database username configuration\n        return config.username\n\n    if config.read_only:\n        # by convention, we provision read-only username for every service\n        return f\"{metadata.name}_ro\"\n\n    return metadata.name"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchooses the database URI to use.", "response": "def choose_uri(metadata, config):\n    \"\"\"\n    Choose the database URI to use.\n\n    \"\"\"\n    database_name = choose_database_name(metadata, config)\n    driver = config.driver\n    host, port = config.host, config.port\n    username, password = choose_username(metadata, config), config.password\n\n    return f\"{driver}://{username}:{password}@{host}:{port}/{database_name}\""}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef choose_connect_args(metadata, config):\n    if not config.require_ssl and not config.verify_ssl:\n        return dict(\n            sslmode=\"prefer\",\n        )\n\n    if config.require_ssl and not config.verify_ssl:\n        return dict(\n            sslmode=\"require\",\n        )\n\n    if not config.ssl_cert_path:\n        raise Exception(\"SSL certificate path (`ssl_cert_path`) must be configured for verification\")\n\n    return dict(\n        sslmode=\"verify-full\",\n        sslrootcert=config.ssl_cert_path,\n    )", "response": "Choose the SSL mode and optional root cert for the connection."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nchoose database connection arguments.", "response": "def choose_args(metadata, config):\n    \"\"\"\n    Choose database connection arguments.\n\n    \"\"\"\n    return dict(\n        connect_args=choose_connect_args(metadata, config),\n        echo=config.echo,\n        max_overflow=config.max_overflow,\n        pool_size=config.pool_size,\n        pool_timeout=config.pool_timeout,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _members(self):\n        return {\n            key: value\n            for key, value in self.__dict__.items()\n            # NB: ignore internal SQLAlchemy state and nested relationships\n            if not key.startswith(\"_\") and not isinstance(value, Model)\n        }", "response": "Return a dict of non - private members."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninserting many items at once into a temporary table.", "response": "def insert_many(self, items):\n    \"\"\"\n    Insert many items at once into a temporary table.\n\n    \"\"\"\n    return SessionContext.session.execute(\n        self.insert(values=[\n            to_dict(item, self.c)\n            for item in items\n        ]),\n    ).rowcount"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef configure_key_provider(graph, key_ids):\n    if graph.metadata.testing:\n        # use static provider\n        provider = StaticMasterKeyProvider()\n        provider.add_master_keys_from_list(key_ids)\n        return provider\n\n    # use AWS provider\n    return KMSMasterKeyProvider(key_ids=key_ids)", "response": "Configure a key provider."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconfigure a crypto materials manager.", "response": "def configure_materials_manager(graph, key_provider):\n    \"\"\"\n    Configure a crypto materials manager\n\n    \"\"\"\n    if graph.config.materials_manager.enable_cache:\n        return CachingCryptoMaterialsManager(\n            cache=LocalCryptoMaterialsCache(graph.config.materials_manager.cache_capacity),\n            master_key_provider=key_provider,\n            max_age=graph.config.materials_manager.cache_max_age,\n            max_messages_encrypted=graph.config.materials_manager.cache_max_messages_encrypted,\n        )\n    return DefaultCryptoMaterialsManager(master_key_provider=key_provider)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates and drop databases.", "response": "def main(graph):\n    \"\"\"\n    Create and drop databases.\n\n    \"\"\"\n    args = parse_args(graph)\n\n    if args.drop:\n        drop_all(graph)\n    create_all(graph)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_lattice_type(cryst):\n    '''Find the symmetry of the crystal using spglib symmetry finder.\n\n    Derive name of the space group and its number extracted from the result.\n    Based on the group number identify also the lattice type and the Bravais\n    lattice of the crystal. The lattice type numbers are\n    (the numbering starts from 1):\n\n    Triclinic (1), Monoclinic (2), Orthorombic (3),\n    Tetragonal (4), Trigonal (5), Hexagonal (6), Cubic (7)\n\n    :param cryst: ASE Atoms object\n\n    :returns: tuple (lattice type number (1-7), lattice name, space group\n                     name, space group number)\n    '''\n\n    # Table of lattice types and correcponding group numbers dividing\n    # the ranges. See get_lattice_type method for precise definition.\n    lattice_types = [\n            [3,   \"Triclinic\"],\n            [16,  \"Monoclinic\"],\n            [75,  \"Orthorombic\"],\n            [143, \"Tetragonal\"],\n            [168, \"Trigonal\"],\n            [195, \"Hexagonal\"],\n            [231, \"Cubic\"]\n        ]\n\n    sg = spg.get_spacegroup(cryst)\n    m = re.match(r'([A-Z].*\\b)\\s*\\(([0-9]*)\\)', sg)\n    sg_name = m.group(1)\n    sg_nr = int(m.group(2))\n\n    for n, l in enumerate(lattice_types):\n        if sg_nr < l[0]:\n            bravais = l[1]\n            lattype = n+1\n            break\n\n    return lattype, bravais, sg_name, sg_nr", "response": "Find the symmetry of the crystal using spglib symmetry finder."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_bulk_modulus(cryst):\n    '''Calculate bulk modulus using the Birch-Murnaghan equation of state.\n\n    The EOS must be previously calculated by get_BM_EOS routine.\n    The returned bulk modulus is a :math:`B_0` coefficient of the B-M EOS.\n    The units of the result are defined by ASE. To get the result in\n    any particular units (e.g. GPa) you need to divide it by\n    ase.units.<unit name>::\n\n        get_bulk_modulus(cryst)/ase.units.GPa\n\n    :param cryst: ASE Atoms object\n\n    :returns: float, bulk modulus :math:`B_0` in ASE units.\n    '''\n\n    if getattr(cryst, 'bm_eos', None) is None:\n        raise RuntimeError('Missing B-M EOS data.')\n    cryst.bulk_modulus = cryst.bm_eos[1]\n    return cryst.bulk_modulus", "response": "Calculates the bulk modulus using the Birch - Murnaghan equation of state."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_BM_EOS(cryst, systems):\n\n    pvdat = array([[r.get_volume(),\n                    get_pressure(r.get_stress()),\n                    norm(r.get_cell()[:, 0]),\n                    norm(r.get_cell()[:, 1]),\n                    norm(r.get_cell()[:, 2])] for r in systems]).T\n\n    # Estimate the initial guess assuming b0p=1\n    # Limiting volumes\n    v1 = min(pvdat[0])\n    v2 = max(pvdat[0])\n\n    # The pressure is falling with the growing volume\n    p2 = min(pvdat[1])\n    p1 = max(pvdat[1])\n    b0 = (p1*v1-p2*v2)/(v2-v1)\n    v0 = v1*(p1+b0)/b0\n\n    # Initial guess\n    p0 = [v0, b0, 1]\n\n    # Fitting\n    try :\n        p1, succ = optimize.curve_fit(BMEOS, pvdat[0], pvdat[1], p0)\n    except (ValueError, RuntimeError, optimize.OptimizeWarning) as ex:\n        raise RuntimeError('Calculation failed')\n\n    cryst.bm_eos = p1\n    cryst.pv = pvdat\n    return cryst.bm_eos", "response": "Calculates the Birch - Murnaghan Equation of State for the crystal."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates elementary deformations for elastic tensor calculation.", "response": "def get_elementary_deformations(cryst, n=5, d=2):\n    '''Generate elementary deformations for elastic tensor calculation.\n\n    The deformations are created based on the symmetry of the crystal and\n    are limited to the non-equivalet axes of the crystal.\n\n    :param cryst: Atoms object, basic structure\n    :param n: integer, number of deformations per non-equivalent axis\n    :param d: float, size of the maximum deformation in percent and degrees\n\n    :returns: list of deformed structures\n    '''\n    # Deformation look-up table\n    # Perhaps the number of deformations for trigonal\n    # system could be reduced to [0,3] but better safe then sorry\n    deform = {\n        \"Cubic\": [[0, 3], regular],\n        \"Hexagonal\": [[0, 2, 3, 5], hexagonal],\n        \"Trigonal\": [[0, 1, 2, 3, 4, 5], trigonal],\n        \"Tetragonal\": [[0, 2, 3, 5], tetragonal],\n        \"Orthorombic\": [[0, 1, 2, 3, 4, 5], orthorombic],\n        \"Monoclinic\": [[0, 1, 2, 3, 4, 5], monoclinic],\n        \"Triclinic\": [[0, 1, 2, 3, 4, 5], triclinic]\n    }\n\n    lattyp, brav, sg_name, sg_nr = get_lattice_type(cryst)\n    # Decide which deformations should be used\n    axis, symm = deform[brav]\n\n    systems = []\n    for a in axis:\n        if a < 3:  # tetragonal deformation\n            for dx in linspace(-d, d, n):\n                systems.append(\n                        get_cart_deformed_cell(cryst, axis=a, size=dx))\n        elif a < 6:  # sheer deformation (skip the zero angle)\n            for dx in linspace(d/10.0, d, n):\n                systems.append(\n                        get_cart_deformed_cell(cryst, axis=a, size=dx))\n    return systems"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the elastic tensor of the crystal.", "response": "def get_elastic_tensor(cryst, systems):\n    '''Calculate elastic tensor of the crystal.\n\n    The elastic tensor is calculated from the stress-strain relation\n    and derived by fitting this relation to the set of linear equations\n    build from the symmetry of the crystal and strains and stresses\n    of the set of elementary deformations of the unit cell.\n\n    It is assumed that the crystal is converged and optimized\n    under intended pressure/stress. The geometry and stress on the\n    cryst is taken as the reference point. No additional optimization\n    will be run. Structures in cryst and systems list must have calculated\n    stresses. The function returns tuple of :math:`C_{ij}` elastic tensor,\n    raw Birch coefficients :math:`B_{ij}` and fitting results: residuals,\n    solution rank, singular values returned by numpy.linalg.lstsq.\n\n    :param cryst: Atoms object, basic structure\n    :param systems: list of Atoms object with calculated deformed structures\n\n    :returns: tuple(:math:`C_{ij}` float vector,\n                    tuple(:math:`B_{ij}` float vector, residuals, solution rank, singular values))\n    '''\n\n    # Deformation look-up table\n    # Perhaps the number of deformations for trigonal\n    # system could be reduced to [0,3] but better safe then sorry\n    deform = {\n        \"Cubic\": [[0, 3], regular],\n        \"Hexagonal\": [[0, 2, 3, 5], hexagonal],\n        \"Trigonal\": [[0, 1, 2, 3, 4, 5], trigonal],\n        \"Tetragonal\": [[0, 2, 3, 5], tetragonal],\n        \"Orthorombic\": [[0, 1, 2, 3, 4, 5], orthorombic],\n        \"Monoclinic\": [[0, 1, 2, 3, 4, 5], monoclinic],\n        \"Triclinic\": [[0, 1, 2, 3, 4, 5], triclinic]\n    }\n\n    lattyp, brav, sg_name, sg_nr = get_lattice_type(cryst)\n    # Decide which deformations should be used\n    axis, symm = deform[brav]\n\n    ul = []\n    sl = []\n    p = get_pressure(cryst.get_stress())\n    for g in systems:\n        ul.append(get_strain(g, refcell=cryst))\n        # Remove the ambient pressure from the stress tensor\n        sl.append(g.get_stress()-array([p, p, p, 0, 0, 0]))\n    # print(symm, ul)\n    eqm = array([symm(u) for u in ul])\n    # print(eqm)\n    # print(eqm[0].shape, eqm.shape)\n    eqm = reshape(eqm, (eqm.shape[0]*eqm.shape[1], eqm.shape[2]))\n    # print(eqm)\n    slm = reshape(array(sl), (-1,))\n    # print(eqm.shape, slm.shape)\n    # print(slm)\n    Bij = lstsq(eqm, slm)\n    # print(Bij[0] / units.GPa)\n    # Calculate elastic constants from Birch coeff.\n    # TODO: Check the sign of the pressure array in the B <=> C relation\n    if (symm == orthorombic):\n        Cij = Bij[0] - array([-p, -p, -p, p, p, p, -p, -p, -p])\n    elif (symm == tetragonal):\n        Cij = Bij[0] - array([-p, -p, p, p, -p, -p])\n    elif (symm == regular):\n        Cij = Bij[0] - array([-p, p, -p])\n    elif (symm == trigonal):\n        Cij = Bij[0] - array([-p, -p, p, p, -p, p])\n    elif (symm == hexagonal):\n        Cij = Bij[0] - array([-p, -p, p, p, -p])\n    elif (symm == monoclinic):\n        # TODO: verify this pressure array\n        Cij = Bij[0] - array([-p, -p, -p, p, p, p, -p, -p, -p, p, p, p, p])\n    elif (symm == triclinic):\n        # TODO: verify this pressure array\n        Cij = Bij[0] - array([-p, -p, -p, p, p, p, -p, -p, -p,\n                              p, p, p, p, p, p, p, p, p])\n    return Cij, Bij"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nscanning the pressure axis from lo to hi in GPa", "response": "def scan_pressures(cryst, lo, hi, n=5, eos=None):\n    '''\n    Scan the pressure axis from lo to hi (inclusive)\n    using B-M EOS as the volume predictor.\n    Pressure (lo, hi) in GPa\n    '''\n    # Inverse B-M EOS to get volumes from pressures\n    # This will work only in limited pressure range p>-B/B'.\n    # Warning! Relative, the V0 prefactor is removed.\n    def invbmeos(b, bp, x):\n        return array([pow(b/(bp*xv+b), 1/(3*bp)) for xv in x])\n\n    if eos is None:\n        raise RuntimeError('Required EOS data missing')\n\n    # Limit negative pressures to 90% of the singularity value.\n    # Beyond this B-M EOS is bound to be wrong anyway.\n    lo = max(lo, -0.9*eos[1]/eos[2])\n\n    scale = (eos[0]/cryst.get_volume())*invbmeos(eos[1], eos[2],\n                                                 linspace(lo, hi, num=n))\n    # print(scale)\n    uc = cryst.get_cell()\n    systems = [Atoms(cryst) for s in scale]\n    for n, s in enumerate(scale):\n        systems[n].set_cell(s*uc, scale_atoms=True)\n\n    return systems"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprovides set of crystals along volume axis from lo to hi (inclusive). No volume cell optimization is performed. Bounds are specified as fractions (1.10 = 10% increase). If scale_volumes==False the scalling is applied to lattice vectors instead of volumes. :param lo: lower bound of the V/V_0 in the scan :param hi: upper bound of the V/V_0 in the scan :param n: number of volume sample points :param scale_volumes: If True scale the unit cell volume or, if False, scale the length of lattice axes. :returns: a list of deformed systems", "response": "def scan_volumes(cryst, lo=0.98, hi=1.02, n=5, scale_volumes=True):\n    '''\n    Provide set of crystals along volume axis from lo to hi (inclusive).\n    No volume cell optimization is performed. Bounds are specified as\n    fractions (1.10 = 10% increase). If scale_volumes==False the scalling\n    is applied to lattice vectors instead of volumes.\n\n    :param lo: lower bound of the V/V_0 in the scan\n    :param hi: upper bound of the V/V_0 in the scan\n    :param n: number of volume sample points\n    :param scale_volumes: If True scale the unit cell volume or,\n                            if False, scale the length of lattice axes.\n\n    :returns: a list of deformed systems\n    '''\n    scale = linspace(lo, hi, num=n)\n    if scale_volumes:\n        scale **= (1.0/3.0)\n    uc = cryst.get_cell()\n    systems = [Atoms(cryst) for s in scale]\n    for n, s in enumerate(scale):\n        systems[n].set_cell(s*uc, scale_atoms=True)\n    return systems"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute A B C alpha beta gamma cell params from the unit cell matrix uc or cryst.", "response": "def get_vecang_cell(cryst, uc=None):\n    '''\n    Compute A,B,C, alpha,beta,gamma cell params\n    from the unit cell matrix (uc) or cryst.\n    Angles in radians.\n    '''\n    if uc is None:\n        uc = cryst.get_cell()\n    ucv = [uc[i, :]/norm(uc[i, :]) for i in range(3)]\n    uca = [acos(dot(ucv[(i+1) % 3], ucv[(i+2) % 3])) for i in range(3)]\n    return [norm(uc[i, :]) for i in range(3)] + uca"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_deformed_cell(base_cryst, axis=0, size=1):\n    '''\n    Return the cell (with atoms) deformed along one\n    cell parameter (0,1,2 = a,b,c ; 3,4,5 = alpha,beta,gamma) by\n    size percent or size degrees (axis/angles).\n    '''\n    cryst = Atoms(base_cryst)\n    uc = base_cryst.get_cell()\n    if axis < 3:\n        uc[axis, :] = (1+size/100.0)*uc[axis, :]\n    else:\n        (a, b, c, alp, bet, gam) = get_vecang_cell(cryst)\n        d = array([0.0, 0.0, 0.0])\n        d[axis-3] = pi*size/180\n        (alp, bet, gam) = array((alp, bet, gam))+d\n        t = 1 - (ctg(bet)*ctg(gam)-cos(alp)*csc(bet)*csc(gam))**2\n        if t < 0.0:\n            print('''\n            The parameters (alpha,beta,gamma)=(%f,%f,%f) are probably\n            incorrect and lead to imaginary coordinates.\n            This range of parameters is unsupported by this program\n            (and is, let me say, very strange for a crystal).\n            Cennot continue, bye.''' % (alp, bet, gam))\n            raise ValueError\n        else:\n            uc = [[a, 0.0, 0.0],\n                  [b*cos(gam), b*sin(gam), 0],\n                  [c*cos(bet),\n                   c*(cos(alp)/sin(gam) - cos(bet)*ctg(gam)),\n                   c*sin(bet)*sqrt(t)]]\n    cryst.set_cell(uc, scale_atoms=True)\n    # print(cryst.get_cell())\n    # print(uc)\n    return cryst", "response": "Return the cell deformed along one Arc."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_cart_deformed_cell(base_cryst, axis=0, size=1):\n    '''Return the cell deformed along one of the cartesian directions\n\n    Creates new deformed structure. The deformation is based on the\n    base structure and is performed along single axis. The axis is\n    specified as follows: 0,1,2 = x,y,z ; sheers: 3,4,5 = yz, xz, xy.\n    The size of the deformation is in percent and degrees, respectively.\n\n    :param base_cryst: structure to be deformed\n    :param axis: direction of deformation\n    :param size: size of the deformation\n\n    :returns: new, deformed structure\n    '''\n    cryst = Atoms(base_cryst)\n    uc = base_cryst.get_cell()\n    s = size/100.0\n    L = diag(ones(3))\n    if axis < 3:\n        L[axis, axis] += s\n    else:\n        if axis == 3:\n            L[1, 2] += s\n        elif axis == 4:\n            L[0, 2] += s\n        else:\n            L[0, 1] += s\n    uc = dot(uc, L)\n    cryst.set_cell(uc, scale_atoms=True)\n    # print(cryst.get_cell())\n    # print(uc)\n    return cryst", "response": "Return the cell deformed along one of the cartesian directions\n    Creates new deformed structure and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the strain tensor in the Voight notation as a conventional 6 - vector.", "response": "def get_strain(cryst, refcell=None):\n    '''Calculate strain tensor in the Voight notation\n\n    Computes the strain tensor in the Voight notation as a conventional\n    6-vector. The calculation is done with respect to the crystal\n    geometry passed in refcell parameter.\n\n    :param cryst: deformed structure\n    :param refcell: reference, undeformed structure\n\n    :returns: 6-vector of strain tensor in the Voight notation\n    '''\n    if refcell is None:\n        refcell = cryst\n    du = cryst.get_cell()-refcell.get_cell()\n    m = refcell.get_cell()\n    m = inv(m)\n    u = dot(m, du)\n    u = (u+u.T)/2\n    return array([u[0, 0], u[1, 1], u[2, 2], u[2, 1], u[2, 0], u[1, 0]])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef work_dir(path):\n    '''\n    Context menager for executing commands in some working directory.\n    Returns to the previous wd when finished.\n\n    Usage:\n    >>> with work_dir(path):\n    ...   subprocess.call('git status')\n\n    '''\n    starting_directory = os.getcwd()\n    try:\n        os.chdir(path)\n        yield\n    finally:\n        os.chdir(starting_directory)", "response": "Context menager for executing commands in some working directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ParCalculate(systems,calc,cleanup=True,block=True,prefix=\"Calc_\"):\n    '''\n    Run calculators in parallel for all systems.\n    Calculators are executed in isolated processes and directories.\n    The resulting objects are returned in the list (one per input system).\n    '''\n\n    if type(systems) != type([]) :\n        sysl=[systems]\n    else :\n        sysl=systems\n\n    if block :\n        iq=Queue(len(sysl)+1)\n        oq=Queue(len(sysl)+1)\n\n        # Create workers\n        for s in sysl:\n            __PCalcProc(iq, oq, calc, prefix=prefix, cleanup=cleanup).start()\n\n        # Put jobs into the queue\n        for n,s in enumerate(sysl):\n            iq.put([n,s])\n            # Protection against too quick insertion\n            time.sleep(0.2)\n\n        if verbose :\n            print(\"Workers started:\", len(sysl))\n\n       # Collect the results\n        res=[]\n        while len(res)<len(sysl) :\n            n,s=oq.get()\n            res.append([n,s])\n            #print(\"Got from oq:\", n, s.get_volume(), s.get_pressure())\n    else :\n        # We do not need the multiprocessing complications for non-blocking\n        # workers. We just run all in sequence.\n        basedir=os.getcwd()\n        res=[]\n        for n,s in enumerate(sysl):\n            s.set_calculator(deepcopy(calc))\n            s.get_calculator().block=block\n            place=tempfile.mkdtemp(prefix=prefix, dir=basedir)\n            os.chdir(place)\n            s.get_calculator().working_dir=place\n            #print(\"Start at :\", place)\n            if hasattr(calc, 'name') and calc.name=='Siesta':\n                s.get_potential_energy()\n            else:\n                s.get_calculator().calculate(s)\n            os.chdir(basedir)\n            #print(\"Submited\", s.get_calculator().calc_finished(), os.getcwd())\n            # Protection against too quick insertion\n            time.sleep(0.2)\n            res.append([n,s])\n        if verbose :\n            print(\"Workers started:\", len(sysl))\n\n    return [r for ns,s in enumerate(sysl) for nr,r in res if nr==ns]", "response": "This function runs calculations in parallel for all systems."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prepare_calc_dir(self):\n        '''\n        Prepare the calculation directory for VASP execution.\n        This needs to be re-implemented for each local setup.\n        The following code reflects just my particular setup.\n        '''\n        with open(\"vasprun.conf\",\"w\") as f:\n            f.write('NODES=\"nodes=%s:ppn=%d\"\\n' % (self.nodes, self.ppn))\n            f.write('BLOCK=%d\\n' % (self.block,))\n            if self.ncl :\n                f.write('NCL=%d\\n' % (1,))", "response": "Prepare the calculation directory for VASP execution."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if the lockfile is in the calculation directory and if it is finished check if the job is still running and if it is crashed check if it is still true and return True otherwise return False", "response": "def calc_finished(self):\n        '''\n        Check if the lockfile is in the calculation directory.\n        It is removed by the script at the end regardless of the\n        success of the calculation. This is totally tied to\n        implementation and you need to implement your own scheme!\n        '''\n        #print_stack(limit=5)\n        if not self.calc_running :\n            #print('Calc running:',self.calc_running)\n            return True\n        else:\n            # The calc is marked as running check if this is still true\n            # We do it by external scripts. You need to write these\n            # scripts for your own system.\n            # See examples/scripts directory for examples.\n            with work_dir(self.working_dir) :\n                o=check_output(['check-job'])\n            #print('Status',o)\n            if o[0] in b'R' :\n                # Still running - we do nothing to preserve the state\n                return False\n            else :\n                # The job is not running maybe it finished maybe crashed\n                # We hope for the best at this point ad pass to the\n                # Standard update function\n                return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_results(self):\n        \n        if self.submited:\n            # The job has been submitted. Check the state.\n            if not self.job_ready() :\n                if self.block :\n                    while not self.job_ready() :\n                        time.sleep(self.job_check_time)\n                else :\n                    raise CalcNotReadyError\n                    \n\n            # Assume the calc finished. Copy the files back.\n            subprocess.call(self.copy_in_cmd % {\n                'ldir': self.wdir,\n                'rdir': os.path.join(self.parameters['rdir'],os.path.split(self.directory)[-1]),\n                'user': self.parameters['user'],\n                'host': self.parameters['host']\n            }, shell=True)\n                \n        \n        fn=os.path.join(self.directory,'pw.out')\n        # Read the pan-ultimate line of the output file\n        try: \n            ln=open(fn).readlines()[-2]\n            if ln.find('JOB DONE.')>-1 :\n                # Job is done we can read the output\n                r=read_quantumespresso_textoutput(fn)\n                self.submited=False\n                self.jobid=None\n            else :\n                # Job not ready.\n                raise CalcNotReadyError\n        except (IOError, IndexError) :\n            # Job not ready.\n            raise CalcNotReadyError\n        \n        # All is fine - really read the results\n        self.calc.read_results(self)", "response": "Read the energy forces and... from output file ( s )."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns a series of calculations in parallel using implicitely ) some remote machine or cluster. The function returns the list of systems ready for the extraction of properties.", "response": "def ParallelCalculate(cls,syslst,properties=['energy'],system_changes=all_changes):\n        '''\n        Run a series of calculations in parallel using (implicitely) some \n        remote machine/cluster. The function returns the list of systems ready\n        for the extraction of calculated properties.\n        '''\n        print('Launching:',end=' ')\n        sys.stdout.flush()\n        for n,s in enumerate(syslst):\n            try :\n                s.calc.block=False\n                s.calc.calculate(atoms=s,properties=properties,system_changes=system_changes)\n            except CalcNotReadyError:\n                s.calc.block=True\n            print(n+1, end=' ')\n            sys.stdout.flush()\n        print()\n        print('     Done:', end=' ')\n        sys.stdout.flush()\n        for n,s in enumerate(syslst):\n            s.calc.read_results()\n            print( n+1, end=' ')\n            sys.stdout.flush()\n        print()\n        return syslst"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save_model(self, request, entry, form, change):\n        context = RequestContext(request)\n        try:\n            content = render_placeholder(entry.content_placeholder, context)\n            entry.content = content or ''\n        except KeyError:\n            # https://github.com/django-blog-zinnia/cmsplugin-zinnia/pull/61\n            entry.content = ''\n        super(EntryPlaceholderAdmin, self).save_model(\n            request, entry, form, change)", "response": "Fill the content field with the interpretation\n            of the placeholder\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn menu s node for entries", "response": "def get_nodes(self, request):\n        \"\"\"\n        Return menu's node for entries\n        \"\"\"\n        nodes = []\n        archives = []\n        attributes = {'hidden': HIDE_ENTRY_MENU}\n        for entry in Entry.published.all():\n            year = entry.creation_date.strftime('%Y')\n            month = entry.creation_date.strftime('%m')\n            month_text = format(entry.creation_date, 'b').capitalize()\n            day = entry.creation_date.strftime('%d')\n\n            key_archive_year = 'year-%s' % year\n            key_archive_month = 'month-%s-%s' % (year, month)\n            key_archive_day = 'day-%s-%s-%s' % (year, month, day)\n\n            if key_archive_year not in archives:\n                nodes.append(NavigationNode(\n                    year, reverse('zinnia:entry_archive_year', args=[year]),\n                    key_archive_year, attr=attributes))\n                archives.append(key_archive_year)\n\n            if key_archive_month not in archives:\n                nodes.append(NavigationNode(\n                    month_text,\n                    reverse('zinnia:entry_archive_month', args=[year, month]),\n                    key_archive_month, key_archive_year,\n                    attr=attributes))\n                archives.append(key_archive_month)\n\n            if key_archive_day not in archives:\n                nodes.append(NavigationNode(\n                    day, reverse('zinnia:entry_archive_day',\n                                 args=[year, month, day]),\n                    key_archive_day, key_archive_month,\n                    attr=attributes))\n                archives.append(key_archive_day)\n\n            nodes.append(NavigationNode(entry.title, entry.get_absolute_url(),\n                                        entry.pk, key_archive_day))\n        return nodes"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_nodes(self, request):\n        nodes = []\n        nodes.append(NavigationNode(_('Categories'),\n                                    reverse('zinnia:category_list'),\n                                    'categories'))\n        for category in Category.objects.all():\n            nodes.append(NavigationNode(category.title,\n                                        category.get_absolute_url(),\n                                        category.pk, 'categories'))\n        return nodes", "response": "Return a list of nodes for the current resource."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of nodes for the authors and authors list", "response": "def get_nodes(self, request):\n        \"\"\"\n        Return menu's node for authors\n        \"\"\"\n        nodes = []\n        nodes.append(NavigationNode(_('Authors'),\n                                    reverse('zinnia:author_list'),\n                                    'authors'))\n        for author in Author.published.all():\n            nodes.append(NavigationNode(author.__str__(),\n                                        author.get_absolute_url(),\n                                        author.pk, 'authors'))\n        return nodes"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_nodes(self, request):\n        nodes = []\n        nodes.append(NavigationNode(_('Tags'), reverse('zinnia:tag_list'),\n                                    'tags'))\n        for tag in tags_published():\n            nodes.append(NavigationNode(tag.name,\n                                        reverse('zinnia:tag_detail',\n                                                args=[tag.name]),\n                                        tag.pk, 'tags'))\n        return nodes", "response": "Return a list of nodes for the current resource."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmodifying nodes of a menu", "response": "def modify(self, request, nodes, namespace, root_id, post_cut, breadcrumb):\n        \"\"\"\n        Modify nodes of a menu\n        \"\"\"\n        if breadcrumb:\n            return nodes\n        for node in nodes:\n            if node.attr.get('hidden'):\n                node.visible = False\n        return nodes"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef render(self, context, instance, placeholder):\n        context = super(CMSSelectedEntriesPlugin, self).render(\n            context, instance, placeholder)\n        context['entries'] = instance.entries.all()\n        return context", "response": "Update the context with the data of the selected entries."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef render(self, context, instance, placeholder):\n        context = super(CMSRandomEntriesPlugin, self).render(\n            context, instance, placeholder)\n        context['template_to_render'] = (str(instance.template_to_render) or\n                                         'zinnia/tags/entries_random.html')\n        return context", "response": "Update the context with the data available in the current instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the context with the data from the CMSQueryEntries plugin s data.", "response": "def render(self, context, instance, placeholder):\n        \"\"\"\n        Update the context with plugin's data\n        \"\"\"\n        entries = Entry.published.search(instance.query)\n        if instance.number_of_entries:\n            entries = entries[:instance.number_of_entries]\n\n        context = super(CMSQueryEntriesPlugin, self).render(\n            context, instance, placeholder)\n        context['entries'] = entries\n        return context"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef acquire_context(self):\n        frame = None\n        request = None\n\n        try:\n            for f in inspect.stack()[1:]:\n                frame = f[0]\n                args, varargs, keywords, alocals = inspect.getargvalues(frame)\n                if not request and 'request' in args:\n                    request = alocals['request']\n                if 'context' in args:\n                    return alocals['context']\n        finally:\n            del frame\n\n        return RequestContext(request)", "response": "Get the current context used by the current user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef html_content(self):\n        context = self.acquire_context()\n        try:\n            return render_placeholder(self.content_placeholder, context)\n        except (AttributeError, KeyError):\n            # Should happen when ``context`` and ``request``\n            # have not been found in the stack.\n            pass\n        return self.content", "response": "Render the content of the content_placeholder field dynamicly."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dkim_sign(message):\n\n    if not HAS_DKIM:\n        return message\n\n    if not (DKIM_DOMAIN and DKIM_PRIVATE_KEY):\n        return message\n\n    sig = dkim.sign(\n        message,\n        DKIM_SELECTOR,\n        DKIM_DOMAIN,\n        DKIM_PRIVATE_KEY,\n        include_headers=DKIM_HEADERS)\n    return sig + message", "response": "Signs a message using dkim."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprinting some basic quota statistics.", "response": "def _print_quota(self, conn):\n        \"\"\"\n        Prints some basic quota statistics.\n        \"\"\"\n        quota = conn.get_send_quota()\n        quota = quota['GetSendQuotaResponse']['GetSendQuotaResult']\n        \n        print \"--- SES Quota ---\"\n        print \"  24 Hour Quota: %s\" % quota['Max24HourSend']\n        print \"  Sent (Last 24 hours): %s\" % quota['SentLast24Hours']\n        print \"  Max sending rate: %s/sec\" % quota['MaxSendRate']"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _print_daily_stats(self, conn):\n        stats = conn.get_send_statistics()\n        stats = stats['GetSendStatisticsResponse']['GetSendStatisticsResult']\n        stats = stats['SendDataPoints']\n        \n        today = datetime.date.today()\n        current_day = {'HeaderName': 'Current Day: %s/%s' % (today.month, \n                                                             today.day)}\n        prev_day = {'HeaderName': 'Past two weeks'}\n        \n        for data_point in stats:\n            if self._is_data_from_today(data_point):\n                day_dict = current_day\n            else:\n                day_dict = prev_day\n                \n            self._update_day_dict(data_point, day_dict)      \n\n        for day in [current_day, prev_day]:\n            print \"--- %s ---\" % day.get('HeaderName', 0)\n            print \"  Delivery attempts: %s\" % day.get('DeliveryAttempts', 0)\n            print \"  Bounces: %s\" % day.get('Bounces', 0)\n            print \"  Rejects: %s\" % day.get('Rejects', 0)\n            print \"  Complaints: %s\" % day.get('Complaints', 0)", "response": "Prints a Today / Last 24 hour stats section."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if this data_point is talking about the current date False otherwise.", "response": "def _is_data_from_today(self, data_point):\n        \"\"\"\n        Takes a DataPoint from SESConnection.get_send_statistics() and returns\n        True if it is talking about the current date, False if not.\n        \n        :param dict data_point: The data point to consider.\n        :rtype: bool\n        :returns: True if this data_point is for today, False if not (probably\n            yesterday).\n        \"\"\"\n        today = datetime.date.today()\n        \n        raw_timestr = data_point['Timestamp']\n        dtime = datetime.datetime.strptime(raw_timestr, '%Y-%m-%dT%H:%M:%SZ')\n        return today.day == dtime.day"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _update_day_dict(self, data_point, day_dict):\n        for topic in ['Bounces', 'Complaints', 'DeliveryAttempts', 'Rejects']:\n            day_dict[topic] = day_dict.get(topic, 0) + int(data_point[topic])", "response": "Helper method for _print_daily_stats. Updates the day dict with the contents of the data point and the stats - tracking dict."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle the parse and validate commands.", "response": "def handle(self, *args, **options):\n        \"\"\"\n        Parses/validates, and breaks off into actions.\n        \"\"\"\n        if len(args) < 1:\n            raise CommandError(\"Please specify an action. See --help.\")\n\n        action = args[0]\n        email = None\n\n        if action not in self.valid_actions:\n            message = \"Invalid action: %s\" % action\n            raise CommandError(message)\n\n        if action in ['verify', 'delete']:\n            if len(args) < 2:\n                message = \"Please specify an email address to %s.\" % action\n                raise CommandError(message)\n\n            email = args[1]\n\n            if not email or not self._is_valid_email(email):\n                message = \"Invalid email address provided: %s\" % email\n                raise CommandError(message)\n\n        # Hand this off to the action routing method.\n        self._route_action(action, email)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _route_action(self, action, email):\n        connection = self._get_ses_connection()\n        if action == \"verify\":\n            connection.verify_email_address(email)\n            print(\"A verification email has been sent to %s.\" % email)\n        elif action == \"delete\":\n            connection.delete_verified_email_address(email)\n            print(\"You have deleted %s from your SES account.\" % email)\n        elif action == \"list\":\n            verified_result = connection.list_verified_email_addresses()\n            if len(verified_result.VerifiedEmailAddresses) > 0:\n                print(\"The following emails have been fully verified on your \"\\\n                      \"Amazon SES account:\")\n                for vemail in verified_result.VerifiedEmailAddresses:\n                    print (\"  %s\" % vemail)\n            else:\n                print(\"Your account has no fully verified email addresses yet.\")", "response": "This function is called by the user to route the action and email to the associated base class."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send_messages(self, email_messages):\n\n        queue = getattr(settings, 'CUCUMBER_ROUTE_QUEUE', '')\n        num_sent = 0\n        for message in email_messages:\n            # Hand this off to a celery task.\n            SendEmailTask.apply_async(args=[\n                    message.from_email,\n                    message.recipients(),\n                    message.message().as_string().decode('utf8'),], \n                queue=queue,\n            )\n            num_sent += 1\n        return num_sent", "response": "Sends one or more EmailMessage objects and returns the number of EmailMessages sent."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nruns a tabu search on a given binary quadratic model and return a sample of the most recent possible entry in the set of recently - set entries.", "response": "def sample(self, bqm, init_solution=None, tenure=None, scale_factor=1, timeout=20, num_reads=1):\n        \"\"\"Run a tabu search on a given binary quadratic model.\n\n        Args:\n            bqm (:obj:`~dimod.BinaryQuadraticModel`):\n                The binary quadratic model (BQM) to be sampled.\n            init_solution (:obj:`~dimod.SampleSet`, optional):\n                Single sample that sets an initial state for all the problem variables.\n                Default is a random initial state.\n            tenure (int, optional):\n                Tabu tenure, which is the length of the tabu list, or number of recently\n                explored solutions kept in memory.\n                Default is a quarter of the number of problem variables up to\n                a maximum value of 20.\n            scale_factor (number, optional):\n                Scaling factor for linear and quadratic biases in the BQM. Internally, the BQM is\n                converted to a QUBO matrix, and elements are stored as long ints\n                using ``internal_q = long int (q * scale_factor)``.\n            timeout (int, optional):\n                Total running time in milliseconds.\n            num_reads (int, optional): Number of reads. Each run of the tabu algorithm\n                generates a sample.\n\n        Returns:\n            :obj:`~dimod.SampleSet`: A `dimod` :obj:`.~dimod.SampleSet` object.\n\n        Examples:\n            This example provides samples for a two-variable QUBO model.\n\n            >>> from tabu import TabuSampler\n            >>> import dimod\n            >>> sampler = TabuSampler()\n            >>> Q = {(0, 0): -1, (1, 1): -1, (0, 1): 2}\n            >>> bqm = dimod.BinaryQuadraticModel.from_qubo(Q, offset=0.0)\n            >>> samples = sampler.sample(bqm)\n            >>> samples.record[0].energy\n            -1.0\n\n        \"\"\"\n\n        # input checking and defaults calculation\n        # TODO: one \"read\" per sample in init_solution sampleset\n        if init_solution is not None:\n            if not isinstance(init_solution, dimod.SampleSet):\n                raise TypeError(\"'init_solution' should be a 'dimod.SampleSet' instance\")\n            if len(init_solution.record) < 1:\n                raise ValueError(\"'init_solution' should contain at least one sample\")\n            if len(init_solution.record[0].sample) != len(bqm):\n                raise ValueError(\"'init_solution' sample dimension different from BQM\")\n            init_sample = self._bqm_sample_to_tabu_sample(\n                init_solution.change_vartype(dimod.BINARY, inplace=False).record[0].sample, bqm.binary)\n        else:\n            init_sample = None\n\n        if not bqm:\n            return dimod.SampleSet.from_samples([], energy=0, vartype=bqm.vartype)\n\n        if tenure is None:\n            tenure = max(min(20, len(bqm) // 4), 0)\n        if not isinstance(tenure, int):\n            raise TypeError(\"'tenure' should be an integer in range [0, num_vars - 1]\")\n        if not 0 <= tenure < len(bqm):\n            raise ValueError(\"'tenure' should be an integer in range [0, num_vars - 1]\")\n\n        if not isinstance(num_reads, int):\n            raise TypeError(\"'num_reads' should be a positive integer\")\n        if num_reads < 1:\n            raise ValueError(\"'num_reads' should be a positive integer\")\n\n        qubo = self._bqm_to_tabu_qubo(bqm.binary)\n\n        # run Tabu search\n        samples = []\n        energies = []\n        for _ in range(num_reads):\n            if init_sample is None:\n                init_sample = self._bqm_sample_to_tabu_sample(self._random_sample(bqm.binary), bqm.binary)\n            r = TabuSearch(qubo, init_sample, tenure, scale_factor, timeout)\n            sample = self._tabu_sample_to_bqm_sample(list(r.bestSolution()), bqm.binary)\n            energy = bqm.binary.energy(sample)\n            samples.append(sample)\n            energies.append(energy)\n\n        response = dimod.SampleSet.from_samples(\n            samples, energy=energies, vartype=dimod.BINARY)\n        response.change_vartype(bqm.vartype, inplace=True)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert sample to dict", "response": "def _sample_as_dict(self, sample):\n        \"\"\"Convert list-like ``sample`` (list/dict/dimod.SampleView),\n        ``list: var``, to ``map: idx -> var``.\n        \"\"\"\n        if isinstance(sample, dict):\n            return sample\n        if isinstance(sample, (list, numpy.ndarray)):\n            sample = enumerate(sample)\n        return dict(sample)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nuploads a GIF from a URL.", "response": "def upload_from_url(self, url):\n        \"\"\"\n        Upload a GIF from a URL.\n        \"\"\"\n        self.check_token()\n        \n        params = {'fetchUrl': url}\n        r = requests.get(FETCH_URL_ENDPOINT, params=params)\n\n        if r.status_code != 200:\n            raise GfycatClientError('Error fetching the URL', r.status_code)\n\n        response = r.json()\n        if 'error' in response:\n            raise GfycatClientError(response['error'])\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nuploads a local file to Gfycat", "response": "def upload_from_file(self, filename):\n        \"\"\"\n        Upload a local file to Gfycat\n        \"\"\"\n        key = str(uuid.uuid4())[:8]\n\n        form = [('key', key),\n                ('acl', ACL),\n                ('AWSAccessKeyId', AWS_ACCESS_KEY_ID),\n                ('success_action_status', SUCCESS_ACTION_STATUS),\n                ('signature', SIGNATURE),\n                ('Content-Type', CONTENT_TYPE),\n                ('policy', POLICY)]\n        data = dict(form)\n\n        files = {'file': open(filename, 'rb')}\n        r = requests.post(FILE_UPLOAD_ENDPOINT, data=data, files=files)\n\n        if r.status_code != 200:\n            raise GfycatClientError('Error uploading the GIF', r.status_code)\n\n        info = self.uploaded_file_info(key)\n        while 'timeout' in info.get('error', '').lower():\n            time.sleep(2)\n            info = self.uploaded_file_info(key)\n        if 'error' in info:\n            raise GfycatClientError(info['error'])\n\n        return info"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef uploaded_file_info(self, key):\n        r = requests.get(FILE_UPLOAD_STATUS_ENDPOINT + key)\n        if r.status_code != 200:\n            raise GfycatClientError('Unable to check the status',\n                                    r.status_code)\n\n        return r.json()", "response": "Get information about an uploaded GIF."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nquerying a gfy name for URLs and more information.", "response": "def query_gfy(self, gfyname):\n        \"\"\"\n        Query a gfy name for URLs and more information.\n        \"\"\"\n        self.check_token()\n        \n        r = requests.get(QUERY_ENDPOINT + gfyname, headers=self.headers)\n        \n        response = r.json()\n        \n        if r.status_code != 200 and not ERROR_KEY in response:\n            raise GfycatClientError('Bad response from Gfycat',\n                                    r.status_code)\n        elif ERROR_KEY in response:\n            raise GfycatClientError(response[ERROR_KEY], r.status_code)\n        \n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_link(self, link):\n        r = requests.get(CHECK_LINK_ENDPOINT + link)\n        if r.status_code != 200:\n            raise GfycatClientError('Unable to check the link',\n                                    r.status_code)\n\n        return r.json()", "response": "Check if a link has been already converted."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the authorization token for the current user", "response": "def get_token(self):\n        \"\"\"\n        Gets the authorization token\n        \"\"\"\n        \n        payload = {'grant_type': 'client_credentials', 'client_id': self.client_id, 'client_secret': self.client_secret}\n        r = requests.post(OAUTH_ENDPOINT, data=json.dumps(payload), headers={'content-type': 'application/json'})\n\t\t\n        response = r.json()\n        \n        if r.status_code != 200 and not ERROR_KEY in response:\n            raise GfycatClientError('Error fetching the OAUTH URL', r.status_code)\n        elif ERROR_KEY in response:\n            raise GfycatClientError(response[ERROR_KEY], r.status_code)\n        \n        self.token_type = response['token_type']\n        self.access_token = response['access_token']\n        self.expires_in = response['expires_in']\n        self.expires_at = time.time() + self.expires_in - 5\n        self.headers = {'content-type': 'application/json','Authorization': self.token_type + ' ' + self.access_token}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a dictionary representation of the metadata.", "response": "def dict(self):\n        \"\"\"\n        dictionary representation of the metadata.\n\n        :return: dictionary representation of the metadata\n        :rtype: dict\n        \"\"\"\n        metadata = {}\n        properties = {}\n        for name, prop in list(self.properties.items()):\n            properties[name] = prop.dict\n        metadata['properties'] = properties\n        return metadata"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the xml representation of the metadata.", "response": "def xml(self):\n        \"\"\"\n        xml representation of the metadata.\n\n        :return: xml representation of the metadata\n        :rtype: ElementTree.Element\n        \"\"\"\n        tree = ElementTree.parse(METADATA_XML_TEMPLATE)\n        root = tree.getroot()\n\n        for name, prop in list(self.properties.items()):\n            path = prop.xml_path\n            elem = root.find(path, XML_NS)\n            if elem is None:\n                # create elem\n                elem = insert_xml_element(root, path)\n            elem.text = self.get_xml_value(name)\n\n        return root"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the json representation of the metadata.", "response": "def json(self):\n        \"\"\"\n        json representation of the metadata.\n\n        :return: json representation of the metadata\n        :rtype: str\n        \"\"\"\n        json_dumps = json.dumps(\n            self.dict,\n            indent=2,\n            sort_keys=True,\n            separators=(',', ': '),\n            cls=MetadataEncoder\n        )\n        if not json_dumps.endswith('\\n'):\n            json_dumps += '\\n'\n        return json_dumps"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_json(self):\n        with reading_ancillary_files(self):\n            if self.json_uri is None:\n                metadata = self._read_json_db()\n            else:\n                metadata = self._read_json_file()\n            if 'properties' in metadata:\n                for name, prop in list(metadata['properties'].items()):\n                    try:\n                        self.set(prop['name'], prop['value'], prop['xml_path'])\n                    except KeyError:\n                        # we just skip if we don't have something, we want\n                        # to have as much as possible read from the JSON\n                        pass\n        return metadata", "response": "read metadata from json and set all the found properties"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _read_json_file(self):\n        with open(self.json_uri) as metadata_file:\n            try:\n                metadata = json.load(metadata_file)\n                return metadata\n            except ValueError:\n                message = tr('the file %s does not appear to be valid JSON')\n                message = message % self.json_uri\n                raise MetadataReadError(message)", "response": "read the json file and return the parsed json dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread metadata from a json string stored in a DB.", "response": "def _read_json_db(self):\n        \"\"\"\n        read metadata from a json string stored in a DB.\n\n        :return: the parsed json dict\n        :rtype: dict\n        \"\"\"\n        try:\n            metadata_str = self.db_io.read_metadata_from_uri(\n                self.layer_uri, 'json')\n        except HashNotFoundError:\n            return {}\n        try:\n            metadata = json.loads(metadata_str)\n            return metadata\n        except ValueError:\n            message = tr('the file DB entry for %s does not appear to be '\n                         'valid JSON')\n            message %= self.layer_uri\n            raise MetadataReadError(message)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread metadata from xml and set all the found properties", "response": "def read_xml(self):\n        \"\"\"\n        read metadata from xml and set all the found properties.\n\n        :return: the root element of the xml\n        :rtype: ElementTree.Element\n        \"\"\"\n        if self.xml_uri is None:\n            root = self._read_xml_db()\n        else:\n            root = self._read_xml_file()\n        if root is not None:\n            for name, path in list(self._standard_properties.items()):\n                value = read_property_from_xml(root, path)\n                if value is not None:\n                    # this calls the default setters\n                    setattr(self, name, value)\n\n        return root"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _read_xml_file(self):\n        # this raises a IOError if the file doesn't exist\n        root = ElementTree.parse(self.xml_uri)\n        root.getroot()\n        return root", "response": "read metadata from an xml file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads metadata from an xml string stored in a DB.", "response": "def _read_xml_db(self):\n        \"\"\"\n        read metadata from an xml string stored in a DB.\n\n        :return: the root element of the xml\n        :rtype: ElementTree.Element\n        \"\"\"\n        try:\n            metadata_str = self.db_io.read_metadata_from_uri(\n                self.layer_uri, 'xml')\n            root = ElementTree.fromstring(metadata_str)\n            return root\n        except HashNotFoundError:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the value of a metadata property.", "response": "def set(self, name, value, xml_path):\n        \"\"\"\n        Create a new metadata property.\n\n        The accepted type depends on the property type which is determined\n        by the xml_path\n\n        :param name: the name of the property\n        :type name: str\n        :param value: the value of the property\n        :type value:\n        :param xml_path: the xml path where the property should be stored.\n        This is split on / and the last element is used to determine the\n        property type\n        :type xml_path: str\n        \"\"\"\n\n        xml_type = xml_path.split('/')[-1]\n        # check if the desired type is supported\n        try:\n            property_class = TYPE_CONVERSIONS[xml_type]\n        except KeyError:\n            raise KeyError('The xml type %s is not supported yet' % xml_type)\n\n        try:\n            metadata_property = property_class(name, value, xml_path)\n            self._properties[name] = metadata_property\n            self.set_last_update_to_now()\n        except TypeError:\n            if self.reading_ancillary_files:\n                # we are parsing files so we want to accept as much as\n                # possible without raising exceptions\n                pass\n            else:\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsaves the metadata to a file or DB.", "response": "def save(self, save_json=True, save_xml=True):\n        \"\"\"\n        Saves the metadata json and/or xml to a file or DB.\n\n        :param save_json: flag to save json\n        :type save_json: bool\n        :param save_xml: flag to save xml\n        :type save_xml: bool\n        \"\"\"\n        if self.layer_is_file_based:\n            if save_json:\n                self.write_to_file(self.json_uri)\n            if save_xml:\n                self.write_to_file(self.xml_uri)\n        else:\n            self.write_to_db(save_json, save_xml)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_to_file(self, destination_path):\n        file_format = os.path.splitext(destination_path)[1][1:]\n        metadata = self.get_writable_metadata(file_format)\n\n        with open(destination_path, 'w', encoding='utf-8') as f:\n            f.write(metadata)\n\n        return metadata", "response": "Writes the metadata json or xml to a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites the metadata json and xml in a DB.", "response": "def write_to_db(self, save_json=True, save_xml=True):\n        \"\"\"\n        Stores the metadata json and/or xml in a DB.\n\n        The returned tuple can contain None.\n\n        :param save_json: flag to save json\n        :type save_json: bool\n        :param save_xml: flag to save xml\n        :type save_xml: bool\n        :return: the stored metadata\n        :rtype: (str, str)\n        \"\"\"\n        metadata_json = None\n        metadata_xml = None\n        if save_json:\n            metadata_json = self.get_writable_metadata('json')\n        if save_xml:\n            metadata_xml = self.get_writable_metadata('xml')\n        self.db_io.write_metadata_for_uri(\n            self.layer_uri, metadata_json, metadata_xml)\n        return metadata_json, metadata_xml"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_writable_metadata(self, file_format):\n        if file_format == 'json':\n            metadata = self.json\n        elif file_format == 'xml':\n            metadata = self.xml\n        else:\n            raise TypeError('The requested file type (%s) is not yet supported'\n                            % file_format)\n        return metadata", "response": "Convert the metadata to a writable form."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntries to read xml and json from an cillary file.", "response": "def read_from_ancillary_file(self, custom_xml=None):\n        \"\"\"\n        try to read xml and json from existing files or db.\n\n        This is used when instantiating a new metadata object. We explicitly\n        check if a custom XML was passed so we give it priority on the JSON.\n        If no custom XML is passed, JSON has priority\n\n        :param custom_xml: the path to a custom xml file\n        :type custom_xml: str\n        \"\"\"\n\n        if custom_xml and os.path.isfile(self.xml_uri):\n            self.read_xml()\n        else:\n            if not self.read_json():\n                self.read_xml()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets properties of metadata using key and value from keywords", "response": "def update_from_dict(self, keywords):\n        \"\"\"Set properties of metadata using key and value from keywords\n\n        :param keywords: A dictionary of keywords (key, value).\n        :type keywords: dict\n\n        \"\"\"\n        for key, value in list(keywords.items()):\n            setattr(self, key, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprocesses the layer for multi buffering and generate a new layer.", "response": "def accept(self):\n        \"\"\"Process the layer for multi buffering and generate a new layer.\n\n        .. note:: This is called on OK click.\n        \"\"\"\n        # set parameter from dialog\n        input_layer = self.layer.currentLayer()\n        output_path = self.output_form.text()\n        radius = self.get_classification()\n        # monkey patch keywords so layer works on multi buffering function\n        input_layer.keywords = {'inasafe_fields': {}}\n\n        # run multi buffering\n        self.output_layer = multi_buffering(input_layer, radius)\n\n        # save output layer to data store and check whether user\n        # provide the output path.\n        if output_path:\n            self.output_directory, self.output_filename = (\n                os.path.split(output_path))\n            self.output_filename, self.output_extension = (\n                os.path.splitext(self.output_filename))\n\n        # if user do not provide the output path, create a temporary file.\n        else:\n            self.output_directory = temp_dir(sub_dir='work')\n            self.output_filename = (\n                unique_filename(\n                    prefix='hazard_layer',\n                    suffix='.geojson',\n                    dir=self.output_directory))\n            self.output_filename = os.path.split(self.output_filename)[1]\n            self.output_filename, self.output_extension = (\n                os.path.splitext(self.output_filename))\n\n        self.data_store = Folder(self.output_directory)\n        if self.output_extension == '.shp':\n            self.data_store.default_vector_format = 'shp'\n        elif self.output_extension == '.geojson':\n            self.data_store.default_vector_format = 'geojson'\n        self.data_store.add_layer(self.output_layer, self.output_filename)\n\n        # add output layer to map canvas\n        self.output_layer = self.data_store.layer(self.output_filename)\n\n        QgsProject.instance().addMapLayers(\n            [self.output_layer])\n        self.iface.setActiveLayer(self.output_layer)\n        self.iface.zoomToActiveLayer()\n        self.done(QtWidgets.QDialog.Accepted)\n\n        if self.keyword_wizard_checkbox.isChecked():\n            self.launch_keyword_wizard()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npopulates output form with default output path based on input layer.", "response": "def get_output_from_input(self):\n        \"\"\"Populate output form with default output path based on input layer.\n        \"\"\"\n        input_path = self.layer.currentLayer().source()\n        output_path = (\n            os.path.splitext(input_path)[0] + '_multi_buffer'\n            + os.path.splitext(input_path)[1])\n        self.output_form.setText(output_path)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npopulates hazard classification on hazard class form.", "response": "def populate_hazard_classification(self):\n        \"\"\"Populate hazard classification on hazard class form.\"\"\"\n        new_class = {\n            'value': self.radius_form.value(),\n            'name': self.class_form.text()}\n        self.classification.append(new_class)\n        self.classification = sorted(\n            self.classification, key=itemgetter('value'))\n\n        self.hazard_class_form.clear()\n        for item in self.classification:\n            new_item = '{value} - {name}'.format(\n                value=item['value'], name=item['name'])\n            self.hazard_class_form.addItem(new_item)\n\n        self.radius_form.setValue(0)\n        self.class_form.clear()\n        self.ok_button_status()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves selected item on hazard class form.", "response": "def remove_selected_classification(self):\n        \"\"\"Remove selected item on hazard class form.\"\"\"\n        removed_classes = self.hazard_class_form.selectedItems()\n        current_item = self.hazard_class_form.currentItem()\n        removed_index = self.hazard_class_form.indexFromItem(current_item)\n        del self.classification[removed_index.row()]\n        for item in removed_classes:\n            self.hazard_class_form.takeItem(\n                self.hazard_class_form.row(item))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget all hazard class created by user.", "response": "def get_classification(self):\n        \"\"\"Get all hazard class created by user.\n\n        :return: Hazard class definition created by user.\n        :rtype: OrderedDict\n        \"\"\"\n        classification_dictionary = {}\n        for item in self.classification:\n            classification_dictionary[item['value']] = item['name']\n\n        classification_dictionary = OrderedDict(\n            sorted(classification_dictionary.items()))\n\n        return classification_dictionary"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfunctions to enable or disable directory button.", "response": "def directory_button_status(self):\n        \"\"\"Function to enable or disable directory button.\"\"\"\n        if self.layer.currentLayer():\n            self.directory_button.setEnabled(True)\n        else:\n            self.directory_button.setEnabled(False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfunctions to enable or disable add class button.", "response": "def add_class_button_status(self):\n        \"\"\"Function to enable or disable add class button.\"\"\"\n        if self.class_form.text() and self.radius_form.value() >= 0:\n            self.add_class_button.setEnabled(True)\n        else:\n            self.add_class_button.setEnabled(False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ok_button_status(self):\n        if not self.layer.currentLayer():\n            self.button_box.button(\n                QtWidgets.QDialogButtonBox.Ok).setEnabled(False)\n        elif (self.hazard_class_form.count() > 0\n              and self.layer.currentLayer().name()\n              and len(self.output_form.text()) >= 0):\n            self.button_box.button(\n                QtWidgets.QDialogButtonBox.Ok).setEnabled(True)\n        else:\n            self.button_box.button(\n                QtWidgets.QDialogButtonBox.Ok).setEnabled(False)", "response": "Function to enable or disable OK button."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef help_toggled(self, flag):\n        if flag:\n            self.help_button.setText(self.tr('Hide Help'))\n            self.show_help()\n        else:\n            self.help_button.setText(self.tr('Show Help'))\n            self.hide_help()", "response": "Show or hide the help tab in the stacked widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef convert_mmi_data(\n        grid_xml_path,\n        title,\n        source,\n        output_path=None,\n        algorithm=None,\n        algorithm_filename_flag=True,\n        smoothing_method=NONE_SMOOTHING,\n        smooth_sigma=0.9,\n        extra_keywords=None\n):\n    \"\"\"Convenience function to convert a single file.\n\n    :param grid_xml_path: Path to the xml shake grid file.\n    :type grid_xml_path: str\n\n    :param title: The title of the earthquake.\n    :type title: str\n\n    :param source: The source of the shake data.\n    :type source: str\n\n    :param place_layer: Nearby cities/places.\n    :type place_layer: QgsVectorLayer\n\n    :param place_name: Column name that indicates name of the cities.\n    :type place_name: str\n\n    :param place_population: Column name that indicates number of population.\n    :type place_population: str\n\n    :param output_path: Specify which path to use as an alternative to the\n        default.\n    :type output_path: str\n\n    :param algorithm: Type of algorithm to be used.\n    :type algorithm: str\n\n    :param algorithm_filename_flag: Flag whether to use the algorithm in the\n        output file's name.\n    :type algorithm_filename_flag: bool\n\n    :param smoothing_method: Smoothing method. One of None, Numpy, Scipy.\n    :type smoothing_method: basestring\n\n    :param smooth_sigma: parameter for gaussian filter used in smoothing\n        function.\n    :type smooth_sigma: float\n\n    :returns: A path to the resulting raster file.\n    :rtype: str\n    \"\"\"\n    LOGGER.debug(grid_xml_path)\n    LOGGER.debug(output_path)\n    if output_path is not None:\n        output_dir, output_basename = os.path.split(output_path)\n        output_basename, _ = os.path.splitext(output_basename)\n        LOGGER.debug(\n            'output_dir : '\n            + output_dir\n            + 'output_basename : ' + output_basename)\n    else:\n        output_dir = output_path\n        output_basename = None\n    converter = ShakeGrid(\n        title,\n        source,\n        grid_xml_path,\n        output_dir=output_dir,\n        output_basename=output_basename,\n        algorithm_filename_flag=algorithm_filename_flag,\n        smoothing_method=smoothing_method,\n        smooth_sigma=smooth_sigma,\n        extra_keywords=extra_keywords\n    )\n    return converter.mmi_to_raster(force_flag=True, algorithm=algorithm)", "response": "Convenience function to convert a single MMI file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef extract_date_time(self, the_time_stamp):\n        date_tokens = the_time_stamp[0:10].split('-')\n        self.year = int(date_tokens[0])\n        self.month = int(date_tokens[1])\n        self.day = int(date_tokens[2])\n\n        time_tokens = the_time_stamp[11:19].split(':')\n        self.hour = int(time_tokens[0])\n        self.minute = int(time_tokens[1])\n        self.second = int(time_tokens[2])\n\n        # right now only handles Indonesian Timezones\n        tz_dict = {\n            'WIB': 'Asia/Jakarta',\n            'WITA': 'Asia/Makassar',\n            'WIT': 'Asia/Jayapura'\n        }\n        if self.time_zone in tz_dict:\n            self.time_zone = tz_dict.get(self.time_zone, self.time_zone)\n\n        # noinspection PyBroadException\n        try:\n            if not self.time_zone:\n                # default to utc if empty\n                tzinfo = pytz.utc\n            else:\n                tzinfo = timezone(self.time_zone)\n        except BaseException:\n            tzinfo = pytz.utc\n\n        self.time = datetime(\n            self.year,\n            self.month,\n            self.day,\n            self.hour,\n            self.minute,\n            self.second)\n        # For now realtime always uses Western Indonesia Time\n        self.time = tzinfo.localize(self.time)", "response": "Extract the parts of a date given a timestamp as per below example."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_grid_xml(self):\n        LOGGER.debug('ParseGridXml requested.')\n        grid_path = self.grid_file_path()\n        try:\n            document = minidom.parse(grid_path)\n            shakemap_grid_element = document.getElementsByTagName(\n                'shakemap_grid')\n            shakemap_grid_element = shakemap_grid_element[0]\n            self.event_id = shakemap_grid_element.attributes[\n                'event_id'].nodeValue\n\n            event_element = document.getElementsByTagName('event')\n            event_element = event_element[0]\n            self.magnitude = float(\n                event_element.attributes['magnitude'].nodeValue)\n            self.longitude = float(\n                event_element.attributes['lon'].nodeValue)\n            self.latitude = float(\n                event_element.attributes['lat'].nodeValue)\n            self.location = event_element.attributes[\n                'event_description'].nodeValue.strip()\n            self.depth = float(\n                event_element.attributes['depth'].nodeValue)\n            # Get the date - it's going to look something like this:\n            # 2012-08-07T01:55:12WIB\n            time_stamp = event_element.attributes['event_timestamp'].nodeValue\n            # Note the timezone here is inconsistent with YZ from grid.xml\n            # use the latter\n            self.time_zone = time_stamp[19:]\n            self.extract_date_time(time_stamp)\n\n            specification_element = document.getElementsByTagName(\n                'grid_specification')\n            specification_element = specification_element[0]\n            self.x_minimum = float(\n                specification_element.attributes['lon_min'].nodeValue)\n            self.x_maximum = float(\n                specification_element.attributes['lon_max'].nodeValue)\n            self.y_minimum = float(\n                specification_element.attributes['lat_min'].nodeValue)\n            self.y_maximum = float(\n                specification_element.attributes['lat_max'].nodeValue)\n            self.grid_bounding_box = QgsRectangle(\n                self.x_minimum, self.y_maximum, self.x_maximum, self.y_minimum)\n            self.rows = int(float(\n                specification_element.attributes['nlat'].nodeValue))\n            self.columns = int(float(\n                specification_element.attributes['nlon'].nodeValue))\n            data_element = document.getElementsByTagName(\n                'grid_data')\n            data_element = data_element[0]\n            data = data_element.firstChild.nodeValue\n\n            # Extract the 1,2 and 5th (MMI) columns and populate mmi_data\n            longitude_column = 0\n            latitude_column = 1\n            mmi_column = 4\n            lon_list = []\n            lat_list = []\n            mmi_list = []\n            for line in data.split('\\n'):\n                if not line:\n                    continue\n                tokens = line.split(' ')\n                longitude = tokens[longitude_column]\n                latitude = tokens[latitude_column]\n                mmi = tokens[mmi_column]\n                lon_list.append(float(longitude))\n                lat_list.append(float(latitude))\n                mmi_list.append(float(mmi))\n\n            if self.smoothing_method == NUMPY_SMOOTHING:\n                LOGGER.debug('We are using NUMPY smoothing')\n                ncols = len(np.where(np.array(lon_list) == lon_list[0])[0])\n                nrows = len(np.where(np.array(lat_list) == lat_list[0])[0])\n\n                # reshape mmi_list to 2D array to apply gaussian filter\n                Z = np.reshape(mmi_list, (nrows, ncols))\n\n                # smooth MMI matrix\n                mmi_list = convolve(Z, gaussian_kernel(self.smoothing_sigma))\n\n                # reshape array back to 1D long list of mmi\n                mmi_list = np.reshape(mmi_list, ncols * nrows)\n\n            elif self.smoothing_method == SCIPY_SMOOTHING:\n                LOGGER.debug('We are using SCIPY smoothing')\n                from scipy.ndimage.filters import gaussian_filter\n                ncols = len(np.where(np.array(lon_list) == lon_list[0])[0])\n                nrows = len(np.where(np.array(lat_list) == lat_list[0])[0])\n\n                # reshape mmi_list to 2D array to apply gaussian filter\n                Z = np.reshape(mmi_list, (nrows, ncols))\n\n                # smooth MMI matrix\n                # Help from Hadi Ghasemi\n                mmi_list = gaussian_filter(Z, self.smoothing_sigma)\n\n                # reshape array back to 1D long list of mmi\n                mmi_list = np.reshape(mmi_list, ncols * nrows)\n\n            # zip lists as list of tuples\n            self.mmi_data = list(zip(lon_list, lat_list, mmi_list))\n\n        except Exception as e:\n            LOGGER.exception('Event parse failed')\n            raise GridXmlParseError(\n                'Failed to parse grid file.\\n%s\\n%s' % (e.__class__, str(e)))", "response": "Parse the grid xyz dataset and calculate the bounding box of the event."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef grid_file_path(self):\n        if os.path.isfile(self.grid_xml_path):\n            return self.grid_xml_path\n        else:\n            raise GridXmlFileNotFoundError", "response": "Validate that the grid xml file path points to a file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mmi_to_delimited_text(self):\n        delimited_text = 'lon,lat,mmi\\n'\n        for row in self.mmi_data:\n            delimited_text += '%s,%s,%s\\n' % (row[0], row[1], row[2])\n        return delimited_text", "response": "Return the mmi data as a delimited test string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mmi_to_delimited_file(self, force_flag=True):\n        LOGGER.debug('mmi_to_delimited_text requested.')\n\n        csv_path = os.path.join(\n            self.output_dir, 'mmi.csv')\n        # short circuit if the csv is already created.\n        if os.path.exists(csv_path) and force_flag is not True:\n            return csv_path\n        csv_file = open(csv_path, 'w')\n        csv_file.write(self.mmi_to_delimited_text())\n        csv_file.close()\n\n        # Also write the .csvt which contains metadata about field types\n        csvt_path = os.path.join(\n            self.output_dir, self.output_basename + '.csvt')\n        csvt_file = open(csvt_path, 'w')\n        csvt_file.write('\"Real\",\"Real\",\"Real\"')\n        csvt_file.close()\n\n        return csv_path", "response": "Save the mmi_data to delimited text file suitable for gdal_grid."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mmi_to_vrt(self, force_flag=True):\n        # Ensure the delimited mmi file exists\n        LOGGER.debug('mmi_to_vrt requested.')\n\n        vrt_path = os.path.join(\n            self.output_dir,\n            self.output_basename + '.vrt')\n\n        # short circuit if the vrt is already created.\n        if os.path.exists(vrt_path) and force_flag is not True:\n            return vrt_path\n\n        csv_path = self.mmi_to_delimited_file(True)\n\n        vrt_string = (\n            '<OGRVRTDataSource>'\n            '  <OGRVRTLayer name=\"mmi\">'\n            '    <SrcDataSource>%s</SrcDataSource>'\n            '    <GeometryType>wkbPoint</GeometryType>'\n            '    <GeometryField encoding=\"PointFromColumns\"'\n            '                      x=\"lon\" y=\"lat\" z=\"mmi\"/>'\n            '  </OGRVRTLayer>'\n            '</OGRVRTDataSource>' % csv_path)\n\n        with codecs.open(vrt_path, 'w', encoding='utf-8') as f:\n            f.write(vrt_string)\n\n        return vrt_path", "response": "Save the mmi_data to an ogr vrt text file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun a command and raise any error as needed.", "response": "def _run_command(self, command):\n        \"\"\"Run a command and raise any error as needed.\n\n        This is a simple runner for executing gdal commands.\n\n        :param command: A command string to be run.\n        :type command: str\n\n        :raises: Any exceptions will be propagated.\n        \"\"\"\n        try:\n            my_result = call(command, shell=True)\n            del my_result\n        except CalledProcessError as e:\n            LOGGER.exception('Running command failed %s' % command)\n            message = (\n                'Error while executing the following shell '\n                'command: %s\\nError message: %s' % (command, str(e)))\n            # shameless hack - see https://github.com/AIFDR/inasafe/issues/141\n            if sys.platform == 'darwin':  # Mac OS X\n                if 'Errno 4' in str(e):\n                    # continue as the error seems to be non critical\n                    pass\n                else:\n                    raise Exception(message)\n            else:\n                raise Exception(message)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert the grid. xml s mmi column to a raster using GDAL.", "response": "def mmi_to_raster(self, force_flag=False, algorithm=USE_ASCII):\n        \"\"\"Convert the grid.xml's mmi column to a raster using gdal_grid.\n\n        A geotiff file will be created.\n\n        Unfortunately no python bindings exist for doing this so we are\n        going to do it using a shell call.\n\n        .. see also:: http://www.gdal.org/gdal_grid.html\n\n        Example of the gdal_grid call we generate::\n\n           gdal_grid -zfield \"mmi\" -a invdist:power=2.0:smoothing=1.0 \\\n           -txe 126.29 130.29 -tye 0.802 4.798 -outsize 400 400 -of GTiff \\\n           -ot Float16 -l mmi mmi.vrt mmi.tif\n\n        .. note:: It is assumed that gdal_grid is in your path.\n\n        :param force_flag: Whether to force the regeneration of the output\n            file. Defaults to False.\n        :type force_flag: bool\n\n        :param algorithm: Which re-sampling algorithm to use.\n            valid options are 'nearest' (for nearest neighbour), 'invdist'\n            (for inverse distance), 'average' (for moving average). Defaults\n            to 'nearest' if not specified. Note that passing re-sampling alg\n            parameters is currently not supported. If None is passed it will\n            be replaced with 'use_ascii'.\n            'use_ascii' algorithm will convert the mmi grid to ascii file\n            then convert it to raster using gdal_translate.\n        :type algorithm: str\n\n        :returns: Path to the resulting tif file.\n        :rtype: str\n\n        .. note:: For interest you can also make quite beautiful smoothed\n          raster using this:\n\n          gdal_grid -zfield \"mmi\" -a_srs EPSG:4326\n          -a invdist:power=2.0:smoothing=1.0 -txe 122.45 126.45\n          -tye -2.21 1.79 -outsize 400 400 -of GTiff\n          -ot Float16 -l mmi mmi.vrt mmi-trippy.tif\n        \"\"\"\n        LOGGER.debug('mmi_to_raster requested.')\n\n        if algorithm is None:\n            algorithm = USE_ASCII\n\n        if self.algorithm_name:\n            tif_path = os.path.join(\n                self.output_dir, '%s-%s.tif' % (\n                    self.output_basename, algorithm))\n        else:\n            tif_path = os.path.join(\n                self.output_dir, '%s.tif' % self.output_basename)\n        # short circuit if the tif is already created.\n        if os.path.exists(tif_path) and force_flag is not True:\n            return tif_path\n\n        if algorithm == USE_ASCII:\n            # Convert to ascii\n            ascii_path = self.mmi_to_ascii(True)\n\n            # Creating command to convert to tif\n            command = (\n                (\n                    '%(gdal_translate)s -a_srs EPSG:4326 '\n                    '\"%(ascii)s\" \"%(tif)s\"'\n                ) % {\n                    'gdal_translate': which('gdal_translate')[0],\n                    'ascii': ascii_path,\n                    'tif': tif_path\n                }\n            )\n\n            LOGGER.info('Created this gdal command:\\n%s' % command)\n            # Now run GDAL warp scottie...\n            self._run_command(command)\n        else:\n            # Ensure the vrt mmi file exists (it will generate csv too if\n            # needed)\n            vrt_path = self.mmi_to_vrt(force_flag)\n\n            # now generate the tif using default nearest neighbour\n            # interpolation options. This gives us the same output as the\n            # mmi.grd generated by the earthquake server.\n\n            if INVDIST in algorithm:\n                algorithm = 'invdist:power=2.0:smoothing=1.0'\n\n            command = (\n                (\n                    '%(gdal_grid)s -a %(alg)s -zfield \"mmi\" -txe %(xMin)s '\n                    '%(xMax)s -tye %(yMin)s %(yMax)s -outsize %(dimX)i '\n                    '%(dimY)i -of GTiff -ot Float16 -a_srs EPSG:4326 -l mmi '\n                    '\"%(vrt)s\" \"%(tif)s\"'\n                ) % {\n                    'gdal_grid': which('gdal_grid')[0],\n                    'alg': algorithm,\n                    'xMin': self.x_minimum,\n                    'xMax': self.x_maximum,\n                    'yMin': self.y_minimum,\n                    'yMax': self.y_maximum,\n                    'dimX': self.columns,\n                    'dimY': self.rows,\n                    'vrt': vrt_path,\n                    'tif': tif_path\n                }\n            )\n\n            LOGGER.info('Created this gdal command:\\n%s' % command)\n            # Now run GDAL warp scottie...\n            self._run_command(command)\n\n            # We will use keywords file name with simple algorithm name since\n            # it will raise an error in windows related to having double\n            # colon in path\n            if INVDIST in algorithm:\n                algorithm = 'invdist'\n\n        # copy the keywords file from fixtures for this layer\n        self.create_keyword_file(algorithm)\n\n        # Lastly copy over the standard qml (QGIS Style file) for the mmi.tif\n        if self.algorithm_name:\n            qml_path = os.path.join(\n                self.output_dir, '%s-%s.qml' % (\n                    self.output_basename, algorithm))\n        else:\n            qml_path = os.path.join(\n                self.output_dir, '%s.qml' % self.output_basename)\n        qml_source_path = resources_path('converter_data', 'mmi.qml')\n        shutil.copyfile(qml_source_path, qml_path)\n        return tif_path"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert grid. xml s mmi column to a vector shp file using ogr2ogr.", "response": "def mmi_to_shapefile(self, force_flag=False):\n        \"\"\"Convert grid.xml's mmi column to a vector shp file using ogr2ogr.\n\n        An ESRI shape file will be created.\n\n        :param force_flag: bool (Optional). Whether to force the regeneration\n            of the output file. Defaults to False.\n\n        :return: Path to the resulting tif file.\n        :rtype: str\n\n        Example of the ogr2ogr call we generate::\n\n           ogr2ogr -select mmi -a_srs EPSG:4326 mmi.shp mmi.vrt mmi\n\n        .. note:: It is assumed that ogr2ogr is in your path.\n        \"\"\"\n        LOGGER.debug('mmi_to_shapefile requested.')\n\n        shp_path = os.path.join(\n            self.output_dir, '%s-points.shp' % self.output_basename)\n        # Short circuit if the tif is already created.\n        if os.path.exists(shp_path) and force_flag is not True:\n            return shp_path\n\n        # Ensure the vrt mmi file exists (it will generate csv too if needed)\n        vrt_path = self.mmi_to_vrt(force_flag)\n\n        # now generate the tif using default interpolation options\n\n        binary_list = which('ogr2ogr')\n        LOGGER.debug('Path for ogr2ogr: %s' % binary_list)\n        if len(binary_list) < 1:\n            raise CallGDALError(\n                tr('ogr2ogr could not be found on your computer'))\n        # Use the first matching gdalwarp found\n        binary = binary_list[0]\n        command = (\n            ('%(ogr2ogr)s -overwrite -select mmi -a_srs EPSG:4326 '\n             '%(shp)s %(vrt)s mmi') % {\n                'ogr2ogr': binary,\n                'shp': shp_path,\n                'vrt': vrt_path})\n\n        LOGGER.info('Created this ogr command:\\n%s' % command)\n        # Now run ogr2ogr ...\n        # noinspection PyProtectedMember\n        self._run_command(command)\n\n        # Lastly copy over the standard qml (QGIS Style file) for the mmi.tif\n        qml_path = os.path.join(\n            self.output_dir, '%s-points.qml' % self.output_basename)\n        source_qml = resources_path('converter_data', 'mmi-shape.qml')\n        shutil.copyfile(source_qml, qml_path)\n        return shp_path"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mmi_to_contours(self, force_flag=True, algorithm=USE_ASCII):\n        LOGGER.debug('mmi_to_contours requested.')\n        # TODO: Use sqlite rather?\n        output_file_base = os.path.join(\n            self.output_dir,\n            '%s-contours-%s.' % (self.output_basename, algorithm))\n        output_file = output_file_base + 'shp'\n        if os.path.exists(output_file) and force_flag is not True:\n            return output_file\n        elif os.path.exists(output_file):\n            try:\n                os.remove(output_file_base + 'shp')\n                os.remove(output_file_base + 'shx')\n                os.remove(output_file_base + 'dbf')\n                os.remove(output_file_base + 'prj')\n            except OSError:\n                LOGGER.exception(\n                    'Old contour files not deleted'\n                    ' - this may indicate a file permissions issue.')\n\n        tif_path = self.mmi_to_raster(force_flag, algorithm)\n        # Based largely on\n        # http://svn.osgeo.org/gdal/trunk/autotest/alg/contour.py\n        driver = ogr.GetDriverByName('ESRI Shapefile')\n        ogr_dataset = driver.CreateDataSource(output_file)\n        if ogr_dataset is None:\n            # Probably the file existed and could not be overriden\n            raise ContourCreationError(\n                'Could not create datasource for:\\n%s. Check that the file '\n                'does not already exist and that you do not have file system '\n                'permissions issues' % output_file)\n        layer = ogr_dataset.CreateLayer('contour')\n        field_definition = ogr.FieldDefn('ID', ogr.OFTInteger)\n        layer.CreateField(field_definition)\n        field_definition = ogr.FieldDefn('MMI', ogr.OFTReal)\n        layer.CreateField(field_definition)\n        # So we can fix the x pos to the same x coord as centroid of the\n        # feature so labels line up nicely vertically\n        field_definition = ogr.FieldDefn('X', ogr.OFTReal)\n        layer.CreateField(field_definition)\n        # So we can fix the y pos to the min y coord of the whole contour so\n        # labels line up nicely vertically\n        field_definition = ogr.FieldDefn('Y', ogr.OFTReal)\n        layer.CreateField(field_definition)\n        # So that we can set the html hex colour based on its MMI class\n        field_definition = ogr.FieldDefn('RGB', ogr.OFTString)\n        layer.CreateField(field_definition)\n        # So that we can set the label in it roman numeral form\n        field_definition = ogr.FieldDefn('ROMAN', ogr.OFTString)\n        layer.CreateField(field_definition)\n        # So that we can set the label horizontal alignment\n        field_definition = ogr.FieldDefn('ALIGN', ogr.OFTString)\n        layer.CreateField(field_definition)\n        # So that we can set the label vertical alignment\n        field_definition = ogr.FieldDefn('VALIGN', ogr.OFTString)\n        layer.CreateField(field_definition)\n        # So that we can set feature length to filter out small features\n        field_definition = ogr.FieldDefn('LEN', ogr.OFTReal)\n        layer.CreateField(field_definition)\n\n        tif_dataset = gdal.Open(tif_path, GA_ReadOnly)\n        # see http://gdal.org/java/org/gdal/gdal/gdal.html for these options\n        band = 1\n        contour_interval = 0.5\n        contour_base = 0\n        fixed_level_list = []\n        use_no_data_flag = 0\n        no_data_value = -9999\n        id_field = 0  # first field defined above\n        elevation_field = 1  # second (MMI) field defined above\n        try:\n            gdal.ContourGenerate(\n                tif_dataset.GetRasterBand(band),\n                contour_interval,\n                contour_base,\n                fixed_level_list,\n                use_no_data_flag,\n                no_data_value,\n                layer,\n                id_field,\n                elevation_field)\n        except Exception as e:\n            LOGGER.exception('Contour creation failed')\n            raise ContourCreationError(str(e))\n        finally:\n            del tif_dataset\n            ogr_dataset.Release()\n\n        # Copy over the standard .prj file since ContourGenerate does not\n        # create a projection definition\n        projection_path = os.path.join(\n            self.output_dir,\n            '%s-contours-%s.prj' % (self.output_basename, algorithm))\n        source_projection_path = resources_path(\n            'converter_data', 'mmi-contours.prj')\n        shutil.copyfile(source_projection_path, projection_path)\n\n        # Lastly copy over the standard qml (QGIS Style file)\n        qml_path = os.path.join(\n            self.output_dir,\n            '%s-contours-%s.qml' % (self.output_basename, algorithm))\n        source_qml_path = resources_path('converter_data', 'mmi-contours.qml')\n        shutil.copyfile(source_qml_path, qml_path)\n\n        # Now update the additional columns - X,Y, ROMAN and RGB\n        try:\n            set_contour_properties(output_file)\n        except InvalidLayerError:\n            raise\n\n        return output_file", "response": "This method extracts the contour product from the event s tif file and returns the path pointing to the contour dataset."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_keyword_file(self, algorithm):\n        keyword_io = KeywordIO()\n\n        # Set thresholds for each exposure\n        mmi_default_classes = default_classification_thresholds(\n            earthquake_mmi_scale\n        )\n        mmi_default_threshold = {\n            earthquake_mmi_scale['key']: {\n                'active': True,\n                'classes': mmi_default_classes\n            }\n        }\n        generic_default_classes = default_classification_thresholds(\n            generic_hazard_classes\n        )\n        generic_default_threshold = {\n            generic_hazard_classes['key']: {\n                'active': True,\n                'classes': generic_default_classes\n            }\n        }\n\n        threshold_keyword = {}\n        for exposure in exposure_all:\n            # Not all exposure is supported by earthquake_mmi_scale\n            if exposure in earthquake_mmi_scale['exposures']:\n                threshold_keyword[exposure['key']] = mmi_default_threshold\n            else:\n                threshold_keyword[\n                    exposure['key']] = generic_default_threshold\n\n        extra_keywords = {\n            extra_keyword_earthquake_latitude['key']: self.latitude,\n            extra_keyword_earthquake_longitude['key']: self.longitude,\n            extra_keyword_earthquake_magnitude['key']: self.magnitude,\n            extra_keyword_earthquake_depth['key']: self.depth,\n            extra_keyword_earthquake_description['key']: self.description,\n            extra_keyword_earthquake_location['key']: self.location,\n            extra_keyword_earthquake_event_time['key']: self.time.strftime(\n                '%Y-%m-%dT%H:%M:%S'),\n            extra_keyword_time_zone['key']: self.time_zone,\n            extra_keyword_earthquake_x_minimum['key']: self.x_minimum,\n            extra_keyword_earthquake_x_maximum['key']: self.x_maximum,\n            extra_keyword_earthquake_y_minimum['key']: self.y_minimum,\n            extra_keyword_earthquake_y_maximum['key']: self.y_maximum,\n            extra_keyword_earthquake_event_id['key']: self.event_id\n        }\n        for key, value in list(self.extra_keywords.items()):\n            extra_keywords[key] = value\n\n        # Delete empty element.\n        empty_keys = []\n        for key, value in list(extra_keywords.items()):\n            if value is None:\n                empty_keys.append(key)\n        for empty_key in empty_keys:\n            extra_keywords.pop(empty_key)\n        keywords = {\n            'hazard': hazard_earthquake['key'],\n            'hazard_category': hazard_category_single_event['key'],\n            'keyword_version': inasafe_keyword_version,\n            'layer_geometry': layer_geometry_raster['key'],\n            'layer_mode': layer_mode_continuous['key'],\n            'layer_purpose': layer_purpose_hazard['key'],\n            'continuous_hazard_unit': unit_mmi['key'],\n            'classification': earthquake_mmi_scale['key'],\n            'thresholds': threshold_keyword,\n            'extra_keywords': extra_keywords,\n            'active_band': 1\n        }\n\n        if self.algorithm_name:\n            layer_path = os.path.join(\n                self.output_dir, '%s-%s.tif' % (\n                    self.output_basename, algorithm))\n        else:\n            layer_path = os.path.join(\n                self.output_dir, '%s.tif' % self.output_basename)\n\n        # append title and source to the keywords file\n        if len(self.title.strip()) == 0:\n            keyword_title = self.output_basename\n        else:\n            keyword_title = self.title\n\n        keywords['title'] = keyword_title\n\n        hazard_layer = QgsRasterLayer(layer_path, keyword_title)\n\n        if not hazard_layer.isValid():\n            raise InvalidLayerError()\n\n        keyword_io.write_keywords(hazard_layer, keywords)", "response": "Create a keyword file for the raster file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mmi_to_ascii(self, force_flag=False):\n        ascii_path = os.path.join(\n            self.output_dir, '%s.asc' % self.output_basename)\n        # Short circuit if the tif is already created.\n        if os.path.exists(ascii_path) and force_flag is not True:\n            return ascii_path\n\n        cell_size = (self.x_maximum - self.x_minimum) / (self.rows - 1)\n        asc_file = open(ascii_path, 'w')\n        asc_file.write('ncols %d\\n' % self.columns)\n        asc_file.write('nrows %d\\n' % self.rows)\n        asc_file.write('xllcorner %.3f\\n' % self.x_minimum)\n        asc_file.write('yllcorner %.3f\\n' % self.y_minimum)\n        asc_file.write('cellsize %.3f\\n' % cell_size)\n        asc_file.write('nodata_value -9999\\n')\n\n        cell_string = ''\n        cell_values = np.reshape(\n            [v[2] for v in self.mmi_data], (self.rows, self.columns))\n        for i in range(self.rows):\n            for j in range(self.columns):\n                cell_string += '%.3f ' % cell_values[i][j]\n            cell_string += '\\n'\n\n        asc_file.write(cell_string)\n\n        asc_file.close()\n\n        return ascii_path", "response": "Convert the grid. xml mmi column to an ascii raster file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_html(self):\n\n        text = self.text\n        if text is None:\n            text = self.uri\n        return '<a href=\"%s\"%s>%s</a>' % (\n            self.uri, self.html_attributes(), text)", "response": "Render as html\n\n        Args:\n            None\n\n        Returns:\n            Str the html representation\n\n        Raises:\n            Errors are propagated"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset widgets on the Summary tab.", "response": "def set_widgets(self):\n        \"\"\"Set widgets on the Summary tab.\"\"\"\n        if self.parent.aggregation_layer:\n            aggr = self.parent.aggregation_layer.name()\n        else:\n            aggr = self.tr('no aggregation')\n\n        html = self.tr('Please ensure the following information '\n                       'is correct and press Run.')\n\n        # TODO: update this to use InaSAFE message API rather...\n        html += '<br/><table cellspacing=\"4\">'\n        html += ('<tr>'\n                 '  <td><b>%s</b></td><td></td><td>%s</td>'\n                 '</tr><tr>'\n                 '  <td><b>%s</b></td><td></td><td>%s</td>'\n                 '</tr><tr>'\n                 '  <td><b>%s</b></td><td></td><td>%s</td>'\n                 '</tr><tr>'\n                 '  <td colspan=\"3\"></td>'\n                 '</tr>' % (\n                     self.tr('hazard layer').capitalize().replace(\n                         ' ', '&nbsp;'),\n                     self.parent.hazard_layer.name(),\n                     self.tr('exposure layer').capitalize().replace(\n                         ' ', '&nbsp;'),\n                     self.parent.exposure_layer.name(),\n                     self.tr('aggregation layer').capitalize().replace(\n                         ' ', '&nbsp;'), aggr))\n\n        self.lblSummary.setText(html)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves a value from a field in the analysis summary layer.", "response": "def inasafe_analysis_summary_field_value(field, feature, parent):\n    \"\"\"Retrieve a value from a field in the analysis summary layer.\n\n    e.g. inasafe_analysis_summary_field_value('total_not_exposed') -> 3\n    \"\"\"\n    _ = feature, parent  # NOQA\n    project_context_scope = QgsExpressionContextUtils.projectScope(\n        QgsProject.instance())\n    registry = QgsProject.instance()\n\n    key = provenance_layer_analysis_impacted_id['provenance_key']\n    if not project_context_scope.hasVariable(key):\n        return None\n\n    layer = registry.mapLayer(project_context_scope.variable(key))\n\n    if not layer:\n        return None\n\n    index = layer.fields().lookupField(field)\n    if index < 0:\n        return None\n\n    feature = next(layer.getFeatures())\n    return feature[index]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef inasafe_sub_analysis_summary_field_value(\n        exposure_key, field, feature, parent):\n    \"\"\"Retrieve a value from field in the specified exposure analysis layer.\n\n    \"\"\"\n    _ = feature, parent  # NOQA\n    project_context_scope = QgsExpressionContextUtils.projectScope(\n        QgsProject.instance())\n    project = QgsProject.instance()\n\n    key = ('{provenance}__{exposure}').format(\n        provenance=provenance_multi_exposure_analysis_summary_layers_id[\n            'provenance_key'],\n        exposure=exposure_key)\n    if not project_context_scope.hasVariable(key):\n        return None\n\n    analysis_summary_layer = project.mapLayer(\n        project_context_scope.variable(key))\n    if not analysis_summary_layer:\n        return None\n\n    index = analysis_summary_layer.fields().lookupField(field)\n    if index < 0:\n        return None\n\n    feature = next(analysis_summary_layer.getFeatures())\n    return feature[index]", "response": "Retrieve a value from field in the specified exposure analysis layer."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve all values from a field in the exposure summary layer.", "response": "def inasafe_exposure_summary_field_values(field, feature, parent):\n    \"\"\"Retrieve all values from a field in the exposure summary layer.\n    \"\"\"\n    _ = feature, parent  # NOQA\n\n    layer = exposure_summary_layer()\n    if not layer:\n        return None\n\n    index = layer.fields().lookupField(field)\n    if index < 0:\n        return None\n\n    values = []\n    for feat in layer.getFeatures():\n        value = feat[index]\n        values.append(value)\n\n    return str(values)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef inasafe_place_value_name(number, feature, parent):\n    _ = feature, parent  # NOQA\n    if number is None:\n        return None\n    rounded_number = round_affected_number(\n        number,\n        use_rounding=True,\n        use_population_rounding=True\n    )\n    value, unit = denomination(rounded_number, 1000)\n    if not unit:\n        return None\n    else:\n        return unit['name']", "response": "Given a number it will return the place value name."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a number it will return the coefficient of the place value name.", "response": "def inasafe_place_value_coefficient(number, feature, parent):\n    \"\"\"Given a number, it will return the coefficient of the place value name.\n\n    For instance:\n    *  inasafe_place_value_coefficient(10) -> 1\n    *  inasafe_place_value_coefficient(1700) -> 1.7\n\n    It needs to be used with inasafe_number_denomination_unit.\n    \"\"\"\n    _ = feature, parent  # NOQA\n\n    if number >= 0:\n        rounded_number = round_affected_number(\n            number,\n            use_rounding=True,\n            use_population_rounding=True\n        )\n        min_number = 1000\n        value, unit = denomination(rounded_number, min_number)\n        if number < min_number:\n            rounded_number = int(round(value, 1))\n        else:\n            rounded_number = round(value, 1)\n        return str(rounded_number)\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef inasafe_place_value_percentage(number, total, feature, parent):\n    _ = feature, parent  # NOQA\n    if number < 0:\n        return None\n    percentage_format = '{percentage}%'\n    percentage = round((float(number) / float(total)) * 100, 1)\n    return percentage_format.format(percentage=percentage)", "response": "Given a number and total it will return the percentage of the number to the total."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving an InaSAFE analysis time it will convert it to a date with the year - month - date format.", "response": "def beautify_date(inasafe_time, feature, parent):\n    \"\"\"Given an InaSAFE analysis time, it will convert it to a date with\n    year-month-date format.\n\n    For instance:\n    *   beautify_date( @start_datetime ) -> will convert datetime provided by\n        qgis_variable.\n    \"\"\"\n    _ = feature, parent  # NOQA\n    datetime_object = parse(inasafe_time)\n    date = datetime_object.strftime('%Y-%m-%d')\n    return date"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef beautify_time(inasafe_time, feature, parent):\n    _ = feature, parent  # NOQA\n    datetime_object = parse(inasafe_time)\n    time = datetime_object.strftime('%H:%M')\n    return time", "response": "Given an InaSAFE analysis time it will convert it to a time with the hour : minute format."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngiving a keyword it will return the value of the keyword from the hazard layer s extra keywords.", "response": "def hazard_extra_keyword(keyword, feature, parent):\n    \"\"\"Given a keyword, it will return the value of the keyword\n    from the hazard layer's extra keywords.\n\n    For instance:\n    *   hazard_extra_keyword( 'depth' ) -> will return the value of 'depth'\n        in current hazard layer's extra keywords.\n    \"\"\"\n    _ = feature, parent  # NOQA\n    hazard_layer_path = QgsExpressionContextUtils. \\\n        projectScope(QgsProject.instance()).variable(\n          'hazard_layer')\n    hazard_layer = load_layer(hazard_layer_path)[0]\n    keywords = KeywordIO.read_keywords(hazard_layer)\n    extra_keywords = keywords.get('extra_keywords')\n    if extra_keywords:\n        value = extra_keywords.get(keyword)\n        if value:\n            value_definition = definition(value)\n            if value_definition:\n                return value_definition['name']\n            return value\n        else:\n            return tr('Keyword %s is not found' % keyword)\n    return tr('No extra keywords found')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_html(self):\n        if self.items is None:\n            return\n        else:\n            html = '<ol%s>\\n' % self.html_attributes()\n            for item in self.items:\n                html += '<li>%s</li>\\n' % item.to_html()\n            html += '</ol>'\n            return html", "response": "Render a Text MessageElement as html"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_text(self):\n        if self.items is None:\n            return\n        else:\n            text = ''\n            for i, item in enumerate(self.items):\n                text += ' %s. %s\\n' % (i + 1, item.to_text())\n\n            return text", "response": "Render a Text MessageElement as plain text"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef prepare_vector_layer(layer):\n    output_layer_name = prepare_vector_steps['output_layer_name']\n    output_layer_name = output_layer_name % layer.keywords['layer_purpose']\n\n    if not layer.keywords.get('inasafe_fields'):\n        msg = 'inasafe_fields is missing in keywords from %s' % layer.name()\n        raise InvalidKeywordsForProcessingAlgorithm(msg)\n\n    cleaned = create_memory_layer(\n        output_layer_name, layer.geometryType(), layer.crs(), layer.fields())\n\n    # We transfer keywords to the output.\n    cleaned.keywords = copy_layer_keywords(layer.keywords)\n\n    copy_layer(layer, cleaned)\n    _remove_features(cleaned)\n\n    # After removing rows, let's check if there is still a feature.\n    request = QgsFeatureRequest().setFlags(QgsFeatureRequest.NoGeometry)\n    iterator = cleaned.getFeatures(request)\n    try:\n        next(iterator)\n    except StopIteration:\n        LOGGER.warning(\n            tr('No feature has been found in the {purpose}'\n                .format(purpose=layer.keywords['layer_purpose'])))\n        # Realtime may have no data in the extent when doing a multiexposure\n        # analysis. We still want the IF. I disabled the exception. ET 19/02/18\n        # raise NoFeaturesInExtentError\n\n    _add_id_column(cleaned)\n    clean_inasafe_fields(cleaned)\n\n    if _size_is_needed(cleaned):\n        LOGGER.info(\n            'We noticed some counts in your exposure layer. Before to update '\n            'geometries, we compute the original size for each feature.')\n        run_single_post_processor(cleaned, post_processor_size)\n\n    if cleaned.keywords['layer_purpose'] == 'exposure':\n        fields = cleaned.keywords['inasafe_fields']\n        if exposure_type_field['key'] not in fields:\n            _add_default_exposure_class(cleaned)\n\n        # Check value mapping\n        _check_value_mapping(cleaned)\n\n    cleaned.keywords['title'] = output_layer_name\n\n    check_layer(cleaned)\n    return cleaned", "response": "This function will prepare the vector layer to be used in InaSAFE."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _check_value_mapping(layer, exposure_key=None):\n    index = layer.fields().lookupField(exposure_type_field['field_name'])\n    unique_exposure = layer.uniqueValues(index)\n    if layer.keywords['layer_purpose'] == layer_purpose_hazard['key']:\n        if not exposure_key:\n            message = tr('Hazard value mapping missing exposure key.')\n            raise InvalidKeywordsForProcessingAlgorithm(message)\n        value_map = active_thresholds_value_maps(layer.keywords, exposure_key)\n    else:\n        value_map = layer.keywords.get('value_map')\n\n    if not value_map:\n        # The exposure do not have a value_map, we can skip the layer.\n        return layer\n\n    if layer.keywords['layer_purpose'] == layer_purpose_hazard['key']:\n        if not exposure_key:\n            message = tr('Hazard classification is missing exposure key.')\n            raise InvalidKeywordsForProcessingAlgorithm(message)\n        classification = active_classification(layer.keywords, exposure_key)\n    else:\n        classification = layer.keywords['classification']\n\n    exposure_classification = definition(classification)\n\n    other = None\n    if exposure_classification['key'] != data_driven_classes['key']:\n        other = exposure_classification['classes'][-1]['key']\n\n    exposure_mapped = []\n    for group in list(value_map.values()):\n        exposure_mapped.extend(group)\n\n    diff = list(unique_exposure - set(exposure_mapped))\n\n    if other in list(value_map.keys()):\n        value_map[other].extend(diff)\n    else:\n        value_map[other] = diff\n\n    layer.keywords['value_map'] = value_map\n    layer.keywords['classification'] = classification\n    return layer", "response": "Check if the value map is correct."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncleaning inasafe_fields based on keywords.", "response": "def clean_inasafe_fields(layer):\n    \"\"\"Clean inasafe_fields based on keywords.\n\n    1. Must use standard field names.\n    2. Sum up list of fields' value and put in the standard field name.\n    3. Remove un-used fields.\n\n    :param layer: The layer\n    :type layer: QgsVectorLayer\n    \"\"\"\n    fields = []\n    # Exposure\n    if layer.keywords['layer_purpose'] == layer_purpose_exposure['key']:\n        fields = get_fields(\n            layer.keywords['layer_purpose'], layer.keywords['exposure'])\n\n    # Hazard\n    elif layer.keywords['layer_purpose'] == layer_purpose_hazard['key']:\n        fields = get_fields(\n            layer.keywords['layer_purpose'], layer.keywords['hazard'])\n\n    # Aggregation\n    elif layer.keywords['layer_purpose'] == layer_purpose_aggregation['key']:\n        fields = get_fields(\n            layer.keywords['layer_purpose'])\n\n    # Add displaced_field definition to expected_fields\n    # for minimum needs calculator.\n    # If there is no displaced_field keyword, then pass\n    try:\n        if layer.keywords['inasafe_fields'][displaced_field['key']]:\n            fields.append(displaced_field)\n    except KeyError:\n        pass\n\n    expected_fields = {field['key']: field['field_name'] for field in fields}\n\n    # Convert the field name and sum up if needed\n    new_keywords = {}\n    for key, val in list(layer.keywords.get('inasafe_fields').items()):\n        if key in expected_fields:\n            if isinstance(val, str):\n                val = [val]\n            sum_fields(layer, key, val)\n            new_keywords[key] = expected_fields[key]\n\n    # Houra, InaSAFE keywords match our concepts !\n    layer.keywords['inasafe_fields'].update(new_keywords)\n\n    to_remove = []\n    # Remove unnecessary fields (the one that is not in the inasafe_fields)\n    for field in layer.fields().toList():\n        if field.name() not in list(layer.keywords['inasafe_fields'].values()):\n            to_remove.append(field.name())\n    remove_fields(layer, to_remove)\n    LOGGER.debug(\n        'Fields which have been removed from %s : %s'\n        % (layer.keywords['layer_purpose'], ' '.join(to_remove)))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _size_is_needed(layer):\n    exposure = layer.keywords.get('exposure')\n    if not exposure:\n        # The layer is not an exposure.\n        return False\n\n    indivisible_exposure_keys = [f['key'] for f in indivisible_exposure]\n    if exposure in indivisible_exposure_keys:\n        # The exposure is not divisible, We don't need to compute the size.\n        return False\n\n    if layer.geometryType() == QgsWkbTypes.PointGeometry:\n        # The exposure is a point layer. We don't need to compute the size.\n        return False\n\n    # The layer is divisible and not a point layer.\n    # We need to check if some fields are absolute.\n\n    fields = layer.keywords['inasafe_fields']\n\n    absolute_field_keys = [f['key'] for f in count_fields]\n\n    for field in fields:\n        if field in absolute_field_keys:\n            return True\n    else:\n        return False", "response": "Checks if the size field is needed."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _remove_features(layer):\n    # Get the layer purpose of the layer.\n    layer_purpose = layer.keywords['layer_purpose']\n    layer_subcategory = layer.keywords.get(layer_purpose)\n\n    compulsory_field = get_compulsory_fields(layer_purpose, layer_subcategory)\n\n    inasafe_fields = layer.keywords['inasafe_fields']\n    # Compulsory fields can be list of field name or single field name.\n    # We need to iterate through all of them\n    field_names = inasafe_fields.get(compulsory_field['key'])\n    if not isinstance(field_names, list):\n        field_names = [field_names]\n    for field_name in field_names:\n        if not field_name:\n            message = 'Keyword %s is missing from %s' % (\n                compulsory_field['key'], layer_purpose)\n            raise InvalidKeywordsForProcessingAlgorithm(message)\n        index = layer.fields().lookupField(field_name)\n\n        request = QgsFeatureRequest()\n        request.setSubsetOfAttributes([field_name], layer.fields())\n        layer.startEditing()\n        i = 0\n        for feature in layer.getFeatures(request):\n            feat_attr = feature.attributes()[index]\n            if (feat_attr is None\n                    or (hasattr(feat_attr, 'isNull')\n                        and feat_attr.isNull())):\n                if layer_purpose == 'hazard':\n                    # Remove the feature if the hazard is null.\n                    layer.deleteFeature(feature.id())\n                    i += 1\n                elif layer_purpose == 'aggregation':\n                    # Put the ID if the value is null.\n                    layer.changeAttributeValue(\n                        feature.id(), index, str(feature.id()))\n                elif layer_purpose == 'exposure':\n                    # Put an empty value, the value mapping will take care of\n                    # it in the 'other' group.\n                    layer.changeAttributeValue(\n                        feature.id(), index, '')\n\n            # Check if there is en empty geometry.\n            geometry = feature.geometry()\n            if not geometry:\n                layer.deleteFeature(feature.id())\n                i += 1\n                continue\n\n            # Check if the geometry is empty.\n            if geometry.isEmpty():\n                layer.deleteFeature(feature.id())\n                i += 1\n                continue\n\n            # Check if the geometry is valid.\n            if not geometry.isGeosValid():\n                # polygonize can produce some invalid geometries\n                # For instance a polygon like this, sharing a same point :\n                #      _______\n                #      |  ___|__\n                #      |  |__|  |\n                #      |________|\n                # layer.deleteFeature(feature.id())\n                # i += 1\n                pass\n\n            # TODO We need to add more tests\n            # like checking if the value is in the value_mapping.\n        layer.commitChanges()\n        if i:\n            LOGGER.critical(\n                'Features which have been removed from %s : %s'\n                % (layer.keywords['layer_purpose'], i))\n        else:\n            LOGGER.info(\n                'No feature has been removed from %s during the vector layer '\n                'preparation' % layer.keywords['layer_purpose'])", "response": "Removes features which do not have information for InaSAFE or an invalid vector layer."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds an ID column if it s not present in the attribute table.", "response": "def _add_id_column(layer):\n    \"\"\"Add an ID column if it's not present in the attribute table.\n\n    :param layer: The vector layer.\n    :type layer: QgsVectorLayer\n    \"\"\"\n    layer_purpose = layer.keywords['layer_purpose']\n    mapping = {\n        layer_purpose_exposure['key']: exposure_id_field,\n        layer_purpose_hazard['key']: hazard_id_field,\n        layer_purpose_aggregation['key']: aggregation_id_field\n    }\n\n    has_id_column = False\n    for layer_type, field in list(mapping.items()):\n        if layer_purpose == layer_type:\n            safe_id = field\n            if layer.keywords['inasafe_fields'].get(field['key']):\n                has_id_column = True\n            break\n\n    if not has_id_column:\n        LOGGER.info(\n            'We add an ID column in {purpose}'.format(purpose=layer_purpose))\n\n        layer.startEditing()\n\n        id_field = QgsField()\n        id_field.setName(safe_id['field_name'])\n        if isinstance(safe_id['type'], list):\n            # Use the first element in the list of type\n            id_field.setType(safe_id['type'][0])\n        else:\n            id_field.setType(safe_id['type'][0])\n        id_field.setPrecision(safe_id['precision'])\n        id_field.setLength(safe_id['length'])\n\n        layer.addAttribute(id_field)\n\n        new_index = layer.fields().lookupField(id_field.name())\n\n        for feature in layer.getFeatures():\n            layer.changeAttributeValue(\n                feature.id(), new_index, feature.id())\n\n        layer.commitChanges()\n\n        layer.keywords['inasafe_fields'][safe_id['key']] = (\n            safe_id['field_name'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _add_default_exposure_class(layer):\n    layer.startEditing()\n\n    field = create_field_from_definition(exposure_class_field)\n    layer.keywords['inasafe_fields'][exposure_class_field['key']] = (\n        exposure_class_field['field_name'])\n    layer.addAttribute(field)\n\n    index = layer.fields().lookupField(exposure_class_field['field_name'])\n\n    exposure = layer.keywords['exposure']\n\n    request = QgsFeatureRequest()\n    request.setFlags(QgsFeatureRequest.NoGeometry)\n    for feature in layer.getFeatures(request):\n        layer.changeAttributeValue(feature.id(), index, exposure)\n\n    layer.commitChanges()\n    return", "response": "Add default exposure class to vector layer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sum_fields(layer, output_field_key, input_fields):\n    field_definition = definition(output_field_key)\n    output_field_name = field_definition['field_name']\n    # If the fields only has one element\n    if len(input_fields) == 1:\n        # Name is different, copy it\n        if input_fields[0] != output_field_name:\n            to_rename = {input_fields[0]: output_field_name}\n            # We copy only, it will be deleted later.\n            # We can't rename the field, we need to copy it as the same\n            # field might be used many times in the FMT tool.\n            copy_fields(layer, to_rename)\n        else:\n            # Name is same, do nothing\n            return\n    else:\n        # Creating expression\n        # Put field name in a double quote. See #4248\n        input_fields = ['\"%s\"' % f for f in input_fields]\n        string_expression = ' + '.join(input_fields)\n        sum_expression = QgsExpression(string_expression)\n        context = QgsExpressionContext()\n        context.setFields(layer.fields())\n        sum_expression.prepare(context)\n\n        # Get the output field index\n        output_idx = layer.fields().lookupField(output_field_name)\n        # Output index is not found\n        layer.startEditing()\n        if output_idx == -1:\n            output_field = create_field_from_definition(field_definition)\n            layer.addAttribute(output_field)\n            output_idx = layer.fields().lookupField(output_field_name)\n\n        # Iterate to all features\n        for feature in layer.getFeatures():\n            context.setFeature(feature)\n            result = sum_expression.evaluate(context)\n            feature[output_idx] = result\n            layer.updateFeature(feature)\n\n        layer.commitChanges()", "response": "Sum the value of input_fields and put it as output_field."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_html(self, **kwargs):\n        super(LineBreak, self).__init__(**kwargs)\n        return '<br%s/>\\n' % self.html_attributes()", "response": "Render as html\n\n        Args:\n            None\n\n        Returns:\n            Str the html representation\n\n        Raises:\n            Errors are propagated\n\n        We pass the kwargs on to the base class so an exception is raised\n        if invalid keywords were passed. See:\n\n        http://stackoverflow.com/questions/13124961/\n        how-to-pass-arguments-efficiently-kwargs-in-python"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the provenance of minimum needs.", "response": "def get_needs_provenance(parameters):\n    \"\"\"Get the provenance of minimum needs.\n\n    :param parameters: A dictionary of impact function parameters.\n    :type parameters: dict\n\n    :returns: A parameter of provenance\n    :rtype: TextParameter\n    \"\"\"\n    if 'minimum needs' not in parameters:\n        return None\n    needs = parameters['minimum needs']\n    provenance = [p for p in needs if p.name == tr('Provenance')]\n    if provenance:\n        return provenance[0]\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load(self):\n        self.minimum_needs = self.settings.value('MinimumNeeds')\n\n        if not self.minimum_needs or self.minimum_needs == '':\n            # Load the most relevant minimum needs\n            # If more than one profile exists, just use defaults so\n            # the user doesn't get confused.\n            profiles = self.get_profiles()\n            if len(profiles) == 1:\n                profile = self.get_profiles()[0]\n                self.load_profile(profile)\n            else:\n                self.minimum_needs = self._defaults()", "response": "Load the minimum needs from QSettings."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_profile(self, profile):\n        profile_path = os.path.join(\n            self.root_directory, 'minimum_needs', profile + '.json')\n        self.read_from_file(profile_path)", "response": "Load a specific profile into the current minimum needs."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves the current minimum needs into a new profile.", "response": "def save_profile(self, profile):\n        \"\"\"Save the current minimum needs into a new profile.\n\n        :param profile: The profile's name\n        :type profile: basestring, str\n        \"\"\"\n        profile = profile.replace('.json', '')\n        profile_path = os.path.join(\n            self.root_directory,\n            'minimum_needs',\n            profile + '.json'\n        )\n        self.write_to_file(profile_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets all the minimum needs profiles.", "response": "def get_profiles(self, overwrite=False):\n        \"\"\"Get all the minimum needs profiles.\n\n        :returns: The minimum needs by name.\n        :rtype: list\n        \"\"\"\n        def sort_by_locale(unsorted_profiles, locale):\n            \"\"\"Sort the profiles by language settings.\n\n            The profiles that are in the same language as the QGIS' locale\n            will be sorted out first.\n\n            :param unsorted_profiles: The user profiles profiles\n            :type unsorted_profiles: list\n\n            :param locale: The language settings string\n            :type locale: str\n\n            :returns: Ordered profiles\n            :rtype: list\n            \"\"\"\n            if locale is None:\n                return unsorted_profiles\n\n            locale = '_%s' % locale[:2]\n            profiles_our_locale = []\n            profiles_remaining = []\n            for profile_name in unsorted_profiles:\n                if locale in profile_name:\n                    profiles_our_locale.append(profile_name)\n                else:\n                    profiles_remaining.append(profile_name)\n\n            return profiles_our_locale + profiles_remaining\n\n        # We ignore empty root_directory to avoid load min needs profile\n        # to test directory when test is running.\n        if not self.root_directory:\n            profiles = []\n            return profiles\n\n        else:\n            locale_minimum_needs_dir = os.path.join(\n                self.root_directory, 'minimum_needs')\n            path_name = resources_path('minimum_needs')\n            if not os.path.exists(locale_minimum_needs_dir):\n                os.makedirs(locale_minimum_needs_dir)\n            # load default min needs profile\n            for file_name in os.listdir(path_name):\n                source_file = os.path.join(path_name, file_name)\n                destination_file = os.path.join(\n                    locale_minimum_needs_dir, file_name)\n                if not os.path.exists(destination_file) or overwrite:\n                    copy(source_file, destination_file)\n            # move old min needs profile under user profile to inasafe\n            # subdirectory\n            self.move_old_profile(locale_minimum_needs_dir)\n            profiles = [\n                profile[:-5] for profile in\n                os.listdir(locale_minimum_needs_dir) if\n                profile[-5:] == '.json']\n            profiles = sort_by_locale(profiles, self.locale)\n            return profiles"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the minimum needs resources in parameter format", "response": "def get_needs_parameters(self):\n        \"\"\"Get the minimum needs resources in parameter format\n\n        :returns: The minimum needs resources wrapped in parameters.\n        :rtype: list\n        \"\"\"\n        parameters = []\n        for resource in self.minimum_needs['resources']:\n            parameter = ResourceParameter()\n            parameter.name = resource['Resource name']\n            parameter.help_text = resource['Resource description']\n            # Adding in the frequency property. This is not in the\n            # FloatParameter by default, so maybe we should subclass.\n            parameter.frequency = resource['Frequency']\n            parameter.description = self.format_sentence(\n                resource['Readable sentence'],\n                resource)\n            parameter.minimum_allowed_value = float(\n                resource['Minimum allowed'])\n            parameter.maximum_allowed_value = float(\n                resource['Maximum allowed'])\n            parameter.unit.name = resource['Unit']\n            parameter.unit.plural = resource['Units']\n            parameter.unit.abbreviation = resource['Unit abbreviation']\n            parameter.value = float(resource['Default'])\n            # choose highest precision between resource's parameters\n            # start with default of 1\n            precisions = [1]\n            precision_influence = [\n                'Maximum allowed', 'Minimum allowed', 'Default']\n            for element in precision_influence:\n                resource_element = str(resource[element])\n                if resource[element] is not None and '.' in resource_element:\n                    precisions.append(self.precision_of(resource_element))\n\n            parameter.precision = max(precisions)\n            parameters.append(parameter)\n\n        prov_parameter = TextParameter()\n        prov_parameter.name = tr('Provenance')\n        prov_parameter.description = tr('The provenance of minimum needs')\n        prov_parameter.help_text = tr('The provenance of minimum needs')\n        try:\n            prov_parameter.value = self.provenance\n        except TypeError:\n            prov_parameter.value = ''\n        parameters.append(prov_parameter)\n\n        return parameters"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef root_directory(self):\n        if not QgsApplication.qgisSettingsDirPath() or (\n                QgsApplication.qgisSettingsDirPath() == ''):\n            self._root_directory = None\n        else:\n            # noinspection PyArgumentList\n            self._root_directory = os.path.join(\n                QgsApplication.qgisSettingsDirPath(),\n                'inasafe')\n\n        return self._root_directory", "response": "Map the root directory to user profile and inasafe so the minimum needs will be placed there."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npopulate the placeholders in the sentence.", "response": "def format_sentence(sentence, resource):\n        \"\"\"Populate the placeholders in the sentence.\n\n        :param sentence: The sentence with placeholder keywords.\n        :type sentence: basestring, str\n\n        :param resource: The resource to be placed into the sentence.\n        :type resource: dict\n\n        :returns: The formatted sentence.\n        :rtype: basestring\n        \"\"\"\n        sentence = sentence.split('{{')\n        updated_sentence = sentence[0].rstrip()\n        for part in sentence[1:]:\n            replace, keep = part.split('}}')\n            replace = replace.strip()\n            updated_sentence = \"%s %s%s\" % (\n                updated_sentence,\n                resource[replace],\n                keep\n            )\n        return updated_sentence"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_profile(self, profile):\n        self.remove_file(\n            os.path.join(\n                self.root_directory, 'minimum_needs', profile + '.json')\n        )", "response": "Remove a profile from the minimum needs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmove old minimum needs profile under user profile and locale_minimum_needs.", "response": "def move_old_profile(self, locale_minimum_needs_dir):\n        \"\"\"Move old minimum needs profile under user profile/minimum_needs.\n           This function is to get rid the old min needs profile came\n           from InaSAFE < 4.0.\n\n        :param locale_minimum_needs_dir: User local minimum needs profile path.\n        :type locale_minimum_needs_dir: str\n        \"\"\"\n        old_profile_path = os.path.join(\n            QgsApplication.qgisSettingsDirPath(), 'minimum_needs')\n\n        if os.path.exists(old_profile_path):\n            for filename in os.listdir(old_profile_path):\n                source_file = os.path.join(old_profile_path, filename)\n                destination_file = os.path.join(\n                    locale_minimum_needs_dir, filename)\n                if not os.path.exists(destination_file):\n                    copy(source_file, destination_file)\n                if os.path.exists(destination_file):\n                    os.remove(source_file)\n            # remove old profile path\n            rmtree(old_profile_path)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef locale(qsetting=''):\n    override_flag = QSettings(qsetting).value(\n        'locale/overrideFlag', True, type=bool)\n\n    default = 'en_US'\n\n    if override_flag:\n        locale_name = QSettings(qsetting).value(\n            'locale/userLocale', default, type=str)\n    else:\n        # noinspection PyArgumentList\n        locale_name = QLocale.system().name()\n\n    if locale_name == 'C':\n        # On travis, locale/userLocale is equal to C. We want 'en'.\n        locale_name = default\n\n    # NOTES: we split the locale name because we need the first two\n    # character i.e. 'id', 'af, etc\n    locale_name = str(locale_name).split('_')[0]\n    return locale_name", "response": "Get the name of the currently active locale."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_band_description(self):\n        self.clear_further_steps()\n        # Set widgets\n        selected_band = self.selected_band()\n        statistics = self.parent.layer.dataProvider().bandStatistics(\n            selected_band,\n            QgsRasterBandStats.All,\n            self.parent.layer.extent(),\n            0)\n        band_description = tr(\n            'This band contains data from {min_value} to {max_value}').format(\n            min_value=statistics.minimumValue,\n            max_value=statistics.maximumValue\n        )\n        self.lblDescribeBandSelector.setText(band_description)", "response": "Helper to update band description."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef selected_band(self):\n        item = self.lstBands.currentItem()\n        return item.data(QtCore.Qt.UserRole)", "response": "Obtain the layer mode selected by user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting widgets on the LayerMode tab.", "response": "def set_widgets(self):\n        \"\"\"Set widgets on the LayerMode tab.\"\"\"\n        self.clear_further_steps()\n        # Set widgets\n        self.lblBandSelector.setText(tr(\n            'Please select which band that contains the data that you want to '\n            'use for this layer.'))\n        self.lstBands.clear()\n        band_num = self.parent.layer.bandCount()\n        for i in range(band_num):\n            item = QListWidgetItem(\n                self.parent.layer.bandName(i + 1),\n                self.lstBands)\n            item.setData(QtCore.Qt.UserRole, i + 1)\n            self.lstBands.addItem(item)\n        existing_band = self.parent.get_existing_keyword('active_band')\n        if existing_band:\n            self.lstBands.setCurrentRow(existing_band - 1)\n        else:\n            # Set to Band 1 / index 0\n            self.lstBands.setCurrentRow(0)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninserting an XML element in an other container", "response": "def insert_xml_element(root, element_path):\n    \"\"\"insert an XML element in an other creating the needed parents.\n    :param root: The container\n    :type root: ElementTree.Element\n    :param element_path: The path relative to root\n    :type element_path: str\n    :return: ElementTree.Element\n    :rtype : ElementTree.Element\n    \"\"\"\n    element_path = element_path.split('/')\n    parent = root\n    # iterate all parents of the missing element\n    for level in range(len(element_path)):\n        path = '/'.join(element_path[0:level + 1])\n        tag = element_path[level]\n        element = root.find(path, XML_NS)\n        if element is None:\n            # if a parent is missing insert it at the right place\n            element = ElementTree.SubElement(parent, tag)\n        parent = element\n    return element"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef merge_dictionaries(base_dict, extra_dict):\n    new_dict = base_dict.copy()\n    new_dict.update(extra_dict)\n    return new_dict", "response": "merge two dictionaries. base_dict is the first dictionary that is used to merge the extra_dict. extra_dict is the second dictionary that is used to merge the base_dict."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_property_from_xml(root, path):\n    element = root.find(path, XML_NS)\n    try:\n        return element.text.strip(' \\t\\n\\r')\n    except AttributeError:\n        return None", "response": "Get the text from an XML property."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets image that will be used as north arrow in reports.", "response": "def north_arrow(self, north_arrow_path):\n        \"\"\"Set image that will be used as north arrow in reports.\n\n        :param north_arrow_path: Path to the north arrow image.\n        :type north_arrow_path: str\n        \"\"\"\n        if isinstance(north_arrow_path, str) and os.path.exists(\n                north_arrow_path):\n            self._north_arrow = north_arrow_path\n        else:\n            self._north_arrow = default_north_arrow_path()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef organisation_logo(self, logo):\n        if isinstance(logo, str) and os.path.exists(logo):\n            self._organisation_logo = logo\n        else:\n            self._organisation_logo = supporters_logo_path()", "response": "Set image that will be used as organisation logo in reports."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef disclaimer(self, text):\n        if not isinstance(text, str):\n            self._disclaimer = disclaimer()\n        else:\n            self._disclaimer = text", "response": "Set text that will be used as disclaimer in reports."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef output_folder(self, value):\n        self._output_folder = value\n        if not os.path.exists(self._output_folder):\n            os.makedirs(self._output_folder)", "response": "Set the output folder path for the rendering."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef absolute_output_path(\n            output_folder, components, component_key):\n        \"\"\"Return absolute output path of component.\n\n        :param output_folder: The base output folder\n        :type output_folder: str\n\n        :param components: The list of components to look up\n        :type components: list[ReportMetadata]\n\n        :param component_key: The component key\n        :type component_key: str\n\n        :return: absolute output path\n        :rtype: str\n\n        .. versionadded:: 4.0\n        \"\"\"\n        comp_keys = [c.key for c in components]\n\n        if component_key in comp_keys:\n            idx = comp_keys.index(component_key)\n            output_path = components[idx].output_path\n            if isinstance(output_path, str):\n                return os.path.abspath(\n                    os.path.join(output_folder, output_path))\n            elif isinstance(output_path, list):\n                output_list = []\n                for path in output_path:\n                    output_list.append(os.path.abspath(\n                        os.path.join(output_folder, path)))\n                return output_list\n            elif isinstance(output_path, dict):\n                output_dict = {}\n                for key, path in list(output_path.items()):\n                    output_dict[key] = os.path.abspath(\n                        os.path.join(output_folder, path))\n                return output_dict\n        return None", "response": "Return absolute output path of component."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef component_absolute_output_path(self, component_key):\n        return ImpactReport.absolute_output_path(\n            self.output_folder,\n            self.metadata.components,\n            component_key)", "response": "Return absolute output path of component."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _check_layer_count(self, layer):\n        if layer:\n            if not layer.isValid():\n                raise ImpactReport.LayerException('Layer is not valid')\n            if isinstance(layer, QgsRasterLayer):\n                # can't check feature count of raster layer\n                return\n            feature_count = len([f for f in layer.getFeatures()])\n            if feature_count == 0:\n                raise ImpactReport.LayerException(\n                    'Layer contains no features')", "response": "Check for validity of the layer."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the map title from the layer keywords if possible.", "response": "def map_title(self):\n        \"\"\"Get the map title from the layer keywords if possible.\n\n        :returns: None on error, otherwise the title.\n        :rtype: None, str\n        \"\"\"\n        # noinspection PyBroadException\n        try:\n            title = self._keyword_io.read_keywords(\n                self.impact, 'map_title')\n            return title\n        except KeywordNotFoundError:\n            return None\n        except Exception:  # pylint: disable=broad-except\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the map legend attributes from the keywords if possible.", "response": "def map_legend_attributes(self):\n        \"\"\"Get the map legend attribute from the layer keywords if possible.\n\n        :returns: None on error, otherwise the attributes (notes and units).\n        :rtype: None, str\n        \"\"\"\n        LOGGER.debug('InaSAFE Map getMapLegendAttributes called')\n        legend_attribute_list = [\n            'legend_notes',\n            'legend_units',\n            'legend_title']\n        legend_attribute_dict = {}\n        for legend_attribute in legend_attribute_list:\n            # noinspection PyBroadException\n            try:\n                legend_attribute_dict[legend_attribute] = \\\n                    self._keyword_io.read_keywords(\n                        self.impact, legend_attribute)\n            except KeywordNotFoundError:\n                pass\n            except Exception:  # pylint: disable=broad-except\n                pass\n        return legend_attribute_dict"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process_components(self):\n        message = m.Message()\n        warning_heading = m.Heading(\n            tr('Report Generation issue'), **WARNING_STYLE)\n        message.add(warning_heading)\n        failed_extract_context = m.Heading(tr(\n            'Failed to extract context'), **WARNING_STYLE)\n        failed_render_context = m.Heading(tr(\n            'Failed to render context'), **WARNING_STYLE)\n        failed_find_extractor = m.Heading(tr(\n            'Failed to load extractor method'), **WARNING_STYLE)\n        failed_find_renderer = m.Heading(tr(\n            'Failed to load renderer method'), **WARNING_STYLE)\n\n        generation_error_code = self.REPORT_GENERATION_SUCCESS\n\n        for component in self.metadata.components:\n            # load extractors\n            try:\n                if not component.context:\n                    if isinstance(component.extractor, collections.Callable):\n                        _extractor_method = component.extractor\n                    else:\n                        _package_name = (\n                            '%(report-key)s.extractors.%(component-key)s')\n                        _package_name %= {\n                            'report-key': self.metadata.key,\n                            'component-key': component.key\n                        }\n                        # replace dash with underscores\n                        _package_name = _package_name.replace('-', '_')\n                        _extractor_path = os.path.join(\n                            self.metadata.template_folder,\n                            component.extractor\n                        )\n                        _module = imp.load_source(\n                            _package_name, _extractor_path)\n                        _extractor_method = getattr(_module, 'extractor')\n                else:\n                    LOGGER.info('Predefined context. Extractor not needed.')\n            except Exception as e:  # pylint: disable=broad-except\n                generation_error_code = self.REPORT_GENERATION_FAILED\n                LOGGER.info(e)\n                if not self.impact_function.use_rounding:\n                    raise\n                else:\n                    message.add(failed_find_extractor)\n                    message.add(component.info)\n                    message.add(get_error_message(e))\n                    continue\n\n            # method signature:\n            #  - this ImpactReport\n            #  - this component\n            try:\n                if not component.context:\n                    context = _extractor_method(self, component)\n                    component.context = context\n                else:\n                    LOGGER.info('Using predefined context.')\n            except Exception as e:  # pylint: disable=broad-except\n                generation_error_code = self.REPORT_GENERATION_FAILED\n                LOGGER.info(e)\n                if not self.impact_function.use_rounding:\n                    raise\n                else:\n                    message.add(failed_extract_context)\n                    message.add(get_error_message(e))\n                    continue\n\n            try:\n                # load processor\n                if isinstance(component.processor, collections.Callable):\n                    _renderer = component.processor\n                else:\n                    _package_name = '%(report-key)s.renderer.%(component-key)s'\n                    _package_name %= {\n                        'report-key': self.metadata.key,\n                        'component-key': component.key\n                    }\n                    # replace dash with underscores\n                    _package_name = _package_name.replace('-', '_')\n                    _renderer_path = os.path.join(\n                        self.metadata.template_folder,\n                        component.processor\n                    )\n                    _module = imp.load_source(_package_name, _renderer_path)\n                    _renderer = getattr(_module, 'renderer')\n            except Exception as e:  # pylint: disable=broad-except\n                generation_error_code = self.REPORT_GENERATION_FAILED\n                LOGGER.info(e)\n                if not self.impact_function.use_rounding:\n                    raise\n                else:\n                    message.add(failed_find_renderer)\n                    message.add(component.info)\n                    message.add(get_error_message(e))\n                    continue\n\n            # method signature:\n            #  - this ImpactReport\n            #  - this component\n            if component.context:\n                try:\n                    output = _renderer(self, component)\n                    output_path = self.component_absolute_output_path(\n                        component.key)\n                    if isinstance(output_path, dict):\n                        try:\n                            dirname = os.path.dirname(output_path.get('doc'))\n                        except BaseException:\n                            dirname = os.path.dirname(output_path.get('map'))\n                    else:\n                        dirname = os.path.dirname(output_path)\n                    if component.resources:\n                        for resource in component.resources:\n                            target_resource = os.path.basename(resource)\n                            target_dir = os.path.join(\n                                dirname, 'resources', target_resource)\n                            # copy here\n                            if os.path.exists(target_dir):\n                                shutil.rmtree(target_dir)\n                            shutil.copytree(resource, target_dir)\n                    component.output = output\n                except Exception as e:  # pylint: disable=broad-except\n                    generation_error_code = self.REPORT_GENERATION_FAILED\n                    LOGGER.info(e)\n                    if not self.impact_function.use_rounding:\n                        raise\n                    else:\n                        message.add(failed_render_context)\n                        message.add(get_error_message(e))\n                        continue\n\n        return generation_error_code, message", "response": "Processes the components and templates and returns a tuple of error code and message."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_next_step(self):\n        if self.parent.get_layer_geometry_key() == \\\n                layer_geometry_raster['key']:\n            return self.parent.step_kw_source\n\n        layer_purpose = self.parent.step_kw_purpose.selected_purpose()\n        if layer_purpose['key'] != layer_purpose_aggregation['key']:\n            subcategory = self.parent.step_kw_subcategory. \\\n                selected_subcategory()\n        else:\n            subcategory = {'key': None}\n\n        # Get all fields with replace_null = False\n        inasafe_fields = get_fields(\n            layer_purpose['key'],\n            subcategory['key'],\n            replace_null=False,\n            in_group=False\n        )\n        # remove compulsory field since it has been set in previous step\n        try:\n            inasafe_fields.remove(get_compulsory_fields(\n                layer_purpose['key'], subcategory['key']))\n        except ValueError:\n            pass\n\n        # Check if possible to skip inasafe field step\n        if skip_inasafe_field(self.parent.layer, inasafe_fields):\n            default_inasafe_fields = get_fields(\n                layer_purpose['key'],\n                subcategory['key'],\n                replace_null=True,\n                in_group=False\n            )\n            # Check if it can go to inasafe default step\n            if default_inasafe_fields:\n                return self.parent.step_kw_default_inasafe_fields\n            # Else, go to source step\n            else:\n                return self.parent.step_kw_source\n\n        # If not possible to skip inasafe field step, then go there\n        else:\n            return self.parent.step_kw_inasafe_fields", "response": "Find the proper step when user clicks the Next button."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nobtain the value - to - class mapping set by user.", "response": "def selected_mapping(self):\n        \"\"\"Obtain the value-to-class mapping set by user.\n\n        :returns: The complete mapping as a dict of lists.\n        :rtype: dict\n        \"\"\"\n        value_map = {}\n        tree_clone = self.treeClasses.invisibleRootItem().clone()\n        for tree_branch in tree_clone.takeChildren():\n            value_list = []\n            for tree_leaf in tree_branch.takeChildren():\n                value_list += [tree_leaf.data(0, Qt.UserRole)]\n            if value_list:\n                value_map[tree_branch.data(0, Qt.UserRole)] = value_list\n        return value_map"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting widgets on the Classify tab.", "response": "def set_widgets(self):\n        \"\"\"Set widgets on the Classify tab.\"\"\"\n        purpose = self.parent.step_kw_purpose.selected_purpose()\n        subcategory = self.parent.step_kw_subcategory.selected_subcategory()\n\n        classification = self.parent.step_kw_classification.\\\n            selected_classification()\n        classification_name = classification['name']\n\n        if is_raster_layer(self.parent.layer):\n            self.lblClassify.setText(classify_raster_question % (\n                subcategory['name'], purpose['name'], classification_name))\n            dataset = gdal.Open(self.parent.layer.source(), GA_ReadOnly)\n            active_band = self.parent.step_kw_band_selector.selected_band()\n            unique_values = numpy.unique(numpy.array(\n                dataset.GetRasterBand(active_band).ReadAsArray()))\n            field_type = 0\n            # Convert datatype to a json serializable type\n            if numpy.issubdtype(unique_values.dtype, float):\n                unique_values = [float(i) for i in unique_values]\n            else:\n                unique_values = [int(i) for i in unique_values]\n        else:\n            field = self.parent.step_kw_field.selected_fields()\n            field_index = self.parent.layer.fields().indexFromName(field)\n            field_type = self.parent.layer.fields()[field_index].type()\n            self.lblClassify.setText(classify_vector_question % (\n                subcategory['name'], purpose['name'],\n                classification_name, field.upper()))\n            unique_values = self.parent.layer.uniqueValues(field_index)\n\n        clean_unique_values = []\n        for unique_value in unique_values:\n            if (unique_value is None\n                    or (hasattr(unique_value, 'isNull')\n                        and unique_value.isNull())):\n                # Don't classify features with NULL value\n                continue\n            clean_unique_values.append(unique_value)\n\n        # get default classes\n        default_classes = deepcopy(classification['classes'])\n        if classification['key'] == data_driven_classes['key']:\n            for unique_value in clean_unique_values:\n                name = str(unique_value).upper().replace('_', ' ')\n                default_class = {'key': unique_value,\n                                 'name': name,\n                                 # 'description': tr('Settlement'),\n                                 'string_defaults': [name]}\n\n                default_classes.append(default_class)\n\n        # Assign unique values to classes (according to default)\n        unassigned_values = list()\n        assigned_values = dict()\n\n        for default_class in default_classes:\n            assigned_values[default_class['key']] = list()\n        for unique_value in clean_unique_values:\n            # Capitalization of the value and removing '_' (raw OSM data).\n            value_as_string = str(unique_value).upper().replace('_', ' ')\n            assigned = False\n            for default_class in default_classes:\n                if 'string_defaults' in default_class:\n                    # To make it case insensitive\n                    upper_string_defaults = [\n                        c.upper() for c in default_class['string_defaults']]\n                    in_string_default = (\n                        value_as_string in upper_string_defaults)\n                    condition_1 = field_type > 9 and in_string_default\n                else:\n                    condition_1 = False\n                condition_2 = (\n                    field_type < 10\n                    and 'numeric_default_min' in default_class\n                    and 'numeric_default_max' in default_class\n                    and (default_class['numeric_default_min']\n                         <= unique_value\n                         <= default_class['numeric_default_max']))\n                if condition_1 or condition_2:\n                    assigned_values[default_class['key']] += [unique_value]\n                    assigned = True\n\n            if not assigned:\n                # add to unassigned values list otherwise\n                unassigned_values += [unique_value]\n\n        self.populate_classified_values(\n            unassigned_values, assigned_values, default_classes)\n\n        # Overwrite assigned values according to existing keyword (if present).\n        # Note the default_classes and unique_values are already loaded!\n\n        value_map = self.parent.get_existing_keyword('value_map')\n        value_map_classification_name = self.parent.get_existing_keyword(\n            'classification')\n        # Do not continue if there is no value_map in existing keywords\n        if (value_map is None\n                or value_map_classification_name != classification['key']):\n            return\n\n        # Do not continue if user selected different field\n        field_keyword = self.parent.field_keyword_for_the_layer()\n        field = self.parent.get_existing_keyword('inasafe_fields').get(\n            field_keyword)\n        if (not is_raster_layer(self.parent.layer)\n                and field != self.parent.step_kw_field.selected_fields()):\n            return\n\n        unassigned_values = list()\n        assigned_values = dict()\n        for default_class in default_classes:\n            assigned_values[default_class['key']] = list()\n        if isinstance(value_map, str):\n            try:\n                value_map = json.loads(value_map)\n            except ValueError:\n                return\n\n        for unique_value in clean_unique_values:\n            # check in value map\n            assigned = False\n            for key, value_list in list(value_map.items()):\n                if unique_value in value_list and key in assigned_values:\n                    assigned_values[key] += [unique_value]\n                    assigned = True\n            if not assigned:\n                unassigned_values += [unique_value]\n        self.populate_classified_values(\n            unassigned_values, assigned_values, default_classes)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef populate_classified_values(\n            self, unassigned_values, assigned_values, default_classes):\n        \"\"\"Populate lstUniqueValues and treeClasses.from the parameters.\n\n        :param unassigned_values: List of values that haven't been assigned\n            to a class. It will be put in self.lstUniqueValues.\n        :type unassigned_values: list\n\n        :param assigned_values: Dictionary with class as the key and list of\n            value as the value of the dictionary. It will be put in\n            self.treeClasses.\n        :type assigned_values: dict\n\n        :param default_classes: Default classes from unit.\n        :type default_classes: list\n        \"\"\"\n        # Populate the unique values list\n        self.lstUniqueValues.clear()\n        self.lstUniqueValues.setSelectionMode(\n            QAbstractItemView.ExtendedSelection)\n        for value in unassigned_values:\n            value_as_string = value is not None and str(value) or 'NULL'\n            list_item = QListWidgetItem(self.lstUniqueValues)\n            list_item.setFlags(\n                Qt.ItemIsEnabled\n                | Qt.ItemIsSelectable\n                | Qt.ItemIsDragEnabled)\n            list_item.setData(Qt.UserRole, value)\n            list_item.setText(value_as_string)\n            self.lstUniqueValues.addItem(list_item)\n        # Populate assigned values tree\n        self.treeClasses.clear()\n        self.treeClasses.invisibleRootItem().setFlags(Qt.ItemIsEnabled)\n        for default_class in default_classes:\n            # Create branch for class\n            tree_branch = QTreeWidgetItem(self.treeClasses)\n            tree_branch.setFlags(Qt.ItemIsDropEnabled | Qt.ItemIsEnabled)\n            tree_branch.setExpanded(True)\n            tree_branch.setFont(0, bold_font)\n            if 'name' in default_class:\n                default_class_name = default_class['name']\n            else:\n                default_class_name = default_class['key']\n            tree_branch.setText(0, default_class_name)\n            tree_branch.setData(0, Qt.UserRole, default_class['key'])\n            if 'description' in default_class:\n                tree_branch.setToolTip(0, default_class['description'])\n            # Assign known values\n            for value in assigned_values[default_class['key']]:\n                string_value = value is not None and str(value) or 'NULL'\n                tree_leaf = QTreeWidgetItem(tree_branch)\n                tree_leaf.setFlags(\n                    Qt.ItemIsEnabled\n                    | Qt.ItemIsSelectable\n                    | Qt.ItemIsDragEnabled)\n                tree_leaf.setData(0, Qt.UserRole, value)\n                tree_leaf.setText(0, string_value)", "response": "Populate the unassigned and assigned values of the classified items in the list and tree classes."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of vector layers available in the geopackage.", "response": "def _vector_layers(self):\n        \"\"\"Return a list of vector layers available.\n\n        :return: List of vector layers available in the geopackage.\n        :rtype: list\n\n        .. versionadded:: 4.0\n        \"\"\"\n        layers = []\n        vector_datasource = self.vector_driver.Open(\n            self.uri.absoluteFilePath())\n        if vector_datasource:\n            for i in range(vector_datasource.GetLayerCount()):\n                layers.append(vector_datasource.GetLayer(i).GetName())\n        return layers"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _raster_layers(self):\n        layers = []\n\n        raster_datasource = gdal.Open(self.uri.absoluteFilePath())\n        if raster_datasource:\n            subdatasets = raster_datasource.GetSubDatasets()\n            if len(subdatasets) == 0:\n                metadata = raster_datasource.GetMetadata()\n                layers.append(metadata['IDENTIFIER'])\n            else:\n                for subdataset in subdatasets:\n                    layers.append(subdataset[0].split(':')[2])\n\n        return layers", "response": "Return a list of raster layers available in the geopackage."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef layer_uri(self, layer_name):\n        for layer in self._vector_layers():\n            if layer == layer_name:\n                uri = '{}|layername={}'.format(\n                    self.uri.absoluteFilePath(), layer_name)\n                return uri\n        else:\n            for layer in self._raster_layers():\n                if layer == layer_name:\n                    uri = 'GPKG:{}:{}'.format(\n                        self.uri.absoluteFilePath(), layer_name)\n                    return uri\n            else:\n                return None", "response": "Get the URI to the layer."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a vector layer to the geopackage.", "response": "def _add_vector_layer(self, vector_layer, layer_name, save_style=False):\n        \"\"\"Add a vector layer to the geopackage.\n\n        :param vector_layer: The layer to add.\n        :type vector_layer: QgsVectorLayer\n\n        :param layer_name: The name of the layer in the datastore.\n        :type layer_name: str\n\n        :param save_style: If we have to save a QML too. Default to False.\n        Not implemented in geopackage !\n        :type save_style: bool\n\n        :returns: A two-tuple. The first element will be True if we could add\n            the layer to the datastore. The second element will be the layer\n            name which has been used or the error message.\n        :rtype: (bool, str)\n\n        .. versionadded:: 4.0\n        \"\"\"\n\n        # Fixme\n        # if not self.is_writable():\n        #    return False, 'The destination is not writable.'\n\n        geometry = QGIS_OGR_GEOMETRY_MAP[vector_layer.wkbType()]\n\n        spatial_reference = osr.SpatialReference()\n        qgis_spatial_reference = vector_layer.crs().authid()\n        # Use 4326 as default if the spatial reference is not found\n        epsg = 4326\n        epsg_string = qgis_spatial_reference\n        if epsg_string:\n            epsg = int(epsg_string.split(':')[1])\n        spatial_reference.ImportFromEPSG(epsg)\n\n        vector_datasource = self.vector_driver.Open(\n            self.uri.absoluteFilePath(), True)\n        vector_datasource.CreateLayer(layer_name, spatial_reference, geometry)\n        uri = '{}|layerid=0'.format(self.uri.absoluteFilePath())\n        vector_layer = QgsVectorLayer(uri, layer_name, 'ogr')\n\n        data_provider = vector_layer.dataProvider()\n        for feature in vector_layer.getFeatures():\n            data_provider.addFeatures([feature])\n\n        return True, layer_name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _add_raster_layer(self, raster_layer, layer_name, save_style=False):\n\n        source = gdal.Open(raster_layer.source())\n        array = source.GetRasterBand(1).ReadAsArray()\n\n        x_size = source.RasterXSize\n        y_size = source.RasterYSize\n\n        output = self.raster_driver.Create(\n            self.uri.absoluteFilePath(),\n            x_size,\n            y_size,\n            1,\n            gdal.GDT_Byte,\n            ['APPEND_SUBDATASET=YES', 'RASTER_TABLE=%s' % layer_name]\n        )\n\n        output.SetGeoTransform(source.GetGeoTransform())\n        output.SetProjection(source.GetProjection())\n        output.GetRasterBand(1).WriteArray(array)\n\n        # Once we're done, close properly the dataset\n        output = None\n        source = None\n        return True, layer_name", "response": "Add a raster layer to the datastore."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _add_tabular_layer(self, tabular_layer, layer_name, save_style=False):\n        return self._add_vector_layer(tabular_layer, layer_name, save_style)", "response": "Add a tabular layer to the geopackage."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds the proper step when user clicks the Next button.", "response": "def get_next_step(self):\n        \"\"\"Find the proper step when user clicks the Next button.\n\n        :returns: The step to be switched to\n        :rtype: WizardStep instance or None\n        \"\"\"\n        if self.parent.is_selected_layer_keywordless:\n            # insert keyword creation thread here\n            self.parent.parent_step = self\n            self.parent.existing_keywords = None\n            self.parent.set_mode_label_to_keywords_creation()\n            new_step = self.parent.step_kw_purpose\n        else:\n            new_step = self.parent.step_fc_explayer_origin\n        return new_step"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate layer description label availNext", "response": "def on_lstCanvasHazLayers_itemSelectionChanged(self):\n        \"\"\"Update layer description label\n\n        .. note:: This is an automatic Qt slot\n           executed when the category selection changes.\n        \"\"\"\n\n        self.parent.hazard_layer = self.selected_canvas_hazlayer()\n        lblText = self.parent.get_layer_description_from_canvas(\n            self.parent.hazard_layer, 'hazard')\n        self.lblDescribeCanvasHazLayer.setText(lblText)\n        self.parent.pbnNext.setEnabled(True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef selected_canvas_hazlayer(self):\n\n        if self.lstCanvasHazLayers.selectedItems():\n            item = self.lstCanvasHazLayers.currentItem()\n        else:\n            return None\n        try:\n            layer_id = item.data(Qt.UserRole)\n        except (AttributeError, NameError):\n            layer_id = None\n\n        # noinspection PyArgumentList\n        layer = QgsProject.instance().mapLayer(layer_id)\n        return layer", "response": "Obtain the canvas layer selected by user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfill the list widget with compatible layers.", "response": "def list_compatible_canvas_layers(self):\n        \"\"\"Fill the list widget with compatible layers.\n\n        :returns: Metadata of found layers.\n        :rtype: list of dicts\n        \"\"\"\n        italic_font = QFont()\n        italic_font.setItalic(True)\n        list_widget = self.lstCanvasHazLayers\n        # Add compatible layers\n        list_widget.clear()\n        for layer in self.parent.get_compatible_canvas_layers('hazard'):\n            item = QListWidgetItem(layer['name'], list_widget)\n            item.setData(Qt.UserRole, layer['id'])\n            if not layer['keywords']:\n                item.setFont(italic_font)\n            list_widget.addItem(item)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting widgets on the Hazard Layer From TOC tab.", "response": "def set_widgets(self):\n        \"\"\"Set widgets on the Hazard Layer From TOC tab.\"\"\"\n        # The list is already populated in the previous step, but now we\n        # need to do it again in case we're back from the Keyword Wizard.\n        # First, preserve self.parent.layer before clearing the list\n        last_layer = self.parent.layer and self.parent.layer.id() or None\n        self.lblDescribeCanvasHazLayer.clear()\n        self.list_compatible_canvas_layers()\n        self.auto_select_one_item(self.lstCanvasHazLayers)\n        # Try to select the last_layer, if found:\n        if last_layer:\n            layers = []\n            for index in range(self.lstCanvasHazLayers.count()):\n                item = self.lstCanvasHazLayers.item(index)\n                layers += [item.data(Qt.UserRole)]\n            if last_layer in layers:\n                self.lstCanvasHazLayers.setCurrentRow(layers.index(last_layer))\n\n        # Set icon\n        hazard = self.parent.step_fc_functions1.selected_value(\n            layer_purpose_hazard['key'])\n        icon_path = get_image_path(hazard)\n        self.lblIconIFCWHazardFromCanvas.setPixmap(QPixmap(icon_path))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_equal(self, other):\n        properties = [\n            'debug_mode',\n            'use_rounding',\n            'requested_extent',\n            'crs',\n            'analysis_extent',\n            'datastore',\n            'name',\n            'title',\n            'start_datetime',\n            'end_datetime',\n            'duration',\n            'earthquake_function',\n            # 'performance_log',  # I don't think need we need this one\n            'hazard',\n            'exposure',\n            'aggregation',\n\n            # Output layers on new IF object will have a different provenance\n            # data with the one from original IF.\n\n            # 'impact',\n            # 'exposure_summary',\n            # 'aggregate_hazard_impacted',\n            # 'aggregation_summary',\n            # 'analysis_impacted',\n            # 'exposure_summary_table',\n\n            'profiling',\n        ]\n        for if_property in properties:\n            # Skip if it's debug mode for profiling\n            if self.debug_mode:\n                if if_property == 'profiling':\n                    continue\n            try:\n                property_a = getattr(self, if_property)\n                property_b = getattr(other, if_property)\n                if not isinstance(property_a, type(property_b)):\n                    message = (\n                        'Different type of property %s.\\nA: %s\\nB: %s' % (\n                            if_property, type(property_a), type(property_b)))\n                    return False, message\n                if isinstance(property_a, QgsMapLayer):\n                    if byteify(property_a.keywords) != byteify(\n                            property_b.keywords):\n                        message = (\n                            'Keyword Layer is not equal is %s' % if_property)\n                        return False, message\n                    if isinstance(property_a, QgsVectorLayer):\n                        fields_a = [f.name() for f in property_a.fields()]\n                        fields_b = [f.name() for f in property_b.fields()]\n                        if fields_a != fields_b:\n                            message = (\n                                'Layer fields is not equal for %s' %\n                                if_property)\n                            return False, message\n                        if (property_a.featureCount()\n                                != property_b.featureCount()):\n                            message = (\n                                'Feature count is not equal for %s' %\n                                if_property)\n                            return False, message\n                elif isinstance(property_a, QgsGeometry):\n                    if not property_a.equals(property_b):\n                        string_a = property_a.asWkt()\n                        string_b = property_b.asWkt()\n                        message = (\n                            '[Non Layer] The not equal property is %s.\\n'\n                            'A: %s\\nB: %s' % (if_property, string_a, string_b))\n                        return False, message\n                elif isinstance(property_a, DataStore):\n                    if property_a.uri_path != property_b.uri_path:\n                        string_a = property_a.uri_path\n                        string_b = property_b.uri_path\n                        message = (\n                            '[Non Layer] The not equal property is %s.\\n'\n                            'A: %s\\nB: %s' % (if_property, string_a, string_b))\n                        return False, message\n                else:\n                    if property_a != property_b:\n                        string_a = property_a\n                        string_b = property_b\n                        message = (\n                            '[Non Layer] The not equal property is %s.\\n'\n                            'A: %s\\nB: %s' % (if_property, string_a, string_b))\n                        return False, message\n            except AttributeError as e:\n                message = (\n                    'Property %s is not found. The exception is %s' % (\n                        if_property, e))\n                return False, message\n            except IndexError as e:\n                if if_property == 'impact':\n                    continue\n                else:\n                    message = (\n                        'Property %s is out of index. The exception is %s' % (\n                            if_property, e))\n                    return False, message\n            except Exception as e:\n                message = (\n                    'Error on %s with error message %s' % (if_property, e))\n                return False, message\n\n        return True, ''", "response": "Equality checker with message\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef performance_log_message(self):\n        message = m.Message()\n        table = m.Table(style_class='table table-condensed table-striped')\n        row = m.Row()\n        row.add(m.Cell(tr('Function'), header=True))\n        row.add(m.Cell(tr('Time'), header=True))\n        if setting(key='memory_profile', expected_type=bool):\n            row.add(m.Cell(tr('Memory'), header=True))\n        table.add(row)\n\n        if self.performance_log is None:\n            message.add(table)\n            return message\n\n        indent = -1\n\n        def display_tree(tree, space):\n            space += 1\n            new_row = m.Row()\n\n            # This is a kind of hack to display the tree with indentation\n            text = '|'\n            text += '*' * space\n\n            if tree.children:\n                text += '\\ '\n            else:\n                text += '| '\n            text += tree.__str__()\n\n            busy = tr('Busy')\n            new_row.add(m.Cell(text))\n            time = tree.elapsed_time\n            if time is None:\n                time = busy\n            new_row.add(m.Cell(time))\n            if setting(key='memory_profile', expected_type=bool):\n                memory_used = tree.memory_used\n                if memory_used is None:\n                    memory_used = busy\n                new_row.add(m.Cell(memory_used))\n            table.add(new_row)\n            if tree.children:\n                for child in tree.children:\n                    display_tree(child, space)\n            space -= 1\n\n        # noinspection PyTypeChecker\n        display_tree(self.performance_log, indent)\n        message.add(table)\n\n        return message", "response": "Return the profiling log as a message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef outputs(self):\n        outputs = self._outputs()\n\n        if len(outputs) != len(self._output_layer_expected):\n            # This will never happen in production.\n            # Travis will fail before.\n            # If this happen, it's an error from InaSAFE core developers.\n            raise Exception(\n                'The computed count of output layers is wrong. It should be '\n                '{expected} but the count is {count}.'.format(\n                    expected=len(self._output_layer_expected),\n                    count=len(outputs)))\n\n        return outputs", "response": "Returns a list of vector layers containing outputs from the IF."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of vector layers containing outputs from the IF.", "response": "def _outputs(self):\n        \"\"\"List of layers containing outputs from the IF.\n\n        :returns: A list of vector layers.\n        :rtype: list\n        \"\"\"\n        layers = OrderedDict()\n        layers[layer_purpose_exposure_summary['key']] = (\n            self._exposure_summary)\n        layers[layer_purpose_aggregate_hazard_impacted['key']] = (\n            self._aggregate_hazard_impacted)\n        layers[layer_purpose_aggregation_summary['key']] = (\n            self._aggregation_summary)\n        layers[layer_purpose_analysis_impacted['key']] = (\n            self._analysis_impacted)\n        layers[layer_purpose_exposure_summary_table['key']] = (\n            self._exposure_summary_table)\n        layers[layer_purpose_profiling['key']] = self._profiling_table\n\n        # Extra layers produced by pre-processing\n        layers.update(self._preprocessors_layers)\n\n        for expected_purpose, layer in list(layers.items()):\n            if layer:\n                purpose = layer.keywords.get('layer_purpose')\n                if purpose != expected_purpose:\n                    # ET 18/11/16\n                    # I'm disabling this check. If an exception is raised in\n                    # the IF, this exception might be raised and will hide the\n                    # other one.\n                    # raise Exception('Wrong layer purpose : %s != %s' % (\n                    #     purpose, expected_purpose))\n                    pass\n\n        # Remove layers which are not set.\n        layers = [layer for layer in list(layers.values()) if layer]\n        return layers"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef requested_extent(self, extent):\n        if isinstance(extent, QgsRectangle):\n            self._requested_extent = extent\n            self._is_ready = False\n        else:\n            raise InvalidExtentError('%s is not a valid extent.' % extent)", "response": "Setter for extent property."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef crs(self, crs):\n        if isinstance(crs, QgsCoordinateReferenceSystem):\n            self._crs = crs\n            self._is_ready = False\n        else:\n            raise InvalidExtentError('%s is not a valid CRS object.' % crs)", "response": "Setter for extent_crs property."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the duration of running the impact function in seconds.", "response": "def duration(self):\n        \"\"\"The duration of running the impact function in seconds.\n\n        Return 0 if the start or end datetime is None.\n\n        :return: The duration.\n        :rtype: float\n        \"\"\"\n        if self.end_datetime is None or self.start_datetime is None:\n            return 0\n        return (self.end_datetime - self.start_datetime).total_seconds()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef console_progress_callback(current, maximum, message=None):\n        # noinspection PyChainedComparisons\n        if maximum > 1000 and current % 1000 != 0 and current != maximum:\n            return\n        if message is not None:\n            LOGGER.info(message['description'])\n        LOGGER.info('Task progress: %i of %i' % (current, maximum))", "response": "Simple console based callback for tests."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncomputing output layers expected that the IF will produce.", "response": "def _compute_output_layer_expected(self):\n        \"\"\"Compute output layers expected that the IF will produce.\n\n        Be careful when you call this function. It's a private function, better\n        to use the public function `output_layers_expected()`.\n\n        :return: List of expected layer keys.\n        :rtype: list\n        \"\"\"\n        # Actually, an IF can produce maximum 6 layers, by default.\n        expected = [\n            layer_purpose_exposure_summary['key'],  # 1\n            layer_purpose_aggregate_hazard_impacted['key'],  # 2\n            layer_purpose_aggregation_summary['key'],  # 3\n            layer_purpose_analysis_impacted['key'],  # 4\n            layer_purpose_exposure_summary_table['key'],  # 5\n            layer_purpose_profiling['key'],  # 6\n        ]\n        if is_raster_layer(self.exposure):\n            if self.exposure.keywords.get('layer_mode') == 'continuous':\n                # If the exposure is a continuous raster, we can't provide the\n                # exposure impacted layer.\n                expected.remove(layer_purpose_exposure_summary['key'])\n\n        if not self.exposure.keywords.get('classification'):\n            # If the exposure doesn't have a classification, such as population\n            # census layer, we can't provide an exposure breakdown layer.\n            expected.remove(layer_purpose_exposure_summary_table['key'])\n\n        # We add any layers produced by pre-processors\n        for preprocessor in self._preprocessors:\n            if preprocessor['output'].get('type') == 'layer':\n                expected.append(preprocessor['output'].get('value')['key'])\n\n        return expected"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _compute_analysis_extent(self):\n        exposure_extent = QgsGeometry.fromRect(self.exposure.extent())\n        hazard_extent = QgsGeometry.fromRect(self.hazard.extent())\n        if self.aggregation:\n            analysis_crs = self.aggregation.crs()\n        else:\n            analysis_crs = self._crs\n\n        if self.hazard.crs().authid() != analysis_crs.authid():\n            crs_transform = QgsCoordinateTransform(\n                self.hazard.crs(), analysis_crs, QgsProject.instance())\n            hazard_extent.transform(crs_transform)\n\n        if self.exposure.crs().authid() != analysis_crs.authid():\n            crs_transform = QgsCoordinateTransform(\n                self.exposure.crs(), analysis_crs, QgsProject.instance())\n            exposure_extent.transform(crs_transform)\n\n        # We check if the hazard and the exposure overlap.\n        if not exposure_extent.intersects(hazard_extent):\n            message = generate_input_error_message(\n                tr('Layers need to overlap.'),\n                m.Paragraph(tr(\n                    'The exposure and the hazard layer need to overlap.'))\n            )\n            return PREPARE_FAILED_INSUFFICIENT_OVERLAP, message\n        else:\n            hazard_exposure = exposure_extent.intersection(hazard_extent)\n\n        if not self.aggregation:\n            if self.requested_extent:\n                user_bounding_box = QgsGeometry.fromRect(self.requested_extent)\n\n                if self._crs != self.exposure.crs():\n                    crs_transform = QgsCoordinateTransform(\n                        self._crs, self.exposure.crs(), QgsProject.instance())\n                    user_bounding_box.transform(crs_transform)\n\n                if not hazard_exposure.intersects(user_bounding_box):\n                    message = generate_input_error_message(\n                        tr('The bounding box need to overlap layers.'),\n                        m.Paragraph(tr(\n                            'The requested analysis extent is not overlaping '\n                            'the exposure and the hazard.'))\n                    )\n                    return (\n                        PREPARE_FAILED_INSUFFICIENT_OVERLAP_REQUESTED_EXTENT,\n                        message)\n                else:\n                    self._analysis_extent = hazard_exposure.intersection(\n                        user_bounding_box)\n\n            elif self.use_exposure_view_only:\n                self._analysis_extent = exposure_extent\n\n            else:\n                self._analysis_extent = hazard_exposure\n\n        else:\n            # We monkey patch if we use selected features only.\n            self.aggregation.use_selected_features_only = (\n                self.use_selected_features_only)\n            self.aggregation = create_valid_aggregation(self.aggregation)\n            list_geometry = []\n            for area in self.aggregation.getFeatures():\n                list_geometry.append(QgsGeometry(area.geometry()))\n\n            geometry = QgsGeometry.unaryUnion(list_geometry)\n            if geometry.isMultipart():\n                multi_polygon = geometry.asMultiPolygon()\n                for polygon in multi_polygon:\n                    for ring in polygon[1:]:\n                        polygon.remove(ring)\n                self._analysis_extent = QgsGeometry.fromMultiPolygonXY(\n                    multi_polygon)\n\n            else:\n                polygon = geometry.asPolygon()\n                for ring in polygon[1:]:\n                    polygon.remove(ring)\n                self._analysis_extent = QgsGeometry.fromPolygonXY(polygon)\n            is_empty = self._analysis_extent.isEmpty()\n            is_invalid = not self._analysis_extent.isGeosValid()\n            if is_empty or is_invalid:\n                message = generate_input_error_message(\n                    tr('There is a problem with the aggregation layer.'),\n                    m.Paragraph(tr(\n                        'The aggregation layer seems to have a problem. '\n                        'Some features might be invalid. You should check the '\n                        'validity of this layer or use a selection within '\n                        'this layer.'))\n                )\n                return PREPARE_FAILED_BAD_LAYER, message\n\n        return PREPARE_SUCCESS, None", "response": "Compute the minimum extent between the hazard and the hazard layer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting the layer produced to the datastore if debug mode is on.", "response": "def debug_layer(self, layer, check_fields=True, add_to_datastore=None):\n        \"\"\"Write the layer produced to the datastore if debug mode is on.\n\n        :param layer: The QGIS layer to check and save.\n        :type layer: QgsMapLayer\n\n        :param check_fields: Boolean to check or not inasafe_fields.\n            By default, it's true.\n        :type check_fields: bool\n\n        :param add_to_datastore: Boolean if we need to store the layer. This\n            parameter will overwrite the debug mode behaviour. Default to None,\n            we usually let debug mode choose for us.\n        :param add_to_datastore: bool\n\n        :return: The name of the layer added in the datastore.\n        :rtype: basestring\n        \"\"\"\n        # This one checks the memory layer.\n        check_layer(layer, has_geometry=None)\n\n        if isinstance(layer, QgsVectorLayer) and check_fields:\n            is_geojson = '.geojson' in layer.source().lower()\n            if layer.featureCount() == 0 and is_geojson:\n                # https://issues.qgis.org/issues/18370\n                # We can't check a geojson file with 0 feature.\n                pass\n            else:\n                check_inasafe_fields(layer)\n\n        # Be careful, add_to_datastore can be None, True or False.\n        # None means we let debug_mode to choose for us.\n        # If add_to_datastore is not None, we do not care about debug_mode.\n        if isinstance(add_to_datastore, bool) and add_to_datastore:\n            save_layer = True\n        elif isinstance(add_to_datastore, bool) and not add_to_datastore:\n            save_layer = False\n        elif self.debug_mode:\n            save_layer = True\n        else:\n            save_layer = False\n\n        if save_layer:\n            result, name = self.datastore.add_layer(\n                layer, layer.keywords['title'])\n            if not result:\n                raise Exception(\n                    'Something went wrong with the datastore : {error_message}'\n                    .format(error_message=name))\n            if self.debug_mode:\n                # This one checks the GeoJSON file. We noticed some difference\n                # between checking a memory layer and a file based layer.\n                check_layer(self.datastore.layer(name))\n\n            return name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self):\n        self._start_datetime = datetime.now()\n        if not self._is_ready:\n            message = generate_input_error_message(\n                tr('You need to run `prepare` first.'),\n                m.Paragraph(tr(\n                    'In order to run the analysis, you need to call '\n                    '\"prepare\" before this function.')))\n            return ANALYSIS_FAILED_BAD_INPUT, message\n\n        try:\n            self.reset_state()\n            clear_prof_data()\n            self._run()\n\n            # Get the profiling log\n            self._performance_log = profiling_log()\n            self.callback(8, 8, analysis_steps['profiling'])\n\n            self._profiling_table = create_profile_layer(\n                self.performance_log_message())\n            result, name = self.datastore.add_layer(\n                self._profiling_table, self._profiling_table.keywords['title'])\n            if not result:\n                raise Exception(\n                    'Something went wrong with the datastore : {error_message}'\n                    .format(error_message=name))\n            self._profiling_table = self.datastore.layer(name)\n            self.profiling.keywords['provenance_data'] = self.provenance\n            write_iso19115_metadata(\n                self.profiling.source(),\n                self.profiling.keywords)\n\n            # Style all output layers.\n            self.style()\n\n            # End of the impact function. We need to set this IF not ready.\n            self._is_ready = False\n\n            # Set back input layers.\n            self.hazard = load_layer(\n                get_provenance(self.provenance, provenance_hazard_layer))[0]\n            self.exposure = load_layer(\n                get_provenance(self.provenance, provenance_exposure_layer))[0]\n            aggregation_path = get_provenance(\n                self.provenance, provenance_aggregation_layer)\n            LOGGER.debug('Aggregation %s' % aggregation_path)\n            if aggregation_path:\n                self.aggregation = load_layer(aggregation_path)[0]\n            else:\n                self.aggregation = None\n\n        except NoFeaturesInExtentError:\n            warning_heading = m.Heading(\n                tr('No features in the extent'), **WARNING_STYLE)\n            warning_message = tr(\n                'There are no features in the analysis extent.')\n            suggestion_heading = m.Heading(\n                tr('Suggestion'), **SUGGESTION_STYLE)\n            suggestion = tr(\n                'Try zooming in to a bigger area or check your features ('\n                'geometry and attribute table). For instance, an empty '\n                'geometry or an hazard without value are removed during the '\n                'process.')\n\n            message = m.Message()\n            message.add(warning_heading)\n            message.add(warning_message)\n            message.add(suggestion_heading)\n            message.add(suggestion)\n            return ANALYSIS_FAILED_BAD_INPUT, message\n\n        except SpatialIndexCreationError:\n            warning_heading = m.Heading(\n                tr('Layer geometry issue'), **WARNING_STYLE)\n            warning_message = tr(\n                'There is a problem while creating the spatial index. '\n                'Unfortunately, there is nothing you can do. Maybe try '\n                'another area or another aggregation layer.')\n            message = m.Message()\n            message.add(warning_heading)\n            message.add(warning_message)\n            return ANALYSIS_FAILED_BAD_INPUT, message\n\n        except ProcessingInstallationError:\n            warning_heading = m.Heading(\n                tr('Configuration issue'), **WARNING_STYLE)\n            warning_message = tr(\n                'There is a problem with the Processing plugin.')\n            suggestion_heading = m.Heading(\n                tr('Suggestion'), **SUGGESTION_STYLE)\n            suggestion = tr(\n                'InaSAFE depends on the QGIS Processing plugin. This is a '\n                'core plugin that ships with QGIS. It used to be possible to '\n                'install the processing plugin from the QGIS Plugin Manager, '\n                'however we advise you not to use these version since the '\n                'Plugin Manager version may be incompatible with the '\n                'version needed by InaSAFE. To resolve this issue, check in '\n                'your (QGIS profile path)/python/plugins directory if you '\n                'have a processing folder. If you do, remove the processing '\n                'folder and then restart QGIS. If this issue persists, please '\n                'report the problem to the InaSAFE team.')\n            message = m.Message()\n            message.add(warning_heading)\n            message.add(warning_message)\n            message.add(suggestion_heading)\n            message.add(suggestion)\n            return ANALYSIS_FAILED_BAD_INPUT, message\n\n        except InaSAFEError as e:\n            message = get_error_message(e)\n            return ANALYSIS_FAILED_BAD_CODE, message\n\n        except MemoryError:\n            warning_heading = m.Heading(tr('Memory issue'), **WARNING_STYLE)\n            warning_message = tr(\n                'There is not enough free memory to run this analysis.')\n            suggestion_heading = m.Heading(\n                tr('Suggestion'), **SUGGESTION_STYLE)\n            suggestion = tr(\n                'Try zooming in to a smaller area or using a raster layer '\n                'with a coarser resolution to speed up execution and reduce '\n                'memory requirements. You could also try adding more RAM to '\n                'your computer.')\n\n            message = m.Message()\n            message.add(warning_heading)\n            message.add(warning_message)\n            message.add(suggestion_heading)\n            message.add(suggestion)\n            return ANALYSIS_FAILED_BAD_INPUT, message\n\n        except Exception as e:\n            if self.debug_mode:\n                # We run in debug mode, we do not want to catch the exception.\n                # You should download the First Aid plugin for instance.\n                raise\n            else:\n                message = get_error_message(e)\n                return ANALYSIS_FAILED_BAD_CODE, message\n\n        else:\n            return ANALYSIS_SUCCESS, None", "response": "Runs the whole impact function."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _run(self):\n        LOGGER.info('ANALYSIS : The impact function is starting.')\n        step_count = len(analysis_steps)\n        self.callback(0, step_count, analysis_steps['initialisation'])\n\n        # Set a unique name for this impact\n        self._unique_name = self._name.replace(' ', '')\n        self._unique_name = replace_accentuated_characters(self._unique_name)\n        now = datetime.now()\n        date = now.strftime('%d%B%Y')\n        # We need to add milliseconds to be sure to have a unique name.\n        # Some tests are executed in less than a second.\n        time = now.strftime('%Hh%M-%S.%f')\n        self._unique_name = '%s_%s_%s' % (self._unique_name, date, time)\n\n        if not self._datastore:\n            # By default, results will go in a temporary folder.\n            # Users are free to set their own datastore with the setter.\n            self.callback(1, step_count, analysis_steps['data_store'])\n\n            default_user_directory = setting(\n                'defaultUserDirectory', default='')\n            if default_user_directory:\n                path = join(default_user_directory, self._unique_name)\n                if not exists(path):\n                    makedirs(path)\n                self._datastore = Folder(path)\n            else:\n                self._datastore = Folder(temp_dir(sub_dir=self._unique_name))\n\n            self._datastore.default_vector_format = 'geojson'\n        LOGGER.info('Datastore : %s' % self.datastore.uri_path)\n\n        if self.debug_mode:\n            self._datastore.use_index = True\n\n            self.datastore.add_layer(self.exposure, 'exposure')\n            self.datastore.add_layer(self.hazard, 'hazard')\n            if self.aggregation:\n                self.datastore.add_layer(self.aggregation, 'aggregation')\n\n        self._performance_log = profiling_log()\n\n        self.callback(2, step_count, analysis_steps['pre_processing'])\n        self.pre_process()\n\n        self.callback(3, step_count, analysis_steps['aggregation_preparation'])\n        self.aggregation_preparation()\n\n        # Special case for earthquake hazard on population. We need to remove\n        # the fatality model.\n        earthquake_on_population = False\n        if self.hazard.keywords.get('hazard') == hazard_earthquake['key']:\n            if self.exposure.keywords.get('exposure') == \\\n                    exposure_population['key']:\n                earthquake_on_population = True\n        if not earthquake_on_population:\n            # This is not a EQ raster on raster population. We need to set it\n            # to None as we don't want notes specific to EQ raster on\n            # population.\n            self._earthquake_function = None\n\n        set_provenance(\n            self._provenance,\n            provenance_earthquake_function,\n            self._earthquake_function)\n\n        step_count = len(analysis_steps)\n\n        self._performance_log = profiling_log()\n        self.callback(4, step_count, analysis_steps['hazard_preparation'])\n        self.hazard_preparation()\n\n        self._performance_log = profiling_log()\n        self.callback(\n            5, step_count, analysis_steps['aggregate_hazard_preparation'])\n        self.aggregate_hazard_preparation()\n\n        self._performance_log = profiling_log()\n        self.callback(6, step_count, analysis_steps['exposure_preparation'])\n        self.exposure_preparation()\n\n        self._performance_log = profiling_log()\n        self.callback(7, step_count, analysis_steps['combine_hazard_exposure'])\n        self.intersect_exposure_and_aggregate_hazard()\n\n        self._performance_log = profiling_log()\n        self.callback(8, step_count, analysis_steps['post_processing'])\n        if is_vector_layer(self._exposure_summary):\n            # We post process the exposure summary\n            self.post_process(self._exposure_summary)\n        else:\n            # We post process the aggregate hazard.\n            # Raster continuous exposure.\n            self.post_process(self._aggregate_hazard_impacted)\n\n        # Quick hack if EQ on places, we do some ordering on the distance.\n        if self.exposure.keywords.get('exposure') == exposure_place['key']:\n            if self.hazard.keywords.get('hazard') == hazard_earthquake['key']:\n                if is_vector_layer(self._exposure_summary):\n                    field = distance_field['field_name']\n                    if self._exposure_summary.fields().lookupField(field) \\\n                            != -1:\n                        layer = create_memory_layer(\n                            'ordered',\n                            self._exposure_summary.geometryType(),\n                            self._exposure_summary.crs(),\n                            self._exposure_summary.fields())\n                        layer.startEditing()\n                        layer.keywords = copy_layer_keywords(\n                            self._exposure_summary.keywords)\n                        request = QgsFeatureRequest()\n                        request.addOrderBy('\"%s\"' % field, True, False)\n                        iterator = self._exposure_summary.getFeatures(request)\n                        for feature in iterator:\n                            layer.addFeature(feature)\n                        layer.commitChanges()\n                        self._exposure_summary = layer\n                        self.debug_layer(self._exposure_summary)\n\n        self._performance_log = profiling_log()\n        self.callback(9, step_count, analysis_steps['summary_calculation'])\n        self.summary_calculation()\n\n        self._end_datetime = datetime.now()\n        set_provenance(\n            self._provenance, provenance_start_datetime, self.start_datetime)\n        set_provenance(\n            self._provenance, provenance_end_datetime, self.end_datetime)\n        set_provenance(\n            self._provenance, provenance_duration, self.duration)\n        self._generate_provenance()\n\n        # Update provenance with output layer path\n        output_layer_provenance = {\n            provenance_layer_exposure_summary['provenance_key']: None,\n            provenance_layer_aggregate_hazard_impacted['provenance_key']: None,\n            provenance_layer_aggregation_summary['provenance_key']: None,\n            provenance_layer_analysis_impacted['provenance_key']: None,\n            provenance_layer_exposure_summary_table['provenance_key']: None,\n            provenance_layer_profiling['provenance_key']: None,\n            provenance_layer_exposure_summary_id['provenance_key']: None,\n            provenance_layer_aggregate_hazard_impacted_id[\n                'provenance_key']: None,\n            provenance_layer_aggregation_summary_id['provenance_key']: None,\n            provenance_layer_analysis_impacted_id['provenance_key']: None,\n            provenance_layer_exposure_summary_table_id['provenance_key']: None,\n        }\n\n        # End of the impact function, we can add layers to the datastore.\n        # We replace memory layers by the real layer from the datastore.\n\n        # Exposure summary\n        if self._exposure_summary:\n            self._exposure_summary.keywords[\n                'provenance_data'] = self.provenance\n            append_ISO19115_keywords(\n                self._exposure_summary.keywords)\n            result, name = self.datastore.add_layer(\n                self._exposure_summary,\n                layer_purpose_exposure_summary['key'])\n            if not result:\n                raise Exception(\n                    tr('Something went wrong with the datastore : '\n                       '{error_message}').format(error_message=name))\n            self._exposure_summary = self.datastore.layer(name)\n            self.debug_layer(self._exposure_summary, add_to_datastore=False)\n\n            output_layer_provenance[provenance_layer_exposure_summary[\n                'provenance_key']] = full_layer_uri(self._exposure_summary)\n            output_layer_provenance[provenance_layer_exposure_summary_id[\n                'provenance_key']] = self._exposure_summary.id()\n\n        # Aggregate hazard impacted\n        if self.aggregate_hazard_impacted:\n            self.aggregate_hazard_impacted.keywords[\n                'provenance_data'] = self.provenance\n            append_ISO19115_keywords(\n                self.aggregate_hazard_impacted.keywords)\n            result, name = self.datastore.add_layer(\n                self._aggregate_hazard_impacted,\n                layer_purpose_aggregate_hazard_impacted['key'])\n            if not result:\n                raise Exception(\n                    tr('Something went wrong with the datastore : '\n                       '{error_message}').format(error_message=name))\n            self._aggregate_hazard_impacted = self.datastore.layer(name)\n            self.debug_layer(\n                self._aggregate_hazard_impacted, add_to_datastore=False)\n\n            output_layer_provenance[\n                provenance_layer_aggregate_hazard_impacted['provenance_key']\n            ] = full_layer_uri(self.aggregate_hazard_impacted)\n            output_layer_provenance[\n                provenance_layer_aggregate_hazard_impacted_id['provenance_key']\n            ] = self.aggregate_hazard_impacted.id()\n\n        # Exposure summary table\n        if self._exposure.keywords.get('classification'):\n            self._exposure_summary_table.keywords[\n                'provenance_data'] = self.provenance\n            append_ISO19115_keywords(\n                self._exposure_summary_table.keywords)\n            result, name = self.datastore.add_layer(\n                self._exposure_summary_table,\n                layer_purpose_exposure_summary_table['key'])\n            if not result:\n                raise Exception(\n                    tr('Something went wrong with the datastore : '\n                       '{error_message}').format(error_message=name))\n            self._exposure_summary_table = self.datastore.layer(name)\n            self.debug_layer(\n                self._exposure_summary_table, add_to_datastore=False)\n\n            output_layer_provenance[\n                provenance_layer_exposure_summary_table['provenance_key']\n            ] = full_layer_uri(self._exposure_summary_table)\n            output_layer_provenance[\n                provenance_layer_exposure_summary_table_id['provenance_key']\n            ] = self._exposure_summary_table.id()\n\n        # Aggregation summary\n        self.aggregation_summary.keywords['provenance_data'] = self.provenance\n        append_ISO19115_keywords(self.aggregation_summary.keywords)\n        result, name = self.datastore.add_layer(\n            self._aggregation_summary,\n            layer_purpose_aggregation_summary['key'])\n        if not result:\n            raise Exception(\n                tr('Something went wrong with the datastore : '\n                   '{error_message}').format(error_message=name))\n        self._aggregation_summary = self.datastore.layer(name)\n        self.debug_layer(self._aggregation_summary, add_to_datastore=False)\n\n        output_layer_provenance[provenance_layer_aggregation_summary[\n            'provenance_key']] = full_layer_uri(self._aggregation_summary)\n        output_layer_provenance[provenance_layer_aggregation_summary_id[\n            'provenance_key']] = self._aggregation_summary.id()\n\n        # Analysis impacted\n        self.analysis_impacted.keywords['provenance_data'] = self.provenance\n        append_ISO19115_keywords(self.analysis_impacted.keywords)\n        result, name = self.datastore.add_layer(\n            self._analysis_impacted, layer_purpose_analysis_impacted['key'])\n        if not result:\n            raise Exception(\n                tr('Something went wrong with the datastore : '\n                   '{error_message}').format(error_message=name))\n        self._analysis_impacted = self.datastore.layer(name)\n        self.debug_layer(self._analysis_impacted, add_to_datastore=False)\n        output_layer_provenance[provenance_layer_analysis_impacted[\n            'provenance_key']] = full_layer_uri(self._analysis_impacted)\n        output_layer_provenance[provenance_layer_analysis_impacted_id[\n            'provenance_key']] = self._analysis_impacted.id()\n\n        # Put profiling file path to the provenance\n        # FIXME(IS): Very hacky\n        if not self.debug_mode:\n            profiling_path = join(dirname(\n                self._analysis_impacted.source()),\n                layer_purpose_profiling['name'] + '.csv')\n            output_layer_provenance[\n                provenance_layer_profiling['provenance_key']] = profiling_path\n\n        # Update provenance data with output layers URI\n        self._provenance.update(output_layer_provenance)\n        if self._exposure_summary:\n            self._exposure_summary.keywords[\n                'provenance_data'] = self.provenance\n            write_iso19115_metadata(\n                self._exposure_summary.source(),\n                self._exposure_summary.keywords)\n        if self._aggregate_hazard_impacted:\n            self._aggregate_hazard_impacted.keywords[\n                'provenance_data'] = self.provenance\n            write_iso19115_metadata(\n                self._aggregate_hazard_impacted.source(),\n                self._aggregate_hazard_impacted.keywords)\n        if self._exposure_summary_table:\n            self._exposure_summary_table.keywords[\n                'provenance_data'] = self.provenance\n            write_iso19115_metadata(\n                self._exposure_summary_table.source(),\n                self._exposure_summary_table.keywords)\n\n        self.aggregation_summary.keywords['provenance_data'] = self.provenance\n        write_iso19115_metadata(\n            self.aggregation_summary.source(),\n            self.aggregation_summary.keywords)\n\n        self.analysis_impacted.keywords['provenance_data'] = self.provenance\n        write_iso19115_metadata(\n            self.analysis_impacted.source(),\n            self.analysis_impacted.keywords)", "response": "Internal function to run the impact function with profiling."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning every pre - processors. is added to the datastore.", "response": "def pre_process(self):\n        \"\"\"Run every pre-processors.\n\n        Preprocessors are creating new layers with a specific layer_purpose.\n        This layer is added then to the datastore.\n\n        :return: Nothing\n        \"\"\"\n        LOGGER.info('ANALYSIS : Pre processing')\n\n        for pre_processor in self._preprocessors:\n            layer = pre_processor['process']['function'](self)\n            purpose = pre_processor['output'].get('value')['key']\n            save_style = pre_processor['output'].get('save_style', False)\n            result, name = self.datastore.add_layer(layer, purpose, save_style)\n            if not result:\n                raise Exception(\n                    tr('Something went wrong with the datastore : '\n                       '{error_message}').format(error_message=name))\n            layer = self.datastore.layer(name)\n            self._preprocessors_layers[purpose] = layer\n            self.debug_layer(layer, add_to_datastore=False)\n\n            self.set_state_process('pre_processor', pre_processor['name'])\n            LOGGER.info('{name} : Running'.format(name=pre_processor['name']))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef aggregation_preparation(self):\n        LOGGER.info('ANALYSIS : Aggregation preparation')\n        if not self.aggregation:\n            self.set_state_info('aggregation', 'provided', False)\n            LOGGER.info(\n                'The aggregation layer is not provided. We are going to '\n                'create it from the analysis extent and the expected CRS.')\n            self.set_state_info('impact function', 'crs', self._crs.authid())\n\n            self.set_state_process(\n                'aggregation',\n                'Convert bbox aggregation to polygon layer with keywords')\n            self.aggregation = create_virtual_aggregation(\n                self.analysis_extent, self._crs)\n            self.debug_layer(self.aggregation)\n\n            exposure = definition(self.exposure.keywords['exposure'])\n            keywords = self.exposure.keywords\n\n            # inasafe_default_values will not exist as we can't use\n            # default in the exposure layer.\n            keywords['inasafe_default_values'] = {}\n\n            if is_vector_layer(self.exposure):\n                LOGGER.info(\n                    'The exposure is a vector layer. According to the kind of '\n                    'exposure, we need to check if the exposure has some '\n                    'counts before adding some default ratios.')\n                non_compulsory_fields = get_non_compulsory_fields(\n                    layer_purpose_exposure['key'], exposure['key'])\n                for count_field in non_compulsory_fields:\n                    count_key = count_field['key']\n                    if count_key in list(count_ratio_mapping.keys()):\n                        ratio_field = count_ratio_mapping[count_key]\n                        if count_key not in keywords['inasafe_fields']:\n                            # The exposure hasn't a count field, we should add\n                            # it.\n                            default_value = get_inasafe_default_value_qsetting(\n                                QSettings(), GLOBAL, ratio_field)\n                            keywords['inasafe_default_values'][ratio_field] = (\n                                default_value)\n                            LOGGER.info(\n                                'The exposure do not have field {count}, we '\n                                'can add {ratio} = {value} to the exposure '\n                                'default values.'.format(\n                                    count=count_key,\n                                    ratio=ratio_field,\n                                    value=default_value))\n                        else:\n                            LOGGER.info(\n                                'The exposure layer has the count field '\n                                '{count}, we skip the ratio '\n                                '{ratio}.'.format(\n                                    count=count_key, ratio=ratio_field))\n\n            else:\n                LOGGER.info(\n                    'The exposure is a raster layer. The exposure can not '\n                    'have some counts. We add every global defaults to the '\n                    'exposure layer related to the exposure.')\n\n                non_compulsory_fields = get_non_compulsory_fields(\n                    layer_purpose_exposure['key'], exposure['key'])\n                for count_field in non_compulsory_fields:\n                    count_key = count_field['key']\n                    if count_key in list(count_ratio_mapping.keys()):\n                        ratio_field = count_ratio_mapping[count_key]\n                        default_value = get_inasafe_default_value_qsetting(\n                            QSettings(), GLOBAL, ratio_field)\n                        keywords['inasafe_default_values'][ratio_field] = (\n                            default_value)\n                        LOGGER.info(\n                            'We are adding {ratio} = {value} to the exposure '\n                            'default values.'.format(\n                                count=count_key,\n                                ratio=ratio_field,\n                                value=default_value))\n\n        else:\n            self.set_state_info('aggregation', 'provided', True)\n            self._crs = self._aggregation.crs()\n            self.set_state_info('impact function', 'crs', self._crs.authid())\n\n            self.set_state_process(\n                'aggregation', 'Cleaning the aggregation layer')\n            self.aggregation = prepare_vector_layer(self.aggregation)\n            self.debug_layer(self.aggregation)\n\n            # We need to check if we can add default ratios to the exposure\n            # by looking also in the aggregation layer.\n            exposure_keywords = self.exposure.keywords\n            # The exposure might be a raster so without inasafe_fields.\n            exposure_fields = exposure_keywords.get('inasafe_fields', {})\n            exposure = definition(exposure_keywords['exposure'])\n            exposure_keywords['inasafe_default_values'] = {}\n            exposure_defaults = exposure_keywords['inasafe_default_values']\n            aggregation_keywords = self.aggregation.keywords\n            aggregation_fields = aggregation_keywords['inasafe_fields']\n            if not aggregation_keywords.get('inasafe_default_values'):\n                aggregation_keywords['inasafe_default_values'] = {}\n            aggregation_default_fields = aggregation_keywords.get(\n                'inasafe_default_values')\n            non_compulsory_fields = get_non_compulsory_fields(\n                layer_purpose_exposure['key'], exposure['key'])\n            for count_field in non_compulsory_fields:\n                if count_field['key'] in list(count_ratio_mapping.keys()):\n                    ratio_field = count_ratio_mapping[count_field['key']]\n                    if count_field['key'] not in exposure_fields:\n                        # The exposure layer can be vector or a raster.\n\n                        ratio_is_a_field = ratio_field in aggregation_fields\n                        ratio_is_a_constant = (\n                            ratio_field in aggregation_default_fields)\n\n                        if ratio_is_a_constant and ratio_is_a_field:\n                            # This should of course never happen! It would\n                            # be an error from the wizard. See #3809.\n                            # Let's raise an exception.\n                            raise Exception\n\n                        if ratio_is_a_field and not ratio_is_a_constant:\n                            # The ratio is a field, we do nothing here.\n                            # The ratio will be propagated to the\n                            # aggregate_hazard layer.\n                            # Let's skip to the next field.\n                            if is_vector_layer(self.exposure):\n                                LOGGER.info(\n                                    '{ratio} field detected in the '\n                                    'aggregation layer AND the equivalent '\n                                    'count has not been detected in the '\n                                    'exposure layer. We will propagate this '\n                                    'ratio to the exposure layer later when '\n                                    'we combine these two layers.'.format(\n                                        ratio=ratio_field))\n                                continue\n                            else:\n                                LOGGER.info(\n                                    '{ratio} field detected in the '\n                                    'aggregation layer. The exposure is a '\n                                    'raster so without the equivalent count. '\n                                    'We will propagate this ratio to the '\n                                    'exposure layer later when we combine '\n                                    'these two layers.'.format(\n                                        ratio=ratio_field))\n\n                        if ratio_is_a_constant and not ratio_is_a_field:\n                            # It's a constant. We need to add to the exposure.\n                            value = aggregation_default_fields[ratio_field]\n                            exposure_defaults[ratio_field] = value\n                            if is_vector_layer(self.exposure):\n                                LOGGER.info(\n                                    '{ratio} = {value} constant detected in '\n                                    'the aggregation layer AND the equivalent '\n                                    'count has not been detected in the '\n                                    'exposure layer. We are adding this ratio '\n                                    'to the exposure layer.'.format(\n                                        ratio=ratio_field, value=value))\n                            else:\n                                LOGGER.info(\n                                    '{ratio} = {value} constant detected in '\n                                    'the aggregation layer. The exposure is a '\n                                    'raster so without the equivalent count.'\n                                    'We are adding this ratio to the exposure '\n                                    'layer.'.format(\n                                        ratio=ratio_field, value=value))\n\n                        if not ratio_is_a_constant and not ratio_is_a_field:\n                            if is_vector_layer(self.exposure):\n                                LOGGER.info(\n                                    '{ratio_field} is neither a constant nor '\n                                    'a field in the aggregation layer AND the '\n                                    'equivalent count has not been detected '\n                                    'in the exposure layer. We will do '\n                                    'nothing about it.'.format(\n                                        ratio_field=ratio_field))\n                            else:\n                                LOGGER.info(\n                                    '{ratio_field} is neither a constant nor '\n                                    'a field in the aggregation layer. The '\n                                    'exposure is a raster so without the '\n                                    'equivalent count. We will do '\n                                    'nothing about it.'.format(\n                                        ratio_field=ratio_field))\n\n                    else:\n                        # The exposure layer is a vector layer only.\n                        if ratio_field in aggregation_fields:\n                            # The count field is in the exposure and the ratio\n                            # is in the aggregation. We need to remove it from\n                            # the aggregation. We remove the keyword too.\n                            remove_fields(\n                                self.aggregation,\n                                [aggregation_fields[ratio_field]])\n                            del aggregation_fields[ratio_field]\n                            LOGGER.info(\n                                '{ratio_field} is detected in the aggregation '\n                                'layer AND {count_field} is detected in the '\n                                'exposure layer. We remove the ratio from the '\n                                'aggregation.'.format(\n                                    ratio_field=ratio_field,\n                                    count_field=count_field['key']))\n\n                        else:\n                            LOGGER.info(\n                                '{ratio_field} is not in the detected in the '\n                                'aggregation layer AND {count_field} is '\n                                'detected in the exposure layer. We do '\n                                'nothing in this step.'.format(\n                                    ratio_field=ratio_field,\n                                    count_field=count_field['key']))\n\n        self.set_state_process(\n            'aggregation',\n            'Convert the aggregation layer to the analysis layer')\n        self._analysis_impacted = create_analysis_layer(\n            self.analysis_extent, self._crs, self.name)\n        self.debug_layer(self._analysis_impacted)\n        self._analysis_impacted.keywords['exposure_keywords'] = (\n            copy_layer_keywords(self.exposure.keywords))\n        self._analysis_impacted.keywords['hazard_keywords'] = (\n            copy_layer_keywords(self.hazard.keywords))", "response": "This function is doing the aggregation preparation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef intersect_exposure_and_aggregate_hazard(self):\n        LOGGER.info('ANALYSIS : Intersect Exposure and Aggregate Hazard')\n        if is_raster_layer(self.exposure):\n            self.set_state_process(\n                'impact function',\n                'Zonal stats between exposure and aggregate hazard')\n\n            # Be careful, our own zonal stats will take care of different\n            # projections between the two layers. We don't want to reproject\n            # rasters.\n            # noinspection PyTypeChecker\n            self._aggregate_hazard_impacted = zonal_stats(\n                self.exposure, self._aggregate_hazard_impacted)\n            self.debug_layer(self._aggregate_hazard_impacted)\n\n            self.set_state_process('impact function', 'Add default values')\n            self._aggregate_hazard_impacted = add_default_values(\n                self._aggregate_hazard_impacted)\n            self.debug_layer(self._aggregate_hazard_impacted)\n\n            # I know it's redundant, it's just to be sure that we don't have\n            # any impact layer for that IF.\n            self._exposure_summary = None\n\n        else:\n            indivisible_keys = [f['key'] for f in indivisible_exposure]\n            geometry = self.exposure.geometryType()\n            exposure = self.exposure.keywords.get('exposure')\n            is_divisible = exposure not in indivisible_keys\n\n            if geometry in [\n                    QgsWkbTypes.LineGeometry,\n                    QgsWkbTypes.PolygonGeometry] and is_divisible:\n\n                self.set_state_process(\n                    'exposure', 'Make exposure layer valid')\n                self._exposure = clean_layer(self.exposure)\n                self.debug_layer(self.exposure)\n\n                self.set_state_process(\n                    'impact function', 'Make aggregate hazard layer valid')\n                self._aggregate_hazard_impacted = clean_layer(\n                    self._aggregate_hazard_impacted)\n                self.debug_layer(self._aggregate_hazard_impacted)\n\n                self.set_state_process(\n                    'impact function',\n                    'Intersect divisible features with the aggregate hazard')\n                self._exposure_summary = intersection(\n                    self._exposure, self._aggregate_hazard_impacted)\n                self.debug_layer(self._exposure_summary)\n\n                # If the layer has the size field, it means we need to\n                # recompute counts based on the old and new size.\n                fields = self._exposure_summary.keywords['inasafe_fields']\n                if size_field['key'] in fields:\n                    self.set_state_process(\n                        'impact function',\n                        'Recompute counts')\n                    LOGGER.info(\n                        'InaSAFE will not use these counts, as we have ratios '\n                        'since the exposure preparation step.')\n                    self._exposure_summary = recompute_counts(\n                        self._exposure_summary)\n                    self.debug_layer(self._exposure_summary)\n\n            else:\n                self.set_state_process(\n                    'impact function',\n                    'Highest class of hazard is assigned to the exposure')\n                self._exposure_summary = assign_highest_value(\n                    self._exposure, self._aggregate_hazard_impacted)\n                self.debug_layer(self._exposure_summary)\n\n            # set title using definition\n            # the title will be overwritten anyway by standard title\n            # set this as fallback.\n            self._exposure_summary.keywords['title'] = (\n                layer_purpose_exposure_summary['name'])\n            if qgis_version() >= 21800:\n                self._exposure_summary.setName(\n                    self._exposure_summary.keywords['title'])\n            else:\n                self._exposure_summary.setLayerName(\n                    self._exposure_summary.keywords['title'])", "response": "This function intersects the exposure with the aggregate hazard."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef post_process(self, layer):\n        LOGGER.info('ANALYSIS : Post processing')\n\n        # Set the layer title\n        purpose = layer.keywords['layer_purpose']\n        if purpose != layer_purpose_aggregation_summary['key']:\n            # On an aggregation layer, the default title does make any sense.\n            layer_title(layer)\n\n        for post_processor in post_processors:\n            run, run_message = should_run(layer.keywords, post_processor)\n            if run:\n                valid, message = enough_input(layer, post_processor['input'])\n                name = post_processor['name']\n                if valid:\n                    valid, message = run_single_post_processor(\n                        layer, post_processor)\n                    if valid:\n                        self.set_state_process('post_processor', name)\n                        message = '{name} : Running'.format(name=name)\n                        LOGGER.info(message)\n\n                else:\n                    # message = u'{name} : Could not run : {reason}'.format(\n                    #     name=name, reason=message)\n                    # LOGGER.info(message)\n                    pass\n            else:\n                # LOGGER.info(run_message)\n                pass\n\n        self.debug_layer(layer, add_to_datastore=False)", "response": "Post processing of the impact layer with data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef summary_calculation(self):\n        LOGGER.info('ANALYSIS : Summary calculation')\n        if is_vector_layer(self._exposure_summary):\n            # With continuous exposure, we don't have an exposure summary layer\n            self.set_state_process(\n                'impact function',\n                'Aggregate the impact summary')\n            self._aggregate_hazard_impacted = aggregate_hazard_summary(\n                self.exposure_summary, self._aggregate_hazard_impacted)\n            self.debug_layer(self._exposure_summary, add_to_datastore=False)\n\n        self.set_state_process(\n            'impact function', 'Aggregate the aggregation summary')\n        self._aggregation_summary = aggregation_summary(\n            self._aggregate_hazard_impacted, self.aggregation)\n        self.debug_layer(\n            self._aggregation_summary, add_to_datastore=False)\n\n        self.set_state_process(\n            'impact function', 'Aggregate the analysis summary')\n        self._analysis_impacted = analysis_summary(\n            self._aggregate_hazard_impacted, self._analysis_impacted)\n        self.debug_layer(self._analysis_impacted)\n\n        if self._exposure.keywords.get('classification'):\n            self.set_state_process(\n                'impact function', 'Build the exposure summary table')\n            self._exposure_summary_table = exposure_summary_table(\n                self._aggregate_hazard_impacted, self._exposure_summary)\n            self.debug_layer(\n                self._exposure_summary_table, add_to_datastore=False)", "response": "This method is called by the summary calculation method. It will aggregate the aggregation and analysis summary and build the exposure summary table."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfunction to apply some styles to the layers.", "response": "def style(self):\n        \"\"\"Function to apply some styles to the layers.\"\"\"\n        LOGGER.info('ANALYSIS : Styling')\n        classes = generate_classified_legend(\n            self.analysis_impacted,\n            self.exposure,\n            self.hazard,\n            self.use_rounding,\n            self.debug_mode)\n\n        # Let's style layers which have a geometry and have hazard_class\n        hazard_class = hazard_class_field['key']\n        for layer in self._outputs():\n            without_geometries = [\n                QgsWkbTypes.NullGeometry,\n                QgsWkbTypes.UnknownGeometry]\n            if layer.geometryType() not in without_geometries:\n                display_not_exposed = False\n                if layer == self.impact or self.debug_mode:\n                    display_not_exposed = True\n\n                if layer.keywords['inasafe_fields'].get(hazard_class):\n                    hazard_class_style(layer, classes, display_not_exposed)\n\n        # Let's style the aggregation and analysis layer.\n        simple_polygon_without_brush(\n            self.aggregation_summary, aggregation_width, aggregation_color)\n        simple_polygon_without_brush(\n            self.analysis_impacted, analysis_width, analysis_color)\n\n        # Styling is finished, save them as QML\n        for layer in self._outputs():\n            layer.saveDefaultStyle()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfunctions to generate provenance at the end of the IF.", "response": "def _generate_provenance(self):\n        \"\"\"Function to generate provenance at the end of the IF.\"\"\"\n        # noinspection PyTypeChecker\n        exposure = definition(\n            self._provenance['exposure_keywords']['exposure'])\n\n        # noinspection PyTypeChecker\n        hazard = definition(\n            self._provenance['hazard_keywords']['hazard'])\n        # noinspection PyTypeChecker\n        hazard_category = definition(self._provenance['hazard_keywords'][\n            'hazard_category'])\n\n        # InaSAFE\n        set_provenance(\n            self._provenance, provenance_impact_function_name, self.name)\n        set_provenance(\n            self._provenance, provenance_impact_function_title, self.title)\n\n        # Map title\n        set_provenance(\n            self._provenance,\n            provenance_map_title,\n            get_map_title(hazard, exposure, hazard_category))\n\n        set_provenance(\n            self._provenance,\n            provenance_map_legend_title,\n            exposure['layer_legend_title'])\n\n        set_provenance(\n            self._provenance,\n            provenance_analysis_question,\n            get_analysis_question(hazard, exposure))\n\n        if self.requested_extent:\n            set_provenance(\n                self._provenance,\n                provenance_requested_extent,\n                self.requested_extent.asWktPolygon())\n        else:\n            set_provenance(\n                self._provenance,\n                provenance_requested_extent,\n                None)\n        set_provenance(\n            self._provenance,\n            provenance_analysis_extent,\n            self.analysis_extent.asWkt())\n\n        set_provenance(\n            self._provenance,\n            provenance_data_store_uri,\n            self.datastore.uri_path)\n\n        # Notes and Action\n        set_provenance(self._provenance, provenance_notes, self.notes())\n        set_provenance(\n            self._provenance,\n            provenance_action_checklist,\n            self.action_checklist())\n\n        # CRS\n        set_provenance(\n            self._provenance, provenance_crs, self._crs.authid())\n\n        # Rounding\n        set_provenance(\n            self._provenance, provenance_use_rounding, self.use_rounding)\n\n        # Debug mode\n        set_provenance(\n            self._provenance, provenance_debug_mode, self.debug_mode)\n\n        self._provenance_ready = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the exposure specific notes defined in definitions and return the list of the exposure definition specific notes dictionary.", "response": "def exposure_notes(self):\n        \"\"\"Get the exposure specific notes defined in definitions.\n\n        This method will do a lookup in definitions and return the\n        exposure definition specific notes dictionary.\n\n        This is a helper function to make it\n        easy to get exposure specific notes from the definitions metadata.\n\n        .. versionadded:: 3.5\n\n        :returns: A list like e.g. safe.definitions.exposure_land_cover[\n            'notes']\n        :rtype: list, None\n        \"\"\"\n        notes = []\n        exposure = definition(self.exposure.keywords.get('exposure'))\n        if 'notes' in exposure:\n            notes += exposure['notes']\n        if self.exposure.keywords['layer_mode'] == 'classified':\n            if 'classified_notes' in exposure:\n                notes += exposure['classified_notes']\n        if self.exposure.keywords['layer_mode'] == 'continuous':\n            if 'continuous_notes' in exposure:\n                notes += exposure['continuous_notes']\n        return notes"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hazard_notes(self):\n        notes = []\n        hazard = definition(self.hazard.keywords.get('hazard'))\n\n        if 'notes' in hazard:\n            notes += hazard['notes']\n        if self.hazard.keywords['layer_mode'] == 'classified':\n            if 'classified_notes' in hazard:\n                notes += hazard['classified_notes']\n        if self.hazard.keywords['layer_mode'] == 'continuous':\n            if 'continuous_notes' in hazard:\n                notes += hazard['continuous_notes']\n        if self.hazard.keywords['hazard_category'] == 'single_event':\n            if 'single_event_notes' in hazard:\n                notes += hazard['single_event_notes']\n        if self.hazard.keywords['hazard_category'] == 'multiple_event':\n            if 'multi_event_notes' in hazard:\n                notes += hazard['multi_event_notes']\n        return notes", "response": "Get the hazard definition specific notes dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef notes(self):\n        fields = []  # Notes still to be defined for ASH\n        # include any generic exposure specific notes from definitions\n        fields = fields + self.exposure_notes()\n        # include any generic hazard specific notes from definitions\n        fields = fields + self.hazard_notes()\n\n        # include any hazard/exposure notes from definitions\n        exposure = definition(self.exposure.keywords.get('exposure'))\n        hazard = definition(self.hazard.keywords.get('hazard'))\n        fields.extend(specific_notes(hazard, exposure))\n\n        if self._earthquake_function is not None:\n            # Get notes specific to the fatality model\n            for fatality_model in EARTHQUAKE_FUNCTIONS:\n                if fatality_model['key'] == self._earthquake_function:\n                    fields.extend(fatality_model.get('notes', []))\n\n        return fields", "response": "Return the notes section of the impact report."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the list of action check list dictionary.", "response": "def action_checklist(self):\n        \"\"\"Return the list of action check list dictionary.\n\n        :return: The list of action check list dictionary.\n        :rtype: list\n        \"\"\"\n        actions = []\n        exposure = definition(self.exposure.keywords.get('exposure'))\n        actions.extend(exposure.get('actions'))\n\n        hazard = definition(self.hazard.keywords.get('hazard'))\n        actions.extend(hazard.get('actions'))\n\n        actions.extend(specific_actions(hazard, exposure))\n        return actions"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads Impact Function based on an output layer s metadata.", "response": "def load_from_output_metadata(output_metadata):\n        \"\"\"Set Impact Function based on an output of an analysis's metadata.\n\n        If possible, we will try to use layers already in the legend and to not\n        recreating new ones. We will keep the style for instance.\n\n        :param output_metadata: Metadata from an output layer.\n        :type output_metadata: OutputLayerMetadata\n\n        :returns: Impact Function based on the metadata.\n        :rtype: ImpactFunction\n        \"\"\"\n        impact_function = ImpactFunction()\n        provenance = output_metadata['provenance_data']\n\n        # Set exposure layer\n        exposure_path = get_provenance(provenance, provenance_exposure_layer)\n        if exposure_path:\n            impact_function.exposure = load_layer_from_registry(exposure_path)\n            set_provenance(\n                provenance,\n                provenance_exposure_layer_id,\n                impact_function.exposure.id())\n\n        # Set hazard layer\n        hazard_path = get_provenance(provenance, provenance_hazard_layer)\n        if hazard_path:\n            impact_function.hazard = load_layer_from_registry(hazard_path)\n            set_provenance(\n                provenance,\n                provenance_hazard_layer_id,\n                impact_function.hazard.id())\n\n        # Set aggregation layer\n        aggregation_path = get_provenance(\n            provenance, provenance_aggregation_layer)\n        if aggregation_path:\n            impact_function.aggregation = (\n                load_layer_from_registry(aggregation_path))\n            set_provenance(\n                provenance,\n                provenance_aggregation_layer_id,\n                impact_function.aggregation.id())\n\n        # Requested extent\n        requested_extent = get_provenance(\n            provenance, provenance_requested_extent)\n        if requested_extent:\n            impact_function.requested_extent = wkt_to_rectangle(\n                requested_extent)\n\n        # Analysis extent\n        analysis_extent = get_provenance(\n            provenance, provenance_analysis_extent)\n        if analysis_extent:\n            impact_function._analysis_extent = QgsGeometry.fromWkt(\n                analysis_extent)\n\n        # Data store\n        data_store_uri = get_provenance(provenance, provenance_data_store_uri)\n        if data_store_uri:\n            impact_function.datastore = Folder(data_store_uri)\n\n        # Name\n        name = get_provenance(provenance, provenance_impact_function_name)\n        impact_function._name = name\n\n        # Title\n        title = get_provenance(provenance, provenance_impact_function_title)\n        impact_function._title = title\n\n        # Start date time\n        start_datetime = get_provenance(\n            provenance, provenance_start_datetime)\n        impact_function._start_datetime = start_datetime\n\n        # End date time\n        end_datetime = get_provenance(\n            provenance, provenance_end_datetime)\n        impact_function._end_datetime = end_datetime\n\n        # Duration\n        duration = get_provenance(provenance, provenance_duration)\n        impact_function._duration = duration\n\n        # Earthquake function\n        earthquake_function = get_provenance(\n            provenance, provenance_earthquake_function)\n        impact_function._earthquake_function = earthquake_function\n\n        # Use rounding\n        impact_function.use_rounding = get_provenance(\n            provenance, provenance_use_rounding)\n\n        # Debug mode\n        debug_mode = get_provenance(provenance, provenance_debug_mode)\n        impact_function.debug_mode = debug_mode\n\n        # Output layers\n        # exposure_summary\n        exposure_summary_path = get_provenance(\n            provenance, provenance_layer_exposure_summary)\n        if exposure_summary_path:\n            impact_function._exposure_summary = load_layer_from_registry(\n                exposure_summary_path)\n            set_provenance(\n                provenance,\n                provenance_layer_exposure_summary_id,\n                impact_function._exposure_summary.id())\n\n        # aggregate_hazard_impacted\n        aggregate_hazard_impacted_path = get_provenance(\n            provenance, provenance_layer_aggregate_hazard_impacted)\n        if aggregate_hazard_impacted_path:\n            impact_function._aggregate_hazard_impacted = (\n                load_layer_from_registry(aggregate_hazard_impacted_path))\n            set_provenance(\n                provenance,\n                provenance_layer_aggregate_hazard_impacted_id,\n                impact_function._aggregate_hazard_impacted.id())\n\n        # aggregation_summary\n        aggregation_summary_path = get_provenance(\n            provenance, provenance_layer_aggregation_summary)\n        if aggregation_summary_path:\n            impact_function._aggregation_summary = load_layer_from_registry(\n                aggregation_summary_path)\n            set_provenance(\n                provenance,\n                provenance_layer_aggregation_summary_id,\n                impact_function._aggregation_summary.id())\n\n        # analysis_impacted\n        analysis_impacted_path = get_provenance(\n            provenance, provenance_layer_analysis_impacted)\n        if analysis_impacted_path:\n            impact_function._analysis_impacted = load_layer_from_registry(\n                analysis_impacted_path)\n            set_provenance(\n                provenance,\n                provenance_layer_analysis_impacted_id,\n                impact_function._analysis_impacted.id())\n\n        # exposure_summary_table\n        exposure_summary_table_path = get_provenance(\n            provenance, provenance_layer_exposure_summary_table)\n        if exposure_summary_table_path:\n            impact_function._exposure_summary_table = load_layer_from_registry(\n                exposure_summary_table_path)\n            set_provenance(\n                provenance,\n                provenance_layer_exposure_summary_table_id,\n                impact_function._exposure_summary_table.id())\n\n        # profiling\n        # Skip if it's debug mode\n        if not impact_function.debug_mode:\n            profiling_path = get_provenance(\n                provenance, provenance_layer_profiling)\n            if profiling_path:\n                impact_function._profiling_table = load_layer_from_registry(\n                    profiling_path)\n\n        impact_function._output_layer_expected = \\\n            impact_function._compute_output_layer_expected()\n\n        # crs\n        crs = get_provenance(provenance, provenance_crs)\n        if crs and not aggregation_path:\n            impact_function._crs = QgsCoordinateReferenceSystem(crs)\n        if aggregation_path:\n            impact_function._crs = impact_function.aggregation.crs()\n\n        # Set provenance data\n        impact_function._provenance = provenance\n        impact_function._provenance_ready = True\n\n        return impact_function"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_report(\n            self,\n            components,\n            output_folder=None,\n            iface=None,\n            ordered_layers_uri=None,\n            legend_layers_uri=None,\n            use_template_extent=False):\n        \"\"\"Generate Impact Report independently by the Impact Function.\n\n        :param components: Report components to be generated.\n        :type components: list\n\n        :param output_folder: The output folder.\n        :type output_folder: str\n\n        :param iface: A QGIS App interface\n        :type iface: QgsInterface\n\n        :param ordered_layers_uri: A list of layers uri for map.\n        :type ordered_layers_uri: list\n\n        :param legend_layers_uri: A list of layers uri for map legend.\n        :type legend_layers_uri: list\n\n        :param use_template_extent: A condition for using template extent.\n        :type use_template_extent: bool\n\n        :returns: Tuple of error code and message\n        :type: tuple\n\n        .. versionadded:: 4.3\n        \"\"\"\n        # iface set up, in case IF run from test\n        if not iface:\n            iface = iface_object\n\n        # don't generate infographic if exposure is not population\n        exposure_type = definition(\n            self.provenance['exposure_keywords']['exposure'])\n        map_overview_layer = None\n\n        generated_components = deepcopy(components)\n        # remove unnecessary components\n        if standard_multi_exposure_impact_report_metadata_pdf in (\n                generated_components):\n            generated_components.remove(\n                standard_multi_exposure_impact_report_metadata_pdf)\n        if exposure_type != exposure_population and (\n                infographic_report in generated_components):\n            generated_components.remove(infographic_report)\n        else:\n            map_overview_layer = QgsRasterLayer(\n                map_overview['path'], 'Overview')\n            add_layer_to_canvas(\n                map_overview_layer, map_overview['id'])\n\n        \"\"\"Map report layers preparation\"\"\"\n\n        # preparing extra layers\n        extra_layers = []\n        print_atlas = setting('print_atlas_report', False, bool)\n\n        aggregation_summary_layer = self.aggregation_summary\n\n        # Define the layers for layer order and legend\n        ordered_layers = None\n        legend_layers = None\n        if ordered_layers_uri:\n            ordered_layers = [\n                load_layer_from_registry(layer_path) for (\n                    layer_path) in ordered_layers_uri]\n        if legend_layers_uri:\n            legend_layers = [\n                load_layer_from_registry(layer_path) for (\n                    layer_path) in legend_layers_uri]\n\n        if print_atlas:\n            extra_layers.append(aggregation_summary_layer)\n\n        error_code = None\n        message = None\n\n        for component in generated_components:\n            # create impact report instance\n\n            if component['key'] == map_report['key']:\n                report_metadata = ReportMetadata(\n                    metadata_dict=component)\n            else:\n                report_metadata = ReportMetadata(\n                    metadata_dict=update_template_component(component))\n\n            self._report_metadata.append(report_metadata)\n            self._impact_report = ImpactReport(\n                iface,\n                report_metadata,\n                impact_function=self,\n                extra_layers=extra_layers,\n                ordered_layers=ordered_layers,\n                legend_layers=legend_layers,\n                use_template_extent=use_template_extent)\n\n            # Get other setting\n            logo_path = setting('organisation_logo_path', None, str)\n            self._impact_report.inasafe_context.organisation_logo = logo_path\n\n            disclaimer_text = setting('reportDisclaimer', None, str)\n            self._impact_report.inasafe_context.disclaimer = disclaimer_text\n\n            north_arrow_path = setting('north_arrow_path', None, str)\n            self._impact_report.inasafe_context.north_arrow = north_arrow_path\n\n            # get the extent of impact layer\n            self._impact_report.qgis_composition_context.extent = (\n                self.impact.extent())\n\n            # generate report folder\n\n            # no other option for now\n            # TODO: retrieve the information from data store\n            if isinstance(self.datastore.uri, QDir):\n                layer_dir = self.datastore.uri.absolutePath()\n            else:\n                # No other way for now\n                return\n\n            # We will generate it on the fly without storing it after datastore\n            # supports\n            if output_folder:\n                self._impact_report.output_folder = output_folder\n            else:\n                self._impact_report.output_folder = join(layer_dir, 'output')\n\n            error_code, message = self._impact_report.process_components()\n            if error_code == ImpactReport.REPORT_GENERATION_FAILED:\n                break\n\n        if map_overview_layer:\n            QgsProject.instance().removeMapLayer(map_overview_layer)\n\n        # Create json file for report urls\n        report_path = self._impact_report.output_folder\n        filename = join(report_path, 'report_metadata.json')\n        write_json(report_urls(self), filename)\n\n        return error_code, message", "response": "Generate Impact Report independently by the Impact Function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndisplaying an error when there is not enough memory.", "response": "def memory_error():\n    \"\"\"Display an error when there is not enough memory.\"\"\"\n    warning_heading = m.Heading(\n        tr('Memory issue'), **WARNING_STYLE)\n    warning_message = tr(\n        'There is not enough free memory to run this analysis.')\n    suggestion_heading = m.Heading(\n        tr('Suggestion'), **SUGGESTION_STYLE)\n    suggestion = tr(\n        'Try zooming in to a smaller area or using a raster layer with a '\n        'coarser resolution to speed up execution and reduce memory '\n        'requirements. You could also try adding more RAM to your computer.')\n\n    message = m.Message()\n    message.add(warning_heading)\n    message.add(warning_message)\n    message.add(suggestion_heading)\n    message.add(suggestion)\n    send_static_message(dispatcher.Anonymous, message)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_top_level_index_entry(title, max_depth, subtitles):\n\n    return_text = title + '\\n'\n    dash = '-' * len(title) + '\\n'\n\n    return_text += dash + '\\n'\n    return_text += '.. toctree::' + '\\n'\n    return_text += '   :maxdepth: ' + str(max_depth) + '\\n\\n'\n\n    for subtitle in subtitles:\n        return_text += '   ' + subtitle + '\\n\\n'\n    return return_text", "response": "Function for creating a text entry in index. rst for its content."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_package_level_rst_index_file(\n        package_name, max_depth, modules, inner_packages=None):\n    \"\"\"Function for creating text for index for a package.\n\n    :param package_name: name of the package\n    :type package_name: str\n\n    :param max_depth: Value for max_depth in the index file.\n    :type max_depth: int\n\n    :param modules: list of module in the package.\n    :type modules: list\n\n    :return: A text for the content of the index file.\n    :rtype: str\n    \"\"\"\n    if inner_packages is None:\n        inner_packages = []\n    return_text = 'Package::' + package_name\n    dash = '=' * len(return_text)\n    return_text += '\\n' + dash + '\\n\\n'\n    return_text += '.. toctree::' + '\\n'\n    return_text += '   :maxdepth: ' + str(max_depth) + '\\n\\n'\n    upper_package = package_name.split('.')[-1]\n    for module in modules:\n        if module in EXCLUDED_PACKAGES:\n            continue\n        return_text += '   ' + upper_package + os.sep + module[:-3] + '\\n'\n    for inner_package in inner_packages:\n        if inner_package in EXCLUDED_PACKAGES:\n            continue\n        return_text += '   ' + upper_package + os.sep + inner_package + '\\n'\n\n    return return_text", "response": "Function for creating text for index for a package."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfunction for creating content in each. rst file for a module.", "response": "def create_module_rst_file(module_name):\n    \"\"\"Function for creating content in each .rst file for a module.\n\n    :param module_name: name of the module.\n    :type module_name: str\n\n    :returns: A content for auto module.\n    :rtype: str\n    \"\"\"\n\n    return_text = 'Module:  ' + module_name\n    dash = '=' * len(return_text)\n    return_text += '\\n' + dash + '\\n\\n'\n    return_text += '.. automodule:: ' + module_name + '\\n'\n    return_text += '   :members:\\n\\n'\n\n    return return_text"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write_rst_file(file_directory, file_name, content):\n    create_dirs(os.path.split(os.path.join(file_directory, file_name))[0])\n    try:\n        fl = open(os.path.join(file_directory, file_name + '.rst'), 'w+')\n        fl.write(content)\n        fl.close()\n\n    except Exception as e:\n        print(('Creating %s failed' % os.path.join(\n            file_directory, file_name + '.rst'), e))", "response": "Write the content of the neccessary element to the rst file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns list of python files from files without excluded files.", "response": "def get_python_files_from_list(files, excluded_files=None):\n    \"\"\"Return list of python file from files, without excluded files.\n\n    :param files: List of files.\n    :type files: list\n\n    :param excluded_files: List of excluded file names.\n    :type excluded_files: list, None\n\n    :returns: List of python file without the excluded file, not started with\n        test.\n    :rtype: list\n    \"\"\"\n    if excluded_files is None:\n        excluded_files = ['__init__.py']\n    python_files = []\n    for fl in files:\n        if (fl.endswith('.py')\n                and fl not in excluded_files\n                and not fl.startswith('test')):\n            python_files.append(fl)\n\n    return python_files"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates the top level index page for the given packages.", "response": "def create_top_level_index(api_docs_path, packages, max_depth=2):\n    \"\"\"Create the top level index page (writing to file)\n\n    :param api_docs_path: Path to the api-docs of inasafe documentation.\n    :type api_docs_path: str\n\n    :param packages: List of packages which want to be extracted their api/\n    :type packages: list\n\n    :param max_depth: The maximum depth of tree in the api docs.\n    :type max_depth: int\n    \"\"\"\n    page_text = INDEX_HEADER\n    for package in packages:\n        # Write top level index file entries for safe\n        text = create_top_level_index_entry(\n            title='Package %s' % package,\n            max_depth=max_depth,\n            subtitles=[package])\n\n        page_text += '%s\\n' % text\n    write_rst_file(api_docs_path, 'index', page_text)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_inasafe_code_path(custom_inasafe_path=None):\n\n    inasafe_code_path = os.path.abspath(\n        os.path.join(os.path.dirname(__file__), '..'))\n\n    if custom_inasafe_path is not None:\n        inasafe_code_path = custom_inasafe_path\n    return inasafe_code_path", "response": "Determine the path to inasafe source code."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clean_api_docs_dirs():\n    inasafe_docs_path = os.path.abspath(\n        os.path.join(\n            os.path.dirname(__file__), '..', 'docs', 'api-docs'))\n    if os.path.exists(inasafe_docs_path):\n        rmtree(inasafe_docs_path)\n    create_dirs(inasafe_docs_path)\n    return inasafe_docs_path", "response": "Empty previous api - docs directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfunctioning for generating the api documentation for all. py files in dir_path.", "response": "def create_api_docs(code_path, api_docs_path, max_depth=2):\n    \"\"\"Function for generating .rst file for all .py file in dir_path folder.\n\n    :param code_path: Path of the source code.\n    :type code_path: str\n\n    :param api_docs_path: Path of the api documentation directory.\n    :type api_docs_path: str\n\n    :param max_depth: Maximum depth for the index.\n    :type max_depth: int\n    \"\"\"\n    base_path = os.path.split(code_path)[0]\n    for package, subpackages, candidate_files in os.walk(code_path):\n        # Checking __init__.py file\n        if '__init__.py' not in candidate_files:\n            continue\n        # Creating directory for the package\n        package_relative_path = package.replace(base_path + os.sep, '')\n        index_package_path = os.path.join(\n            api_docs_path, package_relative_path)\n        # calculate dir one up from package to store the index in\n        index_base_path, package_base_name = os.path.split(index_package_path)\n\n        if package_base_name in EXCLUDED_PACKAGES:\n            continue\n\n        full_package_name = package_relative_path.replace(os.sep, '.')\n        new_rst_dir = os.path.join(api_docs_path, package_relative_path)\n        create_dirs(new_rst_dir)\n\n        # Create index_file for the directory\n        modules = get_python_files_from_list(candidate_files)\n        index_file_text = create_package_level_rst_index_file(\n            package_name=full_package_name,\n            max_depth=max_depth,\n            modules=modules,\n            inner_packages=subpackages)\n\n        write_rst_file(\n            file_directory=index_base_path,\n            file_name=package_base_name,\n            content=index_file_text)\n\n        # Creating .rst file for each .py file\n        for module in modules:\n            module = module[:-3]  # strip .py off the end\n            py_module_text = create_module_rst_file(\n                '%s.%s' % (full_package_name, module))\n            write_rst_file(\n                file_directory=new_rst_dir,\n                file_name=module,\n                content=py_module_text)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_widgets(self):\n        self.clear()\n        existing_inasafe_field = self.parent.get_existing_keyword(\n            'inasafe_fields')\n        existing_inasafe_default_values = self.parent.get_existing_keyword(\n            'inasafe_default_values')\n        # Remove old container and parameter\n        if self.parameter_container:\n            self.kwExtraKeywordsGridLayout.removeWidget(\n                self.parameter_container)\n        if self.parameters:\n            self.parameters = []\n\n        # Iterate through all inasafe fields\n        # existing_inasafe_default_values\n\n        for inasafe_field in self.inasafe_fields_for_the_layer():\n            # Option for Not Available\n            option_list = [no_field]\n            for field in self.parent.layer.fields():\n                # Check the field type\n                if isinstance(inasafe_field['type'], list):\n                    if field.type() in inasafe_field['type']:\n                        field_name = field.name()\n                        option_list.append('%s' % field_name)\n                else:\n                    if field.type() == inasafe_field['type']:\n                        field_name = field.name()\n                        option_list.append('%s' % field_name)\n\n            # Create DefaultSelectParameter\n            parameter = DefaultSelectParameter()\n            parameter.guid = inasafe_field['key']\n            parameter.name = inasafe_field['name']\n            parameter.is_required = False\n            parameter.description = inasafe_field['description']\n            parameter.help_text = inasafe_field['help_text']\n            parameter.element_type = str\n            parameter.options_list = option_list\n            parameter.value = no_field\n            parameter.default_labels = get_inasafe_default_value_fields(\n                self.parent.setting, inasafe_field['key'])[0]\n            parameter.default_values = get_inasafe_default_value_fields(\n                self.parent.setting, inasafe_field['key'])[1]\n            parameter.minimum = inasafe_field['default_value'].get(\n                'min_value')\n            parameter.maximum = inasafe_field['default_value'].get(\n                'max_value')\n            # Check if there is already value in the metadata.\n            if existing_inasafe_field:\n                existing_value = existing_inasafe_field.get(\n                    inasafe_field['key'])\n                if existing_value:\n                    if existing_value in parameter.options_list:\n                        parameter.value = existing_value\n\n            if existing_inasafe_default_values:\n                existing_default_value = existing_inasafe_default_values.get(\n                    inasafe_field['key'])\n                if existing_default_value:\n                    parameter.default = existing_default_value\n\n            self.parameters.append(parameter)\n\n        # Create the parameter container and add to the wizard.\n        self.parameter_container = ParameterContainer(\n            self.parameters, extra_parameters=self.extra_parameters)\n        self.parameter_container.setup_ui()\n        self.kwExtraKeywordsGridLayout.addWidget(self.parameter_container)\n        # Add Message label\n        self.kwExtraKeywordsGridLayout.addWidget(self.message_label)\n\n        # Set default value to None\n        for parameter_widget in self.parameter_container.\\\n                get_parameter_widgets():\n            parameter_widget.widget().set_default(None)\n            # Set selected radio button to 'Do not report'\n            parameter_widget.widget().set_selected_radio_button()\n        # Set default value from existing keywords\n        if existing_inasafe_default_values:\n            for guid, default in list(existing_inasafe_default_values.items()):\n                parameter_widget = self.parameter_container.\\\n                    get_parameter_widget_by_guid(guid)\n                if isinstance(parameter_widget, DefaultSelectParameterWidget):\n                    parameter_widget.set_default(default)\n                    # Set selected radio button to 'Do not report'\n                    parameter_widget.set_selected_radio_button()", "response": "Set widgets on the Extra Keywords tab."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn inasafe fields from the current wizard state.", "response": "def get_inasafe_fields(self):\n        \"\"\"Return inasafe fields from the current wizard state.\n\n        :returns: Dictionary of key and value from InaSAFE Fields.\n        :rtype: dict\n        \"\"\"\n        inasafe_fields = {}\n        parameters = self.parameter_container.get_parameters(True)\n        for parameter in parameters:\n            if not parameter.value == no_field:\n                inasafe_fields[parameter.guid] = parameter.value\n\n        return inasafe_fields"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_inasafe_default_values(self):\n        inasafe_default_values = {}\n        parameters = self.parameter_container.get_parameters(True)\n        for parameter in parameters:\n            if parameter.default is not None:\n                inasafe_default_values[parameter.guid] = parameter.default\n\n        return inasafe_default_values", "response": "Return inasafe default values from the current wizard state."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef function_options_help():\n\n    message = m.Message()\n    message.add(m.Brand())\n    message.add(heading())\n    message.add(content())\n    return message", "response": "Help message for Function options dialog."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn just the content of the current Impact Function.", "response": "def content():\n    \"\"\"Helper method that returns just the content.\n\n    This method was added so that the text could be reused in the\n    dock_help module.\n\n    .. versionadded:: 3.2.2\n\n    :returns: A message object without brand element.\n    :rtype: safe.messaging.message.Message\n    \"\"\"\n    message = m.Message()\n    paragraph = m.Paragraph(\n        m.Image(\n            'file:///%s/img/screenshots/'\n            'batch-calculator-screenshot.png' % resources_path()),\n        style_class='text-center'\n    )\n    message.add(paragraph)\n    message.add(m.Paragraph(tr(\n        'Depending on which Impact Function you have chosen you have '\n        'different options available for adjusting the parameters of the '\n        'question you are asking. Some Impact Functions have more '\n        'configurable Options than others. To open the Impact Function '\n        'Configuration Dialog you need to click on the \"Options ...\" '\n        'button next to the selected impact function paragraph in the '\n        'InaSAFE dock. You can have up to 3 tabs visible:'\n    )))\n\n    bullets = m.BulletedList()\n    bullets.add(m.Text(\n        m.ImportantText(tr('Options')),\n        tr(\n            '- Depending in the Impact function you selected, you can '\n            'influence the result of your question here (the Impact Function) '\n            'by setting different values to the defaults that will be loaded. '\n            'The options available will depend on the Impact Function you '\n            'choose (some Impact Functions do not allow users to change the '\n            'default parameters).')))\n    bullets.add(m.Text(\n        m.ImportantText(tr('Post-processors')),\n        tr(\n            '- Takes the results from the Impact Function and calculates '\n            'derivative indicators, for example if you have an affected '\n            'population total, the Gender postprocessor will calculate gender '\n            'specific indicators such as additional nutritional requirements '\n            'for pregnant women.')))\n    bullets.add(m.Text(\n        m.ImportantText(tr('Minimum Needs')),\n        tr(\n            '- If the analysis uses population exposure, InaSAFE calculates '\n            'the minimum needs of the people affected by the impact scenario. '\n            'You should refer to the minimum needs tool for configuring the '\n            'global defaults used in these calculations. '),\n        m.Image(\n            'file:///%s/img/icons/'\n            'show-minimum-needs.svg' % resources_path(),\n            **SMALL_ICON_STYLE),\n        tr(\n            ' This panel will let you override global defaults for a specific '\n            'analysis run.')))\n    message.add(bullets)\n    return message"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nformats a number according to the standards.", "response": "def format_number(\n        x, use_rounding=True, is_population=False, coefficient=1):\n    \"\"\"Format a number according to the standards.\n\n    :param x: A number to be formatted in a locale friendly way.\n    :type x: int\n\n    :param use_rounding: Flag to enable a rounding.\n    :type use_rounding: bool\n\n    :param is_population: Flag if the number is population. It needs to be\n        used with enable_rounding.\n    :type is_population: bool\n\n    :param coefficient: Divide the result after the rounding.\n    :type coefficient:float\n\n    :returns: A locale friendly formatted string e.g. 1,000,0000.00\n        representing the original x. If a ValueError exception occurs,\n        x is simply returned.\n    :rtype: basestring\n    \"\"\"\n    if use_rounding:\n        x = rounding(x, is_population)\n\n    x //= coefficient\n\n    number = add_separators(x)\n    return number"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_separators(x):\n    try:\n        s = '{0:,}'.format(x)\n        # s = '{0:n}'.format(x)  # n means locale aware (read up on this)\n    # see issue #526\n    except ValueError:\n        return x\n\n    # Quick solution for the moment\n    if locale() in ['id', 'fr']:\n        # Replace commas with the correct thousand separator.\n        s = s.replace(',', thousand_separator())\n    return s", "response": "Format integer with separator between thousands."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntries to round the number.", "response": "def round_affected_number(\n        number,\n        use_rounding=False,\n        use_population_rounding=False):\n    \"\"\"Tries to convert and round the number.\n\n    Rounded using population rounding rule.\n\n    :param number: number represented as string or float\n    :type number: str, float\n\n    :param use_rounding: flag to enable rounding\n    :type use_rounding: bool\n\n    :param use_population_rounding: flag to enable population rounding scheme\n    :type use_population_rounding: bool\n\n    :return: rounded number\n    \"\"\"\n    decimal_number = float(number)\n    rounded_number = int(ceil(decimal_number))\n    if use_rounding and use_population_rounding:\n        # if uses population rounding\n        return rounding(rounded_number, use_population_rounding)\n    elif use_rounding:\n        return rounded_number\n\n    return decimal_number"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fatalities_range(number):\n    range_format = '{min_range} - {max_range}'\n    more_than_format = '> {min_range}'\n    ranges = [\n        [0, 100],\n        [100, 1000],\n        [1000, 10000],\n        [10000, 100000],\n        [100000, float('inf')]\n    ]\n    for r in ranges:\n        min_range = r[0]\n        max_range = r[1]\n\n        if max_range == float('inf'):\n            return more_than_format.format(\n                min_range=add_separators(min_range))\n        elif min_range <= number <= max_range:\n            return range_format.format(\n                min_range=add_separators(min_range),\n                max_range=add_separators(max_range))", "response": "A helper to return fatalities as a range of number."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef denomination(value, min_nominal=None):\n    if value is None or (hasattr(value, 'isNull') and value.isNull()):\n        return None, None\n\n    if not value:\n        return value, None\n\n    if abs(value) == list(nominal_mapping.keys())[0] and not min_nominal:\n        return 1 * value, nominal_mapping[list(nominal_mapping.keys())[0]]\n\n    # we need minimum value of denomination because we don't want to show\n    # '2 ones', '3 tens', etc.\n    index = 0\n    if min_nominal:\n        index = int(ceil(log(min_nominal, 10)))\n\n    iterator = list(zip(list(nominal_mapping.keys())[\n                    index:], list(nominal_mapping.keys())[index + 1:]))\n    for min_value, max_value in iterator:\n\n        if min_value <= abs(value) < max_value:\n            return float(value) / min_value, nominal_mapping[min_value]\n        elif abs(value) < min_value:\n            return float(value), None\n\n    max_value = list(nominal_mapping.keys())[-1]\n    new_value = float(value) / max_value\n    new_unit = nominal_mapping[list(nominal_mapping.keys())[-1]]\n    return new_value, new_unit", "response": "Return the denomination of a number."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_next_step(self):\n        if self.parent.is_selected_layer_keywordless:\n            # insert keyword creation thread here\n            self.parent.parent_step = self\n            self.parent.existing_keywords = None\n            self.parent.set_mode_label_to_keywords_creation()\n            new_step = self.parent.step_kw_purpose\n        else:\n            if layers_intersect(self.parent.exposure_layer,\n                                self.parent.aggregation_layer):\n                new_step = self.parent.step_fc_summary\n            else:\n                new_step = self.parent.step_fc_agglayer_disjoint\n        return new_step", "response": "Find the proper step when user clicks the Next button."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates layer description label.", "response": "def tvBrowserAggregation_selection_changed(self):\n        \"\"\"Update layer description label.\"\"\"\n        (is_compatible, desc) = self.get_layer_description_from_browser(\n            'aggregation')\n        self.lblDescribeBrowserAggLayer.setText(desc)\n        self.parent.pbnNext.setEnabled(is_compatible)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves legend title header string from definitions.", "response": "def legend_title_header_element(feature, parent):\n    \"\"\"Retrieve legend title header string from definitions.\"\"\"\n    _ = feature, parent  # NOQA\n    header = legend_title_header['string_format']\n    return header.capitalize()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef direction_to_nearest_place(feature, parent):\n    _ = feature, parent  # NOQA\n\n    layer = exposure_summary_layer()\n    if not layer:\n        return None\n\n    index = layer.fields().lookupField(\n        direction_field['field_name'])\n    if index < 0:\n        return None\n\n    feature = next(layer.getFeatures())\n    return feature[index]", "response": "This function returns the direction of the impact layer to the nearest place."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bearing_to_nearest_place(feature, parent):\n    _ = feature, parent  # NOQA\n\n    layer = exposure_summary_layer()\n    if not layer:\n        return None\n\n    index = layer.fields().lookupField(\n        bearing_field['field_name'])\n    if index < 0:\n        return None\n\n    feature = next(layer.getFeatures())\n    return feature[index]", "response": "This function returns the bearing to nearest place in degrees."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef name_of_the_nearest_place(feature, parent):\n    _ = feature, parent  # NOQA\n\n    layer = exposure_summary_layer()\n    if not layer:\n        return None\n\n    index = layer.fields().lookupField(\n        exposure_name_field['field_name'])\n    if index < 0:\n        return None\n\n    feature = next(layer.getFeatures())\n    return feature[index]", "response": "Returns the name of the nearest place in the impact layer."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve disclaimer title header string from definitions.", "response": "def disclaimer_title_header_element(feature, parent):\n    \"\"\"Retrieve disclaimer title header string from definitions.\"\"\"\n    _ = feature, parent  # NOQA\n    header = disclaimer_title_header['string_format']\n    return header.capitalize()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving information title header string from definitions.", "response": "def information_title_header_element(feature, parent):\n    \"\"\"Retrieve information title header string from definitions.\"\"\"\n    _ = feature, parent  # NOQA\n    header = information_title_header['string_format']\n    return header.capitalize()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves time title header string from definitions.", "response": "def time_title_header_element(feature, parent):\n    \"\"\"Retrieve time title header string from definitions.\"\"\"\n    _ = feature, parent  # NOQA\n    header = time_title_header['string_format']\n    return header.capitalize()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef caution_title_header_element(feature, parent):\n    _ = feature, parent  # NOQA\n    header = caution_title_header['string_format']\n    return header.capitalize()", "response": "Retrieve caution title header string from definitions."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef source_title_header_element(feature, parent):\n    _ = feature, parent  # NOQA\n    header = source_title_header['string_format']\n    return header.capitalize()", "response": "Retrieve source title header string from definitions."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves analysis title header string from definitions.", "response": "def analysis_title_header_element(feature, parent):\n    \"\"\"Retrieve analysis title header string from definitions.\"\"\"\n    _ = feature, parent  # NOQA\n    header = analysis_title_header['string_format']\n    return header.capitalize()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving version title header string from definitions.", "response": "def version_title_header_element(feature, parent):\n    \"\"\"Retrieve version title header string from definitions.\"\"\"\n    _ = feature, parent  # NOQA\n    header = version_title_header['string_format']\n    return header.capitalize()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reference_title_header_element(feature, parent):\n    _ = feature, parent  # NOQA\n    header = reference_title_header['string_format']\n    return header.capitalize()", "response": "Retrieve reference title header string from definitions."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef crs_text_element(crs, feature, parent):\n    _ = feature, parent  # NOQA\n    crs_definition = QgsCoordinateReferenceSystem(crs)\n    crs_description = crs_definition.description()\n    text = crs_text['string_format'].format(crs=crs_description)\n    return text", "response": "Retrieve coordinate reference system text string from definitions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving reference title header string from definitions.", "response": "def unknown_source_text_element(feature, parent):\n    \"\"\"Retrieve reference title header string from definitions.\"\"\"\n    _ = feature, parent  # NOQA\n    header = unknown_source_text['string_format']\n    return header.capitalize()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving reference title header string from definitions.", "response": "def aggregation_not_used_text_element(feature, parent):\n    \"\"\"Retrieve reference title header string from definitions.\"\"\"\n    _ = feature, parent  # NOQA\n    header = aggregation_not_used_text['string_format']\n    return header.capitalize()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef north_arrow_path(feature, parent):\n    _ = feature, parent  # NOQA\n\n    north_arrow_file = setting(inasafe_north_arrow_path['setting_key'])\n    if os.path.exists(north_arrow_file):\n        return north_arrow_file\n    else:\n        LOGGER.info(\n            'The custom north arrow is not found in {north_arrow_file}. '\n            'Default north arrow will be used.').format(\n            north_arrow_file=north_arrow_file)\n        return inasafe_default_settings['north_arrow_path']", "response": "Retrieve the full path of default north arrow logo."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef organisation_logo_path(feature, parent):\n    _ = feature, parent  # NOQA\n    organisation_logo_file = setting(\n        inasafe_organisation_logo_path['setting_key'])\n    if os.path.exists(organisation_logo_file):\n        return organisation_logo_file\n    else:\n        LOGGER.info(\n            'The custom organisation logo is not found in {logo_path}. '\n            'Default organisation logo will be used.').format(\n            logo_path=organisation_logo_file)\n        return inasafe_default_settings['organisation_logo_path']", "response": "Retrieve the full path of used specified organisation logo."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhelping message for multi buffer dialog.", "response": "def multi_buffer_help():\n    \"\"\"Help message for multi buffer dialog.\n\n    .. versionadded:: 4.0.0\n\n    :returns: A message object containing helpful information.\n    :rtype: messaging.message.Message\n    \"\"\"\n    message = m.Message()\n    message.add(m.Brand())\n    message.add(heading())\n    message.add(content())\n    return message"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calculate_distance(\n        distance_calculator,\n        place_geometry,\n        latitude,\n        longitude,\n        earthquake_hazard=None,\n        place_exposure=None):\n    \"\"\"Simple postprocessor where we compute the distance between two points.\n\n    :param distance_calculator: The size calculator.\n    :type distance_calculator: safe.gis.vector.tools.SizeCalculator\n\n    :param latitude: The latitude to use.\n    :type latitude: float\n\n    :param longitude: The longitude to use.\n    :type longitude: float\n\n    :param place_geometry: Geometry of place.\n    :type place_geometry: QgsGeometry\n\n    :param earthquake_hazard: The hazard to use.\n    :type earthquake_hazard: str\n\n    :param place_exposure: The exposure to use.\n    :type place_exposure: str\n\n    :return: distance\n    :rtype: float\n    \"\"\"\n    _ = earthquake_hazard, place_exposure  # NOQA\n\n    epicenter = QgsPointXY(longitude, latitude)\n    place_point = place_geometry.asPoint()\n    distance = distance_calculator.measure_distance(epicenter, place_point)\n    return distance", "response": "Simple postprocessor where we compute the distance between two points."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calculate_bearing(\n        place_geometry,\n        latitude,\n        longitude,\n        earthquake_hazard=None,\n        place_exposure=None\n):\n    \"\"\"Simple postprocessor where we compute the bearing angle between two\n    points.\n\n    :param place_geometry: Geometry of place.\n    :type place_geometry: QgsGeometry\n\n    :param latitude: The latitude to use.\n    :type latitude: float\n\n    :param longitude: The longitude to use.\n    :type longitude: float\n\n    :param earthquake_hazard: The hazard to use.\n    :type earthquake_hazard: str\n\n    :param place_exposure: The exposure to use.\n    :type place_exposure: str\n\n    :return: Bearing angle\n    :rtype: float\n    \"\"\"\n    _ = earthquake_hazard, place_exposure  # NOQA\n\n    epicenter = QgsPointXY(longitude, latitude)\n    place_point = place_geometry.asPoint()\n    bearing = place_point.azimuth(epicenter)\n    return bearing", "response": "Simple postprocessor where we compute the bearing angle between two locations."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef post_processor_population_displacement_function(\n        hazard=None, classification=None, hazard_class=None, population=None):\n    \"\"\"Private function used in the displacement postprocessor.\n\n    :param hazard: The hazard to use.\n    :type hazard: str\n\n    :param classification: The hazard classification to use.\n    :type classification: str\n\n    :param hazard_class: The hazard class of the feature.\n    :type hazard_class: str\n\n    :param population: We don't use this value here. It's only used for\n        condition for the postprocessor to run.\n    :type population: float, int\n\n    :return: The displacement ratio for a given hazard class.\n    :rtype: float\n    \"\"\"\n    _ = population  # NOQA\n\n    return get_displacement_rate(hazard, classification, hazard_class)", "response": "Private function used in the displacement postprocessor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef post_processor_population_fatality_function(\n        classification=None, hazard_class=None, population=None):\n    \"\"\"Private function used in the fatality postprocessor.\n\n    :param classification: The hazard classification to use.\n    :type classification: str\n\n    :param hazard_class: The hazard class of the feature.\n    :type hazard_class: str\n\n    :param population: We don't use this value here. It's only used for\n        condition for the postprocessor to run.\n    :type population: float, int\n\n    :return: The displacement ratio for a given hazard class.\n    :rtype: float\n    \"\"\"\n    _ = population  # NOQA\n    for hazard in hazard_classes_all:\n        if hazard['key'] == classification:\n            classification = hazard['classes']\n            break\n\n    for hazard_class_def in classification:\n        if hazard_class_def['key'] == hazard_class:\n            displaced_ratio = hazard_class_def.get('fatality_rate', 0.0)\n            if displaced_ratio is None:\n                displaced_ratio = 0.0\n            # We need to cast it to float to make it works.\n            return float(displaced_ratio)\n\n    return 0.0", "response": "Private function used in the fatality postprocessor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nappending ISO19115 from setting to keywords.", "response": "def append_ISO19115_keywords(keywords):\n    \"\"\"Append ISO19115 from setting to keywords.\n\n    :param keywords: The keywords destination.\n    :type keywords: dict\n    \"\"\"\n    # Map setting's key and metadata key\n    ISO19115_mapping = {\n        'ISO19115_ORGANIZATION': 'organisation',\n        'ISO19115_URL': 'url',\n        'ISO19115_EMAIL': 'email',\n        'ISO19115_LICENSE': 'license'\n    }\n    ISO19115_keywords = {}\n    # Getting value from setting.\n    for key, value in list(ISO19115_mapping.items()):\n        ISO19115_keywords[value] = setting(key, expected_type=str)\n    keywords.update(ISO19115_keywords)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates metadata object from a layer path and keywords dictionary.", "response": "def write_iso19115_metadata(layer_uri, keywords, version_35=False):\n    \"\"\"Create metadata  object from a layer path and keywords dictionary.\n\n    This function will save these keywords to the file system or the database.\n\n    :param version_35: If we write keywords version 3.5. Default to False.\n    :type version_35: bool\n\n    :param layer_uri: Uri to layer.\n    :type layer_uri: basestring\n\n    :param keywords: Dictionary of keywords.\n    :type keywords: dict\n    \"\"\"\n    active_metadata_classes = METADATA_CLASSES\n    if version_35:\n        active_metadata_classes = METADATA_CLASSES35\n\n    if 'layer_purpose' in keywords:\n        if keywords['layer_purpose'] in active_metadata_classes:\n            metadata = active_metadata_classes[\n                keywords['layer_purpose']](layer_uri)\n        else:\n            LOGGER.info(\n                'The layer purpose is not supported explicitly. It will use '\n                'generic metadata. The layer purpose is %s' %\n                keywords['layer_purpose'])\n            if version_35:\n                metadata = GenericLayerMetadata35(layer_uri)\n            else:\n                metadata = GenericLayerMetadata(layer_uri)\n    else:\n        if version_35:\n            metadata = GenericLayerMetadata35(layer_uri)\n        else:\n            metadata = GenericLayerMetadata(layer_uri)\n\n    metadata.update_from_dict(keywords)\n    # Always set keyword_version to the latest one.\n    if not version_35:\n        metadata.update_from_dict({'keyword_version': inasafe_keyword_version})\n\n    if metadata.layer_is_file_based:\n        xml_file_path = os.path.splitext(layer_uri)[0] + '.xml'\n        metadata.write_to_file(xml_file_path)\n    else:\n        metadata.write_to_db()\n\n    return metadata"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_iso19115_metadata(layer_uri, keyword=None, version_35=False):\n    xml_uri = os.path.splitext(layer_uri)[0] + '.xml'\n    # Remove the prefix for local file. For example csv.\n    file_prefix = 'file:'\n    if xml_uri.startswith(file_prefix):\n        xml_uri = xml_uri[len(file_prefix):]\n    if not os.path.exists(xml_uri):\n        xml_uri = None\n    if not xml_uri and os.path.exists(layer_uri):\n        message = 'Layer based file but no xml file.\\n'\n        message += 'Layer path: %s.' % layer_uri\n        raise NoKeywordsFoundError(message)\n    if version_35:\n        metadata = GenericLayerMetadata35(layer_uri, xml_uri)\n    else:\n        metadata = GenericLayerMetadata(layer_uri, xml_uri)\n\n    active_metadata_classes = METADATA_CLASSES\n    if version_35:\n        active_metadata_classes = METADATA_CLASSES35\n\n    if metadata.layer_purpose in active_metadata_classes:\n        metadata = active_metadata_classes[\n            metadata.layer_purpose](layer_uri, xml_uri)\n\n    # dictionary comprehension\n    keywords = {\n        x[0]: x[1]['value'] for x in list(metadata.dict['properties'].items())\n        if x[1]['value'] is not None}\n    if 'keyword_version' not in list(keywords.keys()) and xml_uri:\n        message = 'No keyword version found. Metadata xml file is invalid.\\n'\n        message += 'Layer uri: %s\\n' % layer_uri\n        message += 'Keywords file: %s\\n' % os.path.exists(\n            os.path.splitext(layer_uri)[0] + '.xml')\n        message += 'keywords:\\n'\n        for k, v in list(keywords.items()):\n            message += '%s: %s\\n' % (k, v)\n        raise MetadataReadError(message)\n\n    # Get dictionary keywords that has value != None\n    keywords = {\n        x[0]: x[1]['value'] for x in list(metadata.dict['properties'].items())\n        if x[1]['value'] is not None}\n\n    if keyword:\n        try:\n            return keywords[keyword]\n        except KeyError:\n            message = 'Keyword with key %s is not found. ' % keyword\n            message += 'Layer path: %s' % layer_uri\n            raise KeywordNotFoundError(message)\n\n    return keywords", "response": "Reads keywords from a metadata object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef active_thresholds_value_maps(keywords, exposure_key):\n    if 'classification' in keywords:\n        if keywords['layer_mode'] == layer_mode_continuous['key']:\n            return keywords['thresholds']\n        else:\n            return keywords['value_map']\n    if keywords['layer_mode'] == layer_mode_continuous['key']:\n        classifications = keywords['thresholds'].get(exposure_key)\n    else:\n        classifications = keywords['value_maps'].get(exposure_key)\n    if classifications is None:\n        return None\n    for value in list(classifications.values()):\n        if value['active']:\n            return value['classes']\n    return None", "response": "Helper to retrieve active value maps or thresholds for an exposure."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef convert_metadata(keywords, **converter_parameters):\n    def single_field(field, field_definition):\n        \"\"\"Returning single field as string.\n\n        :param field: The field property. Can be string or list of string.\n        :type field: basestring, list\n\n        :param field_definition: The definition of field.\n        :type field_definition: dict\n\n        :returns: The first element of list if only one, or the string if\n            it's string.\n        :rtype: basestring\n        \"\"\"\n        if isinstance(field, list):\n            if len(field) == 1:\n                return field[0]\n            elif len(field) == 0:\n                return None\n            else:\n                raise MetadataConversionError(\n                    'Can not convert keyword with multiple field mapping. The '\n                    'field concept is %s\\nThe fields are %s'\n                    % (field_definition['key'], ', '.join(field))\n                )\n        else:\n            return field\n    if not keywords.get('keyword_version'):\n        raise MetadataConversionError('No keyword version found.')\n    if not keywords['keyword_version'].startswith('4'):\n        raise MetadataConversionError(\n            'Only able to convert metadata version 4.x. Your version is %s' %\n            keywords['keyword_version'])\n    new_keywords = {\n        'keyword_version': '3.5',\n    }\n    # Properties that have the same concepts / values in both 3.5 and 4.3\n    same_properties = [\n        'organisation',\n        'email',\n        'date',\n        'abstract',\n        'title',\n        'license',\n        'url',\n        'layer_purpose',\n        'layer_mode',\n        'layer_geometry',\n        'scale',\n        'source',\n        'exposure',\n        'exposure_unit',\n        'hazard',\n        'hazard_category',\n        'continuous_hazard_unit',\n    ]\n    for same_property in same_properties:\n        if keywords.get(same_property):\n            new_keywords[same_property] = keywords.get(same_property)\n            if same_property == layer_purpose_hazard['key']:\n                if keywords.get(same_property) == hazard_generic['key']:\n                    # We use hazard_generic as key for generic hazard\n                    new_keywords[same_property] = 'hazard_generic'\n\n    # Mandatory keywords\n    try:\n        layer_purpose = keywords['layer_purpose']\n        layer_geometry = keywords['layer_geometry']\n    except KeyError as e:\n        raise MetadataConversionError(e)\n\n    # No need to set value for multipart polygon and resolution\n    inasafe_fields = keywords.get('inasafe_fields', {})\n    inasafe_default_values = keywords.get('inasafe_default_values', {})\n    if layer_purpose == layer_purpose_exposure['key']:\n        exposure = keywords.get('exposure')\n        if not exposure:\n            raise MetadataConversionError(\n                'Layer purpose is exposure but exposure is not set.')\n        if inasafe_fields.get('exposure_type_field'):\n            exposure_class_field = inasafe_fields.get('exposure_type_field')\n            if exposure == exposure_structure['key']:\n                new_keywords['structure_class_field'] = exposure_class_field\n            elif exposure == exposure_road['key']:\n                new_keywords['road_class_field'] = exposure_class_field\n            else:\n                if exposure == exposure_land_cover['key']:\n                    new_keywords['field'] = exposure_class_field\n                else:\n                    new_keywords['structure_class_field'] = (\n                        exposure_class_field)\n        # Data type is only used in population exposure and in v4.x it is\n        # always count\n        if (exposure == exposure_population['key'] and layer_geometry\n                == layer_geometry_raster['key']):\n            new_keywords['datatype'] = 'count'\n        if (exposure == exposure_population['key']\n                and layer_geometry == layer_geometry_polygon['key']):\n            if inasafe_fields.get(exposure_name_field['key']):\n                new_keywords['area_name_field'] = inasafe_fields[\n                    exposure_name_field['key']]\n            if inasafe_fields.get(exposure_id_field['key']):\n                new_keywords['area_id_field'] = inasafe_fields[\n                    exposure_id_field['key']]\n        if inasafe_fields.get(population_count_field['key']):\n            population_field = inasafe_fields[\n                population_count_field['key']]\n            new_keywords['population_field'] = single_field(\n                population_field, population_count_field)\n        if inasafe_fields.get(exposure_name_field['key']):\n            new_keywords['name_field'] = inasafe_fields[\n                exposure_name_field['key']]\n\n        if keywords.get('value_map'):\n            new_keywords['value_mapping'] = keywords['value_map']\n\n    elif layer_purpose == layer_purpose_hazard['key']:\n        layer_mode = keywords['layer_mode']\n        hazard = keywords.get('hazard')\n        if not hazard:\n            raise MetadataConversionError(\n                'Layer purpose is hazard but hazard is not set.')\n        if hazard == hazard_volcano['key']:\n            if inasafe_fields.get(hazard_name_field['key']):\n                new_keywords['volcano_name_field'] = inasafe_fields[\n                    hazard_name_field['key']]\n        if inasafe_fields.get(hazard_value_field['key']):\n            new_keywords['field'] = inasafe_fields[hazard_value_field['key']]\n\n        # Classification and value map (depends on the exposure)\n        try:\n            target_exposure = converter_parameters['exposure']\n        except KeyError:\n            raise MetadataConversionError(\n                'You should supply target exposure for this hazard.'\n            )\n        if layer_mode == layer_mode_continuous['key']:\n            pass\n        # Classified\n        else:\n            classification = active_classification(keywords, target_exposure)\n            value_map = active_thresholds_value_maps(keywords, target_exposure)\n            if layer_geometry == layer_geometry_raster['key']:\n                raster_classification = raster_classification_conversion.get(\n                    classification\n                )\n                if raster_classification:\n                    new_keywords[\n                        'raster_hazard_classification'] = raster_classification\n                    new_keywords['value_map'] = value_map\n                else:\n                    raise MetadataConversionError(\n                        'Could not convert %s to version 3.5 '\n                        'raster hazard classification' % classification\n                    )\n            else:\n                vector_classification = vector_classification_conversion.get(\n                    classification\n                )\n                if vector_classification:\n                    new_keywords[\n                        'vector_hazard_classification'] = vector_classification\n                    new_keywords['value_map'] = value_map\n                else:\n                    raise MetadataConversionError(\n                        'Could not convert %s to version 3.5 '\n                        'vector hazard  classification' % classification\n                    )\n\n    elif layer_purpose == layer_purpose_aggregation['key']:\n        # Fields\n        if inasafe_fields.get(adult_ratio_field['key']):\n            new_keywords['adult ratio attribute'] = single_field(\n                inasafe_fields[adult_ratio_field['key']], adult_ratio_field)\n        if inasafe_fields.get(elderly_ratio_field['key']):\n            new_keywords['elderly ratio attribute'] = single_field(\n                inasafe_fields[elderly_ratio_field['key']],\n                elderly_ratio_field)\n        if inasafe_fields.get(youth_ratio_field['key']):\n            new_keywords['youth ratio attribute'] = single_field(\n                inasafe_fields[youth_ratio_field['key']],\n                youth_ratio_field)\n        if inasafe_fields.get(female_ratio_field['key']):\n            new_keywords['female ratio attribute'] = single_field(\n                inasafe_fields[female_ratio_field['key']],\n                female_ratio_field)\n        # Notes(IS) I think people use name for the aggregation attribute\n        if inasafe_fields.get(aggregation_name_field['key']):\n            new_keywords['aggregation attribute'] = inasafe_fields[\n                aggregation_name_field['key']]\n        # Default values\n        if inasafe_default_values.get(adult_ratio_field['key']):\n            new_keywords['adult ratio default'] = inasafe_default_values[\n                adult_ratio_field['key']]\n        if inasafe_default_values.get(elderly_ratio_field['key']):\n            new_keywords['elderly ratio default'] = inasafe_default_values[\n                elderly_ratio_field['key']]\n        if inasafe_default_values.get(youth_ratio_field['key']):\n            new_keywords['youth ratio default'] = inasafe_default_values[\n                youth_ratio_field['key']]\n        if inasafe_default_values.get(female_ratio_field['key']):\n            new_keywords['female ratio default'] = inasafe_default_values[\n                female_ratio_field['key']]\n\n    return new_keywords", "response": "Convert metadata from version 4. 3 to version 3. 5."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_next_step(self):\n        layer_purpose = self.parent.step_kw_purpose.selected_purpose()\n        if layer_purpose != layer_purpose_aggregation:\n            subcategory = self.parent.step_kw_subcategory.\\\n                selected_subcategory()\n        else:\n            subcategory = {'key': None}\n\n        # Has classifications, go to multi classifications\n        if subcategory.get('classifications'):\n            if layer_purpose == layer_purpose_hazard:\n                return self.parent.step_kw_multi_classifications\n\n        # Check if it can go to inasafe field step\n        non_compulsory_fields = get_non_compulsory_fields(\n            layer_purpose['key'], subcategory['key'])\n        if not skip_inasafe_field(self.parent.layer, non_compulsory_fields):\n            # Do not go to InaSAFE Field step if we already visited it.\n            # For example in place exposure.\n            if (self.parent.step_kw_inasafe_fields not in\n                    self.parent.keyword_steps):\n                return self.parent.step_kw_inasafe_fields\n\n        # Check if it can go to inasafe default field step\n        default_inasafe_fields = get_fields(\n            layer_purpose['key'],\n            subcategory['key'],\n            replace_null=True,\n            in_group=False)\n        if default_inasafe_fields:\n            return self.parent.step_kw_default_inasafe_fields\n\n        # Any other case\n        return self.parent.step_kw_source", "response": "Find the proper step when user clicks the Next button."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting widgets on the Field Mapping step.", "response": "def set_widgets(self):\n        \"\"\"Set widgets on the Field Mapping step.\"\"\"\n        on_the_fly_metadata = {}\n        layer_purpose = self.parent.step_kw_purpose.selected_purpose()\n        on_the_fly_metadata['layer_purpose'] = layer_purpose['key']\n        if layer_purpose != layer_purpose_aggregation:\n            subcategory = self.parent.step_kw_subcategory.\\\n                selected_subcategory()\n            if layer_purpose == layer_purpose_exposure:\n                on_the_fly_metadata['exposure'] = subcategory['key']\n            if layer_purpose == layer_purpose_hazard:\n                on_the_fly_metadata['hazard'] = subcategory['key']\n        inasafe_fields = self.parent.get_existing_keyword(\n            'inasafe_fields')\n        inasafe_default_values = self.parent.get_existing_keyword(\n            'inasafe_default_values')\n        on_the_fly_metadata['inasafe_fields'] = inasafe_fields\n        on_the_fly_metadata['inasafe_default_values'] = inasafe_default_values\n        self.field_mapping_widget.set_layer(\n            self.parent.layer, on_the_fly_metadata)\n        self.field_mapping_widget.show()\n        self.main_layout.addWidget(self.field_mapping_widget)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_field_mapping(self):\n        field_mapping = self.field_mapping_widget.get_field_mapping()\n        for k, v in list(field_mapping['values'].items()):\n            if not v:\n                field_mapping['values'].pop(k)\n        for k, v in list(field_mapping['fields'].items()):\n            if not v:\n                field_mapping['fields'].pop(k)\n        return field_mapping", "response": "Obtain metadata from current state of the widget."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_inasafe_fields(layer, keywords_only=False):\n    inasafe_fields = layer.keywords['inasafe_fields']\n\n    real_fields = [field.name() for field in layer.fields().toList()]\n\n    inasafe_fields_flat = []\n    for value in list(inasafe_fields.values()):\n        if isinstance(value, list):\n            inasafe_fields_flat.extend(value)\n        else:\n            inasafe_fields_flat.append(value)\n\n    difference = set(inasafe_fields_flat).difference(real_fields)\n    if len(difference):\n        message = tr(\n            'inasafe_fields has more fields than the layer %s itself : %s'\n            % (layer.keywords['layer_purpose'], difference))\n        raise InvalidLayerError(message)\n\n    if keywords_only:\n        # We don't check if it's valid from the layer. The layer may have more\n        # fields than inasafe_fields.\n        return True\n\n    difference = set(real_fields).difference(inasafe_fields_flat)\n    if len(difference):\n        message = tr(\n            'The layer %s has more fields than inasafe_fields : %s'\n            % (layer.title(), difference))\n        raise InvalidLayerError(message)\n\n    return True", "response": "Helper to check inasafe_fields."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread last state of GUI from configuration file.", "response": "def restore_state(self):\n        \"\"\"Read last state of GUI from configuration file.\n\n        .. versionadded: 3.3\n        \"\"\"\n        settings = QSettings()\n        try:\n            last_path = settings.value('directory', type=str)\n        except TypeError:\n            last_path = ''\n        self.output_directory.setText(last_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef on_directory_button_clicked(self):\n        # noinspection PyCallByClass,PyTypeChecker\n        self.output_directory.setText(QFileDialog.getExistingDirectory(\n            self, self.tr('Select download directory')))", "response": "Show a dialog to choose directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef accept(self):\n\n        self.save_state()\n        try:\n            self.require_directory()\n        except CanceledImportDialogError:\n            return\n\n        QgsApplication.instance().setOverrideCursor(\n            QtGui.QCursor(QtCore.Qt.WaitCursor)\n        )\n\n        source = self.define_url()\n        # save the file as json first\n        name = 'jakarta_flood.json'\n        output_directory = self.output_directory.text()\n        output_prefix = self.filename_prefix.text()\n        overwrite = self.overwrite_flag.isChecked()\n        date_stamp_flag = self.include_date_flag.isChecked()\n        output_base_file_path = self.get_output_base_path(\n            output_directory,\n            output_prefix,\n            date_stamp_flag,\n            name,\n            overwrite)\n\n        title = self.tr(\"Can't access API\")\n\n        try:\n            self.download(source, output_base_file_path)\n\n            # Open downloaded file as QgsMapLayer\n            options = QgsVectorLayer.LayerOptions(False)\n            layer = QgsVectorLayer(\n                output_base_file_path, 'flood', 'ogr', options)\n        except Exception as e:\n            disable_busy_cursor()\n            QMessageBox.critical(self, title, str(e))\n            return\n\n        self.time_stamp = time.strftime('%d-%b-%Y %H:%M:%S')\n        # Now save as shp\n        name = 'jakarta_flood.shp'\n        output_base_file_path = self.get_output_base_path(\n            output_directory,\n            output_prefix,\n            date_stamp_flag,\n            name,\n            overwrite)\n        QgsVectorFileWriter.writeAsVectorFormat(\n            layer,\n            output_base_file_path,\n            'CP1250',\n            QgsCoordinateTransform(),\n            'ESRI Shapefile')\n        # Get rid of the GeoJSON layer and rather use local shp\n        del layer\n\n        self.copy_style(output_base_file_path)\n\n        self.copy_keywords(output_base_file_path)\n        layer = self.add_flooded_field(output_base_file_path)\n\n        # check if the layer has feature or not\n        if layer.featureCount() <= 0:\n            city = self.city_combo_box.currentText()\n            message = self.tr(\n                'There are no floods data available on {city} '\n                'at this time.').format(city=city)\n            display_warning_message_box(\n                self,\n                self.tr('No data'),\n                message)\n            disable_busy_cursor()\n        else:\n            # add the layer to the map\n            project = QgsProject.instance()\n            project.addMapLayer(layer)\n            disable_busy_cursor()\n            self.done(QDialog.Accepted)", "response": "Download and display the file in QGIS."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a vector layer from the local shp adding the flooded field.", "response": "def add_flooded_field(self, shapefile_path):\n        \"\"\"Create the layer from the local shp adding the flooded field.\n\n        .. versionadded:: 3.3\n\n        Use this method to add a calculated field to a shapefile. The shapefile\n        should have a field called 'count' containing the number of flood\n        reports for the field. The field values will be set to 0 if the count\n        field is < 1, otherwise it will be set to 1.\n\n        :param shapefile_path: Path to the shapefile that will have the flooded\n            field added.\n        :type shapefile_path: basestring\n\n        :return: A vector layer with the flooded field added.\n        :rtype: QgsVectorLayer\n        \"\"\"\n        layer = QgsVectorLayer(\n            shapefile_path, self.tr('Jakarta Floods'), 'ogr')\n        # Add a calculated field indicating if a poly is flooded or not\n        # from qgis.PyQt.QtCore import QVariant\n        layer.startEditing()\n        # Add field with integer from 0 to 4 which represents the flood\n        # class. Its the same as 'state' field except that is being treated\n        # as a string.\n        # This is used for cartography\n        flood_class_field = QgsField('floodclass', QVariant.Int)\n        layer.addAttribute(flood_class_field)\n        layer.commitChanges()\n        layer.startEditing()\n        flood_class_idx = layer.fields().lookupField('floodclass')\n        flood_class_expression = QgsExpression('to_int(state)')\n        context = QgsExpressionContext()\n        context.setFields(layer.fields())\n        flood_class_expression.prepare(context)\n\n        # Add field with boolean flag to say if the area is flooded\n        # This is used by the impact function\n        flooded_field = QgsField('flooded', QVariant.Int)\n        layer.dataProvider().addAttributes([flooded_field])\n        layer.commitChanges()\n        layer.startEditing()\n        flooded_idx = layer.fields().lookupField('flooded')\n        flood_flag_expression = QgsExpression('state > 0')\n        flood_flag_expression.prepare(context)\n        for feature in layer.getFeatures():\n            context.setFeature(feature)\n            feature[flood_class_idx] = flood_class_expression.evaluate(context)\n            feature[flooded_idx] = flood_flag_expression.evaluate(context)\n            layer.updateFeature(feature)\n        layer.commitChanges()\n        return layer"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncopies keywords from the OSM resource directory to the output path.", "response": "def copy_keywords(self, shapefile_path):\n        \"\"\"Copy keywords from the OSM resource directory to the output path.\n\n        .. versionadded: 3.3\n\n        In addition to copying the template, tokens within the template will\n        be replaced with new values for the date token and title token.\n\n        :param shapefile_path: Path to the shapefile that will have the flooded\n            field added.\n        :type shapefile_path: basestring\n        \"\"\"\n        source_xml_path = resources_path('petabencana', 'flood-keywords.xml')\n        output_xml_path = shapefile_path.replace('shp', 'xml')\n        LOGGER.info('Copying xml to: %s' % output_xml_path)\n\n        title_token = '[TITLE]'\n        new_title = self.tr('Jakarta Floods - %s' % self.time_stamp)\n\n        date_token = '[DATE]'\n        new_date = self.time_stamp\n        with open(source_xml_path) as source_file, \\\n                open(output_xml_path, 'w') as output_file:\n            for line in source_file:\n                line = line.replace(date_token, new_date)\n                line = line.replace(title_token, new_title)\n                output_file.write(line)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef copy_style(shapefile_path):\n        source_qml_path = resources_path('petabencana', 'flood-style.qml')\n        output_qml_path = shapefile_path.replace('shp', 'qml')\n        LOGGER.info('Copying qml to: %s' % output_qml_path)\n        copy(source_qml_path, output_qml_path)", "response": "Copy the style from the OSM resource directory to the output path."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_shapefile(self, feature_type, base_path):\n\n        path = '%s.shp' % base_path\n\n        if not os.path.exists(path):\n            message = self.tr(\n                '%s does not exist. The server does not have any data for '\n                'this extent.' % path)\n            raise FileMissingError(message)\n\n        self.iface.addVectorLayer(path, feature_type, 'ogr')", "response": "Load downloaded shape file to QGIS Main Window."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndownload file from API url and write to output_path.", "response": "def download(self, url, output_path):\n        \"\"\"Download file from API url and write to output path.\n\n        :param url: URL of the API.\n        :type url: str\n\n        :param output_path: Path of output file,\n        :type output_path: str\n        \"\"\"\n        request_failed_message = self.tr(\n            \"Can't access PetaBencana API: {source}\").format(\n            source=url)\n        downloader = FileDownloader(url, output_path)\n        result, message = downloader.download()\n        if not result:\n            display_warning_message_box(\n                self,\n                self.tr('Download error'),\n                self.tr(request_failed_message + '\\n' + message))\n\n        if result == QNetworkReply.OperationCanceledError:\n            display_warning_message_box(\n                self,\n                self.tr('Download error'),\n                self.tr(message))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef populate_combo_box(self):\n        if self.radio_button_production.isChecked():\n            self.source = production_api['url']\n            available_data = production_api['available_data']\n\n        else:\n            self.source = development_api['url']\n            available_data = development_api['available_data']\n\n        self.city_combo_box.clear()\n        for index, data in enumerate(available_data):\n            self.city_combo_box.addItem(data['name'])\n            self.city_combo_box.setItemData(\n                index, data['code'], Qt.UserRole)", "response": "Populate combobox for selecting city."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef define_url(self):\n        current_index = self.city_combo_box.currentIndex()\n        city_code = self.city_combo_box.itemData(current_index, Qt.UserRole)\n        source = (self.source).format(city_code=city_code)\n        return source", "response": "Define API url based on which source is selected."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nextracting provenance details of layers. This extractor would be the main provenance details extractor which produce tree view provenance details. :param impact_report: the impact report that acts as a proxy to fetch all the data that extractor needed :type impact_report: safe.report.impact_report.ImpactReport :param component_metadata: the component metadata. Used to obtain information about the component we want to render :type component_metadata: safe.report.report_metadata. ReportComponentsMetadata :return: context for rendering phase :rtype: dict .. versionadded:: 4.1", "response": "def analysis_provenance_details_extractor(impact_report, component_metadata):\n    \"\"\"Extracting provenance details of layers.\n\n    This extractor would be the main provenance details extractor which produce\n    tree view provenance details.\n\n    :param impact_report: the impact report that acts as a proxy to fetch\n        all the data that extractor needed\n    :type impact_report: safe.report.impact_report.ImpactReport\n\n    :param component_metadata: the component metadata. Used to obtain\n        information about the component we want to render\n    :type component_metadata: safe.report.report_metadata.\n        ReportComponentsMetadata\n\n    :return: context for rendering phase\n    :rtype: dict\n\n    .. versionadded:: 4.1\n    \"\"\"\n    context = {}\n    extra_args = component_metadata.extra_args\n\n    provenance_format_args = resolve_from_dictionary(\n        extra_args, 'provenance_format')\n\n    keywords_order = [\n        'title',\n        'source',\n        'layer_purpose',\n        'layer_geometry',\n        'hazard',\n        'exposure',\n        'hazard_category',\n        'exposure_unit',\n        'value_map',\n        'value_maps',\n        'inasafe_fields',\n        'inasafe_default_values',\n        'layer_mode',\n        'hazard_layer',\n        'exposure_layer',\n        'aggregation_layer',\n        'keyword_version',\n        'classification',\n    ]\n\n    use_rounding = impact_report.impact_function.use_rounding\n    debug_mode = impact_report.impact_function.debug_mode\n\n    # we define dict here to create a different object of keyword\n    hazard_keywords = dict(impact_report.impact_function.provenance[\n        'hazard_keywords'])\n\n    # hazard_keywords doesn't have hazard_layer path information\n    hazard_layer = QgsDataSourceUri.removePassword(\n        decode_full_layer_uri(\n            impact_report.impact_function.provenance.get(\n                provenance_hazard_layer['provenance_key']))[0])\n    hazard_keywords['hazard_layer'] = hazard_layer\n\n    # keep only value maps with IF exposure\n    for keyword in ['value_maps', 'thresholds']:\n        if hazard_keywords.get(keyword):\n            temp_keyword = dict(hazard_keywords[keyword])\n            for key in temp_keyword:\n                if key not in impact_report.impact_function.provenance[\n                        'exposure_keywords']['exposure']:\n                    del hazard_keywords[keyword][key]\n\n    header = resolve_from_dictionary(\n        provenance_format_args, 'hazard_header')\n    hazard_provenance = {\n        'header': header.title(),\n        'provenances': headerize(\n            sorted_keywords_by_order(hazard_keywords, keywords_order))\n    }\n\n    # convert value if there is dict_keywords\n    provenances = hazard_provenance['provenances']\n    hazard_provenance['provenances'] = resolve_dict_keywords(provenances)\n\n    # we define dict here to create a different object of keyword\n    exposure_keywords = dict(impact_report.impact_function.provenance[\n        'exposure_keywords'])\n\n    # exposure_keywords doesn't have exposure_layer path information\n    exposure_layer = QgsDataSourceUri.removePassword(\n        decode_full_layer_uri(\n            impact_report.impact_function.provenance.get(\n                provenance_exposure_layer['provenance_key']))[0])\n    exposure_keywords['exposure_layer'] = exposure_layer\n\n    header = resolve_from_dictionary(\n        provenance_format_args, 'exposure_header')\n    exposure_provenance = {\n        'header': header.title(),\n        'provenances': headerize(\n            sorted_keywords_by_order(exposure_keywords, keywords_order))\n    }\n\n    # convert value if there is dict_keywords\n    provenances = exposure_provenance['provenances']\n    exposure_provenance['provenances'] = resolve_dict_keywords(provenances)\n\n    # aggregation keywords could be None so we don't define dict here\n    aggregation_keywords = impact_report.impact_function.provenance[\n        'aggregation_keywords']\n\n    header = resolve_from_dictionary(\n        provenance_format_args, 'aggregation_header')\n\n    aggregation_provenance = {\n        'header': header.title(),\n        'provenances': None\n    }\n\n    # only if aggregation layer used\n    if aggregation_keywords:\n        # we define dict here to create a different object of keyword\n        aggregation_keywords = dict(aggregation_keywords)\n\n        # aggregation_keywords doesn't have aggregation_layer path information\n        aggregation_layer = QgsDataSourceUri.removePassword(\n            decode_full_layer_uri(\n                impact_report.impact_function.provenance.get(\n                    provenance_aggregation_layer['provenance_key']))[0])\n        aggregation_keywords['aggregation_layer'] = aggregation_layer\n\n        aggregation_provenance['provenances'] = headerize(\n            sorted_keywords_by_order(aggregation_keywords, keywords_order))\n\n        # convert value if there is dict_keywords\n        provenances = aggregation_provenance['provenances']\n        aggregation_provenance['provenances'] = resolve_dict_keywords(\n            provenances)\n\n    else:\n        aggregation_not_used = resolve_from_dictionary(\n            extra_args, ['defaults', 'aggregation_not_used'])\n        aggregation_provenance['provenances'] = aggregation_not_used\n\n    all_provenance_keywords = dict(impact_report.impact_function.provenance)\n\n    # we add debug mode information to the provenance\n    all_provenance_keywords[\n        provenance_use_rounding['provenance_key']] = (\n        'On' if use_rounding else 'Off')\n    all_provenance_keywords['debug_mode'] = 'On' if debug_mode else 'Off'\n\n    header = resolve_from_dictionary(\n        provenance_format_args, 'analysis_environment_header')\n    analysis_environment_provenance_items = OrderedDict()\n    analysis_environment_provenance_keys = [\n        'os',\n        'inasafe_version',\n        provenance_use_rounding['provenance_key'],\n        'debug_mode',\n        'qgis_version',\n        'qt_version',\n        'gdal_version',\n        'pyqt_version']\n\n    for item in analysis_environment_provenance_keys:\n        analysis_environment_provenance_items[item] = (\n            all_provenance_keywords[item])\n\n    analysis_environment_provenance = {\n        'header': header.title(),\n        'provenances': headerize(analysis_environment_provenance_items)\n    }\n\n    impact_function_name = impact_report.impact_function.name\n    header = resolve_from_dictionary(\n        provenance_format_args, 'impact_function_header')\n    impact_function_provenance = {\n        'header': header.title(),\n        'provenances': impact_function_name\n    }\n\n    provenance_detail = OrderedDict()\n    provenance_detail['impact_function'] = impact_function_provenance\n    provenance_detail['hazard'] = hazard_provenance\n    provenance_detail['exposure'] = exposure_provenance\n    provenance_detail['aggregation'] = aggregation_provenance\n    provenance_detail['analysis_environment'] = analysis_environment_provenance\n\n    analysis_details_header = resolve_from_dictionary(\n        extra_args, ['header', 'analysis_detail'])\n\n    context['component_key'] = component_metadata.key\n    context.update({\n        'header': analysis_details_header,\n        'details': provenance_detail\n    })\n\n    return context"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef analysis_provenance_details_simplified_extractor(\n        impact_report, component_metadata):\n    \"\"\"Extracting simplified version of provenance details of layers.\n\n    This extractor will produce provenance details which will be displayed in\n    the main report.\n\n    :param impact_report: the impact report that acts as a proxy to fetch\n        all the data that extractor needed\n    :type impact_report: safe.report.impact_report.ImpactReport\n\n    :param component_metadata: the component metadata. Used to obtain\n        information about the component we want to render\n    :type component_metadata: safe.report.report_metadata.\n        ReportComponentsMetadata\n\n    :return: context for rendering phase\n    :rtype: dict\n\n    .. versionadded:: 4.0\n    \"\"\"\n    context = {}\n    extra_args = component_metadata.extra_args\n\n    default_source = resolve_from_dictionary(\n        extra_args, ['defaults', 'source'])\n    default_reference = resolve_from_dictionary(\n        extra_args, ['defaults', 'reference'])\n    provenance_format_args = resolve_from_dictionary(\n        extra_args, 'provenance_format')\n\n    hazard_keywords = impact_report.impact_function.provenance[\n        'hazard_keywords']\n    header = resolve_from_dictionary(\n        provenance_format_args, 'hazard_header')\n    provenance_format = resolve_from_dictionary(\n        provenance_format_args, 'hazard_format')\n    hazard_provenance = {\n        'header': header,\n        'provenance': provenance_format.format(\n            layer_name=hazard_keywords.get('title'),\n            source=QgsDataSourceUri.removePassword(\n                decode_full_layer_uri(hazard_keywords.get('source'))[0]\n                or default_source))\n    }\n\n    exposure_keywords = impact_report.impact_function.provenance[\n        'exposure_keywords']\n    header = resolve_from_dictionary(\n        provenance_format_args, 'exposure_header')\n    provenance_format = resolve_from_dictionary(\n        provenance_format_args, 'exposure_format')\n    exposure_provenance = {\n        'header': header,\n        'provenance': provenance_format.format(\n            layer_name=exposure_keywords.get('title'),\n            source=QgsDataSourceUri.removePassword(\n                decode_full_layer_uri(exposure_keywords.get('source'))[0]\n                or default_source))\n    }\n\n    aggregation_keywords = impact_report.impact_function.provenance[\n        'aggregation_keywords']\n    header = resolve_from_dictionary(\n        provenance_format_args, 'aggregation_header')\n    provenance_format = resolve_from_dictionary(\n        provenance_format_args, 'aggregation_format')\n    # only if aggregation layer used\n    if aggregation_keywords:\n        provenance_string = provenance_format.format(\n            layer_name=aggregation_keywords.get('title'),\n            source=QgsDataSourceUri.removePassword(\n                decode_full_layer_uri(aggregation_keywords.get('source'))[0]\n                or default_source))\n    else:\n        aggregation_not_used = resolve_from_dictionary(\n            extra_args, ['defaults', 'aggregation_not_used'])\n        provenance_string = aggregation_not_used\n\n    aggregation_provenance = {\n        'header': header,\n        'provenance': provenance_string\n    }\n\n    impact_function_name = impact_report.impact_function.name\n    header = resolve_from_dictionary(\n        provenance_format_args, 'impact_function_header')\n    provenance_format = resolve_from_dictionary(\n        provenance_format_args, 'impact_function_format')\n    impact_function_provenance = {\n        'header': header,\n        'provenance': provenance_format.format(\n            impact_function_name=impact_function_name,\n            reference=default_reference)\n    }\n\n    provenance_detail = OrderedDict()\n    provenance_detail['hazard'] = hazard_provenance\n    provenance_detail['exposure'] = exposure_provenance\n    provenance_detail['aggregation'] = aggregation_provenance\n    provenance_detail['impact_function'] = impact_function_provenance\n\n    analysis_details_header = resolve_from_dictionary(\n        extra_args, ['header', 'analysis_detail'])\n\n    context['component_key'] = component_metadata.key\n    context.update({\n        'header': analysis_details_header,\n        'details': provenance_detail\n    })\n\n    return context", "response": "This function extracts the simplified version of provenance details of layers and returns the context for rendering the phase of the analysis."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef analysis_provenance_details_pdf_extractor(\n        impact_report, component_metadata):\n    \"\"\"Extracting the main provenance details to its own pdf report.\n\n    For PDF generations\n\n    :param impact_report: the impact report that acts as a proxy to fetch\n        all the data that extractor needed\n    :type impact_report: safe.report.impact_report.ImpactReport\n\n    :param component_metadata: the component metadata. Used to obtain\n        information about the component we want to render\n    :type component_metadata: safe.report.report_metadata.\n        ReportComponentsMetadata\n\n    :return: context for rendering phase\n    :rtype: dict\n\n    .. versionadded:: 4.1\n    \"\"\"\n    # QGIS Composer needed certain context to generate the output\n    # - Map Settings\n    # - Substitution maps\n    # - Element settings, such as icon for picture file or image source\n\n    context = QGISComposerContext()\n\n    # we only have html elements for this\n    html_frame_elements = [\n        {\n            'id': 'analysis-provenance-details-report',\n            'mode': 'text',\n            'text': jinja2_output_as_string(\n                impact_report, 'analysis-provenance-details-report'),\n            'margin_left': 10,\n            'margin_top': 10,\n        }\n    ]\n    context.html_frame_elements = html_frame_elements\n    return context", "response": "This function extracts the main provenance details to its own pdf report."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a header for every keyword.", "response": "def headerize(provenances):\n    \"\"\"Create a header for each keyword.\n\n    :param provenances: The keywords.\n    :type provenances: dict\n\n    :return: New keywords with header for every keyword.\n    :rtype: dict\n    \"\"\"\n\n    special_case = {\n        'Inasafe': 'InaSAFE',\n        'Qgis': 'QGIS',\n        'Pyqt': 'PyQt',\n        'Os': 'OS',\n        'Gdal': 'GDAL',\n        'Maps': 'Map'\n    }\n    for key, value in list(provenances.items()):\n        if '_' in key:\n            header = key.replace('_', ' ').title()\n        else:\n            header = key.title()\n\n        header_list = header.split(' ')\n        proper_word = None\n        proper_word_index = None\n        for index, word in enumerate(header_list):\n            if word in list(special_case.keys()):\n                proper_word = special_case[word]\n                proper_word_index = index\n\n        if proper_word:\n            header_list[proper_word_index] = proper_word\n\n        header = ' '.join(header_list)\n\n        provenances.update(\n            {\n                key: {\n                    'header': '{header} '.format(header=header),\n                    'content': value\n                }\n            })\n\n    return provenances"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef resolve_dict_keywords(keywords):\n\n    for keyword in ['value_map', 'inasafe_fields', 'inasafe_default_values']:\n        value = keywords.get(keyword)\n        if value:\n            value = value.get('content')\n            value = KeywordIO._dict_to_row(value).to_html()\n            keywords[keyword]['content'] = value\n\n    value_maps = keywords.get('value_maps')\n    thresholds = keywords.get('thresholds')\n    if value_maps:\n        value_maps = value_maps.get('content')\n        value_maps = KeywordIO._value_maps_row(value_maps).to_html()\n        keywords['value_maps']['content'] = value_maps\n    if thresholds:\n        thresholds = thresholds.get('content')\n        thresholds = KeywordIO._threshold_to_row(thresholds).to_html()\n        keywords['thresholds']['content'] = thresholds\n\n    return keywords", "response": "Replace dictionary content with html."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sorted_keywords_by_order(keywords, order):\n\n    # we need to delete item with no value\n    for key, value in list(keywords.items()):\n        if value is None:\n            del keywords[key]\n\n    ordered_keywords = OrderedDict()\n    for key in order:\n        if key in list(keywords.keys()):\n            ordered_keywords[key] = keywords.get(key)\n\n    for keyword in keywords:\n        if keyword not in order:\n            ordered_keywords[keyword] = keywords.get(keyword)\n\n    return ordered_keywords", "response": "Sort keywords based on defined order."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding an action to the InaSAFE toolbar.", "response": "def add_action(self, action, add_to_toolbar=True, add_to_legend=False):\n        \"\"\"Add a toolbar icon to the InaSAFE toolbar.\n\n        :param action: The action that should be added to the toolbar.\n        :type action: QAction\n\n        :param add_to_toolbar: Flag indicating whether the action should also\n            be added to the InaSAFE toolbar. Defaults to True.\n        :type add_to_toolbar: bool\n\n        :param add_to_legend: Flag indicating whether the action should also\n            be added to the layer legend menu. Default to False.\n        :type add_to_legend: bool\n        \"\"\"\n        # store in the class list of actions for easy plugin unloading\n        self.actions.append(action)\n        self.iface.addPluginToMenu(self.tr('InaSAFE'), action)\n        if add_to_toolbar:\n            self.toolbar.addAction(action)\n        if add_to_legend:\n            # The id is the action name without spaces, tabs ...\n            self.iface.addCustomActionForLayerType(\n                action,\n                self.tr('InaSAFE'),\n                QgsMapLayer.VectorLayer,\n                True)\n            self.iface.addCustomActionForLayerType(\n                action,\n                self.tr('InaSAFE'),\n                QgsMapLayer.RasterLayer,\n                True)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _create_dock_toggle_action(self):\n        # pylint: disable=W0201\n        icon = resources_path('img', 'icons', 'icon.svg')\n        self.action_dock = QAction(\n            QIcon(icon),\n            self.tr('Toggle InaSAFE Dock'), self.iface.mainWindow())\n        self.action_dock.setObjectName('InaSAFEDockToggle')\n        self.action_dock.setStatusTip(self.tr(\n            'Show/hide InaSAFE dock widget'))\n        self.action_dock.setWhatsThis(self.tr(\n            'Show/hide InaSAFE dock widget'))\n        self.action_dock.setCheckable(True)\n        self.action_dock.setChecked(True)\n        self.action_dock.triggered.connect(self.toggle_dock_visibility)\n        self.add_action(self.action_dock)", "response": "Create action for plugin dockable window (show or hide."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates action for keywords creation wizard.", "response": "def _create_keywords_wizard_action(self):\n        \"\"\"Create action for keywords creation wizard.\"\"\"\n        icon = resources_path('img', 'icons', 'show-keyword-wizard.svg')\n        self.action_keywords_wizard = QAction(\n            QIcon(icon),\n            self.tr('Keywords Creation Wizard'),\n            self.iface.mainWindow())\n        self.action_keywords_wizard.setStatusTip(self.tr(\n            'Open InaSAFE keywords creation wizard'))\n        self.action_keywords_wizard.setWhatsThis(self.tr(\n            'Open InaSAFE keywords creation wizard'))\n        self.action_keywords_wizard.setEnabled(False)\n        self.action_keywords_wizard.triggered.connect(\n            self.show_keywords_wizard)\n        self.add_action(self.action_keywords_wizard, add_to_legend=True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating action for IF - centric wizard.", "response": "def _create_analysis_wizard_action(self):\n        \"\"\"Create action for IF-centric wizard.\"\"\"\n        icon = resources_path('img', 'icons', 'show-wizard.svg')\n        self.action_function_centric_wizard = QAction(\n            QIcon(icon),\n            self.tr('Impact Function Centric Wizard'),\n            self.iface.mainWindow())\n        self.action_function_centric_wizard.setStatusTip(self.tr(\n            'Open InaSAFE impact function centric wizard'))\n        self.action_function_centric_wizard.setWhatsThis(self.tr(\n            'Open InaSAFE impact function centric wizard'))\n        self.action_function_centric_wizard.setEnabled(True)\n        self.action_function_centric_wizard.triggered.connect(\n            self.show_function_centric_wizard)\n        self.add_action(self.action_function_centric_wizard)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates action for options dialog.", "response": "def _create_options_dialog_action(self):\n        \"\"\"Create action for options dialog.\"\"\"\n        icon = resources_path('img', 'icons', 'configure-inasafe.svg')\n        self.action_options = QAction(\n            QIcon(icon),\n            self.tr('Options'), self.iface.mainWindow())\n        self.action_options.setStatusTip(self.tr(\n            'Open InaSAFE options dialog'))\n        self.action_options.setWhatsThis(self.tr(\n            'Open InaSAFE options dialog'))\n        self.action_options.triggered.connect(self.show_options)\n        self.add_action(self.action_options, add_to_toolbar=self.full_toolbar)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _create_minimum_needs_action(self):\n        icon = resources_path('img', 'icons', 'show-minimum-needs.svg')\n        self.action_minimum_needs = QAction(\n            QIcon(icon),\n            self.tr('Minimum Needs Calculator'), self.iface.mainWindow())\n        self.action_minimum_needs.setStatusTip(self.tr(\n            'Open InaSAFE minimum needs calculator'))\n        self.action_minimum_needs.setWhatsThis(self.tr(\n            'Open InaSAFE minimum needs calculator'))\n        self.action_minimum_needs.triggered.connect(self.show_minimum_needs)\n        self.add_action(\n            self.action_minimum_needs, add_to_toolbar=self.full_toolbar)", "response": "Create action for minimum needs dialog."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating action for multi buffer dialog.", "response": "def _create_multi_buffer_action(self):\n        \"\"\"Create action for multi buffer dialog.\"\"\"\n        icon = resources_path('img', 'icons', 'show-multi-buffer.svg')\n        self.action_multi_buffer = QAction(\n            QIcon(icon),\n            self.tr('Multi Buffer'), self.iface.mainWindow())\n        self.action_multi_buffer.setStatusTip(self.tr(\n            'Open InaSAFE multi buffer'))\n        self.action_multi_buffer.setWhatsThis(self.tr(\n            'Open InaSAFE multi buffer'))\n        self.action_multi_buffer.triggered.connect(self.show_multi_buffer)\n        self.add_action(\n            self.action_multi_buffer,\n            add_to_toolbar=self.full_toolbar)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _create_minimum_needs_options_action(self):\n        icon = resources_path('img', 'icons', 'show-global-minimum-needs.svg')\n        self.action_minimum_needs_config = QAction(\n            QIcon(icon),\n            self.tr('Minimum Needs Configuration'),\n            self.iface.mainWindow())\n        self.action_minimum_needs_config.setStatusTip(self.tr(\n            'Open InaSAFE minimum needs configuration'))\n        self.action_minimum_needs_config.setWhatsThis(self.tr(\n            'Open InaSAFE minimum needs configuration'))\n        self.action_minimum_needs_config.triggered.connect(\n            self.show_minimum_needs_configuration)\n        self.add_action(\n            self.action_minimum_needs_config, add_to_toolbar=self.full_toolbar)", "response": "Create action for global minimum needs dialog."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating action for converter dialog.", "response": "def _create_shakemap_converter_action(self):\n        \"\"\"Create action for converter dialog.\"\"\"\n        icon = resources_path('img', 'icons', 'show-converter-tool.svg')\n        self.action_shake_converter = QAction(\n            QIcon(icon),\n            self.tr('Shakemap Converter'), self.iface.mainWindow())\n        self.action_shake_converter.setStatusTip(self.tr(\n            'Open InaSAFE Converter'))\n        self.action_shake_converter.setWhatsThis(self.tr(\n            'Open InaSAFE Converter'))\n        self.action_shake_converter.triggered.connect(\n            self.show_shakemap_importer)\n        self.add_action(\n            self.action_shake_converter, add_to_toolbar=self.full_toolbar)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _create_batch_runner_action(self):\n        icon = resources_path('img', 'icons', 'show-batch-runner.svg')\n        self.action_batch_runner = QAction(\n            QIcon(icon),\n            self.tr('Batch Runner'), self.iface.mainWindow())\n        self.action_batch_runner.setStatusTip(self.tr(\n            'Open Batch Runner'))\n        self.action_batch_runner.setWhatsThis(self.tr(\n            'Open Batch Runner'))\n        self.action_batch_runner.triggered.connect(self.show_batch_runner)\n        self.add_action(\n            self.action_batch_runner, add_to_toolbar=self.full_toolbar)", "response": "Create action for batch runner dialog."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate action for save current scenario dialog.", "response": "def _create_save_scenario_action(self):\n        \"\"\"Create action for save scenario dialog.\"\"\"\n        icon = resources_path('img', 'icons', 'save-as-scenario.svg')\n        self.action_save_scenario = QAction(\n            QIcon(icon),\n            self.tr('Save Current Scenario'), self.iface.mainWindow())\n        message = self.tr('Save current scenario to text file')\n        self.action_save_scenario.setStatusTip(message)\n        self.action_save_scenario.setWhatsThis(message)\n        # noinspection PyUnresolvedReferences\n        self.action_save_scenario.triggered.connect(self.save_scenario)\n        self.add_action(\n            self.action_save_scenario, add_to_toolbar=self.full_toolbar)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _create_osm_downloader_action(self):\n        icon = resources_path('img', 'icons', 'show-osm-download.svg')\n        self.action_import_dialog = QAction(\n            QIcon(icon),\n            self.tr('OpenStreetMap Downloader'),\n            self.iface.mainWindow())\n        self.action_import_dialog.setStatusTip(self.tr(\n            'OpenStreetMap Downloader'))\n        self.action_import_dialog.setWhatsThis(self.tr(\n            'OpenStreetMap Downloader'))\n        self.action_import_dialog.triggered.connect(self.show_osm_downloader)\n        self.add_action(self.action_import_dialog, add_to_toolbar=True)", "response": "Create action for import OSM Downloader dialog."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _create_geonode_uploader_action(self):\n        icon = resources_path('img', 'icons', 'geonode.png')\n        label = tr('Geonode Uploader')\n        self.action_geonode = QAction(\n            QIcon(icon), label, self.iface.mainWindow())\n        self.action_geonode.setStatusTip(label)\n        self.action_geonode.setWhatsThis(label)\n        self.action_geonode.triggered.connect(self.show_geonode_uploader)\n        self.add_action(self.action_geonode, add_to_toolbar=False)", "response": "Create action for Geonode uploader dialog."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate action for import OSM Dialog.", "response": "def _create_add_osm_layer_action(self):\n        \"\"\"Create action for import OSM Dialog.\"\"\"\n        icon = resources_path('img', 'icons', 'add-osm-tiles-layer.svg')\n        self.action_add_osm_layer = QAction(\n            QIcon(icon),\n            self.tr('Add OpenStreetMap Tile Layer'),\n            self.iface.mainWindow())\n        self.action_add_osm_layer.setStatusTip(self.tr(\n            'Add OpenStreetMap Tile Layer'))\n        self.action_add_osm_layer.setWhatsThis(self.tr(\n            'Use this to add an OSM layer to your map. '\n            'It needs internet access to function.'))\n        self.action_add_osm_layer.triggered.connect(self.add_osm_layer)\n        self.add_action(self.action_add_osm_layer, add_to_toolbar=True)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating action for showing definitions / help.", "response": "def _create_show_definitions_action(self):\n        \"\"\"Create action for showing definitions / help.\"\"\"\n        icon = resources_path('img', 'icons', 'show-inasafe-help.svg')\n        self.action_show_definitions = QAction(\n            QIcon(icon),\n            self.tr('InaSAFE Help'),\n            self.iface.mainWindow())\n        self.action_show_definitions.setStatusTip(self.tr(\n            'Show InaSAFE Help'))\n        self.action_show_definitions.setWhatsThis(self.tr(\n            'Use this to show a document describing all InaSAFE concepts.'))\n        self.action_show_definitions.triggered.connect(\n            self.show_definitions)\n        self.add_action(\n            self.action_show_definitions,\n            add_to_toolbar=True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate action for showing metadata converter dialog.", "response": "def _create_metadata_converter_action(self):\n        \"\"\"Create action for showing metadata converter dialog.\"\"\"\n        icon = resources_path('img', 'icons', 'show-metadata-converter.svg')\n        self.action_metadata_converter = QAction(\n            QIcon(icon),\n            self.tr('InaSAFE Metadata Converter'),\n            self.iface.mainWindow())\n        self.action_metadata_converter.setStatusTip(self.tr(\n            'Convert metadata from version 4.3 to version 3.5.'))\n        self.action_metadata_converter.setWhatsThis(self.tr(\n            'Use this tool to convert metadata 4.3 to version 3.5'))\n        self.action_metadata_converter.triggered.connect(\n            self.show_metadata_converter)\n        self.add_action(\n            self.action_metadata_converter, add_to_toolbar=self.full_toolbar)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate action for showing field mapping dialog.", "response": "def _create_field_mapping_action(self):\n        \"\"\"Create action for showing field mapping dialog.\"\"\"\n        icon = resources_path('img', 'icons', 'show-mapping-tool.svg')\n        self.action_field_mapping = QAction(\n            QIcon(icon),\n            self.tr('InaSAFE Field Mapping Tool'),\n            self.iface.mainWindow())\n        self.action_field_mapping.setStatusTip(self.tr(\n            'Assign field mapping to layer.'))\n        self.action_field_mapping.setWhatsThis(self.tr(\n            'Use this tool to assign field mapping in layer.'))\n        self.action_field_mapping.setEnabled(False)\n        self.action_field_mapping.triggered.connect(self.show_field_mapping)\n        self.add_action(\n            self.action_field_mapping, add_to_toolbar=self.full_toolbar)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _create_multi_exposure_action(self):\n        self.action_multi_exposure = QAction(\n            QIcon(resources_path('img', 'icons', 'show-multi-exposure.svg')),\n            self.tr('InaSAFE Multi Exposure Tool'),\n            self.iface.mainWindow())\n        self.action_multi_exposure.setStatusTip(self.tr(\n            'Open the multi exposure tool.'))\n        self.action_multi_exposure.setWhatsThis(self.tr(\n            'Open the multi exposure tool.'))\n        self.action_multi_exposure.setEnabled(True)\n        self.action_multi_exposure.triggered.connect(self.show_multi_exposure)\n        self.add_action(\n            self.action_multi_exposure, add_to_toolbar=self.full_toolbar)", "response": "Create action for showing the multi exposure tool."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate action for import OSM dialog.", "response": "def _create_add_petabencana_layer_action(self):\n        \"\"\"Create action for import OSM Dialog.\"\"\"\n        icon = resources_path('img', 'icons', 'add-petabencana-layer.svg')\n        self.action_add_petabencana_layer = QAction(\n            QIcon(icon),\n            self.tr('Add PetaBencana Flood Layer'),\n            self.iface.mainWindow())\n        self.action_add_petabencana_layer.setStatusTip(self.tr(\n            'Add PetaBencana Flood Layer'))\n        self.action_add_petabencana_layer.setWhatsThis(self.tr(\n            'Use this to add a PetaBencana layer to your map. '\n            'It needs internet access to function.'))\n        self.action_add_petabencana_layer.triggered.connect(\n            self.add_petabencana_layer)\n        self.add_action(\n            self.action_add_petabencana_layer,\n            add_to_toolbar=self.full_toolbar)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _create_rubber_bands_action(self):\n        icon = resources_path('img', 'icons', 'toggle-rubber-bands.svg')\n        self.action_toggle_rubberbands = QAction(\n            QIcon(icon),\n            self.tr('Toggle Scenario Outlines'), self.iface.mainWindow())\n        message = self.tr('Toggle rubber bands showing scenario extents.')\n        self.action_toggle_rubberbands.setStatusTip(message)\n        self.action_toggle_rubberbands.setWhatsThis(message)\n        # Set initial state\n        self.action_toggle_rubberbands.setCheckable(True)\n        flag = setting('showRubberBands', False, expected_type=bool)\n        self.action_toggle_rubberbands.setChecked(flag)\n        # noinspection PyUnresolvedReferences\n        self.action_toggle_rubberbands.triggered.connect(\n            self.dock_widget.toggle_rubber_bands)\n        self.add_action(self.action_toggle_rubberbands)", "response": "Create action for toggling rubber bands."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates action for analysis extent dialog.", "response": "def _create_analysis_extent_action(self):\n        \"\"\"Create action for analysis extent dialog.\"\"\"\n        icon = resources_path('img', 'icons', 'set-extents-tool.svg')\n        self.action_extent_selector = QAction(\n            QIcon(icon),\n            self.tr('Set Analysis Area'),\n            self.iface.mainWindow())\n        self.action_extent_selector.setStatusTip(self.tr(\n            'Set the analysis area for InaSAFE'))\n        self.action_extent_selector.setWhatsThis(self.tr(\n            'Set the analysis area for InaSAFE'))\n        self.action_extent_selector.triggered.connect(\n            self.show_extent_selector)\n        self.add_action(self.action_extent_selector)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _create_dock(self):\n        # Import dock here as it needs to be imported AFTER i18n is set up\n        from safe.gui.widgets.dock import Dock\n        self.dock_widget = Dock(self.iface)\n        self.dock_widget.setObjectName('InaSAFE-Dock')\n        self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dock_widget)\n        legend_tab = self.iface.mainWindow().findChild(QApplication, 'Legend')\n        if legend_tab:\n            self.iface.mainWindow().tabifyDockWidget(\n                legend_tab, self.dock_widget)\n            self.dock_widget.raise_()", "response": "Create dockwidget and tabify it with the legend."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef initGui(self):\n        self.toolbar = self.iface.addToolBar('InaSAFE')\n        self.toolbar.setObjectName('InaSAFEToolBar')\n        self.dock_widget = None\n        # Now create the actual dock\n        self._create_dock()\n        # And all the menu actions\n        # Configuration Group\n        self._create_dock_toggle_action()\n        self._create_options_dialog_action()\n        self._create_minimum_needs_options_action()\n        self._create_analysis_extent_action()\n        self._create_rubber_bands_action()\n        self._add_spacer_to_menu()\n        self._create_keywords_wizard_action()\n        self._create_analysis_wizard_action()\n        self._add_spacer_to_menu()\n        self._create_field_mapping_action()\n        self._create_multi_exposure_action()\n        self._create_metadata_converter_action()\n        self._create_osm_downloader_action()\n        self._create_add_osm_layer_action()\n        self._create_add_petabencana_layer_action()\n        self._create_geonode_uploader_action()\n        self._create_shakemap_converter_action()\n        self._create_minimum_needs_action()\n        self._create_multi_buffer_action()\n        self._create_test_layers_action()\n        self._create_run_test_action()\n        self._add_spacer_to_menu()\n        self._create_batch_runner_action()\n        self._create_save_scenario_action()\n        self._add_spacer_to_menu()\n        self._create_show_definitions_action()\n\n        # Hook up a slot for when the dock is hidden using its close button\n        # or  view-panels\n        #\n        self.dock_widget.visibilityChanged.connect(self.toggle_inasafe_action)\n        # Also deal with the fact that on start of QGIS dock may already be\n        # hidden.\n        self.action_dock.setChecked(self.dock_widget.isVisible())\n\n        self.iface.initializationCompleted.connect(\n            partial(self.show_welcome_message)\n        )", "response": "This method is called by QGIS to initialize the main GUI. It is called by QGIS to initialize the main GUI."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a spacer to the menu to separate action groups.", "response": "def _add_spacer_to_menu(self):\n        \"\"\"Create a spacer to the menu to separate action groups.\"\"\"\n        separator = QAction(self.iface.mainWindow())\n        separator.setSeparator(True)\n        self.iface.addPluginToMenu(self.tr('InaSAFE'), separator)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nunloading inasafe functions and try to return QGIS to before InaSAFE.", "response": "def clear_modules():\n        \"\"\"Unload inasafe functions and try to return QGIS to before InaSAFE.\n\n        .. todo:: I think this function can be removed. TS.\n        \"\"\"\n        # next lets force remove any inasafe related modules\n        modules = []\n        for module in sys.modules:\n            if 'inasafe' in module:\n                # Check if it is really one of our modules i.e. exists in the\n                # plugin directory\n                tokens = module.split('.')\n                path = ''\n                for myToken in tokens:\n                    path += os.path.sep + myToken\n                parent = os.path.abspath(os.path.join(\n                    __file__, os.path.pardir, os.path.pardir))\n                full_path = os.path.join(parent, path + '.py')\n                if os.path.exists(os.path.abspath(full_path)):\n                    LOGGER.debug('Removing: %s' % module)\n                    modules.append(module)\n        for module in modules:\n            del (sys.modules[module])\n        for module in sys.modules:\n            if 'inasafe' in module:\n                print(module)\n\n        # Lets also clean up all the path additions that were made\n        package_path = os.path.abspath(os.path.join(\n            os.path.dirname(__file__), os.path.pardir))\n        LOGGER.debug('Path to remove: %s' % package_path)\n        # We use a list comprehension to ensure duplicate entries are removed\n        LOGGER.debug(sys.path)\n        sys.path = [y for y in sys.path if package_path not in y]\n        LOGGER.debug(sys.path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nunload the current graphical user interface elements from the GUI.", "response": "def unload(self):\n        \"\"\"GUI breakdown procedure (for QGIS plugin api).\n\n        .. note:: Don't change the name of this method from unload!\n\n        This method is called by QGIS and should be used to *remove*\n        any graphical user interface elements that should appear in QGIS.\n        \"\"\"\n        # Remove the plugin menu item and icon\n        if self.wizard:\n            self.wizard.deleteLater()\n        for myAction in self.actions:\n            self.iface.removePluginMenu(self.tr('InaSAFE'), myAction)\n            self.iface.removeToolBarIcon(myAction)\n            self.iface.removeCustomActionForLayerType(myAction)\n        self.iface.mainWindow().removeDockWidget(self.dock_widget)\n        self.iface.mainWindow().removeToolBar(self.toolbar)\n        self.dock_widget.setVisible(False)\n        self.dock_widget.destroy()\n        self.iface.currentLayerChanged.disconnect(self.layer_changed)\n\n        # Unload QGIS expressions loaded by the plugin.\n        for qgis_expression in list(qgis_expressions().keys()):\n            QgsExpression.unregisterFunction(qgis_expression)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef toggle_dock_visibility(self):\n        if self.dock_widget.isVisible():\n            self.dock_widget.setVisible(False)\n        else:\n            self.dock_widget.setVisible(True)\n            self.dock_widget.raise_()", "response": "Show or hide the dock widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_extent_selector(self):\n        # import here only so that it is AFTER i18n set up\n        from safe.gui.tools.extent_selector_dialog import ExtentSelectorDialog\n        widget = ExtentSelectorDialog(\n            self.iface,\n            self.iface.mainWindow(),\n            extent=self.dock_widget.extent.user_extent,\n            crs=self.dock_widget.extent.crs)\n        widget.clear_extent.connect(\n            self.dock_widget.extent.clear_user_analysis_extent)\n        widget.extent_defined.connect(\n            self.dock_widget.define_user_analysis_extent)\n        # This ensures that run button state is updated on dialog close\n        widget.extent_selector_closed.connect(\n            self.dock_widget.validate_impact_function)\n        # Needs to be non modal to support hide -> interact with map -> show\n        widget.show()", "response": "Show the extent selector widget for defining analysis extents."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nshowing the minimum needs dialog.", "response": "def show_minimum_needs(self):\n        \"\"\"Show the minimum needs dialog.\"\"\"\n        # import here only so that it is AFTER i18n set up\n        from safe.gui.tools.minimum_needs.needs_calculator_dialog import (\n            NeedsCalculatorDialog\n        )\n\n        dialog = NeedsCalculatorDialog(self.iface.mainWindow())\n        dialog.exec_()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_minimum_needs_configuration(self):\n        # import here only so that it is AFTER i18n set up\n        from safe.gui.tools.minimum_needs.needs_manager_dialog import (\n            NeedsManagerDialog)\n\n        dialog = NeedsManagerDialog(\n            parent=self.iface.mainWindow(),\n            dock=self.dock_widget)\n        dialog.exec_()", "response": "Show the minimum needs configuration dialog."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_options(self):\n        # import here only so that it is AFTER i18n set up\n        from safe.gui.tools.options_dialog import OptionsDialog\n\n        dialog = OptionsDialog(\n            iface=self.iface,\n            parent=self.iface.mainWindow())\n        dialog.show_option_dialog()\n        if dialog.exec_():  # modal\n            self.dock_widget.read_settings()\n            from safe.gui.widgets.message import getting_started_message\n            send_static_message(self.dock_widget, getting_started_message())\n            # Issue #4734, make sure to update the combobox after update the\n            # InaSAFE option\n            self.dock_widget.get_layers()", "response": "Show the options dialog."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_welcome_message(self):\n        # import here only so that it is AFTER i18n set up\n        from safe.gui.tools.options_dialog import OptionsDialog\n\n        # Do not show by default\n        show_message = False\n\n        previous_version = StrictVersion(setting('previous_version'))\n        current_version = StrictVersion(inasafe_version)\n\n        # Set previous_version to the current inasafe_version\n        set_setting('previous_version', inasafe_version)\n\n        if setting('always_show_welcome_message', expected_type=bool):\n            # Show if it the setting said so\n            show_message = True\n        elif previous_version < current_version:\n            # Always show if the user installed new version\n            show_message = True\n\n        # Allow to disable welcome message when running automated tests\n        if os.environ.get('INASAFE_DISABLE_WELCOME_MESSAGE', False):\n            show_message = False\n\n        if show_message:\n            dialog = OptionsDialog(\n                iface=self.iface,\n                parent=self.iface.mainWindow())\n            dialog.show_welcome_dialog()\n            if dialog.exec_():  # modal\n                self.dock_widget.read_settings()", "response": "Show the welcome message."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_keywords_wizard(self):\n        # import here only so that it is AFTER i18n set up\n        from safe.gui.tools.wizard.wizard_dialog import WizardDialog\n\n        if self.iface.activeLayer() is None:\n            return\n\n        # Don't break an existing wizard session if accidentally clicked\n        if self.wizard and self.wizard.isVisible():\n            return\n\n        # Prevent spawning multiple copies since the IFCW is non modal\n        if not self.wizard:\n            self.wizard = WizardDialog(\n                self.iface.mainWindow(),\n                self.iface,\n                self.dock_widget)\n        self.wizard.set_keywords_creation_mode()\n        self.wizard.exec_()", "response": "Show the keywords creation wizard."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show_function_centric_wizard(self):\n        # import here only so that it is AFTER i18n set up\n        from safe.gui.tools.wizard.wizard_dialog import WizardDialog\n\n        # Don't break an existing wizard session if accidentally clicked\n        if self.wizard and self.wizard.isVisible():\n            return\n\n        # Prevent spawning multiple copies since it is non modal\n        if not self.wizard:\n            self.wizard = WizardDialog(\n                self.iface.mainWindow(),\n                self.iface,\n                self.dock_widget)\n        self.wizard.set_function_centric_mode()\n        # non-modal in order to hide for selecting user extent\n        self.wizard.show()", "response": "Show the function centric wizard."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_shakemap_importer(self):\n        # import here only so that it is AFTER i18n set up\n        from safe.gui.tools.shake_grid.shakemap_converter_dialog import (\n            ShakemapConverterDialog)\n\n        dialog = ShakemapConverterDialog(\n            self.iface.mainWindow(), self.iface, self.dock_widget)\n        dialog.exec_()", "response": "Show the converter dialog."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nshows the multi buffer tool.", "response": "def show_multi_buffer(self):\n        \"\"\"Show the multi buffer tool.\"\"\"\n        from safe.gui.tools.multi_buffer_dialog import (\n            MultiBufferDialog)\n\n        dialog = MultiBufferDialog(\n            self.iface.mainWindow(), self.iface, self.dock_widget)\n        dialog.exec_()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_osm_downloader(self):\n        from safe.gui.tools.osm_downloader_dialog import OsmDownloaderDialog\n\n        dialog = OsmDownloaderDialog(self.iface.mainWindow(), self.iface)\n        # otherwise dialog is never deleted\n        dialog.setAttribute(Qt.WA_DeleteOnClose, True)\n        dialog.show()", "response": "Show the OSM buildings downloader dialog."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nshow the Geonode uploader dialog.", "response": "def show_geonode_uploader(self):\n        \"\"\"Show the Geonode uploader dialog.\"\"\"\n        from safe.gui.tools.geonode_uploader import GeonodeUploaderDialog\n\n        dialog = GeonodeUploaderDialog(self.iface.mainWindow())\n        dialog.show()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd OSM tile layer to the map.", "response": "def add_osm_layer(self):\n        \"\"\"Add OSM tile layer to the map.\n\n        This uses a gdal wrapper around the OSM tile service - see the\n        WorldOSM.gdal file for how it is constructed.\n        \"\"\"\n        path = resources_path('osm', 'WorldOSM.gdal')\n        layer = QgsRasterLayer(path, self.tr('OpenStreetMap'))\n        project = QgsProject.instance()\n\n        # Try to add it as the last layer in the list\n        # False flag prevents layer being added to legend\n        project.addMapLayer(layer, False)\n        root = QgsProject.instance().layerTreeRoot()\n        index = len(root.findLayers()) + 1\n        # LOGGER.info('Inserting layer %s at position %s' % (\n        #    layer.source(), index))\n        root.insertLayer(index, layer)\n        project.addMapLayer(layer)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nshowing InaSAFE Definitions ( a report showing all key metadata.", "response": "def show_definitions(self):\n        \"\"\"Show InaSAFE Definitions (a report showing all key metadata).\"\"\"\n        from safe.utilities.help import show_help\n        from safe.gui.tools.help import definitions_help\n        show_help(definitions_help.definitions_help())"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshows InaSAFE Field Mapping.", "response": "def show_field_mapping(self):\n        \"\"\"Show InaSAFE Field Mapping.\"\"\"\n        from safe.gui.tools.field_mapping_dialog import FieldMappingDialog\n        dialog = FieldMappingDialog(\n            parent=self.iface.mainWindow(),\n            iface=self.iface,)\n        if dialog.exec_():  # modal\n            LOGGER.debug('Show field mapping accepted')\n            self.dock_widget.layer_changed(self.iface.activeLayer())\n        else:\n            LOGGER.debug('Show field mapping not accepted')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_metadata_converter(self):\n        from safe.gui.tools.metadata_converter_dialog import (\n            MetadataConverterDialog)\n        dialog = MetadataConverterDialog(\n            parent=self.iface.mainWindow(),\n            iface=self.iface,\n        )\n        dialog.exec_()", "response": "Show InaSAFE Metadata Converter."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nshowing InaSAFE Multi Exposure.", "response": "def show_multi_exposure(self):\n        \"\"\"Show InaSAFE Multi Exposure.\"\"\"\n        from safe.gui.tools.multi_exposure_dialog import MultiExposureDialog\n        dialog = MultiExposureDialog(\n            self.iface.mainWindow(), self.iface)\n        dialog.exec_()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_petabencana_layer(self):\n        from safe.gui.tools.peta_bencana_dialog import PetaBencanaDialog\n        dialog = PetaBencanaDialog(self.iface.mainWindow(), self.iface)\n        dialog.show()", "response": "Add a petabencana layer to the map."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nshow the batch runner dialog.", "response": "def show_batch_runner(self):\n        \"\"\"Show the batch runner dialog.\"\"\"\n        from safe.gui.tools.batch.batch_dialog import BatchDialog\n\n        dialog = BatchDialog(\n            parent=self.iface.mainWindow(),\n            iface=self.iface,\n            dock=self.dock_widget)\n        dialog.exec_()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save_scenario(self):\n        from safe.gui.tools.save_scenario import SaveScenarioDialog\n\n        dialog = SaveScenarioDialog(\n            iface=self.iface,\n            dock=self.dock_widget)\n        dialog.save_scenario()", "response": "Save current scenario to text file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nenabling or disable keywords editor icon when active layer changes.", "response": "def layer_changed(self, layer):\n        \"\"\"Enable or disable keywords editor icon when active layer changes.\n\n        :param layer: The layer that is now active.\n        :type layer: QgsMapLayer\n        \"\"\"\n        if not layer:\n            enable_keyword_wizard = False\n        elif not hasattr(layer, 'providerType'):\n            enable_keyword_wizard = False\n        elif layer.providerType() == 'wms':\n            enable_keyword_wizard = False\n        else:\n            enable_keyword_wizard = True\n\n        try:\n            if layer:\n                if is_raster_layer(layer):\n                    enable_field_mapping_tool = False\n                else:\n                    keywords = KeywordIO().read_keywords(layer)\n                    keywords_version = keywords.get('keyword_version')\n                    if not keywords_version:\n                        supported = False\n                    else:\n                        supported = (\n                            is_keyword_version_supported(keywords_version))\n                    if not supported:\n                        enable_field_mapping_tool = False\n                    else:\n                        layer_purpose = keywords.get('layer_purpose')\n\n                        if not layer_purpose:\n                            enable_field_mapping_tool = False\n                        else:\n                            if layer_purpose == layer_purpose_exposure['key']:\n                                layer_subcategory = keywords.get('exposure')\n                            elif layer_purpose == layer_purpose_hazard['key']:\n                                layer_subcategory = keywords.get('hazard')\n                            else:\n                                layer_subcategory = None\n                            field_groups = get_field_groups(\n                                layer_purpose, layer_subcategory)\n                            if len(field_groups) == 0:\n                                # No field group, disable field mapping tool.\n                                enable_field_mapping_tool = False\n                            else:\n                                enable_field_mapping_tool = True\n            else:\n                enable_field_mapping_tool = False\n        except (KeywordNotFoundError, NoKeywordsFoundError, MetadataReadError):\n            # No keywords, disable field mapping tool.\n            enable_field_mapping_tool = False\n\n        self.action_keywords_wizard.setEnabled(enable_keyword_wizard)\n        self.action_field_mapping.setEnabled(enable_field_mapping_tool)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef multi_buffering(layer, radii, callback=None):\n    # Layer output\n    output_layer_name = buffer_steps['output_layer_name']\n    processing_step = buffer_steps['step_name']\n\n    input_crs = layer.crs()\n    feature_count = layer.featureCount()\n\n    fields = layer.fields()\n    # Set the new hazard class field.\n    new_field = create_field_from_definition(hazard_class_field)\n    fields.append(new_field)\n    # Set the new buffer distances field.\n    new_field = create_field_from_definition(buffer_distance_field)\n    fields.append(new_field)\n\n    buffered = create_memory_layer(\n        output_layer_name, QgsWkbTypes.PolygonGeometry, input_crs, fields)\n    buffered.startEditing()\n\n    # Reproject features if needed into UTM if the layer is in 4326.\n    if layer.crs().authid() == 'EPSG:4326':\n        center = layer.extent().center()\n        utm = QgsCoordinateReferenceSystem(\n            get_utm_epsg(center.x(), center.y(), input_crs))\n        transform = QgsCoordinateTransform(\n            layer.crs(), utm, QgsProject.instance())\n        reverse_transform = QgsCoordinateTransform(\n            utm, layer.crs(), QgsProject.instance())\n    else:\n        transform = None\n        reverse_transform = None\n\n    for i, feature in enumerate(layer.getFeatures()):\n        geom = QgsGeometry(feature.geometry())\n\n        if transform:\n            geom.transform(transform)\n\n        inner_ring = None\n\n        for radius in radii:\n            attributes = feature.attributes()\n\n            # We add the hazard value name to the attribute table.\n            attributes.append(radii[radius])\n            # We add the value of buffer distance to the attribute table.\n            attributes.append(radius)\n\n            circle = geom.buffer(radius, 30)\n\n            if inner_ring:\n                circle.addRing(inner_ring)\n\n            inner_ring = circle.asPolygon()[0]\n\n            new_feature = QgsFeature()\n            if reverse_transform:\n                circle.transform(reverse_transform)\n\n            new_feature.setGeometry(circle)\n            new_feature.setAttributes(attributes)\n\n            buffered.addFeature(new_feature)\n\n        if callback:\n            callback(current=i, maximum=feature_count, step=processing_step)\n\n    buffered.commitChanges()\n\n    # We transfer keywords to the output.\n    buffered.keywords = layer.keywords\n    buffered.keywords['layer_geometry'] = 'polygon'\n    buffered.keywords['layer_purpose'] = layer_purpose_hazard['key']\n    buffered.keywords['inasafe_fields'][hazard_class_field['key']] = (\n        hazard_class_field['field_name'])\n\n    check_layer(buffered)\n    return buffered", "response": "Buffer a vector layer using many buffers."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_layer(self, layer, keywords=None):\n        self.layer = layer\n        if keywords is not None:\n            self.metadata = keywords\n        else:\n            self.metadata = self.keyword_io.read_keywords(self.layer)\n        self.populate_tabs()", "response": "Set the layer and update UI accordingly."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef populate_tabs(self):\n        self.delete_tabs()\n        layer_purpose = self.metadata.get('layer_purpose')\n        if not layer_purpose:\n            message = tr(\n                'Key layer_purpose is not found in the layer {layer_name}'\n            ).format(layer_name=self.layer.name())\n            raise KeywordNotFoundError(message)\n        if layer_purpose == layer_purpose_exposure['key']:\n            layer_subcategory = self.metadata.get('exposure')\n        elif layer_purpose == layer_purpose_hazard['key']:\n            layer_subcategory = self.metadata.get('hazard')\n        else:\n            layer_subcategory = None\n\n        field_groups = get_field_groups(layer_purpose, layer_subcategory)\n        for field_group in field_groups:\n            tab = FieldMappingTab(field_group, self, self.iface)\n            tab.set_layer(self.layer, self.metadata)\n            self.addTab(tab, field_group['name'])\n            self.tabs.append(tab)", "response": "Populate tabs based on layer metadata."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_field_mapping(self):\n        fields = {}\n        values = {}\n        for tab in self.tabs:\n            parameter_values = tab.get_parameter_value()\n            fields.update(parameter_values['fields'])\n            values.update(parameter_values['values'])\n        return {\n            'fields': fields,\n            'values': values\n        }", "response": "Obtain metadata from current state of the widget."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef evaluate_formula(formula, variables):\n    for key, value in list(variables.items()):\n        if value is None or (hasattr(value, 'isNull') and value.isNull()):\n            # If one value is null, we return null.\n            return value\n        formula = formula.replace(key, str(value))\n    result = eval(formula)\n    return result", "response": "Evaluate a simple formula."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns a single post processor on the vector layer.", "response": "def run_single_post_processor(layer, post_processor):\n    \"\"\"Run single post processor.\n\n    If the layer has the output field, it will pass the post\n    processor calculation.\n\n    :param layer: The vector layer to use for post processing.\n    :type layer: QgsVectorLayer\n\n    :param post_processor: A post processor definition.\n    :type post_processor: dict\n\n    :returns: Tuple with True if success, else False with an error message.\n    :rtype: (bool, str)\n    \"\"\"\n    if not layer.editBuffer():\n\n        # Turn on the editing mode.\n        if not layer.startEditing():\n            msg = tr('The impact layer could not start the editing mode.')\n            return False, msg\n\n    # Calculate based on formula\n    # Iterate all possible output and create the correct field.\n    for output_key, output_value in list(post_processor['output'].items()):\n\n        # Get output attribute name\n        key = output_value['value']['key']\n        output_field_name = output_value['value']['field_name']\n        layer.keywords['inasafe_fields'][key] = output_field_name\n\n        # If there is already the output field, don't proceed\n        if layer.fields().lookupField(output_field_name) > -1:\n            msg = tr(\n                'The field name %s already exists.'\n                % output_field_name)\n            layer.rollBack()\n            return False, msg\n\n        # Add output attribute name to the layer\n        field = create_field_from_definition(output_value['value'])\n        result = layer.addAttribute(field)\n        if not result:\n            msg = tr(\n                'Error while creating the field %s.'\n                % output_field_name)\n            layer.rollBack()\n            return False, msg\n\n        # Get the index of output attribute\n        output_field_index = layer.fields().lookupField(output_field_name)\n\n        if layer.fields().lookupField(output_field_name) == -1:\n            msg = tr(\n                'The field name %s has not been created.'\n                % output_field_name)\n            layer.rollBack()\n            return False, msg\n\n        # Get the input field's indexes for input\n        input_indexes = {}\n\n        input_properties = {}\n\n        # Default parameters\n        default_parameters = {}\n\n        msg = None\n\n        # Iterate over every inputs.\n        for key, values in list(post_processor['input'].items()):\n            values = values if isinstance(values, list) else [values]\n            for value in values:\n                is_constant_input = (\n                    value['type'] == constant_input_type)\n                is_field_input = (\n                    value['type'] == field_input_type\n                    or value['type'] == dynamic_field_input_type)\n                is_geometry_input = (\n                    value['type'] == geometry_property_input_type)\n                is_keyword_input = (\n                    value['type'] == keyword_input_type)\n                is_needs_input = (\n                    value['type'] == needs_profile_input_type)\n                is_layer_property_input = (\n                    value['type'] == layer_property_input_type)\n                if value['type'] == keyword_value_expected:\n                    break\n                if is_constant_input:\n                    default_parameters[key] = value['value']\n                    break\n                elif is_field_input:\n                    if value['type'] == dynamic_field_input_type:\n                        key_template = value['value']['key']\n                        field_param = value['field_param']\n                        field_key = key_template % field_param\n                    else:\n                        field_key = value['value']['key']\n\n                    inasafe_fields = layer.keywords['inasafe_fields']\n                    name_field = inasafe_fields.get(field_key)\n\n                    if not name_field:\n                        msg = tr(\n                            '%s has not been found in inasafe fields.'\n                            % value['value']['key'])\n                        continue\n\n                    index = layer.fields().lookupField(name_field)\n\n                    if index == -1:\n                        fields = layer.fields().toList()\n                        msg = tr(\n                            'The field name %s has not been found in %s'\n                            % (\n                                name_field,\n                                [f.name() for f in fields]\n                            ))\n                        continue\n\n                    input_indexes[key] = index\n                    break\n\n                # For geometry, create new field that contain the value\n                elif is_geometry_input:\n                    input_properties[key] = geometry_property_input_type['key']\n                    break\n\n                # for keyword\n                elif is_keyword_input:\n                    # See http://stackoverflow.com/questions/14692690/\n                    # access-python-nested-dictionary-items-via-a-list-of-keys\n                    value = reduce(\n                        lambda d, k: d[k], value['value'], layer.keywords)\n\n                    default_parameters[key] = value\n                    break\n\n                # for needs profile\n                elif is_needs_input:\n                    need_parameter = minimum_needs_parameter(\n                        parameter_name=value['value'])\n                    value = need_parameter.value\n\n                    default_parameters[key] = value\n                    break\n\n                # for layer property\n                elif is_layer_property_input:\n                    if value['value'] == layer_crs_input_value:\n                        default_parameters[key] = layer.crs()\n\n                    if value['value'] == size_calculator_input_value:\n                        exposure = layer.keywords.get('exposure')\n                        if not exposure:\n                            keywords = layer.keywords.get('exposure_keywords')\n                            exposure = keywords.get('exposure')\n\n                        default_parameters[key] = SizeCalculator(\n                            layer.crs(), layer.geometryType(), exposure)\n                    break\n\n            else:\n                # executed when we can't find all the inputs\n                layer.rollBack()\n                return False, msg\n\n        # Create iterator for feature\n        request = QgsFeatureRequest().setSubsetOfAttributes(\n            list(input_indexes.values()))\n        iterator = layer.getFeatures(request)\n\n        inputs = input_indexes.copy()\n        inputs.update(input_properties)\n\n        # Iterate all feature\n        for feature in iterator:\n            attributes = feature.attributes()\n\n            # Create dictionary to store the input\n            parameters = {}\n            parameters.update(default_parameters)\n\n            # Fill up the input from fields\n            for key, value in list(inputs.items()):\n                if value == geometry_property_input_type['key']:\n                    parameters[key] = feature.geometry()\n                else:\n                    parameters[key] = attributes[value]\n            # Fill up the input from geometry property\n\n            # Evaluate the function\n            python_function = output_value.get('function')\n            if python_function:\n                # Launch the python function\n                post_processor_result = python_function(**parameters)\n            else:\n                # Evaluate the function\n                formula = output_value['formula']\n                post_processor_result = evaluate_formula(\n                    formula, parameters)\n\n            # The affected postprocessor returns a boolean.\n            if isinstance(post_processor_result, bool):\n                post_processor_result = tr(str(post_processor_result))\n\n            layer.changeAttributeValue(\n                feature.id(),\n                output_field_index,\n                post_processor_result\n            )\n\n    layer.commitChanges()\n    return True, None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if the postprocessor should run for the current hazard and exposure.", "response": "def should_run(keywords, post_processor):\n    \"\"\"\n    Check if the postprocessor should run for the current hazard and exposure\n    :param keywords: impact layer keywords\n    :type keywords: dict\n    :param post_processor: the post processor instance to check\n    :type post_processor: dict\n    :returns: Tuple with True if success, else False with an error message.\n    :rtype: (bool, str)\n    \"\"\"\n    exposure = keywords['exposure_keywords']['exposure']\n    hazard = keywords['hazard_keywords']['hazard']\n    try:\n        run_filter = post_processor['run_filter']\n    except KeyError:\n        # if no run_filter is defined we run the postprocessor\n        return True, None\n\n    msg = tr('Postprocessor \"{name}\" did not run because hazard \"{hazard}\" '\n             'and exposure \"{exposure}\" are not in its run_filter '\n             '\"{run_filter}\"'.format(\n                name=post_processor['name'],\n                hazard=hazard,\n                exposure=exposure,\n                run_filter=run_filter))\n\n    # if an hazard filter is defined the current hazard needs to be defined in\n    # there\n    if 'hazard' in run_filter and hazard not in run_filter['hazard']:\n        return False, msg\n\n    # if an exposure filter is defined the current exposure needs to be\n    # defined in there\n    if 'exposure' in run_filter and exposure not in run_filter['exposure']:\n        return False, msg\n\n    return True, None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef enough_input(layer, post_processor_input):\n    impact_fields = list(layer.keywords['inasafe_fields'].keys())\n    for input_key, input_values in list(post_processor_input.items()):\n        input_values = (\n            input_values if isinstance(input_values, list) else [input_values])\n        msg = None\n        for input_value in input_values:\n            is_constant_input = input_value['type'] == constant_input_type\n            is_field_input = input_value['type'] == field_input_type\n            is_dynamic_input = input_value['type'] == dynamic_field_input_type\n            is_needs_input = input_value['type'] == needs_profile_input_type\n            is_keyword_input = input_value['type'] == keyword_input_type\n            is_layer_input = input_value['type'] == layer_property_input_type\n            is_keyword_value = input_value['type'] == keyword_value_expected\n            is_geometry_input = (\n                input_value['type'] == geometry_property_input_type)\n            if is_constant_input:\n                # constant input doesn't need any check\n                break\n            elif is_field_input:\n                key = input_value['value']['key']\n                if key in impact_fields:\n                    break\n                else:\n                    msg = 'Key %s is missing in fields %s' % (\n                        key, impact_fields)\n            elif is_dynamic_input:\n                key_template = input_value['value']['key']\n                field_param = input_value['field_param']\n                key = key_template % field_param\n                if key in impact_fields:\n                    break\n                else:\n                    msg = 'Key %s is missing in dynamic fields %s' % (\n                        key, impact_fields)\n            elif is_needs_input:\n                parameter_name = input_value['value']\n                if minimum_needs_parameter(parameter_name=parameter_name):\n                    break\n                else:\n                    msg = (\n                        'Minimum needs %s is missing from current '\n                        'profile') % (\n                            parameter_name, )\n            elif is_keyword_input:\n                try:\n                    reduce(\n                        lambda d, k:\n                        d[k], input_value['value'], layer.keywords)\n                    break\n                except KeyError:\n                    msg = 'Value %s is missing in keyword: %s' % (\n                        input_key, input_value['value'])\n            elif is_layer_input or is_geometry_input:\n                # will be taken from the layer itself, so always true\n                break\n            elif is_keyword_value:\n                try:\n                    value = reduce(\n                        lambda d, k:\n                        d[k], input_value[\n                            'value'], layer.keywords)\n                    if value == input_value['expected_value']:\n                        break\n                    else:\n                        msg = 'Value %s is not expected in keyword: %s' % (\n                            input_value['expected_value'],\n                            input_value['value'])\n                except KeyError:\n                    msg = 'Value %s is missing in keyword: %s' % (\n                        input_key, input_value['value'])\n\n        else:\n            return False, msg\n    return True, None", "response": "Check if the input from impact_fields in enough is in the vector layer."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the value of key to value.", "response": "def set_value_for_key(self, key, value):\n        \"\"\"Set the value of key to value.\n\n        :param key: The key.\n        :type key: str\n\n        :param value: The value to be assigned.\n        :type value: list, float, int\n        \"\"\"\n        if key in self.options:\n            self.options[key]['value'] = value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind the proper step when user clicks the Next button.", "response": "def get_next_step(self):\n        \"\"\"Find the proper step when user clicks the Next button.\n\n        :returns: The step to be switched to.\n        :rtype: WizardStep instance or None\n        \"\"\"\n        subcategory = self.parent.step_kw_subcategory.selected_subcategory()\n        is_raster = is_raster_layer(self.parent.layer)\n        has_classifications = get_classifications(subcategory['key'])\n\n        # Vector\n        if not is_raster:\n            return self.parent.step_kw_field\n        # Raster and has classifications\n        elif has_classifications:\n            return self.parent.step_kw_multi_classifications\n        # else go to source\n        return self.parent.step_kw_source"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef on_lstUnits_itemSelectionChanged(self):\n        self.clear_further_steps()\n        # Set widgets\n        unit = self.selected_unit()\n        # Exit if no selection\n        if not unit:\n            return\n        self.lblDescribeUnit.setText(unit['description'])\n        # Enable the next button\n        self.parent.pbnNext.setEnabled(True)", "response": "Update label and field widgets."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef selected_unit(self):\n        item = self.lstUnits.currentItem()\n        try:\n            return definition(item.data(QtCore.Qt.UserRole))\n        except (AttributeError, NameError):\n            return None", "response": "Obtain the metadata of the selected unit."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets widgets on the Unit tab.", "response": "def set_widgets(self):\n        \"\"\"Set widgets on the Unit tab.\"\"\"\n        self.clear_further_steps()\n        # Set widgets\n        purpose = self.parent.step_kw_purpose.selected_purpose()\n        subcategory = self.parent.step_kw_subcategory.selected_subcategory()\n        self.lblSelectUnit.setText(\n            unit_question % (subcategory['name'], purpose['name']))\n        self.lblDescribeUnit.setText('')\n        self.lstUnits.clear()\n        subcat = self.parent.step_kw_subcategory.selected_subcategory()['key']\n        if purpose == layer_purpose_hazard:\n            units_for_layer = hazard_units(subcat)\n        else:\n            units_for_layer = exposure_units(subcat)\n        for unit_for_layer in units_for_layer:\n            item = QListWidgetItem(unit_for_layer['name'], self.lstUnits)\n            item.setData(QtCore.Qt.UserRole, unit_for_layer['key'])\n            self.lstUnits.addItem(item)\n\n        # Set values based on existing keywords (if already assigned)\n        if self.parent.step_kw_purpose.\\\n                selected_purpose() == layer_purpose_hazard:\n            key = continuous_hazard_unit['key']\n        else:\n            key = exposure_unit['key']\n        unit_id = self.parent.get_existing_keyword(key)\n        if unit_id:\n            units = []\n            for index in range(self.lstUnits.count()):\n                item = self.lstUnits.item(index)\n                units.append(item.data(QtCore.Qt.UserRole))\n            if unit_id in units:\n                self.lstUnits.setCurrentRow(units.index(unit_id))\n\n        self.auto_select_one_item(self.lstUnits)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget an analysis directory from a QGIS multi exposure analysis.", "response": "def get_analysis_dir(exposure_key=None):\n    \"\"\"Retrieve an output directory of an analysis/ImpactFunction from a\n    multi exposure analysis/ImpactFunction based on exposure type.\n\n    :param exposure_key: An exposure keyword.\n    :type exposure_key: str\n\n    :return: A directory contains analysis outputs.\n    :rtype: str\n    \"\"\"\n    keyword_io = KeywordIO()\n    layer_tree_root = QgsProject.instance().layerTreeRoot()\n    all_groups = [\n        child for child in layer_tree_root.children() if (\n            isinstance(child, QgsLayerTreeGroup))]\n    multi_exposure_group = None\n    for group in all_groups:\n        if group.customProperty(MULTI_EXPOSURE_ANALYSIS_FLAG):\n            multi_exposure_group = group\n            break\n\n    if multi_exposure_group:\n        multi_exposure_tree_layers = [\n            child for child in multi_exposure_group.children() if (\n                isinstance(child, QgsLayerTreeLayer))]\n        exposure_groups = [\n            child for child in multi_exposure_group.children() if (\n                isinstance(child, QgsLayerTreeGroup))]\n\n        def get_report_ready_layer(tree_layers):\n            \"\"\"Get a layer which has a report inn its directory.\n\n            :param tree_layers: A list of tree layer nodes (QgsLayerTreeLayer)\n            :type tree_layers: list\n\n            :return: A vector layer\n            :rtype: QgsMapLayer\n            \"\"\"\n            for tree_layer in tree_layers:\n                layer = tree_layer.layer()\n                keywords = keyword_io.read_keywords(layer)\n                extra_keywords_found = keywords.get('extra_keywords')\n                provenance = keywords.get('provenance_data')\n                if provenance:\n                    exposure_keywords = provenance.get('exposure_keywords', {})\n                    exposure_key_found = exposure_keywords.get('exposure')\n                    if exposure_key_found and (\n                            exposure_key == exposure_key_found):\n                        return layer\n                if not exposure_key and extra_keywords_found and (\n                        extra_keywords_found[\n                            extra_keyword_analysis_type['key']] == (\n                                MULTI_EXPOSURE_ANALYSIS_FLAG)):\n                    return layer\n            return None\n\n        layer = get_report_ready_layer(multi_exposure_tree_layers)\n\n        if not layer:\n            for exposure_group in exposure_groups:\n                tree_layers = [\n                    child for child in exposure_group.children() if (\n                        isinstance(child, QgsLayerTreeLayer))]\n                layer = get_report_ready_layer(tree_layers)\n                if layer:\n                    break\n\n        if layer:\n            return dirname(layer.source())\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve an HTML string of the impact report.", "response": "def get_impact_report_as_string(analysis_dir):\n    \"\"\"Retrieve an html string of table report (impact-report-output.html).\n\n    :param analysis_dir: Directory of where the report located.\n    :type analysis_dir: str\n\n    :return: HTML string of the report.\n    :rtype: str\n    \"\"\"\n    html_report_products = [\n        'impact-report-output.html',\n        'multi-exposure-impact-report-output.html']\n    output_dir_path = join(analysis_dir, 'output')\n\n    for html_report_product in html_report_products:\n        table_report_path = join(output_dir_path, html_report_product)\n        if exists(table_report_path):\n            break\n        table_report_path = None\n\n    if not table_report_path:\n        return None\n\n    # We can display an impact report.\n    # We need to open the file in UTF-8, the HTML may have some accents\n    with open(table_report_path, 'r', encoding='utf-8') as table_report_file:\n        report = table_report_file.read()\n        return report"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_report_section(\n        html_report, component_id, container_wrapper_format=container_format):\n    \"\"\"Get specific report section from InaSAFE analysis summary report.\n\n    :param html_report: The html report.\n    :type html_report: basestring\n\n    :param component_id: The component key.\n    :type component_id: str\n\n    :param container_wrapper_format: A string format for wrapping the section.\n    :type container_wrapper_format: basestring\n\n    :return: Requested report section as an html.\n    :rtype: basestring\n    \"\"\"\n    no_element_error = tr('No element match the tag or component id.')\n\n    root_element, dict_of_elements = ET.XMLID(html_report)\n    section_element = dict_of_elements.get(component_id)\n\n    if section_element:\n        requested_section = container_wrapper_format.format(\n            section_content=str(ET.tostring(section_element)))\n        return requested_section\n    else:\n        return no_element_error", "response": "Get specific report section from InaSAFE analysis summary report."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef default_inasafe_html_resources(feature, parent):\n    _ = feature, parent  # NOQA\n    project_context_scope = QgsExpressionContextUtils.projectScope()\n    key = provenance_layer_analysis_impacted['provenance_key']\n    if not project_context_scope.hasVariable(key):\n        return None\n\n    analysis_dir = dirname(project_context_scope.variable(key))\n    complete_html_report = get_impact_report_as_string(analysis_dir)\n\n    requested_html_report = get_report_section(\n        complete_html_report,\n        component_id='inasafe-html-resources',\n        container_wrapper_format=u'{section_content}')\n\n    return requested_html_report", "response": "Retrieve default InaSAFE HTML resources."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving an HTML table report of current selected analysis.", "response": "def analysis_summary_report(feature, parent):\n    \"\"\"Retrieve an HTML table report of current selected analysis.\n    \"\"\"\n    _ = feature, parent  # NOQA\n    project_context_scope = QgsExpressionContextUtils.projectScope(\n        QgsProject.instance())\n    key = provenance_layer_analysis_impacted['provenance_key']\n    if not project_context_scope.hasVariable(key):\n        return None\n\n    analysis_dir = dirname(project_context_scope.variable(key))\n    return get_impact_report_as_string(analysis_dir)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef analysis_question_report(feature, parent):\n    _ = feature, parent  # NOQA\n    project_context_scope = QgsExpressionContextUtils.projectScope()\n    key = provenance_layer_analysis_impacted['provenance_key']\n    if not project_context_scope.hasVariable(key):\n        return None\n\n    analysis_dir = dirname(project_context_scope.variable(key))\n    complete_html_report = get_impact_report_as_string(analysis_dir)\n\n    requested_html_report = get_report_section(\n        complete_html_report, component_id=analysis_question_component['key'])\n\n    return requested_html_report", "response": "Retrieve the analysis question section from InaSAFE report."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef population_analysis_summary_report(feature, parent):\n    _ = feature, parent  # NOQA\n    analysis_dir = get_analysis_dir(exposure_population['key'])\n    if analysis_dir:\n        return get_impact_report_as_string(analysis_dir)\n    return None", "response": "Retrieve an HTML population analysis table report from a multi exposure\n    analysis."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve an HTML road analysis table report from a multi exposure analysis.", "response": "def road_analysis_summary_report(feature, parent):\n    \"\"\"Retrieve an HTML road analysis table report from a multi exposure\n    analysis.\n    \"\"\"\n    _ = feature, parent  # NOQA\n    analysis_dir = get_analysis_dir(exposure_road['key'])\n    if analysis_dir:\n        return get_impact_report_as_string(analysis_dir)\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve an HTML structure analysis table report from a multi exposure analysis.", "response": "def structure_analysis_summary_report(feature, parent):\n    \"\"\"Retrieve an HTML structure analysis table report from a multi exposure\n    analysis.\n    \"\"\"\n    _ = feature, parent  # NOQA\n    analysis_dir = get_analysis_dir(exposure_structure['key'])\n    if analysis_dir:\n        return get_impact_report_as_string(analysis_dir)\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef place_analysis_summary_report(feature, parent):\n    _ = feature, parent  # NOQA\n    analysis_dir = get_analysis_dir(exposure_place['key'])\n    if analysis_dir:\n        return get_impact_report_as_string(analysis_dir)\n    return None", "response": "Retrieve an HTML place analysis table report from a multi exposure\n    analysis."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving an HTML land cover analysis table report from a multi exposure analysis.", "response": "def land_cover_analysis_summary_report(feature, parent):\n    \"\"\"Retrieve an HTML land cover analysis table report from a multi exposure\n    analysis.\n    \"\"\"\n    _ = feature, parent  # NOQA\n    analysis_dir = get_analysis_dir(exposure_land_cover['key'])\n    if analysis_dir:\n        return get_impact_report_as_string(analysis_dir)\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve an HTML multi exposure analysis table report.", "response": "def multi_exposure_analysis_summary_report(feature, parent):\n    \"\"\"Retrieve an HTML multi exposure analysis table report.\n    \"\"\"\n    _ = feature, parent  # NOQA\n    analysis_dir = get_analysis_dir()\n    if analysis_dir:\n        return get_impact_report_as_string(analysis_dir)\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_help(self, wizard_step):\n        self.wizard_step = wizard_step\n\n        header = html_header()\n        footer = html_footer()\n\n        content = header\n\n        message = self.wizard_step.help()\n\n        content += message.to_html()\n        content += footer\n\n        self.help_web_view.setHtml(content)\n\n        # Store buttons' state\n        self.next_button_state = self.parent.pbnNext.isEnabled()\n        self.back_button_state = self.parent.pbnBack.isEnabled()\n\n        # Disable those buttons\n        self.parent.pbnNext.setEnabled(False)\n        self.parent.pbnBack.setEnabled(False)", "response": "Set wizard step and show the help text."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef restore_button_state(self):\n        self.parent.pbnNext.setEnabled(self.next_button_state)\n        self.parent.pbnBack.setEnabled(self.back_button_state)", "response": "Helper to restore button state."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef current_git_hash():\n    repo_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    git_show = subprocess.Popen(\n        'git rev-parse --short=6 HEAD',\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        shell=True,\n        cwd=repo_dir,\n        universal_newlines=True,\n        encoding='utf8'\n    )\n    hash_number = git_show.communicate()[0].partition('\\n')[0]\n    return hash_number", "response": "Retrieve the current git hash number of the git repo."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a PEP 386 - compliant version number from VERSION.", "response": "def get_version(version=None):\n    \"\"\"Returns a PEP 386-compliant version number from VERSION.\n\n    :param version: A tuple that represent a version.\n    :type version: tuple\n\n    :returns: a PEP 386-compliant version number.\n    :rtype: str\n\n    \"\"\"\n    if version is None:\n        version_list = inasafe_version.split('.')\n        version = tuple(version_list + [inasafe_release_status] + ['0'])\n\n    if len(version) != 5:\n        msg = 'Version must be a tuple of length 5. I got %s' % (version,)\n        raise RuntimeError(msg)\n\n    if version[3] not in ('alpha', 'beta', 'rc', 'final'):\n        msg = 'Version tuple not as expected. I got %s' % (version,)\n        raise RuntimeError(msg)\n\n    # Now build the two parts of the version number:\n    # main = X.Y[.Z]\n    # sub = .devN - for pre-alpha releases\n    #     | {a|b|c}N - for alpha, beta and rc releases\n    parts = 2 if version[2] == 0 else 3\n    main = '.'.join(str(x) for x in version[:parts])\n\n    sub = ''\n    # This crashes on windows\n    if version[3] == 'alpha' and version[4] == '0':\n        # Currently failed on windows and mac\n        if 'win32' in sys.platform or 'darwin' in sys.platform:\n            sub = '.dev-master'\n        else:\n            try:\n                git_hash = current_git_hash()\n                if git_hash:\n                    sub = '.dev-%s' % git_hash\n            except WindowsError:\n                sub = '.dev-master'\n\n    elif version[3] != 'final':\n        mapping = {'alpha': 'a', 'beta': 'b', 'rc': 'c'}\n        sub = mapping[version[3]] + str(version[4])\n\n    return main + sub"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef html_footer():\n    file_path = resources_path('footer.html')\n    with open(file_path) as header_file:\n        content = header_file.read()\n    return content", "response": "Get a standard html footer for wrapping content in."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef html_header():\n    file_path = resources_path('header.html')\n\n    with codecs.open(file_path, 'r', encoding='utf8') as header_file:\n        content = header_file.read()\n        content = content.replace('PATH', resources_path())\n    return content", "response": "Get a standard html header for wrapping content in."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resources_path(*args):\n    path = os.path.dirname(__file__)\n    path = os.path.abspath(\n        os.path.join(path, os.path.pardir, 'resources'))\n    for item in args:\n        path = os.path.abspath(os.path.join(path, item))\n\n    return path", "response": "Get the absolute path to our resources folder."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a local filesystem url to a given resource.", "response": "def resource_url(path):\n    \"\"\"Get the a local filesystem url to a given resource.\n\n    .. versionadded:: 3.0\n\n    Note that in version 3.0 we removed the use of Qt Resource files in\n    favour of directly accessing on-disk resources.\n\n    :param path: Path to resource e.g. /home/timlinux/foo/bar.png\n    :type path: str\n\n    :return: A valid file url e.g. file:///home/timlinux/foo/bar.png\n    :rtype: str\n    \"\"\"\n    url = QtCore.QUrl.fromLocalFile(path)\n    return str(url.toString())"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget UI Python class from. ui file.", "response": "def get_ui_class(ui_file):\n    \"\"\"Get UI Python class from .ui file.\n\n       Can be filename.ui or subdirectory/filename.ui\n\n    :param ui_file: The file of the ui in safe.gui.ui\n    :type ui_file: str\n    \"\"\"\n    os.path.sep.join(ui_file.split('/'))\n    ui_file_path = os.path.abspath(\n        os.path.join(\n            os.path.dirname(__file__),\n            os.pardir,\n            'gui',\n            'ui',\n            ui_file\n        )\n    )\n    return uic.loadUiType(ui_file_path)[0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind the proper step when user clicks the Next button.", "response": "def get_next_step(self):\n        \"\"\"Find the proper step when user clicks the Next button.\n\n        :returns: The step to be switched to\n        :rtype: WizardStep instance or None\n        \"\"\"\n        subcategory = self.parent.step_kw_subcategory.selected_subcategory()\n        if subcategory and subcategory.get('extra_keywords'):\n            new_step = self.parent.step_kw_extra_keywords\n        else:\n            new_step = self.parent.step_kw_title\n        return new_step"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_widgets(self):\n        # Just set values based on existing keywords\n        source = self.parent.get_existing_keyword('source')\n        if source or source == 0:\n            self.leSource.setText(source)\n        else:\n            self.leSource.clear()\n\n        source_scale = self.parent.get_existing_keyword('scale')\n        if source_scale or source_scale == 0:\n            self.leSource_scale.setText(source_scale)\n        else:\n            self.leSource_scale.clear()\n\n        source_date = self.parent.get_existing_keyword('date')\n        if source_date:\n            self.ckbSource_date.setChecked(True)\n            self.dtSource_date.setDateTime(source_date)\n        else:\n            self.ckbSource_date.setChecked(False)\n            self.dtSource_date.clear()\n\n        source_url = self.parent.get_existing_keyword('url')\n        try:\n            source_url = source_url.toString()\n        except AttributeError:\n            pass\n\n        if source_url or source_url == 0:\n            self.leSource_url.setText(source_url)\n        else:\n            self.leSource_url.clear()\n\n        source_license = self.parent.get_existing_keyword('license')\n        if source_license or source_license == 0:\n            self.leSource_license.setText(source_license)\n        else:\n            self.leSource_license.clear()", "response": "Set widgets on the Source tab."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a single donut chart for affected population.", "response": "def population_chart_extractor(impact_report, component_metadata):\n    \"\"\"Creating population donut chart.\n\n    :param impact_report: the impact report that acts as a proxy to fetch\n        all the data that extractor needed\n    :type impact_report: safe.report.impact_report.ImpactReport\n\n    :param component_metadata: the component metadata. Used to obtain\n        information about the component we want to render\n    :type component_metadata: safe.report.report_metadata.\n        ReportComponentsMetadata\n\n    :return: context for rendering phase\n    :rtype: dict\n\n    .. versionadded:: 4.0\n    \"\"\"\n    context = {}\n    extra_args = component_metadata.extra_args\n\n    analysis_layer = impact_report.analysis\n    analysis_layer_fields = analysis_layer.keywords['inasafe_fields']\n    provenance = impact_report.impact_function.provenance\n    hazard_keywords = provenance['hazard_keywords']\n    exposure_keywords = provenance['exposure_keywords']\n\n    \"\"\"Generate Donut chart for affected population.\"\"\"\n\n    # create context for the donut chart\n\n    # retrieve hazard classification from hazard layer\n    hazard_classification = definition(\n        active_classification(hazard_keywords, exposure_keywords['exposure']))\n\n    if not hazard_classification:\n        return context\n\n    data = []\n    labels = []\n    colors = []\n\n    for hazard_class in hazard_classification['classes']:\n\n        # Skip if it is not affected hazard class\n        if not hazard_class['affected']:\n            continue\n\n        # hazard_count_field is a dynamic field with hazard class\n        # as parameter\n        field_key_name = hazard_count_field['key'] % (\n            hazard_class['key'],)\n\n        try:\n            # retrieve dynamic field name from analysis_fields keywords\n            # will cause key error if no hazard count for that particular\n            # class\n            field_name = analysis_layer_fields[field_key_name]\n            # Hazard label taken from translated hazard count field\n            # label, string-formatted with translated hazard class label\n            hazard_value = value_from_field_name(field_name, analysis_layer)\n            hazard_value = round_affected_number(\n                hazard_value,\n                use_rounding=True,\n                use_population_rounding=True)\n        except KeyError:\n            # in case the field was not found\n            continue\n\n        data.append(hazard_value)\n        labels.append(hazard_class['name'])\n        colors.append(hazard_class['color'].name())\n\n    # add total not affected\n    try:\n        field_name = analysis_layer_fields[total_not_affected_field['key']]\n        hazard_value = value_from_field_name(field_name, analysis_layer)\n        hazard_value = round_affected_number(\n            hazard_value,\n            use_rounding=True,\n            use_population_rounding=True)\n\n        data.append(hazard_value)\n        labels.append(total_not_affected_field['name'])\n        colors.append(green.name())\n    except KeyError:\n        # in case the field is not there\n        pass\n\n    # add number for total not affected\n    chart_title = resolve_from_dictionary(extra_args, 'chart_title')\n    total_header = resolve_from_dictionary(extra_args, 'total_header')\n    donut_context = DonutChartContext(\n        data=data,\n        labels=labels,\n        colors=colors,\n        inner_radius_ratio=0.5,\n        stroke_color='#fff',\n        title=chart_title,\n        total_header=total_header,\n        as_file=True)\n\n    context['context'] = donut_context\n\n    return context"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a context dictionary that can be used to render a population donut chart.", "response": "def population_chart_to_png_extractor(impact_report, component_metadata):\n    \"\"\"Creating population donut chart.\n\n    :param impact_report: the impact report that acts as a proxy to fetch\n        all the data that extractor needed\n    :type impact_report: safe.report.impact_report.ImpactReport\n\n    :param component_metadata: the component metadata. Used to obtain\n        information about the component we want to render\n    :type component_metadata: safe.report.report_metadata.\n        ReportComponentsMetadata\n\n    :return: context for rendering phase\n    :rtype: dict\n\n    .. versionadded:: 4.0\n    \"\"\"\n    context = {}\n\n    population_donut_path = impact_report.component_absolute_output_path(\n        'population-chart')\n\n    if not population_donut_path:\n        return context\n\n    context['filepath'] = population_donut_path\n\n    return context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwelcome message for first running users.", "response": "def welcome_message():\n    \"\"\"Welcome message for first running users.\n\n    .. versionadded:: 4.3.0\n\n    :returns: A message object containing helpful information.\n    :rtype: messaging.message.Message\n    \"\"\"\n\n    message = m.Message()\n    message.add(m.Brand())\n    message.add(heading())\n    message.add(content())\n    return message"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef content():\n    message = m.Message()\n    message.add(m.Paragraph(tr(\n        'Welcome to InaSAFE. Before you begin using InaSAFE, we would like to '\n        'encourage you to review some options that will used by InaSAFE. On '\n        'the \"Organisation Profile\" tab you can set options related to your '\n        'organisation such as: the name and logo.'\n    )))\n    message.add(m.Paragraph(tr(\n        'The \"Population Parameters\" tab is used to define some parameters '\n        'that will be used by InaSAFE in the analysis of exposed population. '\n        'You have the option to change the parameters for whether exposed '\n        'population are considered to be \"affected\" by each hazard type and '\n        'class and the displacement rate that will be used for affected '\n        'people.')))\n    message.add(m.Paragraph(tr(\n        'Please refer to the InaSAFE manual for concept definitions and more '\n        'information on the source of hazard classifications and default '\n        'settings. We really encourage you to consider these '\n        'population parameters carefully and to choose appropriate values for '\n        'your local situation based on past events and expert knowledge.')))\n    message.add(m.Paragraph(tr(\n        'You can return to these options any time by using the Plugins -> '\n        'InaSAFE -> Options menu.'\n    )))\n\n    return message", "response": "Helper method that returns just the content of the current brand element."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_scenarios(filename):\n    # Input checks\n    filename = os.path.abspath(filename)\n\n    blocks = {}\n    parser = ConfigParser()\n\n    # Parse the file content.\n    # if the content don't have section header\n    # we use the filename.\n    try:\n        parser.read(filename)\n    except MissingSectionHeaderError:\n        base_name = os.path.basename(filename)\n        name = os.path.splitext(base_name)[0]\n        section = '[%s]\\n' % name\n        content = section + open(filename).read()\n        parser.readfp(StringIO(content))\n\n    # convert to dictionary\n    for section in parser.sections():\n        items = parser.items(section)\n        # add section as scenario name\n        items.append(('scenario_name', section))\n        # add full path to the blocks\n        items.append(('full_path', filename))\n        blocks[section] = {}\n        for key, value in items:\n            blocks[section][key] = value\n\n    # Ok we have generated a structure that looks like this:\n    # blocks = {{ 'foo' : { 'a': 'b', 'c': 'd'},\n    #           { 'bar' : { 'd': 'e', 'f': 'g'}}\n    # where foo and bar are scenarios and their dicts are the options for\n    # that scenario (e.g. hazard, exposure etc)\n    return blocks", "response": "Read keywords dictionary from file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfunction to validate input layer stored in scenario file.", "response": "def validate_scenario(blocks, scenario_directory):\n    \"\"\"Function to validate input layer stored in scenario file.\n\n    Check whether the files that are used in scenario file need to be\n    updated or not.\n\n    :param blocks: dictionary from read_scenarios\n    :type blocks: dictionary\n\n    :param scenario_directory: directory where scenario text file is saved\n    :type scenario_directory: file directory\n\n    :return: pass message to dialog and log detailed status\n    \"\"\"\n    # dictionary to temporary contain status message\n    blocks_update = {}\n    for section, section_item in list(blocks.items()):\n        ready = True\n        for item in section_item:\n            if item in ['hazard', 'exposure', 'aggregation']:\n                # get relative path\n                rel_path = section_item[item]\n                full_path = os.path.join(scenario_directory, rel_path)\n                filepath = os.path.normpath(full_path)\n                if not os.path.exists(filepath):\n                    blocks_update[section] = {\n                        'status': 'Please update scenario'}\n                    LOGGER.info(section + ' needs to be updated')\n                    LOGGER.info('Unable to find ' + filepath)\n                    ready = False\n        if ready:\n            blocks_update[section] = {'status': 'Scenario ready'}\n            # LOGGER.info(section + \" scenario is ready\")\n    for section, section_item in list(blocks_update.items()):\n        blocks[section]['status'] = blocks_update[section]['status']"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nappends a row to the table widget.", "response": "def append_row(table, label, data):\n    \"\"\"Append new row to table widget.\n\n    :param table: The table that shall have the row added to it.\n    :type table: QTableWidget\n\n    :param label: Label for the row.\n    :type label: str\n\n    :param data: custom data associated with label value.\n    :type data: str\n    \"\"\"\n    # noinspection PyUnresolvedReferences\n    count = table.rowCount()\n    # noinspection PyUnresolvedReferences\n    table.insertRow(table.rowCount())\n\n    items = QTableWidgetItem(label)\n\n    # see for details of why we follow this pattern\n    # http://stackoverflow.com/questions/9257422/\n    # how-to-get-the-original-python-data-from-qvariant\n    # Make the value immutable.\n    variant = (data,)\n    # To retrieve it again you would need to do:\n    # value = myVariant.toPyObject()[0]\n    items.setData(Qt.UserRole, variant)\n    # set scenario status (ready or not) into table\n    # noinspection PyUnresolvedReferences\n    table.setItem(count, 0, items)\n    # noinspection PyUnresolvedReferences\n    table.setItem(count, 1, QTableWidgetItem(data['status']))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef restore_state(self):\n        # restore last source path\n        last_source_path = setting(\n            'lastSourceDir', self.default_directory, expected_type=str)\n        self.source_directory.setText(last_source_path)\n\n        # restore path pdf output\n        last_output_dir = setting(\n            'lastOutputDir', self.default_directory, expected_type=str)\n        self.output_directory.setText(last_output_dir)\n\n        # restore default output dir combo box\n        use_default_output_dir = bool(setting(\n            'useDefaultOutputDir', True, expected_type=bool))\n        self.scenario_directory_radio.setChecked(\n            use_default_output_dir)", "response": "Restore GUI state from configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsave current state of GUI to configuration file.", "response": "def save_state(self):\n        \"\"\"Save current state of GUI to configuration file.\"\"\"\n        set_setting('lastSourceDir', self.source_directory.text())\n        set_setting('lastOutputDir', self.output_directory.text())\n        set_setting(\n            'useDefaultOutputDir', self.scenario_directory_radio.isChecked())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nshow a directory selection dialog.", "response": "def choose_directory(self, line_edit, title):\n        \"\"\" Show a directory selection dialog.\n        This function will show the dialog then set line_edit widget\n        text with output from the dialog.\n\n        :param line_edit: Widget whose text should be updated.\n        :type line_edit: QLineEdit\n\n        :param title: title of dialog\n        :type title: str, QString\n        \"\"\"\n        path = line_edit.text()\n        # noinspection PyCallByClass,PyTypeChecker\n        new_path = QFileDialog.getExistingDirectory(\n            self, title, path, QFileDialog.ShowDirsOnly)\n        if new_path is not None and os.path.exists(new_path):\n            line_edit.setText(new_path)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef populate_table(self, scenario_directory):\n        parsed_files = []\n        unparsed_files = []\n        self.table.clearContents()\n\n        # Block signal to allow update checking only when the table is ready\n        self.table.blockSignals(True)\n        # NOTE(gigih): need this line to remove existing rows\n        self.table.setRowCount(0)\n\n        if not os.path.exists(scenario_directory):\n            # LOGGER.info('Scenario directory does not exist: %s' % path)\n            return\n\n        # only support .py and .txt files\n        for current_path in os.listdir(scenario_directory):\n            extension = os.path.splitext(current_path)[1]\n            absolute_path = os.path.join(scenario_directory, current_path)\n\n            if extension == '.py':\n                append_row(self.table, current_path, absolute_path)\n            elif extension == '.txt':\n                # insert scenarios from file into table widget\n                try:\n                    scenarios = read_scenarios(absolute_path)\n                    validate_scenario(scenarios, scenario_directory)\n                    for key, value in list(scenarios.items()):\n                        append_row(self.table, key, value)\n                    parsed_files.append(current_path)\n                except Error:\n                    unparsed_files.append(current_path)\n\n        # unblock signal\n        self.table.blockSignals(False)", "response": "Populate the table with files from the given directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun a python script in QGIS to exercise InaSAFE functionality.", "response": "def run_script(self, filename):\n        \"\"\" Run a python script in QGIS to exercise InaSAFE functionality.\n\n        This functionality was originally intended for verifying that the key\n        elements are InaSAFE are loading correctly and available. However,\n        the utility of this function is such that you can run any arbitrary\n        python scripts with it. As such you can use it it automate\n        activities in QGIS, for example automatically running an impact\n        assessment in response to an event.\n\n        :param filename: the script filename.\n        :type filename: str\n        \"\"\"\n        module, _ = os.path.splitext(filename)\n        if module in sys.modules:\n            script = reload(sys.modules[module])\n        else:\n            script = __import__(module)\n\n        # run entry function\n        function = script.runScript\n        if function.__code__.co_argcount == 1:\n            function(self.iface)\n        else:\n            function()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreset all scenarios status to empty in the table.", "response": "def reset_status(self):\n        \"\"\"Set all scenarios' status to empty in the table.\"\"\"\n        for row in range(self.table.rowCount()):\n            status_item = self.table.item(row, 1)\n            status_item.setText(self.tr(''))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprepare scenario for impact function variable.", "response": "def prepare_task(self, items):\n        \"\"\"Prepare scenario for impact function variable.\n\n        :param items: Dictionary containing settings for impact function.\n        :type items: Python dictionary.\n\n        :return: A tuple containing True and dictionary containing parameters\n                 if post processor success. Or False and an error message\n                 if something went wrong.\n        \"\"\"\n\n        status = True\n        message = ''\n        # get hazard\n        if 'hazard' in items:\n            hazard_path = items['hazard']\n            hazard = self.define_layer(hazard_path)\n            if not hazard:\n                status = False\n                message = self.tr(\n                    'Unable to find {hazard_path}').format(\n                    hazard_path=hazard_path)\n        else:\n            hazard = None\n            LOGGER.warning('Scenario does not contain hazard path')\n\n        # get exposure\n        if 'exposure' in items:\n            exposure_path = items['exposure']\n            exposure = self.define_layer(exposure_path)\n            if not exposure:\n                status = False\n                if message:\n                    message += '\\n'\n                message += self.tr(\n                    'Unable to find {exposure_path}').format(\n                    exposure_path=exposure_path)\n        else:\n            exposure = None\n            LOGGER.warning('Scenario does not contain hazard path')\n\n        # get aggregation\n        if 'aggregation' in items:\n            aggregation_path = items['aggregation']\n            aggregation = self.define_layer(aggregation_path)\n        else:\n            aggregation = None\n            LOGGER.info('Scenario does not contain aggregation path')\n\n        # get extent\n        if 'extent' in items:\n            LOGGER.info('Extent coordinate is found')\n            coordinates = items['extent']\n            array_coord = extent_string_to_array(coordinates)\n            extent = QgsRectangle(*array_coord)\n        else:\n            extent = None\n            LOGGER.info('Scenario does not contain extent coordinates')\n\n        # get extent crs id\n        if 'extent_crs' in items:\n            LOGGER.info('Extent CRS is found')\n            crs = items['extent_crs']\n            extent_crs = QgsCoordinateReferenceSystem(crs)\n        else:\n            LOGGER.info('Extent crs is not found, assuming crs to EPSG:4326')\n            extent_crs = QgsCoordinateReferenceSystem('EPSG:4326')\n\n        # make sure at least hazard and exposure data are available in\n        # scenario. Aggregation and extent checking will be done when\n        # assigning layer to impact_function\n        if status:\n            parameters = {\n                layer_purpose_hazard['key']: hazard,\n                layer_purpose_exposure['key']: exposure,\n                layer_purpose_aggregation['key']: aggregation,\n                'extent': extent,\n                'crs': extent_crs\n            }\n            return True, parameters\n        else:\n            LOGGER.warning(message)\n            display_critical_message_box(\n                title=self.tr('Error while preparing scenario'),\n                message=message)\n            return False, None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating QGIS layer from file path input.", "response": "def define_layer(self, layer_path):\n        \"\"\"Create QGIS layer (either vector or raster) from file path input.\n\n        :param layer_path: Full path to layer file.\n        :type layer_path: str\n\n        :return: QGIS layer.\n        :rtype: QgsMapLayer\n        \"\"\"\n        scenario_dir = self.source_directory.text()\n        joined_path = os.path.join(scenario_dir, layer_path)\n        full_path = os.path.normpath(joined_path)\n        file_name = os.path.split(layer_path)[-1]\n\n        # get extension and basename to create layer\n        base_name, extension = os.path.splitext(file_name)\n\n        # load layer in scenario\n        layer = QgsRasterLayer(full_path, base_name)\n        if layer.isValid():\n            return layer\n        else:\n            layer = QgsVectorLayer(full_path, base_name, 'ogr')\n            if layer.isValid():\n                return layer\n            # if layer is not vector nor raster\n            else:\n                LOGGER.warning('Input in scenario is not recognized/supported')\n                return"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset a layer in the project visible or not.", "response": "def set_layer_visible(layer, visible):\n        \"\"\"Sets a layer in the project visible or not\n\n        :param layer: layer to change\n        :type layer: QgsMapLayer\n\n        :param visible: True to show layer, False to hide layer\n        :type visible: bool\n        \"\"\"\n        if layer is None:\n            return\n\n        QgsProject.instance().layerTreeRoot().findLayer(\n            layer.id()).setItemVisibilityChecked(visible)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun a single task.", "response": "def run_task(self, task_item, status_item, count=0, index=''):\n        \"\"\"Run a single task.\n\n        :param task_item: Table task_item containing task name / details.\n        :type task_item: QTableWidgetItem\n\n        :param status_item: Table task_item that holds the task status.\n        :type status_item: QTableWidgetItem\n\n        :param count: Count of scenarios that have been run already.\n        :type count:\n\n        :param index: The index for the table item that will be run.\n        :type index: int\n\n        :returns: Flag indicating if the task succeeded or not.\n        :rtype: bool\n        \"\"\"\n        self.enable_busy_cursor()\n        for layer_group in self.layer_group_container:\n            layer_group.setItemVisibilityChecked(False)\n\n        # set status to 'running'\n        status_item.setText(self.tr('Running'))\n\n        # .. see also:: :func:`appendRow` to understand the next 2 lines\n        variant = task_item.data(QtCore.Qt.UserRole)\n        value = variant[0]\n        result = True\n\n        if isinstance(value, str):\n            filename = value\n            # run script\n            try:\n                self.run_script(filename)\n                # set status to 'OK'\n                status_item.setText(self.tr('Script OK'))\n            except Exception as e:  # pylint: disable=W0703\n                # set status to 'fail'\n                status_item.setText(self.tr('Script Fail'))\n\n                LOGGER.exception(\n                    'Running macro failed. The exception: ' + str(e))\n                result = False\n        elif isinstance(value, dict):\n            # start in new project if toggle is active\n            if self.start_in_new_project:\n                self.iface.newProject()\n            # create layer group\n            group_name = value['scenario_name']\n            self.layer_group = self.root.addGroup(group_name)\n            self.layer_group_container.append(self.layer_group)\n\n            # Its a dict containing files for a scenario\n            success, parameters = self.prepare_task(value)\n            if not success:\n                # set status to 'running'\n                status_item.setText(self.tr('Please update scenario'))\n                self.disable_busy_cursor()\n                return False\n\n            directory = self.output_directory.text()\n            if self.scenario_directory_radio.isChecked():\n                directory = self.source_directory.text()\n\n            output_directory = os.path.join(directory, group_name)\n            if not os.path.exists(output_directory):\n                os.makedirs(output_directory)\n\n            # If impact function parameters loaded successfully, initiate IF.\n            impact_function = ImpactFunction()\n            impact_function.datastore = Folder(output_directory)\n            impact_function.datastore.default_vector_format = \"geojson\"\n            impact_function.hazard = parameters[layer_purpose_hazard['key']]\n            impact_function.exposure = (\n                parameters[layer_purpose_exposure['key']])\n            if parameters[layer_purpose_aggregation['key']]:\n                impact_function.aggregation = (\n                    parameters[layer_purpose_aggregation['key']])\n            elif parameters['extent']:\n                impact_function.requested_extent = parameters['extent']\n                impact_function.crs = parameters['crs']\n            prepare_status, prepare_message = impact_function.prepare()\n            if prepare_status == PREPARE_SUCCESS:\n                LOGGER.info('Impact function ready')\n                status, message = impact_function.run()\n                if status == ANALYSIS_SUCCESS:\n                    status_item.setText(self.tr('Analysis Success'))\n                    impact_layer = impact_function.impact\n                    if impact_layer.isValid():\n                        layer_list = [\n                            impact_layer,\n                            impact_function.analysis_impacted,\n                            parameters[layer_purpose_hazard['key']],\n                            parameters[layer_purpose_exposure['key']],\n                            parameters[layer_purpose_aggregation['key']]]\n                        QgsProject.instance().addMapLayers(\n                            layer_list, False)\n                        for layer in layer_list:\n                            self.layer_group.addLayer(layer)\n                        map_canvas = QgsProject.instance().mapLayers()\n                        for layer in map_canvas:\n                            # turn of layer visibility if not impact layer\n                            if map_canvas[layer].id() == impact_layer.id():\n                                self.set_layer_visible(\n                                    map_canvas[layer], True)\n                            else:\n                                self.set_layer_visible(\n                                    map_canvas[layer], False)\n\n                        # we need to set analysis_impacted as an active layer\n                        # because we need to get all qgis variables that we\n                        # need from this layer for infographic.\n                        if self.iface:\n                            self.iface.setActiveLayer(\n                                impact_function.analysis_impacted)\n\n                        report_directory = os.path.join(\n                            output_directory, 'output')\n\n                        # generate map report and impact report\n                        try:\n                            error_code, message = (\n                                impact_function.generate_report(\n                                    all_default_report_components,\n                                    report_directory))\n\n                        except BaseException:\n                            status_item.setText(\n                                self.tr('Report failed to generate.'))\n                    else:\n                        LOGGER.info('Impact layer is invalid')\n\n                elif status == ANALYSIS_FAILED_BAD_INPUT:\n                    LOGGER.info('Bad input detected')\n\n                elif status == ANALYSIS_FAILED_BAD_CODE:\n                    LOGGER.info(\n                        'Impact function encountered a bug: %s' % message)\n\n            else:\n                LOGGER.warning('Impact function not ready')\n                send_error_message(self, prepare_message)\n\n        else:\n            LOGGER.exception('Data type not supported: \"%s\"' % value)\n            result = False\n\n        self.disable_busy_cursor()\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncompiling a formatted list of un - parsable files and show the parsed and unparsed files.", "response": "def show_parser_results(self, parsed_list, unparsed_list):\n        \"\"\"Compile a formatted list of un/successfully parsed files.\n\n        :param parsed_list: A list of files that were parsed successfully.\n        :type parsed_list: list(str)\n\n        :param unparsed_list: A list of files that were not parsable.\n        :type unparsed_list: list(str)\n\n        :returns: A formatted message outlining what could be parsed.\n        :rtype: str\n        \"\"\"\n        parsed_message = self.tr(\n            'The file(s) below were parsed successfully:\\n')\n        unparsed_message = self.tr(\n            'The file(s) below were not parsed successfully:\\n')\n        parsed_contents = '\\n'.join(parsed_list)\n        unparsed_contents = '\\n'.join(unparsed_list)\n        if parsed_contents == '':\n            parsed_contents = 'No successfully parsed files\\n'\n        if unparsed_contents == '':\n            unparsed_contents = 'No failures in parsing files\\n'\n        full_messages = (\n            parsed_message + parsed_contents + '\\n\\n'\n            + unparsed_message + unparsed_contents)\n        return full_messages"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run_selected_clicked(self):\n        # get all selected rows\n        rows = sorted(set(index.row() for index in\n                          self.table.selectedIndexes()))\n        self.enable_busy_cursor()\n        # iterate over selected rows\n        for row in rows:\n            current_row = row\n            item = self.table.item(current_row, 0)\n            status_item = self.table.item(current_row, 1)\n            self.run_task(item, status_item)\n        self.disable_busy_cursor()", "response": "Run the selected scenario."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning all scenario when pbRunAll is clicked.", "response": "def run_all_clicked(self):\n        \"\"\"Run all scenario when pbRunAll is clicked.\"\"\"\n        self.reset_status()\n\n        self.enable_busy_cursor()\n        report = []\n        fail_count = 0\n        pass_count = 0\n\n        index = 0\n        for row in range(self.table.rowCount()):\n            item = self.table.item(row, 0)\n            status_item = self.table.item(row, 1)\n            name_item = item.text()\n\n            try:\n                index += 1\n                result = self.run_task(item, status_item, index=index)\n                if result:\n                    # P for passed\n                    report.append('P: %s\\n' % name_item)\n                    pass_count += 1\n                else:\n                    report.append('F: %s\\n' % name_item)\n                    fail_count += 1\n            except Exception as e:  # pylint: disable=W0703\n                LOGGER.exception(\n                    'Batch execution failed. The exception: ' + str(e))\n                report.append('F: %s\\n' % name_item)\n                fail_count += 1\n                self.disable_busy_cursor()\n\n        try:\n            report_path = self.write_report(\n                report, pass_count, fail_count)\n            self.show_report(report_path)\n        except IOError:\n            # noinspection PyArgumentList,PyCallByClass,PyTypeChecker\n            QMessageBox.question(self, 'Error',\n                                       'Failed to write report file.')\n            self.disable_busy_cursor()\n        self.disable_busy_cursor()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting a report of the status of the current batch run.", "response": "def write_report(self, report, pass_count, fail_count):\n        \"\"\"Write a report status of Batch Runner.\n\n        For convenience, the name will use current time.\n\n        :param report: A list of each scenario and its status.\n        :type report: list\n\n        :param pass_count: Number of passing scenarios.\n        :type pass_count: int\n\n        :param fail_count: Number of failed scenarios.\n        :type fail_count: int\n\n        :returns: A string containing the path to the report file.\n        :rtype: str\n\n        :raises: IOError\n        \"\"\"\n        separator = '-----------------------------\\n'\n        current_time = datetime.now().strftime('%Y%m%d%H%M%S')\n        report_path = 'batch-report-' + current_time + '.txt'\n        output_path = self.output_directory.text()\n        path = os.path.join(output_path, report_path)\n\n        try:\n            report_file = open(path, 'w')\n            report_file.write('InaSAFE Batch Report File\\n')\n            report_file.write(separator)\n            for myLine in report:\n                report_file.write(myLine)\n            report_file.write(separator)\n            report_file.write('Total passed: %s\\n' % pass_count)\n            report_file.write('Total failed: %s\\n' % fail_count)\n            report_file.write('Total tasks: %s\\n' % len(report))\n            report_file.write(separator)\n            report_file.close()\n\n            # LOGGER.info('Log written to %s' % path)\n            return path\n        except IOError:\n            raise IOError"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates and store a PDF report for the given impact function.", "response": "def generate_pdf_report(self, impact_function, iface, scenario_name):\n        \"\"\"Generate and store map and impact report from impact function.\n\n        Directory where the report stored is specified by user input from the\n        dialog. This function is adapted from analysis_utilities.py\n\n        :param impact_function: Impact Function.\n        :type impact_function: ImpactFunction()\n\n        :param iface: iface.\n        :type iface: iface\n\n        :param scenario_name: name of the scenario\n        :type scenario_name: str\n        \"\"\"\n        # output folder\n        output_dir = self.output_directory.text()\n        file_path = os.path.join(output_dir, scenario_name)\n\n        # create impact table report instance\n        table_report_metadata = ReportMetadata(\n            metadata_dict=standard_impact_report_metadata_pdf)\n        impact_table_report = ImpactReport(\n            iface,\n            table_report_metadata,\n            impact_function=impact_function)\n        impact_table_report.output_folder = file_path\n        impact_table_report.process_components()\n\n        # create impact map report instance\n        map_report_metadata = ReportMetadata(\n            metadata_dict=update_template_component(map_report))\n        impact_map_report = ImpactReport(\n            iface,\n            map_report_metadata,\n            impact_function=impact_function)\n        # TODO: Get from settings file\n\n        # get the extent of impact layer\n        impact_map_report.qgis_composition_context.extent = \\\n            impact_function.impact.extent()\n        impact_map_report.output_folder = file_path\n        impact_map_report.process_components()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nshowing the batch report file in batchReportFileName using an external app.", "response": "def show_report(self, report_path):\n        \"\"\"Show batch report file in batchReportFileName using an external app.\n\n        This method uses QDesktop services to display the report (typically\n        using gedit or similar text editor).\n\n        :param report_path: Path to the file of batch report.\n        :type report_path: str\n        \"\"\"\n        if self.show_results_popup:\n            url = QtCore.QUrl.fromLocalFile(report_path)\n            # noinspection PyTypeChecker,PyCallByClass,PyArgumentList\n            QtGui.QDesktopServices.openUrl(url)\n        else:\n            # report = open(report_path).read()\n            # LOGGER.info(report)\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate output dir if set to default.", "response": "def update_default_output_dir(self):\n        \"\"\"Update output dir if set to default.\"\"\"\n        if self.scenario_directory_radio.isChecked():\n            self.output_directory.setText(self.source_directory.text())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nenabling the hourglass busy cursor.", "response": "def enable_busy_cursor(self):\n        \"\"\"Set the hourglass enabled.\"\"\"\n        QgsApplication.instance().setOverrideCursor(\n            QtGui.QCursor(QtCore.Qt.WaitCursor)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef on_scenario_directory_radio_toggled(self, flag):\n        if flag:\n            self.output_directory.setText(self.source_directory.text())\n        self.output_directory_chooser.setEnabled(not flag)", "response": "Autoconnect slot activated when scenario_directory_radio is toggled on or\n            off."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_output_directory_chooser_clicked(self):\n        title = self.tr('Set the output directory for pdf report files')\n        self.choose_directory(self.output_directory, title)", "response": "Auto Connect slot activated when tbOutputDir is clicked."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrenders a Cell MessageElement as html", "response": "def to_html(self):\n        \"\"\"Render a Cell MessageElement as html\n\n        :returns: The html representation of the Cell MessageElement\n        :rtype: basestring\n        \"\"\"\n        # Apply bootstrap alignment classes first\n        if self.align is 'left':\n            if self.style_class is None:\n                self.style_class = 'text-left'\n            else:\n                self.style_class += ' text-left'\n        elif self.align is 'right':\n            if self.style_class is None:\n                self.style_class = 'text-right'\n            else:\n                self.style_class += ' text-right'\n        elif self.align is 'center':\n            if self.style_class is None:\n                self.style_class = 'text-center'\n            else:\n                self.style_class += ' text-center'\n\n        # Special case for when we want to put a nested table in a cell\n        # We don't use isinstance because of recursive imports with table\n        class_name = self.content.__class__.__name__\n        if class_name in ['BulletedList', 'Table', 'Image', 'Message']:\n            html = self.content.to_html()\n        else:\n            html = self.content.to_html(wrap_slash=self.wrap_slash)\n\n        # Check if we have a header or not then render\n        if self.header_flag is True:\n            return '<th%s colspan=%i>%s</th>\\n' % (\n                self.html_attributes(), self.span, html)\n        else:\n            return '<td%s colspan=%i>%s</td>\\n' % (\n                self.html_attributes(), self.span, html)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrender a MessageElement as python dict representation", "response": "def to_dict(self):\n        \"\"\"Render a MessageElement as python dict\n\n        :return: Python dict representation\n        :rtype: dict\n        \"\"\"\n        obj_dict = super(Cell, self).to_dict()\n        child_dict = {\n            'type': self.__class__.__name__,\n            'header_flag': self.header_flag,\n            'align': self.align,\n            'wrap_slash': self.wrap_slash,\n            'content': self.content.to_dict()\n        }\n        obj_dict.update(child_dict)\n        return obj_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef error_creator5():\n    try:\n        error_creator4()\n    except SafeError as e4:\n        message = ErrorMessage(\n            'Creator 5 problem',\n            detail=Message(\n                Paragraph('Could not', ImportantText('call'), 'function.'),\n                Paragraph('Try reinstalling your computer with windows.')),\n            suggestion=Message(ImportantText('Important note')))\n        e4.error_message.append(message)\n        raise", "response": "Raise a safe style error and append a full message."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef qgis_composer_extractor(impact_report, component_metadata):\n    # QGIS Composer needed certain context to generate the output\n    # - Map Settings\n    # - Substitution maps\n    # - Element settings, such as icon for picture file or image source\n\n    # Generate map settings\n    qgis_context = impact_report.qgis_composition_context\n    inasafe_context = impact_report.inasafe_context\n    provenance = impact_report.impact_function.provenance\n    extra_args = component_metadata.extra_args\n\n    context = QGISComposerContext()\n\n    # Set default image elements to replace\n    image_elements = [\n        {\n            'id': 'safe-logo',\n            'path': inasafe_context.inasafe_logo\n        },\n        {\n            'id': 'black-inasafe-logo',\n            'path': inasafe_context.black_inasafe_logo\n        },\n        {\n            'id': 'white-inasafe-logo',\n            'path': inasafe_context.white_inasafe_logo\n        },\n        {\n            'id': 'north-arrow',\n            'path': inasafe_context.north_arrow\n        },\n        {\n            'id': 'organisation-logo',\n            'path': inasafe_context.organisation_logo\n        },\n        {\n            'id': 'supporters_logo',\n            'path': inasafe_context.supporters_logo\n        }\n    ]\n    context.image_elements = image_elements\n\n    # Set default HTML Frame elements to replace\n    html_frame_elements = [\n        {\n            'id': 'impact-report',\n            'mode': 'text',  # another mode is url\n            'text': '',  # TODO: get impact summary table\n        }\n    ]\n    context.html_frame_elements = html_frame_elements\n\n    \"\"\"Define the layers for the impact map.\"\"\"\n\n    project = QgsProject.instance()\n    layers = []\n\n    exposure_summary_layers = []\n    if impact_report.multi_exposure_impact_function:\n        for impact_function in (\n                impact_report.multi_exposure_impact_function.impact_functions):\n            impact_layer = impact_function.exposure_summary or (\n                impact_function.aggregate_hazard_impacted)\n            exposure_summary_layers.append(impact_layer)\n\n    # use custom ordered layer if any\n    if impact_report.ordered_layers:\n        for layer in impact_report.ordered_layers:\n            layers.append(layer)\n\n        # We are keeping this if we want to enable below behaviour again.\n        # Currently realtime might have layer order without impact layer in it.\n\n        # # make sure at least there is an impact layer\n        # if impact_report.multi_exposure_impact_function:\n        #     additional_layers = []  # for exposure summary layers\n        #     impact_layer_found = False\n        #     impact_functions = (\n        #        impact_report.multi_exposure_impact_function.impact_functions)\n        #     # check for impact layer occurrences\n        #     for analysis in impact_functions:\n        #         impact_layer = analysis.exposure_summary or (\n        #             analysis.aggregate_hazard_impacted)\n        #         for index, layer in enumerate(layers):\n        #             if impact_layer.source() == layer.source():\n        #                 add_impact_layers_to_canvas(analysis)\n        #                 layers[index] = impact_layer\n        #                 impact_layer_found = True\n        #     if not impact_layer_found:\n        #         for analysis in impact_functions:\n        #             add_impact_layers_to_canvas(analysis)\n        #             impact_layer = analysis.exposure_summary or (\n        #                 analysis.aggregate_hazard_impacted)\n        #             layer_uri = full_layer_uri(impact_layer)\n        #             layer = load_layer_from_registry(layer_uri)\n        #             additional_layers.append(layer)\n        #     layers = additional_layers + layers\n        # else:\n        #     impact_layer = (\n        #         impact_report.impact_function.exposure_summary or (\n        #             impact_report.impact_function.aggregate_hazard_impacted))\n        #     if impact_layer not in layers:\n        #         layers.insert(0, impact_layer)\n\n    # use default layer order if no custom ordered layer found\n    else:\n        if not impact_report.multi_exposure_impact_function:  # single IF\n            layers = [impact_report.impact] + impact_report.extra_layers\n        else:  # multi-exposure IF\n            layers = [] + impact_report.extra_layers\n\n        add_supplementary_layers = (\n            not impact_report.multi_exposure_impact_function or not (\n                impact_report.multi_exposure_impact_function.\n                output_layers_ordered)\n        )\n        if add_supplementary_layers:\n            # Check show only impact.\n            show_only_impact = setting(\n                'set_show_only_impact_on_report', expected_type=bool)\n            if not show_only_impact:\n                hazard_layer = project.mapLayers().get(\n                    provenance['hazard_layer_id'], None)\n\n                aggregation_layer_id = provenance['aggregation_layer_id']\n                if aggregation_layer_id:\n                    aggregation_layer = project.mapLayers().get(\n                        aggregation_layer_id, None)\n                    layers.append(aggregation_layer)\n\n                layers.append(hazard_layer)\n\n            # check hide exposure settings\n            hide_exposure_flag = setting(\n                'setHideExposureFlag', expected_type=bool)\n            if not hide_exposure_flag:\n                exposure_layers_id = []\n                if provenance.get(\n                        provenance_exposure_layer_id['provenance_key']):\n                    exposure_layers_id.append(\n                        provenance.get(\n                            provenance_exposure_layer_id['provenance_key']))\n                elif provenance.get(\n                        provenance_multi_exposure_layers_id['provenance_key']):\n                    exposure_layers_id = provenance.get(\n                        provenance_multi_exposure_layers_id['provenance_key'])\n\n                # place exposure at the bottom\n                for layer_id in exposure_layers_id:\n                    exposure_layer = project.mapLayers().get(layer_id)\n                    layers.append(exposure_layer)\n\n    # default extent is analysis extent\n    if not qgis_context.extent:\n        qgis_context.extent = impact_report.impact_function.analysis_extent\n\n    map_elements = [\n        {\n            'id': 'impact-map',\n            'extent': qgis_context.extent,\n            'grid_split_count': 5,\n            'layers': layers,\n        }\n    ]\n    context.map_elements = map_elements\n\n    # calculate map_legends, only show the legend for impact layer\n    if impact_report.legend_layers:  # use requested legend if any\n        layers = impact_report.legend_layers\n    elif impact_report.multi_exposure_impact_function:  # multi-exposure IF\n        layers = exposure_summary_layers\n    else:  # single IF\n        layers = [impact_report.impact]\n    symbol_count = 0\n    for l in layers:\n        layer = l\n        \"\"\":type: qgis.core.QgsMapLayer\"\"\"\n        try:\n            symbol_count += len(layer.legendSymbologyItems())\n            continue\n        except Exception:  # pylint: disable=broad-except\n            pass\n        try:\n            symbol_count += len(layer.renderer().legendSymbolItems())\n            continue\n        except Exception:  # pylint: disable=broad-except\n            pass\n        symbol_count += 1\n\n    legend_title = provenance.get('map_legend_title') or ''\n\n    map_legends = [\n        {\n            'id': 'impact-legend',\n            'title': legend_title,\n            'layers': layers,\n            'symbol_count': symbol_count,\n            # 'column_count': 2,  # the number of column in legend display\n        }\n    ]\n    context.map_legends = map_legends\n\n    # process substitution map\n    start_datetime = provenance['start_datetime']\n    \"\"\":type: datetime.datetime\"\"\"\n    date_format = resolve_from_dictionary(extra_args, 'date-format')\n    time_format = resolve_from_dictionary(extra_args, 'time-format')\n    if isinstance(start_datetime, datetime.datetime):\n        date = start_datetime.strftime(date_format)\n        time = start_datetime.strftime(time_format)\n    else:\n        date = ''\n        time = ''\n    long_version = get_version()\n    tokens = long_version.split('.')\n    version = '%s.%s.%s' % (tokens[0], tokens[1], tokens[2])\n    # Get title of the layer\n    title = provenance.get('map_title') or ''\n\n    # Set source\n    unknown_source_text = resolve_from_dictionary(\n        extra_args, ['defaults', 'unknown_source'])\n    aggregation_not_used = resolve_from_dictionary(\n        extra_args, ['defaults', 'aggregation_not_used'])\n\n    hazard_source = (\n        provenance.get(\n            'hazard_keywords', {}).get('source') or unknown_source_text)\n    exposure_source = (\n        provenance.get(\n            'exposure_keywords', {}).get('source') or unknown_source_text)\n    if provenance['aggregation_layer']:\n        aggregation_source = (\n            provenance['aggregation_keywords'].get('source')\n            or unknown_source_text)\n    else:\n        aggregation_source = aggregation_not_used\n\n    spatial_reference_format = resolve_from_dictionary(\n        extra_args, 'spatial-reference-format')\n    reference_name = spatial_reference_format.format(\n        crs=impact_report.impact_function.crs.authid())\n\n    analysis_layer = impact_report.analysis\n    analysis_name = value_from_field_name(\n        analysis_name_field['field_name'], analysis_layer)\n\n    # Prepare the substitution map\n    version_title = resolve_from_dictionary(extra_args, 'version-title')\n    disclaimer_title = resolve_from_dictionary(extra_args, 'disclaimer-title')\n    date_title = resolve_from_dictionary(extra_args, 'date-title')\n    time_title = resolve_from_dictionary(extra_args, 'time-title')\n    caution_title = resolve_from_dictionary(extra_args, 'caution-title')\n    caution_text = resolve_from_dictionary(extra_args, 'caution-text')\n    version_text = resolve_from_dictionary(extra_args, 'version-text')\n    legend_section_title = resolve_from_dictionary(\n        extra_args, 'legend-title')\n    information_title = resolve_from_dictionary(\n        extra_args, 'information-title')\n    supporters_title = resolve_from_dictionary(\n        extra_args, 'supporters-title')\n    source_title = resolve_from_dictionary(extra_args, 'source-title')\n    analysis_title = resolve_from_dictionary(extra_args, 'analysis-title')\n    reference_title = resolve_from_dictionary(\n        extra_args, 'spatial-reference-title')\n    substitution_map = {\n        'impact-title': title,\n        'date': date,\n        'time': time,\n        'safe-version': version,  # deprecated\n        'disclaimer': inasafe_context.disclaimer,\n        # These added in 3.2\n        'version-title': version_title,\n        'inasafe-version': version,\n        'disclaimer-title': disclaimer_title,\n        'date-title': date_title,\n        'time-title': time_title,\n        'caution-title': caution_title,\n        'caution-text': caution_text,\n        'version-text': version_text.format(version=version),\n        'legend-title': legend_section_title,\n        'information-title': information_title,\n        'supporters-title': supporters_title,\n        'source-title': source_title,\n        'analysis-title': analysis_title,\n        'analysis-name': analysis_name,\n        'reference-title': reference_title,\n        'reference-name': reference_name,\n        'hazard-source': hazard_source,\n        'exposure-source': exposure_source,\n        'aggregation-source': aggregation_source,\n    }\n    context.substitution_map = substitution_map\n    return context", "response": "This method extracts the necessary context for a given impact report and component metadata and saves it in the output dictionary so it can be used in composer phase."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef qgis_composer_infographic_extractor(impact_report, component_metadata):\n    qgis_context = impact_report.qgis_composition_context\n    extra_args = component_metadata.extra_args\n\n    context = QGISComposerContext()\n\n    \"\"\"Image Elements.\"\"\"\n\n    # get all image elements with their respective source path\n    image_elements = deepcopy(image_item_elements)\n\n    # remove inasafe_logo_white because we use expression for the image source\n    image_elements.remove(inasafe_logo_white)\n    # remove population_chart because we still don't have the source path\n    image_elements.remove(population_chart)\n    context.image_elements = image_elements\n\n    # get the source path of population_chart\n    population_donut_path = impact_report.component_absolute_output_path(\n        'population-chart-png')\n    population_chart['path'] = population_donut_path\n\n    context.image_elements.append(population_chart)\n\n    \"\"\"HTML Elements.\"\"\"\n\n    components = resolve_from_dictionary(extra_args, 'components')\n    html_elements = deepcopy(html_frame_elements)\n\n    # get the html content from component that has been proceed\n    for element in html_elements:\n        component = components.get(element['component'])\n        if component:\n            element['text'] = jinja2_output_as_string(\n                impact_report, component['key'])\n\n    context.html_frame_elements = html_elements\n\n    \"\"\"Map Elements.\"\"\"\n\n    map_overview_layer = None\n    project = QgsProject.instance()\n    for layer in list(project.mapLayers().values()):\n        if layer.name() == map_overview['id']:\n            map_overview_layer = layer\n\n    layers = [impact_report.impact_function.analysis_impacted]\n\n    if map_overview_layer:\n        layers.append(map_overview_layer)\n\n    # default extent is analysis extent\n    if not qgis_context.extent:\n        qgis_context.extent = impact_report.impact_function.analysis_extent\n\n    map_elements = [\n        {\n            'id': 'map-overview',\n            'extent': qgis_context.extent,\n            'grid_split_count': 5,\n            'layers': layers,\n        }\n    ]\n\n    context.map_elements = map_elements\n\n    return context", "response": "Extract composer context specific for infographic template."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_next_step(self):\n        layer_purpose = self.parent.step_kw_purpose.selected_purpose()\n        if layer_purpose['key'] != layer_purpose_aggregation['key']:\n            subcategory = self.parent.step_kw_subcategory. \\\n                selected_subcategory()\n        else:\n            subcategory = {'key': None}\n\n        # We don't use field mapping for populated place exposure. Use the\n        # population point instead.\n\n        # inasafe_fields = self.get_inasafe_fields()\n        # If population field is set, must go to field mapping step first.\n        # if population_count_field['key'] in inasafe_fields.keys():\n        #     return self.parent.step_kw_fields_mapping\n\n        # Check if it can go to inasafe default field step\n        default_inasafe_fields = get_fields(\n            layer_purpose['key'],\n            subcategory['key'],\n            replace_null=True,\n            in_group=False)\n        if default_inasafe_fields:\n            return self.parent.step_kw_default_inasafe_fields\n\n        # Any other case\n        return self.parent.step_kw_source", "response": "Find the proper step when user clicks the Next button."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef inasafe_fields_for_the_layer(self):\n        if (self.parent.get_layer_geometry_key()\n                == layer_geometry_raster['key']):\n            return []\n        # Get hazard or exposure value\n        layer_purpose_key = self.parent.step_kw_purpose.selected_purpose()[\n            'key']\n        if layer_purpose_key != layer_purpose_aggregation['key']:\n            subcategory_key = self.parent.step_kw_subcategory.\\\n                selected_subcategory()['key']\n        else:\n            subcategory_key = None\n        # Get all fields with replace_null = False\n        inasafe_fields = get_fields(\n            layer_purpose_key,\n            subcategory_key,\n            replace_null=False,\n            in_group=False)\n        # remove compulsory field since it has been set in previous step\n        try:\n            inasafe_fields.remove(get_compulsory_fields(\n                layer_purpose_key, subcategory_key))\n        except ValueError:\n            pass\n        return inasafe_fields", "response": "Return a list of inasafe fields the current layer."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset widgets on the Extra Keywords tab.", "response": "def set_widgets(self):\n        \"\"\"Set widgets on the Extra Keywords tab.\"\"\"\n        existing_inasafe_field = self.parent.get_existing_keyword(\n            'inasafe_fields')\n        # Remove old container and parameter\n        if self.parameter_container:\n            self.kwExtraKeywordsGridLayout.removeWidget(\n                self.parameter_container)\n        if self.parameters:\n            self.parameters = []\n\n        # Iterate through all inasafe fields\n        for inasafe_field in self.inasafe_fields_for_the_layer():\n            # Option for Not Available\n            option_list = [no_field]\n            for field in self.parent.layer.fields():\n                # Check the field type\n                if isinstance(inasafe_field['type'], list):\n                    if field.type() in inasafe_field['type']:\n                        field_name = field.name()\n                        option_list.append('%s' % field_name)\n                else:\n                    if field.type() == inasafe_field['type']:\n                        field_name = field.name()\n                        option_list.append('%s' % field_name)\n\n            # If there is no option, pass\n            if option_list == [no_field]:\n                continue\n\n            # Create SelectParameter\n            select_parameter = SelectParameter()\n            select_parameter.guid = inasafe_field['key']\n            select_parameter.name = inasafe_field['name']\n            select_parameter.is_required = False\n            select_parameter.description = inasafe_field['description']\n            select_parameter.help_text = inasafe_field['help_text']\n            select_parameter.element_type = str\n            select_parameter.options_list = option_list\n            select_parameter.value = no_field\n            # Check if there is already value in the metadata.\n            if existing_inasafe_field:\n                existing_value = existing_inasafe_field.get(\n                    inasafe_field['key'])\n                if existing_value:\n                    if existing_value in select_parameter.options_list:\n                        select_parameter.value = existing_value\n\n            self.parameters.append(select_parameter)\n\n        # Create the parameter container and add to the wizard.\n        self.parameter_container = ParameterContainer(self.parameters)\n        self.parameter_container.setup_ui()\n        self.kwExtraKeywordsGridLayout.addWidget(self.parameter_container)\n\n        if not self.parameters:\n            no_field_message = tr(\n                'There is no available field that has match type for the '\n                'InaSAFE fields. You can click next.')\n            self.lblInaSAFEFields.setText(no_field_message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __if_not_basestring(text_object):\n    converted_str = text_object\n    if not isinstance(text_object, str):\n        converted_str = str(text_object)\n    return converted_str", "response": "Convert to str if object is not a string"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_unicode(input_text, encoding='utf-8'):\n    if isinstance(input_text, str):\n        return input_text\n    return str(input_text, encoding, errors='ignore')", "response": "Get the unicode representation of an object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the byte string representation of an object.", "response": "def get_string(input_text, encoding='utf-8'):\n    \"\"\"Get byte string representation of an object.\n\n    :param input_text:  The input text.\n    :type input_text: unicode, str, float, int\n\n    :param encoding: The encoding used to do the conversion, default to utf-8.\n    :type encoding: str\n\n    :returns: Byte string representation of the input.\n    :rtype: bytes\n    \"\"\"\n    if isinstance(input_text, str):\n        return input_text.encode(encoding)\n    return input_text"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef byteify(input_object):\n    if isinstance(input_object, dict):\n        return {byteify(key): byteify(value)\n                for key, value in list(input_object.items())}\n    elif isinstance(input_object, list):\n        return [byteify(element) for element in input_object]\n    elif isinstance(input_object, str):\n        return input_object.encode('utf-8')\n    else:\n        return input_object", "response": "Recursive function to transform an object such as unicode dictionary or list to byte only."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the dictionary representation of the metadata object", "response": "def dict(self):\n        \"\"\"\n        calls the overridden method and adds provenance and summary data\n\n        :return: dictionary representation of the metadata\n        :rtype: dict\n        \"\"\"\n        metadata = super(ImpactLayerMetadata, self).dict\n\n        metadata['provenance'] = self.provenance\n        metadata['summary_data'] = self.summary_data\n\n        return metadata"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads metadata from json and set all the found properties", "response": "def read_json(self):\n        \"\"\"\n        read metadata from json and set all the found properties.\n\n        :return: the read metadata\n        :rtype: dict\n        \"\"\"\n        with reading_ancillary_files(self):\n            metadata = super(ImpactLayerMetadata, self).read_json()\n            if 'provenance' in metadata:\n                for provenance_step in metadata['provenance']:\n                    try:\n                        title = provenance_step['title']\n                        if 'IF Provenance' in title:\n                            self.append_if_provenance_step(\n                                provenance_step['title'],\n                                provenance_step['description'],\n                                provenance_step['time'],\n                                provenance_step['data']\n                            )\n                        else:\n                            self.append_provenance_step(\n                                provenance_step['title'],\n                                provenance_step['description'],\n                                provenance_step['time'],\n                            )\n                    except KeyError:\n                        # we want to get as much as we can without raising\n                        # errors\n                        pass\n            if 'summary_data' in metadata:\n                self.summary_data = metadata['summary_data']\n\n        return metadata"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the xml representation of the metadata.", "response": "def xml(self):\n        \"\"\"\n        xml representation of the metadata.\n\n        :return: xml representation of the metadata\n        :rtype: str\n        \"\"\"\n\n        root = super(ImpactLayerMetadata, self).xml\n        provenance_path = self._special_properties['provenance']\n        provenance_element = root.find(provenance_path, XML_NS)\n\n        # find the provenance parent tag\n        if provenance_element is not None:\n            # there is already a provenance tag so we remove it\n            provenance_parent = provenance_element.getparent()\n            provenance_parent.remove(provenance_element)\n        else:\n            # find the parent using the provenance path minus one level\n            provenance_parent = '/'.join(provenance_path.split('/')[:-1])\n            provenance_parent = root.find(provenance_parent, XML_NS)\n\n        # generate the provenance xml element\n        provenance_element = ElementTree.fromstring(self.provenance.xml)\n        provenance_parent.append(provenance_element)\n        return prettify_xml(ElementTree.tostring(root, 'unicode'))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_xml(self):\n\n        with reading_ancillary_files(self):\n            root = super(ImpactLayerMetadata, self).read_xml()\n            if root is not None:\n                self._read_provenance_from_xml(root)\n        return root", "response": "read metadata from xml and set all the found properties."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _read_provenance_from_xml(self, root):\n        path = self._special_properties['provenance']\n        provenance = root.find(path, XML_NS)\n        for step in provenance.iter('provenance_step'):\n            title = step.find('title').text\n            description = step.find('description').text\n            timestamp = step.get('timestamp')\n\n            if 'IF Provenance' in title:\n                data = {}\n                from safe.metadata35.provenance import IFProvenanceStep\n                keys = IFProvenanceStep.impact_functions_fields\n                for key in keys:\n                    value = step.find(key)\n                    if value is not None:\n                        data[key] = value.text\n                    else:\n                        data[key] = ''\n                self.append_if_provenance_step(\n                    title, description, timestamp, data)\n            else:\n                self.append_provenance_step(title, description, timestamp)", "response": "read metadata provenance from xml."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a step to the provenance of the metadata.", "response": "def append_provenance_step(self, title, description, timestamp=None):\n        \"\"\"\n        Add a step to the provenance of the metadata\n\n        :param title: The title of the step.\n        :type title: str\n\n        :param description: The content of the step\n        :type description: str\n\n        :param timestamp: the time of the step\n        :type timestamp: datetime, str\n        \"\"\"\n        step_time = self._provenance.append_step(title, description, timestamp)\n        if step_time > self.last_update:\n            self.last_update = step_time"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a new if provenance step to the provenance of the metadata.", "response": "def append_if_provenance_step(\n            self, title, description, timestamp=None, data=None):\n        \"\"\"Add a if provenance step to the provenance of the metadata\n\n        :param title: The title of the step.\n        :type title: str\n\n        :param description: The content of the step\n        :type description: str\n\n        :param timestamp: the time of the step\n        :type timestamp: datetime, str\n\n        :param data: The data of the step.\n        :type data: dict\n        \"\"\"\n        step_time = self._provenance.append_if_provenance_step(\n            title, description, timestamp, data)\n        if step_time > self.last_update:\n            self.last_update = step_time"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the metadata value from a keywords dictionary.", "response": "def update_from_dict(self, keywords):\n        \"\"\"Update metadata value from a keywords dictionary.\n\n        :param keywords:\n        :return:\n        \"\"\"\n        super(ImpactLayerMetadata, self).update_from_dict(keywords)\n\n        if 'if_provenance' in list(keywords.keys()):\n            if_provenance = keywords['if_provenance']\n            for provenance_step in if_provenance:\n                self.provenance.append_provenance_step(provenance_step)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a Text MessageElement to the existing TextMessageElement", "response": "def add(self, text):\n        \"\"\"add a Text MessageElement to the existing Text\n\n        Strings can be passed and are automatically converted in to\n        item.Text()\n\n        :param text: An element to add to the text.\n        :type text: str\n        \"\"\"\n        if self._is_stringable(text) or self._is_qstring(text):\n            self.text.append(PlainText(text))\n        elif isinstance(text, Text):\n            self.text.append(text)\n        elif text is None or (hasattr(text, 'isNull') and text.isNull()):\n            self.text.append(PlainText(\n                tr('None or Null found from the data.')))\n        else:\n            raise InvalidMessageItemError(text, text.__class__)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrendering a Text MessageElement as html.", "response": "def to_html(self, wrap_slash=False):\n        \"\"\"Render a Text MessageElement as html.\n\n        :param wrap_slash: Whether to replace slashes with the slash plus the\n            html <wbr> tag which will help to e.g. wrap html in small cells if\n            it contains a long filename. Disabled by default as it may cause\n            side effects if the text contains html markup.\n        :type wrap_slash: bool\n\n        :returns: Html representation of the Text MessageElement.\n        :rtype: str\n\n        \"\"\"\n        if self.text is None:\n            return\n        else:\n            text = ''\n            for t in self.text:\n                text += t.to_html() + ' '\n            text = ' '.join(text.split())\n        if wrap_slash:\n            # This is a hack to make text wrappable with long filenames TS 3.3\n            text = text.replace('/', '/<wbr>')\n            text = text.replace('\\\\', '\\\\<wbr>')\n        return text"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrender a Text MessageElement as plain text", "response": "def to_text(self):\n        \"\"\"Render a Text MessageElement as plain text\n\n        :returns: Text representation of the Text MessageElement.\n        :rtype: str\n        \"\"\"\n        if self.text is None:\n            return\n        else:\n            text = ''\n            for t in self.text:\n                text += t.to_text() + ' '\n            return ' '.join(text.split())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrender a MessageElement as python dict representation", "response": "def to_dict(self):\n        \"\"\"Render a MessageElement as python dict\n\n        :return: Python dict representation\n        :rtype: dict\n        \"\"\"\n        obj_dict = super(Text, self).to_dict()\n        texts_dict = None\n        if isinstance(self.text, list):\n            texts_dict = [t.to_dict() for t in self.text]\n        child_dict = {\n            'type': self.__class__.__name__,\n            'text': texts_dict\n        }\n        obj_dict.update(child_dict)\n        return obj_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrenders as html Args: None Returns: Str the html representation Raises: Errors are propagated", "response": "def to_html(self):\n        \"\"\"Render as html\n\n        Args:\n            None\n\n        Returns:\n            Str the html representation\n\n        Raises:\n            Errors are propagated\n        \"\"\"\n        icon = self.html_icon()\n        attributes = self.html_attributes()\n        # Deal with long file names that prevent wrapping\n        wrappable_text = self.to_text().replace(os.sep, '<wbr>' + os.sep)\n        if icon is not '' and attributes is not '':\n            return '<span%s>%s%s</span>' % (attributes, icon, wrappable_text)\n        else:\n            return self.to_text()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_dict(self):\n        obj_dict = super(PlainText, self).to_dict()\n        child_dict = {\n            'type': self.__class__.__name__,\n            'text': self.text\n        }\n        obj_dict.update(child_dict)\n        return obj_dict", "response": "Render a MessageElement as python dict representation"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhelps message for Batch Dialog.", "response": "def needs_manager_helps():\n    \"\"\"Help message for Batch Dialog.\n\n    .. versionadded:: 3.2.1\n\n    :returns: A message object containing helpful information.\n    :rtype: messaging.message.Message\n    \"\"\"\n\n    message = m.Message()\n    message.add(m.Brand())\n    message.add(heading())\n    message.add(content())\n    return message"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef content():\n    message = m.Message()\n    paragraph = m.Paragraph(\n        m.Image(\n            'file:///%s/img/screenshots/'\n            'minimum-needs-screenshot.png' % resources_path()),\n        style_class='text-center'\n    )\n    message.add(paragraph)\n    message.add(m.Paragraph(tr(\n        'During and after a disaster, providing for the basic human minimum '\n        'needs of food, water, hygiene and shelter is an important element of '\n        'your contingency plan. InaSAFE has a customisable minimum needs '\n        'system that allows you to define country or region specific '\n        'requirements for compiling a needs report where the exposure '\n        'layer represents population.'\n    )))\n    message.add(m.Paragraph(tr(\n        'By default InaSAFE uses minimum needs defined for Indonesia - '\n        'and ships with additional profiles for the Philippines and Tanzania. '\n        'You can customise these or add your own region-specific profiles too.'\n\n    )))\n    message.add(m.Paragraph(tr(\n        'Minimum needs are grouped into regional or linguistic \\'profiles\\'. '\n        'The default profile is \\'BNPB_en\\' - the english profile for the '\n        'national disaster agency in Indonesia. '\n        'You will see that this profile defines requirements for displaced '\n        'persons in terms of Rice, Drinking Water, Clean Water (for bathing '\n        'etc.), Family Kits (with personal hygiene items) and provision of '\n        'toilets.'\n    )))\n    message.add(m.Paragraph(tr(\n        'Each item in the profile can be customised or removed. For example '\n        'selecting the first item in the list and then clicking on the '\n        '\\'pencil\\' icon will show the details of how it was defined. '\n        'If you scroll up and down in the panel you will see that for each '\n        'item, you can set a name, description, units (in singular, '\n        'plural and abbreviated forms), specify maxima and minima for the '\n        'quantity of item allowed, a default and a frequency. You would use '\n        'the maxima and minima to ensure that disaster managers never '\n        'allocate amounts that will not be sufficient for human livelihood, '\n        'and also that will not overtax the logistics operation for those '\n        'providing humanitarian relief.'\n    )))\n    message.add(m.Paragraph(tr(\n        'The final item in the item configuration is the \\'readable '\n        'sentence\\' which bears special discussion. Using a simple system of '\n        'tokens you can construct a sentence that will be used in the '\n        'generated needs report.'\n    )))\n    message.add(m.Heading(tr('Minimum needs profiles'), **INFO_STYLE))\n    message.add(m.Paragraph(tr(\n        'A profile is a collection of resources that define the minimum needs '\n        'for a particular country or region. Typically a profile should be '\n        'based on a regional, national or international standard. The '\n        'actual definition of which resources are needed in a given '\n        'profile is dependent on the local conditions and customs for the '\n        'area where the contingency plan is being devised.'\n    )))\n    message.add(m.Paragraph(tr(\n        'For example in the middle east, rice is a staple food whereas in '\n        'South Africa, maize meal is a staple food and thus the contingency '\n        'planning should take these localised needs into account.'\n    )))\n\n    message.add(m.Heading(tr('Minimum needs resources'), **INFO_STYLE))\n    message.add(m.Paragraph(tr(\n        'Each item in a minimum needs profile is a resource. Each resource '\n        'is described as a simple natural language sentence e.g.:'\n    )))\n\n    message.add(m.EmphasizedText(tr(\n        'Each person should be provided with 2.8 kilograms of Rice weekly.'\n    )))\n    message.add(m.Paragraph(tr(\n        'By clicking on a resource entry in the profile window, and then '\n        'clicking the black pencil icon you will be able to edit the '\n        'resource using the resource editor. Alternatively you can create a '\n        'new resource for a profile by clicking on the black + icon in '\n        'the profile manager. You can also remove any resource from a '\n        'profile using the - icon in the profile manager.')))\n\n    message.add(m.Heading(tr('Resource Editor'), **INFO_STYLE))\n    message.add(m.Paragraph(tr(\n        'When switching to edit or add resource mode, the minimum needs '\n        'manager will be updated to show the resource editor. Each '\n        'resource is described in terms of:'\n    )))\n    bullets = m.BulletedList()\n    bullets.add(m.Text(\n        m.ImportantText(tr(\n            'resource name')),\n        tr(' - e.g. Rice')))\n    bullets.add(m.Text(\n        m.ImportantText(tr(\n            'a description of the resource')),\n        tr(' - e.g. Basic food')))\n    bullets.add(m.Text(\n        m.ImportantText(tr(\n            'unit in which the resource is provided')),\n        tr(' - e.g. kilogram')))\n    bullets.add(m.Text(\n        m.ImportantText(tr(\n            'pluralised form of the units')),\n        tr(' - e.g. kilograms')))\n    bullets.add(m.Text(\n        m.ImportantText(tr(\n            'abbreviation for the unit')),\n        tr(' - e.g. kg')))\n    bullets.add(m.Text(\n        m.ImportantText(tr(\n            'the default allocation for the resource')),\n        tr(' - e.g. 2.8. This number can be overridden on a '\n           'per-analysis basis')))\n    bullets.add(m.Text(\n        m.ImportantText(tr(\n            'minimum allowed which is used to prevent allocating')),\n        tr(' - e.g. no drinking water to displaced persons')))\n    bullets.add(m.ImportantText(tr(\n        'maximum allowed which is used to set a sensible upper '\n        'limit for the resource')))\n    bullets.add(m.ImportantText(tr(\n        'a readable sentence which is used to compile the '\n        'sentence describing the resource in reports.')))\n    message.add(bullets)\n\n    message.add(m.Paragraph(tr(\n        'These parameters are probably all fairly self explanatory, but '\n        'the readable sentence probably needs further detail. The '\n        'sentence is compiled using a simple keyword token replacement '\n        'system. The following tokens can be used:')))\n\n    bullets = m.BulletedList()\n    bullets.add(m.Text('{{ Default }}'))\n    bullets.add(m.Text('{{ Unit }}'))\n    bullets.add(m.Text('{{ Units }}'))\n    bullets.add(m.Text('{{ Unit abbreviation }}'))\n    bullets.add(m.Text('{{ Resource name }}'))\n    bullets.add(m.Text('{{ Frequency }}'))\n    bullets.add(m.Text('{{ Minimum allowed }}'))\n    bullets.add(m.Text('{{ Maximum allowed }}'))\n    message.add(bullets)\n\n    message.add(m.Paragraph(tr(\n        'When the token is placed in the sentence it will be replaced with '\n        'the actual value at report generation time. This contrived example '\n        'shows a tokenised sentence that includes all possible keywords:'\n    )))\n\n    message.add(m.EmphasizedText(tr(\n        'A displaced person should be provided with {{ %s }} '\n        '{{ %s }}/{{ %s }}/{{ %s }} of {{ %s }}. Though no less than {{ %s }} '\n        'and no more than {{ %s }}. This should be provided {{ %s }}.' % (\n            'Default',\n            'Unit',\n            'Units',\n            'Unit abbreviation',\n            'Resource name',\n            'Minimum allowed',\n            'Maximum allowed',\n            'Frequency'\n        )\n    )))\n    message.add(m.Paragraph(tr(\n        'Would generate a human readable sentence like this:')))\n\n    message.add(m.ImportantText(tr(\n        'A displaced person should be provided with 2.8 kilogram/kilograms/kg '\n        'of rice. Though no less than 0 and no more than 100. This should '\n        'be provided daily.'\n    )))\n    message.add(m.Paragraph(tr(\n        'Once you have populated the resource elements, click the Save '\n        'resource button to return to the profile view. You will see the '\n        'new resource added in the profile\\'s resource list.'\n    )))\n\n    message.add(m.Heading(tr('Managing profiles'), **INFO_STYLE))\n    message.add(m.Paragraph(tr(\n        'In addition to the profiles that come as standard with InaSAFE, you '\n        'can create new ones, either from scratch, or based on an existing '\n        'one (which you can then modify).'\n    )))\n    message.add(m.Paragraph(tr(\n        'Use the New button to create new profile. When prompted, give your '\n        'profile a name e.g. \\'JakartaProfile\\'.'\n    )))\n    message.add(m.Paragraph(tr(\n        'Note: The profile must be saved in your home directory under '\n        '(QGIS profile path)/minimum_needs in order '\n        'for InaSAFE to successfully '\n        'detect it.'\n    )))\n    message.add(m.Paragraph(tr(\n        'An alternative way to create a new profile is to use the Save as to '\n        'clone an existing profile. The clone profile can then be edited '\n        'according to your specific needs.'\n    )))\n    message.add(m.Heading(tr('Active profile'), **INFO_STYLE))\n    message.add(m.Paragraph(tr(\n        'It is important to note, that which ever profile you select in the '\n        'Profile pick list, will be considered active and will be used as '\n        'the basis for all minimum needs analysis. You need to restart '\n        'QGIS before the changed profile become active.'\n    )))\n    return message", "response": "Helper method that returns just the content of the current item."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_parameter(self):\n        # Set value for each key\n        for key, value in list(self._parameter.options.items()):\n            if value.get('type') == STATIC:\n                continue\n            elif value.get('type') == SINGLE_DYNAMIC:\n                new_value = self.spin_boxes.get(key).value()\n                self._parameter.set_value_for_key(key, new_value)\n            elif value.get('type') == MULTIPLE_DYNAMIC:\n                # Need to iterate through all items\n                items = []\n                for index in range(self.list_widget.count()):\n                    items.append(self.list_widget.item(index))\n                new_value = [i.text() for i in items]\n                self._parameter.set_value_for_key(key, new_value)\n\n        # Get selected radio button\n        radio_button_checked_id = self.input_button_group.checkedId()\n        # No radio button checked, then default value = None\n        if radio_button_checked_id == -1:\n            self._parameter.selected = None\n        else:\n            self._parameter.selected = list(self._parameter.options.keys())[\n                radio_button_checked_id]\n\n        return self._parameter", "response": "Obtain the list parameter object from the current state of widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates list widget when radio button is clicked.", "response": "def update_list_widget(self):\n        \"\"\"Update list widget when radio button is clicked.\"\"\"\n        # Get selected radio button\n        radio_button_checked_id = self.input_button_group.checkedId()\n        # No radio button checked, then default value = None\n        if radio_button_checked_id > -1:\n            selected_dict = list(self._parameter.options.values())[\n                radio_button_checked_id]\n            if selected_dict.get('type') == MULTIPLE_DYNAMIC:\n                for field in selected_dict.get('value'):\n                    # Update list widget\n                    field_item = QListWidgetItem(self.list_widget)\n                    field_item.setFlags(\n                        Qt.ItemIsEnabled\n                        | Qt.ItemIsSelectable\n                        | Qt.ItemIsDragEnabled)\n                    field_item.setData(Qt.UserRole, field)\n                    field_item.setText(field)\n                    self.list_widget.addItem(field_item)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef radio_buttons_clicked(self):\n        # Disable all spin boxes\n        for spin_box in list(self.spin_boxes.values()):\n            spin_box.setEnabled(False)\n        # Disable list widget\n        self.list_widget.setEnabled(False)\n\n        # Get selected radio button\n        radio_button_checked_id = self.input_button_group.checkedId()\n\n        if radio_button_checked_id > -1:\n            selected_value = list(self._parameter.options.values())[\n                radio_button_checked_id]\n            if selected_value.get('type') == MULTIPLE_DYNAMIC:\n                # Enable list widget\n                self.list_widget.setEnabled(True)\n            elif selected_value.get('type') == SINGLE_DYNAMIC:\n                selected_key = list(self._parameter.options.keys())[\n                    radio_button_checked_id]\n                self.spin_boxes[selected_key].setEnabled(True)", "response": "Handler when selected radio button changed."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mmi_detail_extractor(impact_report, component_metadata):\n    context = {}\n    analysis_layer = impact_report.analysis\n    analysis_layer_keywords = analysis_layer.keywords\n    extra_args = component_metadata.extra_args\n    use_rounding = impact_report.impact_function.use_rounding\n    provenance = impact_report.impact_function.provenance\n    hazard_keywords = provenance['hazard_keywords']\n    exposure_keywords = provenance['exposure_keywords']\n\n    # check if this is EQ raster with population\n    hazard_type = definition(hazard_keywords['hazard'])\n    if not hazard_type == hazard_earthquake:\n        return context\n\n    hazard_geometry = hazard_keywords[layer_geometry['key']]\n    if not hazard_geometry == layer_geometry_raster['key']:\n        return context\n\n    exposure_type = definition(exposure_keywords['exposure'])\n    if not exposure_type == exposure_population:\n        return context\n\n    header = resolve_from_dictionary(extra_args, 'header')\n\n    context['header'] = header\n\n    reported_fields = resolve_from_dictionary(extra_args, 'reported_fields')\n\n    \"\"\"Generate headers.\"\"\"\n    table_header = [\n        resolve_from_dictionary(extra_args, 'mmi_header')\n    ] + [v['header'] for v in reported_fields]\n\n    \"\"\"Extract MMI-related data\"\"\"\n    # mmi is ranged from 1 to 10, which means: [1, 11)\n    mmi_range = list(range(1, 11))\n    rows = []\n    roman_numeral = [\n        'I',\n        'II',\n        'III',\n        'IV',\n        'V',\n        'VI',\n        'VII',\n        'VIII',\n        'IX',\n        'X'\n    ]\n    for i in mmi_range:\n        columns = [roman_numeral[i - 1]]\n        for value in reported_fields:\n            field = value['field']\n            try:\n                key_name = field['key'] % (i, )\n                field_name = analysis_layer_keywords[key_name]\n                # check field exists\n                count = value_from_field_name(field_name, analysis_layer)\n                if not count:\n                    count = 0\n            except KeyError:\n                count = 0\n            count = format_number(\n                count,\n                use_rounding=use_rounding,\n                is_population=True)\n            columns.append(count)\n\n        rows.append(columns)\n\n    \"\"\"Extract total.\"\"\"\n    total_footer = [\n        resolve_from_dictionary(extra_args, 'total_header')\n    ]\n\n    total_fields = resolve_from_dictionary(extra_args, 'total_fields')\n    for field in total_fields:\n        try:\n            field_name = analysis_layer_keywords[field['key']]\n            total = value_from_field_name(field_name, analysis_layer)\n            if not total:\n                total = 0\n        except KeyError:\n            total = 0\n        total = format_number(\n            total,\n            use_rounding=use_rounding,\n            is_population=True)\n        total_footer.append(total)\n\n    context['component_key'] = component_metadata.key\n    context['mmi'] = {\n        'header': table_header,\n        'rows': rows,\n        'footer': total_footer\n    }\n\n    return context", "response": "This function extracts MMI - related analysis result."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef xml(self):\n\n        xml = self._get_xml(False)\n        for key in self.impact_functions_fields:\n            value = str(self.data(key))\n            element = Element(key)\n            element.text = value\n\n            xml += tostring(element, 'unicode')\n\n        xml += '</provenance_step>'\n        return xml", "response": "the xml string representation of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve a header name of the field name from definitions.", "response": "def inasafe_field_header(field, feature, parent):\n    \"\"\"Retrieve a header name of the field name from definitions.\n\n    For instance:\n    inasafe_field_header('minimum_needs__clean_water') -> 'Clean water'\n    \"\"\"\n    _ = feature, parent  # NOQA\n    age_fields = [under_5_displaced_count_field, over_60_displaced_count_field]\n    symbol_mapping = {\n        'over': '>',\n        'under': '<'\n    }\n\n    field_definition = definition(field, 'field_name')\n    if field_definition:\n        if field_definition in age_fields:\n            header_format = tr('{symbol} {age} y.o')\n            field_name = field_definition.get('field_name')\n            if field_name:\n                symbol, age = field_name.split('_')[:2]\n                if symbol.lower() in list(symbol_mapping.keys()):\n                    header_name = header_format.format(\n                        symbol=symbol_mapping[symbol.lower()],\n                        age=age\n                    )\n                    return header_name\n\n        header_name = field_definition.get('header_name')\n        name = field_definition.get('name')\n        if header_name:\n            return header_name.capitalize()\n        else:\n            return name.capitalize()\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef minimum_needs_unit(field, feature, parent):\n    _ = feature, parent  # NOQA\n    field_definition = definition(field, 'field_name')\n    if field_definition:\n        unit_abbreviation = None\n        frequency = None\n        if field_definition.get('need_parameter'):\n            need = field_definition['need_parameter']\n            if isinstance(need, ResourceParameter):\n                unit_abbreviation = need.unit.abbreviation\n                frequency = need.frequency\n        elif field_definition.get('unit'):\n            need_unit = field_definition.get('unit')\n            unit_abbreviation = need_unit.get('abbreviation')\n\n        if field_definition.get('frequency') and not frequency:\n            frequency = field_definition.get('frequency')\n\n        if not unit_abbreviation:\n            unit_abbreviation = exposure_unit['plural_name']\n\n        once_frequency_field_keys = [\n            'minimum_needs__toilets_count_field'\n        ]\n        if not frequency or (\n                field_definition['key'] in once_frequency_field_keys):\n            return unit_abbreviation.lower()\n\n        unit_format = '{unit_abbreviation}/{frequency}'\n        return unit_format.format(\n            unit_abbreviation=unit_abbreviation, frequency=frequency).lower()\n\n    return None", "response": "Retrieve units of the given minimum needs field name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a formatted infographic header sentence for an impact function.", "response": "def infographic_header_element(impact_function_name, feature, parent):\n    \"\"\"Get a formatted infographic header sentence for an impact function.\n\n    For instance:\n    * infographic_header_element('flood') -> 'Estimated impact of a flood'\n    \"\"\"\n    _ = feature, parent  # NOQA\n    string_format = infographic_header['string_format']\n    if impact_function_name:\n        header = string_format.format(\n            impact_function_name=impact_function_name)\n        return header.capitalize()\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef map_overview_header_element(feature, parent):\n    _ = feature, parent  # NOQA\n    header = map_overview_header['string_format']\n    return header.capitalize()", "response": "Retrieve map overview header string from definitions."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef population_chart_header_element(feature, parent):\n    _ = feature, parent  # NOQA\n    header = population_chart_header['string_format']\n    return header.capitalize()", "response": "Retrieve population chart header string from definitions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef people_section_header_element(feature, parent):\n    _ = feature, parent  # NOQA\n    header = people_section_header['string_format']\n    return header.capitalize()", "response": "Retrieve people section header string from definitions."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef age_gender_section_header_element(feature, parent):\n    _ = feature, parent  # NOQA\n    header = age_gender_section_header['string_format']\n    return header.capitalize()", "response": "Retrieve age gender section header string from definitions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve vulnerability section header string from definitions.", "response": "def vulnerability_section_header_element(feature, parent):\n    \"\"\"Retrieve vulnerability section header string from definitions.\"\"\"\n    _ = feature, parent  # NOQA\n    header = vulnerability_section_header['string_format']\n    return header.capitalize()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef female_vulnerability_section_header_element(feature, parent):\n    _ = feature, parent  # NOQA\n    header = female_vulnerability_section_header['string_format']\n    return header.capitalize()", "response": "Retrieve female vulnerability section header string from definitions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving minimum needs section header string from definitions.", "response": "def minimum_needs_section_header_element(feature, parent):\n    \"\"\"Retrieve minimum needs section header string from definitions.\"\"\"\n    _ = feature, parent  # NOQA\n    header = minimum_needs_section_header['string_format']\n    return header.capitalize()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve additional minimum needs section header string from definitions.", "response": "def additional_minimum_needs_section_header_element(feature, parent):\n    \"\"\"Retrieve additional minimum needs section header string\n    from definitions.\n    \"\"\"\n    _ = feature, parent  # NOQA\n    header = additional_minimum_needs_section_header['string_format']\n    return header.capitalize()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert the parameter into a dictionary.", "response": "def serialize(self):\n        \"\"\"Convert the parameter into a dictionary.\n\n        :return: The parameter dictionary.\n        :rtype: dict\n        \"\"\"\n        pickle = super(ResourceParameter, self).serialize()\n        pickle['frequency'] = self.frequency\n        pickle['unit'] = self._unit.serialize()\n        return pickle"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\noverloads the base dialog reject event so we can handle state change.", "response": "def reject(self):\n        \"\"\"Overload the base dialog reject event so we can handle state change.\n\n        If the user is in resource editing mode, clicking close button,\n        window [x] or pressing escape should switch context back to the\n        profile view, not close the whole window.\n\n        See https://github.com/AIFDR/inasafe/issues/1387\n        \"\"\"\n        if self.stacked_widget.currentWidget() == self.resource_edit_page:\n            self.edit_item = None\n            self.switch_context(self.profile_edit_page)\n        else:\n            super(NeedsManagerDialog, self).reject()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef populate_resource_list(self):\n        minimum_needs = self.minimum_needs.get_full_needs()\n        for full_resource in minimum_needs[\"resources\"]:\n            self.add_resource(full_resource)\n        self.provenance.setText(minimum_needs[\"provenance\"])", "response": "Populate the list resource list."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_resource(self, resource):\n        updated_sentence = NeedsProfile.format_sentence(\n            resource['Readable sentence'], resource)\n        if self.edit_item:\n            item = self.edit_item\n            item.setText(updated_sentence)\n            self.edit_item = None\n        else:\n            item = QtWidgets.QListWidgetItem(updated_sentence)\n        item.resource_full = resource\n        self.resources_list.addItem(item)", "response": "Adds a resource to the minimum needs table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_profiles(self, overwrite=False):\n        for profile in self.minimum_needs.get_profiles(overwrite):\n            self.profile_combo.addItem(profile)\n        minimum_needs = self.minimum_needs.get_full_needs()\n        self.profile_combo.setCurrentIndex(\n            self.profile_combo.findText(minimum_needs['profile']))", "response": "Load the profiles into the dropdown list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef select_profile(self, index):\n        new_profile = self.profile_combo.itemText(index)\n        self.resources_list.clear()\n        self.minimum_needs.load_profile(new_profile)\n        self.clear_resource_list()\n        self.populate_resource_list()\n        self.minimum_needs.save()", "response": "Select a given profile by index."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmarks the current profile as pending by colouring the text red.", "response": "def mark_current_profile_as_pending(self):\n        \"\"\"Mark the current profile as pending by colouring the text red.\n        \"\"\"\n        index = self.profile_combo.currentIndex()\n        item = self.profile_combo.model().item(index)\n        item.setForeground(QtGui.QColor('red'))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle add new resource requests.", "response": "def add_new_resource(self):\n        \"\"\"Handle add new resource requests.\n        \"\"\"\n        parameters_widget = [\n            self.parameters_scrollarea.layout().itemAt(i) for i in\n            range(self.parameters_scrollarea.layout().count())][0].widget()\n        parameter_widgets = [\n            parameters_widget.vertical_layout.itemAt(i).widget() for i in\n            range(parameters_widget.vertical_layout.count())]\n        parameter_widgets[0].set_text('')\n        parameter_widgets[1].set_text('')\n        parameter_widgets[2].set_text('')\n        parameter_widgets[3].set_text('')\n        parameter_widgets[4].set_text('')\n        parameter_widgets[5].set_value(10)\n        parameter_widgets[6].set_value(0)\n        parameter_widgets[7].set_value(100)\n        parameter_widgets[8].set_text(tr('weekly'))\n        parameter_widgets[9].set_text(tr(\n            'A displaced person should be provided with '\n            '%(default value)s %(unit)s/%(units)s/%(unit abbreviation)s of '\n            '%(resource name)s. Though no less than %(minimum allowed)s '\n            'and no more than %(maximum allowed)s. This should be provided '\n            '%(frequency)s.' % {\n                'default value': '{{ Default }}',\n                'unit': '{{ Unit }}',\n                'units': '{{ Units }}',\n                'unit abbreviation': '{{ Unit abbreviation }}',\n                'resource name': '{{ Resource name }}',\n                'minimum allowed': '{{ Minimum allowed }}',\n                'maximum allowed': '{{ Maximum allowed }}',\n                'frequency': '{{ Frequency }}'\n            }))\n        self.stacked_widget.setCurrentWidget(self.resource_edit_page)\n        # hide the close button\n        self.button_box.button(QDialogButtonBox.Close).setHidden(True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling edit resource requests.", "response": "def edit_resource(self):\n        \"\"\"Handle edit resource requests.\n        \"\"\"\n        self.mark_current_profile_as_pending()\n        resource = None\n        for item in self.resources_list.selectedItems()[:1]:\n            resource = item.resource_full\n            self.edit_item = item\n        if not resource:\n            return\n        parameters_widget = [\n            self.parameters_scrollarea.layout().itemAt(i) for i in\n            range(self.parameters_scrollarea.layout().count())][0].widget()\n        parameter_widgets = [\n            parameters_widget.vertical_layout.itemAt(i).widget() for i in\n            range(parameters_widget.vertical_layout.count())]\n        parameter_widgets[0].set_text(resource['Resource name'])\n        parameter_widgets[1].set_text(resource['Resource description'])\n        parameter_widgets[2].set_text(resource['Unit'])\n        parameter_widgets[3].set_text(resource['Units'])\n        parameter_widgets[4].set_text(resource['Unit abbreviation'])\n        parameter_widgets[5].set_value(float(resource['Default']))\n        parameter_widgets[6].set_value(float(resource['Minimum allowed']))\n        parameter_widgets[7].set_value(float(resource['Maximum allowed']))\n        parameter_widgets[8].set_text(resource['Frequency'])\n        parameter_widgets[9].set_text(resource['Readable sentence'])\n        self.switch_context(self.resource_edit_page)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_up_resource_parameters(self):\n        name_parameter = StringParameter('UUID-1')\n        name_parameter.name = self.resource_parameters['Resource name']\n        name_parameter.help_text = tr(\n            'Name of the resource that will be provided '\n            'as part of minimum needs. '\n            'e.g. Rice, Water etc.')\n        name_parameter.description = tr(\n            'A <b>resource</b> is something that you provide to displaced '\n            'persons in the event of a disaster. The resource will be made '\n            'available at IDP camps and may need to be stockpiled by '\n            'contingency planners in their preparations for a disaster.')\n        name_parameter.is_required = True\n        name_parameter.value = ''\n\n        description_parameter = StringParameter('UUID-2')\n        description_parameter.name = self.resource_parameters[\n            'Resource description']\n        description_parameter.help_text = tr(\n            'Description of the resource that will be provided as part of '\n            'minimum needs.')\n        description_parameter.description = tr(\n            'This gives a detailed description of what the resource is and ')\n        description_parameter.is_required = True\n        description_parameter.value = ''\n\n        unit_parameter = StringParameter('UUID-3')\n        unit_parameter.name = self.resource_parameters['Unit']\n        unit_parameter.help_text = tr(\n            'Single unit for the resources spelled out. e.g. litre, '\n            'kilogram etc.')\n        unit_parameter.description = tr(\n            'A <b>unit</b> is the basic measurement unit used for computing '\n            'the allowance per individual. For example when planning water '\n            'rations the unit would be single litre.')\n        unit_parameter.is_required = True\n        unit_parameter.value = ''\n\n        units_parameter = StringParameter('UUID-4')\n        units_parameter.name = self.resource_parameters['Units']\n        units_parameter.help_text = tr(\n            'Multiple units for the resources spelled out. e.g. litres, '\n            'kilogram etc.')\n        units_parameter.description = tr(\n            '<b>Units</b> are the basic measurement used for computing the '\n            'allowance per individual. For example when planning water '\n            'rations the units would be litres.')\n        units_parameter.is_required = True\n        units_parameter.value = ''\n\n        unit_abbreviation_parameter = StringParameter('UUID-5')\n        unit_abbreviation_parameter.name = \\\n            self.resource_parameters['Unit abbreviation']\n        unit_abbreviation_parameter.help_text = tr(\n            'Abbreviations of unit for the resources. e.g. l, kg etc.')\n        unit_abbreviation_parameter.description = tr(\n            \"A <b>unit abbreviation</b> is the basic measurement unit's \"\n            \"shortened. For example when planning water rations \"\n            \"the units would be l.\")\n        unit_abbreviation_parameter.is_required = True\n        unit_abbreviation_parameter.value = ''\n\n        minimum_parameter = FloatParameter('UUID-6')\n        minimum_parameter.name = self.resource_parameters['Minimum allowed']\n        minimum_parameter.is_required = True\n        minimum_parameter.precision = 6\n        minimum_parameter.minimum_allowed_value = 0.0\n        minimum_parameter.maximum_allowed_value = 99999.0\n        minimum_parameter.help_text = tr(\n            'The minimum allowable quantity per person. ')\n        minimum_parameter.description = tr(\n            'The <b>minimum</b> is the minimum allowed quantity of the '\n            'resource per person. For example you may dictate that the water '\n            'ration per person per day should never be allowed to be less '\n            'than 0.5l. This is enforced when tweaking a minimum needs set '\n            'before an impact evaluation')\n        minimum_parameter.value = 0.00\n\n        maximum_parameter = FloatParameter('UUID-7')\n        maximum_parameter.name = self.resource_parameters['Maximum allowed']\n        maximum_parameter.is_required = True\n        maximum_parameter.precision = 6\n        maximum_parameter.minimum_allowed_value = 0.0\n        maximum_parameter.maximum_allowed_value = 99999.0\n        maximum_parameter.help_text = tr(\n            'The maximum allowable quantity per person. ')\n        maximum_parameter.description = tr(\n            'The <b>maximum</b> is the maximum allowed quantity of the '\n            'resource per person. For example you may dictate that the water '\n            'ration per person per day should never be allowed to be more '\n            'than 67l. This is enforced when tweaking a maximum needs set '\n            'before an impact evaluation.')\n        maximum_parameter.value = 100.0\n\n        default_parameter = FloatParameter('UUID-8')\n        default_parameter.name = self.resource_parameters['Default']\n        default_parameter.is_required = True\n        default_parameter.precision = 6\n        default_parameter.minimum_allowed_value = 0.0\n        default_parameter.maximum_allowed_value = 99999.0\n        default_parameter.help_text = tr(\n            'The default allowable quantity per person. ')\n        default_parameter.description = tr(\n            \"The <b>default</b> is the default allowed quantity of the \"\n            \"resource per person. For example you may indicate that the water \"\n            \"ration per person weekly should be 67l.\")\n        default_parameter.value = 10.0\n\n        frequency_parameter = StringParameter('UUID-9')\n        frequency_parameter.name = self.resource_parameters['Frequency']\n        frequency_parameter.help_text = tr(\n            \"The frequency that this resource needs to be provided to a \"\n            \"displaced person. e.g. weekly, daily, once etc.\")\n        frequency_parameter.description = tr(\n            \"The <b>frequency</b> informs the aid worker how regularly this \"\n            \"resource needs to be provided to the displaced person.\")\n        frequency_parameter.is_required = True\n        frequency_parameter.value = tr('weekly')\n\n        sentence_parameter = TextParameter('UUID-10')\n        sentence_parameter.name = self.resource_parameters['Readable sentence']\n        sentence_parameter.help_text = tr(\n            'A readable presentation of the resource.')\n        sentence_parameter.description = tr(\n            \"A <b>readable sentence</b> is a presentation of the resource \"\n            \"that displays all pertinent information. If you are unsure then \"\n            \"use the default. Properties should be included using double \"\n            \"curly brackets '{{' '}}'. Including the resource name would be \"\n            \"achieved by including e.g. {{ Resource name }}\")\n        sentence_parameter.is_required = True\n        sentence_parameter.value = tr(\n            'A displaced person should be provided with '\n            '%(default value)s %(unit)s/%(units)s/%(unit abbreviation)s of '\n            '%(resource name)s. Though no less than %(minimum allowed)s '\n            'and no more than %(maximum allowed)s. This should be provided '\n            '%(frequency)s.' % {\n                'default value': '{{ Default }}',\n                'unit': '{{ Unit }}',\n                'units': '{{ Units }}',\n                'unit abbreviation': '{{ Unit abbreviation }}',\n                'resource name': '{{ Resource name }}',\n                'minimum allowed': '{{ Minimum allowed }}',\n                'maximum allowed': '{{ Maximum allowed }}',\n                'frequency': '{{ Frequency }}'\n            })\n\n        parameters = [\n            name_parameter,\n            description_parameter,\n            unit_parameter,\n            units_parameter,\n            unit_abbreviation_parameter,\n            default_parameter,\n            minimum_parameter,\n            maximum_parameter,\n            frequency_parameter,\n            sentence_parameter\n        ]\n        parameter_container = ParameterContainer(parameters)\n        parameter_container.setup_ui()\n\n        layout = QGridLayout()\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.setSpacing(0)\n        layout.addWidget(parameter_container)\n        self.parameters_scrollarea.setLayout(layout)", "response": "Set up the resource parameter for the add or edit view."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves the currently selected resource.", "response": "def remove_resource(self):\n        \"\"\"Remove the currently selected resource.\n        \"\"\"\n        self.mark_current_profile_as_pending()\n        for item in self.resources_list.selectedItems():\n            self.resources_list.takeItem(self.resources_list.row(item))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_resource(self):\n        # --\n        # Hackorama to get this working outside the method that the\n        # parameters where defined in.\n        parameters_widget = [\n            self.parameters_scrollarea.layout().itemAt(i) for i in\n            range(self.parameters_scrollarea.layout().count())][0]\n        parameters = parameters_widget.widget().get_parameters()\n\n        # To store parameters, we need the english version.\n        translated_to_english = dict(\n            (y, x) for x, y in list(self.resource_parameters.items()))\n        resource = {}\n        for parameter in parameters:\n            resource[translated_to_english[parameter.name]] = parameter.value\n\n        # verify the parameters are ok - create a throw-away resource param\n        try:\n            parameter = ResourceParameter()\n            parameter.name = resource['Resource name']\n            parameter.help_text = resource['Resource description']\n            # Adding in the frequency property. This is not in the\n            # FloatParameter by default, so maybe we should subclass.\n            parameter.frequency = resource['Frequency']\n            parameter.description = NeedsProfile.format_sentence(\n                resource['Readable sentence'],\n                resource)\n            parameter.minimum_allowed_value = float(\n                resource['Minimum allowed'])\n            parameter.maximum_allowed_value = float(\n                resource['Maximum allowed'])\n            parameter.unit.name = resource['Unit']\n            parameter.unit.plural = resource['Units']\n            parameter.unit.abbreviation = resource['Unit abbreviation']\n            parameter.value = float(resource['Default'])\n        except ValueOutOfBounds as e:\n            warning = self.tr(\n                'Problem - default value is invalid') + '\\n' + str(e)\n            # noinspection PyTypeChecker,PyArgumentList\n            QMessageBox.warning(None, 'InaSAFE', warning)\n            return\n        except InvalidMaximumError as e:\n            warning = self.tr(\n                'Problem - maximum value is invalid') + '\\n' + str(e)\n            # noinspection PyTypeChecker,PyArgumentList\n            QMessageBox.warning(None, 'InaSAFE', warning)\n            return\n        except InvalidMinimumError as e:\n            warning = self.tr(\n                'Problem - minimum value is invalid') + '\\n' + str(e)\n            # noinspection PyTypeChecker,PyArgumentList\n            QMessageBox.warning(None, 'InaSAFE', warning)\n            return\n        # end of test for parameter validity\n\n        self.add_resource(resource)\n        self.switch_context(self.profile_edit_page)", "response": "Save the current resource."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef import_profile(self):\n        # noinspection PyCallByClass,PyTypeChecker\n        file_name_dialog = QFileDialog(self)\n        file_name_dialog.setAcceptMode(QFileDialog.AcceptOpen)\n        file_name_dialog.setNameFilter(self.tr('JSON files (*.json *.JSON)'))\n        file_name_dialog.setDefaultSuffix('json')\n        path_name = resources_path('minimum_needs')\n        file_name_dialog.setDirectory(path_name)\n        if file_name_dialog.exec_():\n            file_name = file_name_dialog.selectedFiles()[0]\n        else:\n            return -1\n\n        if self.minimum_needs.read_from_file(file_name) == -1:\n            return -1\n\n        self.clear_resource_list()\n        self.populate_resource_list()\n        self.switch_context(self.profile_edit_page)", "response": "Import minimum needs from an existing json file into the table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexporting minimum needs to a json file.", "response": "def export_profile(self):\n        \"\"\" Export minimum needs to a json file.\n\n        This method will save the current state of the minimum needs setup.\n        Then open a dialog allowing the user to browse to the desired\n        destination location and allow the user to save the needs as a json\n        file.\n        \"\"\"\n        file_name_dialog = QFileDialog(self)\n        file_name_dialog.setAcceptMode(QFileDialog.AcceptSave)\n        file_name_dialog.setNameFilter(self.tr('JSON files (*.json *.JSON)'))\n        file_name_dialog.setDefaultSuffix('json')\n        file_name = None\n        if file_name_dialog.exec_():\n            file_name = file_name_dialog.selectedFiles()[0]\n        if file_name != '' and file_name is not None:\n            self.minimum_needs.write_to_file(file_name)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_profile(self):\n        minimum_needs = {'resources': []}\n        for index in range(self.resources_list.count()):\n            item = self.resources_list.item(index)\n            minimum_needs['resources'].append(item.resource_full)\n        minimum_needs['provenance'] = self.provenance.text()\n        minimum_needs['profile'] = self.profile_combo.itemText(\n            self.profile_combo.currentIndex()\n        )\n        self.minimum_needs.update_minimum_needs(minimum_needs)\n        self.minimum_needs.save()\n        self.minimum_needs.save_profile(minimum_needs['profile'])\n        self.mark_current_profile_as_saved()", "response": "Save the current state of the minimum needs widget."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_profile_as(self):\n        # noinspection PyCallByClass,PyTypeChecker\n        file_name_dialog = QFileDialog(self)\n        file_name_dialog.setAcceptMode(QFileDialog.AcceptSave)\n        file_name_dialog.setNameFilter(self.tr('JSON files (*.json *.JSON)'))\n        file_name_dialog.setDefaultSuffix('json')\n        dir = os.path.join(QgsApplication.qgisSettingsDirPath(),\n                           'inasafe', 'minimum_needs')\n        file_name_dialog.setDirectory(expanduser(dir))\n        if file_name_dialog.exec_():\n            file_name = file_name_dialog.selectedFiles()[0]\n        else:\n            return\n        file_name = basename(file_name)\n        file_name = file_name.replace('.json', '')\n        minimum_needs = {'resources': []}\n        self.mark_current_profile_as_saved()\n        for index in range(self.resources_list.count()):\n            item = self.resources_list.item(index)\n            minimum_needs['resources'].append(item.resource_full)\n        minimum_needs['provenance'] = self.provenance.text()\n        minimum_needs['profile'] = file_name\n        self.minimum_needs.update_minimum_needs(minimum_needs)\n        self.minimum_needs.save()\n        self.minimum_needs.save_profile(file_name)\n        if self.profile_combo.findText(file_name) == -1:\n            self.profile_combo.addItem(file_name)\n        self.profile_combo.setCurrentIndex(\n            self.profile_combo.findText(file_name))", "response": "Save the minimum needs under a new profile name."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new profile by name.", "response": "def new_profile(self):\n        \"\"\"Create a new profile by name.\n        \"\"\"\n        # noinspection PyCallByClass,PyTypeChecker\n        dir = os.path.join(QgsApplication.qgisSettingsDirPath(),\n                           'inasafe', 'minimum_needs')\n        file_name, __ = QFileDialog.getSaveFileName(\n            self,\n            self.tr('Create a minimum needs profile'),\n            expanduser(dir),\n            self.tr('JSON files (*.json *.JSON)'),\n            options=QFileDialog.DontUseNativeDialog)\n        if not file_name:\n            return\n        file_name = basename(file_name)\n        if self.profile_combo.findText(file_name) == -1:\n            minimum_needs = {\n                'resources': [], 'provenance': '', 'profile': file_name}\n            self.minimum_needs.update_minimum_needs(minimum_needs)\n            self.minimum_needs.save_profile(file_name)\n            self.profile_combo.addItem(file_name)\n            self.clear_resource_list()\n            self.profile_combo.setCurrentIndex(\n                self.profile_combo.findText(file_name))\n        else:\n            self.profile_combo.setCurrentIndex(\n                self.profile_combo.findText(file_name))\n            self.select_profile_by_name(file_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nslotting for when tab changes in the stacked widget changes.", "response": "def page_changed(self, index):\n        \"\"\"Slot for when tab changes in the stacked widget changes.\n\n        :param index: Index of the now active tab.\n        :type index: int\n        \"\"\"\n        if index == 0:  # profile edit page\n            for item in self.resource_editing_buttons:\n                item.hide()\n            for item in self.profile_editing_widgets:\n                item.setEnabled(True)\n            for item in self.profile_editing_buttons:\n                item.show()\n        else:  # resource_edit_page\n            for item in self.resource_editing_buttons:\n                item.show()\n            for item in self.profile_editing_widgets:\n                item.setEnabled(False)\n            for item in self.profile_editing_buttons:\n                item.hide()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef switch_context(self, page):\n        # noinspection PyUnresolvedReferences\n        if page.objectName() == 'profile_edit_page':\n            self.stacked_widget.setCurrentIndex(0)\n            self.button_box.button(QDialogButtonBox.Close).setHidden(False)\n        else:  # resource_edit_page\n            self.stacked_widget.setCurrentIndex(1)\n            # hide the close button\n            self.button_box.button(QDialogButtonBox.Close).setHidden(True)", "response": "Switch context tabs by tab widget name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove the current profile.", "response": "def remove_profile(self):\n        \"\"\"Remove the current profile.\n\n        Make sure the user is sure.\n        \"\"\"\n        profile_name = self.profile_combo.currentText()\n        # noinspection PyTypeChecker\n        button_selected = QMessageBox.warning(\n            None,\n            'Remove Profile',\n            self.tr('Remove %s.') % profile_name,\n            QMessageBox.Ok,\n            QMessageBox.Cancel\n        )\n        if button_selected == QMessageBox.Ok:\n            self.profile_combo.removeItem(\n                self.profile_combo.currentIndex()\n            )\n            self.minimum_needs.remove_profile(profile_name)\n            self.select_profile(self.profile_combo.currentIndex())"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a sanitised local url to the logo for insertion into html.", "response": "def logo_element():\n    \"\"\"Create a sanitised local url to the logo for insertion into html.\n\n    :returns: A sanitised local url to the logo prefixed with file://.\n    :rtype: str\n\n    ..note:: We are not using QUrl here because on Windows 10 it returns\n        an empty path if using QUrl.toLocalPath\n    \"\"\"\n\n    path = os.path.join(resources_path(), 'img', 'logos', 'inasafe-logo.png')\n    url = urllib.parse.urljoin('file:', urllib.request.pathname2url(path))\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_text(self):\n        if self.text == '':\n            return '::%s' % self.uri\n        return '::%s [%s]' % (self.text, self.uri)", "response": "Render as plain text."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndisplaying an information message bar.", "response": "def display_information_message_bar(\n        title=None,\n        message=None,\n        more_details=None,\n        button_text=tr('Show details ...'),\n        duration=8,\n        iface_object=iface):\n    \"\"\"\n    Display an information message bar.\n\n    :param iface_object: The QGIS IFace instance. Note that we cannot\n        use qgis.utils.iface since it is not available in our\n        test environment.\n    :type iface_object: QgisInterface\n\n    :param title: The title of the message bar.\n    :type title: basestring\n\n    :param message: The message inside the message bar.\n    :type message: basestring\n\n    :param more_details: The message inside the 'Show details' button.\n    :type more_details: basestring\n\n    :param button_text: The text of the button if 'more_details' is not empty.\n    :type button_text: basestring\n\n    :param duration: The duration for the display, default is 8 seconds.\n    :type duration: int\n    \"\"\"\n    iface_object.messageBar().clearWidgets()\n    widget = iface_object.messageBar().createMessage(title, message)\n\n    if more_details:\n        button = QPushButton(widget)\n        button.setText(button_text)\n        button.pressed.connect(\n            lambda: display_information_message_box(\n                title=title, message=more_details))\n        widget.layout().addWidget(button)\n\n    iface_object.messageBar().pushWidget(widget, Qgis.Info, duration)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef display_warning_message_bar(\n        title=None,\n        message=None,\n        more_details=None,\n        button_text=tr('Show details ...'),\n        duration=8,\n        iface_object=iface):\n    \"\"\"\n    Display a warning message bar.\n\n    :param title: The title of the message bar.\n    :type title: basestring\n\n    :param message: The message inside the message bar.\n    :type message: basestring\n\n    :param more_details: The message inside the 'Show details' button.\n    :type more_details: basestring\n\n    :param button_text: The text of the button if 'more_details' is not empty.\n    :type button_text: basestring\n\n    :param duration: The duration for the display, default is 8 seconds.\n    :type duration: int\n\n    :param iface_object: The QGIS IFace instance. Note that we cannot\n        use qgis.utils.iface since it is not available in our\n        test environment.\n    :type iface_object: QgisInterface\n    \"\"\"\n\n    iface_object.messageBar().clearWidgets()\n    widget = iface_object.messageBar().createMessage(title, message)\n\n    if more_details:\n        button = QPushButton(widget)\n        button.setText(button_text)\n        button.pressed.connect(\n            lambda: display_warning_message_box(\n                title=title, message=more_details))\n        widget.layout().addWidget(button)\n\n    iface_object.messageBar().pushWidget(widget, Qgis.Warning, duration)", "response": "Displays a warning message bar."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef display_critical_message_bar(\n        title=None,\n        message=None,\n        more_details=None,\n        button_text=tr('Show details ...'),\n        duration=8,\n        iface_object=iface\n):\n    \"\"\"\n    Display a critical message bar.\n\n    :param title: The title of the message bar.\n    :type title: basestring\n\n    :param message: The message inside the message bar.\n    :type message: basestring\n\n    :param more_details: The message inside the 'Show details' button.\n    :type more_details: basestring\n\n    :param button_text: The text of the button if 'more_details' is not empty.\n    :type button_text: basestring\n\n    :param duration: The duration for the display, default is 8 seconds.\n    :type duration: int\n\n    :param iface_object: The QGIS IFace instance. Note that we cannot\n        use qgis.utils.iface since it is not available in our\n        test environment.\n    :type iface_object: QgisInterface\n    \"\"\"\n\n    iface_object.messageBar().clearWidgets()\n    widget = iface_object.messageBar().createMessage(title, message)\n\n    if more_details:\n        button = QPushButton(widget)\n        button.setText(button_text)\n        button.pressed.connect(\n            lambda: display_critical_message_box(\n                title=title, message=more_details))\n        widget.layout().addWidget(button)\n\n    iface_object.messageBar().pushWidget(widget, Qgis.Critical, duration)", "response": "Displays a critical message bar."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets colors to the layer according to the hazard.", "response": "def hazard_class_style(layer, classification, display_null=False):\n    \"\"\"Set colors to the layer according to the hazard.\n\n    :param layer: The layer to style.\n    :type layer: QgsVectorLayer\n\n    :param display_null: If we should display the null hazard zone. Default to\n        False.\n    :type display_null: bool\n\n    :param classification: The hazard classification to use.\n    :type classification: dict safe.definitions.hazard_classifications\n    \"\"\"\n    categories = []\n\n    # Conditional styling\n    attribute_table_styles = []\n\n    for hazard_class, (color, label) in list(classification.items()):\n        if hazard_class == not_exposed_class['key'] and not display_null:\n            # We don't want to display the null value (not exposed).\n            # We skip it.\n            continue\n\n        symbol = QgsSymbol.defaultSymbol(layer.geometryType())\n        symbol.setColor(color)\n        if is_line_layer(layer):\n            symbol.setWidth(line_width_exposure)\n        category = QgsRendererCategory(hazard_class, symbol, label)\n        categories.append(category)\n\n        style = QgsConditionalStyle()\n        style.setName(hazard_class)\n        style.setRule(\"hazard_class='%s'\" % hazard_class)\n        style.setBackgroundColor(transparent)\n        symbol = QgsSymbol.defaultSymbol(QgsWkbTypes.PointGeometry)\n        symbol.setColor(color)\n        symbol.setSize(3)\n        style.setSymbol(symbol)\n        attribute_table_styles.append(style)\n\n    layer.conditionalStyles().setFieldStyles(\n        'hazard_class', attribute_table_styles)\n    renderer = QgsCategorizedSymbolRenderer(\n        hazard_class_field['field_name'], categories)\n    layer.setRenderer(renderer)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef layer_title(layer):\n    exposure_type = layer.keywords['exposure_keywords']['exposure']\n    exposure_definitions = definition(exposure_type)\n    title = exposure_definitions['layer_legend_title']\n    layer.setTitle(title)\n    layer.keywords['title'] = title", "response": "Set the layer title according to the standards."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates an ordered python structure with the classified symbology.", "response": "def generate_classified_legend(\n        analysis,\n        exposure,\n        hazard,\n        use_rounding,\n        debug_mode):\n    \"\"\"Generate an ordered python structure with the classified symbology.\n\n    :param analysis: The analysis layer.\n    :type analysis: QgsVectorLayer\n\n    :param exposure: The exposure layer.\n    :type exposure: QgsVectorLayer\n\n    :param hazard: The hazard layer.\n    :type hazard: QgsVectorLayer\n\n    :param use_rounding: Boolean if we round number in the legend.\n    :type use_rounding: bool\n\n    :param debug_mode: Boolean if run in debug mode,to display the not exposed.\n    :type debug_mode: bool\n\n    :return: The ordered dictionary to use to build the classified style.\n    :rtype: OrderedDict\n    \"\"\"\n    # We need to read the analysis layer to get the number of features.\n    analysis_row = next(analysis.getFeatures())\n\n    # Let's style the hazard class in each layers.\n    hazard_classification = hazard.keywords['classification']\n    hazard_classification = definition(hazard_classification)\n\n    # Let's check if there is some thresholds:\n    thresholds = hazard.keywords.get('thresholds')\n    if thresholds:\n        hazard_unit = hazard.keywords.get('continuous_hazard_unit')\n        hazard_unit = definition(hazard_unit)['abbreviation']\n    else:\n        hazard_unit = None\n\n    exposure = exposure.keywords['exposure']\n    exposure_definitions = definition(exposure)\n    exposure_units = exposure_definitions['units']\n    exposure_unit = exposure_units[0]\n    coefficient = 1\n    # We check if can use a greater unit, such as kilometre for instance.\n    if len(exposure_units) > 1:\n        # We use only two units for now.\n        delta = coefficient_between_units(\n            exposure_units[1], exposure_units[0])\n\n        all_values_are_greater = True\n\n        # We check if all values are greater than the coefficient\n        for i, hazard_class in enumerate(hazard_classification['classes']):\n            field_name = hazard_count_field['field_name'] % hazard_class['key']\n            try:\n                value = analysis_row[field_name]\n            except KeyError:\n                value = 0\n\n            if 0 < value < delta:\n                # 0 is fine, we can still keep the second unit.\n                all_values_are_greater = False\n\n        if all_values_are_greater:\n            # If yes, we can use this unit.\n            exposure_unit = exposure_units[1]\n            coefficient = delta\n\n    classes = OrderedDict()\n\n    for i, hazard_class in enumerate(hazard_classification['classes']):\n        # Get the hazard class name.\n        field_name = hazard_count_field['field_name'] % hazard_class['key']\n\n        # Get the number of affected feature by this hazard class.\n        try:\n            value = analysis_row[field_name]\n        except KeyError:\n            # The field might not exist if no feature impacted in this hazard\n            # zone.\n            value = 0\n        value = format_number(\n            value,\n            use_rounding,\n            exposure_definitions['use_population_rounding'],\n            coefficient)\n\n        minimum = None\n        maximum = None\n\n        # Check if we need to add thresholds.\n        if thresholds:\n            if i == 0:\n                minimum = thresholds[hazard_class['key']][0]\n            elif i == len(hazard_classification['classes']) - 1:\n                maximum = thresholds[hazard_class['key']][1]\n            else:\n                minimum = thresholds[hazard_class['key']][0]\n                maximum = thresholds[hazard_class['key']][1]\n\n        label = _format_label(\n            hazard_class=hazard_class['name'],\n            value=value,\n            exposure_unit=exposure_unit['abbreviation'],\n            minimum=minimum,\n            maximum=maximum,\n            hazard_unit=hazard_unit)\n\n        classes[hazard_class['key']] = (hazard_class['color'], label)\n\n    if exposure_definitions['display_not_exposed'] or debug_mode:\n        classes[not_exposed_class['key']] = _add_not_exposed(\n            analysis_row,\n            use_rounding,\n            exposure_definitions['use_population_rounding'],\n            exposure_unit['abbreviation'],\n            coefficient)\n\n    return classes"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _add_not_exposed(\n        analysis_row,\n        enable_rounding,\n        is_population,\n        exposure_unit,\n        coefficient):\n    \"\"\"Helper to add the `not exposed` item to the legend.\n\n    :param analysis_row: The analysis row as a list.\n    :type analysis_row: list\n\n    :param enable_rounding: If we need to do a rounding.\n    :type enable_rounding: bool\n\n    :param is_population: Flag if the number is population. It needs to be\n        used with enable_rounding.\n    :type is_population: bool\n\n    :param exposure_unit: The exposure unit.\n    :type exposure_unit: safe.definitions.units\n\n    :param coefficient: Divide the result after the rounding.\n    :type coefficient:float\n\n    :return: A tuple with the color and the formatted label.\n    :rtype: tuple\n    \"\"\"\n    # We add the not exposed class at the end.\n    not_exposed_field = (\n        hazard_count_field['field_name'] % not_exposed_class['key'])\n    try:\n        value = analysis_row[not_exposed_field]\n    except KeyError:\n        # The field might not exist if there is not feature not exposed.\n        value = 0\n    value = format_number(value, enable_rounding, is_population, coefficient)\n    label = _format_label(\n        hazard_class=not_exposed_class['name'],\n        value=value,\n        exposure_unit=exposure_unit)\n\n    return not_exposed_class['color'], label", "response": "Helper function to add the not exposed item to the legend."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _format_label(\n        hazard_class,\n        value,\n        exposure_unit,\n        hazard_unit=None,\n        minimum=None,\n        maximum=None):\n    \"\"\"Helper function to format the label in the legend.\n\n    :param hazard_class: The main name of the label.\n    :type hazard_class: basestring\n\n    :param value: The number of features affected by this hazard class.\n    :type value: float\n\n    :param exposure_unit: The exposure unit.\n    :type exposure_unit: basestring\n\n    :param hazard_unit: The hazard unit.\n        It can be null if there isn't thresholds.\n    :type hazard_unit: basestring\n\n    :param minimum: The minimum value used in the threshold. It can be null.\n    :type minimum: float\n\n    :param maximum: The maximum value used in the threshold. It can be null.\n    :type maximum: float\n\n    :return: The formatted label.\n    :rtype: basestring\n    \"\"\"\n\n    # If the exposure unit is not null, we need to add a space.\n    if exposure_unit != '':\n        exposure_unit = ' %s' % exposure_unit\n\n    if minimum is None and maximum is None:\n        label = template_without_thresholds.format(\n            name=hazard_class,\n            count=value,\n            exposure_unit=exposure_unit)\n    elif minimum is not None and maximum is None:\n        label = template_with_minimum_thresholds.format(\n            name=hazard_class,\n            count=value,\n            exposure_unit=exposure_unit,\n            min=minimum,\n            hazard_unit=hazard_unit)\n    elif minimum is None and maximum is not None:\n        label = template_with_maximum_thresholds.format(\n            name=hazard_class,\n            count=value,\n            exposure_unit=exposure_unit,\n            max=maximum,\n            hazard_unit=hazard_unit)\n    else:\n        label = template_with_range_thresholds.format(\n            name=hazard_class,\n            count=value,\n            exposure_unit=exposure_unit,\n            min=minimum,\n            max=maximum,\n            hazard_unit=hazard_unit)\n\n    return label", "response": "Helper function to format the label in the legend."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef simple_polygon_without_brush(layer, width='0.26', color=QColor('black')):\n    registry = QgsApplication.symbolLayerRegistry()\n    line_metadata = registry.symbolLayerMetadata(\"SimpleLine\")\n    symbol = QgsSymbol.defaultSymbol(layer.geometryType())\n\n    # Line layer\n    line_layer = line_metadata.createSymbolLayer(\n        {\n            'width': width,\n            'color': color.name(),\n            'offset': '0',\n            'penstyle': 'solid',\n            'use_custom_dash': '0',\n            'joinstyle': 'bevel',\n            'capstyle': 'square'\n        })\n\n    # Replace the default layer with our custom line\n    symbol.deleteSymbolLayer(0)\n    symbol.appendSymbolLayer(line_layer)\n\n    renderer = QgsSingleSymbolRenderer(symbol)\n    layer.setRenderer(renderer)", "response": "Simple style to apply a border line only to a polygon layer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhelping message for Batch Dialog.", "response": "def impact_report_help():\n    \"\"\"Help message for Batch Dialog.\n\n    .. versionadded:: 3.2.1\n\n    :returns: A message object containing helpful information.\n    :rtype: messaging.message.Message\n    \"\"\"\n\n    message = m.Message()\n    message.add(m.Brand())\n    message.add(heading())\n    message.add(content())\n    return message"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add(self, item):\n        if isinstance(item, list):\n            self.rows.append(Row(item))\n        elif isinstance(item, Row):\n            self.rows.append(item)\n        else:\n            raise InvalidMessageItemError(item, item.__class__)", "response": "Add a row to the table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrender a Table MessageElement as html.", "response": "def to_html(self):\n        \"\"\"Render a Table MessageElement as html.\n\n        :returns: The html representation of the Table MessageElement\n        :rtype: basestring\n        \"\"\"\n        table = '<table%s>\\n' % self.html_attributes()\n        if self.caption is not None:\n            if isinstance(self.caption, MessageElement):\n                caption = self.caption.to_html()\n            else:\n                caption = self.caption\n            table += '<caption>%s</caption>\\n' % caption\n        if self.header:\n            if isinstance(self.header, MessageElement):\n                header = self.header.to_html()\n            else:\n                header = self.header\n            table += '<thead>%s</thead>' % header\n        table += '<tbody>\\n'\n        for row in self.rows:\n            table += row.to_html()\n        table += '</tbody>\\n</table>\\n'\n\n        return table"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrender a Table MessageElement as plain text.", "response": "def to_text(self):\n        \"\"\"Render a Table MessageElement as plain text.\n\n        :returns: The text representation of the Table MessageElement\n        :rtype: basestring\n        \"\"\"\n\n        table = ''\n        if self.caption is not None:\n            table += '%s</caption>\\n' % self.caption\n        table += '\\n'\n        for row in self.rows:\n            table += row.to_text()\n        return table"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrendering a MessageElement as python dict.", "response": "def to_dict(self):\n        \"\"\"Render a MessageElement as python dict.\n\n        :return: Python dict representation\n        :rtype: dict\n        \"\"\"\n        obj_dict = super(Table, self).to_dict()\n        rows_dict = [r.to_dict() for r in self.rows]\n        child_dict = {\n            'type': self.__class__.__name__,\n            'caption': self.caption,\n            'rows': rows_dict\n        }\n        obj_dict.update(child_dict)\n        return obj_dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates widgets for extra keyword.", "response": "def extra_keywords_to_widgets(extra_keyword_definition):\n    \"\"\"Create widgets for extra keyword.\n\n    :param extra_keyword_definition: An extra keyword definition.\n    :type extra_keyword_definition: dict\n\n    :return: QCheckBox and The input widget\n    :rtype: (QCheckBox, QWidget)\n    \"\"\"\n    # Check box\n    check_box = QCheckBox(extra_keyword_definition['name'])\n    check_box.setToolTip(extra_keyword_definition['description'])\n    check_box.setChecked(True)\n\n    # Input widget\n    if extra_keyword_definition['type'] == float:\n        input_widget = QDoubleSpinBox()\n        input_widget.setMinimum(extra_keyword_definition['minimum'])\n        input_widget.setMaximum(extra_keyword_definition['maximum'])\n        input_widget.setSuffix(extra_keyword_definition['unit_string'])\n    elif extra_keyword_definition['type'] == int:\n        input_widget = QSpinBox()\n        input_widget.setMinimum(extra_keyword_definition['minimum'])\n        input_widget.setMaximum(extra_keyword_definition['maximum'])\n        input_widget.setSuffix(extra_keyword_definition['unit_string'])\n    elif extra_keyword_definition['type'] == str:\n        if extra_keyword_definition.get('options'):\n            input_widget = QComboBox()\n            options = extra_keyword_definition['options']\n            for option in options:\n                input_widget.addItem(\n                    option['name'],\n                    option['key'],\n                )\n            default_option_index = input_widget.findData(\n                extra_keyword_definition['default_option'])\n            input_widget.setCurrentIndex(default_option_index)\n        else:\n            input_widget = QLineEdit()\n    elif extra_keyword_definition['type'] == datetime:\n        input_widget = QDateTimeEdit()\n        input_widget.setCalendarPopup(True)\n        input_widget.setDisplayFormat('hh:mm:ss, d MMM yyyy')\n        input_widget.setDateTime(datetime.now())\n    else:\n        raise Exception\n    input_widget.setToolTip(extra_keyword_definition['description'])\n\n    # Signal\n    # noinspection PyUnresolvedReferences\n    check_box.stateChanged.connect(input_widget.setEnabled)\n\n    return check_box, input_widget"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset widgets on the extra keywords tab.", "response": "def set_widgets(self):\n        \"\"\"Set widgets on the extra keywords tab.\"\"\"\n        self.clear()\n        self.description_label.setText(\n            'In this step you can set some extra keywords for the layer. This '\n            'keywords can be used for creating richer reporting or map.')\n        subcategory = self.parent.step_kw_subcategory.selected_subcategory()\n        extra_keywords = subcategory.get('extra_keywords')\n        for extra_keyword in extra_keywords:\n            check_box, input_widget = extra_keywords_to_widgets(extra_keyword)\n            self.widgets_dict[extra_keyword['key']] = [\n                check_box,\n                input_widget,\n                extra_keyword\n            ]\n\n        # Add to layout\n        index = 0\n        for key, widgets in list(self.widgets_dict.items()):\n            self.extra_keywords_layout.addWidget(widgets[0], index, 0)\n            self.extra_keywords_layout.addWidget(widgets[1], index, 1)\n            index += 1\n\n        self.set_existing_extra_keywords()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_extra_keywords(self):\n        extra_keywords = {}\n        for key, widgets in list(self.widgets_dict.items()):\n            if widgets[0].isChecked():\n                if isinstance(widgets[1], QLineEdit):\n                    extra_keywords[key] = widgets[1].text()\n                elif isinstance(widgets[1], QComboBox):\n                    current_index = widgets[1].currentIndex()\n                    extra_keywords[key] = widgets[1].itemData(current_index)\n                elif isinstance(widgets[1], (QDoubleSpinBox, QSpinBox)):\n                    extra_keywords[key] = widgets[1].value()\n                elif isinstance(widgets[1], QDateTimeEdit):\n                    extra_keywords[key] = widgets[1].dateTime().toString(\n                        Qt.ISODate)\n\n        return extra_keywords", "response": "Obtain extra keywords from the current state."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset extra keywords from the value from metadata.", "response": "def set_existing_extra_keywords(self):\n        \"\"\"Set extra keywords from the value from metadata.\"\"\"\n        extra_keywords = self.parent.get_existing_keyword('extra_keywords')\n        for key, widgets in list(self.widgets_dict.items()):\n            value = extra_keywords.get(key)\n            if value is None:\n                widgets[0].setChecked(False)\n            else:\n                widgets[0].setChecked(True)\n                if isinstance(widgets[1], QLineEdit):\n                    widgets[1].setText(value)\n                elif isinstance(widgets[1], QComboBox):\n                    value_index = widgets[1].findData(value)\n                    widgets[1].setCurrentIndex(value_index)\n                elif isinstance(widgets[1], QDoubleSpinBox):\n                    try:\n                        value = float(value)\n                        widgets[1].setValue(value)\n                    except ValueError:\n                        LOGGER.warning('Failed to convert %s to float' % value)\n                elif isinstance(widgets[1], QDateTimeEdit):\n                    try:\n                        value_datetime = datetime.strptime(\n                            value, \"%Y-%m-%dT%H:%M:%S.%f\")\n                        widgets[1].setDateTime(value_datetime)\n                    except ValueError:\n                        try:\n                            value_datetime = datetime.strptime(\n                                value, \"%Y-%m-%dT%H:%M:%S\")\n                            widgets[1].setDateTime(value_datetime)\n                        except ValueError:\n                            LOGGER.info(\n                                'Failed to convert %s to datetime' % value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clear(self):\n        # Adapted from http://stackoverflow.com/a/13103617/1198772\n        for i in reversed(list(range(self.extra_keywords_layout.count()))):\n            self.extra_keywords_layout.itemAt(i).widget().setParent(None)\n        self.widgets_dict = OrderedDict()", "response": "Clear the current state of the extra keywords."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a vector memory layer.", "response": "def create_memory_layer(\n        layer_name, geometry, coordinate_reference_system=None, fields=None):\n    \"\"\"Create a vector memory layer.\n\n    :param layer_name: The name of the layer.\n    :type layer_name: str\n\n    :param geometry: The geometry of the layer.\n    :rtype geometry: QgsWkbTypes (note:\n                     from C++ QgsWkbTypes::GeometryType enum)\n\n    :param coordinate_reference_system: The CRS of the memory layer.\n    :type coordinate_reference_system: QgsCoordinateReferenceSystem\n\n    :param fields: Fields of the vector layer. Default to None.\n    :type fields: QgsFields\n\n    :return: The memory layer.\n    :rtype: QgsVectorLayer\n    \"\"\"\n\n    if geometry == QgsWkbTypes.PointGeometry:\n        wkb_type = QgsWkbTypes.MultiPoint\n    elif geometry == QgsWkbTypes.LineGeometry:\n        wkb_type = QgsWkbTypes.MultiLineString\n    elif geometry == QgsWkbTypes.PolygonGeometry:\n        wkb_type = QgsWkbTypes.MultiPolygon\n    elif geometry == QgsWkbTypes.NullGeometry:\n        wkb_type = QgsWkbTypes.NoGeometry\n    else:\n        raise MemoryLayerCreationError(\n            'Layer geometry must be one of: Point, Line, '\n            'Polygon or Null, I got %s' % geometry)\n\n    if coordinate_reference_system is None:\n        coordinate_reference_system = QgsCoordinateReferenceSystem()\n    if fields is None:\n        fields = QgsFields()\n    elif not isinstance(fields, QgsFields):\n        # fields is a list\n        new_fields = QgsFields()\n        for f in fields:\n            new_fields.append(f)\n        fields = new_fields\n    memory_layer = QgsMemoryProviderUtils. \\\n        createMemoryLayer(name=layer_name,\n                          fields=fields,\n                          geometryType=wkb_type,\n                          crs=coordinate_reference_system)\n\n    memory_layer.dataProvider().createSpatialIndex()\n    memory_layer.keywords = {\n        'inasafe_fields': {}\n    }\n    return memory_layer"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copy_layer(source, target):\n    out_feature = QgsFeature()\n    target.startEditing()\n\n    request = QgsFeatureRequest()\n\n    aggregation_layer = False\n    if source.keywords.get('layer_purpose') == 'aggregation':\n        try:\n            use_selected_only = source.use_selected_features_only\n        except AttributeError:\n            use_selected_only = False\n\n        # We need to check if the user wants selected feature only and if there\n        # is one minimum selected.\n        if use_selected_only and source.selectedFeatureCount() > 0:\n            request.setFilterFids(source.selectedFeatureIds())\n\n        aggregation_layer = True\n\n    for i, feature in enumerate(source.getFeatures(request)):\n        geom = feature.geometry()\n        if aggregation_layer and feature.hasGeometry():\n            # See issue https://github.com/inasafe/inasafe/issues/3713\n            # and issue https://github.com/inasafe/inasafe/issues/3927\n            # Also handle if feature has no geometry.\n            was_valid, geom = geometry_checker(geom)\n            if not geom:\n                LOGGER.info(\n                    'One geometry in the aggregation layer is still invalid '\n                    'after cleaning.')\n        out_feature.setGeometry(geom)\n        out_feature.setAttributes(feature.attributes())\n        target.addFeature(out_feature)\n\n    target.commitChanges()", "response": "Copy a vector layer to another vector layer."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrenames fields inside an attribute table.", "response": "def rename_fields(layer, fields_to_copy):\n    \"\"\"Rename fields inside an attribute table.\n\n    Only since QGIS 2.16.\n\n    :param layer: The vector layer.\n    :type layer: QgsVectorLayer\n\n    :param fields_to_copy: Dictionary of fields to copy.\n    :type fields_to_copy: dict\n    \"\"\"\n    for field in fields_to_copy:\n        index = layer.fields().lookupField(field)\n        if index != -1:\n            layer.startEditing()\n            layer.renameAttribute(index, fields_to_copy[field])\n            layer.commitChanges()\n            LOGGER.info(\n                'Renaming field %s to %s' % (field, fields_to_copy[field]))\n        else:\n            LOGGER.info(\n                'Field %s not present in the layer while trying to renaming '\n                'it to %s' % (field, fields_to_copy[field]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef copy_fields(layer, fields_to_copy):\n    for field in fields_to_copy:\n\n        index = layer.fields().lookupField(field)\n        if index != -1:\n\n            layer.startEditing()\n\n            source_field = layer.fields().at(index)\n            new_field = QgsField(source_field)\n            new_field.setName(fields_to_copy[field])\n\n            layer.addAttribute(new_field)\n\n            new_index = layer.fields().lookupField(fields_to_copy[field])\n\n            for feature in layer.getFeatures():\n                attributes = feature.attributes()\n                source_value = attributes[index]\n                layer.changeAttributeValue(\n                    feature.id(), new_index, source_value)\n\n            layer.commitChanges()\n            layer.updateFields()", "response": "Copy fields inside an attribute table."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving fields from a vector layer.", "response": "def remove_fields(layer, fields_to_remove):\n    \"\"\"Remove fields from a vector layer.\n\n    :param layer: The vector layer.\n    :type layer: QgsVectorLayer\n\n    :param fields_to_remove: List of fields to remove.\n    :type fields_to_remove: list\n    \"\"\"\n    index_to_remove = []\n    data_provider = layer.dataProvider()\n\n    for field in fields_to_remove:\n        index = layer.fields().lookupField(field)\n        if index != -1:\n            index_to_remove.append(index)\n\n    data_provider.deleteAttributes(index_to_remove)\n    layer.updateFields()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_spatial_index(layer):\n    request = QgsFeatureRequest().setSubsetOfAttributes([])\n    try:\n        spatial_index = QgsSpatialIndex(layer.getFeatures(request))\n    except BaseException:\n        # Spatial index is creating an unknown exception.\n        # https://github.com/inasafe/inasafe/issues/4304\n        # or https://gitter.im/inasafe/inasafe?at=5a2903d487680e6230e0359a\n        LOGGER.warning(\n            'An Exception has been raised from the spatial index creation. '\n            'We will clean your layer and try again.')\n        new_layer = clean_layer(layer)\n        try:\n            spatial_index = QgsSpatialIndex(new_layer.getFeatures())\n        except BaseException:\n            # We got another exception.\n            # We try now to insert feature by feature.\n            # It's slower than the using the feature iterator.\n            spatial_index = QgsSpatialIndex()\n            for feature in new_layer.getFeatures(request):\n                try:\n                    spatial_index.insertFeature(feature)\n                except BaseException:\n                    LOGGER.critical(\n                        'A feature has been removed from the spatial index.')\n\n            # # We tried one time to clean the layer, we can't do more.\n            # LOGGER.critical(\n            #     'An Exception has been raised from the spatial index '\n            #     'creation. Unfortunately, we already try to clean your '\n            #     'layer. We will stop here the process.')\n            # raise SpatialIndexCreationError\n    return spatial_index", "response": "Helper function to create the spatial index on a vector layer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_field_from_definition(field_definition, name=None, sub_name=None):\n    field = QgsField()\n\n    if name and not sub_name:\n        field.setName(field_definition['field_name'] % name)\n    elif name and sub_name:\n        field.setName(field_definition['field_name'] % (name, sub_name))\n    else:\n        field.setName(field_definition['field_name'])\n\n    if isinstance(field_definition['type'], list):\n        # Use the first element in the list of type\n        field.setType(field_definition['type'][0])\n    else:\n        field.setType(field_definition['type'])\n    field.setLength(field_definition['length'])\n    field.setPrecision(field_definition['precision'])\n    return field", "response": "Helper to create a new field from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_ogr_field_from_definition(field_definition):\n    if isinstance(field_definition['type'], list):\n        # Use the first element in the list of type\n        field_type = field_definition['type'][0]\n    else:\n        field_type = field_definition['type']\n\n    # Conversion to OGR field\n    field_type = field_type_converter.get(field_type, ogr.OFTString)\n\n    return ogr.FieldDefn(field_definition['field_name'], field_type)", "response": "Helper function to create a ogr. FieldDefn object from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_dynamic_inasafe_field(inasafe_fields, dynamic_field, black_list=None):\n    pattern = dynamic_field['key']\n    pattern = pattern.replace('%s', '')\n\n    if black_list is None:\n        black_list = []\n\n    black_list = [field['key'] for field in black_list]\n\n    unique_exposure = []\n    for field_key, name_field in list(inasafe_fields.items()):\n        if field_key.endswith(pattern) and field_key not in black_list:\n            unique_exposure.append(field_key.replace(pattern, ''))\n\n    return unique_exposure", "response": "Helper to read inasafe_fields using a dynamic field."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef measure(self, geometry):\n        message = 'Size with NaN value : geometry valid={valid}, WKT={wkt}'\n        feature_size = 0\n        if geometry.isMultipart():\n            # Be careful, the size calculator is not working well on a\n            # multipart.\n            # So we compute the size part per part. See ticket #3812\n            for single in geometry.asGeometryCollection():\n                if self.geometry_type == QgsWkbTypes.LineGeometry:\n                    geometry_size = self.calculator.measureLength(single)\n                else:\n                    geometry_size = self.calculator.measureArea(single)\n                if not isnan(geometry_size):\n                    feature_size += geometry_size\n                else:\n                    LOGGER.debug(message.format(\n                        valid=single.isGeosValid(),\n                        wkt=single.asWkt()))\n        else:\n            if self.geometry_type == QgsWkbTypes.LineGeometry:\n                geometry_size = self.calculator.measureLength(geometry)\n            else:\n                geometry_size = self.calculator.measureArea(geometry)\n            if not isnan(geometry_size):\n                feature_size = geometry_size\n            else:\n                LOGGER.debug(message.format(\n                    valid=geometry.isGeosValid(),\n                    wkt=geometry.asWkt()))\n\n        feature_size = round(feature_size)\n\n        if self.output_unit:\n            if self.output_unit != self.default_unit:\n                feature_size = convert_unit(\n                    feature_size, self.default_unit, self.output_unit)\n\n        return feature_size", "response": "Measure the length or area of a geometry."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _is_qstring(message):\n        my_class = str(message.__class__)\n        my_class_name = my_class.replace('<class \\'', '').replace('\\'>', '')\n        if my_class_name == 'PyQt5.QtCore.QString':\n            return True\n\n        return False", "response": "Check if the given message is a QString without adding any dep to PyQt5."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_dict(self):\n        return {\n            'type': self.__class__.__name__,\n            'element_id': self.element_id,\n            'style_class': self.style_class,\n            'icon': self.icon,\n            'attributes': self.attributes\n        }", "response": "Render a MessageElement as python dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget extra html attributes such as id and class.", "response": "def html_attributes(self):\n        \"\"\"Get extra html attributes such as id and class.\"\"\"\n        extra_attributes = ''\n        if self.element_id is not None:\n            extra_attributes = ' id=\"%s\"' % self.element_id\n        if self.style_class is not None:\n            extra_attributes = '%s class=\"%s\"' % (\n                extra_attributes, self.style_class)\n        if self.attributes is not None:\n            extra_attributes = '%s %s' % (extra_attributes, self.attributes)\n        return extra_attributes"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a weak reference to a callable target", "response": "def safeRef(target, onDelete = None):\n    \"\"\"Return a *safe* weak reference to a callable target\n\n    target -- the object to be weakly referenced, if it's a\n        bound method reference, will create a BoundMethodWeakref,\n        otherwise creates a simple weakref.\n    onDelete -- if provided, will have a hard reference stored\n        to the callable to be called after the safe reference\n        goes out of scope with the reference object, (either a\n        weakref or a BoundMethodWeakref) as argument.\n    \"\"\"\n    if hasattr(target, im_self):\n        if getattr(target, im_self) is not None:\n            # Turn a bound method into a BoundMethodWeakref instance.\n            # Keep track of these instances for lookup by disconnect().\n            assert hasattr(target, im_func), \"\"\"safeRef target %r has %s, but no %s, don't know how to create reference\"\"\"%( target,im_self,im_func)\n            reference = BoundMethodWeakref(\n                target=target,\n                onDelete=onDelete\n            )\n            return reference\n    if onDelete is not None:\n        return weakref.ref(target, onDelete)\n    else:\n        return weakref.ref( target )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the reference key for this object", "response": "def calculateKey( cls, target ):\n        \"\"\"Calculate the reference key for this reference\n\n        Currently this is a two-tuple of the id()'s of the\n        target object and the target function respectively.\n        \"\"\"\n        return (id(getattr(target,im_self)),id(getattr(target,im_func)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef postgis_path_to_uri(path):\n\n        connection_name = path.split('/')[1]\n        schema = path.split('/')[2]\n        table_name = path.split('/')[3]\n\n        settings = QSettings()\n        key = \"/PostgreSQL/connections/\" + connection_name\n        service = settings.value(key + \"/service\")\n        host = settings.value(key + \"/host\")\n        port = settings.value(key + \"/port\")\n        if not port:\n            port = \"5432\"\n        db = settings.value(key + \"/database\")\n        use_estimated_metadata = settings.value(\n            key + \"/estimatedMetadata\", False, type=bool)\n        sslmode = settings.value(\n            key + \"/sslmode\", QgsDataSourceUri.SSLprefer, type=int)\n        username = \"\"\n        password = \"\"\n        if settings.value(key + \"/saveUsername\") == \"true\":\n            username = settings.value(key + \"/username\")\n\n        if settings.value(key + \"/savePassword\") == \"true\":\n            password = settings.value(key + \"/password\")\n\n        # Old save setting\n        if settings.contains(key + \"/save\"):\n            username = settings.value(key + \"/username\")\n            if settings.value(key + \"/save\") == \"true\":\n                password = settings.value(key + \"/password\")\n\n        uri = QgsDataSourceUri()\n        if service:\n            uri.setConnection(service, db, username, password, sslmode)\n        else:\n            uri.setConnection(host, port, db, username, password, sslmode)\n\n        uri.setUseEstimatedMetadata(use_estimated_metadata)\n\n        # Obtain the geometry column name\n        connector = PostGisDBConnector(uri)\n        tables = connector.getVectorTables(schema)\n        tables = [table for table in tables if table[1] == table_name]\n        if not tables:\n            return None\n        table = tables[0]\n        geom_col = table[8]\n\n        uri.setDataSource(schema, table_name, geom_col)\n        return uri", "response": "Convert a path from QGIS PostGIS to QGIS layer uri."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unsuitable_layer_description_html(\n            self, layer, layer_purpose, keywords=None):\n        \"\"\"Form a html description of a given non-matching layer based on\n           the currently selected impact function requirements vs layer\\'s\n           parameters and keywords if provided, as\n\n        :param layer: The layer to be validated\n        :type layer: QgsVectorLayer | QgsRasterLayer\n\n        :param layer_purpose: The layer_purpose the layer is validated for\n        :type layer_purpose: string\n\n        :param keywords: The layer keywords\n        :type keywords: None, dict\n\n        :returns: The html description in tabular format,\n            ready to use in a label or tool tip.\n        :rtype: str\n        \"\"\"\n\n        def emphasize(str1, str2):\n            \"\"\"Compare two strings and emphasize both if differ.\n\n            :param str1: First string.\n            :type str1: str\n\n            :param str2: Second string.\n            :type str2: str\n\n            :returns: Return emphasized string if differ.\n            :rtype: tuple\n            \"\"\"\n            if str1 != str2:\n                str1 = '<i>%s</i>' % str1\n                str2 = '<i>%s</i>' % str2\n            return str1, str2\n\n        # Get allowed subcategory and layer_geometry from IF constraints\n        h, e, hc, ec = self.parent.selected_impact_function_constraints()\n        imfunc = self.parent.step_fc_function.selected_function()\n        lay_req = imfunc['layer_requirements'][layer_purpose]\n\n        if layer_purpose == layer_purpose_hazard['key']:\n            layer_purpose_key_name = layer_purpose_hazard['name']\n            req_subcategory = h['key']\n            req_geometry = hc['key']\n        elif layer_purpose == layer_purpose_exposure['key']:\n            layer_purpose_key_name = layer_purpose_exposure['name']\n            req_subcategory = e['key']\n            req_geometry = ec['key']\n        else:\n            layer_purpose_key_name = layer_purpose_aggregation['name']\n            req_subcategory = ''\n            # For aggregation layers, only accept polygons\n            req_geometry = layer_geometry_polygon['key']\n        req_layer_mode = lay_req['layer_mode']['key']\n\n        layer_geometry_key = self.parent.get_layer_geometry_key(layer)\n        lay_purpose = '&nbsp;&nbsp;-'\n        lay_subcategory = '&nbsp;&nbsp;-'\n        lay_layer_mode = '&nbsp;&nbsp;-'\n\n        if keywords:\n            if 'layer_purpose' in keywords:\n                lay_purpose = keywords['layer_purpose']\n            if layer_purpose in keywords:\n                lay_subcategory = keywords[layer_purpose]\n            if 'layer_mode' in keywords:\n                lay_layer_mode = keywords['layer_mode']\n\n        layer_geometry_key, req_geometry = emphasize(\n            layer_geometry_key, req_geometry)\n        lay_purpose, layer_purpose = emphasize(lay_purpose, layer_purpose)\n        lay_subcategory, req_subcategory = emphasize(\n            lay_subcategory, req_subcategory)\n        lay_layer_mode, req_layer_mode = emphasize(\n            lay_layer_mode, req_layer_mode)\n\n        # Classification\n        classification_row = ''\n        if (lay_req['layer_mode'] == layer_mode_classified\n                and layer_purpose == layer_purpose_hazard['key']):\n            # Determine the keyword key for the classification\n            classification_obj = hazard_classification\n            classification_key = classification_obj['key']\n            classification_key_name = classification_obj['name']\n            classification_keys = classification_key + 's'\n\n            if classification_keys in lay_req:\n                allowed_classifications = [\n                    c['key'] for c in lay_req[classification_keys]]\n                req_classifications = ', '.join(allowed_classifications)\n\n                lay_classification = '&nbsp;&nbsp;-'\n                if classification_key in keywords:\n                    lay_classification = keywords[classification_key]\n\n                if lay_classification not in allowed_classifications:\n                    # We already know we want to emphasize them and the test\n                    # inside the function will always pass.\n                    lay_classification, req_classifications = emphasize(\n                        lay_classification, req_classifications)\n                classification_row = (\n                    (\n                        '<tr><td><b>%s</b></td>'\n                        + '<td>%s</td><td>%s</td></tr>')\n                    % (\n                        classification_key_name,\n                        lay_classification,\n                        req_classifications))\n\n        # Unit\n        units_row = ''\n        if lay_req['layer_mode'] == layer_mode_continuous:\n            # Determine the keyword key for the unit\n            unit_obj = (\n                continuous_hazard_unit\n                if layer_purpose == layer_purpose_hazard['key']\n                else exposure_unit)\n            unit_key = unit_obj['key']\n            unit_key_name = unit_obj['name']\n            unit_keys = unit_key + 's'\n\n            if unit_keys in lay_req:\n                allowed_units = [c['key'] for c in lay_req[unit_keys]]\n                req_units = ', '.join(allowed_units)\n\n                lay_unit = '&nbsp;&nbsp;-'\n                if unit_key in keywords:\n                    lay_unit = keywords[unit_key]\n\n                if lay_unit not in allowed_units:\n                    # We already know we want to emphasize them and the test\n                    # inside the function will always pass.\n                    lay_unit, req_units = emphasize(lay_unit, req_units)\n                units_row = (\n                    (\n                        '<tr><td><b>%s</b></td>'\n                        + '<td>%s</td><td>%s</td></tr>')\n                    % (unit_key_name, lay_unit, req_units))\n\n        html = '''\n            <table border=\"0\" width=\"100%%\" cellpadding=\"2\">\n                <tr><td width=\"33%%\"></td>\n                    <td width=\"33%%\"><b>%s</b></td>\n                    <td width=\"33%%\"><b>%s</b></td>\n                </tr>\n                <tr><td><b>%s</b></td><td>%s</td><td>%s</td></tr>\n                <tr><td><b>%s</b></td><td>%s</td><td>%s</td></tr>\n                <tr><td><b>%s</b></td><td>%s</td><td>%s</td></tr>\n                <tr><td><b>%s</b></td><td>%s</td><td>%s</td></tr>\n                %s\n                %s\n            </table>\n        ''' % (self.tr('Layer'), self.tr('Required'),\n               safe.definitions.layer_geometry.layer_geometry['name'],\n               layer_geometry_key, req_geometry,\n               safe.definitions.layer_purposes.layer_purpose['name'],\n               lay_purpose, layer_purpose,\n               layer_purpose_key_name, lay_subcategory, req_subcategory,\n               safe.definitions.layer_modes.layer_mode['name'],\n               lay_layer_mode, req_layer_mode,\n               classification_row,\n               units_row)\n        return html", "response": "Form a html description of a given non - matching layer based on the currently selected impact function requirements vs layer s parameters and keywords."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_layer_description_from_browser(self, category):\n\n        if category == 'hazard':\n            browser = self.tvBrowserHazard\n        elif category == 'exposure':\n            browser = self.tvBrowserExposure\n        elif category == 'aggregation':\n            browser = self.tvBrowserAggregation\n        else:\n            raise InaSAFEError\n\n        index = browser.selectionModel().currentIndex()\n        if not index:\n            return False, ''\n\n        # Map the proxy model index to the source model index\n        index = browser.model().mapToSource(index)\n        item = browser.model().sourceModel().dataItem(index)\n        if not item:\n            return False, ''\n\n        item_class_name = item.metaObject().className()\n        # if not itemClassName.endswith('LayerItem'):\n        if not item.type() == QgsDataItem.Layer:\n            if item_class_name == 'QgsPGRootItem' and not item.children():\n                return False, create_postGIS_connection_first\n            else:\n                return False, ''\n\n        if item_class_name not in [\n                'QgsOgrLayerItem', 'QgsGdalLayerItem', 'QgsPGLayerItem',\n                'QgsLayerItem', ]:\n            return False, ''\n\n        path = item.path()\n\n        if item_class_name in ['QgsOgrLayerItem', 'QgsGdalLayerItem',\n                               'QgsLayerItem'] and not os.path.exists(path):\n            return False, ''\n\n        # try to create the layer\n        if item_class_name == 'QgsOgrLayerItem':\n            layer = QgsVectorLayer(path, '', 'ogr')\n        elif item_class_name == 'QgsPGLayerItem':\n            uri = self.postgis_path_to_uri(path)\n            if uri:\n                layer = QgsVectorLayer(uri.uri(), uri.table(), 'postgres')\n            else:\n                layer = None\n        else:\n            layer = QgsRasterLayer(path, '', 'gdal')\n\n        if not layer or not layer.isValid():\n            return False, self.tr('Not a valid layer.')\n\n        try:\n            keywords = self.keyword_io.read_keywords(layer)\n            if 'layer_purpose' not in keywords:\n                keywords = None\n        except (HashNotFoundError,\n                OperationalError,\n                NoKeywordsFoundError,\n                KeywordNotFoundError,\n                InvalidParameterError,\n                UnsupportedProviderError,\n                MissingMetadata):\n            keywords = None\n\n        # set the layer name for further use in the step_fc_summary\n        if keywords:\n            if qgis_version() >= 21800:\n                layer.setName(keywords.get('title'))\n            else:\n                layer.setLayerName(keywords.get('title'))\n\n        if not self.parent.is_layer_compatible(layer, category, keywords):\n            label_text = '%s<br/>%s' % (\n                self.tr(\n                    'This layer\\'s keywords or type are not suitable:'),\n                self.unsuitable_layer_description_html(\n                    layer, category, keywords))\n            return False, label_text\n\n        # set the current layer (e.g. for the keyword creation sub-thread\n        #                          or for adding the layer to mapCanvas)\n        self.parent.layer = layer\n        if category == 'hazard':\n            self.parent.hazard_layer = layer\n        elif category == 'exposure':\n            self.parent.exposure_layer = layer\n        else:\n            self.parent.aggregation_layer = layer\n\n        # Check if the layer is keywordless\n        if keywords and 'keyword_version' in keywords:\n            kw_ver = str(keywords['keyword_version'])\n            self.parent.is_selected_layer_keywordless = (\n                not is_keyword_version_supported(kw_ver))\n        else:\n            self.parent.is_selected_layer_keywordless = True\n\n        desc = layer_description_html(layer, keywords)\n        return True, desc", "response": "Obtain the description of the selected layer from the browser."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreclassify a continuous vector layer.", "response": "def reclassify(layer, exposure_key=None):\n    \"\"\"Reclassify a continuous vector layer.\n\n    This function will modify the input.\n\n    For instance if you want to reclassify like this table :\n            Original Value     |   Class\n            - \u221e < val <= 0     |     1\n            0   < val <= 0.5   |     2\n            0.5 < val <= 5     |     3\n            5   < val <  + \u221e   |     6\n\n    You need a dictionary :\n        ranges = OrderedDict()\n        ranges[1] = [None, 0]\n        ranges[2] = [0.0, 0.5]\n        ranges[3] = [0.5, 5]\n        ranges[6] = [5, None]\n\n    :param layer: The raster layer.\n    :type layer: QgsRasterLayer\n\n    :param exposure_key: The exposure key.\n    :type exposure_key: str\n\n    :return: The classified vector layer.\n    :rtype: QgsVectorLayer\n\n    .. versionadded:: 4.0\n    \"\"\"\n    output_layer_name = reclassify_vector_steps['output_layer_name']\n    output_layer_name = output_layer_name % layer.keywords['title']\n\n    # This layer should have this keyword, or it's a mistake from the dev.\n    inasafe_fields = layer.keywords['inasafe_fields']\n    continuous_column = inasafe_fields[hazard_value_field['key']]\n\n    if exposure_key:\n        classification_key = active_classification(\n            layer.keywords, exposure_key)\n        thresholds = active_thresholds_value_maps(layer.keywords, exposure_key)\n        layer.keywords['thresholds'] = thresholds\n        layer.keywords['classification'] = classification_key\n    else:\n        classification_key = layer.keywords.get('classification')\n        thresholds = layer.keywords.get('thresholds')\n\n    if not thresholds:\n        raise InvalidKeywordsForProcessingAlgorithm(\n            'thresholds are missing from the layer %s'\n            % layer.keywords['layer_purpose'])\n\n    continuous_index = layer.fields().lookupField(continuous_column)\n\n    classified_field = QgsField()\n    classified_field.setType(hazard_class_field['type'])\n    classified_field.setName(hazard_class_field['field_name'])\n    classified_field.setLength(hazard_class_field['length'])\n    classified_field.setPrecision(hazard_class_field['precision'])\n\n    layer.startEditing()\n    layer.addAttribute(classified_field)\n\n    classified_field_index = layer.fields(). \\\n        lookupField(classified_field.name())\n\n    for feature in layer.getFeatures():\n        attributes = feature.attributes()\n        source_value = attributes[continuous_index]\n        classified_value = reclassify_value(source_value, thresholds)\n        if (classified_value is None\n                or (hasattr(classified_value, 'isNull')\n                    and classified_value.isNull())):\n            layer.deleteFeature(feature.id())\n        else:\n            layer.changeAttributeValue(\n                feature.id(), classified_field_index, classified_value)\n\n    layer.commitChanges()\n    layer.updateFields()\n\n    # We transfer keywords to the output.\n    inasafe_fields[hazard_class_field['key']] = (\n        hazard_class_field['field_name'])\n\n    value_map = {}\n\n    hazard_classes = definition(classification_key)['classes']\n    for hazard_class in reversed(hazard_classes):\n        value_map[hazard_class['key']] = [hazard_class['value']]\n\n    layer.keywords['value_map'] = value_map\n    layer.keywords['title'] = output_layer_name\n\n    check_layer(layer)\n    return layer"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind the next step when user clicks the Next button.", "response": "def get_next_step(self):\n        \"\"\"Find the proper step when user clicks the Next button.\n\n        :returns: The step to be switched to\n        :rtype: WizardStep\n        \"\"\"\n        layer_purpose = self.parent.step_kw_purpose.selected_purpose()\n        if layer_purpose != layer_purpose_aggregation:\n            subcategory = self.parent.step_kw_subcategory.\\\n                selected_subcategory()\n        else:\n            subcategory = {'key': None}\n\n        # Has layer groups, go to field mapping\n        field_groups = get_field_groups(\n            layer_purpose['key'], subcategory['key'])\n        compulsory_field = get_compulsory_fields(\n            layer_purpose['key'], subcategory['key'])\n\n        # It's aggregation and has field_groups.\n        if field_groups and layer_purpose == layer_purpose_aggregation:\n            return self.parent.step_kw_fields_mapping\n\n        # It has field_groups and the compulsory field is population count.\n        if field_groups and compulsory_field == population_count_field:\n            return self.parent.step_kw_fields_mapping\n\n        # Has classifications, go to multi classifications\n        if subcategory.get('classifications'):\n            if layer_purpose == layer_purpose_hazard:\n                return self.parent.step_kw_multi_classifications\n            elif layer_purpose == layer_purpose_exposure:\n                return self.parent.step_kw_classification\n\n        # Check if it can go to inasafe field step\n        non_compulsory_fields = get_non_compulsory_fields(\n            layer_purpose['key'], subcategory['key'])\n        if not skip_inasafe_field(self.parent.layer, non_compulsory_fields):\n            return self.parent.step_kw_inasafe_fields\n\n        # Check if it can go to inasafe default field step\n        default_inasafe_fields = get_fields(\n            layer_purpose['key'],\n            subcategory['key'],\n            replace_null=True,\n            in_group=False)\n        if default_inasafe_fields:\n            return self.parent.step_kw_default_inasafe_fields\n\n        # Any other case\n        return self.parent.step_kw_source"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the description label and unlock the Next button.", "response": "def on_lstFields_itemSelectionChanged(self):\n        \"\"\"Update field_names description label and unlock the Next button.\n\n        .. note:: This is an automatic Qt slot\n           executed when the field_names selection changes.\n        \"\"\"\n        self.clear_further_steps()\n        field_names = self.selected_fields()\n        layer_purpose = self.parent.step_kw_purpose.selected_purpose()\n        # Exit if no selection\n        if not field_names:\n            self.parent.pbnNext.setEnabled(False)\n            self.lblDescribeField.setText('')\n            return\n        # Compulsory fields can be list of field name or single field name.\n        # We need to iterate through all of them\n        if not isinstance(field_names, list):\n            field_names = [field_names]\n        field_descriptions = ''\n        feature_count = self.parent.layer.featureCount()\n        for field_name in field_names:\n            layer_fields = self.parent.layer.fields()\n            field_index = layer_fields.indexFromName(field_name)\n            # Exit if the selected field_names comes from a previous wizard run\n            if field_index < 0:\n                return\n\n            # Generate description for the field.\n            field_type = layer_fields.field(field_name).typeName()\n            field_index = layer_fields.indexFromName(field_name)\n            unique_values = self.parent.layer.uniqueValues(field_index)\n            unique_values_str = [\n                i is not None and str(i) or 'NULL'\n                for i in list(unique_values)[0:48]]\n            unique_values_str = ', '.join(unique_values_str)\n            field_descriptions += tr('<b>Field name</b>: {field_name}').format(\n                field_name=field_name)\n            field_descriptions += tr(\n                '<br><b>Field type</b>: {field_type}').format(\n                field_type=field_type)\n            if (feature_count != -1 and (\n                    layer_purpose == layer_purpose_aggregation)):\n                if len(unique_values) == feature_count:\n                    unique = tr('Yes')\n                else:\n                    unique = tr('No')\n                field_descriptions += tr(\n                    '<br><b>Unique</b>: {unique} ({unique_values_count} '\n                    'unique values from {feature_count} features)'.format(\n                        unique=unique,\n                        unique_values_count=len(unique_values),\n                        feature_count=feature_count))\n            field_descriptions += tr(\n                '<br><b>Unique values</b>: {unique_values_str}<br><br>'\n            ).format(unique_values_str=unique_values_str)\n\n        self.lblDescribeField.setText(field_descriptions)\n\n        self.parent.pbnNext.setEnabled(True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nobtains the fields selected by user.", "response": "def selected_fields(self):\n        \"\"\"Obtain the fields selected by user.\n\n        :returns: Keyword of the selected field.\n        :rtype: list, str\n        \"\"\"\n        items = self.lstFields.selectedItems()\n        if items and self.mode == MULTI_MODE:\n            return [item.text() for item in items]\n        elif items and self.mode == SINGLE_MODE:\n            return items[0].text()\n        else:\n            return []"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_widgets(self):\n        self.clear_further_steps()\n        purpose = self.parent.step_kw_purpose.selected_purpose()\n        subcategory = self.parent.step_kw_subcategory.selected_subcategory()\n        unit = self.parent.step_kw_unit.selected_unit()\n        layer_mode = self.parent.step_kw_layermode.selected_layermode()\n\n        # Set mode\n        # Notes(IS) I hard coded this one, need to fix it after it's working.\n        field_key = self.parent.field_keyword_for_the_layer()\n        if field_key == population_count_field['key']:\n            self.mode = MULTI_MODE\n        else:\n            self.mode = SINGLE_MODE\n\n        # Filtering based on field type\n        layer_field = definition(field_key)\n        layer_field_types = deepcopy(layer_field['type'])\n        if not isinstance(layer_field_types, list):\n            layer_field_types = [layer_field_types]\n\n        # Remove string for continuous layer\n        if layer_mode == layer_mode_continuous and unit:\n            if QVariant.String in layer_field_types:\n                layer_field_types.remove(QVariant.String)\n\n        if purpose == layer_purpose_aggregation:\n            question_text = field_question_aggregation\n        elif layer_mode == layer_mode_continuous and unit:\n            subcategory_unit_relation = get_question_text(\n                '%s_%s_question' % (subcategory['key'], unit['key']))\n            if 'MISSING' in subcategory_unit_relation:\n                subcategory_unit_relation = self.tr(\n                    '{subcategory} in {unit} unit').format(\n                    subcategory=subcategory['name'].lower(),\n                    unit=unit['plural_name'])\n            question_text = field_question_subcategory_unit % (\n                purpose['name'],\n                subcategory['name'],\n                unit['name'],\n                subcategory_unit_relation)\n        else:\n            question_text = field_question_subcategory_classified % (\n                subcategory['name'].lower(), subcategory['name'].lower())\n        if self.mode == SINGLE_MODE:\n            question_text += tr('\\nYou can select 1 field only.')\n            self.lstFields.setSelectionMode(QAbstractItemView.SingleSelection)\n        elif self.mode == MULTI_MODE:\n            question_text += tr(\n                '\\nYou can select more than 1 field. InaSAFE will sum up the '\n                'value of the fields that you choose.')\n            self.lstFields.setSelectionMode(\n                QAbstractItemView.ExtendedSelection)\n        self.lblSelectField.setText(question_text)\n        self.lstFields.clear()\n\n        default_item = None\n        for field in self.parent.layer.fields():\n            # Skip if it's not in the field types requirement\n            if field.type() not in layer_field_types:\n                continue\n            field_name = field.name()\n            item = QListWidgetItem(field_name, self.lstFields)\n            item.setData(Qt.UserRole, field_name)\n            # Select the item if it match the unit's default_attribute\n            if unit and 'default_attribute' in unit \\\n                    and field_name == unit['default_attribute']:\n                default_item = item\n            # For continuous data, gray out id, gid, fid and text fields\n            if self.parent.step_kw_layermode.\\\n                    selected_layermode() == layer_mode_continuous and unit:\n                field_type = field.type()\n                if field_type > 9 or re.match('.{0,2}id$', field_name, re.I):\n                    continue  # Don't show unmatched field type\n\n        if default_item:\n            self.lstFields.setCurrentItem(default_item)\n        self.lblDescribeField.clear()\n\n        # Set values based on existing keywords (if already assigned)\n        field_keyword = self.parent.field_keyword_for_the_layer()\n        inasafe_field_keywords = self.parent.get_existing_keyword(\n            'inasafe_fields')\n        if inasafe_field_keywords:\n            fields = inasafe_field_keywords.get(field_keyword)\n            if isinstance(fields, str):\n                fields = [fields]\n            if fields:\n                option_fields = []\n                for index in range(self.lstFields.count()):\n                    option_fields.append(\n                        str(self.lstFields.item(index).text()))\n                for field in fields:\n                    if field in option_fields:\n                        self.lstFields.item(option_fields.index(\n                            field)).setSelected(True)\n\n        self.auto_select_one_item(self.lstFields)\n\n        if self.selected_fields():\n            self.parent.pbnNext.setEnabled(True)\n        else:\n            self.parent.pbnNext.setEnabled(False)", "response": "Set widgets on the Field tab."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the dict representation of the object", "response": "def dict(self):\n        \"\"\"\n        the dict representation.\n\n        :return: the dict\n        :rtype: dict\n        \"\"\"\n\n        return {\n            'title': self.title,\n            'description': self.description,\n            'time': self.time.isoformat(),\n            'data': self.data()\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_xml(self, close_tag=True):\n\n        provenance_step_element = Element('provenance_step', {\n            'timestamp': self.time.isoformat()\n        })\n        title = SubElement(provenance_step_element, 'title')\n        title.text = self.title\n        description = SubElement(provenance_step_element, 'description')\n        description.text = self.description\n\n        xml_string = tostring(provenance_step_element, 'unicode')\n\n        if close_tag:\n            return xml_string\n        else:\n            # Remove the close tag\n            return xml_string[:-len('</provenance_step>')]", "response": "Generate the xml string representation of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfetches a specific item according to its type in a layout.", "response": "def layout_item(layout, item_id, item_class):\n    \"\"\"Fetch a specific item according to its type in a layout.\n\n    There's some sip casting conversion issues with QgsLayout::itemById.\n    Don't use it, and use this function instead.\n    See https://github.com/inasafe/inasafe/issues/4271\n\n    :param layout: The layout to look in.\n    :type layout: QgsLayout\n\n    :param item_id: The ID of the item to look for.\n    :type item_id: basestring\n\n    :param item_class: The expected class name.\n    :type item_class: cls\n\n    :return: The layout item, inherited class of QgsLayoutItem.\n    \"\"\"\n    item = layout.itemById(item_id)\n    if item is None:\n        # no match!\n        return item\n\n    if issubclass(item_class, QgsLayoutMultiFrame):\n        # finding a multiframe by frame id\n        frame = sip.cast(item, QgsLayoutFrame)\n        multi_frame = frame.multiFrame()\n        return sip.cast(multi_frame, item_class)\n    else:\n        # force sip to correctly cast item to required type\n        return sip.cast(item, item_class)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate QGIS PDF output using QGIS layout.", "response": "def create_qgis_pdf_output(\n        impact_report,\n        output_path,\n        layout,\n        file_format,\n        metadata):\n    \"\"\"Produce PDF output using QgsLayout.\n\n    :param output_path: The output path.\n    :type output_path: str\n\n    :param layout: QGIS Layout object.\n    :type layout: qgis.core.QgsPrintLayout\n\n    :param qgis_composition_context: QGIS Composition context used by renderer.\n    :type qgis_composition_context: safe.report.impact_report.\n        QgsLayoutContext\n\n    :param file_format: file format of map output, PDF or PNG.\n    :type file_format: 'pdf', 'png'\n\n    :param metadata: The component metadata.\n    :type metadata: QgisComposerComponentsMetadata\n\n    :return: Generated output path.\n    :rtype: str\n    \"\"\"\n    # make sure directory is created\n    dirname = os.path.dirname(output_path)\n    if not os.path.exists(dirname):\n        os.makedirs(dirname)\n\n    qgis_composition_context = impact_report.qgis_composition_context\n    aggregation_summary_layer = (\n        impact_report.impact_function.aggregation_summary)\n\n    # process atlas generation\n    print_atlas = setting('print_atlas_report', False, bool)\n    if layout.atlas().enabled() and (\n            print_atlas and aggregation_summary_layer):\n        output_path = atlas_renderer(\n            layout, aggregation_summary_layer, output_path, file_format)\n    # for QGIS layout only pdf and png output are available\n    elif file_format == QgisComposerComponentsMetadata.OutputFormat.PDF:\n        try:\n            exporter = QgsLayoutExporter(layout)\n            settings = QgsLayoutExporter.PdfExportSettings()\n            settings.dpi = metadata.page_dpi\n            settings.rasterizeWholeImage = \\\n                qgis_composition_context.save_as_raster\n            # settings.forceVectorOutput = False\n            # settings.exportMetadata = True\n\n            # TODO: ABP: check that page size is set on the pages\n            res = exporter.exportToPdf(output_path, settings)\n            if res != QgsLayoutExporter.Success:\n                LOGGER.error('Error exporting to {}'.format(\n                    exporter.errorFile()))\n                return None\n        except Exception as exc:\n            LOGGER.error(exc)\n            return None\n    elif file_format == QgisComposerComponentsMetadata.OutputFormat.PNG:\n        # TODO: implement PNG generation\n        raise Exception('Not yet supported')\n    return output_path"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_qgis_template_output(output_path, layout):\n    # make sure directory is created\n    dirname = os.path.dirname(output_path)\n    if not os.path.exists(dirname):\n        os.makedirs(dirname)\n\n    context = QgsReadWriteContext()\n    context.setPathResolver(QgsProject.instance().pathResolver())\n\n    layout.saveAsTemplate(output_path, context)\n    return output_path", "response": "Produce QGIS Template output."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef qgis_composer_html_renderer(impact_report, component):\n    context = component.context\n\n    # QGIS3: not used\n    # qgis_composition_context = impact_report.qgis_composition_context\n\n    # create new layout with A4 portrait page\n    layout = QgsPrintLayout(QgsProject.instance())\n    page = QgsLayoutItemPage(layout)\n    page.setPageSize('A4', orientation=QgsLayoutItemPage.Portrait)\n    layout.pageCollection().addPage(page)\n\n    if not context.html_frame_elements:\n        # if no html frame elements at all, do not generate empty report.\n        component.output = ''\n        return component.output\n\n    # Add HTML Frame\n    for html_el in context.html_frame_elements:\n        mode = html_el.get('mode')\n        html_element = QgsLayoutItemHtml(layout)\n        margin_left = html_el.get('margin_left', 10)\n        margin_top = html_el.get('margin_top', 10)\n        width = html_el.get('width', component.page_width - 2 * margin_left)\n        height = html_el.get('height', component.page_height - 2 * margin_top)\n\n        html_frame = QgsLayoutFrame(layout, html_element)\n        html_frame.attemptSetSceneRect(\n            QRectF(margin_left, margin_top, width, height))\n        html_element.addFrame(html_frame)\n\n        if html_element:\n            if mode == 'text':\n                text = html_el.get('text')\n                text = text if text else ''\n                html_element.setContentMode(QgsLayoutItemHtml.ManualHtml)\n                html_element.setResizeMode(\n                    QgsLayoutItemHtml.RepeatUntilFinished)\n                html_element.setHtml(text)\n                html_element.loadHtml()\n            elif mode == 'url':\n                url = html_el.get('url')\n                html_element.setContentMode(QgsLayoutItemHtml.Url)\n                html_element.setResizeMode(\n                    QgsLayoutItemHtml.RepeatUntilFinished)\n                qurl = QUrl.fromLocalFile(url)\n                html_element.setUrl(qurl)\n\n    # Attempt on removing blank page. Notes: We assume that the blank page\n    # will always appears in the last x page(s), not in the middle.\n\n    pc = layout.pageCollection()\n    index = pc.pageCount()\n    while pc.pageIsEmpty(index):\n        pc.deletePage(index)\n        index -= 1\n\n    # process to output\n\n    # in case output folder not specified\n    if impact_report.output_folder is None:\n        impact_report.output_folder = mkdtemp(dir=temp_dir())\n    component_output_path = impact_report.component_absolute_output_path(\n        component.key)\n    component_output = None\n\n    output_format = component.output_format\n\n    doc_format = QgisComposerComponentsMetadata.OutputFormat.DOC_OUTPUT\n    template_format = QgisComposerComponentsMetadata.OutputFormat.QPT\n    if isinstance(output_format, list):\n        component_output = []\n        for i in range(len(output_format)):\n            each_format = output_format[i]\n            each_path = component_output_path[i]\n\n            if each_format in doc_format:\n                result_path = create_qgis_pdf_output(\n                    impact_report,\n                    each_path,\n                    layout,\n                    each_format,\n                    component)\n                component_output.append(result_path)\n            elif each_format == template_format:\n                result_path = create_qgis_template_output(\n                    each_path, layout)\n                component_output.append(result_path)\n    elif isinstance(output_format, dict):\n        component_output = {}\n        for key, each_format in list(output_format.items()):\n            each_path = component_output_path[key]\n\n            if each_format in doc_format:\n                result_path = create_qgis_pdf_output(\n                    impact_report,\n                    each_path,\n                    layout,\n                    each_format,\n                    component)\n                component_output[key] = result_path\n            elif each_format == template_format:\n                result_path = create_qgis_template_output(\n                    each_path, layout)\n                component_output[key] = result_path\n    elif (output_format in\n            QgisComposerComponentsMetadata.OutputFormat.SUPPORTED_OUTPUT):\n        component_output = None\n\n        if output_format in doc_format:\n            result_path = create_qgis_pdf_output(\n                impact_report,\n                component_output_path,\n                layout,\n                output_format,\n                component)\n            component_output = result_path\n        elif output_format == template_format:\n            result_path = create_qgis_template_output(\n                component_output_path, layout)\n            component_output = result_path\n\n    component.output = component_output\n\n    return component.output", "response": "Render HTML to PDF using QGIS Composer."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndefaults QGIS Composition Renderer using QGIS Composer.", "response": "def qgis_composer_renderer(impact_report, component):\n    \"\"\"Default Map Report Renderer using QGIS Composer.\n\n    Render using qgis composer for a given impact_report data and component\n    context.\n\n    :param impact_report: ImpactReport contains data about the report that is\n        going to be generated.\n    :type impact_report: safe.report.impact_report.ImpactReport\n\n    :param component: Contains the component metadata and context for\n        rendering the output.\n    :type component:\n        safe.report.report_metadata.QgisComposerComponentsMetadata\n\n    :return: Whatever type of output the component should be.\n\n    .. versionadded:: 4.0\n    \"\"\"\n    context = component.context\n    qgis_composition_context = impact_report.qgis_composition_context\n\n    # load composition object\n    layout = QgsPrintLayout(QgsProject.instance())\n\n    # load template\n    main_template_folder = impact_report.metadata.template_folder\n\n    # we do this condition in case custom template was found\n    if component.template.startswith('../qgis-composer-templates/'):\n        template_path = os.path.join(main_template_folder, component.template)\n    else:\n        template_path = component.template\n\n    with open(template_path) as template_file:\n        template_content = template_file.read()\n\n    document = QtXml.QDomDocument()\n\n    # Replace\n    for k, v in context.substitution_map.items():\n        template_content = template_content.replace('[{}]'.format(k), v)\n\n    document.setContent(template_content)\n\n    rwcontext = QgsReadWriteContext()\n    load_status = layout.loadFromTemplate(\n        document, rwcontext)\n\n    if not load_status:\n        raise TemplateLoadingError(\n            tr('Error loading template: %s') % template_path)\n\n    # replace image path\n    for img in context.image_elements:\n        item_id = img.get('id')\n        path = img.get('path')\n        image = layout_item(layout, item_id, QgsLayoutItemPicture)\n        if image and path:\n            image.setPicturePath(path)\n\n    # replace html frame\n    for html_el in context.html_frame_elements:\n        item_id = html_el.get('id')\n        mode = html_el.get('mode')\n        html_element = layout_item(layout, item_id, QgsLayoutItemHtml)\n        if html_element:\n            if mode == 'text':\n                text = html_el.get('text')\n                text = text if text else ''\n                html_element.setContentMode(QgsLayoutItemHtml.ManualHtml)\n                html_element.setHtml(text)\n                html_element.loadHtml()\n            elif mode == 'url':\n                url = html_el.get('url')\n                html_element.setContentMode(QgsLayoutItemHtml.Url)\n                qurl = QUrl.fromLocalFile(url)\n                html_element.setUrl(qurl)\n\n    original_crs = impact_report.impact_function.crs\n    destination_crs = qgis_composition_context.map_settings.destinationCrs()\n    coord_transform = QgsCoordinateTransform(original_crs,\n                                             destination_crs,\n                                             QgsProject.instance())\n\n    # resize map extent\n    for map_el in context.map_elements:\n        item_id = map_el.get('id')\n        split_count = map_el.get('grid_split_count')\n        layers = [\n            layer for layer in map_el.get('layers') if isinstance(\n                layer, QgsMapLayer)\n        ]\n        map_extent_option = map_el.get('extent')\n        composer_map = layout_item(layout, item_id, QgsLayoutItemMap)\n\n        for index, layer in enumerate(layers):\n            # we need to check whether the layer is registered or not\n            registered_layer = (\n                QgsProject.instance().mapLayer(layer.id()))\n            if registered_layer:\n                if not registered_layer == layer:\n                    layers[index] = registered_layer\n            else:\n                QgsProject.instance().addMapLayer(layer)\n\n        \"\"\":type: qgis.core.QgsLayoutItemMap\"\"\"\n        if composer_map:\n\n            # Search for specified map extent in the template.\n            min_x = composer_map.extent().xMinimum() if (\n                impact_report.use_template_extent) else None\n            min_y = composer_map.extent().yMinimum() if (\n                impact_report.use_template_extent) else None\n            max_x = composer_map.extent().xMaximum() if (\n                impact_report.use_template_extent) else None\n            max_y = composer_map.extent().yMaximum() if (\n                impact_report.use_template_extent) else None\n\n            composer_map.setKeepLayerSet(True)\n            layer_set = [l for l in layers if isinstance(l, QgsMapLayer)]\n            composer_map.setLayers(layer_set)\n            map_overview_extent = None\n            if map_extent_option and isinstance(\n                    map_extent_option, QgsRectangle):\n                # use provided map extent\n                extent = coord_transform.transform(map_extent_option)\n                for l in [layer for layer in layers if\n                          isinstance(layer, QgsMapLayer)]:\n                    layer_extent = coord_transform.transform(l.extent())\n                    if l.name() == map_overview['id']:\n                        map_overview_extent = layer_extent\n            else:\n                # if map extent not provided, try to calculate extent\n                # from list of given layers. Combine it so all layers were\n                # shown properly\n                extent = QgsRectangle()\n                extent.setMinimal()\n                for l in [layer for layer in layers if\n                          isinstance(layer, QgsMapLayer)]:\n                    # combine extent if different layer is provided.\n                    layer_extent = coord_transform.transform(l.extent())\n                    extent.combineExtentWith(layer_extent)\n                    if l.name() == map_overview['id']:\n                        map_overview_extent = layer_extent\n\n            width = extent.width()\n            height = extent.height()\n            longest_width = width if width > height else height\n            half_length = longest_width / 2\n            margin = half_length / 5\n            center = extent.center()\n            min_x = min_x or (center.x() - half_length - margin)\n            max_x = max_x or (center.x() + half_length + margin)\n            min_y = min_y or (center.y() - half_length - margin)\n            max_y = max_y or (center.y() + half_length + margin)\n\n            # noinspection PyCallingNonCallable\n            square_extent = QgsRectangle(min_x, min_y, max_x, max_y)\n\n            if component.key == 'population-infographic' and (\n                    map_overview_extent):\n                square_extent = map_overview_extent\n\n            composer_map.zoomToExtent(square_extent)\n            composer_map.invalidateCache()\n\n            actual_extent = composer_map.extent()\n\n            # calculate intervals for grid\n            x_interval = actual_extent.width() / split_count\n            composer_map.grid().setIntervalX(x_interval)\n            y_interval = actual_extent.height() / split_count\n            composer_map.grid().setIntervalY(y_interval)\n\n    # calculate legend element\n    for leg_el in context.map_legends:\n        item_id = leg_el.get('id')\n        title = leg_el.get('title')\n        layers = [\n            layer for layer in leg_el.get('layers') if isinstance(\n                layer, QgsMapLayer)\n        ]\n        symbol_count = leg_el.get('symbol_count')\n        column_count = leg_el.get('column_count')\n\n        legend = layout_item(layout, item_id, QgsLayoutItemLegend)\n        \"\"\":type: qgis.core.QgsLayoutItemLegend\"\"\"\n        if legend:\n            # set column count\n            if column_count:\n                legend.setColumnCount(column_count)\n            elif symbol_count <= 7:\n                legend.setColumnCount(1)\n            else:\n                legend.setColumnCount(symbol_count / 7 + 1)\n\n            # set legend title\n            if title is not None and not impact_report.legend_layers:\n                legend.setTitle(title)\n\n            # set legend\n            root_group = legend.model().rootGroup()\n            for layer in layers:\n                # we need to check whether the layer is registered or not\n                registered_layer = (\n                    QgsProject.instance().mapLayer(layer.id()))\n                if registered_layer:\n                    if not registered_layer == layer:\n                        layer = registered_layer\n                else:\n                    QgsProject.instance().addMapLayer(layer)\n                # used for customizations\n                tree_layer = root_group.addLayer(layer)\n                if impact_report.legend_layers or (\n                        not impact_report.multi_exposure_impact_function):\n                    QgsLegendRenderer.setNodeLegendStyle(\n                        tree_layer, QgsLegendStyle.Hidden)\n            legend.adjustBoxSize()\n            legend.updateFilterByMap(False)\n\n    # process to output\n\n    # in case output folder not specified\n    if impact_report.output_folder is None:\n        impact_report.output_folder = mkdtemp(dir=temp_dir())\n\n    output_format = component.output_format\n    component_output_path = impact_report.component_absolute_output_path(\n        component.key)\n    component_output = None\n\n    doc_format = QgisComposerComponentsMetadata.OutputFormat.DOC_OUTPUT\n    template_format = QgisComposerComponentsMetadata.OutputFormat.QPT\n    if isinstance(output_format, list):\n        component_output = []\n        for i in range(len(output_format)):\n            each_format = output_format[i]\n            each_path = component_output_path[i]\n\n            if each_format in doc_format:\n                result_path = create_qgis_pdf_output(\n                    impact_report,\n                    each_path,\n                    layout,\n                    each_format,\n                    component)\n                component_output.append(result_path)\n            elif each_format == template_format:\n                result_path = create_qgis_template_output(\n                    each_path, layout)\n                component_output.append(result_path)\n    elif isinstance(output_format, dict):\n        component_output = {}\n        for key, each_format in list(output_format.items()):\n            each_path = component_output_path[key]\n\n            if each_format in doc_format:\n                result_path = create_qgis_pdf_output(\n                    impact_report,\n                    each_path,\n                    layout,\n                    each_format,\n                    component)\n                component_output[key] = result_path\n            elif each_format == template_format:\n                result_path = create_qgis_template_output(\n                    each_path, layout)\n                component_output[key] = result_path\n    elif (output_format in\n            QgisComposerComponentsMetadata.OutputFormat.SUPPORTED_OUTPUT):\n        component_output = None\n\n        if output_format in doc_format:\n            result_path = create_qgis_pdf_output(\n                impact_report,\n                component_output_path,\n                layout,\n                output_format,\n                component)\n            component_output = result_path\n        elif output_format == template_format:\n            result_path = create_qgis_template_output(\n                component_output_path, layout)\n            component_output = result_path\n\n    component.output = component_output\n\n    return component.output"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef qt_svg_to_png_renderer(impact_report, component):\n    context = component.context\n    filepath = context['filepath']\n    width = component.extra_args['width']\n    height = component.extra_args['height']\n    image_format = QImage.Format_ARGB32\n    qimage = QImage(width, height, image_format)\n    qimage.fill(0x00000000)\n    renderer = QSvgRenderer(filepath)\n    painter = QPainter(qimage)\n    renderer.render(painter)\n    # Should call painter.end() so that QImage is not used\n    painter.end()\n\n    # in case output folder not specified\n    if impact_report.output_folder is None:\n        impact_report.output_folder = mkdtemp(dir=temp_dir())\n    output_path = impact_report.component_absolute_output_path(\n        component.key)\n\n    qimage.save(output_path)\n\n    component.output = output_path\n    return component.output", "response": "Render SVG into PNG."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef atlas_renderer(layout, coverage_layer, output_path, file_format):\n    # set the composer map to be atlas driven\n    composer_map = layout_item(\n        layout, 'impact-map', QgsLayoutItemMap)\n    composer_map.setAtlasDriven(True)\n    composer_map.setAtlasScalingMode(QgsLayoutItemMap.Auto)\n\n    # setup the atlas composition and composition atlas mode\n    atlas_composition = layout.atlas()\n    atlas_composition.setCoverageLayer(coverage_layer)\n    atlas_on_single_file = layout.customProperty('singleFile', True)\n\n    if file_format == QgisComposerComponentsMetadata.OutputFormat.PDF:\n        if not atlas_composition.filenameExpression():\n            atlas_composition.setFilenameExpression(\n                \"'output_'||@atlas_featurenumber\")\n        output_directory = os.path.dirname(output_path)\n\n        # we need to set the predefined scales for atlas\n        project_scales = []\n        scales = QgsProject.instance().readListEntry(\n            \"Scales\", \"/ScalesList\")[0]\n        has_project_scales = QgsProject.instance().readBoolEntry(\n            \"Scales\", \"/useProjectScales\")[0]\n        if not has_project_scales or not scales:\n            scales_string = str(general_setting(\"Map/scales\", PROJECT_SCALES))\n            scales = scales_string.split(',')\n        for scale in scales:\n            parts = scale.split(':')\n            if len(parts) == 2:\n                project_scales.append(float(parts[1]))\n        layout.reportContext().setPredefinedScales(project_scales)\n\n        settings = QgsLayoutExporter.PdfExportSettings()\n\n        LOGGER.info('Exporting Atlas')\n        atlas_output = []\n        if atlas_on_single_file:\n            res, error = QgsLayoutExporter.exportToPdf(\n                atlas_composition, output_path, settings)\n            atlas_output.append(output_path)\n        else:\n            res, error = QgsLayoutExporter.exportToPdfs(\n                atlas_composition, output_directory, settings)\n\n        if res != QgsLayoutExporter.Success:\n            LOGGER.error(error)\n\n        return atlas_output", "response": "Generate a new composition for the atlas map."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef general_report_extractor(impact_report, component_metadata):\n    multi_exposure = impact_report.multi_exposure_impact_function\n    if multi_exposure:\n        return multi_exposure_general_report_extractor(\n            impact_report, component_metadata)\n\n    context = {}\n    extra_args = component_metadata.extra_args\n\n    # figure out analysis report type\n    analysis_layer = impact_report.analysis\n    provenance = impact_report.impact_function.provenance\n    use_rounding = impact_report.impact_function.use_rounding\n    hazard_keywords = provenance['hazard_keywords']\n    exposure_keywords = provenance['exposure_keywords']\n\n    exposure_type = definition(exposure_keywords['exposure'])\n    # Only round the number when it is population exposure and we use rounding\n    is_population = exposure_type is exposure_population\n\n    # find hazard class\n    summary = []\n\n    analysis_feature = next(analysis_layer.getFeatures())\n    analysis_inasafe_fields = analysis_layer.keywords['inasafe_fields']\n\n    exposure_unit = exposure_type['units'][0]\n    hazard_header = resolve_from_dictionary(extra_args, 'hazard_header')\n    if exposure_unit['abbreviation']:\n        value_header = '{measure} ({abbreviation})'.format(**exposure_unit)\n    else:\n        value_header = '{name}'.format(**exposure_unit)\n\n    # Get hazard classification\n    hazard_classification = definition(\n        active_classification(hazard_keywords, exposure_keywords['exposure']))\n\n    # in case there is a classification\n    if hazard_classification:\n\n        # classified hazard must have hazard count in analysis layer\n        hazard_stats = []\n        for hazard_class in hazard_classification['classes']:\n            # hazard_count_field is a dynamic field with hazard class\n            # as parameter\n            field_key_name = hazard_count_field['key'] % (\n                hazard_class['key'], )\n            try:\n                # retrieve dynamic field name from analysis_fields keywords\n                # will cause key error if no hazard count for that particular\n                # class\n                field_name = analysis_inasafe_fields[field_key_name]\n                field_index = analysis_layer.fields().lookupField(field_name)\n                # Hazard label taken from translated hazard count field\n                # label, string-formatted with translated hazard class label\n                hazard_label = hazard_class['name']\n\n                hazard_value = format_number(\n                    analysis_feature[field_index],\n                    use_rounding=use_rounding,\n                    is_population=is_population)\n                stats = {\n                    'key': hazard_class['key'],\n                    'name': hazard_label,\n                    'numbers': [hazard_value]\n                }\n            except KeyError:\n                # in case the field was not found\n                hazard_label = hazard_class['name']\n                stats = {\n                    'key': hazard_class['key'],\n                    'name': hazard_label,\n                    'numbers': ['0'],\n                }\n\n            hazard_stats.append(stats)\n\n        # find total field\n        try:\n            field_name = analysis_inasafe_fields[total_exposed_field['key']]\n            total = value_from_field_name(field_name, analysis_layer)\n            total = format_number(\n                total, use_rounding=use_rounding, is_population=is_population)\n            stats = {\n                'key': total_exposed_field['key'],\n                'name': total_exposed_field['name'],\n                'as_header': True,\n                'numbers': [total]\n            }\n            hazard_stats.append(stats)\n        except KeyError:\n            pass\n\n        summary.append({\n            'header_label': hazard_header,\n            'value_labels': [value_header],\n            'rows': hazard_stats\n        })\n\n    # retrieve affected column\n    report_stats = []\n\n    reported_fields = resolve_from_dictionary(\n        extra_args, 'reported_fields')\n    for item in reported_fields:\n        header = item['header']\n        field = item['field']\n        if field['key'] in analysis_inasafe_fields:\n            field_index = analysis_layer.fields().lookupField(\n                field['field_name'])\n            if field == fatalities_field:\n                # For fatalities field, we show a range of number\n                # instead\n                row_value = fatalities_range(analysis_feature[field_index])\n            else:\n                row_value = format_number(\n                    analysis_feature[field_index],\n                    use_rounding=use_rounding,\n                    is_population=is_population)\n            row_stats = {\n                'key': field['key'],\n                'name': header,\n                'numbers': [row_value]\n            }\n            report_stats.append(row_stats)\n\n    # Give report section\n    header_label = exposure_type['name']\n    summary.append({\n        'header_label': header_label,\n        # This should depend on exposure unit\n        # TODO: Change this so it can take the unit dynamically\n        'value_labels': [value_header],\n        'rows': report_stats\n    })\n\n    header = resolve_from_dictionary(extra_args, ['header'])\n    table_header_format = resolve_from_dictionary(\n        extra_args, 'table_header_format')\n    table_header = table_header_format.format(\n        title=provenance['map_legend_title'],\n        unit=hazard_classification['classification_unit'])\n\n    # Section notes\n    note_format = resolve_from_dictionary(\n        extra_args, ['concept_notes', 'note_format'])\n\n    if is_population:\n        concepts = resolve_from_dictionary(\n            extra_args, ['concept_notes', 'population_concepts'])\n    else:\n        concepts = resolve_from_dictionary(\n            extra_args, ['concept_notes', 'general_concepts'])\n\n    notes = []\n    for concept in concepts:\n        note = note_format.format(**concept)\n        notes.append(note)\n\n    context['component_key'] = component_metadata.key\n    context['header'] = header\n    context['summary'] = summary\n    context['table_header'] = table_header\n    context['notes'] = notes\n\n    return context", "response": "This function extracts the general analysis result from the impact report and returns the context for rendering the phase."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef multi_exposure_general_report_extractor(impact_report, component_metadata):\n    context = {}\n    extra_args = component_metadata.extra_args\n\n    multi_exposure = impact_report.multi_exposure_impact_function\n    analysis_layer = impact_report.analysis\n    provenances = [\n        impact_function.provenance for impact_function in (\n            multi_exposure.impact_functions)]\n    debug_mode = multi_exposure.debug\n    population_exist = False\n\n    hazard_keywords = provenances[0]['hazard_keywords']\n    hazard_header = resolve_from_dictionary(extra_args, 'hazard_header')\n\n    reported_fields = resolve_from_dictionary(extra_args, 'reported_fields')\n\n    # Summarize every value needed for each exposure and extract later to the\n    # context.\n    summary = []\n    map_legend_titles = []\n    hazard_classifications = {}\n    exposures_stats = []\n    for provenance in provenances:\n        map_legend_title = provenance['map_legend_title']\n        map_legend_titles.append(map_legend_title)\n        exposure_stats = {}\n        exposure_keywords = provenance['exposure_keywords']\n        exposure_type = definition(exposure_keywords['exposure'])\n        exposure_stats['exposure'] = exposure_type\n        # Only round the number when it is population exposure and it is not\n        # in debug mode\n        is_rounded = not debug_mode\n        is_population = exposure_type is exposure_population\n        if is_population:\n            population_exist = True\n\n        analysis_feature = next(analysis_layer.getFeatures())\n        analysis_inasafe_fields = analysis_layer.keywords['inasafe_fields']\n\n        exposure_unit = exposure_type['units'][0]\n        if exposure_unit['abbreviation']:\n            value_header = '{measure} ({abbreviation})'.format(\n                measure=map_legend_title,\n                abbreviation=exposure_unit['abbreviation'])\n        else:\n            value_header = '{name}'.format(name=map_legend_title)\n\n        exposure_stats['value_header'] = value_header\n\n        # Get hazard classification\n        hazard_classification = definition(\n            active_classification(hazard_keywords,\n                                  exposure_keywords['exposure']))\n        hazard_classifications[exposure_type['key']] = hazard_classification\n\n        # in case there is a classification\n        if hazard_classification:\n            classification_result = {}\n            reported_fields_result = {}\n            for hazard_class in hazard_classification['classes']:\n                # hazard_count_field is a dynamic field with hazard class\n                # as parameter\n                field_key_name = exposure_hazard_count_field['key'] % (\n                    exposure_type['key'], hazard_class['key'])\n                try:\n                    # retrieve dynamic field name from analysis_fields keywords\n                    # will cause key error if no hazard count for that\n                    # particular class\n                    field_name = analysis_inasafe_fields[field_key_name]\n                    field_index = analysis_layer.fields() \\\n                        .lookupField(field_name)\n                    hazard_value = format_number(\n                        analysis_feature[field_index],\n                        use_rounding=is_rounded,\n                        is_population=is_population)\n                except KeyError:\n                    # in case the field was not found\n                    hazard_value = 0\n\n                classification_result[hazard_class['key']] = hazard_value\n\n            # find total field\n            try:\n                field_key_name = exposure_total_exposed_field['key'] % (\n                    exposure_type['key'])\n                field_name = analysis_inasafe_fields[field_key_name]\n                total = value_from_field_name(field_name, analysis_layer)\n                total = format_number(\n                    total, use_rounding=is_rounded,\n                    is_population=is_population)\n                classification_result[total_exposed_field['key']] = total\n            except KeyError:\n                pass\n\n            exposure_stats['classification_result'] = classification_result\n\n        for item in reported_fields:\n            field = item.get('field')\n            multi_exposure_field = item.get('multi_exposure_field')\n            row_value = '-'\n            if multi_exposure_field:\n                field_key = (\n                    multi_exposure_field['key'] % (exposure_type['key']))\n                field_name = (\n                    multi_exposure_field['field_name'] % (\n                        exposure_type['key']))\n                if field_key in analysis_inasafe_fields:\n                    field_index = analysis_layer.fields() \\\n                        .lookupField(field_name)\n                    row_value = format_number(\n                        analysis_feature[field_index],\n                        use_rounding=is_rounded,\n                        is_population=is_population)\n\n            elif field in [displaced_field, fatalities_field]:\n                if field['key'] in analysis_inasafe_fields and is_population:\n                    field_index = analysis_layer.fields(\n                    ).lookupField(field['name'])\n                    if field == fatalities_field:\n                        # For fatalities field, we show a range of number\n                        # instead\n                        row_value = fatalities_range(\n                            analysis_feature[field_index])\n                    else:\n                        row_value = format_number(\n                            analysis_feature[field_index],\n                            use_rounding=is_rounded,\n                            is_population=is_population)\n\n            reported_fields_result[field['key']] = row_value\n\n        exposure_stats['reported_fields_result'] = reported_fields_result\n        exposures_stats.append(exposure_stats)\n\n    # After finish summarizing value, then proceed to context extraction.\n\n    # find total value and labels for each exposure\n    value_headers = []\n    total_values = []\n    for exposure_stats in exposures_stats:\n        # label\n        value_header = exposure_stats['value_header']\n        value_headers.append(value_header)\n\n        # total value\n        classification_result = exposure_stats['classification_result']\n        total_value = classification_result[total_exposed_field['key']]\n        total_values.append(total_value)\n\n    classifications = list(hazard_classifications.values())\n    is_item_identical = (\n        classifications.count(\n            classifications[0]) == len(classifications))\n    if classifications and is_item_identical:\n        hazard_stats = []\n        for hazard_class in classifications[0]['classes']:\n            values = []\n            for exposure_stats in exposures_stats:\n                classification_result = exposure_stats['classification_result']\n                value = classification_result[hazard_class['key']]\n                values.append(value)\n            stats = {\n                'key': hazard_class['key'],\n                'name': hazard_class['name'],\n                'numbers': values\n            }\n            hazard_stats.append(stats)\n\n        total_stats = {\n            'key': total_exposed_field['key'],\n            'name': total_exposed_field['name'],\n            'as_header': True,\n            'numbers': total_values\n        }\n        hazard_stats.append(total_stats)\n\n        summary.append({\n            'header_label': hazard_header,\n            'value_labels': value_headers,\n            'rows': hazard_stats\n        })\n    # if there are different hazard classifications used in the analysis,\n    # we will create a separate table for each hazard classification\n    else:\n        hazard_classification_groups = {}\n        for exposure_key, hazard_classification in (\n                iter(list(hazard_classifications.items()))):\n            exposure_type = definition(exposure_key)\n            if hazard_classification['key'] not in (\n                    hazard_classification_groups):\n                hazard_classification_groups[hazard_classification['key']] = [\n                    exposure_type]\n            else:\n                hazard_classification_groups[\n                    hazard_classification['key']].append(exposure_type)\n\n        for hazard_classification_key, exposures in (\n                iter(list(hazard_classification_groups.items()))):\n            custom_headers = []\n            custom_total_values = []\n            # find total value and labels for each exposure\n            for exposure_stats in exposures_stats:\n                if exposure_stats['exposure'] not in exposures:\n                    continue\n                # label\n                value_header = exposure_stats['value_header']\n                custom_headers.append(value_header)\n\n                # total value\n                classification_result = exposure_stats['classification_result']\n                total_value = classification_result[total_exposed_field['key']]\n                custom_total_values.append(total_value)\n\n            hazard_stats = []\n            hazard_classification = definition(hazard_classification_key)\n            for hazard_class in hazard_classification['classes']:\n                values = []\n                for exposure_stats in exposures_stats:\n                    if exposure_stats['exposure'] not in exposures:\n                        continue\n                    classification_result = exposure_stats[\n                        'classification_result']\n                    value = classification_result[hazard_class['key']]\n                    values.append(value)\n                stats = {\n                    'key': hazard_class['key'],\n                    'name': hazard_class['name'],\n                    'numbers': values\n                }\n                hazard_stats.append(stats)\n\n            total_stats = {\n                'key': total_exposed_field['key'],\n                'name': total_exposed_field['name'],\n                'as_header': True,\n                'numbers': custom_total_values\n            }\n            hazard_stats.append(total_stats)\n\n            summary.append({\n                'header_label': hazard_header,\n                'value_labels': custom_headers,\n                'rows': hazard_stats\n            })\n\n    reported_fields_stats = []\n    for item in reported_fields:\n        field = item.get('field')\n        values = []\n        for exposure_stats in exposures_stats:\n            reported_fields_result = exposure_stats['reported_fields_result']\n            value = reported_fields_result[field['key']]\n            values.append(value)\n        stats = {\n            'key': field['key'],\n            'name': item['header'],\n            'numbers': values\n        }\n        reported_fields_stats.append(stats)\n\n    header_label = resolve_from_dictionary(\n        extra_args, ['reported_fields_header'])\n    summary.append({\n        'header_label': header_label,\n        'value_labels': value_headers,\n        'rows': reported_fields_stats\n    })\n\n    header = resolve_from_dictionary(extra_args, ['header'])\n\n    combined_map_legend_title = ''\n    for index, map_legend_title in enumerate(map_legend_titles):\n        combined_map_legend_title += map_legend_title\n        if not (index + 1) == len(map_legend_titles):\n            combined_map_legend_title += ', '\n\n    table_header_format = resolve_from_dictionary(\n        extra_args, 'table_header_format')\n    table_header = table_header_format.format(\n        title=combined_map_legend_title,\n        unit=classifications[0]['classification_unit'])\n\n    # Section notes\n    note_format = resolve_from_dictionary(\n        extra_args, ['concept_notes', 'note_format'])\n\n    concepts = resolve_from_dictionary(\n        extra_args, ['concept_notes', 'general_concepts'])\n\n    if population_exist:\n        concepts += resolve_from_dictionary(\n            extra_args, ['concept_notes', 'population_concepts'])\n\n    notes = []\n    for concept in concepts:\n        note = note_format.format(**concept)\n        notes.append(note)\n\n    context['component_key'] = component_metadata.key\n    context['header'] = header\n    context['summary'] = summary\n    context['table_header'] = table_header\n    context['notes'] = notes\n\n    return context", "response": "Extracting general analysis result from the multi - exposure impact layer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef analysis_question_extractor(impact_report, component_metadata):\n    multi_exposure = impact_report.multi_exposure_impact_function\n    if multi_exposure:\n        return multi_exposure_analysis_question_extractor(\n            impact_report, component_metadata)\n\n    context = {}\n    extra_args = component_metadata.extra_args\n    provenance = impact_report.impact_function.provenance\n\n    header = resolve_from_dictionary(extra_args, 'header')\n    analysis_question = provenance['analysis_question']\n\n    context['component_key'] = component_metadata.key\n    context['header'] = header\n    context['analysis_questions'] = [analysis_question]\n\n    return context", "response": "Extracting analysis question from the impact layer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef multi_exposure_analysis_question_extractor(\n        impact_report, component_metadata):\n    \"\"\"Extracting analysis question from the impact layer.\n\n    :param impact_report: the impact report that acts as a proxy to fetch\n        all the data that extractor needed\n    :type impact_report: safe.report.impact_report.ImpactReport\n\n    :param component_metadata: the component metadata. Used to obtain\n        information about the component we want to render\n    :type component_metadata: safe.report.report_metadata.\n        ReportComponentsMetadata\n\n    :return: context for rendering phase\n    :rtype: dict\n\n    .. versionadded:: 4.3\n    \"\"\"\n    context = {}\n    extra_args = component_metadata.extra_args\n\n    multi_exposure = impact_report.multi_exposure_impact_function\n    provenance = multi_exposure.provenance\n\n    header = resolve_from_dictionary(extra_args, 'header')\n    analysis_questions = []\n\n    analysis_question = provenance['analysis_question']\n    analysis_questions.append(analysis_question)\n\n    context['component_key'] = component_metadata.key\n    context['header'] = header\n    context['analysis_questions'] = analysis_questions\n\n    return context", "response": "Extracting analysis question from the impact layer."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reset_defaults(self):\n        self.save_login.setChecked(False)\n        self.save_password.setChecked(False)\n        self.save_url.setChecked(False)\n\n        set_setting(GEONODE_USER, '')\n        set_setting(GEONODE_PASSWORD, '')\n        set_setting(GEONODE_URL, '')\n\n        self.login.setText('')\n        self.password.setText('')\n        self.url.setText('')", "response": "Reset login and password in QgsSettings."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef accept(self):\n        enable_busy_cursor()\n        self.button_box.setEnabled(False)\n        layer = layer_from_combo(self.layers)\n\n        login = self.login.text()\n        if self.save_login.isChecked():\n            set_setting(GEONODE_USER, login)\n        else:\n            set_setting(GEONODE_USER, '')\n\n        password = self.password.text()\n        if self.save_password.isChecked():\n            set_setting(GEONODE_PASSWORD, password)\n        else:\n            set_setting(GEONODE_PASSWORD, '')\n\n        url = self.url.text()\n        if self.save_url.isChecked():\n            set_setting(GEONODE_URL, url)\n        else:\n            set_setting(GEONODE_URL, '')\n\n        geonode_session = login_user(url, login, password)\n\n        try:\n            result = upload(url, geonode_session, layer.source())\n        except GeoNodeLayerUploadError as e:\n            result = {\n                'success': False,\n                'message': str(e)\n            }\n        finally:\n            self.button_box.setEnabled(True)\n            disable_busy_cursor()\n\n        if result['success']:\n            self.done(QDialog.Accepted)\n            layer_url = urljoin(url, result['url'])\n            # Link is not working in QGIS 2.\n            # It's gonna work in QGIS 3.\n            if qgis_version() >= 29900:\n                external_link = '<a href=\\\"{url}\\\">{url}</a>'.format(\n                    url=layer_url)\n            else:\n                external_link = layer_url\n\n            display_success_message_bar(\n                tr('Uploading done'),\n                tr('Successfully uploaded to {external_link}').format(\n                    external_link=external_link),\n            )\n        else:\n            display_warning_message_box(\n                self,\n                tr('Error while uploading the layer.'),\n                str(result)\n            )", "response": "Upload the layer to Geonode."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_value_map(layer, exposure_key=None):\n    output_layer_name = assign_inasafe_values_steps['output_layer_name']\n    output_layer_name = output_layer_name % layer.keywords['layer_purpose']\n\n    keywords = layer.keywords\n    inasafe_fields = keywords['inasafe_fields']\n\n    classification = None\n    if keywords['layer_purpose'] == layer_purpose_hazard['key']:\n        if not inasafe_fields.get(hazard_value_field['key']):\n            raise InvalidKeywordsForProcessingAlgorithm\n        old_field = hazard_value_field\n        new_field = hazard_class_field\n        classification = active_classification(layer.keywords, exposure_key)\n\n    elif keywords['layer_purpose'] == layer_purpose_exposure['key']:\n        if not inasafe_fields.get(exposure_type_field['key']):\n            raise InvalidKeywordsForProcessingAlgorithm\n        old_field = exposure_type_field\n        new_field = exposure_class_field\n    else:\n        raise InvalidKeywordsForProcessingAlgorithm\n\n    # It's a hazard layer\n    if exposure_key:\n        if not active_thresholds_value_maps(keywords, exposure_key):\n            raise InvalidKeywordsForProcessingAlgorithm\n        value_map = active_thresholds_value_maps(keywords, exposure_key)\n    # It's exposure layer\n    else:\n        if not keywords.get('value_map'):\n            raise InvalidKeywordsForProcessingAlgorithm\n        value_map = keywords.get('value_map')\n\n    unclassified_column = inasafe_fields[old_field['key']]\n    unclassified_index = layer.fields().lookupField(unclassified_column)\n\n    reversed_value_map = {}\n    for inasafe_class, values in list(value_map.items()):\n        for val in values:\n            reversed_value_map[val] = inasafe_class\n\n    classified_field = QgsField()\n    classified_field.setType(new_field['type'])\n    classified_field.setName(new_field['field_name'])\n    classified_field.setLength(new_field['length'])\n    classified_field.setPrecision(new_field['precision'])\n\n    layer.startEditing()\n    layer.addAttribute(classified_field)\n\n    classified_field_index = layer.fields(). \\\n        lookupField(classified_field.name())\n\n    for feature in layer.getFeatures():\n        attributes = feature.attributes()\n        source_value = attributes[unclassified_index]\n        classified_value = reversed_value_map.get(source_value)\n\n        if not classified_value:\n            classified_value = ''\n\n        layer.changeAttributeValue(\n            feature.id(), classified_field_index, classified_value)\n\n    layer.commitChanges()\n\n    remove_fields(layer, [unclassified_column])\n\n    # We transfer keywords to the output.\n    # We add new class field\n    inasafe_fields[new_field['key']] = new_field['field_name']\n\n    # and we remove hazard value field\n    inasafe_fields.pop(old_field['key'])\n\n    layer.keywords = keywords\n    layer.keywords['inasafe_fields'] = inasafe_fields\n    if exposure_key:\n        value_map_key = 'value_maps'\n    else:\n        value_map_key = 'value_map'\n    if value_map_key in list(layer.keywords.keys()):\n        layer.keywords.pop(value_map_key)\n    layer.keywords['title'] = output_layer_name\n    if classification:\n        layer.keywords['classification'] = classification\n\n    check_layer(layer)\n    return layer", "response": "Assign inasafe values according to definitions for a vector layer."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the minimum needs information about the minimum needs. That is the resource and the amount.", "response": "def get_minimum_needs(self):\n        \"\"\"Get the minimum needed information about the minimum needs.\n\n        That is the resource and the amount.\n\n        :returns: minimum needs\n        :rtype: OrderedDict\n        \"\"\"\n        minimum_needs = OrderedDict()\n        for resource in self.minimum_needs['resources']:\n            if resource['Unit abbreviation']:\n                name = '%s [%s]' % (\n                    tr(resource['Resource name']),\n                    resource['Unit abbreviation']\n                )\n            else:\n                name = tr(resource['Resource name'])\n            amount = resource['Default']\n            minimum_needs[name] = amount\n        return OrderedDict(minimum_needs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_need(self, resource, amount, units, frequency='weekly'):\n        self.minimum_needs['resources'].append({\n            'Resource name': resource,\n            'Default': amount,\n            'Unit abbreviation': units,\n            'Frequency': frequency\n        })", "response": "Append a new entry to the list of minimum needs."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _defaults(cls):\n        minimum_needs = {\n            \"resources\": [\n                {\n                    \"Default\": \"2.8\",\n                    \"Minimum allowed\": \"0\",\n                    \"Maximum allowed\": \"100\",\n                    \"Frequency\": \"weekly\",\n                    \"Resource name\": cls.Rice,\n                    \"Resource description\": \"Basic food\",\n                    \"Unit\": \"kilogram\",\n                    \"Units\": \"kilograms\",\n                    \"Unit abbreviation\": \"kg\",\n                    \"Readable sentence\": (\n                        \"Each person should be provided with {{ Default }} \"\n                        \"{{ Units }} of {{ Resource name }} {{ Frequency }}.\")\n                },\n                {\n                    \"Default\": \"17.5\",\n                    \"Minimum allowed\": \"0\",\n                    \"Maximum allowed\": \"100\",\n                    \"Frequency\": \"weekly\",\n                    \"Resource name\": cls.Drinking_water,\n                    \"Resource description\": \"For drinking\",\n                    \"Unit\": \"litre\",\n                    \"Units\": \"litres\",\n                    \"Unit abbreviation\": \"l\",\n                    \"Readable sentence\": (\n                        \"Each person should be provided with {{ Default }} \"\n                        \"{{ Units }} of {{ Resource name }} {{ Frequency }} \"\n                        \"for drinking.\")\n                },\n                {\n                    \"Default\": \"67\",\n                    \"Minimum allowed\": \"10\",\n                    \"Maximum allowed\": \"100\",\n                    \"Frequency\": \"weekly\",\n                    \"Resource name\": cls.Water,\n                    \"Resource description\": \"For washing\",\n                    \"Unit\": \"litre\",\n                    \"Units\": \"litres\",\n                    \"Unit abbreviation\": \"l\",\n                    \"Readable sentence\": (\n                        \"Each person should be provided with {{ Default }} \"\n                        \"{{ Units }} of {{ Resource name }} {{ Frequency }} \"\n                        \"for washing.\")\n                },\n                {\n                    \"Default\": \"0.2\",\n                    \"Minimum allowed\": \"0.1\",\n                    \"Maximum allowed\": \"1\",\n                    \"Frequency\": \"weekly\",\n                    \"Resource name\": cls.Family_kits,\n                    \"Resource description\": \"Hygiene kits\",\n                    \"Unit\": \"\",\n                    \"Units\": \"\",\n                    \"Unit abbreviation\": \"\",\n                    \"Readable sentence\": (\n                        \"Each family of 5 persons should be provided with 1 \"\n                        \"Family Kit per week.\")\n                },\n                {\n                    \"Default\": \"0.05\",\n                    \"Minimum allowed\": \"0.02\",\n                    \"Maximum allowed\": \"1\",\n                    \"Frequency\": \"single\",\n                    \"Resource name\": cls.Toilets,\n                    \"Resource description\": \"\",\n                    \"Unit\": \"\",\n                    \"Units\": \"\",\n                    \"Unit abbreviation\": \"\",\n                    \"Readable sentence\": (\n                        \"A Toilet should be provided for every 20 persons.\")\n                }\n            ],\n            \"provenance\": \"The minimum needs are based on Perka 7/2008.\",\n            \"profile\": \"BNPB_en\"\n        }\n        return minimum_needs", "response": "Helper to get the default minimum needs."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads the minimum needs from a json file.", "response": "def read_from_file(self, filename):\n        \"\"\"Read from an existing json file.\n\n        :param filename: The file to be written to.\n        :type filename: basestring, str\n\n        :returns: Success status. -1 for unsuccessful 0 for success\n        :rtype: int\n        \"\"\"\n        if not exists(filename):\n            return -1\n        with open(filename) as fd:\n            needs_json = fd.read()\n            try:\n                minimum_needs = json.loads(needs_json)\n            except (TypeError, ValueError):\n                minimum_needs = None\n\n        if not minimum_needs:\n            return -1\n\n        return self.update_minimum_needs(minimum_needs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting the minimum needs as json to a file.", "response": "def write_to_file(self, filename):\n        \"\"\"Write minimum needs as json to a file.\n\n        :param filename: The file to be written to.\n        :type filename: basestring, str\n        \"\"\"\n        if not exists(dirname(filename)):\n            return -1\n        with open(filename, 'w') as fd:\n            needs_json = json.dumps(self.minimum_needs)\n            fd.write(needs_json)\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef osm_downloader_help():\n\n    message = m.Message()\n    message.add(m.Brand())\n    message.add(heading())\n    message.add(content())\n    return message", "response": "Help message for OSM Downloader dialog."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of dicts for the current object", "response": "def dict(self):\n        \"\"\"\n        the python object for rendering json.\n\n        It is called dict to be\n        coherent with the other modules but it actually returns a list\n\n        :return: the python object for rendering json\n        :rtype: list\n        \"\"\"\n\n        json_list = []\n        for step in self.steps:\n            json_list.append(step.dict)\n        return json_list"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef append_step(self, title, description, timestamp=None, data=None):\n        step = ProvenanceStep(title, description, timestamp, data)\n        self._steps.append(step)\n        return step.time", "response": "Append a new provenance step."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef append_if_provenance_step(\n            self, title, description, timestamp=None, data=None):\n        \"\"\"Append a new IF provenance step.\n\n        :param title: the title of the IF ProvenanceStep\n        :type title: str\n\n        :param description: the description of the IF ProvenanceStep\n        :type description: str\n\n        :param timestamp: the time of the IF ProvenanceStep\n        :type timestamp: datetime, None\n\n        :param data: The data of the IF ProvenanceStep\n        :type data: dict\n\n        :returns: the time of the IF ProvenanceStep\n        :rtype: datetime\n        \"\"\"\n        step = IFProvenanceStep(title, description, timestamp, data)\n        self._steps.append(step)\n        return step.time", "response": "Append a new IF provenance step."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef assign_highest_value(exposure, hazard):\n    output_layer_name = assign_highest_value_steps['output_layer_name']\n\n    hazard_inasafe_fields = hazard.keywords['inasafe_fields']\n\n    if not hazard.keywords.get('classification'):\n        raise InvalidKeywordsForProcessingAlgorithm\n    if not hazard_inasafe_fields.get(hazard_class_field['key']):\n        raise InvalidKeywordsForProcessingAlgorithm\n\n    indices = []\n    exposure.startEditing()\n    for field in hazard.fields():\n        exposure.addAttribute(field)\n        indices.append(exposure.fields().lookupField(field.name()))\n    exposure.commitChanges()\n    provider = exposure.dataProvider()\n\n    spatial_index = create_spatial_index(exposure)\n\n    # cache features from exposure layer for faster retrieval\n    exposure_features = {}\n    for f in exposure.getFeatures():\n        exposure_features[f.id()] = f\n\n    # Todo callback\n    # total = 100.0 / len(selectionA)\n\n    hazard_field = hazard_inasafe_fields[hazard_class_field['key']]\n\n    layer_classification = None\n    for classification in hazard_classification['types']:\n        if classification['key'] == hazard.keywords['classification']:\n            layer_classification = classification\n            break\n\n    # Get a ordered list of classes like ['high', 'medium', 'low']\n    levels = [key['key'] for key in layer_classification['classes']]\n    levels.append(not_exposed_class['key'])\n\n    # Let's loop over the hazard layer, from high to low hazard zone.\n    for hazard_value in levels:\n        expression = '\"%s\" = \\'%s\\'' % (hazard_field, hazard_value)\n        hazard_request = QgsFeatureRequest().setFilterExpression(expression)\n        update_map = {}\n        for area in hazard.getFeatures(hazard_request):\n            geometry = area.geometry().constGet()\n            intersects = spatial_index.intersects(geometry.boundingBox())\n\n            # use prepared geometry: makes multiple intersection tests faster\n            geometry_prepared = QgsGeometry.createGeometryEngine(\n                geometry)\n            geometry_prepared.prepareGeometry()\n\n            # We need to loop over each intersections exposure / hazard.\n            for i in intersects:\n                building = exposure_features[i]\n                building_geometry = building.geometry()\n\n                if geometry_prepared.intersects(building_geometry.constGet()):\n                    update_map[building.id()] = {}\n                    for index, value in zip(indices, area.attributes()):\n                        update_map[building.id()][index] = value\n\n                    # We don't want this building again, let's remove it from\n                    # the index.\n                    spatial_index.deleteFeature(building)\n\n        provider.changeAttributeValues(update_map)\n\n    exposure.updateExtents()\n    exposure.updateFields()\n\n    exposure.keywords['inasafe_fields'].update(\n        hazard.keywords['inasafe_fields'])\n    exposure.keywords['layer_purpose'] = layer_purpose_exposure_summary['key']\n\n    exposure.keywords['exposure_keywords'] = exposure.keywords.copy()\n    exposure.keywords['aggregation_keywords'] = (\n        hazard.keywords['aggregation_keywords'].copy())\n    exposure.keywords['hazard_keywords'] = (\n        hazard.keywords['hazard_keywords'].copy())\n\n    exposure.keywords['title'] = output_layer_name\n\n    check_layer(exposure)\n    return exposure", "response": "Assign the highest hazard value to an exposure layer."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nobtaining InaSAFE s version from version file.", "response": "def get_version():\n    \"\"\"Obtain InaSAFE's version from version file.\n\n    :returns: The current version number.\n    :rtype: str\n\n    \"\"\"\n    # Get location of application wide version info\n    root_dir = os.path.abspath(os.path.join(os.path.dirname(__file__)))\n    version_file = os.path.join(root_dir, 'safe', 'definitions', 'versions.py')\n    fid = open(version_file)\n    version = ''\n    for line in fid.readlines():\n        if line.startswith('inasafe_version'):\n            version = line.strip().split(' = ')[1]\n            version = version.replace('\\'', '')\n            break\n    fid.close()\n    if version:\n        return version\n    else:\n        raise Exception('Version is not found in %s' % version_file)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_next_step(self):\n        if self.parent.parent_step:\n            # Come back from KW to the parent IFCW thread.\n            parent_step = self.parent.parent_step\n            if self.parent.is_layer_compatible(self.parent.layer):\n                # If the layer is compatible,\n                # go to the next step (issue #2347)\n                if parent_step in [self.parent.step_fc_hazlayer_from_canvas,\n                                   self.parent.step_fc_hazlayer_from_browser]:\n                    new_step = self.parent.step_fc_explayer_origin\n\n                elif parent_step in [self.parent.step_fc_explayer_from_canvas,\n                                     self.parent.\n                                     step_fc_explayer_from_browser]:\n                    if layers_intersect(\n                            self.parent.hazard_layer,\n                            self.parent.exposure_layer):\n                        new_step = self.parent.step_fc_agglayer_origin\n                    else:\n                        new_step = self.parent.step_fc_disjoint_layers\n\n                elif parent_step in [self.parent.step_fc_agglayer_from_canvas,\n                                     self.parent.\n                                     step_fc_agglayer_from_browser]:\n                    if layers_intersect(self.parent.exposure_layer,\n                                        self.parent.aggregation_layer):\n                        new_step = self.parent.step_fc_summary\n                    else:\n                        new_step = self.parent.step_fc_agglayer_disjoint\n                else:\n                    raise Exception('No such step')\n            else:\n                # If the layer is incompatible, stay on the parent step.\n                # However, if the step is xxxLayerFromCanvas and there are\n                # no compatible layers, the list will be empty,\n                # so go one step back.\n                haz = layer_purpose_hazard['key']\n                exp = layer_purpose_exposure['key']\n                agg = layer_purpose_aggregation['key']\n                if (parent_step == self.parent.step_fc_hazlayer_from_canvas\n                        and not self.parent.get_compatible_canvas_layers(haz)):\n                    new_step = self.parent.step_fc_hazlayer_origin\n                elif (parent_step\n                      == self.parent.step_fc_explayer_from_canvas\n                      and not self.parent.get_compatible_canvas_layers(exp)):\n                    new_step = self.parent.step_fc_explayer_origin\n                elif (parent_step\n                      == self.parent.step_fc_agglayer_from_canvas\n                      and not self.parent.get_compatible_canvas_layers(agg)):\n                    new_step = self.parent.step_fc_agglayer_origin\n                else:\n                    new_step = parent_step\n            self.parent.parent_step = None\n            self.parent.is_selected_layer_keywordless = False\n            self.parent.set_mode_label_to_ifcw()\n        else:\n            # Wizard complete\n            new_step = None\n        # Reset the step history\n        self.parent.keyword_steps = []\n        return new_step", "response": "Find the next step when user clicks the Next button."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets widgets on the Keywords Summary tab.", "response": "def set_widgets(self):\n        \"\"\"Set widgets on the Keywords Summary tab.\"\"\"\n\n        current_keywords = self.parent.get_keywords()\n        current_keywords[inasafe_keyword_version_key] = inasafe_keyword_version\n\n        header_path = resources_path('header.html')\n        footer_path = resources_path('footer.html')\n        header_file = open(header_path)\n        footer_file = open(footer_path)\n        header = header_file.read()\n        footer = footer_file.read()\n        header_file.close()\n        footer_file.close()\n        header = header.replace('PATH', resources_path())\n\n        # TODO: Clone the dict inside keyword_io.to_message rather then here.\n        #       It pops the dict elements damaging the function parameter\n        body = self.parent.keyword_io.to_message(dict(current_keywords)).\\\n            to_html()\n        # remove the branding div\n        body = re.sub(\n            r'^.*div class=\"branding\".*$', '', body, flags=re.MULTILINE)\n\n        if self.parent.parent_step:\n            # It's the KW mode embedded in IFCW mode,\n            # so check if the layer is compatible\n            if not self.parent.is_layer_compatible(\n                    self.parent.layer, None, current_keywords):\n                msg = self.tr(\n                    'The selected keywords don\\'t match requirements of the '\n                    'selected combination for the impact function. You can '\n                    'continue with registering the layer, however, you\\'ll '\n                    'need to choose another layer for that function.')\n                body = '<br/><h5 class=\"problem\">%s</h5> %s' % (msg, body)\n\n        html = header + body + footer\n        self.wvKwSummary.setHtml(html)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef raise_invalid_type_exception(self):\n        message = 'Expecting element type of %s' % (\n            self._parameter.element_type.__name__)\n        err = ValueError(message)\n        return err", "response": "Raise an exception if the type of the current element is not valid."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nobtain the list parameter object from the current state of widget", "response": "def get_parameter(self):\n        \"\"\"Obtain list parameter object from the current widget state.\n\n        :returns: A DefaultValueParameter from the current state of widget\n        :rtype: DefaultValueParameter\n        \"\"\"\n        radio_button_checked_id = self.input_button_group.checkedId()\n        # No radio button checked, then default value = None\n        if radio_button_checked_id == -1:\n            self._parameter.value = None\n        # The last radio button (custom) is checked, get the value from the\n        # line edit\n        elif radio_button_checked_id == len(self._parameter.options) - 1:\n            self._parameter.options[radio_button_checked_id] = \\\n                self.custom_value.value()\n            self._parameter.value = self.custom_value.value()\n        else:\n            self._parameter.value = self._parameter.options[\n                radio_button_checked_id]\n\n        return self._parameter"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset value by item s string.", "response": "def set_value(self, value):\n        \"\"\"Set value by item's string.\n\n        :param value: The value.\n        :type value: str, int\n\n        :returns: True if success, else False.\n        :rtype: bool\n        \"\"\"\n        # Find index of choice\n        try:\n            value_index = self._parameter.options.index(value)\n            self.input_button_group.button(value_index).setChecked(True)\n        except ValueError:\n            last_index = len(self._parameter.options) - 1\n            self.input_button_group.button(last_index).setChecked(\n                True)\n            self.custom_value.setValue(value)\n\n        self.toggle_custom_value()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef toggle_custom_value(self):\n        radio_button_checked_id = self.input_button_group.checkedId()\n        if (radio_button_checked_id\n                == len(self._parameter.options) - 1):\n            self.custom_value.setDisabled(False)\n        else:\n            self.custom_value.setDisabled(True)", "response": "Enable or disable the custom value line edit."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef memory_used(self):\n        if self._end_memory:\n            memory_used = self._end_memory - self._start_memory\n            return memory_used\n        else:\n            return None", "response": "To know the allocated memory at function termination."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef append(self, node):\n        if node.parent == self.key and not self.elapsed_time:\n            self.children.append(node)\n        else:\n            # Recursive call\n            for child in self.children:\n                if not child.elapsed_time:\n                    child.append(node)", "response": "To append a new child."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_analysis_question(hazard, exposure):\n    # First we look for a translated hardcoded question.\n    question = specific_analysis_question(hazard, exposure)\n    if question:\n        return question\n\n    if hazard == hazard_generic:\n        # Secondly, if the hazard is generic, we don't need the hazard.\n        question = tr(\n            'In each of the hazard zones {exposure_measure} {exposure_name} '\n            'might be affected?').format(\n            exposure_measure=exposure['measure_question'],\n            exposure_name=exposure['name'])\n        return question\n\n    # Then, we fallback on a generated string on the fly.\n    question = tr(\n        'In the event of a {hazard_name}, {exposure_measure} {exposure_name} '\n        'might be affected?').format(\n            hazard_name=hazard['name'],\n            exposure_measure=exposure['measure_question'],\n            exposure_name=exposure['name'])\n    return question", "response": "Construct an analysis question based on hazard and exposure."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_multi_exposure_analysis_question(hazard, exposures):\n    exposures_question = ''\n    exposure_format = '{exposure_measure} {exposure_name}'\n    for index, exposure in enumerate(exposures):\n        if index + 1 == len(exposures):\n            if len(exposures) > 2:\n                exposures_question += tr(', and ')\n            else:\n                exposures_question += tr(' and ')\n        elif index != 0:\n            exposures_question += ', '\n        exposures_question += exposure_format.format(\n            exposure_measure=exposure['measure_question'],\n            exposure_name=exposure['name'])\n\n    if hazard == hazard_generic:\n        question = tr(\n            'In each of the hazard zones, {exposures_question} '\n            'might be affected?').format(exposures_question=exposures_question)\n    else:\n        question = tr(\n            'In the event of a {hazard_name}, {exposures_question} '\n            'might be affected?').format(\n            hazard_name=hazard['name'], exposures_question=exposures_question)\n\n    return question", "response": "Construct an analysis question based on hazard and exposures."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_next_step(self):\n        if self.parent.get_layer_geometry_key() == \\\n                layer_geometry_raster['key']:\n            return self.parent.step_kw_source\n\n        layer_purpose = self.parent.step_kw_purpose.selected_purpose()\n        if layer_purpose['key'] != layer_purpose_aggregation['key']:\n            subcategory = self.parent.step_kw_subcategory. \\\n                selected_subcategory()\n        else:\n            subcategory = {'key': None}\n\n        # Check if it can go to inasafe field step\n        non_compulsory_fields = get_non_compulsory_fields(\n            layer_purpose['key'], subcategory['key'])\n        if not skip_inasafe_field(self.parent.layer, non_compulsory_fields):\n            return self.parent.step_kw_inasafe_fields\n\n        # Check if it can go to inasafe default field step\n        default_inasafe_fields = get_fields(\n            layer_purpose['key'],\n            subcategory['key'],\n            replace_null=True,\n            in_group=False\n        )\n        if default_inasafe_fields:\n            return self.parent.step_kw_default_inasafe_fields\n\n        # Any other case\n        return self.parent.step_kw_source", "response": "Find the proper step when user clicks the Next button."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_widgets(self):\n        clear_layout(self.gridLayoutThreshold)\n\n        # Set text in the label\n        layer_purpose = self.parent.step_kw_purpose.selected_purpose()\n        layer_subcategory = self.parent.step_kw_subcategory.\\\n            selected_subcategory()\n        classification = self.parent.step_kw_classification. \\\n            selected_classification()\n\n        if is_raster_layer(self.parent.layer):\n            statistics = self.parent.layer.dataProvider().bandStatistics(\n                1, QgsRasterBandStats.All, self.parent.layer.extent(), 0)\n            text = continuous_raster_question % (\n                layer_purpose['name'],\n                layer_subcategory['name'],\n                classification['name'],\n                statistics.minimumValue,\n                statistics.maximumValue)\n        else:\n            field_name = self.parent.step_kw_field.selected_fields()\n            field_index = self.parent.layer.fields().lookupField(field_name)\n            min_value_layer = self.parent.layer.minimumValue(field_index)\n            max_value_layer = self.parent.layer.maximumValue(field_index)\n            text = continuous_vector_question % (\n                layer_purpose['name'],\n                layer_subcategory['name'],\n                field_name,\n                classification['name'],\n                min_value_layer,\n                max_value_layer)\n        self.lblThreshold.setText(text)\n\n        thresholds = self.parent.get_existing_keyword('thresholds')\n        selected_unit = self.parent.step_kw_unit.selected_unit()['key']\n\n        self.classes = OrderedDict()\n        classes = classification.get('classes')\n        # Sort by value, put the lowest first\n        classes = sorted(classes, key=lambda k: k['value'])\n\n        for i, the_class in enumerate(classes):\n            class_layout = QHBoxLayout()\n\n            # Class label\n            class_label = QLabel(the_class['name'])\n\n            # Min label\n            min_label = QLabel(tr('Min >'))\n\n            # Min value as double spin\n            min_value_input = QDoubleSpinBox()\n            # TODO(IS) We can set the min and max depends on the unit, later\n            min_value_input.setMinimum(0)\n            min_value_input.setMaximum(999999)\n            if thresholds.get(the_class['key']):\n                min_value_input.setValue(thresholds[the_class['key']][0])\n            else:\n                default_min = the_class['numeric_default_min']\n                if isinstance(default_min, dict):\n                    default_min = the_class[\n                        'numeric_default_min'][selected_unit]\n                min_value_input.setValue(default_min)\n            min_value_input.setSingleStep(0.1)\n\n            # Max label\n            max_label = QLabel(tr('Max <='))\n\n            # Max value as double spin\n            max_value_input = QDoubleSpinBox()\n            # TODO(IS) We can set the min and max depends on the unit, later\n            max_value_input.setMinimum(0)\n            max_value_input.setMaximum(999999)\n            if thresholds.get(the_class['key']):\n                max_value_input.setValue(thresholds[the_class['key']][1])\n            else:\n                default_max = the_class['numeric_default_max']\n                if isinstance(default_max, dict):\n                    default_max = the_class[\n                        'numeric_default_max'][selected_unit]\n                max_value_input.setValue(default_max)\n            max_value_input.setSingleStep(0.1)\n\n            # Add to class_layout\n            class_layout.addWidget(min_label)\n            class_layout.addWidget(min_value_input)\n            # class_layout.addStretch(1)\n            class_layout.addWidget(max_label)\n            class_layout.addWidget(max_value_input)\n\n            # Add to grid_layout\n            self.gridLayoutThreshold.addWidget(class_label, i, 0)\n            self.gridLayoutThreshold.addLayout(class_layout, i, 1)\n\n            self.classes[the_class['key']] = [min_value_input, max_value_input]\n\n        self.gridLayoutThreshold.setSpacing(0)\n\n        def min_max_changed(index, the_string):\n            \"\"\"Slot when min or max value change.\n\n            :param index: The index of the double spin.\n            :type index: int\n\n            :param the_string: The flag to indicate the min or max value.\n            :type the_string: str\n            \"\"\"\n            if the_string == 'Max value':\n                current_max_value = list(self.classes.values())[index][1]\n                target_min_value = list(self.classes.values())[index + 1][0]\n                if current_max_value.value() != target_min_value.value():\n                    target_min_value.setValue(current_max_value.value())\n            elif the_string == 'Min value':\n                current_min_value = list(self.classes.values())[index][0]\n                target_max_value = list(self.classes.values())[index - 1][1]\n                if current_min_value.value() != target_max_value.value():\n                    target_max_value.setValue(current_min_value.value())\n\n        # Set behaviour\n        for k, v in list(self.classes.items()):\n            index = list(self.classes.keys()).index(k)\n            if index < len(self.classes) - 1:\n                # Max value changed\n                v[1].valueChanged.connect(partial(\n                    min_max_changed, index=index, the_string='Max value'))\n            if index > 0:\n                # Min value\n                v[0].valueChanged.connect(partial(\n                    min_max_changed, index=index, the_string='Min value'))", "response": "Set widgets on the Threshold tab."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a MessageElement to the end of the queue.", "response": "def add(self, message):\n        \"\"\"Add a MessageElement to the end of the queue.\n\n        Strings can be passed and are automatically converted in to\n        item.Text()\n\n        :param message: An element to add to the message queue.\n        :type message: safe.messaging.Message, MessageElement, str\n\n        \"\"\"\n        if self._is_stringable(message) or self._is_qstring(message):\n            self.message.append(Text(message))\n        elif isinstance(message, MessageElement):\n            self.message.append(message)\n        elif isinstance(message, Message):\n            self.message.extend(message.message)\n        else:\n            raise InvalidMessageItemError(message, message.__class__)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_text(self):\n        message = ''\n        last_was_text = False\n        for m in self.message:\n            if last_was_text and not isinstance(m, Text):\n                message += '\\n'\n\n            message += m.to_text()\n\n            if isinstance(m, Text):\n                last_was_text = True\n            else:\n                message += '\\n'\n                last_was_text = False\n        return message", "response": "Render a MessageElement queue as plain text."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_html(\n            self,\n            suppress_newlines=False,\n            in_div_flag=False):  # pylint: disable=W0221\n        \"\"\"Render a MessageElement as html.\n\n        :param suppress_newlines: Whether to suppress any newlines in the\n            output. If this option is enabled, the entire html output will be\n            rendered on a single line.\n        :type suppress_newlines: bool\n\n        :param in_div_flag: Whether the message should be placed into an outer\n            div element.\n        :type in_div_flag: bool\n\n        :returns: HTML representation of the message.\n        :rtype: str\n        \"\"\"\n\n        if in_div_flag or self.in_div_flag:\n            message = '<div %s>' % self.html_attributes()\n        else:\n            message = ''\n\n        last_was_text = False\n        for m in self.message:\n            if last_was_text and not isinstance(m, Text):\n                message += '\\n'\n\n            message += m.to_html()\n\n            if isinstance(m, Text):\n                last_was_text = True\n            else:\n                message += '\\n'\n                last_was_text = False\n\n        if in_div_flag:\n            message += '</div>'\n\n        if suppress_newlines:\n            return message.replace('\\n', '')\n        return message", "response": "Render a MessageElement as html."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef validate_sum(parameter_container, validation_message, **kwargs):\n    parameters = parameter_container.get_parameters(False)\n    values = []\n    for parameter in parameters:\n        if parameter.selected_option_type() in [SINGLE_DYNAMIC, STATIC]:\n            values.append(parameter.value)\n\n    sum_threshold = kwargs.get('max', 1)\n\n    if None in values:\n        # If there is None, just check to not exceeding validation_threshold\n        clean_value = [x for x in values if x is not None]\n        values.remove(None)\n        if sum(clean_value) > sum_threshold:\n            return {\n                'valid': False,\n                'message': validation_message\n            }\n    else:\n        # Just make sure to not have more than validation_threshold.\n        if sum(values) > sum_threshold:\n            return {\n                'valid': False,\n                'message': validation_message\n            }\n    return {\n        'valid': True,\n        'message': ''\n    }", "response": "Validate the sum of the parameter value s."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds the proper step when user clicks the Next button.", "response": "def get_next_step(self):\n        \"\"\"Find the proper step when user clicks the Next button.\n\n        :returns: The step to be switched to\n        :rtype: WizardStep instance or None\n        \"\"\"\n        is_raster = is_raster_layer(self.parent.layer)\n        subcategory = self.parent.step_kw_subcategory.selected_subcategory()\n        has_unit = subcategory.get('units') or subcategory.get(\n            'continuous_hazard_units')\n        selected_layer_mode = self.selected_layermode()\n\n        # continuous\n        if selected_layer_mode == layer_mode_continuous and has_unit:\n            new_step = self.parent.step_kw_unit\n        # no unit and vector\n        elif not is_raster:\n            new_step = self.parent.step_kw_field\n        # no unit and raster\n        elif is_raster:\n            new_step = self.parent.step_kw_multi_classifications\n        else:\n            raise InvalidWizardStep\n\n        return new_step"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef on_lstLayerModes_itemSelectionChanged(self):\n        self.clear_further_steps()\n        # Set widgets\n        layer_mode = self.selected_layermode()\n        # Exit if no selection\n        if not layer_mode:\n            self.lblDescribeLayerMode.setText('')\n            return\n        # Set description label\n        self.lblDescribeLayerMode.setText(layer_mode['description'])\n        # Enable the next button\n        self.parent.pbnNext.setEnabled(True)", "response": "Update description label and unit widgets."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef selected_layermode(self):\n        item = self.lstLayerModes.currentItem()\n        try:\n            return definition(item.data(QtCore.Qt.UserRole))\n        except (AttributeError, NameError):\n            return None", "response": "Obtain the layer mode selected by user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset widgets on the LayerMode tab.", "response": "def set_widgets(self):\n        \"\"\"Set widgets on the LayerMode tab.\"\"\"\n        self.clear_further_steps()\n        # Set widgets\n        purpose = self.parent.step_kw_purpose.selected_purpose()\n        subcategory = self.parent.step_kw_subcategory.selected_subcategory()\n        layer_mode_question = (\n            layer_mode_raster_question\n            if is_raster_layer(self.parent.layer)\n            else layer_mode_vector_question)\n\n        self.lblDescribeLayerMode.setText('')\n        self.lstLayerModes.clear()\n        layer_modes = get_layer_modes(subcategory['key'])\n        if is_raster_layer(self.parent.layer):\n            layer_mode_question = layer_mode_raster_question\n        else:\n            if len(layer_modes) == 2:\n                layer_mode_question = layer_mode_vector_question\n            elif len(layer_modes) == 1:\n                if layer_modes[0]['key'] == 'classified':\n                    layer_mode_question = layer_mode_vector_classified_confirm\n                elif layer_modes[0]['key'] == 'continuous':\n                    layer_mode_question = layer_mode_vector_continuous_confirm\n                else:\n                    layer_mode_question = layer_mode_vector_question\n        self.lblSelectLayerMode.setText(\n            layer_mode_question % (subcategory['name'], purpose['name']))\n        for layer_mode in layer_modes:\n            item = QListWidgetItem(layer_mode['name'], self.lstLayerModes)\n            item.setData(QtCore.Qt.UserRole, layer_mode['key'])\n            self.lstLayerModes.addItem(item)\n\n        # Set value to existing keyword or default value\n        layer_mode_keys = [m['key'] for m in layer_modes]\n        layer_mode_keyword = self.parent.get_existing_keyword('layer_mode')\n        if layer_mode_keyword in layer_mode_keys:\n            index = layer_mode_keys.index(layer_mode_keyword)\n        elif layer_mode_continuous['key'] in layer_mode_keys:\n            # Set default value\n            index = layer_mode_keys.index(layer_mode_continuous['key'])\n        else:\n            index = -1\n        self.lstLayerModes.setCurrentRow(index)\n\n        self.auto_select_one_item(self.lstLayerModes)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_button_status(self):\n        # enable/disable ok button\n        if len(self.displaced.currentField()) > 0:\n            self.button_box.button(\n                QtWidgets.QDialogButtonBox.Ok).setEnabled(True)\n        else:\n            self.button_box.button(\n                QtWidgets.QDialogButtonBox.Ok).setEnabled(False)", "response": "Function to enable or disable the Ok button."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing the minimum needs given a vector layer and a column containing population counts.", "response": "def minimum_needs(self, input_layer):\n        \"\"\"Compute minimum needs given a layer and a column containing pop.\n\n        :param input_layer: Vector layer assumed to contain\n            population counts.\n        :type input_layer: QgsVectorLayer\n\n        :returns: A tuple containing True and the vector layer if\n                  post processor success. Or False and an error message\n                  if something went wrong.\n        :rtype: tuple(bool,QgsVectorLayer or basetring)\n        \"\"\"\n        # Create a new layer for output layer\n        output_layer = self.prepare_new_layer(input_layer)\n\n        # count each minimum needs for every features\n        for needs in minimum_needs_post_processors:\n            is_success, message = run_single_post_processor(\n                output_layer, needs)\n            # check if post processor not running successfully\n            if not is_success:\n                LOGGER.debug(message)\n                display_critical_message_box(\n                    title=self.tr('Error while running post processor'),\n                    message=message)\n\n                return False, None\n\n        return True, output_layer"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef prepare_new_layer(self, input_layer):\n        # create memory layer\n        output_layer_name = os.path.splitext(input_layer.name())[0]\n        output_layer_name = unique_filename(\n            prefix=('%s_minimum_needs_' % output_layer_name),\n            dir='minimum_needs_calculator')\n        output_layer = create_memory_layer(\n            output_layer_name,\n            input_layer.geometryType(),\n            input_layer.crs(),\n            input_layer.fields())\n\n        # monkey patching input layer to make it work with\n        # prepare vector layer function\n        temp_layer = input_layer\n        temp_layer.keywords = {\n            'layer_purpose': layer_purpose_aggregation['key']}\n\n        # copy features to output layer\n        copy_layer(temp_layer, output_layer)\n\n        # Monkey patching output layer to make it work with\n        # minimum needs calculator\n        output_layer.keywords['layer_purpose'] = (\n            layer_purpose_aggregation['key'])\n        output_layer.keywords['inasafe_fields'] = {\n            displaced_field['key']: self.displaced.currentField()\n        }\n        if self.aggregation_name.currentField():\n            output_layer.keywords['inasafe_fields'][\n                aggregation_name_field['key']] = (\n                    self.aggregation_name.currentField())\n\n        # remove unnecessary fields & rename inasafe fields\n        clean_inasafe_fields(output_layer)\n\n        return output_layer", "response": "Prepare new memory layer for the output layer."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprocess the layer and field and generate a new layer.", "response": "def accept(self):\n        \"\"\"Process the layer and field and generate a new layer.\n\n        .. note:: This is called on OK click.\n\n        \"\"\"\n        # run minimum needs calculator\n        try:\n            success, self.result_layer = (\n                self.minimum_needs(self.layer.currentLayer()))\n            if not success:\n                return\n        except Exception as e:\n            error_name, traceback = humanise_exception(e)\n            message = (\n                'Problem(s) occured. \\n%s \\nDiagnosis: \\n%s' % (\n                    error_name, traceback))\n            display_critical_message_box(\n                title=self.tr('Error while calculating minimum needs'),\n                message=message)\n            return\n\n        # remove monkey patching keywords\n        del self.result_layer.keywords\n\n        # write memory layer to file system\n        settings = QSettings()\n        default_user_directory = settings.value(\n            'inasafe/defaultUserDirectory', defaultValue='')\n\n        if default_user_directory:\n            output_directory = os.path.join(\n                default_user_directory, 'minimum_needs_calculator')\n            if not os.path.exists(output_directory):\n                os.makedirs(output_directory)\n        else:\n            output_directory = temp_dir(sub_dir='minimum_needs_calculator')\n\n        output_layer_name = os.path.split(self.result_layer.name())[1]\n\n        # If normal filename doesn't exist, then use normal filename\n        random_string_length = len(output_layer_name.split('_')[-1])\n        normal_filename = output_layer_name[:-(random_string_length + 1)]\n        if not os.path.exists(os.path.join(output_directory, normal_filename)):\n            output_layer_name = normal_filename\n\n        data_store = Folder(output_directory)\n        data_store.default_vector_format = 'geojson'\n        data_store.add_layer(self.result_layer, output_layer_name)\n\n        self.result_layer = data_store.layer(output_layer_name)\n\n        # noinspection PyArgumentList\n        QgsProject.instance().addMapLayers(\n            [data_store.layer(self.result_layer.name())])\n        self.done(QtWidgets.QDialog.Accepted)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexecute analysis after the tab is displayed. Please check the code in dock.py accept(). It should follow approximately the same code.", "response": "def setup_and_run_analysis(self):\n        \"\"\"Execute analysis after the tab is displayed.\n\n        Please check the code in dock.py accept(). It should follow\n        approximately the same code.\n        \"\"\"\n        self.show_busy()\n        # Read user's settings\n        self.read_settings()\n        # Prepare impact function from wizard dialog user input\n        self.impact_function = self.prepare_impact_function()\n\n        # Prepare impact function\n        status, message = self.impact_function.prepare()\n        message = basestring_to_message(message)\n        # Check status\n        if status == PREPARE_FAILED_BAD_INPUT:\n            self.hide_busy()\n            LOGGER.warning(tr(\n                'The impact function will not be able to run because of the '\n                'inputs.'))\n            LOGGER.warning(message.to_text())\n            send_error_message(self, message)\n            return status, message\n        if status == PREPARE_FAILED_BAD_CODE:\n            self.hide_busy()\n            LOGGER.warning(tr(\n                'The impact function was not able to be prepared because of a '\n                'bug.'))\n            LOGGER.exception(message.to_text())\n            send_error_message(self, message)\n            return status, message\n\n        # Start the analysis\n        status, message = self.impact_function.run()\n        message = basestring_to_message(message)\n        # Check status\n        if status == ANALYSIS_FAILED_BAD_INPUT:\n            self.hide_busy()\n            LOGGER.warning(tr(\n                'The impact function could not run because of the inputs.'))\n            LOGGER.warning(message.to_text())\n            send_error_message(self, message)\n            return status, message\n        elif status == ANALYSIS_FAILED_BAD_CODE:\n            self.hide_busy()\n            LOGGER.warning(tr(\n                'The impact function could not run because of a bug.'))\n            LOGGER.exception(message.to_text())\n            send_error_message(self, message)\n            return status, message\n\n        LOGGER.info(tr('The impact function could run without errors.'))\n\n        # Add result layer to QGIS\n        add_impact_layers_to_canvas(\n            self.impact_function, iface=self.parent.iface)\n\n        # Some if-s i.e. zoom, debug, hide exposure\n        if self.zoom_to_impact_flag:\n            self.iface.zoomToActiveLayer()\n\n        qgis_exposure = (\n            QgsProject.instance().mapLayer(\n                self.parent.exposure_layer.id()))\n        if self.hide_exposure_flag and qgis_exposure is not None:\n            treeroot = QgsProject.instance().layerTreeRoot()\n            treelayer = treeroot.findLayer(qgis_exposure.id())\n            if treelayer:\n                treelayer.setItemVisibilityChecked(False)\n\n        # we only want to generate non pdf/qpt report\n        html_components = [standard_impact_report_metadata_html]\n        error_code, message = self.impact_function.generate_report(\n            html_components)\n        message = basestring_to_message(message)\n        if error_code == ImpactReport.REPORT_GENERATION_FAILED:\n            self.hide_busy()\n            LOGGER.info(tr(\n                'The impact report could not be generated.'))\n            send_error_message(self, message)\n            LOGGER.exception(message.to_text())\n            return ANALYSIS_FAILED_BAD_CODE, message\n\n        self.extent.set_last_analysis_extent(\n            self.impact_function.analysis_extent,\n            qgis_exposure.crs())\n\n        # Hide busy\n        self.hide_busy()\n        # Setup gui if analysis is done\n        self.setup_gui_analysis_done()\n        return ANALYSIS_SUCCESS, None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets widgets on the Progress tab.", "response": "def set_widgets(self):\n        \"\"\"Set widgets on the Progress tab.\"\"\"\n        self.progress_bar.setValue(0)\n        self.results_webview.setHtml('')\n        self.pbnReportWeb.hide()\n        self.pbnReportPDF.hide()\n        self.pbnReportComposer.hide()\n        self.lblAnalysisStatus.setText(tr('Running analysis...'))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread the settings from QSettings.", "response": "def read_settings(self):\n        \"\"\"Set the IF state from QSettings.\"\"\"\n        extent = setting('user_extent', None, str)\n        if extent:\n            extent = QgsGeometry.fromWkt(extent)\n            if not extent.isGeosValid():\n                extent = None\n\n        crs = setting('user_extent_crs', None, str)\n        if crs:\n            crs = QgsCoordinateReferenceSystem(crs)\n            if not crs.isValid():\n                crs = None\n\n        mode = setting('analysis_extents_mode', HAZARD_EXPOSURE_VIEW)\n        if crs and extent and mode == HAZARD_EXPOSURE_BOUNDINGBOX:\n            self.extent.set_user_extent(extent, crs)\n\n        self.extent.show_rubber_bands = setting(\n            'showRubberBands', False, bool)\n\n        self.zoom_to_impact_flag = setting('setZoomToImpactFlag', True, bool)\n\n        # whether exposure layer should be hidden after model completes\n        self.hide_exposure_flag = setting('setHideExposureFlag', False, bool)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating analysis as a representation of current situation of IFCW.", "response": "def prepare_impact_function(self):\n        \"\"\"Create analysis as a representation of current situation of IFCW.\"\"\"\n\n        # Impact Functions\n        impact_function = ImpactFunction()\n        impact_function.callback = self.progress_callback\n\n        # Layers\n        impact_function.hazard = self.parent.hazard_layer\n        impact_function.exposure = self.parent.exposure_layer\n        aggregation = self.parent.aggregation_layer\n\n        if aggregation:\n            impact_function.aggregation = aggregation\n            impact_function.use_selected_features_only = (\n                setting('useSelectedFeaturesOnly', False, bool))\n        else:\n            # self.extent.crs is the map canvas CRS.\n            impact_function.crs = self.extent.crs\n            mode = setting('analysis_extents_mode')\n            if self.extent.user_extent:\n                # This like a hack to transform a geometry to a rectangle.\n                # self.extent.user_extent is a QgsGeometry.\n                # impact_function.requested_extent needs a QgsRectangle.\n                wkt = self.extent.user_extent.asWkt()\n                impact_function.requested_extent = wkt_to_rectangle(wkt)\n\n            elif mode == HAZARD_EXPOSURE_VIEW:\n                impact_function.requested_extent = (\n                    self.iface.mapCanvas().extent())\n\n            elif mode == EXPOSURE:\n                impact_function.use_exposure_view_only = True\n\n        # We don't have any checkbox in the wizard for the debug mode.\n        impact_function.debug_mode = False\n\n        return impact_function"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setup_gui_analysis_done(self):\n        self.progress_bar.hide()\n        self.lblAnalysisStatus.setText(tr('Analysis done.'))\n        self.pbnReportWeb.show()\n        self.pbnReportPDF.show()\n        # self.pbnReportComposer.show()  # Hide until it works again.\n        self.pbnReportPDF.clicked.connect(self.print_map)", "response": "Helper method to setup gui if analysis is done."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_busy(self):\n        self.progress_bar.show()\n        self.parent.pbnNext.setEnabled(False)\n        self.parent.pbnBack.setEnabled(False)\n        self.parent.pbnCancel.setEnabled(False)\n        self.parent.repaint()\n        enable_busy_cursor()\n        QgsApplication.processEvents()", "response": "Show the busy cursor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nunlock buttons A helper function to indicate processing is done.", "response": "def hide_busy(self):\n        \"\"\"Unlock buttons A helper function to indicate processing is done.\"\"\"\n        self.progress_bar.hide()\n        self.parent.pbnNext.setEnabled(True)\n        self.parent.pbnBack.setEnabled(True)\n        self.parent.pbnCancel.setEnabled(True)\n        self.parent.repaint()\n        disable_busy_cursor()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nopening impact report dialog used to tune report when printing.", "response": "def print_map(self):\n        \"\"\"Open impact report dialog used to tune report when printing.\"\"\"\n        # Check if selected layer is valid\n        impact_layer = self.parent.iface.activeLayer()\n        if impact_layer is None:\n            # noinspection PyCallByClass,PyTypeChecker\n            QtWidgets.QMessageBox.warning(\n                self,\n                'InaSAFE',\n                tr(\n                    'Please select a valid impact layer before trying to '\n                    'print.'))\n            return\n\n        # Get output path from datastore\n        # Fetch report for pdfs report\n        report_path = os.path.dirname(impact_layer.source())\n        output_paths = [\n            os.path.join(\n                report_path,\n                'output/impact-report-output.pdf'),\n            os.path.join(\n                report_path,\n                'output/inasafe-map-report-portrait.pdf'),\n            os.path.join(\n                report_path,\n                'output/inasafe-map-report-landscape.pdf'),\n        ]\n\n        # Make sure the file paths can wrap nicely:\n        wrapped_output_paths = [\n            path.replace(os.sep, '<wbr>' + os.sep) for path in\n            output_paths]\n\n        # create message to user\n        status = m.Message(\n            m.Heading(tr('Map Creator'), **INFO_STYLE),\n            m.Paragraph(tr(\n                'Your PDF was created....opening using the default PDF '\n                'viewer on your system. The generated pdfs were saved '\n                'as:')))\n\n        for path in wrapped_output_paths:\n            status.add(m.Paragraph(path))\n\n        send_static_message(self, status)\n\n        for path in output_paths:\n            # noinspection PyCallByClass,PyTypeChecker,PyTypeChecker\n            QtGui.QDesktopServices.openUrl(\n                QtCore.QUrl.fromLocalFile(path))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nswapping coordinates for pair of coordinates in a line.", "response": "def swap_pairs(line, starttag=position_tag):\n    \"\"\"Swap coordinate pairs\n\n    Inputs\n        line: gml line assumed to contain pairs of coordinates ordered as\n              latitude, longitude\n        starttag: tag marking the start of the coordinate pairs.\n    \"\"\"\n\n    endtag = starttag.replace('<', '</')\n\n    index = line.find(starttag)\n    if index < 0:\n        msg = 'Expected line starting with <gml:posList>, got %s' % line\n        raise Exception(msg)\n\n    # Reuse indentation and tag\n    k = index + len(starttag)\n    new_line = line[:k]\n    remaining_line = line[k:]\n\n    # Swap coordinates for the rest of the line\n    got_lat = False\n    got_lon = False\n    for field in remaining_line.split():\n\n        # Clean end-tag from last field if present\n        index = field.find(endtag)\n        if index > -1:\n            # We got e.g. 136.28396002600005</gml:posList>\n            x = float(field[:index])\n        else:\n            x = float(field)\n\n        # Assign latitude or longitude\n        if got_lat:\n            lon = x\n            got_lon = True\n        else:\n            lat = x\n            got_lat = True\n\n        # Swap and write back every time a pair has been found\n        # Ensure there are enough decimals for the required precision\n        if got_lat and got_lon:\n            new_line += ' %.9f %.9f' % (lon, lat)\n            got_lat = got_lon = False\n\n    # Close position list and return\n    new_line += endtag + '\\n'\n    return new_line"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef swap_coords(filename):\n\n    # Read from input file\n    fid = open(filename, 'r')\n    lines = fid.readlines()\n    fid.close()\n\n    # Open output file\n    basename, ext = os.path.splitext(filename)\n    fid = open(basename + '_converted' + ext, 'w')\n\n    # Report\n    N = len(lines)\n    print 'There are %i lines in %s' % (N, filename)\n\n    # Process\n    reading_positions = False\n    got_lat = False\n    got_lon = False\n    for k, line in enumerate(lines):\n        s = line.strip()\n        if s.startswith(position_tag):\n            # Swap lat and lon pairs in this line and write back\n            fid.write(swap_pairs(line))\n        elif s.startswith(lc_tag):\n            fid.write(swap_pairs(line, starttag=lc_tag))\n        elif s.startswith(uc_tag):\n            fid.write(swap_pairs(line, starttag=uc_tag))\n        else:\n            # Store back unchanged\n            fid.write(line)\n\n    fid.close()", "response": "Swap lat and lon in filename\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef aggregation_summary(aggregate_hazard, aggregation):\n    source_fields = aggregate_hazard.keywords['inasafe_fields']\n    target_fields = aggregation.keywords['inasafe_fields']\n\n    target_compulsory_fields = [\n        aggregation_id_field,\n        aggregation_name_field,\n    ]\n    check_inputs(target_compulsory_fields, target_fields)\n\n    # Missing exposure_count_field\n    source_compulsory_fields = [\n        aggregation_id_field,\n        aggregation_name_field,\n        hazard_id_field,\n        hazard_class_field,\n        affected_field,\n    ]\n    check_inputs(source_compulsory_fields, source_fields)\n\n    pattern = exposure_count_field['key']\n    pattern = pattern.replace('%s', '')\n    unique_exposure = read_dynamic_inasafe_field(\n        source_fields, exposure_count_field)\n\n    absolute_values = create_absolute_values_structure(\n        aggregate_hazard, ['aggregation_id'])\n\n    flat_table = FlatTable('aggregation_id', 'exposure_class')\n\n    aggregation_index = source_fields[aggregation_id_field['key']]\n\n    # We want to loop over affected features only.\n    request = QgsFeatureRequest()\n    request.setFlags(QgsFeatureRequest.NoGeometry)\n    expression = '\\\"%s\\\" = \\'%s\\'' % (\n        affected_field['field_name'], tr('True'))\n    request.setFilterExpression(expression)\n    for area in aggregate_hazard.getFeatures(request):\n\n        for key, name_field in list(source_fields.items()):\n            if key.endswith(pattern):\n                aggregation_id = area[aggregation_index]\n                exposure_class = key.replace(pattern, '')\n                value = area[name_field]\n                flat_table.add_value(\n                    value,\n                    aggregation_id=aggregation_id,\n                    exposure_class=exposure_class\n                )\n\n        # We summarize every absolute values.\n        for field, field_definition in list(absolute_values.items()):\n            value = area[field]\n            if (value is None or value == ''\n                    or (hasattr(value, 'isNull')\n                        and value.isNull())):\n                value = 0\n            field_definition[0].add_value(\n                value,\n                aggregation_id=area[aggregation_index],\n            )\n\n    shift = aggregation.fields().count()\n\n    aggregation.startEditing()\n    dynamic_structure = [\n        [affected_exposure_count_field, unique_exposure],\n    ]\n    add_fields(\n        aggregation,\n        absolute_values,\n        [total_affected_field],\n        dynamic_structure)\n\n    aggregation_index = target_fields[aggregation_id_field['key']]\n\n    request = QgsFeatureRequest()\n    request.setFlags(QgsFeatureRequest.NoGeometry)\n    for area in aggregation.getFeatures(request):\n        aggregation_value = area[aggregation_index]\n        total = 0\n        for i, val in enumerate(unique_exposure):\n            sum = flat_table.get_value(\n                aggregation_id=aggregation_value,\n                exposure_class=val\n            )\n            total += sum\n            aggregation.changeAttributeValue(area.id(), shift + i, sum)\n\n        aggregation.changeAttributeValue(\n            area.id(), shift + len(unique_exposure), total)\n\n        for i, field in enumerate(absolute_values.values()):\n            value = field[0].get_value(\n                aggregation_id=aggregation_value,\n            )\n            target_index = shift + len(unique_exposure) + 1 + i\n            aggregation.changeAttributeValue(\n                area.id(), target_index, value)\n\n    aggregation.commitChanges()\n\n    aggregation.keywords['title'] = layer_purpose_aggregation_summary['name']\n    if qgis_version() >= 21800:\n        aggregation.setName(aggregation.keywords['title'])\n    else:\n        aggregation.setLayerName(aggregation.keywords['title'])\n    aggregation.keywords['layer_purpose'] = (\n        layer_purpose_aggregation_summary['key'])\n    aggregation.keywords['exposure_keywords'] = (\n        aggregate_hazard.keywords['exposure_keywords'].copy())\n\n    check_layer(aggregation)\n    return aggregation", "response": "Compute the summary from the aggregation hazard to the analysis layer."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_next_step(self):\n        layer_mode = self.parent.step_kw_layermode.selected_layermode()\n        if layer_mode == layer_mode_classified:\n            new_step = self.parent.step_kw_classify\n        elif layer_mode == layer_mode_continuous:\n            new_step = self.parent.step_kw_threshold\n        else:\n            message = tr('Layer mode should be continuous or classified')\n            raise InvalidWizardStep(message)\n        return new_step", "response": "Find the proper step when user clicks the Next button."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of valid classifications for a layer.", "response": "def classifications_for_layer(self):\n        \"\"\"Return a list of valid classifications for a layer.\n\n        :returns: A list where each value represents a valid classification.\n        :rtype: list\n        \"\"\"\n        subcategory_key = self.parent.step_kw_subcategory.\\\n            selected_subcategory()['key']\n        layer_purpose = self.parent.step_kw_purpose.selected_purpose()\n        if layer_purpose in [layer_purpose_hazard, layer_purpose_exposure]:\n            classifications = []\n            selected_unit = self.parent.step_kw_unit.selected_unit()\n            for classification in get_classifications(subcategory_key):\n                if selected_unit is None:\n                    # we are using classified data, so let's allow all\n                    # classifications\n                    classifications.append(classification)\n                elif 'multiple_units' not in classification:\n                    # this classification is not multiple unit aware, so let's\n                    # allow it\n                    classifications.append(classification)\n                elif selected_unit in classification['multiple_units']:\n                    # we are using continuous data, and this classification\n                    # supports the chosen unit so we allow it\n                    classifications.append(classification)\n            return classifications\n        else:\n            # There are no classifications for non exposure and hazard\n            # defined yet\n            return []"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef on_lstClassifications_itemSelectionChanged(self):\n        self.clear_further_steps()\n        classification = self.selected_classification()\n        # Exit if no selection\n        if not classification:\n            return\n        # Set description label\n        self.lblDescribeClassification.setText(classification[\"description\"])\n        # Enable the next button\n        self.parent.pbnNext.setEnabled(True)", "response": "Update classification description label and unlock the Next button."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef selected_classification(self):\n        item = self.lstClassifications.currentItem()\n        try:\n            return definition(item.data(QtCore.Qt.UserRole))\n        except (AttributeError, NameError):\n            return None", "response": "Obtain the metadata of the selected classification."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_widgets(self):\n        self.clear_further_steps()\n        purpose = self.parent.step_kw_purpose.selected_purpose()['name']\n        subcategory = self.parent.step_kw_subcategory.\\\n            selected_subcategory()['name']\n        self.lstClassifications.clear()\n        self.lblDescribeClassification.setText('')\n        self.lblSelectClassification.setText(\n            classification_question % (subcategory, purpose))\n        classifications = self.classifications_for_layer()\n        for classification in classifications:\n            if not isinstance(classification, dict):\n                classification = definition(classification)\n            item = QListWidgetItem(\n                classification['name'],\n                self.lstClassifications)\n            item.setData(QtCore.Qt.UserRole, classification['key'])\n            self.lstClassifications.addItem(item)\n\n        # Set values based on existing keywords (if already assigned)\n        classification_keyword = self.parent.get_existing_keyword(\n            'classification')\n        if classification_keyword:\n            classifications = []\n            for index in range(self.lstClassifications.count()):\n                item = self.lstClassifications.item(index)\n                classifications.append(item.data(QtCore.Qt.UserRole))\n            if classification_keyword in classifications:\n                self.lstClassifications.setCurrentRow(\n                    classifications.index(classification_keyword))\n\n        self.auto_select_one_item(self.lstClassifications)", "response": "Set widgets on the Classification tab."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of sibling files available.", "response": "def siblings_files(path):\n    \"\"\"Return a list of sibling files available.\"\"\"\n    file_basename, extension = splitext(path)\n    main_extension = extension.lower()\n    files = {}\n    if extension.lower() in list(extension_siblings.keys()):\n        for text_extension in list(extension_siblings[main_extension].keys()):\n            if isfile(file_basename + text_extension):\n                files[file_basename + text_extension] = (\n                    extension_siblings[main_extension][text_extension])\n\n    if len(files) > 0:\n        mime_base_file = extension_siblings[main_extension][main_extension]\n    else:\n        mime_base_file = None\n    return files, mime_base_file"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef login_user(server, login, password):\n    login_url = urljoin(server, login_url_prefix)\n\n    # Start the web session\n    session = requests.session()\n    result = session.get(login_url)\n\n    # Check if the request ok\n    if not result.ok:\n        message = (tr(\n            'Request failed to {geonode_url}, got status code {status_code} '\n            'and reason {request_reason}').format(\n                geonode_url=server,\n                status_code=result.status_code,\n                request_reason=result.reason))\n        raise GeoNodeInstanceError(message)\n\n    # Take the CSRF token\n    login_form_regexp = (\n        \"<input type='hidden' name='csrfmiddlewaretoken' value='(.*)' />\")\n    expression_compiled = re.compile(login_form_regexp)\n    match = expression_compiled.search(result.text)\n    csrf_token = match.groups()[0]\n\n    payload = {\n        'username': login,\n        'password': password,\n        'csrfmiddlewaretoken': csrf_token,\n    }\n\n    # Make the login\n    result = session.post(login_url, data=payload, headers=dict(\n        referer=login_url))\n\n    # Check the result url to check if the login success\n    if result.url == login_url:\n        message = tr('Failed to login to GeoNode at {geonode_url}').format(\n            geonode_url=server)\n        raise GeoNodeLoginError(message)\n\n    return session", "response": "Get the login session."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef upload(server, session, base_file, charset='UTF-8'):\n    file_ext = os.path.splitext(base_file)[1]\n    is_geojson = file_ext in ['.geojson', '.json']\n    original_sibling_files, _ = siblings_files(base_file)\n    if is_geojson:\n        # base_file = os.path.splitext(base_file)[0]\n        # create temp shapefile\n        convert_geojson_to_shapefile(base_file)\n        base_file = os.path.splitext(base_file)[0] + '.shp'\n\n    upload_url = urljoin(server, upload_url_prefix)\n    result = session.get(upload_url)\n\n    # Get the upload CSRF token\n    expression = re.compile('csrf_token(\\s*)=(\\s*)\"([a-zA-Z0-9]*?)\",')\n    match = expression.search(result.text)\n    csrf_token = match.groups()[2]\n\n    # Start the data dict\n    payload = {\n        'charset': charset,\n        'permissions': (\n            '{\"users\":{\"AnonymousUser\":'\n            '[\"view_resourcebase\",\"download_resourcebase\"]},\"groups\":{}}'\n        )\n    }\n\n    headers = dict()\n    headers['referer'] = upload_url\n    headers['X-CSRFToken'] = csrf_token\n\n    files, mime = siblings_files(base_file)\n    if len(files) < 1:\n        raise RuntimeError(tr('The base layer is not recognised.'))\n\n    name_file = split(base_file)[1]\n    multiple_files = [\n        ('base_file', (name_file, open(base_file, 'rb'), mime)),\n    ]\n    for sibling, mime in list(files.items()):\n        if sibling != base_file:\n            name_param = splitext(sibling)[1][1:]\n            name_file = split(sibling)[1]\n            open_file = (name_file, open(sibling, 'rb'), mime)\n            definition = ('{}_file'.format(name_param), open_file)\n            multiple_files.append(definition)\n\n    # For debug\n    upload_request = requests.Request(\n        'POST',\n        upload_url,\n        data=payload,\n        files=multiple_files,\n        headers=headers)\n\n    prepared_request = session.prepare_request(upload_request)\n    # For debug\n    # pretty_print_post(prepared_request)\n    result = session.send(prepared_request)\n\n    # Clean up shapefile and its sibling friends\n    if is_geojson:\n        for filename in files.keys():\n            if filename not in original_sibling_files:\n                try:\n                    os.remove(filename)\n                except OSError:\n                    pass\n\n    if result.ok:\n        result = json.loads(result.content)\n        full_url = server + result['url']\n        result['full_url'] = full_url\n        return result\n    else:\n        message = (tr(\n            'Failed to upload layer. Got HTTP Status Code {status_code} and '\n            'the reason is {reason}').format(\n                status_code=result.status_code, reason=result.reason))\n        raise GeoNodeLayerUploadError(message)", "response": "Push a layer to a Geonode instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_logging_handler_once(logger, handler):\n    class_name = handler.__class__.__name__\n    for logger_handler in logger.handlers:\n        if logger_handler.__class__.__name__ == class_name:\n            return False\n\n    logger.addHandler(handler)\n    return True", "response": "A helper to add a logging handler to a logger."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nruns once when the module is loaded and enable logging. :param logger_name: The logger name that we want to set up. :type logger_name: str :param log_file: Optional full path to a file to write logs to. :type log_file: str :param sentry_url: Optional url to sentry api for remote logging. Defaults to URL defined in safe.definitions.sentry.py which is the sentry project for InaSAFE desktop. :type sentry_url: str Borrowed heavily from this: http://docs.python.org/howto/logging-cookbook.html Now to log a message do:: LOGGER.debug('Some debug message') .. note:: The file logs are written to the inasafe user tmp dir e.g.: /tmp/inasafe/23-08-2012/timlinux/logs/inasafe.log", "response": "def setup_logger(logger_name, log_file=None, sentry_url=None):\n    \"\"\"Run once when the module is loaded and enable logging.\n\n    :param logger_name: The logger name that we want to set up.\n    :type logger_name: str\n\n    :param log_file: Optional full path to a file to write logs to.\n    :type log_file: str\n\n    :param sentry_url: Optional url to sentry api for remote\n        logging. Defaults to URL defined in safe.definitions.sentry.py\n        which is the sentry project for InaSAFE desktop.\n    :type sentry_url: str\n\n    Borrowed heavily from this:\n    http://docs.python.org/howto/logging-cookbook.html\n\n    Now to log a message do::\n\n       LOGGER.debug('Some debug message')\n\n    .. note:: The file logs are written to the inasafe user tmp dir e.g.:\n       /tmp/inasafe/23-08-2012/timlinux/logs/inasafe.log\n    \"\"\"\n    logger = logging.getLogger(logger_name)\n    logging_level = int(os.environ.get('INASAFE_LOGGING_LEVEL', logging.DEBUG))\n    logger.setLevel(logging_level)\n    default_handler_level = logging_level\n\n    # create formatter that will be added to the handlers\n    formatter = logging.Formatter(\n        '%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n\n    # create syslog handler which logs even debug messages\n    # (ariel): Make this log to /var/log/safe.log instead of\n    #               /var/log/syslog\n    # (Tim) Ole and I discussed this - we prefer to log into the\n    # user's temporary working directory.\n    inasafe_log_path = log_file_path()\n    if log_file is None:\n        file_handler = logging.FileHandler(inasafe_log_path)\n    else:\n        file_handler = logging.FileHandler(log_file)\n    file_handler.setLevel(default_handler_level)\n    file_handler.setFormatter(formatter)\n    add_logging_handler_once(logger, file_handler)\n\n    if 'MUTE_LOGS' not in os.environ:\n        # create console handler with a higher log level\n        console_handler = logging.StreamHandler()\n        console_handler.setLevel(logging.INFO)\n        console_handler.setFormatter(formatter)\n        add_logging_handler_once(logger, console_handler)\n\n    # create a QGIS handler\n    qgis_handler = QgsLogHandler()\n    qgis_handler.setFormatter(formatter)\n    add_logging_handler_once(logger, qgis_handler)\n\n    # Sentry handler - this is optional hence the localised import\n    # If raven is available logging messages will be sent to\n    # http://sentry.kartoza.com\n    # We will log exceptions only there. You need to either:\n    #  * Set env var 'INASAFE_SENTRY=1' present (value can be anything)\n    # before this will be enabled or sentry is enabled in QSettings\n    qsettings_flag = QSettings().value('inasafe/useSentry', False, type=bool)\n    environment_flag = 'INASAFE_SENTRY' in os.environ\n\n    if environment_flag or qsettings_flag:\n        if sentry_url is None:\n            sentry_url = PRODUCTION_SERVER\n\n        tags = dict()\n        tags[provenance_gdal_version['provenance_key']] = gdal.__version__\n        tags[provenance_os['provenance_key']] = readable_os_version()\n        qgis_short_version = provenance_qgis_version['provenance_key']\n        qgis_full_version = qgis_short_version + '_full'\n        versions = [str(v) for v in qgis_version_detailed()]\n        tags[qgis_short_version] = '.'.join(versions[0:2])\n        tags[qgis_full_version] = '.'.join(versions[0:3])\n        tags[provenance_qt_version['provenance_key']] = QT_VERSION_STR\n\n        hostname = os.environ.get('HOSTNAME_SENTRY', socket.gethostname())\n\n        sentry_handler = SentryHandler(\n            dsn=sentry_url,\n            name=hostname,\n            release=get_version(),\n            tags=tags,\n        )\n        sentry_handler.setFormatter(formatter)\n        sentry_handler.setLevel(logging.ERROR)\n        if add_logging_handler_once(logger, sentry_handler):\n            logger.debug('Sentry logging enabled in safe')\n    else:\n        logger.debug('Sentry logging disabled in safe')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef emit(self, record):\n        try:\n            # Check logging.LogRecord properties for lots of other goodies\n            # like line number etc. you can get from the log message.\n            QgsMessageLog.logMessage(record.getMessage(), 'InaSAFE', 0)\n        except MemoryError:\n            message = tr(\n                'Due to memory limitations on this machine, InaSAFE can not '\n                'handle the full log')\n            print(message)\n            QgsMessageLog.logMessage(message, 'InaSAFE', 0)", "response": "Try to log the message to QGIS if available otherwise do nothing."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef initialize_processing():\n\n    need_initialize = False\n\n    needed_algorithms = [\n        'native:clip',\n        'gdal:cliprasterbyextent',\n        'native:union',\n        'native:intersection'\n    ]\n\n    if not QgsApplication.processingRegistry().algorithms():\n        need_initialize = True\n\n    if not need_initialize:\n        for needed_algorithm in needed_algorithms:\n            if not QgsApplication.processingRegistry().algorithmById(\n                    needed_algorithm):\n                need_initialize = True\n                break\n\n    if need_initialize:\n        QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms())\n        processing.Processing.initialize()", "response": "Initializes processing if it s not already done\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a default processing context for a Linked processing feedback object.", "response": "def create_processing_context(feedback):\n    \"\"\"\n    Creates a default processing context\n\n    :param feedback: Linked processing feedback object\n    :type feedback: QgsProcessingFeedback\n\n    :return: Processing context\n    :rtype: QgsProcessingContext\n    \"\"\"\n    context = QgsProcessingContext()\n    context.setFeedback(feedback)\n    context.setProject(QgsProject.instance())\n\n    # skip Processing geometry checks - Inasafe has its own geometry validation\n    # routines which have already been used\n    context.setInvalidGeometryCheck(QgsFeatureRequest.GeometryNoCheck)\n    return context"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_layer(self, layer, layer_name, save_style=False):\n        if self._use_index:\n            layer_name = '%s-%s' % (self._index, layer_name)\n            self._index += 1\n\n        if self.layer_uri(layer_name):\n            return False, tr('The layer already exists in the datastore.')\n\n        if isinstance(layer, QgsRasterLayer):\n            result = self._add_raster_layer(layer, layer_name, save_style)\n        else:\n            if layer.wkbType() == QgsWkbTypes.NoGeometry:\n                result = self._add_tabular_layer(layer, layer_name, save_style)\n            else:\n                result = self._add_vector_layer(layer, layer_name, save_style)\n\n        if result[0]:\n            LOGGER.info(\n                'Layer saved {layer_name}'.format(layer_name=result[1]))\n\n        try:\n            layer.keywords\n            real_layer = self.layer(result[1])\n            if isinstance(real_layer, bool):\n                message = ('{name} was not found in the datastore or the '\n                           'layer was not valid.'.format(name=result[1]))\n                LOGGER.debug(message)\n                return False, message\n            KeywordIO().write_keywords(real_layer, layer.keywords)\n        except AttributeError:\n            pass\n\n        return result", "response": "Add a layer to the datastore."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the QGIS layer with the given name.", "response": "def layer(self, layer_name):\n        \"\"\"Get QGIS layer.\n\n        :param layer_name: The name of the layer to fetch.\n        :type layer_name: str\n\n        :return: The QGIS layer.\n        :rtype: QgsMapLayer\n\n        .. versionadded:: 4.0\n        \"\"\"\n        uri = self.layer_uri(layer_name)\n        layer = QgsVectorLayer(uri, layer_name, 'ogr')\n        if not layer.isValid():\n            layer = QgsRasterLayer(uri, layer_name)\n            if not layer.isValid():\n                return False\n\n        monkey_patch_keywords(layer)\n\n        return layer"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a QGIS layer according to a keyword and its value.", "response": "def layer_keyword(self, keyword, value):\n        \"\"\"Get a layer according to a keyword and its value.\n\n        :param keyword: The keyword to check.\n        :type keyword: basestring\n\n        :param value: The value to check for the specific keyword.\n        :type value: basestring\n\n        :return: The QGIS layer.\n        :rtype: QgsMapLayer\n\n        .. versionadded:: 4.0\n        \"\"\"\n        for layer in sorted(self.layers(), reverse=True):\n            qgis_layer = self.layer(layer)\n            if qgis_layer.keywords.get(keyword) == value:\n                return qgis_layer\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets list of suitable layer purpose.", "response": "def purposes_for_layer(layer_geometry_key):\n    \"\"\"Get purposes of a layer geometry id.\n\n    :param layer_geometry_key: The geometry id\n    :type layer_geometry_key: str\n\n    :returns: List of suitable layer purpose.\n    :rtype: list\n    \"\"\"\n    return_value = []\n    for layer_purpose in layer_purposes:\n        layer_geometry_keys = [\n            i['key'] for i in layer_purpose['allowed_geometries']]\n        if layer_geometry_key in layer_geometry_keys:\n            return_value.append(layer_purpose['key'])\n\n    return sorted(return_value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hazards_for_layer(layer_geometry_key):\n    result = []\n    for hazard in hazard_all:\n        if layer_geometry_key in hazard.get('allowed_geometries'):\n            result.append(hazard)\n\n    return sorted(result, key=lambda k: k['key'])", "response": "Get hazard categories form layer_geometry_key."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets hazard categories form layer_geometry_key", "response": "def exposures_for_layer(layer_geometry_key):\n    \"\"\"Get hazard categories form layer_geometry_key\n\n    :param layer_geometry_key: The geometry key\n    :type layer_geometry_key: str\n\n    :returns: List of hazard\n    :rtype: list\n    \"\"\"\n    result = []\n    for exposure in exposure_all:\n        if layer_geometry_key in exposure.get('allowed_geometries'):\n            result.append(exposure)\n\n    return sorted(result, key=lambda k: k['key'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_layer_modes(subcategory):\n    layer_modes = definition(subcategory)['layer_modes']\n    return sorted(layer_modes, key=lambda k: k['key'])", "response": "Return all layer modes from exposure or hazard."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hazard_units(hazard):\n    units = definition(hazard)['continuous_hazard_units']\n    return sorted(units, key=lambda k: k['key'])", "response": "Helper to get unit of a hazard."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the list of hazard or exposure classifications.", "response": "def get_classifications(subcategory_key):\n    \"\"\"Get hazard or exposure classifications.\n\n    :param subcategory_key: The hazard or exposure key\n    :type subcategory_key: str\n\n    :returns: List of hazard or exposure classifications\n    :rtype: list\n    \"\"\"\n    classifications = definition(subcategory_key)['classifications']\n    return sorted(classifications, key=lambda k: k['key'])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_fields(\n        layer_purpose, layer_subcategory=None, replace_null=None,\n        in_group=True):\n    \"\"\"Get all field based on the layer purpose.\n\n    :param layer_purpose: The layer purpose.\n    :type layer_purpose: str\n\n    :param layer_subcategory: Exposure or hazard value.\n    :type layer_subcategory: str\n\n    :param replace_null: If None all fields are returned, if True only if\n        it's True, if False only if it's False.\n    :type replace_null: None or bool\n\n    :param in_group: Flag to include field in field_groups or not.\n    :type in_group: bool\n\n    :returns: List of fields.\n    :rtype: list\n    \"\"\"\n    fields_for_purpose = []\n    if layer_purpose == layer_purpose_exposure['key']:\n        if layer_subcategory:\n            subcategory = definition(layer_subcategory)\n            fields_for_purpose += subcategory['compulsory_fields']\n            fields_for_purpose += subcategory['fields']\n            fields_for_purpose += subcategory['extra_fields']\n        else:\n            fields_for_purpose = deepcopy(exposure_fields)\n    elif layer_purpose == layer_purpose_hazard['key']:\n        if layer_subcategory:\n            subcategory = definition(layer_subcategory)\n            fields_for_purpose += subcategory['compulsory_fields']\n            fields_for_purpose += subcategory['fields']\n            fields_for_purpose += subcategory['extra_fields']\n        else:\n            fields_for_purpose = deepcopy(hazard_fields)\n    elif layer_purpose == layer_purpose_aggregation['key']:\n        fields_for_purpose = deepcopy(aggregation_fields)\n    elif layer_purpose == layer_purpose_exposure_summary['key']:\n        fields_for_purpose = deepcopy(impact_fields)\n\n    if in_group:\n        field_groups = get_field_groups(layer_purpose, layer_subcategory)\n        fields_for_purpose += fields_in_field_groups(field_groups)\n\n    if isinstance(replace_null, bool):\n        fields_for_purpose = [\n            f for f in fields_for_purpose\n            if f.get('replace_null') == replace_null]\n        return fields_for_purpose\n    else:\n        return fields_for_purpose", "response": "Get all fields for the given layer purpose and subcategory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_compulsory_fields(layer_purpose, layer_subcategory=None):\n    if not layer_subcategory:\n        if layer_purpose == 'hazard':\n            return hazard_value_field\n        elif layer_purpose == 'exposure':\n            return exposure_type_field\n        elif layer_purpose == 'aggregation':\n            return aggregation_name_field\n        else:\n            return None\n    else:\n        return definition(layer_subcategory).get('compulsory_fields')[0]", "response": "Get compulsory field based on layer_purpose and layer_subcategory."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets non - compulsory fields based on layer_purpose and layer_subcategory.", "response": "def get_non_compulsory_fields(layer_purpose, layer_subcategory=None):\n    \"\"\"Get non compulsory field based on layer_purpose and layer_subcategory.\n\n    Used for get field in InaSAFE Fields step in wizard.\n\n    :param layer_purpose: The layer purpose.\n    :type layer_purpose: str\n\n    :param layer_subcategory: Exposure or hazard value.\n    :type layer_subcategory: str\n\n    :returns: Compulsory fields\n    :rtype: list\n    \"\"\"\n    all_fields = get_fields(\n        layer_purpose, layer_subcategory, replace_null=False)\n    compulsory_field = get_compulsory_fields(\n        layer_purpose, layer_subcategory)\n    if compulsory_field in all_fields:\n        all_fields.remove(compulsory_field)\n    return all_fields"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef definition(keyword, key=None):\n\n    for item in dir(definitions):\n        if not item.startswith(\"__\"):\n            var = getattr(definitions, item)\n            if isinstance(var, dict):\n                if var.get('key') == keyword or var.get(key) == keyword:\n                    return var\n    return None", "response": "Given a keyword and a key try to get a definition dict for it. If no match is found None is returned."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntrying to get the name of a keyword.", "response": "def get_name(key):\n    \"\"\"Given a keyword, try to get the name of it.\n\n    .. versionadded:: 4.2\n\n    Definition dicts are defined in keywords.py. We try to return\n    the name if present, otherwise we return none.\n\n    keyword = 'layer_purpose'\n    kio = safe.utilities.keyword_io.Keyword_IO()\n    name = kio.get_name(keyword)\n    print name\n\n    :param key: A keyword key.\n    :type key: str\n\n    :returns: The name of the keyword\n    :rtype: str\n    \"\"\"\n    definition_dict = definition(key)\n    if definition_dict:\n        return definition_dict.get('name', key)\n    # Else, return the keyword\n    return key"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_class_name(class_key, classification_key):\n    classification = definition(classification_key)\n    for the_class in classification['classes']:\n        if the_class.get('key') == class_key:\n            return the_class.get('name', class_key)\n    return class_key", "response": "Helper to get class name from a class_key of a classification."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_allowed_geometries(layer_purpose_key):\n    preferred_order = [\n        'point',\n        'line',\n        'polygon',\n        'raster'\n    ]\n    allowed_geometries = set()\n    all_layer_type = []\n    if layer_purpose_key == layer_purpose_hazard['key']:\n        all_layer_type = hazard_all\n    elif layer_purpose_key == layer_purpose_exposure['key']:\n        all_layer_type = exposure_all\n\n    for layer in all_layer_type:\n        for allowed_geometry in layer['allowed_geometries']:\n            allowed_geometries.add(allowed_geometry)\n\n    allowed_geometries = list(allowed_geometries)\n    allowed_geometries_definition = []\n    for allowed_geometry in allowed_geometries:\n        allowed_geometries_definition.append(definition(allowed_geometry))\n\n    # Adapted from http://stackoverflow.com/a/15650556/1198772\n    order_dict = {color: index for index, color in enumerate(preferred_order)}\n    allowed_geometries_definition.sort(key=lambda x: order_dict[x[\"key\"]])\n\n    return allowed_geometries_definition", "response": "Helper function to get all possible geometry in a node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef default_classification_thresholds(classification, unit=None):\n    thresholds = {}\n    for hazard_class in classification['classes']:\n        if isinstance(hazard_class['numeric_default_min'], dict):\n            min_value = hazard_class['numeric_default_min'][unit]\n        else:\n            min_value = hazard_class['numeric_default_min']\n        if isinstance(hazard_class['numeric_default_max'], dict):\n            max_value = hazard_class['numeric_default_max'][unit]\n        else:\n            max_value = hazard_class['numeric_default_max']\n        thresholds[hazard_class['key']] = [min_value, max_value]\n\n    return thresholds", "response": "Helper to get default thresholds from classification and unit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef default_classification_value_maps(classification):\n    value_maps = {}\n    for hazard_class in classification['classes']:\n        value_maps[hazard_class['key']] = hazard_class.get(\n            'string_defaults', [])\n\n    return value_maps", "response": "Helper to get default value maps from classification."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nobtain list of field groups from layer purpose and subcategory.", "response": "def get_field_groups(layer_purpose, layer_subcategory=None):\n    \"\"\"Obtain list of field groups from layer purpose and subcategory.\n\n    :param layer_purpose: The layer purpose.\n    :type layer_purpose: str\n\n    :param layer_subcategory: Exposure or hazard value.\n    :type layer_subcategory: str\n\n    :returns: List of layer groups.\n    :rtype: list\n    \"\"\"\n    layer_purpose_dict = definition(layer_purpose)\n    if not layer_purpose_dict:\n        return []\n    field_groups = deepcopy(layer_purpose_dict.get('field_groups', []))\n    if layer_purpose in [\n            layer_purpose_exposure['key'], layer_purpose_hazard['key']]:\n        if layer_subcategory:\n            subcategory = definition(layer_subcategory)\n            if 'field_groups' in subcategory:\n                field_groups += deepcopy(subcategory['field_groups'])\n    return field_groups"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\noverrides a default component with a new component with given template.", "response": "def override_component_template(component, template_path):\n    \"\"\"Override a default component with a new component with given template.\n\n    :param component: Component as dictionary.\n    :type component: dict\n\n    :param template_path: Custom template path that will be used.\n    :type template_path: str\n\n    :returns: New report component.\n    :rtype: dict\n    \"\"\"\n    copy_component = deepcopy(component)\n    template_directory, template_filename = split(template_path)\n    file_name, file_format = splitext(template_filename)\n    if file_format[1:] != (\n            QgisComposerComponentsMetadata.OutputFormat.QPT) or (\n                not exists(template_path)):\n        return copy_component\n\n    # we do the import here to avoid circular import when starting\n    # up the plugin\n    from safe.definitions.reports.components import (\n        map_report_component_boilerplate)\n    custom_template_component = deepcopy(\n        map_report_component_boilerplate)\n\n    # we need to update several items in this component\n    pdf_output_file = '{file_name}.pdf'.format(file_name=file_name)\n    qpt_output_file = '{file_name}.qpt'.format(file_name=file_name)\n\n    custom_template_component['key'] = file_name\n    custom_template_component['template'] = template_path\n    custom_template_component['output_path']['template'] = qpt_output_file\n    custom_template_component['output_path']['map'] = pdf_output_file\n\n    # we need to update the orientation of the custom template\n    with open(custom_template_component['template']) as (\n            template_file):\n        template_content = template_file.read()\n    document = QDomDocument()\n    document.setContent(template_content)\n    root_element = document.namedItem('Composer')\n    composition_element = root_element.namedItem('Composition')\n    all_orientations = [\n        landscape_map_report_description,\n        portrait_map_report_description\n    ]\n    orientation = None\n    if isinstance(root_element, QDomNode):\n        paper_width = composition_element.attributes().namedItem(\n            'paperWidth').nodeValue()\n        paper_height = composition_element.attributes().namedItem(\n            'paperHeight').nodeValue()\n        for _orientation in all_orientations:\n            if _orientation['width'] == int(paper_width) and (\n                    _orientation['height'] == int(paper_height)):\n                orientation = _orientation['orientation']\n                break\n\n    # By default, the component is landscape oriented, So if we found that\n    # the custom template is portrait, we need to delete the information about\n    # orientation in the component because in the report metadata, if there is\n    # no specification about the orientation, then they will set it\n    # to portrait.\n    if orientation == portrait_map_report_description['orientation']:\n        custom_template_component['orientation'] = orientation\n        del custom_template_component['page_width']\n        del custom_template_component['page_height']\n\n    copy_component['components'] = [custom_template_component]\n\n    return copy_component"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_template_component(\n        component, custom_template_dir=None, hazard=None, exposure=None):\n    \"\"\"Get a component based on custom qpt if exists\n\n    :param component: Component as dictionary.\n    :type component: dict\n\n    :param custom_template_dir: The directory where the custom template stored.\n    :type custom_template_dir: basestring\n\n    :param hazard: The hazard definition.\n    :type hazard: dict\n\n    :param exposure: The exposure definition.\n    :type exposure: dict\n\n    :returns: Map report component.\n    :rtype: dict\n    \"\"\"\n    copy_component = deepcopy(component)\n\n    # get the default template component from the original map report component\n    default_component_keys = []\n    for component in copy_component['components']:\n        default_component_keys.append(component['key'])\n\n    if not custom_template_dir:\n        # noinspection PyArgumentList\n        custom_template_dir = join(\n            QgsApplication.qgisSettingsDirPath(), 'inasafe')\n\n    for component in copy_component['components']:\n        if not component.get('template'):\n            continue\n\n        template_format = splitext(component['template'])[-1][1:]\n        if template_format != QgisComposerComponentsMetadata.OutputFormat.QPT:\n            continue\n\n        qpt_file_name = component['template'].split('/')[-1]\n        custom_qpt_path = join(custom_template_dir, qpt_file_name)\n        if exists(custom_qpt_path):\n            component['template'] = custom_qpt_path\n\n    # we want to check if there is hazard-exposure specific template available\n    # in user's custom template directory\n    if exists(custom_template_dir) and hazard and exposure:\n        for filename in listdir(custom_template_dir):\n\n            file_name, file_format = splitext(filename)\n            if file_format[1:] != (\n                    QgisComposerComponentsMetadata.OutputFormat.QPT):\n                continue\n            if hazard['key'] in file_name and exposure['key'] in file_name:\n                # we do the import here to avoid circular import when starting\n                # up the plugin\n                from safe.definitions.reports.components import (\n                    map_report_component_boilerplate)\n                hazard_exposure_component = deepcopy(\n                    map_report_component_boilerplate)\n\n                # we need to update several items in this component\n                pdf_output_file = '{file_name}.pdf'.format(file_name=file_name)\n                qpt_output_file = '{file_name}.qpt'.format(file_name=file_name)\n\n                hazard_exposure_component['key'] = file_name\n                hazard_exposure_component['template'] = join(\n                    custom_template_dir, filename)\n                hazard_exposure_component['output_path']['template'] = (\n                    qpt_output_file)\n                hazard_exposure_component['output_path']['map'] = (\n                    pdf_output_file)\n\n                # add this hazard-exposure component to the returned component\n                copy_component['components'].append(hazard_exposure_component)\n\n                # remove the original template component because we want to\n                # override it using this new hazard-exposure template component\n                new_component = [\n                    component for component in copy_component['components']\n                    if component['key'] not in default_component_keys\n                ]\n                copy_component['components'] = new_component\n\n    return copy_component", "response": "Update the component based on custom qpt"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_default_profile():\n    data_format = {}\n    for hazard in hazard_all:\n        if exposure_population in hazard['disabled_exposures']:\n            continue\n        data_format[hazard['key']] = {}\n        for classification in hazard['classifications']:\n            data_format[hazard['key']][classification['key']] = OrderedDict()\n            for the_class in classification['classes']:\n                entry = {\n                    'affected': the_class['affected'],\n                    'displacement_rate': the_class['displacement_rate'],\n                }\n                data_format[hazard['key']][classification['key']][the_class[\n                    'key']] = entry\n\n    return data_format", "response": "Helper function to create a dictionary of default profile data."}
